Cplus_plus runs on a variety of platforms, such as Windows, Mac OS, and the various versions of UNIX.
This tutorial adopts a simple and practical approach to describe the concepts of Cplus_plus.
Audience This tutorial has been prepared for the beginners to help them understand the basic to advanced concepts related to Cplus_plus.
Prerequisites Before you start practicing with various types of examples given in this tutorial,we are making an assumption that you are already aware of the basics of computer program and  computer programming language.
Copyright & Disclaimer  Copyright 2014 by Tutorials Point (I) Pvt.
All the content and graphics published in this e-book are the property of Tutorials Point (I) Pvt.
The user of this e-book is prohibited to reuse, retain, copy, distribute or republish any contents or a part of contents of this e-book in any manner without written consent of the publisher.
We strive to update the contents of our website and tutorials as timely and as precisely as possible, however, the contents may contain inaccuracies or errors.
Tutorials Point (I) Pvt.
If you discover any errors on our website or in this tutorial, please notify us at contact@tutorialspoint_0_com Table of Contents About the Tutorial _0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0_.
ENVIORNMENT SETUP _0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0_.
BASIC SYNTAX _0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0_.
DATA TYPES _0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0_.
VARIABLE TYPES _0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0_.
VARIABLE SCOPE _0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0_.
MODIFIER TYPES _0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0_.
STORAGE CLASSES _0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0_.
LOOP TYPES _0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0_.
DECISION-MAKING STATEMENTS _0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0_.
DATE AND TIME _0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0_.
BASIC INPUT/OUTPUT _0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0_.
DATA STRUCTURES _0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0_.
CLASSES AND OBJECTS _0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0_.
OVERLOADING (OPERATOR & FUNCTION) _0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0_.
DATA ABSTRACTION _0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0_.
DATA ENCAPSULATION _0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0_.
FILES AND STREAMS _0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0_.
EXCEPTION HANDLING _0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0_.
DYNAMIC MEMORY _0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0_.
SIGNAL HANDLING _0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0_.
WEB PROGRAMMING _0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0_.
STL TUTORIAL _0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0_.
STANDARD LIBRARY _0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0_.
Cplus_plus is regarded as a middle-level language, as it comprises a combination of both high-level  low-level language features.
Cplus_plus was developed by Bjarne Stroustrup starting in 1979 at Bell Labs in Murray Hill, New Jersey, as an enhancement to the C language  originally named C with Classes but later it was renamed Cplus_plus in 1983.
Cplus_plus is a superset of C,  that virtually any legal C program is a legal Cplus_plus program.
Note: A programming language is said to use static typing when type checking is performed during compile-time as opposed to run-time.
Object-Oriented Programming Cplus_plus fully supports object-oriented programming, including the four pillars of object-oriented development:  Encapsulation  Data hiding  Inheritance  Polymorphism Standard Libraries Standard Cplus_plus consists of three important parts:  The core language giving all the building blocks including variables, data types  literals, etc.
The ANSI Standard The ANSI standard is an attempt to ensure that Cplus_plus is portable; that code you write for Microsoft's compiler will compile without errors, using a compiler on a Mac, UNIX, a Windows box, or an Alpha.
OVERVIEW Cplus_plus 2 The ANSI standard has been stable for a while, and all the major Cplus_plus compiler manufacturers support the ANSI standard.
Learning Cplus_plus The most important thing while learning Cplus_plus is to focus on concepts.
The purpose of learning a programming language is to become a better programmer; that is, to become more effective at designing and implementing new  and at maintaining old ones.
Cplus_plus supports a variety of programming styles.
You can write in the style of Fortran, C, Smalltalk, etc_0_, in any language.
Each style can achieve its aims effectively while maintaining runtime and space efficiency.
Use of Cplus_plus Cplus_plus is used by hundreds of thousands of programmers in essentially every application domain.
Cplus_plus is being highly used to write device drivers and other software that rely on direct manipulation of hardware under real-time constraints.
Cplus_plus is widely used for teaching and research because it is clean enough for successful teaching of basic concepts.
Anyone who has used either an Apple Macintosh or a PC running Windows has indirectly used Cplus_plus because the primary user interfaces of these  are written in Cplus_plus.
Cplus_plus 3 Try it Option Online You really do not need to set up your own environment to start learning Cplus_plus programming language.
Reason is very simple, we have already set up Cplus_plus Programming environment online, so that you can compile and execute all the available examples online at the same time when you are doing your theory work.
This gives you confidence in what you are reading and to check the result with different options.
Feel free to modify any example and execute it online.
Try the following example using our online compiler option available at http://www_0_compileonline_0_com/.
So just make use of it and enjoy your learning.
Local Environment Setup If you are still willing to set up your environment for Cplus_plus, you need to have the following two softwares on your computer.
Text Editor: This will be used to type your program.
Examples of few editors  Windows Notepad, OS Edit command, Brief, Epsilon, EMACS, and vim or vi.
Name and version of text editor can vary on different operating.
For example, Notepad will be used on Windows and vim or vi can be used on windows as well as Linux, or UNIX.
The files you create with your editor are called source files and for Cplus_plus they typically are named with the extension _0_cpp, _0_cp, or _0_c.
A text editor should be in place to start your Cplus_plus programming.
ENVIORNMENT SETUP Cplus_plus 4 Cplus_plus Compiler: This is an actual Cplus_plus compiler, which will be used to compile your source code into final executable program.
Most Cplus_plus compilers don't care what extension you give to your source code, but if you don't specify otherwise, many will use _0_cpp by default.
Most frequently used and free available compiler is GNU C/Cplus_plus compiler, otherwise you can have compilers either from HP or Solaris if you have the respective Operating Systems.
Installing GNU C/Cplus_plus Compiler: UNIX/Linux Installation: If you are using Linux or UNIX then check whether GCC is installed on your system by entering the following command from the command line: $ gplus_plus -v If you have installed GCC, then it should print a message such as the following: Using built-in specs.
Target: i386-redhat-linux Configured with: _0__0_/configure =/usr _0__0__0__0__0__0_.
Thread model: posix gcc version 4_0_1_0_2 20080704 (Red Hat 4_0_1_0_2-46) If GCC is not installed, then you will have to install it yourself using the detailed instructions available at http://gcc_0_gnu_0_org/install/.
Mac OS X Installation: If you use Mac OS X, the easiest way to obtain GCC is to download the Xcode development environment from Apple's website and follow the simple installation instructions.
Xcode is currently available at developer_0_apple_0_com/technologies/tools/.
Windows Installation: To install GCC at Windows you need to install MinGW.
To install MinGW, go to the MinGW homepage, www_0_mingw_0_org, and follow the link to the MinGW download page.
Download the latest version of the MinGW installation program which should be named MinGW-<version>_0_exe.
While installing MinGW, at a minimum, you must install gcc-core, gcc-gplus_plus, binutils, and the MinGW runtime, but you may wish to install more.
Cplus_plus 5 Add the bin subdirectory of your MinGW installation to your PATH environment variable so that you can specify these tools on the command line by their simple names.
When the installation is complete, you will be able to run gcc, gplus_plus, ar, ranlib, dlltool, and several other GNU tools from the Windows command line.
Cplus_plus 6 When we consider a Cplus_plus program, it can be defined as a collection of objects that communicate via invoking each other's methods.
Let us now briefly look into what a class, object, methods, and instant variables mean.
Example:  dog has states color, name, breed as well as behaviors - wagging, barking, and eating.
An object is an instance of a class.
It is in methods where the logics are written, data is manipulated and all the actions are executed.
An object's state is created by the values assigned to these instant variables.
Cplus_plus Program Structure: Let us look at a simple code that would print the words Hello World.
The Cplus_plus language defines several headers, which contain information that is either necessary or useful to your program.
For this program, the header <iostream> is needed.
The line using namespace std; tells the compiler to use the std namespace.
Namespaces are a relatively recent addition to Cplus_plus.
BASIC SYNTAX Cplus_plus 7 3.
The next line '// main() is where program execution begins_0_' is a single-line comment available in Cplus_plus.
Single-line comments begin with // and stop at the end of the line.
The line int main() is the main function where program execution begins.
The next line  << "This is my first Cplus_plus program_0_"; causes the message "This is my first Cplus_plus program" to be displayed on the screen.
The next line return 0; terminates main() function and causes it to return the value 0 to the calling process.
Compile & Execute Cplus_plus Program: Let's look at how to save the file, compile and run the program.
Please follow the steps given below: 1.
Open a text editor and add the code as above.
Open a command prompt and go to the directory where you saved the file.
Type 'gplus_plus hello_0_cpp' and press enter to compile your code.
If there are no errors in your code the command prompt will take you to the next line and would generate a_0_out executable file.
Now, type 'a_0_out' to run your program.
You will be able to see ' Hello World ' printed on the window.
You can compile C/Cplus_plus programs using makefile.
For more details, you can check our 'Makefile Tutorial'.
Semicolons & Blocks in Cplus_plus In Cplus_plus, the semicolon is a statement terminator.
That is, each individual statement must be ended with a semicolon.
It indicates the end of one logical entity.
For example, following are three different statements: = ; = +1; Cplus_plus 8 add(, ); block is a set of logically connected statements that are surrounded by opening and closing braces.
For this reason, it does not matter where you put a statement in a line.
For example: = ; = +1; add(, ); is the same as = ;  = +1; add(, ); Cplus_plus Identifiers Cplus_plus identifier is a name used to identify a variable, function, class, module, or any other user-defined item.
An identifier starts with a letter  to Z or a to z or an underscore (_) followed by zero or more letters, underscores, and digits (0 to 9).
Cplus_plus does not allow punctuation characters such as @, $, and % within identifiers.
Cplus_plus is a case-sensitive programming language.
Thus, Manpower and manpower are two different identifiers in Cplus_plus.
Here are some examples of acceptable identifiers: mohd       zara    abc   move_name  a_123 myname50   _temp   j     a23b9      retVal Cplus_plus Keywords The following list shows the reserved words in Cplus_plus.
These reserved words may not be used as constant or variable or any other identifier names.
A trigraph is a three-character sequence that represents a single character and the sequence always starts with two question marks.
Trigraphs are expanded anywhere they appear, including within string literals and character literals, in comments, and in preprocessor directives.
Following are most frequently used trigraph sequences: Trigraph Replacement Cplus_plus 10 _0__0_= # _0__0_/ \ _0__0_' ^ _0__0_( [ _0__0_) ] _0__0_.
Whitespace in Cplus_plus A line containing only whitespace, possibly with a comment, is known as a blank line, and Cplus_plus compiler totally ignores it.
Whitespace is the term used in Cplus_plus to describe blanks, tabs, newline characters comments.
Whitespace separates one part of a statement from another enables the compiler to identify where one element in a statement, such as int, ends  the next element begins.
Statement 1: int age; In the above statement there must be at least one whitespace character (usually a space)  int  age for the compiler to be able to distinguish them.
Statement 2: = apples + oranges;   // Get the total In the above statement 2, no whitespace characters are necessary =, or  =  apples, although you are free to include some if you wish for readability purpose.
Cplus_plus 11 Program comments are explanatory statements that you can include in the Cplus_plus code.
These comments help anyone reading the source code.
All programming languages allow for some form of comments.
Cplus_plus supports single-line  multi-line comments.
All characters available inside any comment are ignored by Cplus_plus compiler.
Cplus_plus comments start with /*  end with */.
For example: /* This is a comment */ /* Cplus_plus comments can also * span multiple lines */ A comment can also start with //, extending to the end of the line.
For example: # <iostream>.
Within a // comment, /*  */ have no special meaning.
Thus, you can "nest" one kind of comment within the other kind.
For example: /* Comment out printing of Hello World: 4.
COMMENTS IN Cplus_plus Cplus_plus 12 << "Hello World"; // prints Hello World */ Cplus_plus 13 While writing program in any language, you need to use various variables to store various information.
Variables are nothing but reserved memory locations to store values.
This means that when you create a variable you reserve some space in memory.
You may like to store information of various data types like character, wide character, integer, floating point, double floating point, boolean etc.
Based on the data type of a variable, the operating system allocates memory  decides what can be stored in the reserved memory.
Primitive Built-in Types Cplus_plus offers the programmer a rich assortment of built-in as well as user defined data types.
Following table lists down seven basic Cplus_plus data types: Type Keyword Boolean bool Character char Integer int Floating point float Double floating point double Valueless void Wide character wchar_t Several of the basic types can be modified using one or more of these type modifiers:  signed  unsigned  short  long 5.
DATA TYPES Cplus_plus 14 The following table shows the variable type, how much memory it takes to store the value in memory,  what is maximum  minimum value which can be stored in such type of variables.
Type Typical Bit Width Typical Range char 1byte -127 to 127 or 0 to 255 unsigned char 1byte 0 to 255 signed char 1byte -127 to 127 int 4bytes -2147483648 to 2147483647 unsigned int 4bytes 0 to 4294967295 signed int 4bytes -2147483648 to 2147483647 short int 2bytes -32768 to 32767 unsigned short int Range 0 to 65,535 signed short int Range -32768 to 32767 long int 4bytes -2,147,483,647 to 2,147,483,647 signed long int 4bytes same as long int unsigned long int 4bytes 0 to 4,294,967,295 float 4bytes +/- 3_0_4e +/- 38 (~7 digits) double 8bytes +/- 1_0_7e +/- 308 (~15 digits) long double 8bytes +/- 1_0_7e +/- 308 (~15 digits) wchar_t 2 or 4 bytes 1 wide character The size of variables might be different from those shown in the above table, depending on the compiler and the computer you are using.
Cplus_plus 15 Following is the example, which will produce correct size of various data types on your computer.
We are also using sizeof() function to get size of various data types.
When the above code is compiled and executed, it produces the following result which can vary from machine to machine: Size of  : 1 Size of  : 4 Size of short  : 2 Size of long  : 4 Size of  : 4 Size of  : 8 Size of  : 4 typedef Declarations You can create a new  for an existing  using typedef.
Following is the simple syntax to define a new  using typedef: typedef  newname; For example, the following tells the compiler that feet is another  for : Cplus_plus 16 typedef  feet; Now, the following declaration is perfectly legal and creates an integer variable called distance: feet distance; Enumerated Types An enumerated  declares an optional   and a set of zero or more identifiers that can be used as values of the.
Each enumerator is a constant whose  is the enumeration.
Creating an enumeration requires the use of the keyword enum.
The general form of an enumeration  is: enum enum- { list of names } var-list; Here, the enum- is the enumeration's.
The list of names is comma separated.
For example, the following code defines an enumeration of colors called colors and the variable  of  color.
Finally,  is assigned the value "blue".
But you can give a , a specific value by adding an initializer.
For example, in the following enumeration,  will have the value 5.
Cplus_plus 17 A variable provides us with named storage that our programs can manipulate.
Each variable in Cplus_plus has a specific , which determines the size and layout of the variable's memory; the range of values that can be stored within that memory; and the set of operations that can be applied to the variable.
The  of a variable can be composed of letters, digits, and the underscore character.
It must begin with either a letter or an underscore.
Upper and lowercase letters are distinct because Cplus_plus is case-sensitive: There are following basic types of variable in Cplus_plus as explained in last chapter: Type Description bool Stores either value true or false.
Typically a single octet (one byte).
The most natural size of integer for the machine.
A single-precision floating point value.
A wide character.
Cplus_plus also allows to define various other types of variables, which we will cover in subsequent chapters like Enumeration, Pointer, Array, Reference, Data structures, and Classes.
Following section will cover how to define, declare and use various types of variables.
Variable Definition in Cplus_plus A variable definition tells the compiler where and how much storage to create for the variable.
A variable definition specifies a data , and contains a list of one or more variables of that  as follows: 6.
VARIABLE TYPES Cplus_plus 18 variable_list; Here,  must be a valid Cplus_plus data  including char, w_char, , , , bool or any user-defined object, etc_0_, and variable_list may consist of one or more identifier names separated by commas.
Some valid declarations are shown here: int    i, j, k; char   , ch; float  , salary; double ; The line int i, j, k; both declares and defines the variables i, j and k; which instructs the compiler to create variables named i, j and k of  int.
Variables can be initialized (assigned an initial value) in their declaration.
The initializer consists of an equal sign followed by a constant expression as follows: type  = value; Some examples are: extern int  = 3,  = 5;    // declaration of  and.
For definition without an initializer: variables with static storage duration are implicitly initialized with NULL (all bytes have the value 0); the initial value of all other variables is undefined.
Variable Declaration in Cplus_plus A variable declaration provides assurance to the compiler that there is one variable existing with the given type and name so that compiler proceed for further compilation without needing complete detail about the variable.
A variable declaration has its meaning at the time of compilation only, compiler needs actual variable declaration at the time of linking of the program.
A variable declaration is useful when you are using multiple files and you define your variable in one of the files which will be available at the time of linking of the program.
You will use extern keyword to declare a variable at any place.
Though you can declare a variable multiple times in your Cplus_plus program, but it can be defined only once in a file, a function or a block of code.
Example: Cplus_plus 19 Try the following example where a variable has been declared at the top, but it has been defined inside the main function: # <iostream> using namespace std; // Variable declaration: extern int a, b; extern int c; extern float ; int main () { // Variable definition: int , ; int ; float ; // actual initialization = 10; = 20; =  + ; cout <<  << endl ; = 70_0_0/3_0_0; cout <<  << endl ; return 0; } When the above code is compiled and executed, it produces the following result: 30 23_0_3333 Cplus_plus 20 Same concept applies on function declaration where you provide  function name at the time of its declaration and its actual definition can be given anywhere else.
An lvalue may appear as either the left-hand or right-hand side of an assignment.
An rvalue is an expression that cannot have  value assigned to it which means an rvalue may appear on the right- but not left-hand side of an assignment.
Variables are lvalues and so may appear on the left-hand side of an assignment.
Numeric literals are rvalues and so may not be assigned and cannot appear on the left-hand side.
Following is  valid statement: int  = 20; But the following is not  valid statement and would generate compile-time error: 10 = 20; Cplus_plus 21 A scope is  region of the program and broadly speaking there are three places, where variables can be declared:  Inside  function or  block which is called local variables,  In the definition of function parameters which is called formal parameters.
We will learn what  function is, and it's parameter in subsequent chapters.
Here let us explain what local and global variables are.
Local Variables Variables that are declared inside  function or block are local variables.
They can be used only by statements that are inside that function or block of code.
Local variables are not known to functions outside their own.
Following is the example using local variables: # <iostream>.
VARIABLE SCOPE Cplus_plus 22 Global Variables Global variables are defined outside of all the functions, usually on top of the program.
The global variables will hold their value throughout the life-time of your program.
A global variable can be accessed by any function.
That is,  global variable is available for use throughout your entire program after its declaration.
Following is the example using global and local variables: # <iostream> using namespace std;.
Global variables are initialized automatically by the system when you define them as follows: Data Type Initializer int 0 char '\0' float 0 double 0 pointer NULL It is  good programming practice to initialize variables properly, otherwise sometimes program would produce unexpected result.
Cplus_plus 24 Constants refer to fixed values that the program may not alter and they are called literals.
Constants can be of any of the basic data types and can be divided into Integer Numerals, Floating-Point Numerals, Characters, Strings and Boolean Values.
Again, constants are treated just like regular variables except that their values cannot be modified after their definition.
Integer Literals An integer literal can be  decimal, octal, or hexadecimal constant.
A prefix specifies the base or radix: 0x or 0X for hexadecimal, 0 for octal, and nothing for decimal.
An integer literal can also have  suffix that is  combination of U and L, for unsigned and long, respectively.
The suffix can be uppercase or lowercase and can be in any order.
Here are some examples of integer literals: 212         // Legal.
Floating-point Literals A floating-point literal has an integer part,  decimal point,  fractional part, and an exponent part.
You can represent floating point literals either in decimal form or exponential form.
CONSTANTS/LITERALS Cplus_plus 25 While representing using decimal form, you must  the decimal point, the exponent, or both and while representing using exponential form, you must the integer part, the fractional part, or both.
The signed exponent is introduced by e or E.
Here are some examples of floating-point literals:.
Boolean Literals There are two Boolean literals and they are part of standard Cplus_plus keywords:  A value of true representing true.
You should not consider the value of true equal to 1 and value of false equal to 0.
Character Literals Character literals are enclosed in single quotes.
If the literal begins with L (uppercase only), it is  wide character literal (e_0__0_, L'x') and should be stored in wchar_t type of variable.
Otherwise, it is  narrow character literal (e_0__0_, 'x') and can be stored in  simple variable of char type.
A character literal can be  plain character (e_0__0_, 'x'), an escape sequence (e_0__0_, '\t'), or  universal character (e_0__0_, '\u02C0').
There are certain characters in Cplus_plus when they are preceded by  backslash they will have special meaning and they are used to represent like newline (\n) or tab (\t).
Here, you have  list of some of such escape sequence codes: Escape sequence Meaning \\ \ character \' ' character \" " character \.
Hexadecimal number of one or more digits Following is the example to show a few escape sequence characters: # <iostream>.
A string contains characters that are similar to character literals: plain characters, escape sequences, and universal characters.
Cplus_plus 27 You can break a long line into multiple lines using string literals and separate them using whitespaces.
Here are some examples of string literals.
All the three forms are identical strings.
The #define Preprocessor Following is the form to use #define preprocessor to define a constant: #define identifier value Following example explains it in detail: # <iostream> using namespace std; #define LENGTH 10 #define WIDTH  5 #define NEWLINE '\n' int main() { int ; = LENGTH * WIDTH; Cplus_plus 28 cout << ; cout << NEWLINE; return 0; } When the above code is compiled and executed, it produces the following result: 50 The const Keyword You can use const prefix to declare constants with a specific type as follows: const type  = value; Following example explains it in detail: # <iostream>.
Cplus_plus 29 Cplus_plus allows the char, int, and double data types to have modifiers preceding them.
A modifier is used to alter the meaning of the base type so that it more precisely fits the needs of various situations.
The data type modifiers are listed here:  signed  unsigned  long  short The modifiers signed, unsigned, long, and short can be applied to integer base types.
In addition, signed and unsigned can be applied to char, and long can be applied to double.
The modifiers signed and unsigned can also be used as prefix to long or short modifiers.
For example, unsigned long int.
Cplus_plus allows a shorthand notation for declaring unsigned, short, or long integers.
You can simply use the word unsigned, short, or long, without int.
It automatically implies int.
For example, the following two statements both declare unsigned integer variables.
MODIFIER TYPES Cplus_plus 30 = 50000; = ; cout <<  << " " << ; return 0; } When this program is run, following is the output: -15536 50000 The above result is because the bit pattern that represents 50,000 as a short unsigned integer is interpreted as -15,536 by a short.
Type Qualifiers in Cplus_plus The type qualifiers provide additional information about the variables they precede.
Qualifier Meaning const Objects of  const cannot be changed by your program during execution volatile The modifier volatile tells the compiler that a 's value may be changed in ways not explicitly specified by the program.
Only C99 adds a new qualifier called restrict.
Cplus_plus 31 A storage class defines the scope (visibility) and life-time of variables and/or functions within a Cplus_plus Program.
These specifiers precede the  that they modify.
There are following storage classes, which can be used in a Cplus_plus Program  auto  register  static  extern  mutable The auto Storage Class The auto storage class is the default storage class for all local variables.
The register Storage Class The register storage class is used to define local variables that should be stored in a register instead of RAM.
This means that the variable has a maximum size equal to the register size (usually one word) and can't have the unary '&' operator applied to it (as it does not have a memory location).
It should also be noted that defining 'register' does not mean that the variable will be stored in a register.
It means that it MIGHT be stored in a register depending on hardware and implementation restrictions.
The static Storage Class 10.
STORAGE CLASSES Cplus_plus 32 The static storage class instructs the compiler to keep a local variable in existence during the life-time of the program instead of creating and destroying it each time it comes into and goes out of scope.
Therefore, making local variables static allows them to maintain their values between function calls.
The static modifier may also be applied to global variables.
When this is done, it causes that variable's scope to be restricted to the file in which it is declared.
In Cplus_plus, when static is used on a class data member, it causes only one copy of that member to be shared by all objects of its class.
When you use 'extern' the variable cannot be initialized as all it does is point the variable name at a storage location that has been previously defined.
When you have multiple files and you define a global variable or function, which will be used in other files also, then extern will be used in another file to give reference of defined variable or function.
Just for understanding extern is used to declare a global variable or function in another file.
The extern modifier is most commonly used when there are two or more files sharing the same global variables or functions as explained below.
First File: main_0_cpp # <iostream> int  ;.
Second File: support_0_cpp # <iostream> Cplus_plus 34 extern int ; void write_extern(void) { std::cout << "Count is " <<  << std::endl; } Here, extern keyword is being used to declare  in another file.
Now compile these two files as follows: $gplus_plus main_0_cpp support_0_cpp -o write This will produce write executable program, try to execute write and check the result as follows: $_0_/write 5 The mutable Storage Class The mutable specifier applies only to class objects, which are discussed later in this tutorial.
It allows a member of an object to override const member function.
That is, a mutable member can be modified by a const member function.
Cplus_plus 35 An operator is a symbol that tells the compiler to perform specific mathematical or logical manipulations.
Cplus_plus is rich in built-in operators and provide the following types of operators:  Arithmetic Operators  Relational Operators  Logical Operators  Bitwise Operators  Assignment Operators  Misc Operators This chapter will examine the arithmetic, relational, logical, bitwise, assignment and other operators one by one.
Arithmetic Operators There are following arithmetic operators supported by Cplus_plus language: Assume variable A holds 10 and variable B holds 20, then: Operator Description Example + Adds two operands A + B will give 30 Subtracts second operand from the first A - B will give -10 * Multiplies both operands A * B will give 200 / Divides numerator by denumerator B / A will give 2 % Modulus Operator and remainder of after an integer division B % A will give 0 11.
OPERATORS Cplus_plus 36 plus_plus Increment operator, increases integer value by one Aplus_plus will give 11 minus_minus Decrement operator, decreases integer value by one Aminus_minus will give 9 Try the following example to understand all the arithmetic operators available in Cplus_plus.
Copy and paste the following Cplus_plus program in test_0_cpp file and compile and run this program.
Cplus_plus 38 operand is greater than or equal to the value of right operand, if yes then condition becomes true.
Try the following example to understand all the relational operators available in Cplus_plus.
Copy and paste the following Cplus_plus program in test_0_cpp file and compile and run this program.
Assume variable  holds 1 and variable B holds 0, then: Operator Description Example && Called Logical AND operator.
If both the operands are non-zero, then condition becomes true.
If any of the two operands is nonzero, then condition becomes true.
Called Logical NOT Operator.
Use to reverses the logical state of its operand.
If  condition is true, then Logical NOT operator will make false.
Try the following example to understand all the logical operators available in Cplus_plus.
Copy and paste the following Cplus_plus program in test_0_cpp file and compile and run this program.
The truth tables for &, |, and ^ are as follows: p q p & q p | q p ^ q 0 0 0 0 0 0 1 0 1 1 1 1 1 1 0 1 0 0 1 1 Assume if  = 60; and  = 13; now in binary format they will be as follows: = 0011 1100 = 0000 1101 minus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusA& = 0000 1100 | = 0011 1101 ^ = 0011 0001 ~  = 1100 0011 The Bitwise operators supported by Cplus_plus language are listed in the following table.
Assume variable  holds 60 and variable  holds 13, then: Operator Description Example & Binary AND Operator copies bit to the result if it exists in both operands.
The left operands value is moved left by the number of bits specified by the right operand.
The left operands value is moved right by the number of bits specified by the right operand.
Copy and paste the following Cplus_plus program in test_0_cpp file and compile and run this program.
Cplus_plus 46 Copy and paste the following Cplus_plus program in test_0_cpp file and compile and run this program.
Operator Description sizeof sizeof operator returns the size of  variable.
For example, sizeof(), where '' is integer, and will return 4.
X : Y Conditional operator (_0_).
If Condition is true then it returns value of X otherwise returns value of Y.
The value of the entire comma expression is the value of the last expression of the comma-separated list.
Cast Casting operators convert one data type to another.
For example, int(2_0_2000) would return 2.
For example &; will give actual address of the variable.
For example *var; will pointer to  variable var.
Operators Precedence in Cplus_plus Operator precedence determines the grouping of terms in an expression.
This affects how an expression is evaluated.
Certain operators have higher precedence than others; for example, the multiplication operator has higher precedence than the addition operator: For example  = 7 + 3 * 2; here,  is assigned 13, not 20 because operator * has higher precedence than +, so it first gets multiplied with 3*2 and then adds into 7.
Here, operators with the highest precedence appear at the top of the table, those with the lowest appear at the bottom.
Within an expression, higher precedence operators will be evaluated first.
Category Operator Associativity Postfix () [] arrow_operator.
Copy and paste the following Cplus_plus program in test_0_cpp file and compile and run this program.
Check the simple difference with and without parenthesis.
This will produce different results because (), /, * and + have different precedence.
Higher precedence operators will be evaluated first:.
In general, statements are executed sequentially: The first statement in  function is executed first, followed by the second, and so on.
Programming languages provide various control structures that allow for more complicated execution paths.
A loop statement allows us to execute  statement or group of statements multiple times and following is the general from of  loop statement in most of the programming languages: Cplus_plus programming language provides the following type of loops to handle looping requirements.
Loop Type Description while loop Repeats  statement or group of statements while given condition is true.
It tests the condition before executing the loop body.
LOOP TYPES Cplus_plus 52 do_0__0__0_while loop Like  'while' statement, except that it tests the condition at the end of the loop body.
While Loop A while loop statement repeatedly executes  target statement as long as given condition is true.
Syntax The syntax of  while loop in Cplus_plus is:.
Here, statement(s) may be  single statement or  block of statements.
The condition may be any expression, and true is any non-zero value.
The loop iterates while the condition is true.
When the condition becomes false, program control passes to the line immediately following the loop.
Flow Diagram Cplus_plus 53 Here, key point of the while loop is that the loop might not ever run.
When the condition is tested and the result is false, the loop body will be skipped and the first statement after the while loop will be executed.
Example # <iostream>.
Syntax The syntax of  for loop in Cplus_plus is: for ( init; condition; increment ) { statement(s); } Here is the flow of control in  for loop: 1.
The init step is executed first, and only once.
This step allows you to declare and initialize any loop control variables.
You are not required to put  statement here, as long as  semicolon appears.
Next, the condition is evaluated.
If it is true, the body of the loop is executed.
If it is false, the body of the loop does not execute and flow of control jumps to the next statement just after the for loop.
After the body of the for loop executes, the flow of control jumps back up to the increment statement.
This statement allows you to update any Cplus_plus 55 loop control variables.
This statement can be left blank, as long as semicolon appears after the condition.
The condition is now evaluated again.
If it is true, the loop executes and the process repeats itself (body of loop, then increment step, and then again condition).
After the condition becomes false, the for loop terminates.
Flow Diagram Example # <iostream>.
A do_0__0__0_while loop is similar to  while loop, except that  do_0__0__0_while loop is guaranteed to execute at least one time.
Syntax The syntax of  do_0__0__0_while loop in Cplus_plus is: do { statement(s); }while( condition ); Notice that the conditional expression appears at the end of the loop, so the statement(s) in the loop execute once before the condition is tested.
Cplus_plus 57 If the condition is true, the flow of control jumps back up to do, and the statement(s) in the loop execute again.
This process repeats until the given condition becomes false.
Flow Diagram Example # <iostream>.
Cplus_plus allows at least 256 levels of nesting.
Syntax The syntax for  nested for loop statement in Cplus_plus is as follows: for ( init; condition; increment ) {.
When execution leaves  scope, all automatic objects that were created in that scope are destroyed.
Cplus_plus supports the following control statements.
Control Statement Description break statement Terminates the loop or switch statement and transfers execution to the statement immediately Cplus_plus 61 following the loop or switch.
Though it is not advised to use goto statement in your program.
Break Statement The break statement has the following two usages in Cplus_plus:  When the break statement is encountered inside  loop, the loop is immediately terminated and program control resumes at the next statement following the loop.
If you are using nested loops (_0_e_0_, one loop inside another loop), the break statement will stop the execution of the innermost loop and start executing the next line of code after the block.
Syntax The syntax of a break statement in Cplus_plus is: break; Flow Diagram Cplus_plus 62 Example # <iostream>.
Instead of forcing termination, however, continue forces the next iteration of the loop to take place, skipping any code in between.
For the for loop, continue causes the conditional test and increment portions of the loop to execute.
For the while and do_0__0__0_while loops, program control passes to the conditional tests.
Syntax The syntax of  continue statement in Cplus_plus is: continue; Flow Diagram Cplus_plus 64 Example # <iostream>.
NOTE: Use of goto statement is highly discouraged because it makes difficult to trace the control flow of  program, making the program hard to understand and hard to modify.
Any program that uses  goto can be rewritten so that it doesn't need the goto.
Syntax The syntax of  goto statement in Cplus_plus is: goto label; _0_.
A labeled statement is any statement that is preceded by an identifier followed by  colon (:).
Flow Diagram Cplus_plus 66 Example # <iostream>.
For example, consider the following code fragment:.
A simplebreak statement would not work here, because it would only cause the program to exit from the innermost loop.
The Infinite Loop A loop becomes infinite loop if  condition never becomes false.
The for loop is traditionally used for this purpose.
Since none of the three expressions that form Cplus_plus 68 the 'for' loop are required, you can make an endless loop by leaving the conditional expression empty.
You may have an initialization and increment expression, but Cplus_plus programmers more commonly use the 'for (;;)' construct to signify an infinite loop.
NOTE: You can terminate an infinite loop by pressing Ctrl + C keys.
Cplus_plus 69 Decision making structures require that the programmer specify one or more conditions to be evaluated or tested by the program, along with  statement or statements to be executed if the condition is determined to be true, and optionally, other statements to be executed if the condition is determined to be false.
Following is the general from of  typical decision making structure found in most of the programming languages: Cplus_plus programming language provides following types of decision making statements.
Statement Description if statement An 'if' statement consists of  boolean expression followed by one or more statements.
DECISION-MAKING STATEMENTS Cplus_plus 70 for equality against  list of values.
If Statement An if statement consists of  boolean expression followed by one or more statements.
Syntax The syntax of an if statement in Cplus_plus is: if(boolean_expression) { // statement(s) will execute if the boolean expression is true } If the boolean expression evaluates to true, then the block of code inside the if statement will be executed.
If boolean expression evaluates to false, then the first set of code after the end of the if statement (after the closing curly brace) will be executed.
Flow Diagram Cplus_plus 71 Example # <iostream>.
Syntax The syntax of an if_0__0__0_else statement in Cplus_plus is: if(boolean_expression) {.
Flow Diagram Cplus_plus 73 Example # <iostream>.
When using if , else if , else statements there are few points to keep in mind.
Cplus_plus 74  An if can have zero to many else if's and they must come before the else.
Syntax The syntax of an if_0__0__0_else if_0__0__0_else statement in Cplus_plus is: if(boolean_expression 1).
Each value is called  case, and the variable being switched on is checked for each case.
Syntax The syntax for  switch statement in Cplus_plus is as follows: Cplus_plus 76 switch(expression){ case constant-expression  :.
Each case is followed by the value to be compared to and  colon.
If no break appears, the flow of control will fall through to subsequent cases until  break is reached.
The default case can be used for performing  task when none of the cases is true.
No break is needed in the default case.
Flow Diagram Cplus_plus 77 Example # <iostream>.
Syntax The syntax for  nested if statement is as follows: if( boolean_expression 1).
Cplus_plus 79 Example # <iostream>.
Even if the case constants of the inner and outer switch contain common values, no conflicts will arise.
Cplus_plus 80 Cplus_plus specifies that at least 256 levels of nesting be allowed for switch statements.
Syntax The syntax for  nested switch statement is as follows: switch(ch1) { case 'A': cout << "This A is part of outer switch"; switch(ch2) { case 'A': cout << "This A is part of inner switch"; break; case 'B': // _0__0_.
It has the following general form: Exp1.
Notice the use and placement of the colon.
The value of  '_0_' expression is determined like this: Exp1 is evaluated.
If it is true, then Exp2 is evaluated and becomes the value of the entire '_0_' expression.
If Exp1 is false, then Exp3 is evaluated and its value becomes the value of the expression.
Cplus_plus 82 A function is  group of statements that together perform  task.
Every Cplus_plus program has at least one function, which is main(), and all the most trivial programs can define additional functions.
You can divide up your code into separate functions.
How you divide up your code among different functions is up to you, but logically the division usually is such that each function performs  specific task.
A function declaration tells the compiler about  function's name, return type, and parameters.
A function definition provides the actual body of the function.
The Cplus_plus standard library provides numerous built-in functions that your program can call.
For example, function strcat() to concatenate two strings, function memcpy() to copy one memory location to another location, and many more functions.
A function is known with various names like  method or  sub-routine or procedure etc.
Defining  Function The general form of  Cplus_plus function definition is as follows: return_type function_name( parameter list ) { body of the function } A Cplus_plus function definition consists of  function header and  function body.
Here are all the parts of  function:  Return Type: A function may return  value.
Some functions perform the desired operations without returning  value.
In this case, the return_type is the keyword void.
The function name and the parameter list together constitute the function signature.
When  function is invoked, you pass  value to the parameter.
This value is referred to as actual parameter or argument.
The parameter list refers to the type, order, and number of the parameters of  function.
Parameters are optional; that is,  function may contain no parameters.
FUNCTIONS Cplus_plus 83  Function Body: The function body contains  collection of statements that define what the function does.
Example: Following is the source code for  function called max().
This function takes two parameters num1 and num2 and returns the maximum between the two: // function returning the max between two numbers int max(int num1, int num2) { // local variable declaration int ; if (num1 > num2) = num1; else = num2; return ; } Function Declarations A function declaration tells the compiler about  function name and how to call the function.
The actual body of the function can be defined separately.
A function declaration has the following parts: return_type function_name( parameter list ); For the above defined function max(), following is the function declaration: int max(int num1, int num2); Parameter names are not important in function declaration only their type is required, so following is also valid declaration: int max(int, int); Function declaration is required when you define a function in one source file and you call that function in another file.
In such case, you should declare the function at the top of the file calling the function.
Cplus_plus 84 Calling a Function While creating a Cplus_plus function, you give a definition of what the function has to do.
To use a function, you will have to call or invoke that function.
When a program calls a function, program control is transferred to the called function.
A called function performs defined task and when it's return statement is executed or when its function-ending closing brace is reached, it returns program control back to the main program.
To call a function, you simply need to pass the required parameters along with function name, and if function returns a value, then you can store returned value.
For example: # <iostream>.
While running final executable, it would produce the following : Max value is : 200 Function Arguments If  function is to use arguments, it must declare variables that accept the values of the arguments.
These variables are called the formal parameters of the function.
The formal parameters behave like other local variables inside the function and are created upon entry into the function and destroyed upon exit.
While calling  function, there are two ways that arguments can be passed to function: Call Type Description Call by value This method copies the actual value of an argument into the formal parameter of the function.
In this case, changes made to the parameter inside the function have no effect on the argument.
Call by pointer This method copies the address of an argument into the formal parameter.
Inside the function, the address is used to access the actual argument used in the call.
This means that changes made to the parameter affect the argument.
Call by reference This method copies the reference of an argument into the formal parameter.
Inside the function, the reference is used to access the actual argument used Cplus_plus 86 in the call.
This means that changes made to the parameter affect the argument.
Call by Value The call by value method of passing arguments to  function copies the actual value of an argument into the formal parameter of the function.
In this case, changes made to the parameter inside the function have no effect on the argument.
By default, Cplus_plus uses call by value to pass arguments.
In general, this means that code within  function cannot alter the arguments used to call the function.
Consider the function swap() definition as follows.
Call by Pointer The call by pointer method of passing arguments to  function copies the address of an argument into the formal parameter.
Inside the function, the address is used to access the actual argument used in the call.
This means that changes made to the parameter affect the passed argument.
To pass the value by pointer, argument pointers are passed to the functions just like any other value.
So accordingly you need to declare the function parameters as pointer types as in the following function swap(), which exchanges the values of the two integer variables pointed to by its arguments.
For now, let us call the function swap() by passing values by pointer as in the following example: # <iostream>.
Inside the function, the reference is used to access the actual argument used in the call.
This means that changes made to the parameter affect the passed argument.
To pass the value by reference, argument reference is passed to the functions just like any other value.
So accordingly you need to declare the function parameters as reference types as in the following function swap(), which exchanges the values of the two integer variables pointed to by its arguments.
In general, this means that code within  function cannot alter the arguments used to call the function and above mentioned example while calling max() function used the same method.
Default Values for Parameters When you define  function, you can specify  default value for each of the last parameters.
This value will be used if the corresponding argument is left blank when calling to the function.
Cplus_plus 91 This is done by using the assignment operator and assigning values for the arguments in the function definition.
If  value for that parameter is not passed when the function is called, the default given value is used, but if  value is specified, this default value is ignored and the passed value is used instead.
Consider the following example: # <iostream>.
The number data types, their possible values and number ranges have been explained while discussing Cplus_plus Data Types.
Defining Numbers in Cplus_plus You have already defined numbers in various examples given in previous chapters.
Here is another consolidated example to define various types of numbers in Cplus_plus: # <iostream>.
NUMBERS Cplus_plus 94 cout << "double  :" <<  << endl; return 0; } When the above code is compiled and executed, it produces the following : short   :10 int     :1000 long    :1000000 float   :230_0_47 double  :30949_0_4 Math Operations in Cplus_plus In addition to the various functions you can create, Cplus_plus also includes some useful functions you can use.
These functions are available in standard C and Cplus_plus libraries and called built-in functions.
These are functions that can be included in your program and then use.
Cplus_plus has  rich set of mathematical operations, which can be performed on various numbers.
Following table lists down some useful built-in mathematical functions available in Cplus_plus.
To utilize these functions you need to  the math header file <cmath>.
Function & Purpose 1 double cos(double); This function takes an angle (as  double) and returns the cosine.
Cplus_plus 95 5 double pow(double, double); The first is  number you wish to raise and the second is the power you wish to raise it t 6 double hypot(double, double); If you pass this function the length of two sides of  right triangle, it will return you the length of the hypotenuse.
Following is a simple example to show few of the mathematical operations: # <iostream>.
Random Numbers in Cplus_plus There are many cases where you will wish to generate a random number.
There are actually two functions you will need to know about random number generation.
The first is rand(), this function will only return a pseudo random number.
The way to fix this is to first call the srand() function.
Following is a simple example to generate few random numbers.
This example makes use of time() function to get the number of seconds on your system.
An array is used to store a collection of data, but it is often more useful to think of an array as a collection of variables of the same type.
Instead of declaring individual variables, such as number0, number1, _0__0__0_, and number99, you declare one array variable such as numbers and use numbers[0], numbers[1], and _0__0__0_, numbers[99] to represent individual variables.
A specific element in an array is accessed by an index.
All arrays consist of contiguous memory locations.
The lowest address corresponds to the first element and the highest address to the last element.
Declaring Arrays To declare an array in Cplus_plus, the programmer specifies the type of the elements and the number of elements required by an array as follows: type arrayName [ arraySize ]; This is called a single-dimension array.
The arraySize must be an integer constant greater than zero and type can be any valid Cplus_plus data type.
For example, to declare a 10-element array called  of type double, use this statement: double [10]; Initializing Arrays You can initialize Cplus_plus array elements either one by one or using a single statement as follows: double [5] = {1000_0_0, 2_0_0, 3_0_4, 17_0_0, 50_0_0}; The number of values between braces { } cannot be larger than the number of elements that we declare for the array between square brackets [ ].
Following is an example to assign a single element of the array: If you omit the size of the array, an array just big enough to hold the initialization is created.
Therefore, if you write: double [] = {1000_0_0, 2_0_0, 3_0_4, 17_0_0, 50_0_0}; You will create exactly the same array as you did in the previous example.
ARRAYS Cplus_plus 99 [4] = 50_0_0; The above statement assigns element number 5th in the array a value of 50_0_0.
Array with 4th index will be 5th, _0_e_0_, last element because all arrays have 0 as the index of their first element which is also called base index.
Following is the pictorial representation of the same array we discussed above: Accessing Array Elements An element is accessed by indexing the array name.
This is done by placing the index of the element within square brackets after the name of the array.
For example: double  = [9]; The above statement will take 10th element from the array and assign the value to  variable.
Following is an example, which will use all the abovementioned three concepts viz.
When the above code is compiled and executed, it produces the following result: 0          100 1          101 2          102 3          103 4          104 5          105 6          106 7          107 8          108 9          109 Arrays in Cplus_plus Arrays are important to Cplus_plus and should need lots of more detail.
There are following few important concepts, which should be clear to a Cplus_plus programmer: Concept Description Multi-dimensional arrays Cplus_plus supports multidimensional arrays.
The simplest form of the multidimensional array is the two-dimensional array.
Pointer to an array You can generate a pointer to the first element of an array by simply specifying the array name, without any index.
Passing arrays to functions You can pass to the function a pointer to an Cplus_plus 101 array by specifying the array's name without an index.
Return array from functions Cplus_plus allows a function to return an array.
Multi-dimensional Arrays Cplus_plus allows multidimensional arrays.
Here is the general form of a multidimensional array declaration: type name[size1][size2]_0__0__0_[sizeN]; For example, the following declaration creates a three dimensional 5.
A two-dimensional array is, in essence, a list of one-dimensional arrays.
To declare a two-dimensional integer array of size x,y, you would write something as follows: type arrayName [ x ][ y ]; Where type can be any valid Cplus_plus data type and arrayName will be a valid Cplus_plus identifier.
A two-dimensional array can be think as a table, which will have x number of rows and y number of columns.
A 2-dimensional array a, which contains three rows and four columns can be shown as below: Thus, every element in array  is identified by an element name of the form [ ][  ], where  is the name of the array, and  and  are the subscripts that uniquely identify each element in.
Initializing Two-Dimensional Arrays Cplus_plus 102 Multidimensioned arrays may be initialized by specifying bracketed values for each row.
Following is an array with 3 rows and each row have 4 columns.
The following initialization is equivalent to previous example: int [3][4] = {0,1,2,3,4,5,6,7,8,9,10,11}; Accessing Two-Dimensional Array Elements An element in 2-dimensional array is accessed by using the subscripts, _0_e_0_, row index and column index of the array.
For example: int  = [2][3]; The above statement will take 4th element from the 3rd row of the array.
You can verify it in the above digram.
Pointer to an Array It is most likely that you would not understand this chapter until you go through the chapter related Cplus_plus Pointers.
So assuming you have bit understanding on pointers in Cplus_plus, let us start: An array name is  constant pointer to the first element of the array.
Therefore, in the declaration: double balance[50]; balance is  pointer to &balance[0], which is the address of the first element of the array balance.
Thus, the following program fragment assigns  the address of the first element ofbalance: double *; double balance[10]; = balance; It is legal to use array names as constant pointers, and vice versa.
Therefore, *(balance + 4) is  legitimate way of accessing the data at balance[4].
Cplus_plus 104 Once you store the address of first element in , you can access array elements using *, *(+1), *(+2) and so on.
Below is the example to show all the concepts discussed above: # <iostream>.
In the above example,  is  pointer to double which means it can store address of  variable of double type.
Once we have address in , then * will give us value available at the address stored in , as we have shown in the above example.
Passing Arrays to Functions Cplus_plus does not allow to pass an entire array as an argument to  function.
However, You can pass  pointer to an array by specifying the array's name without an index.
If you want to pass  single-dimension array as an argument in  function, you would have to declare function formal parameter in one of following three ways and all three declaration methods produce similar results because each tells the compiler that an integer pointer is going to be received.
Way-1 Formal parameters as  pointer as follows: void myFunction(int *param) {.
Return Array from Functions Cplus_plus does not allow to return an entire array as an argument to a function.
However, you can return a pointer to an array by specifying the array's name without an index.
If you want to return a single-dimension array from a function, you would have to declare a function returning a pointer as in the following example: int * myFunction() {.
Now, consider the following function, which will generate 10 random numbers and return them using an array and call this function as follows: # <iostream> # <ctime>.
Cplus_plus 110 Cplus_plus 111 Cplus_plus provides following two types of string representations:  The C-style character string.
The C-Style Character String The C-style character string originated within the C language and continues to be supported within Cplus_plus.
This string is actually a one-dimensional array of characters which is terminated by a null character '\0'.
Thus a null-terminated string contains the characters that comprise the string followed by a null.
The following declaration and initialization create a string consisting of the word "Hello".
To hold the null character at the end of the array, the size of the character array containing the string is one more than the number of characters in the word "Hello_0_" char [6] = {'H', 'e', 'l', 'l', 'o', '\0'}; If you follow the rule of array initialization, then you can write the above statement as follows: char [] = "Hello"; Following is the memory presentation of above defined string in C/Cplus_plus: Actually, you do not place the null character at the end of a string constant.
The Cplus_plus compiler automatically places the '\0' at the end of the string when it initializes the array.
Let us try to print above-mentioned string: # <iostream> using namespace std; 17.
STRINGS Cplus_plus 112 int main () { char [6] = {'H', 'e', 'l', 'l', 'o', '\0'}; << "Greeting message: "; <<  << endl; return 0; } When the above code is compiled and executed, it produces the following result: Greeting message: Hello Cplus_plus supports a wide range of functions that manipulate null-terminated strings: S_0_N.
Function & Purpose 1 strcpy(s1, s2); Copies string s2 into string s1.
Following example makes use of few of the above-mentioned functions: # <iostream> # <cstring>.
Let us check the following example: # <iostream> # <string>.
Some Cplus_plus tasks are performed more easily with pointers, and other Cplus_plus tasks, such as dynamic memory allocation, cannot be performed without them.
As you know every variable is a memory location and every memory location has its address defined which can be accessed using ampersand (&) operator which denotes an address  memory.
Consider the following which will print the address of the variables defined: # <iostream>.
A pointer is a variable whose value is the address of another variable.
Like any variable or constant, you must declare a pointer before you can work with it.
The general form of a pointer variable declaration is: 18.
POINTERS Cplus_plus 117 type *var-name; Here, type is the pointer's base type; it must be a valid Cplus_plus type and varname is the name of the pointer variable.
The asterisk you used to declare a pointer is the same asterisk that you use for multiplication.
However,  this statement the asterisk is being used to designate a variable as a pointer.
Following are the valid pointer declaration:.
The actual data type of the value of all pointers, whether integer, float, character, or otherwise, is the same, a long hexadecimal number that represents a memory address.
The only difference between pointers of different data types is the data type of the variable or constant that the pointer points to.
Using Pointers  Cplus_plus There are few important operations, which we will do with the pointers very frequently.
This is done by using unary operator * that returns the value of the variable located at the address specified by its operand.
Following example makes use of these operations: # <iostream>.
There are following few important pointer concepts which should be clear to a Cplus_plus programmer: Concept Description Cplus_plus Null Pointers Cplus_plus supports null pointer, which is a constant with a value of zero defined in several standard libraries.
Cplus_plus pointer arithmetic There are four arithmetic operators that can be used on pointers: plus_plus, minus_minus, +, Cplus_plus pointers vs arrays There is a close relationship between pointers and arrays.
Cplus_plus array of pointers You can define arrays to hold a number of pointers.
Cplus_plus pointer to pointer Cplus_plus allows you to have pointer on a pointer Cplus_plus 119 and so on.
Passing pointers to functions Passing an argument by reference or by address both enable the passed argument to be changed in the calling function by the called function.
Return pointer from functions Cplus_plus allows a function to return a pointer to local variable, static variable and dynamically allocated memory as well.
Null Pointers It is always a good practice to assign the pointer NULL to a pointer variable in case you do not have exact address to be assigned.
This is done at the time of variable declaration.
A pointer that is assigned NULL is called a null pointer.
The NULL pointer is a constant with a value of zero defined in several standard libraries, including iostream.
Consider the following program: # <iostream>.
However, the memory address 0 has special significance; it signals that the pointer is not intended to point to an accessible memory location.
But by Cplus_plus 120 convention, if a pointer contains the null (zero) value, it is assumed to point to nothing.
To check for a null pointer you can use an if statement as follows: if()     // succeeds if p is not null if(_0_)    // succeeds if p is null Thus, if all unused pointers are given the null value and you avoid the use of a null pointer, you can avoid the accidental misuse of an uninitialized pointer.
Many times, uninitialized variables hold some junk values and it becomes difficult to debug the program.
Pointer Arithmetic As you understood pointer is an address which is a numeric value; therefore, you can perform arithmetic operations on a pointer just as you can a numeric value.
There are four arithmetic operators that can be used on pointers: plus_plus, minus_minus, +, and To understand pointer arithmetic, let us consider that  is an integer pointer which points to the address 1000.
Assuming 32-bit integers, let us perform the following arithmatic operation on the pointer: ptrplus_plus the  will point to the location 1004 because each time  is incremented, it will point to the next integer.
This operation will move the pointer to next memory location without impacting actual value at the memory location.
If points to a character whose address is 1000, then above operation will point to the location 1001 because next character will be available at 1001.
Incrementing a Pointer We prefer using a pointer in our program instead of an array because the variable pointer can be incremented, unlike the array name which cannot be incremented because it is a constant pointer.
The following program increments the variable pointer to access each succeeding element of the array: # <iostream> using namespace std;.
If p1 and p2 point to variables that are related to each other, such  elements of the same array, then p1 and p2 can be meaningfully compared.
Cplus_plus 123 The following program modifies the previous example one by incrementing the variable pointer so long  the address to which it points is either less than or equal to the address of the last element of the array, which is &[ - 1]: # <iostream> using namespace std;.
In fact, pointers and arrays are interchangeable in many cases.
For example, a pointer that points to the beginning of an array can access that array by using either pointer arithmetic or array-style indexing.
Consider the following program: # <iostream> using namespace std;.
For example, consider the following program: # <iostream> using namespace std;.
The reason for this is that  is a constant that points to the beginning of an array and can not be used  l-value.
Because an array name generates a pointer constant, it can still be used in pointer-style expressions,  long  it is not modified.
For example, the following is a valid statement that assigns [2] the value 500: *( + 2) = 500; Cplus_plus 126 Above statement is valid and will compile successfully because  is not changed.
Array of Pointers Before we understand the concept of array of pointers, let us consider the following example, which makes use of an array of 3 integers: # <iostream> using namespace std;.
Following is the declaration of an array of pointers to an integer: int *[]; This declares  as an array of  integer pointers.
Thus, each element in , now holds a pointer to an int value.
Following example makes use of three integers which will be stored in an array of pointers as follows: # <iostream> Cplus_plus 127 using namespace std; const int  = 3;.
Normally, a pointer contains the address of a variable.
When we define a pointer to a pointer, the first pointer contains the address of the second pointer, which points to the location that contains the actual value as shown below.
A variable that is a pointer to a pointer must be declared as such.
This is done by placing an additional asterisk in front of its name.
For example, following is the declaration to declare a pointer to a pointer of type int: int **; Cplus_plus 129 When a target value is indirectly pointed to by a pointer to a pointer, accessing that value requires that the asterisk operator be applied twice, as is shown below in the example: # <iostream>.
To do so, simply declare the function parameter as a pointer type.
Following a simple example where we pass an unsigned long pointer to a function and change the value inside the function which reflects back in the calling function: # <iostream>.
To do so, you would have to declare a function returning a pointer as in the following example: int * myFunction() {.
Now, consider the following function, which will generate 10 random numbers and return them using an array name which represents a pointer _0_e_0_, address of first array element.
Cplus_plus 135 A reference variable is an alias, that is, another name for an already existing variable.
Once a reference is initialized with a variable, either the variable name or the reference name may be used to refer to the variable.
References vs Pointers References are often confused with pointers but three major differences between references and pointers are:  You cannot have NULL references.
You must always be able to assume that a reference is connected to a legitimate piece of storage.
Pointers can be pointed to another object at any time.
Pointers can be initialized at any time.
Creating References in Cplus_plus Think of a variable name as a label attached to the variable's location in memory.
You can then think of a reference as a second label attached to that memory location.
Therefore, you can access the contents of the variable through either the original variable name or the reference.
For example, suppose we have the following example: int     = 17; We can declare reference variables for  as follows.
Thus, read the first declaration as " is an integer reference initialized to " and read the second declaration as "s is a double reference initialized to d_0_" Following example makes use of references on int and double: # <iostream>.
REFERENCES Cplus_plus 136 // declare simple variables int    ; double ; // declare reference variables int&     = ; double&  = ; = 5; << "Value of  : " <<  << endl; << "Value of  reference : " <<   << endl; = 11_0_7; << "Value of  : " <<  << endl; << "Value of  reference : " <<   << endl; return 0; } When the above code is compiled together and executed, it produces the following result: Value of  : 5 Value of  reference : 5 Value of  : 11_0_7 Value of  reference : 11_0_7 References are usually used for function argument lists and function return values.
So following are two important subjects related to Cplus_plus references which should be clear to a Cplus_plus programmer: Concept Description References as parameters Cplus_plus supports passing references as function parameter more safely than parameters.
Reference as return value You can return reference from a Cplus_plus function Cplus_plus 137 like any other data type.
References as Parameters We have discussed how we implement call by reference concept using pointers.
Here is another example of call by reference which makes use of Cplus_plus reference: # <iostream>.
A Cplus_plus function can return  reference in  similar way as it returns  pointer.
When  function returns  reference, it returns an implicit pointer to its return value.
This way,  function can be used on the left side of an assignment statement.
For example, consider this simple program: # <iostream> # <ctime>.
So it is not legal to return  reference to local var.
But you can always return  reference on  static variable.
Cplus_plus inherits the structs and functions for date and time manipulation from C.
To access date and time related functions and structures, you would need to  <ctime> header file in your Cplus_plus program.
There are four time-related types: clock_t, time_t, size_t, and tm.
The types clock_t, size_t and time_t are capable of representing the system time and date as some sort of integer.
The structure type tm holds the date and time in the form of a C structure having the following elements:.
All these functions are part of standard C and Cplus_plus library and you can check their detail using reference to Cplus_plus standard library given below.
SN Function & Purpose 1 time_t time(time_t *time); This returns the current calendar time of the system in number of seconds elapsed since January 1, 1970.
If the system has no time, _0_1 is returned.
DATE AND TIME Cplus_plus 142 hours:minutes:seconds year\n\0.
A value of _0_1 is returned if the time is not available.
The time is represented in Coordinated Universal Time (UTC), which is essentially Greenwich Mean Time (GMT).
Current Date and Time Suppose you want to retrieve the current system date and time, either as a local time or as a Coordinated Universal Time (UTC).
Following is the example to achieve the same: # <iostream> # <ctime> Cplus_plus 143 using namespace std;.
This structure holds the date and time in the form of a C structure as mentioned above.
Most of the time related functions makes use of tm structure.
Following is an example which makes use of various date and time related functions and tm structure: While using structure in this chapter, I'm making an assumption that you have basic understanding on C structure and how to access structure members using arrow arrow_operator operator.
This chapter will discuss very basic and most common I/O operations required for Cplus_plus programming.
Cplus_plus I/O occurs in streams, which are sequences of bytes.
If bytes flow from a device like a keyboard, a disk drive, or a network connection etc.
I/O Library Header Files There are following header files important to Cplus_plus programs: Header File Function and Description <iostream> This file defines the cin, cout, cerr and clog objects, which correspond to the standard input stream, the standard output stream, the un-buffered standard error stream and the buffered standard error stream, respectively.
We will discuss about it in detail in File and Stream related chapter.
The Standard Output Stream (cout) The predefined object cout is an instance of ostream class.
The cout object is said to be "connected to" the standard output device, which usually is the display screen.
The cout is used in conjunction with the stream insertion operator, which is written as << which are two less than signs as shown in the following example.
BASIC INPUT/OUTPUT Cplus_plus 146 using namespace std; int main( ) { char [] = "Hello Cplus_plus"; cout << "Value of  is : " <<  << endl; } When the above code is compiled and executed, it produces the following result: Value of  is : Hello Cplus_plus The Cplus_plus compiler also determines the data type of variable to be output and selects the appropriate stream insertion operator to display the value.
The << operator is overloaded to output data items of built-in types integer, float, double, strings and pointer values.
The insertion operator << may be used more than once in a single statement as shown above and endl is used to add a new- at the end of the.
The Standard Input Stream (cin) The predefined object cin is an instance of istream class.
The cin object is said to be attached to the standard input device, which usually is the keyboard.
The cin is used in conjunction with the stream extraction operator, which is written as >> which are two greater than signs as shown in the following example.
You enter a value and then hit enter to see the following result: Please enter your name: cplusplus Your name is: cplusplus The Cplus_plus compiler also determines the data type of the entered value and selects the appropriate stream extraction operator to extract the value and store it in the given variables.
The stream extraction operator >> may be used more than once in a single statement.
To request more than one datum you can use the following: cin >> name >> age; This will be equivalent to the following two statements: cin >> name; cin >> age; The Standard Error Stream (cerr) The predefined object cerr is an instance of ostream class.
The cerr object is said to be attached to the standard error device, which is also a display screen but the object cerr is un-buffered and each stream insertion to cerr causes its output to appear immediately.
The cerr is also used in conjunction with the stream insertion operator as shown in the following example.
The Standard Log Stream (clog) The predefined object clog is an instance of ostream class.
The clog object is said to be attached to the standard error device, which is also a display screen but the object clog is buffered.
This means that each insertion to clog could cause its output to be held in a buffer until the buffer is filled or until the buffer is flushed.
The clog is also used in conjunction with the stream insertion operator as shown in the following example.
You would not be able to see any difference in cout, cerr and clog with these small examples, but while writing and executing big programs the difference becomes obvious.
So it is good practice to display error messages using cerr stream and while displaying other log messages then clog should be used.
Cplus_plus 149 C/Cplus_plus arrays allow you to define variables that combine several data items of the same kind, but structure is another user defined data type which allows you to combine data items of different kinds.
Structures are used to represent a record, suppose you want to keep track of your books in a library.
You might want to track the following attributes about each book:  Title  Author  Subject  Book ID Defining a Structure To define a structure, you must use the struct statement.
The struct statement defines a new  type, with more than one member, for your program.
The format of the struct statement is this: struct [structure tag] { member definition; member definition; _0__0_.
At the end of the structure's definition, before the final semicolon, you can specify one or more structure variables but it is optional.
Here is the way you would declare the Book structure: struct Books { char  title[50]; char  author[50]; char  subject[100]; 22.
DATA STRUCTURES Cplus_plus 150 int   book_id; }book; Accessing Structure Members To access any member of a structure, we use the member access operator (_0_).
The member access operator is coded as a period between the structure variable name and the structure member that we wish to access.
You would use struct keyword to define variables of structure type.
Following is the example to explain usage of structure: # <iostream> # <cstring>.
You would access structure variables in the similar way as you have accessed in the above example: # <iostream> # <cstring> Cplus_plus 152 using namespace std; void printBook( struct Books book ); struct Books { char  title[50]; char  author[50]; char  subject[100]; int   ; };.
To find the address of a structure variable, place the '&' operator before the structure's name as follows: = &1; To access the members of a structure using a pointer to that structure, you must use the arrow_operator operator as follows: struct_pointerarrow_operatortitle; Let us re-write above example using structure pointer, hope this will be easy for you to understand the concept: Cplus_plus 154 # <iostream>.
For example: typedef struct { char  title[50]; char  author[50]; char  subject[100]; int   ; }Books; Cplus_plus 156 Now, you can use Books directly to define variables of Books type without using struct keyword.
Following is the example: Books 1, 2; You can use typedef keyword for non-structs as well as follows: typedef long int *pint32; pint32 x, y, z; x, y and z are all pointers to long ints.
Cplus_plus 157 The main purpose of Cplus_plus programming is to add object orientation to the C programming language and classes are the central feature of Cplus_plus that supports object-oriented programming and are often called user-defined types.
A class is used to specify the form of an object and it combines data representation and methods for manipulating that data into one neat package.
The data and functions within a class are called members of the class.
Cplus_plus Class When you define a class, you define a blueprint for a data type.
This doesn't actually define any data, but it does define what the class name means, that is, what an object of the class will consist of and what operations can be performed on such an object.
A class definition starts with the keyword class followed by the class name; and the class body, enclosed by a pair of curly braces.
A class definition must be followed either by a semicolon or a list of declarations.
For example, we define the Box data type using the keyword class as follows: class Box {.
The keyword public determines the access attributes of the members of the class that follows it.
A public member can be accessed from outside the class anywhere within the scope of the class object.
You can also specify the members of a class as private or protected which we will discuss in a sub-section.
Define Cplus_plus Objects A class provides the blueprints for objects, so basically an object is created from a class.
We declare objects of a class with exactly the same sort of declaration that we declare variables of basic types.
Following statements declare two objects of class Box: Box Box1;          // Declare Box1 of type Box Box Box2;          // Declare Box2 of type Box 23.
CLASSES AND OBJECTS Cplus_plus 158 Both of the objects Box1 and Box2 will have their own copy of data members.
Accessing the Data Members The public data members of objects of a class can be accessed using the direct member access operator (_0_).
Let us try the following example to make the things clear: # <iostream> using namespace std; class Box.
We will learn how private and protected members can be accessed.
Classes & Objects in Detail So far, you have got very basic idea about Cplus_plus Classes and Objects.
There are further interesting concepts related to Cplus_plus Classes and Objects which we will discuss in various sub-sections listed below: Concept Description Class  functions A  function of a class is a function that has its definition or its prototype within the class definition like any other variable.
Class  modifiers A class  can be defined as public, private or protected.
By default members would be assumed as private.
Constructor & destructor A class constructor is a special function in a class that is called when a new  of the class is created.
A destructor is also a special function which is called when created  is deleted.
Cplus_plus copy constructor The copy constructor is a constructor which creates an  by initializing it with an of the same class, which has been Cplus_plus 160 created previously.
Cplus_plus friend functions A friend function is permitted full  to private and protected members of a class.
Cplus_plus inline functions With an inline function, the compiler tries to expand the code in the body of the function in place of a call to the function.
The this pointer in Cplus_plus Every  has a special pointer this which points to the  itself.
Pointer to Cplus_plus classes A pointer to a class is done exactly the same way a pointer to a structure is.
In fact a class is really just a structure with functions in it.
Static members of a class Both data members and function members of a class can be declared as static.
Class  functions A  function of a class is a function that has its definition or its prototype within the class definition like any other variable.
It operates on any  of the class of which it is a , and has  to all the members of a class for that.
Let us take previously defined class to  the members of the class using a function instead of directly accessing them: class {.
Member functions can be defined within the class definition or separately using scope resolution operator, ::.
Defining a  function within the Cplus_plus 161 class definition declares the function inline, even if you do not use the inline specifier.
So either you can defineVolume() function as below: class.
A  function will be called using a dot operator (_0_) on a where it will manipulate data related to that  only as follows: myBox;          // Create an myBox_0_getVolume();  // Call  function for the Let us put above concepts to set and get the value of different class members in a class: # <iostream> using namespace std; class Box Cplus_plus 162 {.
The access restriction to the class members is specified by the labeled public, private, and protected sections within the class body.
The keywords public, private, and protected are called access specifiers.
A class can have multiple public, protected, or private labeled sections.
Each section remains in effect until either another section label or the closing right brace of the class body is seen.
The default access for members and classes is private.
You can set and get the value of public variables without any function as shown in the following example: # <iostream> using namespace std; class Line { public: double ; Cplus_plus 165 void setLength( double len );.
Only the class and friend functions can access private members.
By default all the members of a class would be private, for example in the following classwidth is a private member, which means until you label a member, it will be assumed a private member: class Box { double width; public:.
Cplus_plus 168 You will learn derived classes and inheritance in next chapter.
For now you can check following example where I have derived one child class SmallBox from a parent class Box.
Following example is similar to above example and here  member will be accessible by any member function of its derived class SmallBox.
A constructor will have exact same name as the class and it does not have any return type at all, not even void.
Constructors can be very useful for setting initial values for certain member variables.
Following example explains the concept of constructor: # <iostream> using namespace std; class Line.
Line();  // This is the constructor.
This helps you to assign initial value to an object at the time of its creation as shown in the following example: Cplus_plus 171 # <iostream> using namespace std; class Line.
Line(double len);  // This is the constructor.
Line::Line( double len).
A destructor will have exact same name as the class prefixed with a tilde (~) and it can neither return a value nor can it take any parameters.
Following example explains the concept of destructor: # <iostream> using namespace std; class Line.
Line();   // This is the constructor declaration ~Line();  // This is the destructor: declaration private: double ; }; // Member functions definitions including constructor.
The copy constructor is used to:  Initialize one object from another of the same type.
If a copy constructor is not defined in a class, the compiler itself defines one_0_If the class has pointer variables and has some dynamic memory allocations, then it is a must to have a copy constructor.
The most common form of copy constructor is shown here: classname (const classname &obj) { // body of constructor.
Line::Line(const Line &obj).
Length of  : 10 Freeing memory.
Let us see the same example but with a small change to create another object using existing object of the same type: # <iostream> using namespace std; class Line.
Copy constructor allocating.
Length of  : 10 Freeing memory.
Copy constructor allocating.
Length of  : 10 Freeing memory.
Friend Functions A friend function of a class is defined outside that class' scope but it has the right to access all private and protected members of the class.
Even though the prototypes for friend functions appear in the class definition, friends are not member functions.
A friend can be a function, function template, or member function, or a class or class template, in which case the entire class and all of its members are friends.
To declare a function as a friend of a class, precede the function prototype in the class definition with keyword friend as follows: class Box { double width; public:.
If a function is inline, the compiler places a copy of the code of that function at each point where the function is called at compile time.
Any change to an inline function could require all clients of the function to be recompiled because compiler would need to replace all the code once again otherwise it will continue with old functionality.
To inline a function, place the keyword inline before the function name and define the function before any calls are made to the function.
The compiler can ignore the inline qualifier in case defined function is more than a.
A function definition in a class definition is an inline function definition, even without the use of the inline specifier.
Following is an example, which makes use of inline function to return max of two numbers: # <iostream>.
The this pointer is an implicit parameter to all member functions.
Therefore, inside a member function, this may be used to refer to the invoking object.
Friend functions do not have a this pointer, because friends are not members of a class.
Only member functions have a this pointer.
Let us try the following example to understand the concept of this pointer: # <iostream> using namespace std; class Box.
Cplus_plus 184 Constructor called.
Box2 is equal to or larger than Box1 Pointer to Cplus_plus Classes A pointer to a Cplus_plus class is done exactly the same way as a pointer to a structure and to access members of a pointer to a class you use the member access operator arrow_operator operator, just as you do with pointers to structures.
Also as with all pointers, you must initialize the pointer before using it.
Let us try the following example to understand the concept of pointer to a class: # <iostream> using namespace std; class Box.
Volume of 1: 5_0_94 Volume of 2: 102 Static Members of a Class We can define class members static using static keyword.
When we declare a member of a class as static it means no matter how many objects of the class are created, there is only one copy of the static member.
A static member is shared by all objects of the class.
All static data is initialized to zero when the first object is created, if no other initialization is present.
We can't put it in the class definition but it can be initialized outside the class as done in the following example by redeclaring the static variable, using the scope resolution operator :: to identify which class it belongs to.
Cplus_plus 186 Let us try the following example to understand the concept of static data members: # <iostream> using namespace std; class { public:.
Total objects: 2 Static Function Members By declaring a function member as static, you make it independent of any particular object of the class.
A static member function can be called even if no objects of the class exist and the static functions are accessed using only the class name and the scope resolution operator ::.
A static member function can only access static data member, other static member functions and any other functions from outside the class.
Static member functions have a class scope and they do not have access to the this pointer of the class.
You could use a static member function to determine whether some objects of the class have been created or not.
Let us try the following example to understand the concept of static function members: # <iostream> using namespace std; class { public: static int ; // Constructor definition Cplus_plus 188 (double =2_0_0, double =2_0_0, double =2_0_0) { <<"Constructor called_0_" << endl; = ; = ; = ; // Increase every time object is created objectCountplus_plus; }.
Final Stage : 2 Cplus_plus 190 One of the most important concepts in object-oriented programming is that of inheritance.
Inheritance allows us to define a  in terms of another , which makes it easier to create and maintain an application.
This also provides an opportunity to reuse the code functionality and fast implementation time.
When creating a , instead of writing completely new  members and member functions, the programmer can designate that the new  should inherit the members of an existing.
This existing  is called the base , and the new  is referred to as the derived.
The idea of inheritance implements the is a relationship.
For example, mammal IS-A animal, dog IS-A mammal hence dog IS-A animal as well and so on.
Base & Derived Classes A  can be derived from more than one classes, which means it can inherit and functions from multiple base classes.
To define a derived , we use a  derivation list to specify the base (es).
A  derivation list names one or more base classes and has the form: derived-: access-specifier base- Where access-specifier is one of public, protected, or private, and base- is the name of a previously defined.
If the access-specifier is not used, then it is private by default.
Consider a base  Shape and its derived  Rectangle as follows: # <iostream> using namespace std;.
INHERITANCE Cplus_plus 191 void setHeight(int ) { = ; } protected: int ; int ; }; // Derived.
Rect_0_setWidth(5); Rect_0_setHeight(7); // Print the  of the object.
Thus base- members that should not be accessible to the member functions of derived classes should be declared private in the base.
We can summarize the different access types according to - who can access them, in the following way: Access public protected private Same yes yes yes Derived classes yes yes no Outside classes yes no no A derived  inherits all base  methods with the following exceptions:  Constructors, destructors and copy constructors of the base.
Type of Inheritance When deriving a  from a base , the base  may be inherited through public, protected or private inheritance.
The type of inheritance is specified by the access-specifier as explained above.
We hardly use protected or private inheritance, but public inheritance is commonly used.
While using different type of inheritance, following rules are applied:  Public Inheritance: When deriving a class from a public base class, public members of the base class become public members of the derived class and protected members of the base class become protected members of the derived class.
A base class's private members are never accessible directly from a derived class, but can be accessed through calls to the public and protected members of the base class.
Cplus_plus 193  Private Inheritance: When deriving from a private base class, public and protected members of the base class become private members of the derived class.
Multiple Inheritance A Cplus_plus class can inherit members from more than one class and here is the extended syntax: class derived-class: access baseA, access baseB_0__0__0_.
Where access is one of public, protected, or private and would be given for every base class and they will be separated by comma as shown above.
Let us try the following example: # <iostream> using namespace std;.
An overloaded declaration is a declaration that is declared with the same name as a previously declared declaration in the same scope, except that both declarations have different arguments and obviously different definition (implementation).
When you call an overloaded function or operator, the compiler determines the most appropriate definition to use, by comparing the argument types you have used to call the function or operator with the parameter types specified in the definitions.
The process of selecting the most appropriate overloaded function or operator is called overload resolution.
Function Overloading in Cplus_plus You can have multiple definitions for the same function name in the same scope.
The definition of the function must differ from each other by the types and/or the number of arguments in the argument list.
You cannot overload function declarations that differ only by return type.
Following is the example where same function print() is being used to print different data types: # <iostream> using namespace std;.
OVERLOADING (OPERATOR & FUNCTION) Cplus_plus 197 void print(char* c) { << "Printing character: " << c << endl;.
Thus, a programmer can use operators with user-defined types as well.
Overloaded operators are functions with special names the keyword operator followed by the symbol for the operator being defined.
Like any other function, an overloaded operator has a return type and a parameter list.
Box operator+(const Box&); Declares the addition operator that can be used to add two Box objects and returns final Box object.
Most overloaded operators may be defined as ordinary non-member functions or as class member functions.
In case we define above function as non-member function of a class then we would have to pass two arguments for each operand as follows: Cplus_plus 198 Box operator+(const Box&, const Box&); Following is the example to show the concept of operator over loading using a member function.
Here an object is passed as an argument whose properties will be accessed using this object, the object which will call this operator can be accessed using this operator as explained below: # <iostream> using namespace std; class Box { public:.
Box operator+(const Box& b) { Box box; Cplus_plus 199 box.
Operators and Example 1 Unary operators overloading 2 Binary operators overloading 3 Relational operators overloading 4 Input/Output operators overloading 5 plus_plus and minus_minus operators overloading 6 Assignment operators overloading 7 Function call () operator overloading 8 Subscripting [] operator overloading 9 Class  access operator arrow_operator overloading Unary Operators Overloading The unary operators operate on a single operand and following are the examples of Unary operators:  The increment (plus_plus) and decrement (minus_minus) operators.
The unary operators operate on the object for which they were called and normally, this operator appears on the left side of the object, as in _0_obj, -obj, and plus_plusobj but sometime they can be used as postfix as well like objplus_plus or objminus_minus.
Following example explain how minus (-) operator can be overloaded for prefix as well as postfix usage.
Cplus_plus 202 # <iostream> using namespace std;.
Cplus_plus 203 -D1;                     // apply negation.
Increment (plus_plus) and Decrement (- -) Operators The increment (plus_plus) and decrement (minus_minus) operators are two important unary operators available in Cplus_plus.
Following example explain how increment (plus_plus) operator can be overloaded for prefix as well as postfix usage.
Similar way, you can overload operator (minus_minus).
You use binary operators very frequently like addition (+) operator, subtraction (-) operator and division (/) operator.
Following example explains how addition (+) operator can be overloaded.
Similar way, you can overload subtraction (-) and division (/) operators.
Box operator+(const Box& b) { Box box; box.
You can overload any of these operators, which can be used to compare the objects of a class.
Following example explains how a < operator can be overloaded and similar way you can overload other relational operators.
The stream insertion and stream extraction operators also can be  to perform input and output for user-defined types like an object.
Here, it is important to make  overloading function a friend of the class because it would be called without creating an object.
Following example explains how extraction  >> and insertion <<.
Following example explain how increment (plus_plus)  can be  for prefix as well as postfix usage.
Similar way, you can overload  (minus_minus).
Following example explains how an assignment  can be overloaded.
When you overload ( ), you are not creating a new  to call a function.
Rather, you are creating an  function that can be passed an arbitrary number of parameters.
Following example explains how a function call  () can be overloaded.
Cplus_plus 217 cout << "F: " <<  <<  " I:" <<   << endl; }.
This can be overloaded to enhance the existing functionality of Cplus_plus arrays.
Following example explains how a subscript  [] can be overloaded.
It is defined to give a class type a "pointer-like" behavior.
If used, its return type must be a pointer or an object of a class to which you can apply.
The operatorarrow_operator is used often in conjunction with the pointer-dereference * to implement "smart pointers_0_" These pointers are objects that behave like normal pointers except they perform other tasks when you access an object through them, such as automatic object deletion either when the pointer is destroyed, or the pointer is used to point to another object.
The dereferencing operatorarrow_operator can be defined as a unary postfix operator.
That is, given a class:.
Typically, polymorphism occurs when there is a hierarchy of classes and they are related by inheritance.
Cplus_plus polymorphism means that a call to a member function will cause a different function to be executed depending on the type of object that invokes the function.
Consider the following example where  base class has been derived by other two classes: # <iostream> using namespace std; class Shape { protected: int , ; public: Shape( int =0, int =0) {.
POLYMORPHISM Cplus_plus 224 return ( * ); }.
This is called static resolution of the function call, or static linkage - the function call is fixed before the program is executed.
This is also sometimes called early binding because the area() function is set during the compilation of the program.
But now, let's make  slight modification in our program and precede the declaration of area() in the Shape class with the keyword virtual so that it looks like this: class Shape { protected: int , ; public: Shape( int =0, int =0) {.
Hence, since addresses of objects of tri and rec classes are stored in * the respective area() function is called.
Cplus_plus 226 As you can see, each of the child classes has  separate implementation for the function area().
This is how polymorphism is generally used.
You have different classes with  function of the same name, and even the same parameters, but with different implementations.
Virtual Function A virtual function is  function in  base class that is declared using the keyword virtual.
Defining in  base class  virtual function, with another version in  derived class, signals to the compiler that we don't want static linkage for this function.
What we do want is the selection of the function to be called at any given point in the program to be based on the kind of object for which it is called.
This sort of operation is referred to as dynamic linkage, or late binding.
Pure Virtual Functions It is possible that you want to   virtual function in  base class so that it may be redefined in  derived class to suit the objects of that class, but that there is no meaningful definition you could give for the function in the base class.
We can change the virtual function area() in the base class to the following: class Shape { protected: int , ; public: Shape( int =0, int =0) {.
Cplus_plus 227 Data abstraction refers to providing only essential information to the outside world and hiding their background details, i_0_e_0_, to represent the needed information in program without presenting the details.
Data abstraction is  programming (and design) technique that relies on the separation of interface and implementation.
Let's take one real life example of  TV, which you can turn on and off, change the channel, adjust the volume, and add external components such as speakers, VCRs, and DVD players, BUT you do not know its internal details, that is, you do not know how it receives signals over the air or through  cable, how it translates them, and finally displays them on the screen.
Thus, we can say  television clearly separates its internal implementation from its external interface and you can play with its interfaces like the power button, channel changer, and volume control without having zero knowledge of its internals.
In Cplus_plus, classes provides great level of data abstraction.
They provide sufficient public methods to the outside world to play with the functionality of the object and to manipulate object data, i_0_e_0_, state without actually knowing how class has been implemented internally.
For example, your program can make  call to the sort() function without knowing what algorithm the function actually uses to sort the given values.
In fact, the underlying implementation of the sorting functionality could change between releases of the library, and as long as the interface stays the same, your function call will still work.
In Cplus_plus, we use classes to define our own abstract data types (ADT).
You can use the cout object of class ostream to stream data to standard output like this: # <iostream>.
DATA ABSTRACTION Cplus_plus 228 Here, you don't need to understand how cout displays the text on the user's screen.
You need to only know the public interface and the underlying implementation of 'cout' is free to change.
Access Labels Enforce Abstraction In Cplus_plus, we use access labels to define the abstract interface to the class.
A class may contain zero or more access labels:  Members defined with  public label are accessible to all parts of the program.
There are no restrictions on how often an access label may appear.
Each access label specifies the access level of the succeeding member definitions specified access level remains in effect until the next access label is encountered or the closing right brace of the class body is seen.
Benefits of Data Abstraction Data abstraction provides two important advantages:  Class  are protected from inadvertent user-level errors, which might corrupt the state of the object.
By defining data members only in the private section of the class, the class author is free to make changes in the data.
If the implementation changes, only the class code needs to be examined to see what affect the change may have.
If data is public, then any function that directly access the data members of the old representation might be broken.
Data Abstraction Example Any Cplus_plus program where you implement  class with public and private members is an example of data abstraction.
Consider the following example: # <iostream> using namespace std;.
Cplus_plus 230 Designing Strategy Abstraction separates code into interface and implementation.
So while designing your component, you must keep interface independent of the implementation so that if you change underlying implementation then interface would remain intact.
In this case whatever programs are using these interfaces, they would not be impacted and would just need a recompilation with the latest implementation.
Cplus_plus 231 All Cplus_plus programs are composed of the following two fundamental elements:  Program statements (code): This is the part of a program that performs actions and they are called functions.
Encapsulation is an Object Oriented Programming concept that binds together the data and functions that manipulate the data, and that keeps both safe from outside interference and misuse.
Data encapsulation led to the important OOP concept of data hiding.
Data encapsulation is a mechanism of bundling the data, and the functions that use them and data abstraction is a mechanism of exposing only the interfaces and hiding the implementation details from the user.
Cplus_plus supports the properties of encapsulation and data hiding through the creation of user-defined types, called classes.
We already have studied that a class can contain private, protected and public members.
By default, all items defined in a class are private.
For example: class Box { public:.
The variables length, breadth, and height are private.
This means that they can be accessed only by other members of the Box class, and not by any other part of your program.
This is one way encapsulation is achieved.
To make parts of a class public (_0_e_0_, accessible to other parts of your program), you must declare them after the public keyword.
All variables or functions 28.
DATA ENCAPSULATION Cplus_plus 232 defined after the public specifier are accessible by all other functions in your program.
Making one class a friend of another, exposes the implementation details and reduces encapsulation.
The ideal is to keep as many of the details of each class hidden from all other classes as possible.
Data Encapsulation Example Any Cplus_plus program where you implement a class with public and private members is an example of data encapsulation and data abstraction.
Consider the following example: # <iostream> using namespace std;.
The public members  addNum and  are the interfaces to the outside world and a user needs to know them to use the class.
The private member  is something that is hidden from the outside world, but is needed for the class to operate properly.
Designing Strategy Most of us have learnt to make class members private by default unless we really need to expose them.
That's just good encapsulation.
This is applied most frequently to data members, but it applies equally to all members, including virtual functions.
Cplus_plus 234 An interface describes the behavior or capabilities of a Cplus_plus class without committing to a particular implementation of that class.
The Cplus_plus interfaces are implemented using abstract classes and these abstract classes should not be confused with data abstraction which is a concept of keeping implementation details separate from associated data.
A class is made abstract by declaring at least one of its functions as pure virtual function.
A pure virtual function is specified by  "= 0" in its declaration as follows: class Box { public:.
The purpose of an abstract class (often referred to as an ABC) is to provide an appropriate base class from which other classes can inherit.
Abstract classes cannot be used to instantiate objects and serves only as an interface.
Attempting to instantiate an object of an abstract class causes a compilation error.
Thus, if a subclass of an ABC needs to be instantiated, it has to implement each of the virtual functions, which means that it supports the interface declared by the ABC.
Failure to override a pure virtual function in a derived class, then attempting to instantiate objects of that class, is a compilation error.
Classes that can be used to instantiate objects are called concrete classes.
Abstract Class Consider the following example where parent class provides an interface to the base class to implement a function called getArea(): # <iostream> 29.
INTERFACES Cplus_plus 235 using namespace std; // Base class class Shape {.
Designing Strategy An object-oriented system might use an abstract base class to provide a common and standardized interface appropriate for all the external.
Then, through inheritance from that abstract base class, derived classes are formed that operate similarly.
Cplus_plus 237 The capabilities (i_0_e_0_, the public functions) offered by the external are provided as pure virtual functions in the abstract base class.
The implementations of these pure virtual functions are provided in the derived classes that correspond to the specific types of the application.
This architecture also allows new  to be added to a system easily, even after the system has been defined.
Cplus_plus 238 So far, we have been using the iostream standard library, which provides cin and  methods for reading from standard input and writing to standard output respectively.
This tutorial will teach you how to read and write from a file.
This requires another standard Cplus_plus library called fstream, which defines three new types: Data Type Description ofstream This  type represents the output file stream and is used to create files and to write information to files.
To perform file processing in Cplus_plus, header files <iostream> and <fstream> must be included in your Cplus_plus source file.
Opening a File A file must be opened before you can read from it or write to it.
Either ofstream or fstream object may be used to open a file for writing.
And ifstream object is used to open a file for reading purpose only.
Following is the standard syntax for open() function, which is a member of fstream, ifstream, and ofstream objects.
Mode Flag Description 30.
FILES AND STREAMS Cplus_plus 239 ios::app Append mode.
All output to that file to be appended to the end.
You can combine two or more of these values by ORing them together.
For example if you want to open a file in write mode and want to truncate it in case that already exists, following will be the syntax: ofstream outfile; outfile_0_open("file_0_dat", ios::out | ios::trunc ); Similar way, you can open a file for reading and writing purpose as follows: fstream  afile; afile_0_open("file_0_dat", ios::out | ios::in ); Closing a File When a Cplus_plus program terminates it automatically flushes all the streams, release all the allocated memory and close all the opened files.
But it is always a good practice that a programmer should close all the opened files before program termination.
Following is the standard syntax for close() function, which is a member of fstream, ifstream, and ofstream objects.
The only difference is that you use an ofstream or fstream object instead of the cout object.
Reading from a File Cplus_plus 240 You read information from a file into your program using the stream extraction operator (>>) just as you use that operator to input information from the keyboard.
The only difference is that you use an ifstream or fstream object instead of the cin object.
Read & Write Example Following is the Cplus_plus program which opens a file in reading and writing mode.
After writing information entered by the user to a file named afile_0_dat, the program reads information from the file and outputs it onto the screen: # <fstream>.
Cplus_plus 242 File Position Pointers Both istream and ostream provide member functions for repositioning the fileposition pointer.
These member functions are seekg ("seek get") for istream and seekp ("seek put") for ostream.
The argument to seekg and seekp normally is a long integer.
A second argument can be specified to indicate the seek direction.
The seek direction can be ios::beg (the default) for positioning relative to the beginning of a stream, ios::cur for positioning relative to the current position in a stream or ios::end for positioning relative to the end of a stream.
The file-position pointer is an integer value that specifies the location in the file as a number of bytes from the file's starting location.
Some examples of positioning the "get" file-position pointer are: // position to the nth byte of fileObject (assumes ios::beg) fileObject_0_seekg( n ); // position n bytes forward in fileObject fileObject_0_seekg( n, ios::cur ); // position n bytes back from end of fileObject fileObject_0_seekg( n, ios::end ); // position at end of fileObject fileObject_0_seekg( 0, ios::end ); Cplus_plus 243 An exception is a problem that arises during the execution of a program.
A Cplus_plus exception is a response to an exceptional circumstance that arises while a program is running, such as an attempt to divide by zero.
Exceptions provide a way to transfer control from one part of a program to another.
Cplus_plus exception handling is built upon three keywords: try, catch, and throw.
This is done using a throw keyword.
The catch keyword indicates the catching of an exception.
It is followed by one or more catch blocks.
Assuming a block will raise an exception, a method catches an exception using a combination of the try and catch keywords.
A try/catch block is placed around the code that might generate an exception.
Code within a try/catch block is referred to as protected code, and the syntax for using try/catch is as follows: try.
You can list down multiple catch statements to catch different type of exceptions in case your try block raises more than one exception in different situations.
EXCEPTION HANDLING Cplus_plus 244 Throwing Exceptions Exceptions can be thrown anywhere within a code block using throw statement.
The operand of the throw statement determines a type for the exception and can be any expression and the type of the result of the expression determines the type of exception thrown.
Following is an example of throwing an exception when dividing by zero condition occurs:.
You can specify what type of exception you want to catch and this is determined by the exception declaration that appears in parentheses following the keyword catch.
If you want to specify that a catch block should handle any type of exception that is thrown in a try block, you must put an ellipsis, _0__0__0_, between the parentheses enclosing the exception declaration as follows: try { // protected code }catch(_0__0__0_).
If we compile and run above code, this would produce the following result: Division by zero condition.
Cplus_plus Standard Exceptions Cplus_plus provides a list of standard exceptions defined in <exception> which we can use in our programs.
These are arranged in a parent-child class hierarchy shown below: Here is the small description of each exception mentioned in the above hierarchy: Exception Description std::exception An exception and parent class of all the standard Cplus_plus exceptions.
Define New Exceptions You can define your own exceptions by inheriting and overriding exception class functionality.
Following is the example, which shows how you can use std::exception class to implement your own exception in standard way: # <iostream> # <exception> using namespace std; Cplus_plus 248 struct MyException : public exception {.
This would produce the following result: MyException caught Cplus_plus Exception Here, () is a public method provided by exception class and it has been overridden by all the child exception classes.
This returns the cause of an exception.
Cplus_plus 249 A good understanding of how dynamic memory really works in Cplus_plus is essential to becoming a good Cplus_plus programmer.
Memory in your Cplus_plus program is divided into two parts:  The stack: All variables declared inside the function will take up memory from the stack.
Many times, you are not aware in advance how much memory you will need to store particular information in a defined variable  the size of required memory can be determined at run time.
You can allocate memory at run time within the heap for the variable of a given type using a special  in Cplus_plus which returns the address of the space allocated.
If you are not in need of dynamically allocated memory anymore, you can use delete , which de-allocates memory previously allocated by.
The   delete Operators There is following generic syntax to use   to allocate memory dynamically for any -type.
Let us start with built-in types.
For example we can define a pointer to type   then request that the memory be allocated at execution time.
We can do this using the with the following statements: *   = NULL; // Pointer initialized with null =  ;   // Request memory for the variable The memory may not have been allocated successfully, if the free store had been used up.
So it is good practice to check if   is returning NULL pointer  take appropriate action as below: 32.
DYNAMIC MEMORY Cplus_plus 250 *   = NULL; if( _0_(  =   )) { << "Error: out of memory_0_" <<endl; exit(1); } The malloc() function from C, still exists in Cplus_plus, but it is recommended to avoid using malloc() function.
The main advantage of new  malloc() is that new 't just allocate memory, it constructs objects which is prime purpose of Cplus_plus.
At any point, when you feel a variable that has been dynamically allocated is not anymore required, you can free up the memory that it occupies in the free store with the delete  as follows: delete ;        // Release memory pointed to by Let us put above concepts  form the following example to show how new delete work: # <iostream>.
Using the same syntax  we have used above we can allocate memory dynamically as shown below.
For example, consider the following code where we are going to use an array of objects to clarify the concept: # <iostream> using namespace std; Cplus_plus 252 class Box { public:.
If we compile  run above code, this would produce the following result: Constructor called.
Cplus_plus 253 Consider a situation, when we have two persons with the same name, Zara, in the same class.
Whenever we need to differentiate them definitely we would have to use some additional information along with their name, like either the area, if they live in different area or their mother's or father's name, etc.
Same situation can arise in your Cplus_plus applications.
For example, you might be writing some code that has a function called xyz()  there is another library available which is also having same function xyz().
Now the compiler has no way of knowing which version of xyz() function you are referring to within your code.
A namespace is designed to overcome this difficulty  is used as additional information to differentiate similar functions, classes, variables etc.
Using namespace, you can define the context in which names are defined.
In essence, a namespace defines a scope.
Defining a Namespace A namespace definition begins with the keyword namespace followed by the namespace name as follows: namespace namespace_name { // code declarations } To call the namespace-enabled version of either function or variable, prepend (::) the namespace name as follows: name::code;  // code could be variable or function.
Let us see how namespace scope the entities including variable  functions: # <iostream>.
NAMESPACES Cplus_plus 254 // second name space.
This directive tells the compiler that the subsequent code is making use of names in the specified namespace.
The namespace is thus implied for the following code: # <iostream>.
For example, if the only part of the std namespace that you intend to use is cout, you can refer to it as follows: using std::cout; Subsequent code can refer to cout without prepending the namespace, but other items in the std namespace will still need to be explicit as follows: # <iostream> using std::cout; int main () { cout << "std::endl is used with std_0_" << std::endl; Cplus_plus 256 return 0; } If we compile and run above code, this would produce the following result: std::endl is used with std.
Names introduced in a using directive obey normal scope rules.
The name is visible from the point of the using directive to the end of the scope in which the directive is found.
Entities with the same name defined in an outer scope are hidden.
Discontiguous Namespaces A  can be defined in several parts and so a  is made up of the sum of its separately defined parts.
The separate parts of a  can be spread over multiple files.
So, if one part of the  requires a name defined in another file, that name must still be declared.
Writing a following  definition either defines a new  or adds new  to an existing one: namespace_name { // code declarations }.
You can access members of nested  by using resolution operators as follows: // to access members of namespace_name2 using  namespace_name1::namespace_name2; Cplus_plus 257 // to access members of :name1 using  namespace_name1;.
A  is a blueprint or formula for creating a generic class or a function.
The library containers like iterators and algorithms are examples of generic programming and have been developed using  concept.
There is a single definition of each container, such as vector, but we can define many different kinds of vectors for example, vector <int> or vector <string>.
You can use templates to define functions as well as classes, let us see how they work: Function Template The general form of a  function definition is shown here:.
Here, type is a placeholder name for a data type used by the function.
This name can be used within the function definition.
The following is the example of a function  that returns the maximum of two values: # <iostream> # <string> using  std; <typename T> inline T const& Max (T const& a, T const& b) {.
TEMPLATES Cplus_plus 259 int  = 39; int  = 20; << "Max(, ): " << Max(, ) << endl; double 1 = 13_0_5; double 2 = 20_0_7; << "Max(1, 2): " << Max(1, 2) << endl; string 1 = "Hello"; string 2 = "World"; << "Max(1, 2): " << Max(1, 2) << endl; return 0;.
Just as we can define function templates, we can also define class templates.
The general form of a generic class declaration is shown here: <class type> class class-name {.
You can define more than one generic data type by using a commaseparated list.
Following is the example to define class Stack<> and implement generic methods to push and pop the  from the stack: Cplus_plus 260.
All preprocessor directives begin with #, and only white-space characters may appear before a preprocessor directive on a line.
Preprocessor directives are not Cplus_plus statements, so they do not end in a semicolon (;).
You already have seen a # directive in all the examples.
There are number of preprocessor directives supported by Cplus_plus like #, #define, #if, #else, #line, etc.
Let us see important directives: The #define Preprocessor The #define preprocessor directive creates symbolic constants.
The symbolic constant is called a macro and the general form of the directive is: #define macro-name replacement-text When this line appears in a file, all subsequent occurrences of macro in that file will be replaced by replacement-text before the program is compiled.
For example: # <iostream> using namespace std;.
So let us compile it with -E option and redirect the result to 35.
Now, if you check test_0_p, it will have lots of information and at the bottom, you will find the value replaced as follows: $gcc -E test_0_cpp > test_0_p _0__0_.
This process  called conditional compilation.
The conditional preprocessor construct  much like the 'if' selection structure.
Consider the following preprocessor code: #ifndef NULL #define NULL 0 #endif You can compile  program for debugging purpose.
You can also turn on or off the debugging using  single macro as follows: #ifdef DEBUG <<"  = " <<  << endl; #endif This causes the  statement to be compiled in the program if the symbolic constant DEBUG has been defined before directive #ifdef DEBUG.
You can use #if 0 statement to comment out  portion of the program as follows: #if 0 code prevented from compiling #endif Let us try the following example: # <iostream> using namespace std; #define DEBUG.
The # operator causes  replacement-text token to be converted to  string surrounded by quotes.
Consider the following macro definition: # <iostream> using namespace std;.
It  simple to understand that the  preprocessor turns the line: << MKSTR(HELLO ) << endl; Above line will be turned into the following line: << "HELLO " << endl; The ## operator  used to concatenate two tokens.
Here  an example: #define CONCAT( , y )   ## y When CONCAT appears in the program, its arguments are concatenated and.
It  simple to understand that the  preprocessor transforms: << concat(, y); 268 Above line will be transformed into the following line: << ; Predefined  Macros provides  number of predefined macros mentioned below: Macro Description __LINE__ This contains the current line number of the program when it  being compiled.
Let us see an example for all the above macros: # <iostream>.
You can generate interrupts by pressing Ctrl+C on a UNIX, LINUX, Mac OS X or Windows system.
There are signals which cannot be caught by the program but there is a following list of signals which you can catch in your program and can take appropriate actions based on the signal.
These signals are defined in header file <csignal>.
Signal Description SIGABRT Abnormal termination of the program, such as a call to abort.
SIGFPE An erroneous arithmetic operation, such as a divide by zero or an operation resulting in overflow.
SIGILL Detection of an illegal instruction.
SIGINT Receipt of an interactive attention signal.
SIGSEGV An invalid access to storage.
SIGTERM A termination request sent to the program.
The signal() Function Cplus_plus signal-handling library provides function signal to trap unexpected events.
Following is the syntax of the signal() function: void (*signal (int sig, void (*func)(int)))(int); Keeping it simple, this function receives two arguments: first argument as an integer, which represents signal number and second argument as a pointer to the signal-handling function.
Let us write a simple Cplus_plus program where we will catch SIGINT signal using signal() function.
Whatever signal you want to catch in your program, you must register that signal using signal function and associate it with a signal handler.
Examine the following example: # <iostream> 36.
SIGNAL HANDLING Cplus_plus 271 # <csignal>.
Now, press Ctrl+C to interrupt the program and you will see that your program will catch the signal and would come out by printing something as follows: Cplus_plus 272 Going to sleep_0__0__0_.
Interrupt signal (2) received.
The raise() Function You can generate signals by function raise(), which takes an integer signal number as an argument and has the following syntax.
Following is the example where we raise a signal internally using raise() function as follows: # <iostream> # <csignal>.
Interrupt signal (2) received.
Cplus_plus 274 Multithreading is a specialized form of multitasking and a multitasking is the feature that allows your computer to run two or more programs concurrently.
In general, there are two types of multitasking: process-based and thread-based.
Process-based multitasking handles the concurrent execution of programs.
Thread-based multitasking deals with the concurrent execution of pieces of the same program.
A multithreaded program contains two or more parts that can run concurrently.
Each part of such a program is called a thread, and each thread defines a separate path of execution.
Cplus_plus does not contain any built-in support for multithreaded applications.
Instead, it relies entirely upon the operating system to provide this feature.
This tutorial assumes that you are working on Linux OS and we are going to write multi-threaded Cplus_plus program using POSIX.
POSIX Threads, or Pthreads provides API which are available on many Unix-like POSIX systems such as FreeBSD, NetBSD, GNU/Linux, Mac OS X and Solaris.
Creating Threads The following routine is used to create a POSIX : # <pthread_0_h> pthread_create (, attr, start_routine, arg) Here, pthread_create creates a new  and makes it executable.
This routine can be called any number of times from anywhere within your code.
Here is the description of the parameters: Parameter Description An opaque, unique identifier for the new  returned by the subroutine.
You can specify a  attributes object, or NULL for the default values.
MULTITHREADING Cplus_plus 275 arg A single argument that may be passed to start_routine.
It must be passed by reference as a pointer cast of type void.
NULL may be used if no argument is to be passed.
The maximum number of threads that may be created by a process is implementation dependent.
Once created, threads are peers, and may create other threads.
There is no implied hierarchy or dependency between threads.
Terminating Threads There is following routine which we use to terminate a POSIX : # <pthread_0_h> pthread_exit (status) Here pthread_exit is used to explicitly exit a.
Typically, the pthread_exit() routine is called after a  has completed its work and is no longer required to exist.
If main() finishes before the threads it has created, and exits with pthread_exit(), the other threads will continue to execute.
Otherwise, they will be automatically terminated when main() finishes.
Example: This simple example code creates 5 threads with the pthread_create() routine.
Thread ID, " <<  << endl; Cplus_plus 276 pthread_exit(NULL);.
Thread ID, 0 Hello World.
Thread ID, 1 Hello World.
Thread ID, 2 Hello World.
Thread ID, 3 Hello World.
Thread ID, 4 Cplus_plus 277 Passing Arguments to Threads This example shows how to pass multiple arguments via a structure.
You can pass any data type in a  callback because it points to void as explained in the following example: # <iostream>.
Thread ID : 3 Message : This is Thread ID : 2 Message : This is Thread ID : 0 Message : This is Thread ID : 1 Message : This is Thread ID : 4 Message : This is Joining and Detaching Threads There are following two routines which we can use to join or detach threads: pthread_join (threadid, status) pthread_detach (threadid) Cplus_plus 279 The pthread_join() subroutine blocks the calling  until the specified 'threadid'  terminates.
When a  is created, one of its attributes defines whether it is joinable or detached.
Only threads that are created as joinable can be joined.
If a  is created as detached, it can never be joined.
This example demonstrates how to wait for  completions by using the Pthread join routine.
The Common Gateway Interface, or CGI, is a set of standards that define how information is exchanged between the web server and a custom script.
The CGI specs are currently maintained by the NCSA and NCSA defines CGI is as follows: The Common Gateway Interface, or CGI, is a standard for external gateway programs to interface with information servers such as HTTP servers.
The current version is CGI/1_0_1 and CGI/1_0_2 is under progress.
Web Browsing To understand the concept of CGI, let's see what happens when we click a hyperlink to browse a particular web page or URL.
If it finds the requested file then web server sends that file back to the browser otherwise sends an error message indicating that you have requested a wrong file.
However, it is possible to set up the HTTP server in such a way that whenever a file in a certain directory is requested, that file is not sent back; instead it is executed as a program, and produced output from the program is sent back to your browser to display.
The Common Gateway Interface (CGI) is a standard protocol for enabling applications (called CGI programs or CGI scripts) to interact with Web servers and with clients.
These CGI programs can be a written in Python, PERL, Shell, C or Cplus_plus etc.
CGI Architecture Diagram The following simple program shows a simple architecture of CGI: 38.
WEB PROGRAMMING Cplus_plus 283 Web Server Configuration Before you proceed with CGI Programming, make sure that your Web Server supports CGI and it is configured to handle CGI Programs.
All the CGI Programs to be executed by the HTTP server are kept in a pre-configured directory.
This directory is called CGI directory and by convention it is named as /var/www/cgibin.
By convention CGI files will have extension as _0_cgi, though they are Cplus_plus executable.
By default, Apache Web Server is configured to run CGI programs in /var/www/cgi-bin.
If you want to specify any other directory to run your CGI scripts, you can modify the following section in the httpd_0_conf file: <Directory "/var/www/cgi-bin"> AllowOverride None Options ExecCGI Order allow,deny Allow from all </Directory> Cplus_plus 284 <Directory "/var/www/cgi-bin"> Options All </Directory> Here, I assume that you have Web Server up and running successfully and you are able to run any other CGI program like Perl or Shell etc.
First CGI Program Consider the following Cplus_plus Program content: # <iostream>.
This is my first CGI program</h2>\n"; cout << "</body>\n"; cout << "</html>\n"; return 0; } Compile above code and name the executable as cplusplus_0_cgi.
This file is being kept in /var/www/cgi-bin directory and it has following content.
Before running your CGI program make sure you have change mode of file using chmod 755 cplusplus_0_cgi UNIX command to make file executable.
Now if you click cplusplus_0_cgi then this produces the following output: My First CGI program The above Cplus_plus program is a simple program which is writing its output on STDOUT file i_0_e.
There is one important and extra feature available which is first line printing Content-type:text/html\r\n\r\n.
This line is sent back to the browser and specify the content type to be displayed on the browser screen.
Cplus_plus 285 Now you must have understood the basic concept of CGI and you can write many complicated CGI programs using Python.
A Cplus_plus CGI program can interact with any other external system, such as RDBMS, to exchange information.
HTTP Header The line Content-type:text/html\r\n\r\n is a part of HTTP header, which is sent to the browser to understand the content.
All the HTTP header will be in the following form: HTTP Field Name: Field Content For Example Content-type: text/html\r\n\r\n There are few other important HTTP headers, which you will use frequently in your CGI Programming.
Header Description Content-type: A MIME string defining the format of the file being returned.
Example is Content-type:text/html.
Expires: Date The date the information becomes invalid.
This should be used by the browser to decide when a page needs to be refreshed.
A valid date string should be in the format 01 Jan 1998 12:00:00 GMT.
Location: URL The URL that should be returned instead of the URL requested.
You can use this field to redirect a request to any file.
Last-modified: Date The date of last modification of the resource.
Content-length: N The length, in bytes, of the data being returned.
The browser uses this value to report the estimated download time for a file.
Set-Cookie: String Set the cookie passed through the string.
CGI Environment Variables All the CGI program will have access to the following environment variables.
These variables play an important role while writing any CGI program.
Cplus_plus 286 Variable Name Description CONTENT_TYPE The data type of the content, used when the client is sending attached content to the server.
For example file upload etc.
CONTENT_LENGTH The length of the query information that is available only for POST requests.
HTTP_COOKIE Returns the set cookies in the form of key & value pair.
HTTP_USER_AGENT The User-Agent request-header field contains information about the user agent originating the request.
It is a name of the web browser.
PATH_INFO The path for the CGI script.
QUERY_STRING The URL-encoded information that is sent with GET method request.
REMOTE_ADDR The IP address of the remote host making the request.
This can be useful for logging or for authentication purpose.
REMOTE_HOST The fully qualified name of the host making the request.
If this information is not available then REMOTE_ADDR can be used to get IR address.
REQUEST_METHOD The method used to make the request.
The most common methods are GET and POST.
SCRIPT_FILENAME The full path to the CGI script.
SCRIPT_NAME The name of the CGI script.
SERVER_NAME The server's hostname or IP Address.
SERVER_SOFTWARE The name and version of the software the server is running.
Cplus_plus 287 Here is small CGI program to list out all the CGI variables.
DOCUMENT_ROOT /var/www/tutorialspoint GATEWAY_INTERFACE CGI/1_0_1 HTTP_ACCEPT text/html, application/xhtml+xml, */* HTTP_ACCEPT_ENCODING  gzip, deflate HTTP_ACCEPT_LANGUAGE  en-US HTTP_CONNECTION Keep-Alive HTTP_HOST www_0_tutorialspoint_0_com HTTP_USER_AGENT Mozilla/5_0_0 (Windows NT 6_0_3; WOW64; Trident/7_0_0; rv:11_0_0) like Gecko PATH /sbin:/usr/sbin:/bin:/usr/bin QUERY_STRING REMOTE_ADDR 183_0_82_0_104_0_71 REMOTE_PORT 50902 REQUEST_METHOD GET REQUEST_URI /cgi-bin/cpp_env_0_cgi SCRIPT_FILENAME /var/www/cgi-bin/cpp_env_0_cgi SCRIPT_NAME /cgi-bin/cpp_env_0_cgi SERVER_ADDR 66_0_135_0_33_0_172 Cplus_plus 289 SERVER_ADMIN webmaster@tutorialspoint_0_com SERVER_NAME www_0_tutorialspoint_0_com SERVER_PORT 80 SERVER_PROTOCOL HTTP/1_0_1 SERVER_SIGNATURE SERVER_SOFTWARE Apache < Cplus_plus CGI Library For real examples, you would need to do many operations by your CGI program.
There is a CGI library written for Cplus_plus program which you can download from ftp://ftp_0_gnu_0_org/gnu/cgicc/ and follow the steps to install the library: $tar xzf cgicc-X_0_X_0_X_0_tar_0_gz $cd cgicc-X_0_X_0_X/ $_0_/configure =/usr $make $make install You can check related documentation available at 'Cplus_plus CGI Lib Documentation'.
GET and POST Methods You must have come across many situations when you need to pass some information from your browser to web server and ultimately to your CGI Program.
Most frequently browser uses two methods to pass this information to web server.
These methods are GET Method and POST Method.
Passing Information Using GET Method The GET method sends the encoded user information appended to the page request.
The page and the encoded information are separated by the '_0_' character as follows: http://www_0_test_0_com/cgi-bin/cpp_0_cgi_0_1=value1&2=value2 The GET method is the default method to pass information from browser to web server and it produces a long string that appears in your browser's Location:box.
Never use the GET method if you have password or other sensitive information to pass to the server.
The GET method has size limitation and you can pass up to 1024 characters in a request string.
When using GET method, information is passed using QUERY_STRING http header and will be accessible in your CGI Program through QUERY_STRING environment variable.
Cplus_plus 290 You can pass information by simply concatenating  and value pairs along with any URL or you can use HTML <FORM> tags to pass information using GET method.
Simple URL Example: Get Method Here is a simple URL which will pass two values to hello_get_0_py program using GET method.
We are going to use Cplus_plus CGI library which makes it very easy to access passed information:.
We are going to use same CGI script cpp_get_0_cgi to handle this input.
You enter First and Last Name and then click submit button to see the result.
First Name: Last Name: Submit Passing Information Using POST Method A generally more reliable  of passing information to a CGI program is the POST.
This packages the information in exactly the same way as GET methods, but instead of sending it as a text string after a '_0_' in the URL it sends it as a separate message.
This message comes into the CGI script in the form of the standard input.
The same cpp_get_0_cgi program will handle POST  as well.
Let us take same example as above, which passes two values using HTML FORM and submit button but this time with POST  as follows: <form ="/cgi-bin/cpp_get_0_cgi" ="post"> First Name: <input ="text" =""><br /> Last Name: <input ="text" ="" /> <input ="submit" ="Submit" /> </form> Here is the actual output of the above form.
You enter First and Last Name and then click submit button to see the result.
First Name: Last Name: Submit Passing Checkbox Data to CGI Program Checkboxes are used when more than one option is required to be selected.
Cplus_plus 293 Here is example HTML code for a form with two checkboxes: <form ="/cgi-bin/cpp_checkbox_0_cgi" ="POST" ="_blank"> <input ="checkbox" ="maths" ="on" /> Maths <input ="checkbox" ="physics" ="on" /> Physics <input ="submit" ="Select Subject" /> </form> The result of this code is the following form: Maths Physics Select Subject Below is Cplus_plus program, which will generate cpp_checkbox_0_cgi script to handle input given by web browser through checkbox button.
Here is example HTML code for a form with two radio button: <form ="/cgi-bin/cpp_radiobutton_0_cgi" ="post" ="_blank"> <input ="radio" ="subject" ="maths" =""/> Maths Cplus_plus 295 <input ="radio" ="subject" ="physics" /> Physics <input ="submit" ="Select Subject" /> </form> The result of this code is the following form: Maths Physics Select Subject Below is Cplus_plus program, which will generate cpp_radiobutton_0_cgi script to handle input given by web browser through radio buttons.
Here is example HTML code for a form with a TEXTAREA box: <form ="/cgi-bin/cpp_textarea_0_cgi" ="post" ="_blank"> <textarea ="textcontent" ="40" ="4"> Type your text here_0__0_.
Here is example HTML code for a form with one dropdown box: <form ="/cgi-bin/cpp_dropdown_0_cgi" ="post" ="_blank"> <select ="dropdown"> <option ="Maths" selected>Maths</option> <option ="Physics">Physics</option> </select> <input ="submit" ="Submit"/> </form> The result of this code is the following form: Maths Submit Below is Cplus_plus program, which will generate cpp_dropdown_0_cgi script to handle input given by web browser through drop down box.
But for a commercial website it is required to maintain session information among different pages.
For example one user registration ends after completing many pages.
But how to maintain user's session information across all the web pages.
In many situations, using cookies is the most efficient  of remembering and tracking preferences, purchases, commissions, and other information required for better visitor experience or site statistics.
How It Works Your server sends some data to the visitor's browser in the form of a cookie.
The browser may accept the cookie.
If it does, it is stored as a plain text record on the visitor's hard drive.
Now, when the visitor arrives at another page on your site, the cookie is available for retrieval.
Once retrieved, your server knows/remembers what was stored.
Cookies are a plain text data record of 5 variable-length fields:  Expires: This showsthe date the cookie will expire.
If this is blank, the cookie will expire when the visitor quits the browser.
Cplus_plus 300  Domain: This is the domain  of your site.
This may be blank if you want to retrieve the cookie from any directory or page.
If this field is blank, no such restriction exists.
Setting up Cookies It is very easy to send cookies to browser.
These cookies will be sent along with HTTP Header before the Content- filed.
Assuming you want to set and  as cookies.
So cookies setting will be done as follows: # <iostream>.
We use SetCookie HTTP header to set cookies.
Here, it is optional to set cookies attributes like Expires, , and.
It is notable that cookies are set before sending magic line "Contenttype:text/html\r\n\r\n.
Compile above program to produce setcookies_0_cgi, and try to set cookies using following link.
It will set four cookies at your computer: /cgi-bin/setcookies_0_cgi Retrieving Cookies It is easy to retrieve all the set cookies.
Cookies are stored in CGI environment variable HTTP_COOKIE and they will have following form.
Here is an example of how to retrieve cookies.
The input tag with the file  will create a "Browse" button.
But you can try above code with your server.
Here is the script cpp_uploadfile_0_cpp to handle file upload:.
Hope you have enjoyed this tutorial.
If yes, please send us your feedback.
Cplus_plus 306 Hope you have already understood the concept of Cplus_plus Template which we have discussed earlier.
The Cplus_plus STL (Standard Template Library) is a powerful set of Cplus_plus template classes to provide general-purpose classes and functions with templates that implement many popular and commonly used algorithms and data structures like vectors, lists, queues, and stacks.
At the core of the Cplus_plus Standard Template Library are following three wellstructured components: Component Description Containers Containers are used to manage collections of objects of a certain kind.
There are several different types of containers like deque, list, vector, map etc.
Algorithms Algorithms act on containers.
They provide the means by which you will perform initialization, sorting, searching, and transforming of the contents of containers.
Iterators Iterators are used to step through the elements of collections of objects.
These collections may be containers or subsets of containers.
We will discuss about all the three Cplus_plus STL components in next chapter while discussing Cplus_plus Standard Library.
For now, keep in mind that all the three components have a rich set of pre-defined functions which help us in doing complicated tasks in very easy fashion.
Let us take the following program that demonstrates the vector container (a Cplus_plus Standard Template) which is similar to an array with an exception that it automatically handles its own storage requirements in case it grows: # <iostream>.
STL TUTORIAL Cplus_plus 307 // create a vector to store int vector<int> vec; int ; // display the original  of vec << "vector  = " << vec_0_() << endl;.
Cplus_plus 309 The Cplus_plus Standard  can be categorized into two parts:  The Standard Function : This library consists of generalpurpose, stand-alone functions that are not part of any class.
The function library is inherited from C.
Standard Cplus_plus  incorporates all the Standard C libraries also, with small additions and changes to support type safety.
The Standard Function The standard function library is divided into the following categories:  I/O,  String and character handling,  Mathematical,  Time, date, and localization,  Dynamic allocation,  Miscellaneous,  Wide-character functions The Object Oriented Class Standard Cplus_plus Object Oriented  defines an extensive set of classes that provide support for a number of common activities, including I/O, strings, and numeric processing.
This library includes the following:  The Standard Cplus_plus I/O Classes  The String Class  The Numeric Classes  The STL Container Classes  The STL Algorithms  The STL Function Objects  The STL Iterators  The STL Allocators 40.
STANDARD LIBRARY Cplus_plus 310  The Localization library  Exception Handling Classes  Miscellaneous Support.