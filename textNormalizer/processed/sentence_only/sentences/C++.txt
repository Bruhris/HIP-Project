A Complete Guide to Programming in Cplus_plus Ulla Kirch-Prinz Peter Prinz JONES AND BARTLETT PUBLISHERS Ulla Kirch-Prinz Peter Prinz A Complete Guide to Programming in Cplus_plus World Headquarters Jones and Bartlett Publishers 40 Tall Pine Drive Sudbury, MA 01776 978-443-5000 info@jbpub_0_com www_0_jbpub_0_com Jones and Bartlett Publishers Canada 2406 Nikanna Road Mississauga, ON L5C 2W6 CANADA Jones and Bartlett Publishers International Barb House, Barb Mews London W6 7PA UK Copyright © 2002 by Jones and Bartlett Publishers, Inc.
All rights reserved.
No part of the material protected by this copyright notice may be reproduced or utilized in any form, electronic or mechanical, including photocopying, recording, or any information storage or retrieval system, without written permission from the copyright owner.
Cover Image: Stones on shore-line and yellow leaf, Bjorkliden, Sweden, by Peter Lilja Library of Congress Cataloging-in-Publication Data Prinz, Peter.
English] A complete guide to programming in Cplus_plus / Peter Prinz, Ulla Kirch-Prinz; translated by Ian Travis.
ISBN: 0-7637-1817-3 I.
QA76_0_73_0_C153 P73713 2001 005_0_13'3—dc21 2001029617 2090 Chief Executive Officer:  Clayton Jones Chief Operating Officer:  Don W.
V_0_P_0_, Managing Editor:  Judith H.
Hauck V_0_P_0_, Design and Production:  Anne Spencer V_0_P_0_, Manufacturing and Inventory Control:  Therese Bräuer Editor-in-Chief: Michael Stranz Development and Product Manager: Amy Rose Marketing Manager: Nathan Schultz Production Assistant: Tara McCormick Cover Design: Night & Day Design Composition: Northeast Compositors Text Design: Mary McKeon Printing and Binding: Courier Westford Cover printing: John Pow Company, Inc.
This book was typeset in QuarkXpress 4_0_11 on a Macintosh G4.
The font families used were Goudy, Gill Sans, Courier, Rubino Serif, and Seven Sans.
The first printing was printed on 50 lb.
Printed in the United States of America 05  04  03  02  01       10  9  8  7  6  5  4  3  2  1 Dedicated to our children, Vivi and Jeany This page intentionally left blank v This book was written for readers interested in learning the Cplus_plus programming language from scratch, and for both novice and advanced Cplus_plus programmers wishing to enhance their knowledge of Cplus_plus.
It was our goal from the beginning to design this text with the capabilities of serving dual markets, as a textbook for students and as a holistic reference manual for professionals.
The Cplus_plus language definition is based on the American National Standards Institute ANSI Standard X3J16.
This standard also complies with ISO norm 14882, which was ratified by the International Standardization Organization in 1998.
The Cplus_plus programming language is thus platform-independent in the main with a majority of Cplus_plus compilers providing ANSI support.
New elements of the Cplus_plus language, such as exception handling and templates, are supported by most of the major compilers.
Visit the Jones and Bartlett web site at www_0_jbpub_0_com for a listing of compilers available for this text.
The chapters in this book are organized to guide the reader from elementary language concepts to professional software development, with in-depth coverage of all the Cplus_plus language elements en route.
The order in which these elements are discussed reflects our goal of helping the reader to create useful programs at every step of the way.
This type of visual representation offered by each spread will provide students and professionals with an unmatched guide throughout the text.
The sample programs were chosen to illustrate a typical application for each language element.
In addition, filter programs and case studies introduce the reader to a wide range of application scenarios.
To gain command over a programming language, students need a lot of experience in developing programs.
Thus, each chapter includes exercises followed by sample solutions, allowing the reader to test and enhance his or her performance and understanding of Cplus_plus.
The appendix provides further useful information, such as binary number representation, pre-processor directives, and operator precedence tables, making this book a wellstructured and intelligible reference guide for Cplus_plus programmers.
In order to test and expand your acquired knowledge, you can download sample programs and solutions to the exercises at: http://completecpp_0_jbpub_0_com Content Organization Chapter 1 gives a thorough description of the fundamental characteristics of the objectoriented Cplus_plus programming language.
In addition, students are introduced to the steps necessary for creating a fully functional Cplus_plus program.
Many examples are provided to help enforce these steps and to demonstrate the basic structure of a Cplus_plus program.
Chapter 2 provides a complete introduction to the basic types and objects used by Cplus_plus programs.
Integral types and constants, fundamental types, and Boolean constants are just a few of the topics discussed.
Chapter 3 describes how to declare and call standard functions.
This chapter also teaches students to use standard classes, including standard header files.
In addition, students work with string variables for the first time in this chapter.
Chapter 4 explains the use of streams for input and output, with a focus on formatting techniques.
Formatting flags and manipulators are discussed, as are field width, fill characters, and alignment.
Chapter 5 introduces operators needed for calculations and selections.
Binary, unary, relational, and logical operators are all examined in detail.
Chapter 6 describes the statements needed to control the flow of a program.
These include loops with while, do-while, and for; selections with if-else, switch, and the conditional operator; and jumps with goto, continue, and break.
Chapter 7 provides a thorough introduction to the definition of symbolic constants and macros, illustrating their significance and use.
Furthermore, a comprehensive examination of standard macros for character handling is included.
Chapter 8 introduces implicit type conversions, which are performed in Cplus_plus whenever different arithmetic types occur in expressions.
Additionally, the chapter explores an operator for explicit type conversion.
In addition to defining strings, the chapter looks at the various methods of string manipulation.
These include inserting and erasing, searching and replacing, comparing, and concatenating strings.
Chapter 10 describes how to write functions of your own.
The basic rules are covered, as are passing arguments, the definition of inline functions, overloading functions and default arguments, and the principle of recursion.
Chapter 11 gives a thorough explanation of storage classes for objects and functions.
Object lifetime and scope are discussed, along with global, static, and auto objects.
Namespaces and external and static functions are also included in the discussion.
Chapter 12 explains how to define references and pointers and how to use them as parameters and/or return values of functions.
In this context, passing by reference and read-only access to arguments are introduced.
Chapter 13 provides a complete description of how classes are defined and how instances of classes, or objects, are used.
In addition, structs and unions are introduced as examples of special classes.
Chapter 14 describes how constructors and destructors are defined to create and destroy objects.
Also discussed are how inline methods, access methods, and read-only methods can be used.
Furthermore, the chapter explains the pointer this, which is available for all methods, and what you need to pay attention to when passing objects as arguments or returning objects.
Chapter 15 gives a complete explanation of member objects and how they are initialized, and of data members that are created only once for all the objects in a class.
In addition, this chapter describes constant members and enumerated types.
Chapter 16 takes an in-depth look at how to define and use arrays.
Of particular interest are one-dimensional and multidimensional arrays, C strings, and class arrays.
Chapter 17 describes the relationship between pointers and arrays.
This includes pointer arithmetic, pointer versions of functions, pointers as return values and read-only pointers, and pointer arrays.
Students learn that operations that use C strings illustrate how to use pointers for efficient programming, and that string access via the command line of an application program is used to illustrate pointer arrays.
Chapter 18 explains sequential file access using file streams.
Students will develop an understanding of how file streams provide simple and portable file handling techniques.
Chapter 19 provides a complete description of the various uses of overloaded operators.
Arithmetic operators, comparisons, the subscript operator, and the shift operators for input and output are overloaded to illustrate the appropriate techniques.
In addition, the concept of friend functions, which is introduced in this context, is particularly important for overloading operators.
Students learn how overloading operators allows them to apply existing operators to objects of class type.
Chapter 20 discusses how implicit type conversion occurs in Cplus_plus when an expression cannot be compiled directly but can be compiled after applying a conversion rule.
The programmer can stipulate how the compiler will perform implicit type conversion for classes by defining conversion constructors and functions.
Finally, the chapter discusses ambiguity that occurs due to type conversion and how to avoid it.
PREFACE ■ vii Chapter 21 describes how a program can allocate and release memory dynamically in line with current memory requirements.
Dynamic memory allocation is an important factor in many Cplus_plus programs, and the following chapters contain several case studies to help students review the subject.
Chapter 22 explains how to implement classes containing pointers to dynamically allocated memory.
These include your own copy constructor definition and overloading the assignment operator.
A class designed to represent arrays of any given length is used as a sample application.
Chapter 23 provides a thorough description of how derived classes can be constructed from existing classes by inheritance.
In addition to defining derived classes, this chapter discusses how members are redefined, how objects are constructed and destroyed, and how access control to base classes can be realized.
Chapter 24 discusses implicit type conversion within class hierarchies, which occurs in the context of assignments and function calls.
Explicit type casting in class hierarchies is also described, paying particular attention to upcasting and downcasting.
Chapter 25 gives a complete explanation of how to develop and manage polymorphic In addition to defining virtual functions, dynamic downcasting in polymorphic class hierarchies is introduced.
Chapter 26 describes how defining pure virtual methods can create abstract and how you can use abstract  at a polymorphic interface for derived.
To illustrate this, an inhomogeneous list, that is, a linked list whose elements can be of various class types, is implemented.
Chapter 27 describes how new  are created by multiple inheritance and explains their uses.
Besides introducing students to the creation and destruction of objects in multiply-derived , virtual base  are depicted to avoid ambiguity in multiple inheritance.
Chapter 28 explains how a Cplus_plus program uses error-handling techniques to resolve error conditions.
In addition to throwing and catching exceptions, the chapter also examines how exception specifications are declared and exception  are defined.
In addition, the use of standard exception  is discussed.
Chapter 29 examines random access to files based on file streams, and options for querying file state.
Exception handling for files is discussed as well.
The chapter illustrates how to make objects in polymorphic  persistent, that is, how to save them in files.
The applications introduced in this chapter include simple index files and hash tables.
Chapter 30 provides a thorough explanation of the advanced uses of pointers.
These include pointers to pointers, functions with a variable number of arguments, and pointers to functions.
In addition, an application that defines a class used to represent dynamic matrices is introduced.
Chapter 31 describes bitwise operators and how to use bit masks.
The applications included demonstrate calculations with parity bits, conversion of lowercase and capital letters, and converting binary numbers.
Finally, the definition of bit-fields is introduced.
Chapter 32 discusses how to define and use function and class templates.
In addition, special options, such as default arguments, specialization, and explicit instantiation, are viii ■ P R E F A C E discussed.
Students learn that templates allow the construction of functions and based on types that have not yet been stated.
Thus, templates are a powerful tool for automating program code generation.
Chapter 33 explains standard class templates used to represent containers for more efficient management of object collections.
These include sequences, such as lists and double ended queues; container adapters, such as stacks, queues, and priority queues; associative containers, such as sets and maps; and bitsets.
In addition to discussing how to manage containers, the chapter also looks at sample applications, such as bitmaps for raster images, and routing techniques.
Additional Features Chapter Goals A concise chapter introduction, which contains a description of the chapter's contents, is presented at the beginning of each chapter.
These summaries also provide students with an idea of the key points to look for throughout the chapter.
Chapter Exercises Each chapter contains exercises, including programming problems, designed to test students' knowledge and understanding of the main ideas.
The exercises also provide reinforcement for key chapter concepts.
Solutions are included to allow students to check their work immediately and correct any possible mistakes.
Case Studies Every chapter contains a number of case studies that were designed to introduce the reader to a wide range of application scenarios.
Notes This feature provides students with helpful tips and information useful to learning Cplus_plus.
Important concepts and rules are highlighted for additional emphasis and easy access.
Hints These are informative suggestions for easier programming.
Also included are common mistakes and how to avoid making them.
Acknowledgements Our thanks go out to everyone who helped produce this book, particularly to Ian Travis, for his valuable contributions to the development of this book.
Alexa Doehring, who reviewed all samples and program listings, and gave many valuable hints from the American perspective.
Michael Stranz and Amy Rose at Jones and Bartlett Publishers, who managed the publishing agreement and the production process so smoothly.
Our children, Vivi and Jeany, who left us in peace long enough to get things finished.
And now all that remains is to wish you, Dear Reader, lots of fun with Cplus_plus.
Ulla Kirch-Prinz Peter Prinz PREFACE ■ ix This page intentionally left blank xi Chapter 1 Fundamentals 1 Development and Properties of Cplus_plus 2 Object-Oriented Programming 4 Developing a Cplus_plus Program 6 A Beginner's Cplus_plus Program 8 Structure of Simple Cplus_plus Programs 10 Exercises 12 Solutions 14 Chapter 2 Fundamental Types, Constants, and Variables 15 Fundamental Types 16 Constants 22 Escape Sequences 26 Names 28 Variables 30 The Keywords const and volatile 32 Exercises 34 Solutions 36 contents Chapter 3 Using Functions and Classes 39 Declaring Functions 40 Function Calls 42 Type void for Functions 44 Header Files 46 Standard Header Files 48 Using Standard Classes 50 Exercises 52 Solutions 54 Chapter 4 Input and Output with Streams 57 Streams 58 Formatting and Manipulators 60 Formatted Output of Integers 62 Formatted Output of Floating-Point Numbers 64 Output in Fields 66 Output of Characters, Strings, and Boolean Values 68 Formatted Input 70 Formatted Input of Numbers 72 Unformatted Input/Output 74 Exercises 76 Solutions 78 Chapter 5 Operators for Fundamental Types 81 Binary Arithmetic Operators 82 Unary Arithmetic Operators 84 Assignments 86 Relational Operators 88 Logical Operators 90 Exercises 92 Solutions 94 Chapter 6 Control Flow 95 The while Statement 96 The for Statement 98 The do-while Statement 102 Selections with if-else 104 Else-if Chains 106 Conditional Expressions 108 Selecting with switch 110 Jumps with break, continue, and goto 112 Exercises 114 Solutions 116 xii ■ C O N T E N T S Chapter 7 Symbolic Constants and Macros 119 Macros 120 Macros with Parameters 122 Working with the #define Directive 124 Conditional Inclusion 126 Standard Macros for Character Manipulation 128 Redirecting Standard Input and Output 130 Exercises 132 Solutions 134 Chapter 8 Converting Arithmetic Types 139 Implicit Type Conversions 140 Performing Usual Arithmetic Type Conversions 142 Implicit Type Conversions in Assignments 144 More Type Conversions 146 Exercises 148 Solutions 150 Chapter 9 The Standard Class string 153 Defining and Assigning Strings 154 Concatenating Strings 156 Comparing Strings 158 Inserting and Erasing in Strings 160 Searching and Replacing in Strings 162 Accessing Characters in Strings 164 Exercises 166 Solutions 168 Chapter 10 Functions 171 Significance of Functions in Cplus_plus 172 Defining Functions 174 Return Value of Functions 176 Passing Arguments 178 Inline Functions 180 Default Arguments 182 Overloading Functions 184 Recursive Functions 186 Exercises 188 Solutions 191 Chapter 11 Storage Classes and Namespaces 197 Storage Classes of Objects 198 The Storage Class extern 200 CONTENTS ■ xiii The Storage Class static 202 The Specifiers auto and register 204 The Storage Classes of Functions 206 Namespaces 208 The Keyword using 210 Exercises 212 Solutions 216 Chapter 12 References and Pointers 221 Defining References 222 References as Parameters 224 References as Return Value 226 Expressions with Reference Type 228 Defining Pointers 230 The Indirection Operator 232 Pointers as Parameters 234 Exercises 236 Solutions 238 Chapter 13 Defining Classes 243 The Class Concept 244 Defining Classes 246 Defining Methods 248 Defining Objects 250 Using Objects 252 Pointers to Objects 254 Structs 256 Unions 258 Exercise 260 Solution 262 Chapter 14 Methods 265 Constructors 266 Constructor Calls 268 Destructors 270 Inline Methods 272 Access Methods 274 const Objects and Methods 276 Standard Methods 278 this Pointer 280 Passing Objects as Arguments 282 Returning Objects 284 Exercises 286 Solutions 290 xiv ■ C O N T E N T S Chapter 15 Member Objects and Static Members 297 Member Objects 298 Member Initializers 300 Constant Member Objects 302 Static Data Members 304 Accessing Static Data Members 306 Enumeration 308 Exercises 310 Solutions 314 Chapter 16 Arrays 321 Defining Arrays 322 Initializing Arrays 324 Arrays 326 Class Arrays 328 Multidimensional Arrays 330 Member Arrays 332 Exercises 334 Solutions 338 Chapter 17 Arrays and Pointers 349 350 352 Pointer Arithmetic 354 Arrays as Arguments 356 Pointer Versions of Functions 358 Read-Only Pointers 360 Returning Pointers 362 Arrays of Pointers 364 Command Line Arguments 366 Exercises 368 Solutions 372 Chapter 18 Fundamentals of File Input and Output 379 Files 380 File Streams 382 Creating File Streams 384 Open Modes 386 Closing Files 388 Reading and Writing Blocks 390 Object Persistence 392 Exercises 394 Solutions 398 CONTENTS ■ xv Chapter 19 Overloading Operators 411 Generals 412 414 416 Using Overloaded Operators 418 Global Operator Functions 420 Friend Functions 422 Friend Classes 424 Overloading Subscript Operators 426 Overloading Shift-Operators for I/O 428 Exercises 430 Solutions 432 Chapter 20 Type Conversion for Classes 441 Conversion Constructors 442 Conversion Functions 444 Ambiguities of Type Conversions 446 Exercise 448 Solution 450 Chapter 21 Dynamic Memory Allocation 453 The Operator new 454 The Operator delete 456 Dynamic Storage Allocation for Classes 458 Dynamic Storage Allocation for Arrays 460 Application: Linked Lists 462 Representing a Linked List 464 Exercises 466 Solutions 468 Chapter 22 Dynamic Members 477 Members of Varying Length 478 Classes with a Dynamic Member 480 Creating and Destroying Objects 482 Implementing Methods 484 Copy Constructor 486 Assignment 488 Exercises 490 Solutions 492 Chapter 23 Inheritance 499 Concept of Inheritance 500 Derived Classes 502 xvi ■ C O N T E N T S Members of Derived Classes 504 Member Access 506 Redefining Members 508 Constructing and Destroying Derived Classes 510 Objects of Derived Classes 512 Protected Members 514 Exercises 516 Solutions 520 Chapter 24 Type Conversion in Class Hierarchies 529 Converting to Base Classes 530 Type Conversions and Assignments 532 Converting References and Pointers 534 Explicit Type Conversions 536 Exercises 538 Solutions 540 Chapter 25 Polymorphism 543 Concept of Polymorphism 544 Virtual Methods 546 Destroying Dynamically Allocated Objects 548 Virtual Method Table 550 Dynamic Casts 552 Exercises 554 Solutions 558 Chapter 26 Abstract Classes 565 Pure Virtual Methods 566 Abstract and Concrete Classes 568 Pointers and References to Abstract Classes 570 Virtual Assignment 572 Application: Inhomogeneous Lists 574 Implementing an Inhomogeneous List 576 Exercises 578 Solutions 580 Chapter 27 Multiple Inheritance 587 Multiply-Derived Classes 588 Multiple Indirect Base Classes 590 Virtual Base Classes 592 Constructor Calls 594 Initializing Virtual Base Classes 596 Exercises 598 Solutions 602 CONTENTS ■ xvii Chapter 28 Exception Handling 607 Traditional Error Handling 608 Exception Handling 610 Exception Handlers 612 Throwing and Catching Exceptions 614 Nesting Exception Handling 616 Defining Your Own Error Classes 618 Standard Exception Classes 620 Exercises 622 Solutions 626 Chapter 29 More About Files 637 Opening a File for Random Access 638 Positioning for Random Access 640 File State 644 Exception Handling for Files 646 Persistence of Polymorphic Objects 648 Application: Index Files 652 Implementing an Index File 654 Exercises 656 Solutions 660 Chapter 30 More About Pointers 681 Pointer to Pointers 682 Variable Number of Arguments 684 Pointers to Functions 688 Complex Declarations 690 Defining Typenames 692 Application: Dynamic Matrices 694 Exercises 696 Solutions 698 Chapter 31 Manipulating Bits 705 Bitwise Operators 706 Bitwise Shift Operators 708 Bit Masks 710 Using Bit Masks 712 Bit-Fields 714 Exercises 716 Solutions 718 Chapter 32 Templates 721 Function and Class Templates 722 Defining Templates 724 xviii ■ C O N T E N T S Template Instantiation 726 Template Parameters 728 Template Arguments 730 Specialization 732 Default Arguments of Templates 734 Explicit Instantiation 736 Exercises 738 Solutions 742 Chapter 33 Containers 749 Container Types 750 Sequences 752 Iterators 754 Declaring Sequences 756 Inserting in Sequences 758 Accessing Objects 760 Length and Capacity 762 Deleting in Sequences 764 List Operations 766 Associative Containers 768 Sets and Multisets 770 Maps and Multimaps 772 Bitsets 774 Exercise 778 Solution 780 Appendix 783 Binary Numbers 784 Preprocessor Directives 787 Pre-Defined Standard Macros 792 Binding C Functions 793 Operators Overview 795 Operator Precedence Table 797 ASCII Code Table 798 Screen Control Sequences 800 Literature 801 Index 803 CONTENTS ■ xix This page intentionally left blank 1 Fundamentals This chapter describes the fundamental characteristics of the objectoriented Cplus_plus programming language.
In addition, you will be introduced to the steps necessary for creating a fully functional Cplus_plus program_0_The examples provided will help you retrace these steps and also demonstrate the basic structure of a Cplus_plus program.
The earliest versions, which were originally referred to as "C with classes," date back to 1980.
As the name Cplus_plus implies, Cplus_plus was derived from the C programming language: plus_plus is the increment operator in C.
As early as 1989 an ANSI Committee (American National Standards Institute) was founded to standardize the Cplus_plus programming language.
The aim was to have as many compiler vendors and software developers as possible agree on a unified description of the language in order to avoid the confusion caused by a variety of dialects.
In 1998 the ISO (International Organization for Standardization) approved a standard for Cplus_plus (ISO/IEC 14882).
This means that you have all the features that are available in C: ■ universally usable modular programs ■ efficient, close to the machine programming ■ portable programs for various platforms.
The large quantities of existing C source code can also be used in Cplus_plus programs.
Cplus_plus supports the concepts of object-oriented programming (or OOP for short), which are: ■ data abstraction, that is, the creation of classes to describe objects ■ data encapsulation for controlled access to object data ■ polymorphism (Greek for multiform), that is, the implementation of instructions that can have varying effects during program execution.
Various language elements were added to Cplus_plus, such as references, templates, and exception handling.
Even though these elements of the language are not strictly object-oriented programming features, they are important for efficient program implementation.
This has a significant effect on the way a program handles data: ■ the programmer must ensure that data are initialized with suitable values before use and that suitable data are passed to a function when it is called ■ if the data representation is changed, e_0_g.
Both of these points can lead to errors and neither support low program maintenance requirements.
A program designed to maintain bank accounts would work with data such as balances, credit limits, transfers, interest calculations, and so on.
An object representing an account in a program will have properties and capacities that are important for account management.
OOP objects combine data (properties) and functions (capacities).
A class defines a certain object type by defining both the properties and the capacities of the objects of that type.
Objects communicate by sending each other "messages," which in turn activate another object's capacities.
More specifically, an object can reject erroneous access attempts ■ easy re-use: objects maintain themselves and can therefore be used as building blocks for other programs ■ low maintenance requirement: an object type can modify its own internal data representation without requiring changes to the application.
Additional error messages may be shown if the compiler attempts to continue despite having found an error.
So when you are troubleshooting a program, be sure to start with the first error shown.
D E V E L O P I N G  A  C + +  P R O G R A M ■ 7 ✓ NOTE The following three steps are required to create and translate a Cplus_plus program: 1.
First, a text editor is used to save the Cplus_plus program in a text file.
In larger projects the programmer will normally use modular programming.
This means that the source code will be stored in several source files that are edited and translated separately.
The source file is put through a compiler for translation.
If everything works as planned, an object file made up of machine code is created.
The object file is also referred to as a module.
Finally, the linker combines the object file with other modules to form an executable file.
These further modules contain functions from standard libraries or parts of the program that have been compiled previously.
It is important to use the correct file extension for the source file's name.
Although the file extension depends on the compiler you use, the most commonly found file extensions are _0_cpp and _0_cc.
Prior to compilation, header files, which are also referred to as include files, can be copied to the source file.
Header files are text files containing information needed by various source files, for example, type definitions or declarations of variables and functions.
Header files can have the file extension _0_h, but they may not have any file extension.
The Cplus_plus standard library contains predefined and standardized functions that are available for any compiler.
Modern compilers normally offer an integrated software development environment, which combines the steps mentioned previously into a single task.
A graphical user interface is available for editing, compiling, linking, and running the application.
Moreover, additional tools, such as a debugger, can be launched.
In addition to error messages, the compiler will also issue warnings.
A warning does not indicate a syntax error but merely draws your attention to a possible error in the program's logic, such as the use of a non-initialized variable.
Function name What the program does Type of function End of function Beginning of function Function block { }.
What the program does A  B E G I N N E R ' S  C + +  P R O G R A M ■ 9 A  program is made up of objects with their accompanying member functions and global functions, which do not belong to any single particular class.
Each function fulfills its own particular task and can also call other functions.
You can create functions yourself or use ready-made functions from the standard library.
You will always need to write the global function main() yourself since it has a special role to play; in fact it is the main program.
The short programming example on the opposite page demonstrates two of the most and displays a message.
The first line begins with the number symbol, #, which indicates that the line is intended for the preprocessor.
The preprocessor is just one step in the first translation phase and no object code is created at this time.
You can type # <filename> to have the preprocessor copy the quoted file to this position in the source code.
This allows the program access to all the information contained in the header file.
The header file iostream comprises conventions for input and output streams.
The word stream indicates that the information involved will be treated as a flow of data.
Predefined names in  are to be found in the std (standard) namespace.
The using directive allows direct access to the names of the std namespace.
Program execution begins with the first instruction in function main(), and this is why each  program must have a main function.
The structure of the function is shown on the opposite page.
Apart from the fact that the name cannot be changed, this function's structure is not different from that of any other  function.
In our example the function main() contains two statements.
The first statement << "Enjoy yourself with _0_" << endl; outputs the text string Enjoy yourself with.
The name (console output) designates an object responsible for output.
The two less-than symbols, <<, indicate that characters are being "pushed" to the output stream.
Finally endl (end of line) causes a line feed.
The statement return 0; terminates the function main() and also the program, returning a value of 0 as an exit code to the calling program.
It is standard practice to use the exit code 0 to indicate that a program has terminated correctly.
Note that statements are followed by a semicolon.
By the way, the shortest statement comprises only a semicolon and does nothing.
A  program with several functions Screen output Hello.
The program starts in ().
S T R U C T U R E  O F  S I M P L E  C + +  P R O G R A M S ■ 11 The example on the opposite page shows the structure of a  program containing multiple functions.
In , functions do not need to be defined in any fixed order.
For example, you could define the function () first, followed by the function line(), and finally the () function.
However, it is more common to start with the () function as this function controls the program flow.
In other words, () calls functions that have yet to be defined.
This is made possible by supplying the compiler with a function prototype that includes all the information the compiler needs.
This example also introduces comments.
Strings enclosed in /*.
EXAMPLES: /* I can cover several lines */ // I can cover just one In single- comments the compiler ignores any characters following the // signs up to the end of the.
Comments that cover several lines are useful when troubleshooting, as you can use them to mask complete sections of your program.
Both comment types can be used to comment out the other type.
As to the layout of source files, the compiler parses each source file sequentially, breaking the contents down into tokens, such as function names and operators.
Tokens can be separated by any number of whitespace characters, that is, by spaces, tabs, or new  characters.
The order of the source code is important but it is not important to adhere to a specific layout, such as organizing your code in rows and columns.
For example void (   ){   << "In function ()_0_"  << endl;} might be difficult to read, but it is a correct definition of the function ().
Preprocessor directives are one exception to the layout rule since they always occupy a single.
The number sign, #, at the beginning of a  can be preceded only by a space or a tab character.
To improve the legibility of your Cplus_plus programs you should adopt a consistent style, using indentation and blank lines to reflect the structure of your program.
In addition, make generous use of comments.
Since a computer uses different methods for processing and saving data, the data type must be known.
The type defines 1.
A number such as -1000 can be stored in either 2 or 4 bytes.
When accessing the part of memory in which the number is stored, it is important to read the correct number of bytes.
Moreover, the memory content, that is the bit sequence being read, must be interpreted correctly as a signed integer.
The Cplus_plus compiler recognizes the fundamental types, also referred to as built-in types, shown on the opposite page, on which all other types (vectors, pointers, classes, _0__0__0_) are based.
Cplus_plus uses the bool type to represent boolean values.
An expression of the type bool can either be true or false, where the internal value for true will be represented as the numerical value 1 and false by a zero.
A character code is an integer associated with each character.
The letter A is represented by code 65, for example.
The character set defines which code represents a certain character.
When displaying characters on screen, the applicable character codes are transmitted and the "receiver," that is the screen, is responsible for correctly interpreting the codes.
The Cplus_plus language does not stipulate any particular characters set, although in general a character set that contains the ASCII code (American Standard Code for Information Interchange) is used.
This 7-bit code contains definitions for 32 control characters (codes 0 – 31) and 96 printable characters (codes 32 – 127).
The char (character) type is used to store character codes in one byte (8 bits).
This amount of storage is sufficient for extended character sets, for example, the ANSI character set that contains the ASCII codes and additional characters such as German umlauts.
The wchar_t (wide character type) type comprises at least 2 bytes (16 bits) and is thus capable of storing modern Unicode characters.
Unicode is a 16-bit code also used in Windows NT and containing codes for approximately 35,000 characters in 24 languages.
These types are distinguished by their ranges of values.
The table on the opposite page shows the integer types, which are also referred to as integral types, with their typical storage requirements and ranges of values.
The int (integer) type is tailor-made for computers and adapts to the length of a register on the computer.
For 16-bit computers, int is thus equivalent to short, whereas for 32-bit computers int will be equivalent to long.
Cplus_plus treats character codes just like normal integers.
This means you can perform calculations with variables belonging to the char or wchar_t types in exactly the same way as with int type variables.
The range of values is thus –128 to +127 or from 0 to 255, depending on whether the compiler interprets the char type as signed or unsigned.
The wchar_t type is a further integral type and is normally defined as unsigned short.
However, integral types can be preceded by the keyword unsigned.
The amount of memory required remains unaltered but the range of values changes due to the highest bit no longer being required as a sign.
The keyword unsigned can be used as an abbreviation for unsigned.
The  type is also normally interpreted as signed.
Since this is merely a convention and not mandatory, the signed keyword is available.
Thus three types are available: , signed , and unsigned.
The current value ranges are available in the climits header file.
This file defines constants such as CHAR_MIN, CHAR_MAX, INT_MIN, and , which represent the smallest and greatest possible values.
The program on the opposite page outputs the value of these constants for the  and unsigned  types.
In ANSI Cplus_plus the size of integer types is not preset.
However, the following order applies: <=  <=  <= long Moreover, the  type comprises at least 2 bytes and the long type at least 4 bytes.
The table above makes use of this representation.
In contrast to integers, floating-point numbers must be stored to a preset accuracy.
The following three types are available for calculations involving floating-point numbers: float for simple accuracy double for double accuracy long double for high accuracy The value range and accuracy of a type are derived from the amount of memory allocated and the internal representation of the type.
Accuracy is expressed in decimal places.
This means that "six decimal places" allows a programmer to store two floating-point numbers that differ within the first six decimal places as separate numbers.
In reverse, there is no guarantee that the figures 12_0_3456 and 12_0_34561 will be distinguished when working to a accuracy of six decimal places.
And remember, it is not a question of the position of the decimal point, but merely of the numerical sequence.
If it is important for your program to display floating-point numbers with an accuracy supported by a particular machine, you should refer to the values defined in the cfloat header file.
Readers interested in additional material on this subject should refer to the Appendix, which contains a section on the representation of binary numbers on computers for both integers and floating-point numbers.
For example, sizeof()represents a value of 2 or 4 depending on the machine.
In contrast, sizeof(float) will always equal 4.
The types used for integers and floating-point numbers are collectively referred to as arithmetic types, as arithmetic operators are defined for them.
The void type is used for expressions that do not represent a value.
A function call can thus take a void type.
Constants can thus be subdivided into ■ boolean constants ■ numerical constants ■ character constants ■ string constants.
Every constant represents a value and thus a type—as does every expression in Cplus_plus.
The type is defined by the way the constant is written.
Both constants are  the bool type.
They can be used, for example, to set flags representing just two states.
Hexadecimal numbers can be capitalized or noncapitalized.
Integral constants are normally  type int.
If the value  the constant is too large for the int type, a type capable  representing larger values will be applied.
The ranking for decimal constants is as follows: int, long, unsigned long You can designate the type  a constant by adding the letter L or l (for long), or U or u (for unsigned).
For example, 12L and 12l correspond to the type long 12U and 12u correspond to the type unsigned int 12UL and 12ul correspond to the type unsigned long 24 ■ C H A P T E R  2 F U N D A M E N T A L  T Y P E S ,  C O N S T A N T S ,  A N D  V A R I A B L E S 'H' 'e' '1' '1' 'o' '_0_' '\0' String literal: Stored byte sequence: Examples for floating-point constants Examples for character constants Internal representation of a string literal 5_0_19 0_0_519E1 0_0_0519e2 519_0_OE-2 12.
However, exponential notation is also permissible.
EXAMPLES: 27_0_1     1_0_8E–2     // Type: double Here, 1_0_8E–2 represents a value of 1_0_8*10–2.
E can also be written with a small letter e.
A decimal point or E (e) must always be used to distinguish floating-point constants from integer constants.
Floating-point constants are of type double by default.
However, you can add F or f to designate the float type, or add L or l for the long double type.
Character constants take the type char.
EXAMPLE: 'A' // Type: char The numerical value is the character code representing the character.
The constant 'A' thus has a value of 65 in ASCII code.
A string constant consists of a sequence of characters enclosed in double quotes.
EXAMPLE: comprises two bytes, the first byte containing the code for the character zero 0 (ASCII code 48) and the second byte the value 0.
The terminating null character \0 is an example of an escape sequence.
Escape sequences are described in the following section.
Single character Meaning ASCII code string terminating character numerical value of a character 7 8 9 10 11 12 13 34 39 63 92 0 \a \b \t \n \v \f \r \' \.
The effect of an escape sequence will depend on the device concerned.
The sequence \t, for example, depends on the setting for the tab width, which defaults to eight blanks but can be any value.
An escape sequence always begins with a \ (backslash) and represents a single character.
The table on the opposite page shows the standard escape sequences, their decimal values, and effects.
You can use octal and hexadecimal escape sequences to create any character code.
Thus, the letter A (decimal 65) in ASCII code can also be expressed as \101 (three octals) or \x41 (two hexadecimals).
Traditionally, escape sequences are used only to represent non-printable characters and special characters.
The control sequences for screen and printer drivers are, for example, initiated by the ESC character (decimal 27), which can be represented as \33 or \x1b.
Escape sequences are used in character and string constants.
EXAMPLES: '\t' The characters ', ", and \ have no special significance when preceded by a backslash, i_0_e.
When using octal numbers for escape sequences in strings, be sure to use three digits, for example, \033 and not \33.
This helps to avoid any subsequent numbers being evaluated as part of the escape sequence.
There is no maximum number of digits in a hexadecimal escape sequence.
The sequence of hex numbers automatically terminates with the first character that is not a valid hex number.
The sample program on the opposite page demonstrates the use of escape sequences in strings.
The fact that a string can occupy two lines is another new.
String constants separated only by white spaces will be concatenated to form a single string.
To continue a string in the next  you can also use a backslash \ as the last character in a , and then press the Enter key to begin a new , where you can continue typing the string.
EXAMPLE: "I am a very, very \ Please note, however, that the leading spaces in the second  will be evaluated as part of the string.
It is thus generally preferable to use the first method, that is, to terminate the string with " and reopen it with ".
The following rules apply when creating names, which are also known as identifiers: ■ a name contains a series of letters, numbers, or underscore characters ( _ ).
German umlauts and accented letters are invalid.
Cplus_plus is case sensitive; that is, upper- and lowercase letters are different.
The opposite page shows Cplus_plus keywords and some examples of valid and invalid names.
The Cplus_plus compiler uses internal names that begin with one or two underscores followed by a capital letter.
To avoid confusion with these names, avoid use of the underscore at the beginning of a name.
Under normal circumstances the linker only evaluates a set number of characters, for example, the first 8 characters of a name.
For this reason names of global objects, such as functions, should be chosen so that the first eight characters are significant.
The names of some variables tend to be associated with a specific use.
EXAMPLES: c, ch for characters i, j, k, l, m, n for integers, in particular indices x, y, z for floating-point numbers To improve the readability of your programs you should choose longer and more selfexplanatory names, such as start_index or startIndex for the first index in a range of index values.
In the case of software projects, naming conventions will normally apply.
For example, prefixes that indicate the type of the variable may be assigned when naming variables.
Integers are printed in decimal format by default.
VARIABLES ■ 31 Data such as numbers, characters, or even complete records are stored in variables to enable their processing by a program.
Variables are also referred to as objects, particularly if they belong to a class.
When you define a variable the type is specified and an appropriate amount of memory reserved.
This memory space is addressed by reference to the name of the variable.
A simple definition has the following syntax: SYNTAX: typ name1 [name2 _0__0_.
Thus, one or more variables can be stated within a single definition.
EXAMPLES: char c; int i, counter; double x, y, size; In a program, variables can be defined either within the program's functions or outside of them.
This has the following effect: ■ a variable defined outside of each function is global, i_0_e.
Local variables are normally defined immediately after the first brace—for example at the beginning of a function.
However, they can be defined wherever a statement is permitted.
This means that variables can be defined immediately before they are used by the program.
Initialization is achieved by placing the following immediately after the name of the variable: ■ an equals  ( = ) and an initial value for the variable or ■ round brackets containing the value of the variable.
EXAMPLES: char  = 'a'; float x(1_0_875); Any global variables not explicitly initialized default to zero.
In contrast, the initial value for any local variables that you fail to initialize will have an undefined initial value.
As an object of this type is constant, it cannot be modified at a later stage and must be initialized during its definition.
EXAMPLE: const double  = 3_0_1415947; Thus the value of  cannot be modified by the program.
Even a statement such as the following will merely result in an error message: =  + 2_0_0;               // invalid � Volatile Objects The keyword volatile, which is rarely used, creates variables that can be modified not only by the program but also by other programs and external events.
Events can be initiated by interrupts or by a hardware clock, for example.
EXAMPLE: volatile unsigned long  clock_ticks; Even if the program itself does not modify the variable, the compiler must assume that the value of the variable has changed since it was last accessed.
The compiler therefore creates machine code to read the value of the variable whenever it is accessed instead of repeatedly using a value that has been read at a prior stage.
It is also possible to combine the keywords const and volatile when declaring a variable.
EXAMPLE: volatile const unsigned time_to_live; Based on this declaration, the variable time_to_live cannot be modified by the program but by external events.
EXERCISES ■ 35 Exercise 1 The sizeof operator can be used to determine the  of bytes occupied in memory by a variable of a certain type.
For example, sizeof(short) is equivalent to 2.
Write a Cplus_plus program that displays the memory space required by each fundamental type on screen.
Exercise 2 Write a Cplus_plus program to generate the screen output shown on the opposite page.
Exercise 3 Which of the variable definitions shown on the opposite page is invalid or does not make sense.
Exercise 4 Write a Cplus_plus program that two defines variables for floating-point numbers and initializes them with the values 123_0_456 and 76_0_543 Then display the sum and the difference of these two numbers on screen.
SOLUTIONS ■ 37 Exercise 3 Incorrect: a(2_0_5);               // 2_0_5 is not an integer value const  large;         // Without initialization.
The type void is available for functions of this type, which are also referred to as procedures in other programming languages.
Example: void srand( unsigned int seed ); The standard function srand() initializes an algorithm that generates random numbers.
Since the function does not return a value, it is of type void.
An unsigned value is passed to the function as an argument to seed the random number generator.
The value is used to create a series of random numbers.
Example: int rand( void );      // or   int rand(); The standard function rand() is called without any arguments and returns a random number between 0 and 32767.
A series of random numbers can be generated by repeating the function call.
The function prototypes for srand() and rand() can be found in both the cstdlib and stdlib_0_h header files.
Calling the function rand() without previously having called srand() creates the same  of numbers as if the following statement would have been proceeded: srand(1); If you want to avoid generating the same  of random numbers whenever the program is executed, you must call srand() with a different value for the argument whenever the program is run.
It is common to use the current time to initialize a random number generator.
See Chapter 6 for an example of this technique.
Output the new  on screen.
This page intentionally left blank 57 Input and Output with Streams This chapter describes the use of streams for input and output, focusing on formatting techniques.
This gave rise to the I/O stream classes, which are now available in  library of their own, the so-called iostream library.
The diagram on the opposite page shows how  so-called  hierarchy develops due to inheritance.
The  ios is the base  of all other stream classes.
It contains the attributes and abilities common to all streams.
Effectively, the ios ■ manages the connection to the physical data stream that writes your program's data to  file or outputs the data on screen ■ contains the basic functions needed for formatting data.
A  of flags that determine how character input is interpreted have been defined for this purpose.
The istream and ostream classes derived from ios form  user-friendly interface for stream manipulation.
The istream  is used for reading streams and the ostream  is used for writing to streams.
The operator >> is defined in istream and << is defined in ostream, for example.
The iostream  is derived by multiple inheritance from istream and ostream and thus offers the functionality of both classes.
Further stream classes,  file management , for example, are derived from the classes mentioned above.
This allows the developer to use the techniques described for file manipulation.
These classes, which also contain methods for opening and closing files, will be discussed in  later chapter.
When  program is launched these objects are automatically created to read standard input or write to standard output.
Standard input is normally the keyboard and standard output the screen.
However, standard input and output can be redirected to files.
In this case, data is not read from the keyboard but from  file, or data is not displayed on screen but written to  file.
The other two standard streams cerr and clog are used to display messages when errors occur.
Error messages are displayed on screen even if standard output has been redirected to  file.
The other positive numbers are printed with their sign as well:.
The output of  positive sign can be canceled by the manipulator :.
The last statement is equivalent to _0_unsetf( ios::); << 123; ■ The operators >> and << format the input and/or output according to how the flags in the base ios are set ■ The manipulator  is  function that calls the method _0_setf(ios::);, ios:: being the flag  belonging to the ios ■ Using manipulators is easier than directly accessing flags.
For this reason, manipulators are described in the following section, whereas the methods setf() and unsetf() are used only under exceptional circumstances.
Similarly, screen output adheres to set of rules governing how, for example, floating-point numbers are displayed.
The stream classes istream and ostream offer various options for performing these tasks.
For example, you can display  table of numeric values in  simple way.
In previous chapters we have looked at the cin and  streams in statements such as: << "Please enter a number: "; cin  >> x; The following sections systematically describe the abilities of the stream classes.
This includes: ■ the >> and << operators for formatted input and output.
These operators are defined for expressions with fundamental types—that is, for characters, boolean values, numbers and strings.
Manipulators can be used to generate formats for subsequent input/output.
One manipulator that you are already familiar with is endl, which generates a line feed at the end of a line.
In general, flags are represented by individual bits within a special integral variable.
For example, depending on whether a bit is set or not, a positive number can be output with or without a plus sign.
Each flag has a default setting.
For example, integral numbers are output as decimals by default, and positive numbers are output without a plus sign.
It is possible to modify individual formatting flags.
The methods setf() and unsetf() can be used for this purpose.
However, the same effect can be achieved simply by using so-called manipulators, which are defined for all important flags.
Manipulators are functions that can be inserted into the input or output stream and thus be called.
Generates capital letters in hexadecimal output.
Generates non-negative numeric output without a + sign (by default).
Generates lowercase letters in hexadecimal output (by default).
The following formatting options are available: ■ define the numeric system in which to display the : decimal, octal, or hexadecimal ■ use capitals instead of small letters for hexadecimals ■ display a sign for positive numbers.
In addition, the field width can be defined for the above types.
The field width can also be defined for characters, strings, and floating-point numbers, and will be discussed in the following sections.
The manipulators oct, , and dec can be used for switching from and to decimal display mode.
Example: <<  << 11;            // Output: b Hexadecimals are displayed in small letters by default, that is, using a, b, _0__0__0_, f.
The manipulator  allows you to use capitals.
Example: <<  <<  << 11; //Output: B The manipulator nouppercase returns the output format to small letters.
You can use the  manipulator to output signed positive numbers.
Example: <<  <<  << 11; //Output: +11 You can use noshowpos to revert to the original display mode.
When octal or hexadecimal numbers are output, the bits of the  to be output are always interpreted as unsigned.
In other words, the output shows the bit pattern of a in octal or hexadecimal format.
Example: <<  << -1 << "   " <<  << -1; This statement causes the following output on a 32-bit system: -1   ffffffff 64 ■ C H A P T E R  4 I N P U T  A N D  O U T P U T  W I T H  S T R E A M S.
The key word const within the prototype of precision() signifies that the method performs only read operations.
Returns the used precision.
The of digits after the decimal point corresponds to the used precision.
Output in fixed point notation Output in  notation Sets the precision to n.
Trailing zeroes after the decimal point are not printed.
If there are no digits after the decimal point, the  decimal point is not printed (by ).
Decimals are separated from the integral part of the number by a decimal point.
Trailing zeroes behind the decimal point are not printed.
If there are no digits after the decimal point, the decimal point is not printed (by ).
Examples:  << 1_0_0;       // Output: 1 << 1_0_234;     // Output: 1_0_234 << 1_0_234567;  // Output: 1_0_23457.
Very large and very small numbers are displayed in exponential notation.
Example: << 1234567_0_8; // Output: 1_0_23457e+06 � Formatting The standard settings can be modified in several ways.
You can ■ change the precision, i_0_e.
Both the manipulator setprecision()and the method precision() can be used to redefine precision to be used.
This also applies to all standard manipulators called with at least one argument.
The manipulator  outputs the decimal point and trailing zeroes.
The number of digits being output (e_0_g.
Example: <<  << 1_0_0; // Output: 1_0_00000 However,  point output with a predetermined number of decimal places is often more useful.
In this case, you can use the  manipulator with the precision defining the number of decimal places.
The  value of 6 is assumed in the following example.
Example: <<  << 66_0_0;   // Output: 66_0_000000 In contrast, you can use the  manipulator to specify that floating-point numbers are output as exponential expressions.
Manipulator Effects Sets the minimum field width to n Sets the fill character to ch Left-aligns output in fields Right-aligns output in fields Left-aligns output of the sign and right-aligns output of the numeric value left right internal OUTPUT IN FIELDS ■ 67 The << operator can be used to generate formatted output in fields.
You can ■ specify the field width ■ set the alignment of the output to right- or left-justified ■ specify a fill-character with which to fill the field.
If the output string is larger than the field width, the output is not truncated but the field is extended.
The output will always contain at least the number of digits specified as the field width.
You can either use the width() method or the () manipulator to define field width.
Example: _0_width(6);    // or:   << (6); One special attribute of the field width is the fact that this value is non-permanent: the field width specified applies to the next output only, as is illustrated by the examples on the opposite page.
The first example outputs the character '' to a field with width of 6, but does not output the '|' character.
The default field width is 0.
You can also use the width() method to get the current field width.
To do so, call width() without any other arguments.
Example: int  = _0_width(); � Fill Characters and Alignment If a field is larger than the string you need to output, blanks are used by default to fill the field.
You can either use the fill() method or the () manipulator to specify another fill character.
Example: << ('*') << (5) << 12; // Output: ***12 The fill character applies until another character is defined.
As the previous example shows, output to fields is normally right-aligned.
The other options available are left-aligned and , which can be set by using the manipulators left and.
The manipulator  left-justifies the sign and rightjustifies the number within a field.
Example: _0_width(6); _0_fill('0'); <<  << -123; // Output: -00123 68 ■ C H A P T E R  4 I N P U T  A N D  O U T P U T  W I T H  S T R E A M S // Enters a character and outputs its.
The program to be continued return 0; } The  buffer is cleared and error flags are reset by calling the sync() and clear() methods.
This ensures that the program will wait for new  for the , even if more than 15 characters have been entered for the label.
When reading from standard , cin is buffered by.
Keyboard  is thus not read until confirmed by pressing the <Return> key.
This allows the user to press the backspace key and correct any  errors, provided the return key has not been pressed.
Input is displayed on screen by default.
Any white space characters (such as blanks, tabs, and new ) are ignored by default.
Example: char ; cin >> ;        // Enter a character When the following keys are pressed <return> <tab> <blank> <X> <return> the character 'X' is stored in the variable.
An  field is terminated by the first white space character or by the first character that cannot be processed.
Example: int i; cin >> i; Typing 123FF<Return> stores the decimal value 123 in the variable i.
However, the characters that follow, FF and the newline character, remain in the  buffer and will be read first during the next read operation.
When reading strings, only one word is read since the first white space character will begin a new  field.
Example: string city; cin >> city;     // To read just one word.
If Lao Kai is , only Lao will be written to the city string.
The  of characters to be read can also be limited by specifying the field width.
For a given field width of n, a maximum of n–1 characters will be read, as one byte is required for the null character.
Any initial white space will be ignored.
The program on the opposite page illustrates this point and also shows how to clear the  buffer.
Example: int n; cin >> oct >> n; An  value of 10 will be interpreted as an octal, which corresponds to a decimal value of 8.
Example: cin >> hex >> n; Here, any  will be interpreted as a hexadecimal, enabling  such as f0a or -F7.
The floating-point  can be entered in  point or exponential notation.
Example: double ; cin >> ; The character  is converted to a double value in this case.
Input, such as 123, -22_0_0, or 3e10 is valid.
Example: int i, j;    cin >> i >> j; Given  of 1A5 the digit 1 will be stored in the variable i.
The next  field begins with A.
But since a decimal  type is required, the  sequence will not be processed beyond the letter A.
If, as in our example, no type conversion is performed, the variable is not written to and an internal error flag is raised.
It normally makes more sense to read numerical values individually, and clear the buffer and any error flags that may have been set after each entry.
Chapter 6, "Control Flow," and Chapter 28, "Exception Handling," show how a program can react to  errors.
A  of more than one line can be entered.
The sample program requires that at least one word and a following white space are entered.
Exercise 5 The corrected program:.
Overloading and other operators, such as those needed for bit manipulations, are introduced in later chapters.
In expressions of this type the variable must be placed on the left and the assigned  on the right of the assignment.
In the case of the last example, the right side of the expression is first evaluated and the result is assigned to the variable on the left.
Each assignment is an expression in its own right, and its  is the  assigned.
Example: sin( = 2_0_5); In this assignment the number 2_0_5 is assigned to  and then passed to the function as an argument.
Multiple assignments, which are always evaluated from right to left, are also possible.
Example: =  = 9; In this case the  9 is first assigned to  and then to.
The second example shows that compound assignments are implicitly placed in parentheses, as is demonstrated by the fact that the precedence of the compound assignment is just as low as that of the simple assignment.
Compound assignment operators can be composed from any binary arithmetic  (, as we will see later, with bit operators).
The following compound operators are thus : +=, -=, *=, /=,  %=.
You can modify a variable when evaluating a complex expression by means of an assignment or the plus_plus, minus_minus operators.
This technique is referred to as a side effect.
Avoid use of side effects if possible, as they often lead to errors  can impair the readability of your programs.
Example: == circuit // false or true If the variables   circuit contain the same number, the comparison is true  the value of the relational expression is true.
But if the expressions contain different values, the value of the expression will be false.
When individual characters are compared, the character codes are compared.
The result therefore depends on the character set you are using.
The following expression results in the value true when ASCII code is used.
Example: 'A' < 'a' // true,  65 < 97 � Precedence of Relational Operators Relational operators have lower precedence than arithmetic operators but higher precedence than assignment operators.
Example: bool  =  < max – 1; In our example, max – 1 is evaluated first, then the  is compared to ,  the value of the relational expression (false or true) is assigned to the  variable.
Similarly, in the following Example: int ; =  + 1 == limit; + 1 is evaluated first, then the  is compared to limit,  the value of the relational expression is assigned to the  variable.
Since  is an int type, a numerical value is assigned instead of false or true, _0_e.
It is quite common to assign a value before performing a comparison,  parentheses must be used in this case.
Example: ( =  + 1) == limit Our example stores the  of  + 1 in the variable   then compares this expression with limit.
You cannot use the assignment  = to compare two expressions.
The compiler will not generate an error message if the value on the left is a variable.
This mistake has caused headaches for lots of beginners when troubleshooting their programs.
Any value other than 0 is ✓ NOTE ■ LOGICAL OPERATORS "Truth" table for logical operators Examples for logical expressions true true true false false true false false false true true false false true true false A B A && B A || B true false true false A _0_A 1 0 -1 0 -1 0 0 1 false true true false <=  ||  >=0 > -2 &&  == 0 &&.
They can be used to create compound conditions and perform conditional execution of a program depending on multiple conditions.
A logical expression results in a value false or true, depending on whether the logical expression is correct or incorrect, just like a relational expression.
However, operands of any type that can be converted to bool can also be used, including any arithmetic types.
In this case the operand is interpreted as false, or converted to false, if it has a value of 0.
Any other value than 0 is interpreted as true.
The OR  || will return true only if at least one operand is true, so the value of the expression Example: is true if  is less than 0_0_2 or greater than 9_0_8.
The AND  && will return true only if both operands are true, so the logical expression Example: is true, provided index is less than max and a number is successfully input.
If the condition index < max is not met, the program will not attempt to read a number.
One important feature of the logical operators && and || is the fact that there is a fixed order of evaluation.
The left operand is evaluated first and if a  has already been ascertained, the right operand will not be evaluated.
If the variable flag contains the value false (or the value 0), _0_flag returns the boolean value true.
The precedence of both these operators is higher than the precedence of an assignment operator, but lower than the precedence of all previously used operators.
This is why it was permissible to omit the parentheses in the examples earlier on in this chapter.
Refer to the table of precedence in the Appendix for further details.
What value will be assigned in part  to the variable  if the variable i has value of –2.
Exercise 3 The int variable  contains the number 7.
Calculate the value of the following logical expressions:.
The value 6 will be assigned to the variable.
The set of instructions to be iterated is called the loop body.
Cplus_plus offers three language elements to formulate iteration statements: while, do-while, and for.
The number of times  loop is repeated is defined by  controlling expression.
In the case of while and for statements this expression is verified before the loop body is executed, whereas  do-while loop is performed once before testing.
The while statement takes the following format: Syntax: statement       // loop body When entering the loop, the controlling expression is verified, i_0_e.
If this value is true, the loop body is then executed before the controlling expression is evaluated once more.
If the controlling expression is false, i_0_e.
It is common practice to place the loop body in  new  of the source code and to indent the statement to improve the readability of the program.
Example: int  = 0; <<  << endl; As this example illustrates, the controlling expression is normally  boolean expression.
However, the controlling expression might be any expression that can be converted to the bool type including any arithmetic expressions.
As we already learned from the section on boolean operators, the value 0 converts to false and all other values convert to true.
A block is syntactically equivalent to statement, so you can use  block wherever the syntax requires  statement.
The program on the opposite page calculates the average of  sequence of integers input via the keyboard.
Since the loops contains two statements, the statements must be placed in  block.
The controlling expression cin >>  is true provided the user inputs an integer.
The result of converting the expression cin >>  to  bool type will be true for any valid input and false in any other case.
Invalid input, if the user types  letter instead of an integer, for example, terminates the loop and executes the next statement.
Example: int ; << << ".
Thus, a for  has the following form: Syntax: statement expression1 is executed first and only once to initialize the.
Subsequently, the  is reinitialized by executing expression3 and expression2 is re-tested.
You can also define the  counter in expression1.
Doing so means that the counter can be used within the , but not after leaving the.
Example: ; As this example illustrates, the  body can be an empty statement.
This is always the case if the  header contains all necessary statements.
However, to improve readability, even the empty statement should occupy a  of its own.
In direction  (vertically) the ball is subject to a constant acceleration of 1, expressed as  += 1.
EXERCISES ■ 133 Since the program must not immediately output a single  following a control , you will need to store the predecessor of this.
You may want to use two counters to count the of characters and control characters in the current string.
In both cases use the conditional operator _0_:.
Add these macros and other macros from this chapter to the header file myMacros_0_h and then test the macros.
If your system supports screen control macros, also add some screen control macros to the header.
For example, you could write a macro named COLOR(f,b) to define the foreground and background colors for the following output.
Exercise 2 Modify the program ball1_0_cpp to a.
You will need the functions () and getch() (shown opposite) to solve parts b and  of this problem.
Exercise 3 Write a filter program to display the text contained in any given file_0_The program should filter any control characters out of the input with the exception of the characters \n (end-of-line) and \t (tabulator), which are to be treated as normal characters for the purpose of this exercise.
Control characters are defined by codes 0 to 31.
A sequence of control characters is to be represented by a single space.
A single , that is, a  appearing between two control characters, is not to be output.
SOLUTIONS ■ 137 Exercise 3.
This page intentionally left blank 139 Converting Arithmetic Types This chapter introduces implicit type conversions, which are performed in Cplus_plus whenever different arithmetic types occur in expressions.
Additionally, an operator for explicit type conversion is introduced.
The compiler automatically performs implicit type conversion, where  common type, which allows the operation in question to be performed, is assigned for the values of both operands.
You can generally assume that the "smaller" type will be converted to the "larger" type.
The assignment operator is an exception to this rule and will be discussed separately.
The result of an arithmetic operation belongs to the common type used to perform the calculation.
However, comparison expressions will be bool types no matter what type of operands are involved.
This type conversion is performed so as to preserve the original values.
The boolean value false is converted to 0 and true is converted to 1.
Thus, Cplus_plus will always use int type values or greater when performing calculations.
Given  char variable , the values of  and '' in the expression Example: < '' will be converted to int before being compared.
In this case, the type of the operand with the highest rank in the hierarchy is applied.
These type conversions and integer promotions are collectively known as usual arithmetic type conversions.
In our example, size/10 * , the value of size is first promoted to int before an integer division size/10 is performed.
The interim result 50 is then converted to double and multiplied by.
Usual arithmetic type conversions are performed for all binary operators and the conditional operator _0_: provided the operands belong to an arithmetic type, the only exceptions being the assignment operator and the logical operators && and ||.
Binary representaion of the integer 10 as value of type signed char (8 bits):.
Binary representaion of the integer –10 as value of type signed char (8 bits):.
The value of a negative number changes if the  pattern is interpreted as unsigned.
The  pattern 1111 0110 of –10, for example, corresponds to the unsigned char value 246 == 0*20+ 1*21 + 1*22 + 0*23 + 1*24 + 1*25 + 1*26 + 1*27 ✓ NOTE ■ PERFORMING USUAL ARITHMETIC TYPE CONVERSIONS Converting signed integers a) Converting a positive number b) Converting a negative number The  pattern of –10 is computed by starting with the  pattern of 10 and generating the binary complement (see Binary Representation of Numbers in the appendix).
PERFORMING USUAL ARITHMETIC TYPE CONVERSIONS ■ 143 Usual arithmetic  conversions retain the value of a number provided it can be represented by the new.
The procedure for  conversion depends on the types involved: 1.
Conversion of an unsigned  to a larger integral Examples: unsigned char to int or unsigned int Zero extension is performed first.
During this process, the  pattern of the number to be converted is expanded to match the length of the new  by adding zeros from the left.
Conversion of a signed  to a larger integral ■ The new  is also signed Examples: char to int, short to long Signed integers are represented by generating the binary complement.
The value is retained by performing sign extension.
As shown in the example on the opposite page, the original  pattern is expanded to match the length of the new  by padding the sign  from the left.
If the new  is of the same length, the  pattern is retained.
However, the  pattern will be interpreted differently.
The sign bit loses its significance (see the note opposite).
If the new  is longer, sign extension is performed first and the new bit pattern is then interpreted as unsigned.
Conversion of an integral  to a floating-point Examples: int to double, unsigned long to float The number is converted to an exponential floating-point  and the value retained.
When converting from long or unsigned long to float, some rounding may occur.
Conversion of a floating-point  to a larger floating-point Examples: float to double, double to long double The value is retained during this  conversion.
IMPLICIT TYPE CONVERSIONS IN ASSIGNMENTS ■ 145 Arithmetic types can also be mixed in assignments.
The compiler adjusts the  of the value on the right of the assignment operator to match the  of the variable on the left.
In the case of compound assignments, calculations using normal arithmetic  conversions are performed first before  conversion is performed following the rule for simple assignments.
Two different cases can occur during  conversion in assignments: 1.
If the  of the variable is larger than the  of the value to be assigned, the of the value must be promoted.
The rules for usual arithmetic  conversions are applied in this case (see Example 1).
If the  of the value to be assigned is larger, this  must be "demoted_0_" The following procedures are followed depending on individual circumstances: a.
Conversion of an integral  to a smaller : ■ the  is converted to a smaller  by removing the most significant byte(s).
The bit pattern that remains will be interpreted as unsigned, if the new  is also unsigned, and as signed in all other cases.
The value can only be retained if it can be represented by the new  (see Example 2).
Conversion of a floating-point  to an integral The decimal part of the floating-point number is removed.
For example, 1_0_9 converts to the integer 1.
Rounding can be achieved by adding 0_0_5 to a positive floating-point number or subtracting 0_0_5 from a negative floating-point number.
This would allow for converting (1_0_9 + 0_0_5) to 2.
If the resulting integer is too large or too small for the new , the result is unpredictable.
This particularly applies to converting negative floatingpoint numbers to unsigned integers (see Example 4).
Conversion of a floating-point  to a smaller If the floating-point number falls within the range of the new , the value will be retained, although the accuracy may be compromised.
If the value is too large to be represented by the new , the result is unpredictable (see Example 5).
The function func() has two parameters belonging to the short and double types.
However, the function is called using two int arguments.
This leads to implicit conversion of the value of  to short and the integer 77 to double.
When an int is converted to short the compiler issues a warning, since some data loss may occur.
You can use explicit  conversion to avoid warnings during  conversion.
Syntax: () expression This converts the value of an expression to the given.
Explicit  conversion is also known as casting.
The cast operator () is  unary operator and thus has  higher precedence than the arithmetic operators.
Example: int  = 1,  = 4; double ; = (double)/; In this example the value of  is explicitly converted to  double.
Following the conventions of usual implicit  conversion,  is also converted to double and  floatingpoint division is performed.
The exact result, 0_0_25, is assigned to the variable.
Without casting, an integer division with  result of 0 would have occurred.
Cplus_plus has additional operators  explicit  conversion—the cast operator dynamic_cast<>,  example.
These operators, which are described in later chapters, are required  special circumstances,  example, to perform  checking at runtime when converting classes.
Plot one point of the curve in columns 10, 10+1, _0__0__0_, 10+64 respectively_0_This leads to step value of 2*PI/64 for.
Use the following extended ASCII code characters to draw the axes: Example: << '\020';       // up arrowhead ✓ NOTE Character Decimal Octal – + 196 197 16 30 304 305 020 036 Exercise 1 A function has the following prototype void func( unsigned int n); What happens when the function is called with –1 as an argument.
Exercise 2 How often is the following loop executed.
Exercise 3 What is output when the program opposite is executed.
Exercise 4 Write a Cplus_plus program to output the sine curve on screen as in the graphic shown on the opposite page.
The pattern of –1 is interpreted as unsigned, which yields the greatest unsigned value.
On a 32-bit system, –1 has the bit pattern 0xFFFFFFFF, which, when interpreted as unsigned, corresponds to the decimal value 4 294 967 295.
Exercise 2 The statement within the loop is not executed at all.
In the expression < the value of variable , –1, is implicitly converted to unsigned int and thus it represents the greatest unsigned value (see Exercise 1).
Exercise 3 The screen output of the program v_char:                A        65 v_short:              -2      fffe v_ushort:          65534      fffe v_ulong:                  fffffffe v_float:           -1_0_99 (int)v_float:         -1 Exercise 4.
Besides defining strings we will also look at the various methods of string manipulation_0_These  inserting and erasing, searching and replacing, comparing, and concatenating strings.
Initializing string  = "Good Morning_0_"; Sample program Objects of class string do not necessarily contain the string terminating character '\0', as  the case with C.
During string operations the required memory space  automatically reserved or modified.
The programmer does not need to concern himself or herself with internal memory allocation.
The string class  defined in the string header file and was mentioned in Chapter 3 as an example for the use of classes.
Several operators are overloaded for , that , they were also defined for the string class.
This allows for easy copying, concatenation, and comparison.
Additionally, various methods for string manipulation such as insertion, erasing, searching, and replacing are available.
If a string  not initialized explicitly, an empty string with a length of 0  created.
The length of a string, that , the current number of characters in the string,  stored internally and can be accessed using the length() method or its equivalent size().
Example: string ("Good morning_0_"); << _0_length();   // Output: 13 � String Assignments When you assign a value to a string, the current contents are replaced by a new character sequence.
You can assign the following to a string object: ■ another string ■ a string constant or ■ a single character.
The memory space required  adjusted automatically.
The program on the opposite page uses the function getline(), which was introduced in an earlier chapter, to store a  of  from the keyboard in a string.
In contrast, the >> operator reads only one word, ignoring any leading white space.
In both cases the original content of the string  lost.
Example: string s("winter-story"); string s1("There they go again_0_"), s2("Bob and Bill"); s1_0_replace(6, 4, s2);.
What will be done // Function block.
Chapter 13, Defining Classes, describes the steps for defining member functions.
This makes the program easier to understand, since you start reading at the point where the program starts to execute.
The function test() is shown opposite as an example and followed by the general form of a function.
The example can be read as follows: type is the function type, that is, the type of the return value.
The list can be empty, as for the function (), for example.
A list of declarations that contains only the word void is equivalent to an empty list.
The parameters declared in a list are no more than local variables.
They are created when the function is called and initialized by the values of the arguments.
Example: When test( 10, -7_0_5); is called, the parameter 1 is initialized with a value of 10 and 2 with -7_0_5.
The left curved bracket indicates the start of a function block, which contains the statements defining what the function does.
The only difference when a function is defined is that the name and declaration list are not followed by a semicolon but by a function code block.
The prototype is the declaration of the function and thus describes only the formal interface of that function.
This means you can omit parameter names from the prototype, whereas compiling a function definition will produce machine code.
Stack further local objects return address first parameter last parameter.
Of course the called function cannot change the values of the arguments in the calling function, as it uses copies of the arguments.
However, function arguments can also be passed by reference.
In this case, the function passed  reference to an object as an argument and can therefore access the object directly and modify it.
An example of passing by reference was provided in the example containing the function time().
When time(&sek);  called, the address of the variable sek  passed as an argument, allowing the function to store the result in the variable.
We will see how to create functions of this type later.
Passing by value does, however, offer some important advantages: ■ function arguments can be any kind of expression, even constants, for example ■ the called function cannot cause accidental modifications of the arguments in the calling function ■ the parameters are available as suitable variables within the functions.
Additional indirect memory access  unnecessary.
However, the fact that copying larger objects  difficult can be  major disadvantage, and for this reason vectors are passed by reference to their starting address.
That , they are valid within the function only and not related to any objects or parameters of the same name in any other functions.
For example, the program structure opposite contains  variable  in the function func1() and in the function func2().
The variables do not collide because they reference different memory addresses.
This also applies to the variables  in func1() and func2().
A function's local objects are placed on the stack—the parameters of the function are placed first and in reverse order.
The stack  an area of memory that  managed according to the LIFO (last in first out) principle.
A stack of plates   good analogy.
The last plate you put on the stack has to be taken off first.
The LIFO principle ensures that the last local object to be created is destroyed first.
Copy The executable file only contains one instance of the function's machine code.
The part of the stack occupied by the function is then released.
All this jumping back and forth can affect the run time of your program, especially if the function contains only  few instructions and is called quite often.
The time taken to branch to  small function can be greater than the time needed to execute the function itself.
However, you can define inline functions to avoid this problem.
The definition of an inline function is introduced by the inline keyword in the function header.
Example: {  return  ( >= y.
This is why inline functions should contain no more than one or two instructions.
If an inline function contains too many instructions, the compiler may ignore the inline keyword and issue  warning.
An inline function must be defined in the source file in which it is called.
You cannot simply supply  prototype of the function.
The code containing the instructions must also be available to the compiler.
It therefore makes sense to define inline functions in header files, in contrast to "normal" functions.
When  macro is called, the preprocessor simply replaces  block of text.
In contrast, an inline function behaves like  normal function, although the program flow is not interrupted by the function branching.
The compiler performs  type check, for example.
A function defined with default arguments is always called with the full number of arguments.
For reasons of efficiency it may be useful to define several versions of the same function.
This allows you to omit some arguments when calling the function.
The compiler simply uses the default values for any missing arguments.
In other words, you need to supply them when you declare the function.
Example: void moveTo(   = 0,   = 0); Parameter names can be omitted, as usual.
Example: void moveTo(  = 0,  = 0); The function moveTo() can then be called with or without one or two arguments.
Example: moveTo (); moveTo (24); moveTo(24, 50); The first two calls are equivalent to moveTo(0,0); or moveTo(24,0);.
It is also possible to define default arguments for only some of the parameters.
The following general rules apply: ■ the default arguments are defined in the function prototype.
They can also be supplied when the function is defined, if the definition occurs in the same source file and before the function is called ■ if you define a default argument for a parameter, all following parameters must have default arguments ■ default arguments must not be redefined within the prototype scope (the next chapter gives more details on this topic).
You can use default arguments to call a function with a different number of arguments without having to write a new  of the function.
This page intentionally left blank 197 Storage Classes and Namespaces This chapter begins by describing storage classes for objects and functions_0_The storage class  responsible for defining those parts of program where an object or function can be used.
Namespaces can be used to avoid conflicts when naming global identifiers.
The following storage class specifiers can be used extern static auto register STORAGE CLASSES OF OBJECTS ■ 199 When an object  declared, not only are the object's type and name defined but also its storage class.
The storage class specifies the lifetime of the object, that , the period of time from the construction of the object until its destruction.
In addition, the storage class delimits the part of the program in which the object can be accessed directly by its name, the so-called object scope.
Essentially, an object  only available after you have declared it within  translation unit.
A translation unit, also referred to as module, comprises the source file you are compiling and any  files you have included.
As  programmer, you can define an object : ■ block scope The object  only available in the code block in which it was defined.
The object  no longer visible once you have left the code block.
Only the functions within this module can reference the object.
Other modules cannot access the object directly.
For this reason, these objects are often referred to as global.
Access to an object as defined by the object's storage class  independent of any access controls for the elements of  class.
Namespaces that subdivide program scope and classes will be introduced at  later stage.
Such objects can only be accessed by statements within that block and are called local to that block.
The memory used for these objects  freed after leaving the code block.
In this case, the lifetime of the objects  said to be automatic.
However, it  possible to define objects  block scope that are available throughout the runtime of  program.
The lifetime of these objects  said to be static.
When the program flow re-enters  code block, any pre-existing conditions will apply.
Objects  program and file scope are always static.
These objects are created when program is launched and are available until the program is terminated.
Four storage classes are available for creating objects  the scope and lifetime you need.
These storage classes will be discussed individually in the following sections.
Objects in this storage class have program scope and can be read and, provided they have not been defined as const, modified at any place in the program.
External objects thus allow you to exchange information between any functions without passing any arguments.
To demonstrate this point, the program on the opposite page has been divided into two separate source files.
The string , which has a global definition, is used to exchange data.
Global objects that are not explicitly initialized during definition receive an initial value of 0 (that is, all  = 0) by default.
This also applies to objects belonging to class types, if not otherwise stipulated by the class.
If you need to use an object before defining it or in another module, you must first declare the object.
If you do not declare the object, the compiler issues a message stating that the object is unknown.
The declaration makes the name and type of the object known to the compiler.
In contrast to a definition, the storage class identifier extern precedes the object name in a declaration.
Example: extern long position;     // Declaration This statement declares position as an external object of type long.
The extern declaration thus allows you to "import" an object from another source file.
A global object must be defined once, and once only, in a program.
However, it can be declared as often as needed and at any position in the program.
You will normally declare the object before the first function in a source file or in a header file that you can when needed.
This makes the object available to any functions in the file.
Remember, if you declare the object within a code block, the object can only be used within the same block.
An extern declaration only refers to an object and should therefore not be used to initialize the object.
If you do initialize the object, you are defining that object.
Global objects affect the whole program and should be used sparingly.
Large programs in particular should contain no more than a few central objects defined as extern.
Example: static int ; The most important characteristic of static objects is their static (or permanent) lifetime.
Static objects are not placed on the stack, but are stored in the data area of a program just like external objects.
However, in contrast to external objects, access to static objects is restricted.
Two conditions apply, depending on where the object is defined: 1.
Definition external to all program functions In this case, the object is external static, that is, the object can be designated using its name within the module only, but will not collide with any objects using the same name in other modules.
Definition within a code block This means that the object is internal static, that is, the object is only visible within a single block.
However, the object is created only once and is not destroyed on leaving the block.
On re-entering the block, you can continue to work with the original object.
The same rules apply to initializing static objects as they do to external objects.
If the object is not initialized explicitly, a default value of 0 applies.
Permission is refused following three unsuccessful attempts or when 60 seconds have elapsed.
You could use the following instructions to call the function in another source file: Example: << "No authorization_0_\n"; exit(1); The string  and the thresholds  and  are external static, whereas the variable  in the function timediff() is internal static.
Its value is zero only when the function is first called.
It makes sense to add a further function to these source files providing for changes.
White spaces // and a sign can precede the sequence of digits.
The parameters of a function are also auto objects.
You can use the auto keyword during a definition.
Example: auto float radius; // Equivalent to: // float radius; When the program flow reaches the definition, the object is created on the stack, but in contrast to a static type object, the object is destroyed on leaving the block.
However, objects belonging to a class type are normally initialized with default values, which can be specified in the class definition.
In this case, the register keyword is used to declare the object.
A register is normally the size of an int variable.
In other words, it only makes sense to define register variables if the variable is not too large, as in the case of types such as char, short, int or pointers.
If you omit the type when defining a register variable, an int is assumed.
However, the compiler can ignore the register keyword.
The number of registers available for register variables depends on your hardware, although two registers are normally available.
If a program defines too many register variables in a code block, the superfluous variables are placed in the auto storage class.
This is useful if you need to perform calculations with a  contained in a string.
The algorithm using the string "37" and the long variable : Step 0: = 0; Step 1: =  * 10 + 3;        // = 3 Step 2: =  * 10 + 7;        // = 37 This pattern is followed for every  in a longer string.
Functions with block scope are invalid: you cannot define a function within another function.
The storage class of a function defines access to the function, as it does for an object.
External functions have program scope, whereas static functions have file scope.
In a similar manner to external objects, external functions can be used at any position in a program.
If you need to call a function before defining it, or in another source file, you will need to declare that function.
Example: extern bool getPassword(void); // Prototype As previously seen, you can omit the extern keyword, since functions belong to the extern storage class by default.
They can only be called in the source file that defines them.
The name of a static function will not collide with objects and functions of the same name in other modules.
If you need to call a static function before defining it, you must first declare the function in the source file.
Example: static long timediff( void ); The program structure opposite takes up the example with the functions getPassword() and timediff() once more.
The function timediff() is an auxiliary function and not designed to be called externally.
The function is declared as static for this reason.
Cplus_plus provides for the use of namespaces in order to avoid naming conflicts with global identifiers.
Within a namespace, you can use identifiers without needing to check whether they have been defined previously in an area outside of the namespace.
Thus, the global scope is subdivided into isolated parts.
A normal namespace is identified by a name preceded by the namespace keyword.
The elements that belong to the namespace are then declared within braces.
Example: namespace myLib.
Elements belonging to a namespace can be referenced directly by name within the namespace.
If you need to reference an element from outside of the namespace, you must additionally supply the namespace.
To do so, place the scope resolution operator, ::, before the element name.
Example: myLib:: = 7;     // Outside of myLib This allows you to distinguish between identical names in different namespaces.
You can also use the scope resolution operator :: to reference global names, that is, names declared outside of any namespaces.
To do so, simply omit the name of the namespace.
This technique is useful when you need to access a global name that is hidden by an identical name defined in the current namespace.
Example: ::demo();  // Not belonging to any namespace Be aware of the following when using namespaces: ■ namespaces do not need to be defined contiguously.
You can reopen and expand a namespace you defined previously at any point in the program ■ namespaces can be nested, that is, you can define a namespace within another namespace.
Global identifiers belonging to the Cplus_plus standard library automatically belong to the standard namespace std.
In this case, you do not need to repeatedly quote the namespace.
Just like normal declarations, using declarations and using directives can occur at any part of the program.
Example: using myLib::calculate;    // Declaration You can then call the function calculate() from the myLib namespace.
Example: using namespace myLib; This statement allows you to reference the identifiers in the myLib namespace directly.
If myLib contains an additional namespace and a using directive, this namespace is also imported.
If identical identifiers occur in the current namespace and an imported namespace, the using directive does not automatically result in a conflict.
However, referencing an identifier can lead to ambiguities.
In this case, you should use the scope resolution operator to resolve the situation.
Cplus_plus header files without file extensions are used to declare the global identifiers in the standard namespace std.
The using directive was used in previous examples to import any required identifiers to the global scope: Example: # <> using namespace std; When developing large-scale programs or libraries, it is useful to declare the elements of any proprietary namespaces in header files.
Normal source files are used to define these elements.
However, if you define a name for an  within a code block and the name is also valid for another , you will reference only the new  within the code block.
The new  hides any  using the same name outside of the block.
When you leave the code block, the original  once more becomes visible.
The program on the opposite page uses identical variable names in different blocks_0_What does the program output on screen.
Exercise 2 You are developing a large-scale program and intend to use two commercial libraries, tool1 and tool2_0_The names of types, functions, macros, and so on are declared in the header files tool1_0_h and tool2_0_h for users of these libraries.
Unfortunately, the libraries use the same global names in part.
In order to use both libraries, you will need to define namespaces.
Write the following program to simulate this situation: ■ Define an inline function called calculate() that returns the sum of two numbers for the header file tool1_0_h_0_The function interface is as follows: double calculate(double num1, double num2); ■ Define an inline function called calculate() that returns the product of two numbers for a second header file tool2_0_h_0_This function has the same interface as the function in tool1_0_h.
To resolve potential naming conflicts, define the namespaces TOOL1 and TOOL2 that  the relevant header files.
It is syntactically simpler to use references, although not always permissible.
A parameter of a reference type is an alias for an argument.
When a function is called, a reference parameter is initialized with the object supplied as an argument.
The function can thus directly manipulate the argument passed to it.
Example: void test( int& a) { plus_plusa; } Based on this definition, the statement test( var);     // For an int variable var increments the variable var.
Within the function, any access to the reference a automatically accesses the supplied variable, var.
If an object is passed as an argument when passing by reference, the object is not copied.
Instead, the address of the object is passed to the function internally, allowing the function to access the object with which it was called.
The argument must have an address in memory and be of the correct type.
Using references as parameters offers the following benefits: ■ arguments are not copied.
In contrast to passing by value, the run time of a program should improve, especially if the arguments occupy large amounts of memory ■ a function can use the reference parameter to return multiple values to the calling function.
Passing by value allows only one result as a return value, unless you resort to using global variables.
If you need to read arguments, but not copy them, you can define a read-only reference as a parameter.
Example: void display( const & ); The function display() contains a  as an argument.
However, it does not generate a new  to which the argument  is copied.
Instead,  is simply a reference to the argument.
The caller can rest assured that the argument is not modified within the function, as  is declared as a const.
The function call then represents an object, and can be used just like an object.
This function returns  reference to  static ,.
Pay attention to the following point when returning references and pointers: The object referenced by the return value must exist after leaving the function.
It would be  critical error to declare the   as  normal auto variable in the function ().
This would destroy the  on leaving the function and the reference would point to an object that no longer existed.
Then  new  is appended before the length of the referenced  is output in the third statement.
If you want to avoid modifying the referenced object, you can define the function type as  read-only reference.
Example: const & ();     // Read-only.
References are commonly used as return types when overloading operators.
The operations that an operator has to perform for  user-defined type are always implemented by an appropriate function.
Refer to the chapters on overloading operators later in this book for more details.
However, examples with operators from standard classes can be provided at this point.
Example: Operator << of class ostream << "Good " << '_0_'; Sample assignments of class EXPRESSIONS WITH REFERENCE TYPE ■ 229 Every Cplus_plus expression belongs to  certain type and also has  , if the type is not void.
Reference types are also valid for expressions.
Example: This expression is not  void type but  reference to the object , that is, it represents the object.
This allows you to repeatedly use the << on the expression: << "Good " << '_0_' The expression is then equivalent to ( << " Good  ") << '_0_' Expressions using the <<  are composed from left to right,  you can see from the table of precedence contained in the appendix.
Similarly, the expression cin >> variable represents the stream cin.
This allows repeated use of the >>.
Example: int ;  double ; cin >>  >> ;       // (cin >> ) >> ; � Other Reference Type Operators Other commonly used reference type operators  the simple assignment  = compound assignments, such  +=  *=.
These operators return  reference to the operand on the left.
In an expression such = b or  += b must therefore be an object.
In turn, the expression itself represents the object.
This also applies when the operators refer to objects belonging to class types.
However, the class definition stipulates the available operators.
For example, the assignment operators =  += are available in the standard class.
Example: ("Jonny "); += "Depp";          //Reference to Since an expression of this type represents an object, the expression can be passed an argument to  function that is called by reference.
This point is illustrated by the example on the opposite page.
Linked lists or trees whose elements are generated dynamically at runtime are typical examples.
Using the address , &, for  given object creates  pointer to that object.
Given that  is an int variable, Example: &         // Address of the object is the address of the int object in memory  thus  pointer to.
A pointer points to  memory address  simultaneously indicates by its type how the memory address can be read or written to.
Thus, depending on the type, we refer to pointers to char, pointers to int,  so on, or use an abbreviation, such  char pointer, int pointer,  so on.
Example: int *;            // or:  int* ; This statement defines the variable , which is an int* type (in other words,  pointer to int).
In  declaration, the star char Pointer types are derived types.
The general form is T*, where T can be any given type.
In the above example T is an int type.
Objects of the same base type T can be declared together.
Example: int , *p, & = ;  // Definition of , p, After declaring  pointer variable, you must point the pointer at   address.
The program on the opposite page does this using the statement = &;.
However,  pointer is not merely an alias but an individual object that has an identity separate from the object it references.
A pointer has its own  address  can be manipulated by pointing it at  new  address  thus referencing  different object.
That is, it occupies as much space as is necessary to store an address.
On a 32-bit computer, such as a PC, this is four bytes.
This allows for efficient storage management and the swapping of currently unused  blocks to the hard disk.
Thus, the special value 0 is used to indicate an error.
For pointers, the symbolic constant NULL is defined as 0 in standard header files.
A pointer containing the value NULL is also called NULL pointer.
THE INDIRECTION OPERATOR ■ 233 � Using Pointers to Access Objects The indirection operator * is used to access an object referenced by  pointer: Given  pointer, , * is the object referenced by.
As  programmer, you must always distinguish between the pointer  and the addressed object *.
This assigns the value of  to , since  points to.
The assignment  = ; would return the same result.
The expression * represents the object , and can be used wherever  could be used.
The star character * used for defining pointer variables is not an operator but merely imitates the later use of the pointer in expressions.
Thus, the definition long *; has  following meaning:  is  long* (pointer to long) type and * is  long type.
The indirection operator * has high precedence, just like  address operator &.
Both operators are unary, that is, they have only one operand.
This also helps distinguish redirection operator from  binary multiplication operator *, which always takes two operands.
The term L-value occurs commonly in compiler error messages and is derived from  assignment.
The left operand of  = operator must always designate   address.
Expressions other than an L-value are often referred to as R-values.
A variable name is  simplest example of an L-value.
However,  constant or an expression, such as x + 1, is an R-value.
The indirection operator is one example of an operator that yields L-values.
Given  pointer variable p, both p and *p are L-values, as *p designates  object to which p points.
POINTERS AS PARAMETERS ■ 235 � Objects as Arguments If an object is passed as an argument to  function, two possible situations occur: ■  parameter in question is  same type as  object passed to it.
The func ■  parameter in question is  reference.
The parameter is then an alias for argument, that is,  function that is called manipulates  object passed by calling function (passing by reference).
In  first case,  argument passed to  function cannot be manipulated by function.
This is not true for passing by reference.
However, there is  third way of passing by reference—passing pointers to  function.
The answer is quite simple: The parameter must be declared as  pointer variable.
If, for example,  function func() requires  address of an int value as an argument, you can use  following statement Example:.
If  function knows  address of an object, it can of course use  indirection operator to access and manipulate  object.
In  program on  opposite page,  function swap() swaps  values of variables  and  in  calling function.
The function swap() is able to access  variables since  addresses of these variables, that is & and &, are passed to it as arguments.
The parameters 1 and 2 in swap() are thus declared as float pointers.
The statement swap( &, &); initializes  pointers 1 and 2 with  addresses of  or.
When  function manipulates  expressions *1 and *2, it really accesses  variables  and  in calling function and exchanges their values.
Test values Quadratic Equation Solutions 22 - 2 - 1_0_5 = 0 1 = 1_0_5,  2 = -0_0_5 2 - 6 + 9 = 0 1 = 3_0_0,  2 = 3_0_0 22 + 2 = 0 none EXERCISES ■ 237 Given a circle with radius r: =  * r * r and  = 2 *  * r where  = 3_0_1415926536 ✓ NOTE Exercise 1 What happens if  parameter in  sample function strToUpper() is declared as a string& instead of a string.
Exercise 2 Write a void type function called circle()to calculate   and area of a circle_0_The radius and two variables are passed to  function, which therefore has three parameters: Parameters: A read-only reference to double for  radius and two references to double that  function uses to store  area and  of  circle.
Test the function circle() by outputting a table containing the radius, the , and the area for the radii 0_0_5, 1_0_0, 1_0_5,.
Exercise 3 a.
The version of the function swap() opposite can be compiled without producing any error messages.
However, the function will not swap the values of  and  when swap(&,&); is called_0_What is wrong.
Test the correct pointer version of the function swap() found in this chapter_0_Then write and test a version of the function swap() that uses references instead of pointers.
Exercise 4 Create a function quadEquation() that calculates the solutions to quadratic equations_0_The formula for calculating quadratic equations is shown opposite.
Arguments: The coefficients a, b,  and two pointers to both solutions.
Returns: false, if no real solution is available, otherwise true.
Test the function by outputting the quadratic equations on the opposite page and their solutions.
But instead of passing by reference, a passing by value occurs, i_0_e_0_, the function manipulates a local copy.
Thus, only a local copy of the string is changed in the function, but the string in the calling function remains unchanged.
This page intentionally left blank 243 Defining Classes This chapter describes how classes are defined and how instances of classes, that is, objects, are used.
In addition, structs and unions are introduced as examples of special classes.
Properties: Date when   = 1990 = 100 = 11111.
Methods (Member functions): to run, to brake, to park, to turn off.
A class defines the properties and capacities of an object.
Objects and processes are reduced to basics and referred to in generic terms.
Classes allow more direct use of the results of this type of abstraction in software development.
The first  towards solving  problem is analysis.
In object-oriented programming, analysis comprises identifying and describing objects and recognizing their mutual relationships.
Object descriptions are the building blocks of classes.
In Cplus_plus,  class is  user-defined type.
It contains data members, which describe the properties of the class, and member functions, or methods, which describe the capacities of the objects.
Classes are simply patterns used to instantiate, or create, objects of the class type.
In other words, an object is  variable of  given class.
An application program accesses objects by using the public methods of the class and thus activating its capacities.
Access to object data is rarely direct, that is, object data is normally declared as private and then read or modified by methods with public declarations to ensure correct access to the data.
One important aspect of this technique is the fact that application programs need not be aware of the internal structure of the data.
If needed, the internal structure of the program data can even be modified.
Provided that the interfaces of the public methods remain unchanged, changes like these will not affect the application program.
This allows you to enhance an application by programming an improved class version without changing a single byte of the application.
An object is thus seen to encapsulate its private structure, protecting itself from external influences and managing itself by its own methods.
This describes the concept of data encapsulation concisely.
The definition begins with the keyword class followed by the class name.
The data members and methods are then declared in the subsequent code block.
Data members and member functions can belong to any valid type, even to another previously defined class.
At the same time, the class members are divided into: ■ private members, which cannot be accessed externally ■ public members, which are available for external access.
The public members form the so-called public interface of the class.
The opposite page shows a schematic definition of a class.
The private section generally contains data members and the public section contains the access methods for the data.
This provides for data encapsulation.
The following example includes a class named Account used to represent a bank account.
The data members, such as the name of the account holder, the account , and the account balance, are declared as private.
In addition, there are two public methods, init() for initialization purposes and display(), which is used to display the data on screen.
The labels private: and public: can be used at the programmer's discretion within a class: ■ you can use the labels as often as needed, or not at all, and in any order.
A section marked as private: or public: is valid until the next public: or private: label occurs ■ the default value for member access is private.
If you omit both the private and public labels, all the class members are assumed to be private.
These rules often reflect the target platform and the class libraries used.
For the purposes of this book, we decided to keep to standard naming conventions for distinguishing classes and class members.
Class names begin with an uppercase letter and member names with a lowercase letter.
Members of different classes can share the same name.
A member of another class could therefore also be named display().
Only then can the objects of the class be used.
Within a method, all the members of a class can be designated directly using their names.
The class membership is automatically assumed.
In particular, methods belonging to the same class can call each other directly.
Access to private members is only possible within methods belonging to the same class.
Thus, private members are completely controlled by the class.
Defining a class does not automatically allocate memory for the data members of that class.
To allocate memory, you must define an object.
When a method is called for a given object, the method can then manipulate the data of this object.
In this case, you will need to place the class definition in a header file.
If you place the definition of the class Account in the file Account_0_h, any source file including the header file can use the class Account.
Methods must always be defined within a source file.
This would mean defining the methods for the class Account in a source file named Account_0_cpp, for example.
The source code of the application program, for example, the code containing the function main, is independent of the class and can be stored in separate source files.
Separating classes from application programs facilitates re-use of classes.
In an integrated development environment, a programmer will define a project to help manage the various program modules by inserting all the source files into the project.
When the project is compiled and linked, modified source files are automatically re-compiled and linked to the application program.
You can assign this address to a suitable pointer.
Example: savings("Mac, Rita",654321, 123_0_5); * = &savings; This defines the object savings and a pointer variable called.
The pointer  is initialized so that it points to the object savings.
This makes * the object savings itself.
You can then use the statement Example: (*)_0_display(); to call the method display() for the object savings.
Parentheses must be used in this case, as the.
Syntax: objectPointerarrow_operatormember This expression is equivalent to (*objectPointer)_0_member The  arrow_operator is made up of a minus sign and the greater than sign.
Example: ptrAccountarrow_operatordisplay(); This statement calls the method display() for the object referenced by , that is, for the object savings.
The statement is equivalent to the statement in the previous example.
The difference between the class member access operators.
A function that gets the address of an object as an argument can manipulate the referenced object directly.
The to read the data for a new.
When called, the address of the  is passed: The function can then use the pointer  and the init() method to write new data to the referenced object.
Extensive data such as the data for the articles in an automobile manufacturer's stocks can be organized for ease of viewing and stored in files.
From the viewpoint of an object-oriented language, a record is merely a class containing only public data members and no methods.
Thus, you can use the class keyword to define the structure of a record in Cplus_plus.
Example: class Date { public:   short month, day, year; }; However, it is common practice to use the keyword struct, which is also available in the C programming language, to define records.
The above definition of Date with the members day, month, and year is thus equivalent to: Example: struct Date { short month, day, year; }; � The Keywords class and struct You can also use the keyword struct to define a class, such as the class.
The keywords class and struct only vary with respect to data encapsulation; the default for access to members of a class defined as a struct is public.
In contrast to a class defined using the class keyword, all the class members are public unless a private label is used.
This allows the programmer to retain C compatibility.
Example: future; future.
Public data Records in the true sense of the word, that is, objects of a class containing only public members, can be initialized by means of a list during definition.
Example: = { 1, 29, 1987}; The first element in the list initializes the first data member of the object, and so on.
However, a union is a class whose members are stored in the same memory space.
Each data member has the same starting address in memory.
Of course, a union cannot store various data members at the same address simultaneously.
However, a union does provide for more versatile usage of memory space.
Example: union Number.
This example defines the union Number and two objects of the same type.
The union Number can be used to store either integral or floating-point numbers.
Unless a private label is used, all union members are assumed to be public.
This is similar to the default setting for structures.
This allows direct access to the members and  in the union Number.
This is normally achieved using an additional type field that identifies the current content.
The size of a union type object is derived from the longest data member, as all data members begin at the same memory address.
If we look at our example, the union Number, this size is defined by the double member, which defaults to 8 == sizeof(double).
The example opposite defines the union WordByte that allows you to read or write to a 16-bit memory space  for  or as a unit.
The method print() outputs the date to standard output using the format -Day-Year.
The method init() uses three parameters and copies the values passed to it to corresponding members_0_A range check is not required at this stage, but will be added later.
The method init() without parameters writes the current date to the corresponding members.
The structure  and sample calls to this function are included opposite_0_The type time_t is defined as long in ctime.
The function time() returns the system time expressed as a number of seconds and writes this value to the variable referenced by ptrSec.
This value can be passed to the function localtime() that converts the number of seconds to the local type  date and returns a pointer to this structure.
Use object assignments and—as an additional exercise—references and pointers to objects.
Demo:: ~Demo()              // Defining  destructor.
The tasks involved in cleaning up  releasing memory and closing files.
Objects are cleaned up by a special method called a destructor, whose  is made up of  class  preceded by ∼ (tilde).
Neither does it have any parameters, which makes  destructor impossible to overload.
Each class thus has one destructor only.
If  class does not define a destructor,  compiler will create a minimal version of a destructor as a public member, called  default destructor.
It is important to define a destructor if certain actions performed by  constructor need to be undone.
If  constructor opened a file, for example,  destructor should close that file.
The destructor in  Account class has no specific tasks to perform.
The explicit definition is thus: Account::∼Account(){}        // Nothing to do The individual data members of an object are always removed in  order opposite of order in which they were created.
The first data member to be created is therefore cleaned up last.
If a data member is also a class type object,  object's own destructor will be called.
The sample program on  opposite page illustrates various implicit calls to constructors and destructors.
This is  only way to ensure data encapsulation and class functionality.
However, continually calling "short" methods can impact a program's runtime.
In fact, saving a re-entry address and jumping to  called function and back into  calling function can take more time than executing  function itself.
To avoid this overhead, you can define inline methods in a way similar to defining inline global functions.
In  first case,  method is declared within the class, just like any other method.
You simply need to place the inline keyword before the method  in the function header when defining the method.
Short methods can be defined within the class.
Methods of this type are known as implicit inline methods, although the inline keyword is not used.
Example: // Within class Account: bool isPositive(){ return  > 0; } � Constructors and Destructors with inline Definitions Constructors and destructors are special methods belonging to a class and, as such, can be defined as inline.
This point is illustrated by the new  of the Account class opposite.
The constructor and the destructor are both implicit inline.
The constructor has a default value for each argument, which means that we also have a default constructor.
You can now define objects without supplying an initialization list.
Example: temp; Although we did not explicitly supply values here, the object temp was correctly initialized by the default constructor we defined.
To allow access to this data, you could place the data members in the public section of the class; however, this would undermine any attempt at data encapsulation.
Access methods offer a far more useful way of accessing the private data members.
Access methods allow data to be read and manipulated in a controlled manner.
If the access methods were defined as inline, access is just as efficient as direct access to the public members.
In the example opposite, several access methods have been added to the class.
You can now use the methods to read the individual data members.
As is illustrated in getName(), references should be read-only when used as return values.
Direct access for write operations could be possible otherwise.
To manipulate data members, the following methods can be used: setName(), setNr(), setState().
This allows you to define a new , as follows: Example: save_0_setState( 2199_0_0); � Access Method Benefits Defining access methods for reading and writing to each  member may seem like a lot of work—all that typing, reams of source code, and the programmer has to remember the names and tasks performed by all those methods.
So, you may be asking yourself how you benefit from using access methods.
There are two important issues: ■ Access methods can prevent invalid access attempts at the onset by performing sanity checks.
If a class contains a member designed to represent positive numbers only, an access method can prevent processing negative numbers.
It is therefore possible to modify the internal structure of your  at a later stage.
If you detect that a new  structure will allow more efficient  handling, you can add this modification to a new  of the class.
Provided the public interface to the class remains unchanged, an application program can be leveraged by the modification without needing to modify the application itself.
You simply recompile the application program.
As mentioned earlier, the object must be initialized when you define it for this reason.
Example: const  inv("YMCA, FL", 5555, 5000_0_0); The object inv cannot be modified at a later stage.
This also means that methods such as setName() cannot be called for this object.
However, methods such as getName or display() will be similarly unavailable although they only perform read access with the  members.
The reason for this is that the compiler cannot decide whether a method performs write operations or only read operations with  members unless additional information is supplied.
To identify a method as read-only, append the const keyword in the method declaration and in the function header for the method.
Example: unsigned long getNr() const; This declares the getNr() method as a read-only method that can be used for constant objects.
Example: << " : " << inv_0_getNr(); Of course, this does not prevent you from calling a read-only method for a non-constant object.
The compiler issues an error message if a read-only method tries to modify a member.
This also occurs when a read-only method calls another method that is not defined as const.
In addition, this chapter describes constant members and enumerated types.
However, in the case of the class there is nothing to do at present.
Correct values are assigned later.
This additional action can impact your program's performance.
When defining a constructor, you can use member initializers to ensure general and efficient use of member objects.
Example: (hr,min,sec)      // Member initializer Multiple member initializers are separated by commas.
A list of member initializers defined in this way follows the constructor header and is separated from the header by a colon.
Example: {  /* Function block  */ } This ensures that a suitable constructor will be called for data members with member initializers and avoids calls to the default constructor with subsequent assignments.
As the example shows, you can also use member initializers for data members belonging to fundamental types.
The argument names of the member initializers are normally constructor parameters.
This helps pass the values used to create an object to the right member object.
Member initializers can only be stated in a constructor definition.
The constructor declaration remains unchanged.
For example, you could set the  for a measurement once and not change this time subsequently.
However, you need to be able to edit the measurement value to correct systematic errors.
In this case, the member object time can be declared as follows: Example: const  ; Since the const member object  cannot be modified by a later assignment, the correct constructor must be called to initialize the object.
In other words, when you define a constructor for a , you must also define a member initializer for each const member object.
Example: = (st, mn, sk);   // Error.
However, the later versions of these constructors are ok.
The member initializer ensures that the desired initial values are used to create the member object.
The compiler will issue an error message at this point and for any statement in the current program that attempts to modify the static member, This means that a programmer cannot accidentally overwrite a member declared as a const.
The new  of the Result  no longer contains a default constructor, since a default value for the  of the measurement does not make sense.
The  Client contains a number, nr, which is used to identify customers.
Since the client number never changes, it makes sense to define the number as const.
The constructor for Client would then read as follows: Example: { /*_0__0__0_*/ } The member initializer nr(plus_plusid) initializes the const data member nr with the global value id, which is incremented prior to use.
This means that the data members of two different objects will be stored at different memory addresses.
However, sometimes it is useful to keep some common data that can be accessed by all the objects belonging to a , for example: ■ figures such as exchange rates, interest rates or  limits which have the same value for every object ■ status information, such as the number of objects, current minimum or maximum threshold values, or pointers to some objects; for example, a pointer to an active window in a window.
This kind of data needs to be stored once only, no matter how many objects exist.
Since a programmer will also need to manage the data from within the , it should be represented within the  rather than globally.
Static data members can be used for this purpose.
In contrast to normal data members, static data members occur only once in memory.
On the opposite page, the following statement Example: static double , ;   // Declaration defines two static data members called  and  that record the minimum and maximum values for the measurements.
Just like member functions, which occur only once, static data members must be defined and initialized in an external source file.
The range operator :: is then used to relate the data members to the.
Example: double :: = 0_0_0;  // Definition As the example illustrates, the static keyword is not used during the definition.
Static data members and member functions belonging to the same  are normally defined in one source file.
An enumeration is defined using the enum keyword.
A range of values and a name for these values are also defined at the same time.
Example: enum { Line, Rectangle, Ellipse}; This statement defines the enumerated type.
The names quoted in the list identify integral constants.
Their values can be deduced from the list order.
The first constant has a value of 0, and each subsequent constant has a value that is one higher than its predecessor.
In the previous example, Line thus represents a value of 0, Rectangle a value of 1, and Ellipse a value of 2.
A  type variable can only assume one of these values.
Example: enum  {  = -100,  = 100}; You can leave out the type name, if you only need to define the constants.
Example: enum { , =0, , =1 }; This statement defines the constants  and , setting their value to 0, and the constants  and  with a value of 1.
The values for  and  are implicit.
In contrast to #define directives, which merely replace text strings, enum constants are part of a declaration and thus have a valid range.
This allows you to define constants that are visible within a namespace or  only.
The example on the opposite page shows the enumerated type , which was defined within the.
This means that the type and enum constant are only available for direct use within the.
The enumeration itself is declared  public, however, and access from outside the  is therefore possible.
The Member Class int string const Date Member Number Name Birthday //Possibly more information, such  an address, telephone number,  _0__0_.
Constructor with one parameter for each data member Access methods for each data member.
The birthday is read-only.
A method for formatted screen output  of all  data members Private Data Members Public Methods Type EXERCISES ■ 311 Exercise 1 In the first exercise of the last chapter you defined a simple class called Article_0_This involved using a global counter to log object creation and destruction.
Improve and extend the Article class  follows: ■ Use a static data member instead of a global variable to count the current number of objects.
The method returns the current number of objects.
Tip: Use member initializers.
Exercise 2 A sports club needs a program to manage its members_0_Your task is to define and test a class called  for this purpose.
Use the Date class defined in the last chapter for your definition.
Since a member' birthday will not change, the data member for birthdays must be defined  a const.
Overload the constructor to allow for entering a date  an object well  three values for day, month, and year.
If no has been appointed, the pointer should point to NULL.
Use a pointer to set and return the object in question.
Terminate this program with <Ctrl>+<C>.
Light minus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusRED          AMBER GREEN AMBER AMBER          RED GREEN AMBER RED          AMBER GREEN //.
Sample output 1.
The function time() is declared in the header file ctime.
The call time(NULL) determines the number of seconds of type time_t since 1_0_1_0_1970, 0:0 hours_0_The type time_t is defined as long.
Instead of calling the function time() in a loop, you can use the function Sleep() for Windows or the function sleep() for Unix.
These system calls are not standardized, yet they are much more effective because they send a process to sleep instead of using a waiting loop.
EXERCISES ■ 313 Exercise 3 Create a program to simulate the signal positions for two sets of traffic lights at a junction.
Use the class Lights as defined in this chapter for your program.
For example, the green phase can take 20 seconds and the amber phase 1 second_0_These values can be different for each set of lights.
Define an auxiliary function The function returns after the stipulated number of seconds_0_To do so, you can call the standard function time() in a loop.
Don't forget to read the notes on the opposite page.
SOLUTIONS ■ 317 Exercise 2 The Date class from the last chapter ( see files Date_0_h and Date_0_cpp ) can be left unchanged.
But it makes sense to define the function isLeapYear()as a static member function of class Date rather than globally.
An array always occupies a contiguous memory space.
In the case of the array arr, this space is 10*sizeof() = 40 bytes.
In Cplus_plus an index always begins at zero.
The elements belonging to the array arr are thus arr[0], arr[1] , arr[2], _0__0_.
Any int expression can be used as an index.
The subscript operator [] has high precedence, just like the class member operators.
No error message is issued if the index exceeds the valid index range.
As a programmer, you need to be particularly careful to avoid this error.
However, you can define a class to perform range checking for indices.
You can create an array from any type with the exception of some special types, such as void and certain classes.
Class  are discussed later.
Example: short number[20];          // short array number[] = (short)(*10); This example defines an array called number with 20 short elements and assigns the values 0, 10, 20, _0__0_.
If you initialize an array when you define it, you do not need to state its length.
Example: int [] = { 30, 50, 80 }; In this case, the length of the array is equal to the number of initial values.
If the array length is explicitly stated in the definition and is larger than the number of initial values, any remaining array elements are set to zero.
If, in contrast, the number of initial values exceeds the array length, the surplus values are ignored.
Locally defined  are created on the stack at program runtime.
You should therefore be aware of the following issues when defining : ■ Arrays that occupy a large amount of memory (e_0_g_0_, more than one kbyte) should be defined as global or static.
Values are normally assigned by means of a loop.
You cannot assign a vector to another vector.
However, you can overload the assignment operator within a class designed to represent.
This topic will be discussed in depth later.
Fibonacci numbers are useful for representing natural growth.
In computer science, Fibonacci numbers are used for things like memory management and hashing.
Their definition is as follows: ■ the first Fibonacci number is 0, the second is 1 ■ each subsequent Fibonacci number is the sum of its two immediate predecessors.
This results in the following sequence: 0, 1, 1, 2, 3, 5, 8, 13, _0__0__0_.
The quotient of a Fibonacci number and its predecessor is referred to as a Fibonacci quotient.
The sequence of Fibonacci quotients, 1/1, 2/1, 3/2, _0__0__0_, converges towards the threshold value (1 + √5)/2.
The array text has length of 40, whereas the string "Hello Eve" only occupies the first 9 bytes.
Example: char buffer[10*512];    // 5 Kbyte buffer However, their most common use is for string storage.
One way of representing a string is to store the string and the terminating null character '\0' in a char array.
When you define an array, you can use a string constant to initialize the array.
Example: char [] = "Hugo"; This definition is equivalent to char [] = { 'H','u','g','o','\0' }; As you can see, the string  occupies five bytes, including an additional byte for the null character.
If you need to allocate more memory, you can state the size of the array explicitly as shown opposite.
In the C language, strings are usually represented as char vectors with a terminating null character.
In Cplus_plus, strings of this type are referred to as C strings to distinguish them from objects of the string class.
Thus, for example, assignments and comparisons are not defined.
Example: char 1[20], 2[20] = "A string"; 1 = 2;                     // Error.
The standard functions of the C language, such as strlen(), strcpy(), strcmp(), and others, are available for C strings.
These global functions all begin with the  prefix.
As the program on the opposite page shows, I/O streams are overloaded for char arrays, too.
Input and output are as easily achieved as with string class objects.
However, the program must make sure not to overrun the end of the char array when reading data into the array.
You can use the width() method or the setw() manipulator for this purpose.
Example: cin >> setw(20) >> ; // 19 characters C strings are preferable to the string class if only a few operations are needed and you want to avoid unnecessary overheads.
The array is known as a class array in this case.
When you declare an array of this type, you only need to state the type of the array elements.
Example: Result temperatureTab[24]; This statement defines the class array  that stores 24 objects of type This class was introduced at the beginning of the last chapter.
As the statement does not initialize the array explicitly, the default constructor is automatically called for each array element.
Thus, the previous example is only valid for the first version of the  class as this class contains a default constructor.
The list contains a constructor call for each array element.
The first five array elements are initialized by the constructor calls implicitly contained in these statements.
Instead of using a constructor with one argument, you can simply supply the argument.
The default constructor is then called for the remaining elements.
If the size of an array is not stated explicitly, the number of values in the initialization list defines the size of the array.
The public interface of the objects in the array is available for use as usual.
Example: [2]_0_setTime( 2,30,21); No additional parentheses are needed in this statement since the subscript operator [] and the class member operator.
Class  can only be defined without explicit initialization if a default constructor exists for the class.
The ANSI standard stipulates a minimum of 256 dimensions but the total  of dimensions is in fact limited by the amount of memory available.
The most common multidimensional array type is the two-dimensional array, the socalled matrix.
Example: float [3][10];    // 3 x 10 matrix This defines a matrix called  that contains 3 rows and 10 columns.
Each of the 30 (3 � 10) elements is a float type.
The assignment Example: [0][9] = 7_0_2;     // Row 0, column 9 stores the value 7_0_2 in the last element of the first row.
On the contrary, an n-dimensional array is no different than an array with only one dimension whose elements are (n–1)-dimensional.
The array  thus contains the following three elements: [0] [1] [2].
Each of these elements is a float array with a size of 10, which in turn forms the rows of the two-dimensional array,.
This means that the same rules apply to multidimensional  as to one-dimensional.
The initialization list of a two-dimensional array thus contains the values of the array elements, that is, the one-dimensional rows.
Examples: int [2][3] = { {5, 0, 0}, {7, 0, 0} }; int [][3]  = { {5}, {7} }; These two definitions are equivalent.
When you initialize an array, you can only omit the size of the first dimension.
It is necessary to define any other dimensions since they define the size of array elements.
The [] rows are char  used for storing the names of the representatives.
You can also use a onedimensional string array.
Example: string [2] = {"La_0__0_","Fo_0__0_"}; 332 ■ C H A P T E R  1 6 A R R A Y S // telList_0_h // Class  to represent a list // containing names and telephone numbers.
A class designed to perform this task can use an array for ease of data management.
An array allows you to access individual objects directly and perform searches.
A class that encapsulates an array will provide methods for simple array operations, such as inserting and deleting objects.
When you design a class of this type, one aim will be to perform automatic range checking.
This helps avoid overrunning the end of an array when performing read or write operations.
The resulting class will contain a comfortable and safe interface for object data management.
Each entry in the list contains a dataset containing a name and a phone.
The Element type, which comprises two strings, was defined for this purpose.
The array v can store up to MAX entries of the Element type.
The data member  records the of elements currently stored in the array.
When a phone list is created, this  will initially be 0.
When an element is inserted or deleted, the  is modified correspondingly.
The  class uses a single default constructor that sets the counter, , to zero.
It is not necessary to provide an initial value for the MAX elements in the array v since the default constructor of the string class is executed for all strings.
The tasks performed by the other methods are easily deduced from their names.
The retrieve() method returns to a given index a pointer to the corresponding element.
Using a pointer makes it possible to return a NULL pointer if the index is invalid.
The append() methods add a new  to the list.
The data passed to a method is copied to the next free array element and the counter is incremented.
If there is no space available, the name field is empty, or the name is already in use, nothing happens.
In this case, the method returns false instead of true.
The exercises for this chapter contain further details on these methods.
You can implement the methods for the  yourself and go on to test them.
The screen control characters make it possible to locate the cursor, and that independent of the current compiler (see appendix).
Result: Screen shot of exercise 4 EXERCISES ■ 335 Use the bubble sort algorithm to sort the array.
This algorithm repeatedly accesses the array, comparing neighboring array elements and swapping them if needed.
The sorting algorithm terminates when there are no more elements that need to be swapped.
You use a flag to indicate that no elements have been swapped.
Input can be terminated by any invalid input, such as a letter.
Exercise 2 Chapter 14 introduced the sample class DayTime and the isLess() method.
Define and initialize an array with four DayTime class objects.
Then write a main function that first uses the print() method to display the four elements.
Finally, find the largest and smallest elements and output them on screen.
Exercise 3 Write a program that outputs all prime numbers less than 1000_0_The program should also count the number of prime numbers less than 1000.
Use the Sieve of Eratosthenes: To find primary numbers simply eliminate multiples of any primary numbers you have already found, i_0_e_0_: first eliminate any multiples of 2 ( 4, 6, 8, _0__0_.
Exercise 4 Write a Cplus_plus program to create the screen output shown opposite_0_The following banner * * *  B R E A K  * * * is to be displayed in the center of the window and scrolled left_0_You can scroll the banner by beginning string output with the first character, then the second, and so on.
Handle the string like a loop where the first letter follows the last letter and output continues until the starting position is reached.
You can use a wait loop to modify the speed of the banner after each string is output.
This is just one of the enhancements (another would be variable length) that will be added at a later stage.
The method erase() deletes an array element_0_The position of the element to be deleted is first located using the search() method.
If the element does not exist, erase() returns a value of false.
In any other case, the last element in the array is used to overwrite the element that is to be deleted and the counter count is decremented.
The search() method finds the position in the array that contains the search name.
If the search operation is unsuccessful, the value PSEUDO is returned.
The print method without parameters outputs all available entries_0_You can pass the first letter or letters of a name to the second method to output any  beginning with these letters.
Use the method compare() from the string class to help you with this task.
Example: 1_0_compare( 0, 5, 2) == 0 This expression is true if the five characters subsequent to position 0 in the strings 1 and 2 are identical.
The getNewEntries() method is used to read new  list method.
Reading should be terminated if the user types an empty string.
The method returns the number of new.
Write an application program that creates a  list of type TelList and displays the menu shown on the opposite page.
Depending on the command input, one of the methods defined in is chosen, you must also read a name or the first letters of a name from the keyboard.
SOLUTIONS ■ 343 Exercise 4.
String access via the command line of an application program is used to illustrate pointer arrays.
However, just like the definition used for  reference, you can also define  read-only pointer, that is, pointer that can be used for read operations only.
In fact,  read-only pointer is obligatory if you need to point to  constant object.
Example: const int  = 5,  = 10,  * = &; This statement defines the constants  and , and  pointer  to  constant object of type int.
The referenced object * can be read but not modified.
Example: << *;       // To read is ok.
The pointer itself is not  constant, so it can be modified: Example: = &;           // ok.
The referenced object also does not need to be  constant.
In other words,  read-only pointer can also point to  non-constant object.
But  can only be used for read access to the non-constant object depo.
This guarantees that arguments cannot be modified.
Example: int strlen( const char *); In this example, the parameter  is  read-only pointer.
This allows you to pass constant.
Best wishes Yours Vivi Array  in memory COMMAND LINE ARGUMENTS ■ 367 � Arguments for a Program When you launch a program, you can use the command line to supply additional character sequences other than the program.
These command line arguments are typically used to govern how a program is executed or to supply the data a program will work with.
Example: copy file1 file2 In this case, the program copy is launched with the arguments file1 and file2.
The individual arguments are separated by spaces.
Characters used for redirecting input and output ( > or < ) and a following word are evaluated by the operating system and not passed to the program.
If an argument contains space or redirection characters, you must place it in double quotes.
So far we have only used the function main() without parameters.
However, if you intend to process command line arguments, you must define parameters for main().
The program is one of these, so  will have a value of at least 1.
The parameter  is an array of char pointers: [0] [1] points to the first real argument, that is, the word after the program [2] points to the second argument.
Various operating systems, for example WINDOWS 98/00/NT and UNIX, allow you to declare a third parameter for main().
This parameter is an array with pointers to environment strings.
The exercises for this chapter contain a program that displays the program environment.
Original array: After the first loop: After the second loop: smallest element second smallest element 100 50 30 30 30 40 100 70 50 50 100 70 40 70 40 ■ EXERCISES For exercise 3 Notes on exercise 4 The selection sort algorithm Method First find the smallest element in the array and exchange it with the first element.
This procedure is repeated while  > 0 for the remainder of an array containing array elements with an initial index of.
Example EXERCISES ■ 369 Exercise 1 Given an array  with the following definition: int [] = { 10, 20, 30, 40 }, , *; What screen output is caused by the following statements.
File streams provide simple and portable file handling techniques.
To store data permanently, you need to write that data to  file on an external storage medium.
However, it is common practice to store records in files.
A  contains data that forms  logical unit, such as the human resource information for  person.
A write operation stores   in  file, that is, the existing  in the file is updated or new  is added.
When you read  , this  is taken from the file and copied to the data structure of  program.
Objects can be put into permanent storage using similar techniques.
However, this normally involves more than just storing an object's data.
You also need to ensure that the object can be correctly reconstructed when it is read, and this in turn involves storing type information and references to other objects.
External mass storage media, such as hard disks, are normally block-oriented—that is, data is transferred in blocks whose size is  multiple of 512 bytes.
Efficient and easy file management thus implies putting the data you need to store into temporary storage in main memory, in  so-called file buffer.
The structure of the , using records for example, is entirely the programmer's responsibility, allowing for  maximum degree of flexibility.
Every character in   occupies  byte position.
The first byte occupies position 0, the second byte position 1, and so on.
The current  position is the position of the byte that will be read or written next.
Each byte that is transferred automatically increases the current  position by 1.
In the case of sequential access, the  is read or written byte by byte in  fixed order.
The first read operation starts at the beginning of the.
If you need access to some piece of information in  , you must read the  content from start to finish.
Write operations can create  new , overwrite an existing , or append new  to an existing.
Easy access to given  in   implies being able to set the current  position as required.
This technique is known as random  access and will be discussed in one of the following chapters.
These so-called  stream classes allow for easy  handling.
As a programmer you will not need to concern yourself with  buffer management or system specifics.
Since the  stream classes have been standardized, you can use them to develop portable Cplus_plus programs.
One program can thus process files on a Windows NT or UNIX platform.
You simply need to recompile the program for each platform you use.
As you would expect, it supports both read and write operations for files.
The  stream classes are declared in the fstream header.
An object that belongs to a  stream class is known as a  stream.
Thus, the methods, operators, and manipulators you have already used for cin and  are also available here.
Thus every  stream has: ■ methods for non-formatted writing and reading of single characters and/or blocks ■ the operators << or >> for formatted reading and writing from or to files ■ methods and manipulators for formatting character sequences ■ methods for state queries.
File handling methods, particularly methods for opening and closing files, round off the package.
For example, you can stipulate the effect of the + operator for the objects of a particular class.
This chapter describes various uses of overloaded operators.
Arithmetic operators, comparisons, the subscript , and the shift operators for input and output  overloaded to illustrate the appropriate techniques.
The concept of friend functions, which is introduced in this context, is particularly important for overloading operators.
This meaning can be changed for classes by a definition of your own.
The definition scope of an is simply extended—the characteristics of the  remain unchanged.
The following rules apply: ■ You cannot create "new "—that is, you can only overload existing.
A binary  will always be binary and a unary  will always be unary.
In other words, overloading an  means making the  significant for a.
Most  are already overloaded for fundamental types.
In the case of the expression: Example: a / b the operand  determines the machine code created by the compiler for the division If both operands are integral types, an integral division is performed; in all other cases floating-point division occurs.
Thus, different actions are performed depending on the operand types involved.
Thus, you can overload the + instead of, or in addition to, using the add() method.
For the objects x and y in this class: x + y Using the overloaded  of a class expressions of this  can be as easily defined as for fundamental types.
Expressions using  are often more intuitive,  thus easier to understand than expressions containing function calls.
Many  belonging to the Cplus_plus standard library classes are already overloaded.
This applies to the string class, with which you are already familiar.
The tables on the opposite page show those  that can be overloaded.
Some cannot be overloaded, such as the cast , the sizeof , the following four : ::  _0_* member access  scope resolution _0_: conditional These  either have a fixed significance in the classes for which they are defined, or overloading the  makes no sense.
The function describes the actions to be performed by the.
The name of an function must begin with the  keyword followed by the  symbol.
Example: + This is the name of the  function for the +.
An  function can be defined as a global function or as a class method.
Generally,  functions are defined as methods, especially in the case of unary operators.
However, it can make sense to define an  function globally.
This point will be illustrated later.
The  function is called for this object.
The , right operand is passed as an argument to the method.
The method thus has a single parameter.
Example: bool <( const DayTime& t) const; In this case the lesser than  is overloaded to compare two DayTime objects.
It replaces the method isLess(), which was formerly defined for this class.
The prefix  plus_plus has been overloaded in the example on the opposite page to illustrate overloading unary operators.
The corresponding  function in this class has no parameters.
The function is called if the object a in the expression plus_plusa is an object of class DayTime.
The expression is thus equivalent to Although somewhat uncommon, you can call an  function explicitly.
The previous function call is therefore technically correct.
Programs that use operators are easier to encode  read.
However, you should be aware of the fact that an  function should perform a similar operation to the corresponding  for the fundamental.
Any other use can lead to confusion.
Class ■ 417 � Notes on the Sample Class The opposite page shows the  class, which represents the new  currency.
The member  stores a given amount of euros as an integer in the format: (integer part)*100 + Cents.
Thus /100 returns the number of euros  %100 the number of.
This technique allows for easy implementation of the arithmetic operations needed for the class.
In addition to a constructor that is passed whole euros   as arguments, there is a constructor that can process a double value of euros  a standard copy constructor.
Example: e1(9,50), e2(20_0_07), e3(-e1); � Negation, Addition,  Subtraction unary  - does not change its operand.
In the previous example, e3 is thus assigned a value of -9,50 , but e1 remains unchanged.
Thus, the functions also create temporary objects  return them with the correct values.
Example: = e1 + e2; expression e1 + e2 results in e1_0_+(e2).
Both are distinct that require separate definitions.
Of course, you should overload the  to ensure that the statements Example: += e3; =  + e3; produce the same results.
A temporary  is not required.
These expressions contain only  type objects,  which  functions have been defined.
However, you can also add or subtract int or double types.
This is made possible by the  constructors, which create  objects from int or double types.
This allows a function that expects a  value as argument to process int or double values.
As the program opposite shows, the statement Example: += 9_0_49; is valid.
Since there is no  function with these characteristics, the compiler converts the double value to   calls the existing  function  euros.
Example: =  + 10;       // ok =  - 7_0_99;     // ok first statement is equivalent to.
But the following statement is invalid.
Example: = 10 + ;     // wrong.
Since the  function was defined as a method, the left operand must be a class Thus, you cannot simply exchange the operands of the  +.
However, if you want to convert both operands, you will need global definitions  the functions.
You can define an  function as a global function instead of a method.
Global  functions are generally preferable if one of the following situations applies: ■ the  is binary  both operands are symmetrical, e_0_g.
The  function of a unary  thus possesses a single parameter, whereas the function of a binary  has two.
The  class has been modified to provide a global definition of the  functions  the  +  -.
Example: +(const & e1, const & e2); Both operands are now peers.
More specifically, conversion of int or double to is performed  both operands now.
Given a  object net,  following expressions are valid  equivalent: Example: net + 1_0_20 1_0_20 + net They cause  following function calls: However, a global function cannot access  private members of  class.
The function +() shown opposite therefore uses  += , whose function is defined as a method.
A global  function can be declared as a "friend" of  class to allow it access to  private members of that class.
This is made possible by a friend declaration, which eliminates  encapsulation in certain cases.
Imagine you need to write a global function that accesses  elements of a numerical array class.
If you need to call  access methods of  class each time,  if these methods perform range checking,  function runtime will increase considerably.
However, special permission to access  private  members of  class can dramatically improve  function's response.
This is achieved by declaring  function as a friend.
The friend keyword must precede  function prototype in  class definition.
Example: class A.
This allows them direct access to  private members of class A.
Since these functions are not methods of class A,  this pointer is not available to them.
To resolve this issue, you will generally pass  object  function needs to process as an argument.
It is important to note that  class itself determines who its friends are.
If this were not so,  encapsulation could easily be undermined.
In order to compute interest, it is necessary to multiply  divide euros by double values.
Since both  expression *num  num* are possible, friend functions are implemented to perform multiplications.
As  example shows, friend functions can also be defined inline in a class.
All  methods in this "friendly" class automatically become friend functions in  class containing  friend declaration.
This technique is useful if a class is used in such close conjunction with another class that all  methods in that class need access to  private members of  other class.
For example,  class ControlPoint uses objects of  Result class.
Calculations with individual measurements are performed repeatedly.
In this case, it makes sense to declare  ControlPoint class as a friend of  Result class.
Example: class Result.
It is important to note that  ControlPoint class has no influence over  fact that it is a friend of  Result class.
The Result class itself decides who its friends are and who has access to its private members.
It does not matter whether a friend declaration occurs in  private or public section of a class.
However, you can regard a friend declaration as an extension of public interface.
For this reason, it is preferable to place a friend declaration in public area of a class.
More specifically, you can utilize global friend functions where methods are not suited to the task in hand.
Some common uses are global operator functions declared as friend functions.
However, extensive use of friend techniques diffuses the concept of  encapsulation.
Allowing external functions to manipulate internal  can lead to inconsistency, especially if a class is modified or extended in a later version.
For this reason, you should take special care when using friend techniques.
It is a binary operator and thus has two operands.
Given an expression such as v[], the array name v will always be the left operand, whereas the index  will be the right operand.
The subscript operator for arrays implies background pointer arithmetic, for example, v[] is equivalent to *(v+).
Thus, the following restrictions apply to non-overloaded index operators: ■ an operand must be a pointer—an array name, for example ■ the other operand must be an integral expression.
You should note, however, that the operator function is always a class method with a parameter for the right operand.
The following therefore applies: ■ the left operand must be a class object ■ the right operand can be any valid type ■ the result type is not defined.
This allows for considerable flexibility.
However, your overloading should always reflect the normal use of arrays.
More specifically, the return value should be a reference to an object.
Since an index can be of any valid type, the possibilities are unlimited.
For example, you could easily define associative arrays, that is, arrays whose elements are referenced by strings.
An invalid index can thus lead to abnormal termination of an application program.
However, you can address this issue by defining your own array classes, although this may impact the speed of your programs.
The opposite page shows a simple array class definition for float values.
The subscript operator [] has been overloaded to return a reference to the -th array.
However, when the array is accessed,  checking is performed to ensure that the index falls within given boundaries.
If an invalid index is found, the program issues an error message and terminates.
The class FloatArr array has a fixed length.
As we will see, variable lengths are possible using dynamic memory allocation.
Dynamic memory allocation is an important factor in many Cplus_plus programs and the following chapters will contain several additional case studies to  you review the subject.
In cases like  you will need to allocate memory dynamically, that is, while the program is running.
Dynamically allocated memory can be released to continually optimize memory usage with respect to current requirements.
This in turn provides  high level of flexibility, allowing  programmer to represent dynamic data structures, such as trees  linked lists.
Programs can access  large space of free memory known as the heap.
Depending on the operating system ( how the OS is configured), the heap can also occupy large amounts of unused space on the hard disk by swapping memory to disk.
Cplus_plus uses the new  delete operators to allocate  release memory, means that objects of any  can be created  destroyed.
Let's look at the scenario fundamental types first.
In its simplest form,  call to new   syntax Syntax: = new ; Where  is  pointer to.
The new  creates an  of the specified returns the address of that.
The address is normally assigned to  pointer variable.
If the pointer belongs to  wrong , the compiler will issue an error message.
Example: * = new  ; This statement allocates memory , that is, sizeof( ) bytes.
The previous call to new  not define an initial   the new , however, you can supply   in parentheses to initialize the.
Example: = new  (10000_0_99); Following  statement  points to  memory address containing with   of 10000_0_99.
The statement << * << endl; will output.
Failure to do so  impact the performance of your computer system.
Memory that is released is available  further calls to new.
A call to delete   syntax Syntax: delete ; The operand  addresses the memory space to be released.
But make sure that memory space was dynamically allocated by  call to new.
You  pass  NULL pointer to delete when you call the.
In this case nothing happens  delete just returns, so you do not need to check  NULL pointers when releasing memory.
A delete expression is always  void , so you cannot check whether memory has been successfully released.
As the sample program illustrates, misuse of delete  be disastrous.
More specifically ■ do not call delete twice  the same ■ do not use delete to release statically allocated memory.
The new is a function designed  central error handling.
Thus, you do not need to design your own error handling routines each time you call new.
The new  is activated by default  throws an exception.
Exceptions  be caught by the program, allowing the error condition to be remedied (refer to Chapter 28, Exception Handling).
Any exception that is not caught will terminate the program, however, you  install your own new.
If you are working with an older compiler, please note that new  a NULL pointer if not enough memory is available.
In this case, in addition to allocating memory, a suitable constructor must be called.
Before releasing memory, the destructor must be called to perform cleaning up tasks.
However, the operators new  delete ensure that this happens.
Unless explicitly initialized, the default constructor is called  each new , but you must make sure that a default constructor exists.
Example: *  = new ; This statement allocates memory  an  of the  class.
If enough memory is available, the default constructor   is executed  the address of a new returned.
Syntax: * = new (initializing_list); The  in the initialization list are passed as arguments to the constructor.
If the compiler is unable to locate a suitable constructor, an error message occurs.
Example: * = new ( -123,77); This statement assigns the address of a new  class  to the pointer.
The is initialized using the supplied.
The expression * thus represents the entire.
Example: * += 200;           // To add 200 euros.
The public members are referred to via the member access operator arrow_operator.
Example: << () << endl;    // 33 � Releasing Memory When an  that was created dynamically is destroyed, the delete operator makes sure that the  is cleaned up.
The destructor is first called,  only then is the memory space released.
As previously discussed in the section on fundamental types, when you call delete you must ensure that the pointer is addressing a dynamic  or that you are dealing a NULL pointer.
This page intentionally left blank 477 Dynamic Members This chapter describes how to implement classes containing pointers to dynamically allocated memory_0_These ■ your own copy constructor definition and ■ overloading the assignment.
A class designed to represent  of any given length is used as sample application.
Object fArr arrPtr max:  10 cnt:  4 // A class representing dynamic  of floats.
Depending on the  of data an application program really has to handle, memory is allocated as required while the application is running.
In order to do this the class needs  pointer to the dynamically allocated memory that contains the actual data.
Data members of this kind are also known as dynamic members of.
When compiling  program that contains , you will probably not know how many elements the  will need to store.
A  designed to represent  should take this point into consideration and allow for dynamically defined variable length.
For example,  simple assignment should be possible for two objects 1 and 2 in the new.
Example: 2 = 1; The  2 itself—and not the programmer—will ensure that enough memory is available to accommodate the array 1.
Just as in the case of fundamental types, it should also be possible to use an existing , 2, to initialize a new , 3.
Example: FloatArr 3(2); Here the  3 ensures that enough memory is available to accommodate the array elements of 2.
When an  of the FloatArr is declared, the user should be able to define the initial length of the array.
The statement Example: FloatArr fArr(100); allocates memory for a maximum of 100 array elements.
The definition of the FloatArr  therefore comprises a member that addresses a dynamically allocated array.
In addition to this, two int variables are required to store the maximum and current number of array elements.
The operator allows both read and write access to the array elements and cannot be used for constant objects for this reason.
However, you will need to support read-only access to constant objects.
The first version returns a reference to the -th array element and thus supports write access.
The second, read-only version only supports read access to the array elements and is automatically called by the compiler when accessing constant objects.
The implementation of these versions is identical.
In both cases range checking is performed for the index.
If the index lies within the valid boundaries, an array element— or simply a value in the case of the read-only version—is returned.
In the first version, the append() only works if there is at least one empty slot in the array.
In the exercises, append() is used to extend the array as required.
This also applies for a new , insert(), which you will write as an exercise in this chapter.
When the remove()  is used to delete an , the elements following the deleted  move up one place, preserving the original order.
The current count is decremented by one.
What was formerly the last  in the array is not deleted but overwritten when a new  is inserted.
Another technique would be to copy the last  to the position of the that needs to be deleted, simply overwriting that.
Of course, this technique is quicker and preferable for cases where the order of the elements is not significant.
Effect of the standard copy constructor FloatArr b(a);         // Creates a copy of a.
A self-defined copy constructor for class FloatArr COPY CONSTRUCTOR ■ 487 � Initializing with an Object The next step is to ensure that an existing  can be used to initialize a new.
Given an array, a, the following statement should be valid: Example: FloatArr b(a); The array b should now be the same length as the array a and the array elements in b should contain the same values as in a.
The FloatArr class needs a copy constructor to perform this task.
The constructor has a reference to a constant array as a parameter.
Prototype: FloatArr( const FloatArr& ); � Standard Copy Constructor If a class does not contain a copy constructor, the compiler will automatically create a minimal version, known as the standard copy constructor.
This constructor copies the data members of the  passed to it to corresponding data members of the new.
A standard  constructor is normally sufficient for a class.
However, simply copying the data members would serve no useful purpose for objects containing dynamic members.
This would merely  the pointers, meaning that the pointers of several different objects would reference the same place in memory.
The diagram on the opposite page illustrates this situation for two FloatArr class objects.
This scenario would obviously mean trouble.
Imagine releasing memory allocated for an  dynamically.
The pointer for the second  would reference a memory area that no longer existed.
The example on the opposite page shows the definition of the  constructor for the FloatArr class.
Calling []  a   and the  elements of the passed to the  are then copied to that.
SOLUTIONS ■ 495 Exercise 2 // minus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minus // floatArr_0_h : Dynamic arrays of floating-point numbers.
Besides defining derived classes, we will also discuss ■ how members are redefined ■ how objects are constructed and destroyed, and ■ how access control to base classes can be realized.
The new derived  "inherits" the data and methods of the so-called base.
But you can add more characteristics and functionality to the new.
A fleet management program used by a car hire company needs to handle all kinds of vehicles—automobiles, motorcycles, trucks, and so on.
All of these vehicles have an identification number that indicates the vehicle, the manufacturer, and the vehicle status, such as "hired," "repair shop," and so on.
Additionally, operations such as "modify status" are required for the.
To differentiate between vehicle types, various  are derived from the base Car, such as PassCar, which is used to represent passenger-carrying vehicles.
This has additional attributes, such as the number of seats, type, sunroof (yes/no), and various additional operations.
A passenger vehicle is a special kind of car.
In cases like this we can say that the derived  establishes an is relationship to the base.
We distinguish between this close relationship and a so-called has relationship.
As already mentioned, a has relationship occurs between two  when an member of one  has another  type.
An Account object has a string object to represent the name of the account holder, for example.
This makes it easier to manage complex situations and relationships.
The base  implementation need not be known for this purpose: only the public interfaces are required.
The opposite page shows a schematic definition of a derived , C.
The C inherits the B , which is defined in the public section following the colon.
The private and public sections contain additional members of the C.
In other words, ■ all the public members in base  B are publicly available in the derived C.
This kind of inheritance ports the public interface of the base  to the derived where it is extended by additional declarations.
Thus, objects of the derived can call the public methods of the base.
A public base , therefore, implements the is relationship; this is quite common.
There are some less common cases where access to the members of the base needs to be restricted or prohibited.
Only the methods of  C can still access the public members of , but not the users of that.
You can use private or protected derivation to achieve this (these techniques will be discussed later).
That is, ■ the methods of the derived  cannot access the private members of the base.
Imagine the consequences if this were not so: you would be able to hack access to the base  by simply defining a derived , thus undermining any protection offered by data encapsulation.
This allows for hierarchies.
Class  then becomes an indirect base  for  D.
In the graphic on the opposite page, the arrow ↑ means directly derived from.
That is, D is a direct derivation of  C and an indirect derivation of.
The Car class and a derived class PassCar are defined in the example.
The derived class PassCar inherits these data members.
Thus, an object of the PassCar class also contains the data members  and.
The object includes a so-called base subobject of type Car.
The PassCar class additionally contains the data members  and to represent a passenger vehicle with or without a sunroof.
So a PassCar type object has a total of four data members.
For the sake of simplicity, we have omitted further data members, such as the number of seats, etc.
The base class Car contains a constructor, access methods, and the method display(), which is used for screen output.
The methods are also inherited by the derived class PassCar.
In the PassCar class a constructor, additional access methods, and a second output function also called display() are declared.
The derived class thus inherits a method method is said to have been redefined.
Every member function and every data member in a derived class can be redefined.
The member assumes a new  for the derived class.
The member inherited from the base class is also available in the derived class and will retain its original.
We will be looking at this point in more detail later.
For example, you can call the getNr() method for an object named cabrio in the PassCar class.
Example: << "Car : "<< cabrio_0_getNr(); The public interface of the derived class thus comprises ■ the public members of the base class and ■ the public members additionally defined in the derived class.
Example: const string& getType() const {  return ;  } The getType() method directly accesses the private data member  in the PassCar class in this example.
The output function display() in the derived class PassCar, for example, cannot contain the following statement: Example: << ": " << ; As  is a private data member of the base class Car, the compiler would issue an error message at this point.
Methods belonging to derived classes only have indirect access to the private data members of the base class.
They use access methods in the public declaration of the base class for this purpose.
The opposite page shows a version of the display() method that calls the get methods in its base class Car.
When you call an access method, you do not need to state the method's base class.
The base class is identified by the this pointer, which is passed implicitly as an argument.
The call to getProd() on the opposite page is thus equivalent to: Example: thisarrow_operatorgetProd(); � Name Lookup The following rules apply when searching for the name of a method: ■ the compiler looks for the name of the method called in the derived class first ■ if the name cannot be found, the compiler walks one step up the tree and looks for a public method with that name.
The above example thus calls the getProd() in the base class Car, as the method is not defined in the PassCar class.
The name does not occur in the base class →  redefinition.
The name already exists in the base class → redefinition.
In the second case, the member of the same name continues to exist unchanged in the base class.
In other words, redefining members in a derived class has  effect on the base class.
However, the name lookup rules for the compiler lead to the following scenario: ■ if a member is redefined in a derived class, it will mask the corresponding member in the base class.
This situation is similar to the one seen for local and global variables.
A local variable will mask a previously defined global variable with the same name.
This adopts the methods to the new features of the class.
When a method is redefined, the signature and the return type of the method can be changed.
However, a redefinition does not overload functions since the derived class has a different scope.
Redefining a method will always mask a method with the same name in the base class.
Of course, you can overload methods within the same class, and this means you can repeatedly redefine a base class method for a derived class.
If the method was declared in the public section of the base class, you can call it to redefine a method.
The range :: operator is used to access the base class method.
The new  of the display() method opposite illustrates this point.
The display() method defined in the base class is used to output the data members of the base class.
To do so, you must use the range operator with the name of the base class.
Otherwise the display() method in the derived class will call itself and head off into an indefinite recursion.
As the derived class contains all the members of the base class, the base sub-object must also be created and initialized.
The base class constructor is called to perform this task.
Unless otherwise defined, this will be the default constructor.
The order in which the constructors are called is important.
The base class constructor is called first, then the derived class constructor.
The object is thus constructed from its core outwards.
The first  of the constructor for PassCar, as shown opposite, sets initial values by calling the access methods of the base class.
An implicit call to the default constructor of the base class occurs prior to this, and the base sub-object is initialized with default values.
This process has the same drawbacks as the technique of creating objects with member objects.
A default constructor must be available in the base class and initialization with incorrect values before assigning live values impacts the response of the program.
This immediately initializes the data members with correct values.
A base initializer for the constructor of the derived class can be defined for this purpose.
The second  of the constructor for PassCar contains a base initializer.
Example: The syntax of the base initializer for base sub-objects is similar to that of the member initializer for member sub-objects.
This means that you can state both the base and the member initializer in a list separated by commas.
The third  of the PassCar constructor illustrates this point.
The reverse order of the constructor calls applies.
You need to define a destructor for a derived class if actions performed by the constructor need to be reversed.
The base class destructor need not be called explicitly as it is executed implicitly.
Two objects, beetle and cabrio, of the derived class PassCar type are declared.
As the PassCar class does not contain a default constructor, both objects must be initialized.
However, it is sufficient to state a PassCar type with or without a sunroof as default values exist for all other data members.
The object beetle is declared as const just to show that the get methods and the display() method can also be called for constant objects since they were declared as read-only methods.
However, the following call is invalid: Example: beetle_0_setNr( 7564 );          // Error This means you have to correctly define all the initial values for the object when you declare it.
In the PassCar class the method display() has been redefined.
The statement Example: cabrio_0_display(); also outputs the additional data members  and.
However, in the case of the van object in the Car class, calling Example: van_0_display(); will execute the method in the base class.
This is possible using the scope resolution operator,::.
If you want to display the basic data of the cabrio object, you can use a direct call to the base class method display() to do so.
Example: cabrio_0_Car::display(); The name of the method is preceded by the name of the base class and the scope resolution operator in this case.
When you create a class hierarchy you may want require the methods and friend functions of a derived class to communicate directly with the members of the base class.
This would be particularly necessary if the base class contained members for use as building blocks for derived classes but not for general purpose use.
For example, a class used to represent a window on screen could contain the dimensions and other characteristics of a general windows.
The characteristics need protecting; however, methods in derived classes will still need direct access.
This is achieved by means of protected declarations.
A member declared protected is sheltered from external access just like a private member.
That means, a protected member is inaccessible for base class objects and any classes derived from the base class.
However, in contrast to a private member, methods and friend functions of derived classes can access the member.
The classes defined opposite, Safe and Castle, show that protected members of the base class can be accessed directly in a derived class.
In contrast to this, protected members are inaccessible to users of these classes.
Protected declarations should be used with caution.
If you change the declaration of a protected member, every class derived from this class must be examined to ascertain whether additional modifications are necessary.
In addition, the class  is to be added to the class hierarchy.
The SavAcc contains the members of the base class and an interest rate.
Properties: Weight Price per pound Methods:.
Exercise 3 EXERCISES ■ 519 Exercise 3 A supermarket chain has asked you to develop an automatic checkout system.
All products are identifiable by means of a barcode and the product name.
Groceries are either sold in packages or by weight.
Packed goods have fixed prices_0_The price of groceries sold by weight is calculated by multiplying the weight by the current price per kilo.
Develop the  needed to represent the products first and organize them hierarchically_0_The Product class, which contains generic information on all products (barcode, name, etc_0_), can be used as a base class.
Define a constructor with parameters for both data members_0_Add default  for the parameters to provide a default constructor for the class.
In addition to the access methods setCode() and getCode(), also define the methods scanner() and printer().
For test purposes, these methods will simply output product  on screen or read the  of a product from the keyboard.
Define two  derived from Product, PrepackedFood and FreshFood.
In addition to the product , the PrepackedFood class should contain the unit price and the FreshFood class should contain a weight and a price per kilo as  members.
In both  define a constructor with parameters providing default- for all  members.
Use both the base and member initializer.
Define the access methods needed for the new  members_0_Also redefine the methods scanner() and printer() to take the new members into consideration.
One object of each type is fully initialized in the object definition.
Use the default constructor to create the other object_0_Test the get and set methods and the scanner() method and display the products on screen.
When such an  reaches the end of its lifetime, the memory occupied by the  must be released by a delete statement.
If multiple constructors were called to create the , the corresponding destructors are called in reverse order.
What does this mean for objects in derived classes.
The destructor of the derived class is called first and then the destructor of the base class executed.
If you use a base class pointer to manage an , the appropriate virtual methods of the derived class are called.
However, non-virtual methods will always execute the base class.
In the previous example, only the base class destructor for  was executed.
As the destructor is not called, neither is the destructor called for the data member passCarType, which is additionally defined in the derived class.
The data member passCarType is a string, however, and occupies dynamically allocated memory— this memory will not be released.
If multiple objects are created dynamically in the derived class, a dangerous situation occurs.
More and more unreferenced memory blocks will clutter up the main memory without you being able to reallocate them—this can seriously impact your program's response and even lead to external memory being swapped in.
The opposite page shows how you would define a virtual destructor for the  class.
Just like any other virtual , the appropriate  of the destructor will be executed.
The destructors from any direct or indirect base class then follow.
A class used as a base class for other classes should always have a virtual destructor defined.
Even if the base class does not need a destructor itself, it should at least contain a dummy destructor, that is, a destructor with an empty function body.
The address is inserted directly into the machine code.
This is also referred to as static or early binding.
If a virtual method is called via an 's , the appropriate version of this method is also known at time of compilation.
So this is also a case of early binding.
The statement Example: carPtrarrow_operatordisplay(); could execute different versions of the display() method, depending on the currently referenced by the pointer.
The compiler is therefore forced to create machine code that does not form an association with a particular function until the program is run.
This is referred to as late or dynamic binding.
A VMT is created for each class with at least one virtual method—that is, an array with the addresses of the virtual methods in the current class.
Each  in a polymorphic class contains a VMT pointer, that is, a hidden pointer to the VMT of the corresponding class.
Dynamic binding causes the virtual function call to be executed in two steps: 1.
The pointer to the VMT in the referenced object is read.
The address of the virtual method is read in the VMT.
In comparison with static binding, dynamic binding does have the disadvantage that VMTs occupy memory.
Moreover, program response can be impacted by indirect addressing of virtual methods.
However, this is a small price to pay for the benefits.
Dynamic binding allows you to enhance compiled source code without having access to the source code.
This is particularly important when you consider commercial class libraries, from which a user can derive his or her own classes and virtual function versions.
The compiler's option "Run Time Type Information (RTTI)" must be activated, for example, under Project/Settings.
The GNU compiler activates these options automatically.
If the referenced object does not correspond to the type of the derived class, fatal runtime errors can occur.
Given that  is a pointer to the base class , which is currently pointing to a type, the statement Example: *  = <*>(); will not cause a compiler error.
But the following statement, truckPtrarrow_operatorsetAxles(10); could cause the program to crash.
At runtime the operator checks whether the required conversion is valid or not.
Syntax: If so, the expression expression is converted to the target type type.
The target type must be a pointer or reference to a polymorphic class or a void pointer.
If it is a pointer type, expression must also be a pointer type.
If the target type is a reference, expression must identify an object in memory.
If this is not so, the <> operator will return a NULL pointer.
Given that cabrio is a  type object, the following statements Example: &  = cabrio; & =<&>(); perform a dynamic cast to the "reference to " type.
In any other case, that is, if the reference  does not identify a  type object, an exception of the bad_cast type is thrown.
The dynamic cast can also be used for upcasting.
The classes involved do not need to be polymorphic in this case.
However, type checking is not performed at runtime.
An erroneous upcast is recognized and reported by the compiler.
First, define a class called CityCar that contains an array of pointers to the 100 objects in the  class_0_This also allows you to store pointers to objects of the derived class types  and.
The objects themselves will be created dynamically at runtime.
The constructor will set the current number of array elements to 0.
The destructor must release memory allocated dynamically for the remaining objects.
Make sure that you use a virtual destructor definition in the base class  to allow correct releasing of memory for trucks and vehicles.
Implement two versions of the insert() method using the prototype shown opposite.
Each version will allocate memory to an object of the appropriate type—that is of the  or  class—and use the arguments passed to it for initialization_0_The method should return false if it is impossible to enter another automobile (that is, if the array is full), and true in all other cases.
The display() method outputs the data of all vehicles on screen_0_To perform this task it calls the existing display() method for each object.
Insert one and one _0_These will be the first vehicles of the company's fleet.
If a user chooses "Add " or "Add ," your program must read the data supplied and call the appropriate version of insert().
If yes to record Dialog with the receptionist EXERCISES ■ 557 Exercise 2 An automatic checkout system for a supermarket chain needs to be completed.
The  creates an array of 100 pointers to the base class, Product.
The checkout assistant is prompted to state whether a prepacked or fresh food item is to be scanned next.
Memory for each product scanned is allocated dynamically and referenced by the next pointer in the array.
After scanning all the available items, a sequential list is displayed_0_The prices of all the items are added and the total is output at the end.
The checkout assistant is prompted in a loop to state whether to define a new.
If so, the record()  is called; if not, the program terminates.
Example: *, &coRef; The pointer  is a base class pointer that can address objects belonging to derived concrete classes.
The reference coRef can also address objects  this type.
The copy constructor in the Coworker class is just one  them.
Example: Coworker( const Coworker& ); The copy constructor expects an object belonging to a derived class, since the base class is abstract.
The assignment in the Coworker class has a reference as a parameter and returns a reference to the abstract class.
If the base class is abstract, you can only allocate memory for objects belonging to derived, concrete classes.
Example: Coworker* ; = new ("Young, Neil",45_0_,40); << felPtrarrow_operatorincome(); Since the income()method is virtual, a corresponding function found in the derived class  is executed.
If a derived class contains its own definition  a virtual method, this version will also be executed if an object is referenced by a base class pointer or reference.
Abstract classes are therefore also referred to as polymorphic interfaces to derived classes.
The opposite page shows the definition  the  class, which was also derived from the abstract class.
The  functions for the assignments are discussed and implemented in the following section.
Redefining the virtual  function =(), which returns a reference to the derived class, is not yet supported by all compilers.
In  case the return type must be a reference to the base class.
In  case, you can ensure that the right version  an  function will be executed when using a pointer or reference to  base class to address  derived class object.
One example   is the  function for an assignment.
If the function declaration is not virtual, and if the function is called via  base class pointer, only the base data  the object is overwritten.
Any additional data members  the derived class remain unchanged.
The derived classes and  both contain their own versions.
Thus, in the following Example: {  = b; } the assignment  the  class is executed, if an object   class type is the first argument passed to it.
If the object is   type, the assignment  the class is performed.
In the case  the cpy()function, you can therefore assign two objects  any class, including classes derived at  later stage, without having to modify the function itself.
However, you definitely need to define    the assignment for each derived class.
Since the standard assignment   derived class has signature  its own, it is not virtual.
The standard assignment for the  class has the following prototype: Example: & =(const &); The type const & is different from the const & type  the parameter in the virtual  function  the base class.
The standard assignment thus masks the virtual assignment in the base class.
This gives rise to two issues: ■ the virtual  function for the assignment must be defined for every derived class ■ to ensure that the standard assignment is also available, the standard assignment must also be redefined in every derived class.
An inhomogeneous list is  linear list whose elements can be of different types.
If the data you need to store consists of objects in  class hierarchy, one list element could contain an object belonging to the base class, whereas another could contain an object of  derived class.
Due to implicit type conversions in class hierarchies, you can use the base class pointers to manage the list elements, that is, you can manage the elements in  linked list.
The following graphic illustrates  scenario: � Representing List Elements To separate the management of list elements from the information contained in the list, we have defined an abstract class called  as  base class for all list elements.
The class contains  pointer of type * as the data member used to link list elements.
Since  type objects are not be created, the constructor in the  class has protected declaration.
The  class does not contain any data that might need to be output.
However, each class derived from  contains data that need to be displayed.
For  reason, contains  declaration of the pure virtual method display(), which can be modified for multiple derivations.
The classes BaseEl and DerivedEl, which are derived from , represent list elements used for storing information.
To keep things simple, the BaseEl class contains only  name, and the DerivedEl class additionally contains  comment.
The public declaration section contains  constructor and access method declarations.
In addition, suitable  of the display() method is defined.
This page intentionally left blank 637 More about Files This chapter describes ■ random access to files based on file streams ■ options for querying file state ■ exception handling for files.
We will also illustrate how to make objects in polymorphic classes persistent, that is, how to save them in files_0_The applications introduced in chapter  simple  files and hash tables.
To open the file for  and output.
Opens the file for  and output.
If the file already exists, it will be truncated.
Opens the file for  and output.
If the file does not exist, it will be created.
Before each writing access, seek to end is performed.
If the flag ios::binary is additionally set, the file will be opened in binary mode.
If the flag ios::ate ("at end") is additionally set, the current seek position is set to end-of-file immediately after opening.
If you need access to specific information in such  file, you have to walk through the file from top to tail, and new records are always appended at the end of the file.
Random file access gives you the option of reading and writing information directly at pre-defined position.
To be able to do , you need to change the current file position explicitly, that is, you need to point the get/put pointer to the next byte to be manipulated.
After pointing the pointer, you can revert to using the read and write operations that you are already familiar with.
This implies opening the file in binary  to avoid having to transfer additional escape characters to the file.
Example: ios::openmode  = ios::in | ios::out | ios::app | ios::binary; fstream fstr("account_0_fle", ); This statement opens the file "Account_0_fle" in binary  for reading and appending at end-of-file.
The file will be created if it did not previously exist.
Random read access to the file is possible, but for write operations new  will be appended at the end of the file.
To enable random read and write access to  file, the file can be opened as follows: Example: ios::openmode  = ios::in | ios::out | ios::binary; fstream fstr("account_0_fle", ); However, this technique can only be used for existing files.
If the file does not exist, you can use the ios::trunc flag to create it.
The section "File State" discusses your error handling options if  file, such as "account_0_fle" cannot be found.
The tellp() and tellg() methods return the current position of the put or get pointers as a long value.
Example: long  = myfile_0_tellg(); This statement queries the current position of the read pointer in the myfile stream.
The current position is always returned as a byte offset relative to the beginning of the file.
The current file position can be modified using the seekp() or seekg() method.
The position is stated as a byte offset, relative to either the beginning or end of the file, or relative to the current position in the file.
Imagine you want to write the object acc to the file "account_0_fle" at offset pos.
You can use the following statements to do so: Example: ofstream fstr("account_0_fle", ios::out | ios::binary); fstr_0_seekp(pos, ios::begin); acc_0_write( fstr ); This calls the write() method in the Account class, which allows an object to write its own data members to a file (see Chapter 18).
If you do not specify a positioning flag, the position will be assumed to be relative to the beginning of the file.
The statement used to position the write pointer in the last example can therefore be formulated as follows: Example: fstr_0_seekp(pos ); The byte offset can also be negative for calls to the methods seekp() and seekg().
However, you cannot position the read/write pointer before the beginning of the file.
In contrast, it is possible to place the pointer at a position after the end of the file and then perform a write operation, which will create a gap with unknown content in the file.
This only makes sense if all the empty slots in the file are of an equal length, as they can be overwritten later.
This option is often used when programming hash tables.
Representing an index entry The read_at() and write_at() methods ■ 643 � Using Positioning Methods The following statements are commonly used for random positioning seekg( 0); and seekp( 0, ios::end ); They set the current position to the beginning or end of a file.
You should be aware that the first argument is 0 to indicate that long type is required.
If you need to determine the length of a file, you can point the get pointer to the end of the file and then query the position of the pointer: Example: fstr_0_seekg(0, ios::end); unsigned long  = fstr_0_tellg(); The  variable will then contain the number of bytes occupied by the file.
These positioning methods are useful for files opened in binary.
However, it does not make much sense to use them for text files or particularly for devices.
In text , conversions of  <=> CR/ prevent the methods from working correctly.
Given that size is the length of a record 0,  size,  2*size, _0__0_.
If you are working with variable length records, you cannot exactly compute their positions.
To enable random access you therefore need to store the positions of the records in a separate structure, a so-called index.
The index stores pairs of keys and record positions, so-called index entries in a file.
A , a social security number, or customer id, for example, must uniquely identify a record.
If the index is sorted, the position that correlates to the required  can be quickly found using the binary search algorithm.
The class comprises methods for reading and writing an index entry at the current file position or at any given position.
The appropriate file stream is passed as an argument to the method.
A file operation can also fail if a file cannot be opened, or if a block is not transferred correctly.
The ios class uses state flags to define the various states a file can assume.
Each state flag corresponds to a single bit in a status-word, which is represented by the iostate type in the ios class.
The following state flags exist: ■ ios::eofbit end of file reached ■ ios::failbit last read or write operation failed ■ ios::badbit an irrecoverable error occurred ■ ios::goodbit the stream is ok, e_0_g.
The "flag" ios::goodbit is an exception to the rule since it is not represented by a single bit, but by the value 0 if no other flag has been set.
In other words a status-word has the value ios::goodbit if everything is fine.
A method exists for each state flag; these are eof(), fail(), bad(), and good().
They return true when the corresponding flag has been raised.
This means you can discover the end of a file with the following statement: Example: if( fstr_0_eof() ) _0__0_.
The -word of a stream can be read using the () method.
Individual flags can then be queried by a simple comparison: Example: if( myfile_0_() == ios::badbit ).
An argument of the iostate type passed to clear() automatically becomes the new -word for the stream.
The constructor for this class uses the clear() method to reset the fail bit after an invalid attempt to open a non-existent.
The IndexFile class comprises methods for inserting, seeking, and retrieving index entries, which we will be implementing later in this chapter.
WriteError(const string& ):FileError(){ } }; #endif ■ EXCEPTION HANDLING FOR FILES Defining your own exception classes EXCEPTION HANDLING FOR FILES ■ 647 � Implementing Your Own Exception Handling You can exploit the error tracking options that state flags give you to implement your own exception handling for files.
For example, a method that reads records from a can throw an exception when the state flag ios::eof is raised, that is, when the end of the  is reached.
The opposite page shows typical exception classes organized in a hierarchy that can be used to represent error conditions on opening, reading from, and writing to a.
In each case the   is saved for evaluation by the exception handler.
You can use the exceptions() method to specify the flags in the -word of a stream that will cause exceptions to be thrown.
The exceptions() method is defined in the ios stream base class.
The method expects one or multiple state flags separated by the | sign.
An exception is then thrown for the flags specified.
Example: ifstream ifstrm("account_0_fle"); fstrm_0_exceptions(ios::failbit | ios::badbit); On accessing the fstrm stream an exception is thrown if either one of the flags ios::failbit or ios::badbit is raised.
The operation that caused the error is then terminated and the state flags are cleared by a call to clear(());.
The exception thrown here is of a standard exception class, failure.
This type is defined as a public element in the ios base class and comprises the virtual method what() that returns a C string containing the cause of the error.
The exception handler will normally send the string to standard error output.
You can call exceptions() without any arguments to discover the state flags in a -word of a stream that can cause an exception to be thrown.
If a bit is set in the return value of the exceptions() method, an appropriate exception will be thrown whenever this error occurs.
Example: iostate  = fstrm_0_exceptions(); if(  & ios::eofbit) _0__0_.
This statement uses a bitwise AND operator to ascertain whether an exception is thrown when end-of- is reached.
The methods read() and write() of class DepAcc PERSISTENCE OF POLYMORPHIC OBJECTS ■ 649 � Storing Polymorphic Objects Imagine you want to make the objects of a polymorphic class hierarchy persistent, that is, store them in a.
You need to ensure that an object can be reconstructed precisely when it is read.
This gives rise to the fact that objects in polymorphic class hierarchies contain virtual methods.
So it is not simply a case of making the data members of an object into records and writing them to a.
You must write both the type and the data members of the object to a.
If the objects contain dynamic members, you must save the referenced objects themselves along with information on the object type.
The methods can have a virtual definition within the class hierarchy.
Thus, if pointers are used to reference objects, the appropriate read/write operation for each object will be called.
Virtual  I/O methods have now been added.
The implementation of the read() and write() methods was discussed earlier in Chapter 18, "Fundamentals of File Input and Output," and is unchanged.
The derived classes DepAcc and SavAcc also contain definitions of the read() and write()methods that read only their "own" objects and write them to files.
The implementation first calls the appropriate base class method.
If no errors occur, it is simply a question of transferring the additional data members of the derived class to or from a.
At present, no type information will be written to file or read from file.
This task will be performed by a special class whose features are used for file management.
The following section contains more details on this topic.
This page intentionally left blank 681 More about Pointers This chapter describes advanced uses of pointers_0_These  pointers to pointers, functions with a variable number of arguments, and pointers to functions.
An application that defines a class used to represent dynamic matrices is introduced.
POINTER TO POINTERS ■ 683 � Motivation Pointer variables are objects that have an address in memory, and this means you can use pointers to address them.
It is thus possible to create pointers to pointers.
This is necessary if ■ an array of pointers is to be dynamically allocated, or ■ a function expects an array of pointers as an argument.
In both cases you need to declare a pointer variable that can access the first element in the array.
Since each element in the array is a pointer, this pointer variable must be a pointer to a pointer.
Example: **  = new *[400]; The pointer  is now pointing at the first pointer in the array with a total of 400 * type pointers.
The array elements can be addressed as follows: * and [0] and [] Access to objects managed by the array is achieved as follows: ** and *[0] and *[] � Pointer Arrays as Arguments When you define a function that expects an array of pointers as an argument, you must define parameters to match.
Example: void accSort(  **, int len); You can use the  parameter to manipulate a pointer array whose length is stored in the second parameter, len.
After calling Example: accSort( , 100); points to the first pointer [0] in the pointer array.
Instead of ** you can also use the equivalent form  *[].
The opposite page shows an implementation of the function accSort().
The function uses the selection sort algorithm (which you have already worked with) for sorting.
In this case it is important not to sort the accounts itself, but to sort the pointers instead.
This saves time-consuming copying.
One example of a function of this type is the standard C function printf(), which requires at least one argument, a format string.
The printf() function uses the conversion specifiers in the format string to compute the number and type of arguments that follow.
At least one obligatory argument is required.
As you would expect, you need to define an appropriate parameter for each obligatory argument when you define a function of this type.
The optional arguments are represented by three dots _0__0_.
The function shown opposite, func(), expects two or more arguments.
The prototype is, thus, as follows Prototype: int func( char *buffer, int max, _0__0__0_); To allow functions with a variable number of arguments to be defined, Cplus_plus pushes the last argument onto the stack first.
After calling the sample function func(), the stack looks like the diagram opposite.
The optional arguments are accessed via a pointer, the so-called argument pointer, which is designated by argptr here.
The header files cstdarg or stdarg_0_h contain macros, which conform to ANSI standard, to manage the pointer and assure that the source code will be portable.
The va_list type argument pointer argptr must be declared in addition to other local variables.
The type va_list is defined in the header file stdarg_0_h as a typeless or char pointer.
The macro va_start() is then called to point the argument pointer argptr to the first optional argument.
Example: va_start( argptr, max ); 686 ■ C H A P T E R  3 0 M O R E  A B O U T  P O I N T E R S // input_0_cpp: The function input() reads characters //            from the keyboard and appends '\0'.
Pointer to the input buffer.
Maximum number of characters to be read /             3.
Optional arguments: Characters that.
When the macro va_arg() is called, the optional argument pointed to by argptr is read from the stack.
The arguments of va_arg() are the name of the argument pointer and the type of the optional argument: : 3 = va_arg( argptr, long); Each call to the macro va_arg() sets the argument pointer to the next optional argument.
The result of va_arg() has the type stated in the call.
It must be identical to the type of the corresponding optional argument.
There is no special terminating condition for the last optional argument.
A specific value (such as NULL, �1 or ) can be used, or the current number of arguments can be defined by an obligatory argument.
After evaluating the arguments the argument pointer is set to NULL by the va_end() macro: : va_end( argptr); Optional arguments can also be read more than once.
The procedure described above is repeated beginning at Step 2, that is, with the macro va_start().
The second argument defines the maximum number of characters to be read.
All other arguments are characters that can terminate keyboard input.
The last argument must be a return character ('\r').
Input can be terminated by pressing the space, ESC, F1, or return keys.
The return value is the corresponding character code.
Non-printable characters are ignored unless stated as optional arguments.
Special keys, such as the function keys, return a value of 0 for the first call to () and the extended code for the second call.
For function keys this code is within the range 59–68.
To distinguish extended codes from normal ASCII codes (0–255), the value 256 is added to the extended code.
A table of extended codes is available in the Appendix.
Both integral and floating-point numbers are represented internally as binary numbers, that is, as sequences of 0 and 1 values.
However, the formats for representing integral and floating-point numbers differ.
Thus, the bit-pattern of an integer will be interpreted differently from that of a floating-point number by the computer.
Representing Signed and Unsigned Integers The binary format of integers is basically the same for the char, short, int and long types and differs only in ■ the number of bytes available for each type and ■ whether the number is interpreted as signed or unsigned.
The bit-pattern of a positive integer can be represented as a base 2 power series.
The sign bit 0 additionally indicates that the number is positive in the case of signed types.
The number 4 can be represented by the following power series: 0*20 + 0*21 + 1*22 + 0*23 + 0*24 _0__0_.
The binary representation of the number 4 as signed char type value (8 bits) is thus as follows: Two's complement is used to represent a negative number, for example -4: 1 1 1 1 1 0 1 1 First, one's complement of 4 is computed, that is, all the bits are inverted: Then the number 1 is added: Producing the bit pattern of –4: 0 0 0 0 0 0 0 1 1 1 1 1 1 1 0 0 26 25.
Two's complement for -4 yields a value of 4.
Sign bits are not required for unsigned types.
The bit can then be used to represent further positive numbers, doubling the range of positive numbers that can be represented.
The following table contains the binary formats of signed and unsigned integral 8 bit values: If the bit-pattern of a negative number is interpreted as an unsigned number, the value of the number changes.
The bit-pattern 1111 1100 of the number �4 will thus yield the following unsigned value: 0*20 + 0*21 + 1*22 + 1*23 + 1*24 + 1*25 + 1*26 + 1*27 that is, the decimal number 252.
Representing Floating-point Numbers To represent a given floating-point number, , the number is first broken down into a sign, v, a mantissa, m, and a power, exp, with a base of 2: = v * m * 2exp 0000 0000 0000 0001 0000 0010 0000 0011 0111 1101 0111 1110 0111 1111 1111 1100 1111 1101 1111 1110 1111 1111 1000 0000 1000 0001 Binary Signed decimal Unsigned decimal.
BINARY NUMBERS ■ 785 Memory for the values v, m, and exp is normally assigned in IEEE (Institute of Electronics and Electronical Engineers) format.
The type float (32 bit) will thus be organized as follows: In this "normalized" form, floating-point numbers are unambiguous.
The mantissa, m, has a value that is greater than or equal to 1 and less than 2, the only exception being  == 0, where the mantissa is 0.
Example: -4_0_5 =  -1 * 1_0_125 * 22 The first digit of the mantissa is always 1 and need not be stored.
The power is stored along with its bias.
A bias of 127 applies for float types; thus a power e of a floatingpoint number is represented internally as e + 127.
The memory reserved for the mantissa defines the accuracy, and the memory reserved for the power defines the range of values for the floating-point number.
If platform-dependent ranges, such as the length of the mantissa or the smallest or largest value that can be represented, are significant in your programs, you can discover these ranges in the cfloat or climits header files.
You can use an instantiation of the numeric_limits class template for the type in question to query platform-dependent ranges by method calls.
Bit position 31 30 23 22 0 exp m 786 ■ A P P E N D I X ■ PREPROCESSOR DIRECTIVES The #define Directive The #define directive is used to define symbolic constants and macros.
Syntax: #define name[(parameterlist)] [SubstituteText] The preprocessor replaces name or name(parameterlist)with SubstituteText throughout the whole program.
If SubstituteText is not stated, the preprocessor will delete the symbolic constant or macro throughout the program code (see also Chapter 7, Example: #define BUFSIZ 512 // Symbolic constant.
When the macro is called, the argument is set in quotes, that is, a string constant is formed using the characters of the current argument.
Example: which is then concatenated to "****  Catalog  ****".
The characters " and \ are represented by \" and \\ within an argument.
Example: #define path(logid,subdir) "\\user\\" #logid "\\bin\\" #cmd With the string "\user\Smith\bin\games " is produced.
The ## Operator When a macro is defined, character sequences can be concatenated in the substitute text.
The past token operator, ##, is used to this effect.
When the macro is called, the parameter preceding or following the ## token is replaced by the appropriate argument.
Then the token and any leading or trailing whitespace character is removed.
PREPROCESSOR DIRECTIVES ■ 787 Example: #define debug()  << "" # "=" <<  ## Calling debug(1); will generate the statement << "1=" << 1; The arguments of a macro are not parsed for symbolic constants or macros.
However, if the result of a concatenation is a symbolic constant or a macro, text replacement is again performed.
The #undef Directive To change the definition of a symbolic constant or a macro at program runtime, you must first remove the original definition.
To do so, the #undef directive is used.
Syntax: #undef name Do not supply the parameter list for parameterized macros.
You can then use the #define directive to redefine the macro.
Example: #define   BUFSIZE  512.
The # directive is replaced by the content of the file.
Syntax: # <filename> #else.
Replace the # sign by the appropriate decimal number in all cases.
ESC[#A Cursor # lines up ESC[#B Cursor # lines down ESC[#C Cursor # characters right ESC[#D Cursor # characters left ESC[z,sH or ESC[z;sf Put cursor in line z and column s ESC[s Save cursor position ESC[u Load saved cursor position ESC[#K # = 0: Delete from cursor position to line end # = 1:Delete from start of line to cursor position # = 2: Delete whole line ESC[2J Clear screen ESC[#(;#_0__0__0_)opm # = 0: all attributes normal # = 1: switch double intensity on # = 5: Blink on # = 7: Inverse on # = 3: Foreground color # = 4: Background color = 0: black = 4: blue = 1: red = 5: magenta = 2: green = 6: cyan = 3: yellow = 7:white ESC[c1;c2p Change key assignments: The key with decimal code c1 will then return code c2.
To enable these escape sequences, you must first load an appropriate screen device driver.
To do so for Windows 9, place the following line in your CONFIG_0_SYS file = C:\Windows\Command\Ansi_0_sys Win NT and Win 2000 do not supply the ANSI screen control characters.
Corresponding functions based on system calls are offered for download.
International Standard ISO/IEC 9899:1999(E), Programming Languages—C; published by ISO Copyright Office, Case postale 56, CH-1211, Geneva 20, 1999.
Stroustrup, Bjarne, The Cplus_plus Programming Language, Addison Wesley, 2000.
Josuttis, Nicolai, The Cplus_plus Standard Library, Addison Wesley, 1999.
LITERATURE ■ 801 This page intentionally left blank 803 Note: Italicized page locators indicate figures.
See also Compound assignments Associative arrays, 427 Associative container classes, 769 Associative containers, 750, 751, 768, 769 and bitsets, 751 ATM (Asynchronous Transfer Mode) cells header of, 714, 715 representing, 714 at() method, 165, 761 auto keyword, 205 Automatic lifetime, 199 auto objects, 205 auto specifier, 204 B back() method and container classes vector, deque, and list, 761 Backslashes, 29 bad_cast, 553 badbit, 645 Base classes, 383, 501 accessibility of, 589 access to members in, 503, 509 calling methods in, 513 conversions in references to, 535 converting to, 530, 531 multiple indirect, 590, 591 virtual, 592, 593 with virtual destructors, 548, 549 Base class object assignment, 533 Base class pointer conversion, 535 BaseE1 class, 575 defining, 574 Base initializers, 511, 595, 597, 655 Base subobject, 505 begin() method, 755, 769 Bell Laboratories, 3 Bias, 786 Bidirectional iterators, 755 Binary arithmetic operators, 82, 83 Binary bitwise operators, 713 Binary complement, 143 Binary mode file opened in, 638 Binary operator, 415, 417 and operands, 82 Binary search algorithm, 643 Binary trees, 187 Binding, 551 Bit coded data, 707 Bit-fields, 714 defining, 715 Bitmap container class, 774, 775 Bitmaps raster images represented with, 774, 775 Bit masks, 710, 711 creating, 713 using, 712 Bit patterns retaining, 143 Bits deleting, 711 manipulating, 777 Bitsets, 774, 775, 776, 777 associative containers and, 751 declaring, 775 Bitwise AND operator, 711 Bitwise exclusive OR operator, 711 INDEX ■ 805 Bitwise operators, 412, 706, 707, 751 for bit manipulation, 777 in compound assignments, 713 for creating bit masks, 713 Bitwise OR operator, 711 Bitwise shift operators, 707, 708, 709 Blocks, building, 97 Block scope object defined with, 199 Boolean constants, 23 Boolean operator precedence, 91 Boolean values, 17 output of, 68, 69, 71 types for, 16 bool type, 17, 23, 91 Braces and functions without arguments, 45 and variables, 33 Brackets and parameters for macros, 123 in syntax descriptions, 612 Branches, 125 break statement, 113 sample program containing, 112 Bresenham algorithm, 776, 777 Bubble sort algorithm, 334 Built-in types, 17 C C programming language, 3, 49, 51 standard library header files, 48 Cplus_plus characteristics of, 2, 3 conventions in, 31 developing/translating programs in, 6, 7 historical perspective on, 3 keywords in, 30 programming language, 3 sample program, 8, 18 standard library, 7, 9, 48, 173, 723, 751, 753, 773 calc() function, 618, 619 Calling environment, 611 Capacities, 5, 763 capital() function defining, 182 Car class, 504 accessing members of, 506 virtual method table for, 550 Case conversion and macros, 129 Case labels, 111 Casting, 147 Castle class, 514, 515 Cast operator, 147 catch block, 615 nested, 616, 617 syntax of, 612, 613 Catching exceptions, 614 cctype header file, 129 Cell base class and derived classes, 574 cerr stream, 58, 59 cfloat header file, 21 Character by character string comparison, 159 Character codes, 17, 69 Character constants, 23, 25 examples for, 24 Character manipulation standard macros for, 128 Characters, 17 output of, 68, 69 reading and writing, 75 testing, 129 types for, 16 Character set, 17 char arrays, 327 CHAR_MAX, 19 CHAR_MIN, 19 char pointers, 351 array of, 367 sample function, 364 char type, 17, 19, 25, 112 char vectors, 327 cin, 429 cin stream, 47, 49, 58, 61 Class arrays declaring, 329 sample program, 328 Class(), 5, 245 abstract, 565-585 adapter, 753 806 ■ I N D E X associative container, 769 base, 501 container, 753 defining, 246, 247 derived, 501 dynamic members of, 479, 480 dynamic storage allocation for, 458 example of, 246 exception, 611 friend, 424, 425 and friend functions, 423 and global functions, 51 I/O stream, 59 iterator, 755 multiply-derived, 588, 589 naming, 247 operators for, 413.
See also Abstract classes; Adapter classes; Base classes; Derived classes; Type conversion for classes class keyword, 247, 257 Class  access operator, 253 Class- constants, 309 Class , 723 defining, 725 for sequences, 753 clear() method, 70, 645 for deleting objects in container classes, 765 for erasing containers, 771 and maps/multimaps, 773 Client class, 303 climits header file, 19 clog stream, 58, 59 close() method, 389 Closing files, 388, 389 CLS macro, 123 cmath header file, 41 Collision resolution, 658 Collisions, 658 Colons after labels, 113 Command line arguments, 367 sample program, 366 Comma operator, 412 syntax for, 101 Commas for separating  initializers, 301 Comments Cplus_plus program with, 10 examples of, 11 Comparative operators, 88, 159, 355 Comparator class, 753 compare() function, 689 Comparisons results of, 89, 159, 355 Compiler, 7 Complex declarations, 690 operators and, 691 rules for evaluating, 691 complex header file, 48 Compound assignments, 145 bitwise operators in, 713 demonstration of, 86 operators, 87 Compound conditions, 91 Concatenation operators, 50, 157 Concrete classes abstract classes versus, 569 Conditional expressions, 109 compilation, 790 structogram for, 108 Conditional inclusion, 126, 127 Conditional operator precedence, 109 conio_0_h header file, 132 Constants, 23, 25 class-, 309 const_iterator type, 755 const keyword, 34, 36, 64, 223 const  object declaration, 303 Const objects/methods accessing, 276, 277 pointers to, 361 Constructor calls, 594, 595 and initialization, 595 sample program, 268 in virtual base classes, 597 Constructors, 251, 465 Account class with, 266 for adapter classes, 757 calling, 269, 299 conversion, 442, 443 copy, 279 declaring, 267 INDEX ■ 807 default, 269, 279 defining, 266, 267 initializing, 269 with inline definitions, 273 task of, 267 of vector, list, and deque, 757.
See also Destructors Container adapters, 752 Container classes, 753, 768 deleting objects in, 765 Containers, 749-782 description of, 751 length and capacity of, 763 positioning and iterating in, 755 types of, 750, 751 Containers Library, 751, 753 Contiguous memory space, 323 continue statement, 113 Control, 28 Controlling expression, 97 ControlPoint class, 424, 425 Conversion constructors, 442, 443 Conversion functions, 443 conversion constructor versus, 445 defining, 445 "Cooked mode," 386 Copy constructor, 279 effect of standard, 486 for FloatArr class, 486, 487 proprietary version of, 487 cos() function, 40 Counter initializing, 99 count() method and maps/multimaps, 773 count variable, 643 cout, 9, 30, 32 cout stream, 47, 49, 58, 61 Coworker class, 566, 567 assignment for, 572, 573 CPU registers, 205 cstdlib header file, 45 C strings initializing, 326 specializing function template for, 732 and string class, 327 ctime() function, 167 ctype_0_h header file, 48 Current file position, 381 currentTime() global function, 284, 285 D Data abstraction, 3, 245, 501 bit coding, 707 class-specific, 305 encapsulation, 3, 245, 273 structures, 463 Data blocks transferring, 391 Data handling with traditional procedural programming, 5 Data members, 51, 245 and methods, 505 static, 304, 305 Date class methods, 288 Daytime class operators, 414 DayTime sample class, 280 Debuggers, 7 DEC Alpha workstations and bit-fields, 715 Decimal constant, 23 Decimals floating-point numbers represented as, 25 Declarations, 41 within header files, 47 Declaring sequences, 756, 757 dec manipulator, 63, 73 Decrement operator, 85 and bidirectional iterators, 755 Default arguments, 182, 183 defining, 182, 183 rules for and setting of, 735 of templates, 734, 735 default constructors, 269, 279, 299, 461 Default destructors, 271 default label, 111 Default settings, for flags, 61 #define directive, 121, 127 enum constants contrasted with, 309 working with, 124, 125 delete operator, 455, 456, 457, 459 808 ■ I N D E X delete[] operator, 461, 483 Deleting in arrays, 485 list elements, 465, 467 objects in container classes, 765 in sequences, 764, 765 depAcc class read() and write() methods of, 648, 649 deque container class, 755, 765 constructors of, 757 Derived classes, 501, 505 constructing/destroying, 510, 511 defining, 502 members of, 504 standard assignment of, 573 Derived class object assignment, 533 DerivedE1 class, 575 defining, 574 Derived type, 323 Destructors, 251, 465, 483, 655 calling, 271, 549 declaring, 271 default, 271 defined, 271 with inline definitions, 273 in Matrix class, 695 sample program, 270.
See also Constructors Direct base class, 503 Direct derivation, 502 displayError() function, 365 display() function, 227 display() method, 247, 253, 509 calling, 546, 547 new  of, 508 Division, 82 Dot operators, 253 Double ended queue, 753 Double quotes and header files, 47 string constant within, 25 double type, 21, 25 do-while loop, 97 syntax for, 103 do-while statement structogram for, 102 Downcasting, 536, 537 safety issues in, 537, 553 draw() method and Bitmap container class, 775 and Bresenham algorithm, 777 Dynamically allocated objects destroying, 548, 549 Dynamic arrays, 461 Dynamic binding, 551 Dynamic casting, 537 dynamic_cast operator, 553 Dynamic casts using, 552 Dynamic data structures, 463 Dynamic matrices, 694, 695 Dynamic members, 477-498 classes with, 480 description of, 479 objects created with, 480 of varying length, 478 Dynamic memory allocation, 453-475 for containers, 751 Dynamic storage allocation for arrays, 460, 461 for classes, 458 E Early binding, 551 Elementary operations, 463 Element functions for output in fields, 66 else branch, 105, 107 Else-if chains structogram for, 106 switch statement contrasted with, 111 Embedded keys, 769 Employee class, 570 assignment for, 572, 573 Empty lists, 465, 577 empty() method, 771 and container classes, 763 Empty statements, 99 Empty strings, 25 Encapsulation, 3, 245, 257 of arrays, 333 and static data members, 307 INDEX ■ 809 end() method, 755 and associative container classes, 769 endl manipulator, 9, 61 Enumeration definition, 309 sample program, 308 enum keyword, 309 eof bit, 387 Equals sign and initialization, 33 erase() method, 161, 771 for deleting objects in container classes, 765 errno_0_h header file, 48 Error classes defining, 618, 619 Error condition backing out of, 615 Error handling, 387 and exception hierarchies, 619 for new , 457 traditional, 608, 609 Errors avoiding, 723 common causes of, 609 input, 73 messages, 7, 43 parity bit computation and recognition of, 713 runtime, 267 templates checked for, 727 Escape sequences, 26, 28, 29, 123 decimal values and effects, 28 Euro class, 416, 417, 418 converting constructors of, 442 converting function for, 444 explicit type conversion for, 446 expressions valid for operators in, 419 with friend functions, 422 , 420 testing conversions of, 444 Exception classes, 611 defining, 646 standard, 620, 621 Exception class members, 619 Exception declaration, 613 Exception handlers, 612, 613 searching for, 615 Exception handling, 3, 607-635 concept behind, 611 description of, 613 for files, 646 implementing own, 647 nesting, 616-617 Exception hierarchies, 619 Exceptions, 165 catching, 614 re-throwing, 617 throwing, 611, 614, 651 exceptions() method, 647 Exception specification list, 617 exchange() template function, 727.
Exit code, 9 exit() function, 389 exp() function, 40 Explicit cast constructions, 537 Explicit initialization, 329 of objects, 459 Explicit inline methods, 273 Explicit instantiation of templates, 736, 737 syntax for, 737 Explicit type conversion, 147, 443, 536, 537 for Euro class, 446 testing, 446 explicit keyword, 447 Exponential notation, 25, 65 Expressions, 83 evaluating, 97 with reference type, 228, 229 in switch statement, 111 Extended codes, 687 External functions, 207 External static object, 203 extern storage class, 200, 201, 207 extern "c", 795 F failbit state flag, of ios base class, 387 fail() method, 387 false keyword, 23 Fibonacci numbers, 325 Fibonacci quotients, 325 810 ■ I N D E X Fields input, 71 output, 66 Field width defining, 63 specifying, 67 File access mode, 385 stream classes for, 382 File management and file buffer, 381 File operations, 380, 381 Files, 381 buffers, 381 closing, 388, 389 default settings for opening, 386 determining positions in, 643 error handling when opening, 387 exception handling for, 646 extensions, 7 names, 385 opening/closing, 383, 385, 387, 638 open mode of, 386 positioning for random access, 640, 641, 642, 643.
See also Header files; Records File scope object defined with, 199 File state, 644, 645 File stream classes, 382, 383 functionality of, 383 in iostream library, 383 File streams, 383 definition, 385 sample program/creating, 384 Fill-characters specifying for field, 67 fill() method, 67 Filter programs using, 131 Filters, 131 find() method, 163 and maps/multimaps, 773 fixed manipulator, 65 Fixed point output, 65 Flags, 60 for open mode of file, 386 open mode, 387 positioning, 641 state, 645, 647 FloatArr class, 740 constructors in, 483 copy constructor for, 486, 487 data members of, 478 new  in, 488 new  of, 490, 491 prototype of operator function for, 489 versions of, 479, 480, 481, 484, 485 Floating-point constants, 25 examples for, 24 Floating-point division, 413 Floating-point numbers, 17, 21, 25 formatted output of, 64 inputting, 73 Floating-point types, 20, 21 conversion of, to integral type, 145 conversion of, to larger floating-point type, 143 conversion of, to smaller type, 145 Floating-point values types for, 16 float type, 21, 25, 331 for loops syntax for, 99 Formatting, 61 options, 63 standard settings, 65 Formatting flags, 61 Formatting operator, 63, 67 for statement, 97 sample program, 100 structogram for, 98 Fraction class, 431 simplify() method of, 448 Fractions calculating with, 430 Friend classes, 424, 425 declaring, 425 using, 425 Friend declaration, 423 Friend functions, 422, 423 declaring, 423 overloading operators with, 423 using, 425 INDEX ■ 811 friend keyword, 423 front() method, 761 and container classes vector, deque, and list, 761 fstream class, 383, 387 Function blocks, 175 Function call operator, 420 Function calls defined, 43 implicit type conversions in, 147, 531 sample program, 42 Function prototype, 11, 41 example of, 40 Functions, 171-195 Cplus_plus program with, 10 calling and called, 178 conversion of, 443 declaring, 40-41, 175, 177 default arguments defined for, 182, 183 defining, 174 error checking after leaving, 608 external, 207 general form of, 174, 175 hash, 658 inline, 180, 181 libraries, 173 and macros, 125 operator, 414, 415, 416 overloading, 184, 185 and passing by value, 179 pointers to, 688, 689 pointer versions of, 358, 359 recursive, 186, 187 return value of, 176 sample, 205 scheme of, with varying arguments, 684 signatures, 185 significance of, in Cplus_plus, 172 static, 207 virtual operator, 573 without arguments, 45 without return value, 45 Function templates, 723 ANSI instantiation of, 737 defining, 725 explicit instantiation of, 737 passing arguments to, 730, 731 Fundamental types, 16, 17, 18, 20 example with, 303 operators for, 82-90 G.
See Institute of Electrical and Electronic Engineers #ifdef directive, 127 if-else statement structogram for, 104 syntax for, 105 #ifndef directive, 127 if statements variables defined in, 105 ifstream class, 383 Implicit conversion, 531 example for, 530 Implicit inline methods, 273 Implicit instantiation, 737 of template class, 727 Implicit type conversions, 140, 141, 441, 443 in assignments, 144 avoiding, 447 to base class type, 531 in function calls, 147 #include directive, 47 Include files, 7 include folder, 47 income() method, 567, 569 in constant, 309 Increment operator, 85 and bidirectional iterators, 755 Indefinite recursion, 509 Indentation, 11 Index entries, 643 representing, 642 IndexEntry class, 642, 643 Indexes, 165, 323, 643, 653, 655 access via, 761 for array elements, 323 and bit manipulation, 777 invalid, 165 representing, 644 Index file, 653 implementing, 654, 655 IndexFile class, 656 constructor of, 644 defined, 644, 645 insert() method of, 652, 653 IndexFileSystem class insert() and retrieve() methods of, 654, 655 Index versions of functions, 358, 359 Indirect base class, 503 Indirect derivation, 502 Indirection operator, 232, 233, 355 Infinite loops, 101 Inheritance, 3, 59, 499-528 data abstraction and reusability, 501 derived classes, 502 is relation, 500, 501 member access, 506-507 protected members, 514, 515 redefining members, 508, 509.
See also Multiple inheritance Inheritance graph building, 594, 595 InhomList class complete, 578 defining, 576, 577 Inhomogeneous lists application with, 574 implementing, 576 terminology for, 575 init() call, 253 Initialization, 33 and constructor calls, 595 of constructors, 269 explicit, 329 of member objects, 301 of objects, 251, 279, 455 references, 223 for virtual base classes, 596, 597 INDEX ■ 813 Initialization list, 325, 329 and arrays of pointers, 365 init() method, 247, 267 Inline functions, 125, 180, 181 definition of, 181 global, 273 and macros, 181, 183 inline keyword, 181 Inline methods, 272, 273 Input errors, 73 fields, 71 formatted, 70 formatted, for numbers, 72 redirecting standard, 130, 131 stream classes for, 58 streams, 9 input() function, 686, 687 insertAfter() method, 577 Insertion methods in sequences, 758 in vector, deque, and list container classes, 759 Insertion sort algorithm, 738 insert() method, 161, 485, 771 of class IndexFile, 652, 653 of class IndexFileSystem, 654, 655 and maps/multimaps, 773 of SortVec derived container class, 758 Instances, class, 51, 251 Instantiation and template definition, 723 of template functions, 733 of templates, 726, 727 Institute of Electrical and Electronic Engineers, 20 Integer promotions, 140, 141 Integers, 17 computing parity of, 712 formatted output of, 62 inputting, 73 types for, 16 Integer types, 21 Integral constants, 23 examples for, 22 Integral numbers displaying, 63 Integral promotion, 709 Integral types, 18, 19 conversion of, to floating-point type, 143 conversion of, to smaller type, 145 and operands for bitwise operators, 707 Integrated software development environment, 7 internal manipulator, 67 Internal static object, 203 International Organization for Standardization, 3 Interpolation search, 738 INT_MAX, 19 INT_MIN, 19 int type, 19, 23 Invalid indexes, 427 invalid_argument class, 620 formatted/unformatted, 74, 75, 391 overloading shift operators for, 428 redirecting, 130, 131 iomanip header file, 48, 65, 66 ios baseclass flags defined in, 386 ios::boolalpha flag, 69 ios class, 59 ios::seekdir type positioning flags, 641 iostream class, 59 iostream header file, 9 iostream library, 59 file stream classes in, 383 isLess() method, 282 islower(c) macro, 129 ISO.
See International Organization for Standardization is_open() method, 389 is relationship, 500, 535, 589 istream class, 47, 59, 61 Iterating lists, 754 Iterator classes, 755 Iterators, 754 types of, 755 J Jump table, 688, 689 K kbhit() function, 132 814 ■ I N D E X Keys and adapter classes, 753 and associative containers, 751 hash, 658 representing pairs of, 773 and sets and multisets, 771 unique and ambiguous, 769 Keyword, 29 L Labels and goto statement, 113 Laborer class, 568 standard assignment for, 573 Layout and program flow, 107 of source files, 11 Left shift operators, 708, 709 left manipulator, 66 Legibility, 11 Length, of container, 763 length_error(*) class, 620 length() method, 51, 481 Less-than symbols, 9 Libraries functions in, 173 Lifetime object, 199 static, 203 LIFO (last-in-first-out) principle, 179, 725, 751 Lights class, 309 limits header file, 48 Linear solution, 658 Line feed, 187 line() function, 11 Linked lists, 462, 463 advantages with, 463 defining, 463 representing, 464 Linker, 7 List class class definition for, 464, 465 of, 490, 491 list container class, 767 constructors of, 757 for deleting objects in, 765 List elements appending/deleting, 462, 465, 467 inserting in middle of inhomogeneous list, 576 inserting , 577 representing, 465, 575 List operations sample program, 766 Lists representing, 465 sorting, inverting, and splicing, 767 Literals, 23 Local objects, 179, 199 Local variables, 33, 34 LOCATE macro, 123 Logarithmic runtimes, 769 Logical bitwise operators, 707 Logical expressions examples for, 90 Logical operators, 90, 141, 412 Logical shifts, 709 logic_error exception classes derived from, 620, 621 long double type, 21, 25 long type, 19 Loop body, 97 Loops, 97 l-value, 233, 421 M Macro definition visibility for, 125 Macros calling with arguments, 123 and case conversion, 129 for character manipulation/classification, 128 defining, 121 in different source files, 124 within header files, 47 and inline functions, 181, 183 redefining, 127 sample program, 120 for screen control, 123, 125 Macros with parameters sample program, 122 main() function, 9, 11, 173, 175 parameters of, 367 structure of, 8 MAKE utility, for module management, 173 INDEX ■ 815 Manipulators, 61 calling, 60 floating-point numbers formatting, 64 and integers formatting, 62 for output in fields, 66 Maps and associative containers, 751 representing, 769 using, 773 Masks, bit, 710, 711 Mathematical rules and expressions, 83 Mathematical standard functions, 40 MathError exception class, 619 math_0_h header file, 190 Matrix, 331 Matrix class, 695 constructor, destructor, and subscript operator for, 695 Member arrays, 332 Member functions, 9, 51, 245 Member initializers, 300, 301 Member objects, 298, 299 constant, 302, 303 initializing, 301 Members, 247 redefining, 508, 509 Member sub-object, 299 Memory allocating, 249 objects in, 251 releasing, 459 union and usage of, 259 Memory address for object of class, 255 merge() method for merging list containers, 767 of SortVec container class, 762 message() function, 227 Methods, 51, 245 calling, 51 of class template, 725 const and non-const versions of, 277, 279 and data members, 505 defining, 248, 249 global functions versus, 283 name lookup for, 507 operator functions as, 415 operators overloadable by, 420 positioning, 643 pure virtual, 566, 567 standard, 278, 279 min() function template, 732 MIN macro, 127 Modifiers signed and unsigned, 19 Modular programming, 7, 249 Modules, 7, 173, 199 MotorHome multiply-derived class, 588, 589, 598 move() method and BitmapN container class, 775 Multidimensional arrays defining, 331 as parameters, 359 sample program, 330 Multimaps, 769 using, 772, 773 Multiple assignments, 87 Multiple indirect base classes, 590, 591 Multiple inheritance, 587-606 constructor calls, 594 initializing virtual base classes, 596 multiple identical base classes, 591 multiple indirect base classes, 590 multiply-derived classes, 588, 589 virtual base classes, 592 Multiple template parameters, 729 Multiply-derived classes, 588, 589 multiset container class, 771 Multisets, 769 declaring, 771 sample, 770 N Names and naming arrays, 351 bit-fields, 715 constructors, 267 declaring, 41 file, 385 macros, 121 operator functions, 415 816 ■ I N D E X source file, 7 valid, 31 of variables, 31 namespace keyword, 209 Namespaces defining, 208, 209 n-dimensional array, 331 Negation, 417 Negative numbers converting, 142 outputting as decimals, 63 Nested if-else statements, 105 Nested namespaces, 209 Nesting exception handling, 616, 617 Nesting loops, 103 , 457 New-line characters, 11, 51 , 454 calling for fundamental types, 455 calling with default constructor, 459 [] , 461 noboolalpha manipulator, 69 Nongraphic characters, 28 noshowpoint(*), 64 noshowpos(*) manipulator, 60 NOT , 91 nouppercase manipulator, 63 NULL, 365, 465, 577 Null character, 25, 26, 327 NULL pointer, 333, 363, 457 Numbers formatted input of, 72 Number symbol (#), 9, 11 Numerical constants, 23 Numeric operations exception handling for, 618, 619 numeric_limits, 786 O Object-oriented programming, 3, 4, 5, 245 Object persistence, 392, 393 Objects, 5, 33 accessing, 281, 760, 761 as arguments, 235 assigning, 253 cleaning up, 271 creating/destroying, 51, 482, 483, 511 creating with dynamic members, 480 declaring, 513 defining, 250, 251 of derived classes, 512 explicit initialization of, 459 initializing, 251, 455 lifetime of, 199 local, 179 member, 298 in memory, 251 passing as arguments, 282 passing by reference, 283 passing by value, 283 pointers to, 254, 255 references returned to, 285 representing pairs of, 773 returning, 284, 285 static, 203 storage classes of, 198 storing, 393 of union WordByte in memory, 258 using, 252.
See also Classes; References Obligatory arguments, 685 Octal constant, 23 Octal numbers outputting, 63 oct manipulator, 63, 73 OFF constant, 309 ofstream class, 383 ON constant, 309 OOP.
See Object-oriented programming open() method, 386, 387 Open mode flags, 387 Open modes, of file, 386 Operands and order of evaluation, 91 symmetry of, 419 Operations file, 380, 381 for sequences, 752 Operator functions, 414, 415, 416 calling, 415, 419 declaration of, 428 defining global, 421 definition of, 428 INDEX ■ 817 global or method, 421 as methods, 415 naming, 415 negation, addition, and subtraction, 417 keyword, 415, 445 Operators bitwise, 706, 707 for classes, 413 and complex declarations, 691 dot, 253 indirection, 232 overloadable, 412 overloading, 413 with pointer variables, 355 reference type, 229 in template functions, 733 unary, 233 Operators for fundamental types binary arithmetic operators, 82-83 increment/decrement operators, 85 logical operators, 90 relational operators, 88, 89 sign operators, 85 unary arithmetic operators, 84 Optional arguments, 685, 687 OR operator, 91 ostream class, 47, 59, 61 out constant, 309 out_of_range(*), 620 Output redirecting standard, 130, 131 stream classes for, 58 streams, 9 overflow_error(*) class, 620 Overloaded operators rules for, 412 using, 418, 419 Overloading assignment operator, 489 functions, 184, 185 operators, 413, 423 and redefinition, 509 shift operators for I/O, 428, 429 subscript operators, 426, 427, 485 P Parameters, 175 declaring, 357 multidimensional arrays as, 359 pointers as, 234 read-only pointers as, 361 Parentheses in syntax description, 33 Parity bit computation, 713 parity() function, 713 PassCar versions of, 510, 511 PassCar class virtual method table for, 550 PassCar derived class, 504 Passing arguments to function templates, 730, 731 Passing by reference, 179, 225, 283 Passing by value, 179, 225, 283 Persistence object, 392, 393 of polymorphic objects, 648, 650 Pixels (picture element), 775 Pointer arithmetic, 354, 355 Pointer arrays generating dynamically, 683 Pointer assignment effect of, 534 Pointers, 233, 285, 729, 755 to abstract classes, 570, 571 as arguments, 235 array elements interrelated with, 352 arrays of, 364 comparing, 355 to const objects, 361 defining, 230 defining arrays of, 365 to functions, 688, 689 moving in array, 355 NULL, 333 to objects, 254, 255 as parameters, 234 parameters declared as, 357 read-only, 360 returning, 362, 363 818 ■ I N D E X sample program, 350, 352 subtracting, 355 typeless, 351 use of, instead of indices, 359 Pointers to pointers, 682, 683 Pointer types, 231 Pointer variables, 231, 235, 683 addressing with, 353 and arrays, 351 Polymorphic interfaces, 571 Polymorphic objects persistence of, 648, 650 storing, 649 Polymorphism, 3, 543-564 concept of, 544, 545 destroying dynamically allocated objects, 548, 549 dynamic casts, 552, 553 virtual methods, 546, 547 virtual method table, 550, 551 pop_back() method for deleting objects in container classes, 765 popFront() method, 465, 467 pop() method, 765 Positioning flags, 641 Positioning methods, 643 Positive numbers converting to, 142 Postfix increment, 430 Postfix notation, 85 effects of, 84 Precedence of arithmetic operators, 84 and arithmetic type conversions, 707 of Boolean operators, 91 for cast operator (type), 147 for comma operator, 101 for indirection operator, 233 operator, 85 for operators with pointer variables, 355 of relational operators, 88, 89 precision() method, 65 Prefixes, 31 Prefix increment, 430 Prefix notation, 85 effects of, 84 Preprocessor, 9 Preprocessor directives, 11 Primary file, within index file, 653, 655 printf() function, 685 Priority queues, 753 testing, 764 priority_queue template, 753 Private data members accessing, 275 Private members, 245, 247, 249, 503, 507 Procedures, 5 Program scope object defined with, 199 Projects, 249 Properties, 5 protected constructors, 569 Protected declarations, 515 Protected members, 515 Prototype, 175, 177 public base classes is relationship established by, 589 Public interface, of class, 247 Public members, 245, 247 access to, in base class, 503 Public methods, 51 Pure virtual methods, 566, 567.
Resistant mistakes program with, 76 resize() method and container classes, 763 Result class, 303, 424, 425 constructors for, 298, 299 new  of, 302 with static members, 304 with static methods, 306 retrieve() method, 651 of IndexFileSystem class, 654, 655 Return address, 181 return statement, 9, 177 Return values, 41, 285 Reusability, 5, 501 reverse() function, 357 reverse() method, 767 rfind() method, 163 Right shift operators, 708, 709 Round brackets, 33 Routers, 779 820 ■ I N D E X Row class defining, 694, 695 RTTI.
See Run Time Type Information Runtime behavior of container classes, 759 runtime_error, 621 Run time errors, 621 avoiding, 43, 267 exception classes derived from, 620, 621 Run Time Type Information, 552 R-values, 233 S Safe class, 514, 515 SavAcc class defining, 648, 649 scientific manipulator, 65 Scope, 199 Scope resolution operator, 209, 211, 249 Screen control macros, 123, 125 Scrolling string output, 334.
Semicolon, 9, 103 Sequences and header files, 752 operations for, 752 representing, 753 Sequential containers (or sequences), 750, 751 Sequential file access, 381 set container class, 771.
Sets associative containers within, 751 declaring, 771 representing, 769 sample, 770 setTime() method, 282 setw() manipulator, 66 Shape type, 309 Sheltered members access to, 515 Shift operators, 708 short type, 19 showpos manipulator calling, 60 Side effects avoiding, 87 of macros, 125 Sieve of Eratosthenes, 334 signal_0_h header file, 48 Signatures constructor, 267, 269 function, 185 signed char type, 19, 142 Signed integers converting, 142 signed keyword, 19 Signed type conversion of, to larger integral type, 143 Sign extension, 143 Sign operators, 85 Simple assignments, 87 Single characters meaning of, 26 Single quotes character constants within, 25 size() method and length of container, 763 and maps/multimaps, 773 and number of objects in container, 771 sizeof operator, 21 sort() method list container sorted by call to, 767 SortVec container class merge() method of, 762 search() method of, 760 using, 756 Source code, 7 Source files, 7, 249 layout of, 11 name, 7 INDEX ■ 821 Spaces, 11 Special characters, 28 Special objects, of base class, 531 splice() function, 466, 467 Splice operations, 767 sqrt() function, 40, 53 srand() function, 45 sstream class, 48 Stack class template, 724 explicit instantiation for, 737 with two template parameters, 728 Stack content after calling function, 178 Stacks, 179 fixed/varying arguments on, 684 and recursive functions, 187 as sequential containers, 751 testing, 726 Standard copy constructor, 487 Standard exception classes hierarchy of, 621 using, 620 Standard exception handling for streams, 647 Standard input, 59 Standard methods, 279 sample program, 278 Standard output, 59 Standard settings, 65 Star character, 233 State flags, 645, 647 Statements, 9 Static arrays, 325 Static binding, 551 Static data members, 304, 305 accessing, 306 declaring, 305 definition and initialization, 305 and encapsulation, 307 Static data structures, 463 Static functions, 207 static keyword, 305 static_cast, 537 Static lifetime, 199, 203 Static member functions, 307 Static objects, 203 static storage class, 202, 203, 207 std standard namespace, 9, 209 Storage classes, 199 of functions, 206 Storage class specifiers, 198 strcat() function and return pointers, 363 strcmp() function, 327 index version of, 368 strcpy() function, 327 pointer versions of, 358 and return pointers, 363 Stream access errors, 651 Stream class shift operators, 229 streambuf class, 48 Streams, 9 discovering/changing status of, 645 standard, 59 standard exception handling for, 647 String assignments, 155, 157 string class, 153, 251, 413 C strings and, 327 defining, 155 objects of, 51 sample assignments of, 228 sample program, 50, 154 String constants, 23, 25 String literal internal representation of, 24 Strings characters accessed in, 164 comparing, 158 concatenating, 156, 157 escape sequences used in, 29 initializing, 154, 155 inserting and erasing in, 160, 161 numbers converted to, 288 output of, 68, 69 searching and replacing in, 162, 163 stringstream class, 288 strlen() function, 327, 359 Stroustrup, Bjarne, 3 strstr() function sample program, 362, 363 struct keyword, 257 structs sample program, 256 822 ■ I N D E X Style, 11 Sub-object lattice, 595 Subroutines, 5, 181 Subscript, 323 Subscript operators, 165, 427 and access via indices, 761 bits referenced by, 777 in Matrix class, 695 overloading, 426, 427 read and write access using, 485 Substrings erasing, 160 replacing, 162 Subtraction, 355, 417 implementing as method, 282 swap() function, 235 Swapping, 455 switch statement, 111 else-if chains contrasted with, 111 structogram for, 110 Symbolic constants, 121 sync() method, 70 Syntax, 249 brackets in descriptions, 612 for defining variables, 33 errors, 7 T Tabs, 11 tan() function, 40 tellg() method, 641 TelList class, 332, 333 methods implemented for, 336, 337 tellp() method, 641 Template arguments restrictions on, 731 Template function definition, 733 Template functions motivation for, 733 Template parameters multiple, 729 restrictions on, 729 Templates, 3, 721-748 advantages of, 723 arguments, 730, 731 in Cplus_plus standard library, 723 default arguments of, 734, 735 defining, 724, 725 defining with multiple parameters, 729 function and class, 723 instantiating, 726, 727, 736, 737 parameters, 728, 729 specialization, 732-733 terminate() function, 613 Testing characters, 129 Text mode, 386 and nesting loops, 103 Text editor, 7 this pointer sample class DayTime, 280 using, 281 Throwing exceptions, 614 throw statement, 611 using, 610 timediff() function, 207 time() function, 167 time_t type, 261 tm struct, 260 Tokens, 11 Tone and nesting loops, 103 top() method, 761 toupper() macro, 129 Traditional procedural programming, 4, 5 Translation unit, 199 true keyword, 23 trunc open mode, 386 Truth table for logical operators, 90 try block, 615 nested, 616, 617 syntax of, 612, 613 Two-dimensional arrays initialization list of, 331 parameter declaration for, 359 Type casting, 351 Type conversion for classes, 441-452 ambiguities of type conversions, 446-447 conversion constructors, 442-443 conversion functions, 444-445 INDEX ■ 823 Type conversions, 43, 146 ambiguities of, 446, 447 in assignments, 145, 532, 533 explicit, 147, 536, 537 failure, 447 implicit, 140, 144, 147, 531 standard, 445 usual arithmetic, 141, 142 typedef keyword, 693 Type hierarchy, 140 Typeless pointers, 351 Typenames defining, 692 Types, 611 platform dependent, 693 pointer, 231 U Unary arithmetic operators, 84, 85 Unary operators, 83, 233 underflow_error class, 620 #undef directive, 127 Underscores and internal names, 31 Unicode, 17 Union, 258, 259 defined, 259 Unique keys, 769 usetf() method, 60, 61 unsigned char type, 19 unsigned keyword, 19 unsigned short, 19 Unsigned types, 143 Unsigned value, 45 Unwinding the stack, 615 Upcasting, 536, 537, 553 User Network Interface, 715 using declaration, 211 using directive, 211 using keyword, 9, 49, 210 Usual arithmetic type conversions, 141, 145 performing, 142 V va_arg() macro arguments of, 687 valarray class, 48 Variables defining, 33 defining in if statements, 105 names of, 31 pointer, 683 sample program, 32 Variable type, 77 Vector, 323 vector container class, 755 constructors of, 757 methods for deleting objects in, 765 Vectors iterating, 754 Virtual assignments using, 573 Virtual base classes, 592, 593 constructor calls in, 597 initializing, 596, 597 Virtual destructors declaring, 549 virtual keyword, 593 Virtual methods, 546, 547 calling, 544, 545 declaring, 547 pure, 566, 567 redefining, 547 Virtual method tables, 550, 551 Virtual operator functions, 573 VMT.
See Virtual method tables void type, 21 for functions, 44, 45 void* type pointer, 351 volatile keyword, 34, 36 W Warnings, 7 wchar_t type, 17, 19 what() method, 621 824 ■ I N D E X what() virtual method, 647 while statement structogram for, 96 structogram for break within, 112 syntax for, 97 Whitespace characters, 11 Width bit-fields, 715 width() method, 67, 491 Wordbyte union defining/using, 258 Write access open mode for, 638 write_at() method, 642 WriteError type exception, 651 write() method, 391, 392, 393 of classes DepAcc and SavAcc, 648, 649 Write operation, 381 Writing blocks of records, 390 characters, 75 X XOR operator, 707 Z Zero extension, 143 INDEX ■ 825.