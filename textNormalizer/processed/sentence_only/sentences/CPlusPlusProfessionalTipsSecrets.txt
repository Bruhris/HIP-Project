Cplus_plus Complete Tips & Secrets for Professionals Complete Cplus_plus Tips & Secrets for Professionals 500+ pages of professional hints and tricks GoalKicker_0_com Free Programming Books Disclaimer This is an unocial free book created for educational purposes and is not aliated with ocial Cplus_plus group(s) or company(s).
All trademarks and registered trademarks are the property of their respective owners Contents About _0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0_.
Covariant result version of the base example, static type checking.
Covariant smart pointer result (automated cleanup).
Chapter 146: Arithmitic Metaprogramming _0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0_.
Images may be copyright of their respective owners unless otherwise speciﬁed This book creation is not aﬃliated with Cplus_plus group(s) nor Stack Overﬂow, and all terms and trademarks belong to their respective company owners The information presented in this book is not guaranteed to be correct nor accurate, use at your own risk Send feedback and corrections to web@petercv_0_com Complete Cplus_plus Tips & Secrets for Professionals 1 Chapter 1: Getting started with Cplus_plus Version Standard Release Date Cplus_plus98 ISO/IEC 14882:1998 1998-09-01 Cplus_plus03 ISO/IEC 14882:2003 2003-10-16 Cplus_plus11 ISO/IEC 14882:2011 2011-09-01 Cplus_plus14 ISO/IEC 14882:2014 2014-12-15 Cplus_plus17 TBD 2017-01-01 Cplus_plus20 TBD 2020-01-01 Section 1_0_1: Hello.
Analysis Let's examine each part of this code in detail: # <iostream> is a preprocessor directive that includes the content of the standard Cplus_plus header ﬁle iostream.
These deﬁnitions are included in the std namespace, explained below.
The standard input/output (I/O) streams provide ways for programs to get input from and output to an external system minus_minus usually the terminal.
By convention, the main  is called upon execution of the program.
There must be only one main  in a Cplus_plus program, and it must always return a number of the int type.
Here, the int is what is called the 's return type.
The value returned by the main  is an exit code.
By convention, a program exit code of 0 or EXIT_SUCCESS is interpreted as success by a system that executes the program.
Any other return code is associated with an error.
If no return statement is present, the main  (and thus, the program itself) returns 0 by default.
In this example, we don't need to explicitly write return 0;.
All other functions, except those that return the void type, must explicitly return a value according to their return type, or else must not return at all.
Here, we use :: to show we want to use  from the std namespace.
For more information refer to Scope Resolution Operator - Microsoft Documentation.
The standard library deﬁnes the << operator to perform data insertion for certain data types into output streams.
This allows stream insertions to be chained: std:: << "Foo" << " Bar"; prints "FooBar" to the console.
Inserting a manipulator into a stream changes the state of the stream.
The stream manipulator std::endl does two things: ﬁrst it inserts the end-of-line character and then it ﬂushes the stream buﬀer to force the text to show up on the console.
This ensures that the data inserted into the stream actually appear on your console.
The semicolon (;) notiﬁes the compiler that a statement has ended.
All Cplus_plus statements and class deﬁnitions require an ending/terminating semicolon.
Section 1_0_2: Comments A comment is a way to put arbitrary text inside source code without having the Cplus_plus compiler interpret it with any functional meaning.
Comments are used to give insight into the design or method of a program.
There are two types of comments in Cplus_plus: Single-Line Comments The double forward-slash sequence // will mark all text until a newline as a comment:.
C-Style/Block Comments The sequence /* is used to declare the start of the comment block and the sequence */ is used to declare the end of comment.
All text between the start and end sequences is interpreted as a comment, even if the text is otherwise valid Cplus_plus syntax.
These are sometimes called "C-style" comments, as this comment syntax is inherited from Cplus_plus's predecessor language, C: { /*.
Block comments can also start and end within a single line.
For example: void SomeFunction(/* argument 1 */ int a, /* argument 2 */ int b); Importance of Comments As with all programming languages, comments provide several beneﬁts: Explicit documentation of code to make it easier to read/maintain Explanation of the purpose and functionality of code Details on the history or reasoning behind the code Placement of copyright/licenses, project notes, special thanks, contributor credits, etc.
However, comments also have their downsides: They must be maintained to reﬂect any changes in the code Excessive comments tend to make the code less readable The need for comments can be reduced by writing clear, self-documenting code.
A simple example is the use of explanatory names for variables, functions, and types.
Factoring out logically related tasks into discrete functions goes hand-in-hand with this.
Comment markers used to disable code Complete Cplus_plus Tips & Secrets for Professionals 4 During development, comments can also be used to quickly disable portions of code without deleting it.
This is often useful for testing or debugging purposes, but is not good style for anything other than temporary edits.
This is often referred to as "commenting out".
Similarly, keeping old versions of a piece of code in a comment for reference purposes is frowned upon, as it clutters ﬁles while oﬀering little value compared to exploring the code's history via a versioning system.
Section 1_0_3: The standard Cplus_plus compilation process Executable Cplus_plus program code is usually produced by a compiler.
Using a compiler to translate code is called compilation.
Cplus_plus inherits the form of its compilation process from its "parent" language, C.
Below is a list showing the four major steps of compilation in Cplus_plus: 1.
The Cplus_plus preprocessor copies the contents of any included header ﬁles into the source code ﬁle, generates macro code, and replaces symbolic constants deﬁned using #deﬁne with their values.
The expanded source code ﬁle produced by the Cplus_plus preprocessor is compiled into assembly language appropriate for the platform.
The assembler code generated by the compiler is assembled into appropriate object code for the platform.
The object code ﬁle generated by the assembler is linked together with the object code ﬁles for any library functions used to produce an executable ﬁle.
Note: some compiled code is linked together, but not to create a ﬁnal program.
Usually, this "linked" code can also be packaged into a format that can be used by other programs.
This "bundle of packaged, usable code" is what Cplus_plus programmers refer to as a library.
Many Cplus_plus compilers may also merge or un-merge certain parts of the compilation process for ease or for additional analysis.
Many Cplus_plus programmers will use diﬀerent tools, but all of the tools will generally follow this generalized process when they are involved in the production of a program.
The link below extends this discussion and provides a nice graphic to help.
Functions can accept arguments or values and return a single value (or not).
To use a function, a function call is used on argument values and the use of the function call itself is replaced with its return value.
Every function has a type signature minus_minus the types of its arguments and the type of its return type.
Functions are inspired by the concepts of the procedure and the mathematical function.
Note: Cplus_plus functions are essentially procedures and do not follow the exact deﬁnition or rules of mathematical functions.
Functions are often meant to perform a speciﬁc task.
A function must be declared and deﬁned before it is called elsewhere in a program.
Note: popular function deﬁnitions may be hidden in other included ﬁles (often for convenience and reuse across many ﬁles).
This is a common use of header ﬁles.
Complete Cplus_plus Tips & Secrets for Professionals 5 Function Declaration A function declaration is declares the existence of a function with its name and type signature to the compiler.
The syntax is as the following: In the example above, the int add2(int i) function declares the following to the compiler: The return type is int.
The name of the function is add2.
The number of arguments to the function is 1: The ﬁrst argument is of the type int.
The ﬁrst argument will be referred to in the function's contents by the name i.
The argument name is optional; the declaration for the function could also be the following: int add2(int); // Omitting the function arguments' name is also permitted.
Per the one-deﬁnition rule, a function with a certain type signature can only be declared or deﬁned once in an.
If a function returns nothing, its return type is written as void.
If it takes no parameters, the parameter list should be empty.
Function Call A function can be called after it has been declared.
For example, the following program calls add2 with the value of.
Here, 2(2) is the syntax for a function call.
Function Deﬁnition A function deﬁnition* is similar to a declaration, except it also contains the code that is executed when the function is called within its body.
Complete Cplus_plus Tips & Secrets for Professionals 6.
Both functions are called by the same name 2, but the actual function that is called depends directly on the amount and type of the parameters in the call.
In most cases, the Cplus_plus compiler can compute which function to call.
In some cases, the type must be explicitly stated.
Default Parameters Default values for function parameters can only be speciﬁed in function declarations.
Default arguments must be placed in the latter arguments of the function.
The most common example is that of operators.
Certain special character sequences that will be reduced to function calls by the compiler, such as _0_, +, -, *, %, and << and many more.
These special characters are normally associated with non-programming usage or are used for aesthetics (e_0_g.
Cplus_plus handles these character sequences with  special syntax; but, in essence, each occurrence of an operator is reduced to  function call.
For example, the following Cplus_plus expression: 3+3 Complete Cplus_plus Tips & Secrets for Professionals.
All operator function names start with operator.
While in Cplus_plus's immediate predecessor, C, operator function names cannot be assigned diﬀerent meanings by providing additional deﬁnitions with diﬀerent type signatures, in Cplus_plus, this is valid.
Section 1_0_5: Visibility of function prototypes and declarations In Cplus_plus, code must be declared or deﬁned before usage.
For example, the following produces  compile time error:.
The prototype must specify the return type (void), the name of the function (foo), and the argument list variable types (int), but the names of the arguments are NOT required.
One common way to integrate this into the organization of source ﬁles is to make  header ﬁle containing all of the prototype declarations: // foo_0_h.
These can be trickier to resolve as the compiler won't report the error until the ﬁnal linking stage, and it doesn't know which  to jump to in the code to show the error.
Section 1_0_6: Preprocessor The preprocessor is an important part of the compiler.
It edits the source code, cutting some bits out, changing others, and adding other things.
In source ﬁles, we can  preprocessor directives.
These directives tells the preprocessor to perform speciﬁc actions.
A directive starts with  # on  new.
Example: #define ZERO 0 The ﬁrst preprocessor directive you will meet is probably the # <something>.
The C language, which also uses the preprocessor, does not have as many header ﬁles as the Cplus_plus language, but in Cplus_plus you can use all the C header ﬁles.
The next important directive is probably the #define  something_else directive.
This tells the preprocessor that as it goes along the ﬁle, it should replace every occurrence of with something_else.
It can also make things similar to functions, but that probably counts as advanced Cplus_plus.
The something_else is not needed, but if you deﬁne  as nothing, then outside preprocessor directives, all occurrences of  will vanish.
This actually is useful, because of the #if,#else and #ifdef directives.
The format for these would be the following: #if ==true //code #else //more code.
Chapter 2: Templates < -parameter-list > declaration export  < -parameter-list > declaration /* until Cplus_plus11 */ <> declaration declaration extern  declaration /* since Cplus_plus11 */.
A  is  piece of code with some free parameters that will become  concrete class, function, or variable when all parameters are speciﬁed.
Parameters can be types, values, or themselves templates.
A well-known  is std::vector, which becomes  concrete container type when the element type is speciﬁed, e_0_g_0_, std::vector<int>.
Section 2_0_1: Basic Class Template The basic idea of  class  is that the  parameter gets substituted by  type at compile time.
The result is that the same class can be reused for multiple types.
The user speciﬁes which type will be used when variable of the class is declared.
Three examples of this are shown in main(): # <iostream> using std::cout;.
Section 2_0_2: Function Templates Templating can also be applied to functions (as well as the more traditional structures) with the same eﬀect.
In both these case the  argument  used to replace the types of the parameters; the result works just like a normal Cplus_plus function (if the parameters don't match the  type the compiler applies the standard conversions).
One additional property of  functions (unlike  classes)  that the compiler can infer the parameters based on the parameters passed to the function.
In this case the parameters are two different types.
The compiler  unable to deduce the type of T because there are contradictions.
As a result this  a compile time error.
This feature allows us to simplify code when we combine  structures and functions.
There  a common pattern in the standard library that allows us to make  structure X using a helper function make_X().
Create object explicitly defining the types Create object using the types of the paramters.
In this code both 1 and 2 are the same type.
Note: This  not designed to shorten the code.
This  designed to make the code more robust.
It allows the types to be changed by changing the code in a single place rather than in multiple locations.
Section 2_0_3: Variadic  data structures Version≥Cplus_plus14 It  often useful to deﬁne classes or structures that have a variable number and type of data members which are deﬁned at compile time.
The canonical example  std::tuple, but sometimes  it  necessary to deﬁne your own custom structures.
Here  an example that deﬁnes the structure using compounding (rather than inheritance as with std::tuple.
Start with the general (empty) deﬁnition, which also serves as the base-case for recrusion termination in the later specialisation: <typename _0__0_.
T> struct DataStructure {}; This already allows us to deﬁne an empty structure, <> data, albeit that isn't very useful yet.
Next comes the recursive case specialisation: <typename T, typename _0__0_.
Rest> struct <T, Rest _0__0__0_> {.
First, note that this  a specialisation whose requirement  that at least one variadic parameter (namely T above) exists, whilst not caring about the speciﬁc makeup of the pack Rest.
Knowing that T exists allows the deﬁnition of its data member, first.
The rest of the data  recursively packaged as <Rest _0__0_.
The constructor initiates both of those members, including a recursive constructor call to the rest member.
To understand this better, we can work through an example: suppose you have a declaration <int, float> data.
The declaration ﬁrst matches against the specialisation, yielding a structure with int first and <float> rest data members.
The rest deﬁnition again matches this specialisation, creating its own float first and <> rest members.
Finally this last rest matches against the base-case deﬁntion, producing an empty structure.
So we  a get method to it (only needed in the specialisation as the base-case structure has no data to get): <typename T, typename _0__0_.
Rest> struct <T, Rest _0__0__0_> { _0__0_.
As you can see this get member function  itself templated - this time on the index of the member that  needed (so usage can be things like data_0_get<1>(), similar to std::tuple).
The actual work  done by a static function in a helper class,.
The reason we can't deﬁne the required functionality directly in 's get because (as we will shortly see) we would need to specialise on  - but it isn't possible to specialise a template member function without specialising the containing class template.
Note also the use of a Cplus_plus14-style auto here makes our lives signiﬁcantly simpler as otherwise we would need quite a complicated expression for the return type.
So on to the helper class.
This time we will need an empty forward declaration and two specialisations.
First the declaration: template<size_t , typename T> struct ; Now the base-case (when ==0).
In this case we just return the first member:.
In the ﬁrst case, the type T is deduced as reference to X (X&), and the type of t is lvalue reference to X, while in the second case the type of T is deduced as X and the type of t as rvalue reference to X (X&&).
Note: It is worth noticing that in the ﬁrst case, decltype(t) is the same as T, but not in the second.
In order to perfectly  t to another function ,whether it is an lvalue or rvalue reference, one must use std::: template <typename T>.
Partial template specialization is only available for template class/structs: // Common case:.
As shown above, partial template specializations may introduce completely diﬀerent sets of data and function members.
When a partially specialized template is instantiated, the most suitable specialization is selected.
For example, let's deﬁne a template and two partial specializations: template<typename , typename U, typename V>.
Section 2_0_6: Template Specialization You can deﬁne implementation for speciﬁc instantiations of  template class/method.
For example if you have: template <typename > ( ) { /* Some generic implementation */ }.
Section 2_0_7: Alias Version≥Cplus_plus11.
Alias templates cannot be specialized.
However, that functionality can be obtained indirectly by having them refer to  nested type in  struct: <typename > struct  { typedef * type; };.
Section 2_0_8: Explicit instantiation An explicit instantiation deﬁnition creates and declares  concrete class, function, or variable from  , without using it just yet.
An explicit instantiation can be referenced from other translation units.
This can be used to avoid deﬁning   in  header ﬁle, if it will only be instantiated with  ﬁnite set of arguments.
Because print_string<char> and print_string<wchar_t> are explicitly instantiated in print_string_0_cpp, the linker will be able to ﬁnd them even though the print_string  is not deﬁned in the header.
If these explicit instantiation declarations were not present,  linker error would likely occur.
See Why can templates only be implemented in the header ﬁle.
Version≥Cplus_plus11 If an explicit instantiation deﬁnition is preceded by the extern keyword, it becomes an explicit instantiation declaration instead.
The presence of an explicit instantiation declaration for  given specialization prevents the implicit instantiation of the given specialization within the current translation unit.
Instead,  reference to that specialization that would otherwise cause an implicit instantiation can refer to an explicit instantiation deﬁnition in the same or another TU.
Section 2_0_9: Non-type  parameter Apart from types as   parameter we are allowed to declare values of constant expressions meeting one of the following criteria: integral or enumeration type, to object or  to function, lvalue reference to object or lvalue reference to function, to member, std::nullptr_t.
Like all  parameters, non-type  parameters can be explicitly speciﬁed, defaulted, or derived implicitly via Template Argument Deduction.
Example of non-type  parameter usage: Complete Cplus_plus Tips & Secrets for Professionals 18.
Section 2_0_10: Declaring non-  arguments with auto Prior to Cplus_plus17, when writing   non- parameter, you had to specify its  ﬁrst.
So  common pattern became writing something like: <class ,  N>.
The solution is to simplify this idiom and simply allow auto: Version≥Cplus_plus17.
A nice motivating example can come from trying to combine the empty base optimization with  custom deleter for unique_ptr.
Diﬀerent C API deleters have diﬀerent return types, but we don' care - we just want something to work for any function: <auto DeleteFn> struct FunctionDeleter { <class >.
This is what parameters are created for.
Very simple   parameter examples: <class > struct 1 { }; <class >.
Section 2_0_12: Default  parameter Just like in  of the function arguments,  parameters can have their default values.
All parameters with  default  have to be declared at the end of the  parameter list.
The basic idea is that the  parameters with default  can be omitted while  instantiation.
Simple example of default  parameter  usage: <class , size_t  = 10> struct  {.
Chapter 3: Metaprogramming In Cplus_plus Metaprogramming refers to the use of macros or templates to generate code at compile-time.
In general, macros are frowned upon in this role and templates are preferred, although they are not as generic.
Template metaprogramming often makes use of compile-time computations, whether via templates or constexpr functions, to achieve its goals of generating code, however compile-time computations are not metaprogramming per se.
Section 3_0_1: Calculating Factorials Factorials can be computed at compile-time using  metaprogramming techniques.
In the above code, we evaluate the  metafunction by instantiating the  with the parameters we want to pass, and using :: to get the result of the evaluation.
Complete Cplus_plus Tips & Secrets for Professionals 21 The metafunction itself relies on recursively instantiating the same metafunction with smaller values.
The <0> specialization represents the terminating condition.
Template metaprogramming has most of the restrictions of a functional programming language, so recursion is the primary "looping" construct.
Since  metafunctions execute at compile time, their results can be used in contexts that require compiletime values.
For example: [<5>::]; Automatic arrays must have a compile-time deﬁned size.
And the result of a metafunction is a compile-time constant, so it can be used here.
Limitation: Most of the compilers won't allow recursion depth beyond a limit.
For example, gplus_plus compiler by default limits recursion depeth to 256 levels.
In case of gplus_plus, programmer can set recursion depth using -ftemplate-depthX option.
Version≥Cplus_plus11 Since Cplus_plus11, the std:: template can be used for this kind of template computation: # <iostream>.
Version≥Cplus_plus14 Since Cplus_plus14, many restrictions for constexpr functions have been dropped and they can now be written much more conveniently:.
Section 3_0_2: Iterating over a parameter pack Often, we need to perform an operation over every element in a variadic template parameter pack.
There are many ways to do this, and the solutions get easier to read and write with Cplus_plus17.
Suppose we simply want to print every element in a pack.
The simplest solution is to recurse: Version≥Cplus_plus11.
Version≥Cplus_plus17 With Cplus_plus17, we get two powerful new  in our arsenal for solving this problem.
The ﬁrst is a fold-expression:.
Since Cplus_plus14, the standard provides the class template template <class , _0__0_.
Ints> class ; template <std::size_t_0__0_.
While this comes standard in Cplus_plus14, this can be implemented using Cplus_plus11.
Section 3_0_4: Tag Dispatching A simple way of selecting between functions at compile time is to dispatch a function to an overloaded pair of functions that take a tag as one (usually the last) argument.
For example, to implement std::advance(), we can dispatch on the iterator category: namespace details {.
The std::XY_iterator_tag arguments of the overloaded details::advance functions are unused function parameters.
The actual implementation does not matter (actually  is completely empty).
Their only purpose is to allow the compiler to select an overload based on which tag class details::advance is called with.
In this example, advance uses the <>::iterator_category metafunction which returns one of the iterator_tag classes, depending on the actual type of Iter.
A default-constructed object of the iterator_category<Iter>::type then lets the compiler select one of the diﬀerent overloads of details::advance.
Note: while Cplus_plus17's if constexpr may simplify the implementation of advance in particular,  is not suitable for open implementations unlike tag dispatching.
Complete Cplus_plus Tips & Secrets for Professionals 25 Section 3_0_5: Detect Whether Expression is Valid It is possible to detect whether an operator or function can be called on a type.
To test if a  has an overload of.
For detecting if an operator, such as operator< is deﬁned, the syntax is almost the same: <,  = void> struct : std::false_type {}; < >.
Section 3_0_7: Manual distinction of types when given any type When implementing SFINAE using std::enable_if,  is often useful to have access to helper templates that determines if a given type  matches a set of criteria.
To help us with that, the standard already provides two types analog to true and false which are std::true_type and std::false_type.
The following example show how to detect if a type  is a pointer or not, the is_pointer  mimic the behavior of the standard std::is_pointer helper: <typename > struct : std::false_type {}; <typename >.
The ﬁrst declaration of  is the default case, and inherits from std::false_type.
The default case should always inherit from std::false_type since  is analogous to a "false condition".
The second declaration specialize the   for pointer * without caring about what  is really.
This version inherits from std::true_type.
The third declaration (the real one) simply remove any unnecessary information from  (in this case we remove const and volatile qualiﬁers) and then fall backs to one of the two previous declarations.
Since is_pointer<> is a , to access its value you need to either: Use ::value, e_0_g.
Complete Cplus_plus Tips & Secrets for Professionals 27 It is a good habit to provides "helper helper templates" that let you directly access the value: <typename > constexpr bool  = <>::value; Version≥Cplus_plus17.
With Cplus_plus11 and higher calculations at compile time can  much easier.
For example calculating the  of a given number at compile time will  following: <typename >.
Keyword constexpr is responsible for calculating function in compilation time, then and only then, when all the requirements for this will  met (see more at constexpr keyword reference) for example all the arguments must known at compile time.
Note: In Cplus_plus11 constexpr function must compose only from one return statement.
Advantages: Comparing this to the standard way of compile time calculation, this method is also useful for runtime calculations.
It means, that if the arguments of the function are not known at the compilation time (e_0_g.
Version>Cplus_plus11 It's possible to write  generic function (for example min) which accepts various numerical types and arbitrary argument count by  meta-programming.
This function declares  min for two arguments and recursively for more.
Chapter 4: Iterators Section 4_0_1: Overview Iterators are Positions Iterators are  means of navigating and operating on  sequence of elements and are  generalized extension of pointers.
Conceptually it is important to remember that iterators are positions, not elements.
For example, take the following sequence: A B C The sequence contains three elements and four positions +minus_minus-+minus_minus-+minus_minus-+minus_minus-+ | A | B | C | | +minus_minus-+minus_minus-+minus_minus-+minus_minus-+ Elements are things within  sequence.
Positions are places where meaningful operations can happen to the sequence.
For example, one inserts into  position, before or after element A, not into an element.
Even deletion of an element (erase(A)) is done by ﬁrst ﬁnding its position, then deleting it.
From Iterators to Values To convert from  position to  , an iterator is dereferenced: auto  = my_vector_0_begin(); // position auto  = *; //.
In all the sequences and containers found in the Cplus_plus standard library, begin() will return an iterator to the ﬁrst position, and end() will return an iterator to one past the last position (not the last position_0_).
Consequently, the names of these iterators in algorithms are oftentimes labelled first and last: +minus_minus-+minus_minus-+minus_minus-+minus_minus-+ | A | B | C | | +minus_minus-+minus_minus-+minus_minus-+minus_minus-+.
Some situations where this view is particularly useful are: insert operations will insert elements into the position indicated by the iterator, erase operations will return an iterator corresponding to the same position as the one passed in, an iterator and its corresponding reverse iterator are located in the same _0_position between elements Invalid Iterators An iterator becomes invalidated if (say, in the course of an operation) its position is no longer  part of  sequence.
An invalidated iterator cannot be dereferenced until it has been reassigned to  valid position.
Each algorithm is diﬀerent in the way they treat (and invalidate) iterators.
Navigating with Iterators As we know, iterators are for navigating sequences.
In order to do that an iterator must migrate its position throughout the sequence.
Iterators can advance forward in the sequence and some can advance backwards:.
Note, second argument of std::distance should be reachable from the ﬁrst one(or, in other words  should be less or equal than second).
Even though you can perform arithmetic operators with iterators, not all operations are deﬁned for all types of iterators.
So it is recommended to use special functions in case you are not sure what is iterator type (for example, in  template function accepting iterator).
Iterator Concepts The Cplus_plus standard describes several diﬀerent iterator concepts.
These are grouped according to how they behave in the sequences they refer to.
If you know the concept an iterator models (behaves like), you can be assured of the behavior of that iterator regardless of the sequence to which it belongs.
They are often described in order from the most to least restrictive (because the next iterator concept is  step better than its predecessor): Input Iterators : Can be dereferenced only once per position.
Can only advance, and only one position at time.
Forward Iterators : An input iterator that can be dereferenced any number of times.
Bidirectional Iterators : A forward iterator that can also advance backwards one position at  time.
Random Access Iterators : A bidirectional iterator that can advance forwards or backwards any number of positions at  time.
Contiguous Iterators (since Cplus_plus17) : A random access iterator that guaranties that underlying data is contiguous in memory.
Algorithms can vary depending on the concept modeled by the iterators they are given.
For example, although random_shuffle can be implemented for forward iterators,  more eﬃcient variant that requires random access iterators could be provided.
Iterator traits Iterator traits provide uniform interface to the properties of iterators.
They allow you to retrieve value, diﬀerence, pointer, reference types and also category of iterator: Complete Cplus_plus Tips & Secrets for Professionals.
Section 4_0_2: Vector Iterator begin returns an iterator to the ﬁrst element in the sequence container.
If the  object is const, both begin and end return  const_iterator.
If you want  const_iterator to be returned even if your  is not const, you can use cbegin and cend.
Complete Cplus_plus Tips & Secrets for Professionals 32.
Output: => 200 => 100 => 300 Section 4_0_4: Reverse Iterators If we want to iterate backwards through  list or  we can use  reverse_iterator.
A reverse iterator is made from  bidirectional, or random access iterator which  keeps as  member which can be accessed through base().
To iterate backwards use rbegin() and rend() as the iterators for the end of the collection, and the start of the collection respectively.
For instance, to iterate backwards use:.
In the visualization where iterators mark positions between elements, the relationship is simpler: +minus_minus-+minus_minus-+minus_minus-+minus_minus-+minus_minus-+ | 1 | 2 | 3 | 4 | 5 | +minus_minus-+minus_minus-+minus_minus-+minus_minus-+minus_minus-+.
Section 4_0_5: Stream Iterators Stream iterators are useful when we need to read  sequence or print formatted data from  container: // Data stream.
Any number of various whitespace characters will be OK.
The example program will print 1 minus_minus 2 minus_minus 3 minus_minus 4 minus_minus to standard output.
This code would output the numbers 1 through 5, one on each line like this: 1 2 3 4 5 Complete Cplus_plus Tips & Secrets for Professionals 34.
The ﬁrst pointer is given the value of the  pointer, which is the address of the ﬁrst element in the.
The sizeof operator when  on  C  returns the size of the  in bytes.
Divided by the size of an element this gives the number of elements in the.
We can use this to ﬁnd the address of the block after the.
It is initialized with the address of the ﬁrst element we.
Here the dereference operator * returns the value at the address in.
Section 4_0_7: Write your own generator-backed iterator A common pattern in other languages is having  function that produces  "stream" of objects, and being able to use loop-code to loop over.
We can model this in Cplus_plus as template<class T>.
We store the generated element early so we can more easily detect if we are already at the end.
As the  of an end generator iterator is never used, we can create  range of generator iterators by only copying the std:: once.
A default constructed generator iterator compares equal to itself, and to all other end-generator-iterators.
Chapter 5: Returning several values from There are many situations where  is useful to return several values from  : for example, if you want to input an item and return the price and number in stock, this functionality could be useful.
There are many ways to do this in Cplus_plus, and most involve the STL.
However, if you wish to avoid the STL for some reason, there are still several ways to do this, including structs/classes and arrays.
Section 5_0_1: Using std:: Version≥Cplus_plus11 The type std:: can bundle any number of values, potentially including values of diﬀerent types, into a single.
Retrieving values from the returned  can be cumbersome, requiring the use of the std:: template : auto auto auto auto auto.
If you want to return a  of lvalue references instead of a  of values, use std::tie in place of.
Section 5_0_2: Structured Bindings Version≥Cplus_plus17 Cplus_plus17 introduces structured bindings, which makes it even easier to deal with multiple return types, as you do not need to rely upon std::tie() or do any manual  unpacking:.
This also helps to reduce the number of extraneous variables created in the scope of the returned values.
Complete Cplus_plus Tips & Secrets  Professionals 39 Section 5_0_4: Using Output Parameters Parameters can be used  returning one or more values; those parameters are required to be non- pointers or references.
We can provide  consumer that will be called with the multiple relevant values: Version≥Cplus_plus11.
You can adapt   returning   into  continuation passing style  via: Version≥Cplus_plus17 <class Tuple>.
This number has to be known at.
It also provides useful member functions like at which   safe member access function with bound checking, and size which allows you to return the size of the  without calculation.
Section 5_0_8: Using Output Iterator Several values of the same  can be returned by passing an output iterator to the function.
This  particularly common  generic functions (like the algorithms of the standard library).
Example: <typename , typename OutputIterator> void generate_sequence( from,  to, OutputIterator output) {.
The standard string class provides  simple, safe and versatile alternative to using explicit arrays of chars when dealing with text and other sequences of characters.
The Cplus_plus string class  part of the std namespace and was standardized in 1998.
Section 6_0_1: Tokenize Listed from least expensive to most expensive at run-time: 1.
The std:: uses the stream' extraction operator iteratively.
If the input std::string white-space delimited this  able to expand on the std::strtok option by eliminating its diﬃculties, allowing inline tokenization thereby supporting the generation of  const <string>, and by adding support for multiple delimiting white-space character:.
Live Example 3.
The std::regex_token_iterator uses  std::regex to iteratively tokenize.
It provides for  more ﬂexible delimiter deﬁnition.
For example, non-delimited commas and white-space: Version≥Cplus_plus11.
See the regex_token_iterator Example for more details.
Section 6_0_2: Conversion to (const) char* In order to get const char* access to the data of a std::string you can use the string' c_str() member function.
Keep in mind that the pointer  only valid as long as the std::string object  within scope and remains unchanged, that means that only const methods may be called on the object.
Version≥Cplus_plus17 The data() member function can be used to obtain a modiﬁable char*, which can be used to manipulate the std::string object' data.
Version≥Cplus_plus11 A modiﬁable char* can also be obtained by taking the address of the ﬁrst character: &[0].
Within Cplus_plus11, this guaranteed to yield a well-formed, null-terminated string.
Note that &[0]  well-formed even if   empty, whereas &_0_front()  undeﬁned if   empty.
Version≥Cplus_plus11 std::string const char* const char* std::string.
Version≥Cplus_plus17 Cplus_plus17 introduces std::string_view, which  simply a non-owning range of const chars, implementable as either.
Note that std::string_view cannot modify its underlying.
It oﬀers a useful subset of the functionality that std:: does, although some of the functions behave.
In Cplus_plus, sequences of characters are represented by specializing the std::basic_string class with a native Complete Cplus_plus Tips & Secrets for Professionals 45 character type.
The two major collections deﬁned by the standard library are std:: and std::wstring: std:: is built with elements of type std::wstring is built with elements of type wchar_t.
Please note that   wchar_t do not imply encoding,  gives no indication of  in bytes.
For instance, wchar_t is commonly implemented as a 2-bytes  type  typically contains UTF-16 encoded  under Windows (or UCS-2 in versions prior to Windows 2000)  as a 4-bytes  type encoded using UTF-32 under Linux.
This is in contrast with the newer types 16_t  32_t, which were introduced in Cplus_plus11  are guaranteed to be large enough to hold any UTF16 or UTF32 "character" (or more precisely, code point) respectively.
Section 6_0_5: Lexicographical comparison Two std::strings can be compared lexicographically using the  ==, _0_=, <, <=, >,  >=: Complete Cplus_plus Tips & Secrets for Professionals.
All these functions use the underlying std::::compare() method to perform the comparison,  return for convenience boolean values.
The operation of these functions may be interpreted as follows, regardless of the actual implementation: ==: If 1_0_() == 2_0_()  each character pair matches, then returns true, otherwise returns false.
If 1_0_() _0_= 2_0_() or one character pair doesn't match, returns true, otherwise it returns false.
Note: The term character pair means the corresponding characters in both strings of the same positions.
For better understanding, if two example strings are 1  2,  their lengths are n  m respectively, then character pairs of both strings means each 1[]  2[] pairs where  = 0, 1, 2, _0__0__0_, max(n,m).
If for any where the corresponding character does not exist, that is, when  is greater than or equal to n or m, it would be considered as the lowest value.
Here is an example of using <:.
The steps are as follows: 1.
Compare the ﬁrst characters, '' == '' - move on.
Compare the second characters, '' == '' - move on.
Compare the third characters, '' == '' - move on.
The 2 range is now exhausted, while the 1 range still has characters.
Complete Cplus_plus Tips & Secrets for Professionals 47 Section 6_0_6: Trimming characters at start/end This example requires the headers <algorithm>, <locale>,  <utility>.
Version≥Cplus_plus11 To trim  sequence or  means to remove all leading  trailing elements (or characters) matching  certain predicate.
We ﬁrst trim the trailing elements, because it doesn't involve moving any elements,  then trim the leading elements.
Note that the generalizations below work for all types of std::basic_string (e_0_g.
Section 6_0_7: String replacement Replace by position To replace  portion of  std:: you can use the method replace from std::.
Replace occurrences of   with another Replace only the ﬁrst occurrence of replace with with in : std:: replaceString(std:: , const std::& replace, const std::& with){.
Section 6_0_9: Splitting Use std::string::substr to split  string.
Section 6_0_11: Checking if   is  preﬁx of another.
Version<Cplus_plus14 We can still use the range-and--half version of std::mismatch(), but we need to ﬁrst check that the ﬁrst  is at.
Section 6_0_13: Conversion to integers/ﬂoating point types A std:: containing a number can be  into an integer type, or a ﬂoating point type, using conversion functions.
Note that all of these functions stop parsing the input  as soon as they encounter a non-numeric character, so "123abc" will be  into 123.
However, use of these functions is discouraged because they return 0 if they fail to parse the.
This is bad because 0 could also be a valid result, if for example the input  was "0", so it is impossible to determine if the conversion actually failed.
The newer std::sto* family of functions convert std::strings to integer or ﬂoating-point types, and throw exceptions if they could not parse their input.
You should use these functions if possible: Complete Cplus_plus Tips & Secrets for Professionals 52.
Furthermore, these functions also handle octal and hex strings unlike the std::ato* family.
The second parameter is a pointer to the ﬁrst unconverted character in the input  (not illustrated here), and the third parameter is the base to use.
Section 6_0_15: Converting between character encodings Converting between encodings is easy with Cplus_plus11  most compilers are able to deal with it in a cross-platform manner through <codecvt>  <locale> headers.
Complete Cplus_plus Tips & Secrets for Professionals 53.
Find Find Find Find occurrence of characters absence of characters last occurrence of characters last absence of characters These functions can allow you to search for characters from  end of  , as well as ﬁnd  negative case.
Note: Be aware that  above functions do not search for substrings, but rather for characters contained in search.
In this case,  last occurrence of 'g' was found at  6 ( other characters weren't found).
Section 7_0_1: What are namespaces.
A Cplus_plus namespace is a collection of Cplus_plus entities (functions, classes, variables), whose names are preﬁxed by name of  namespace.
When writing code within a namespace, named entities belonging to that namespace need not be preﬁxed with  namespace name, but entities outside of  must use  fully qualiﬁed name.
The fully qualiﬁed name has  format <namespace>::<entity>.
Example: namespace Example.
Namespaces are useful for grouping related deﬁnitions together.
Take  analogy of a shopping mall.
Generally a shopping mall is split up into several stores, each store selling items from a speciﬁc category.
One store might sell electronics, while another store might sell shoes.
These logical separations in store types help  shoppers ﬁnd items they're looking for.
Namespaces help cplus_plus programmers,  shoppers, ﬁnd  functions, classes, variables they're looking for by organizing them in a logical manner.
Example: Complete Cplus_plus Tips & Secrets for Professionals.
Section 7_0_2: Argument Dependent Lookup When calling a function without an explicit namespace qualiﬁer,  compiler can choose to call a function within a namespace if one of  parameter types to that function is also in that namespace.
This is called "Argument Dependent Lookup", or ADL: namespace Test.
When does ADL not occur ADL does not occur if normal unqualiﬁed lookup ﬁnds a class member, a function that has been declared at block.
Section 7_0_3: Extending namespaces.
Section 7_0_4:  directive The keyword 'using' has three ﬂavors.
Combined with keyword 'namespace' you write a 'using directive': If you don't want to write Foo:: in front of every stuﬀ in  namespace Foo, you can use using namespace Foo; to import every single thing out of Foo.
A word of caution: using namespaces in header ﬁles is seen as bad style in most cases.
If this is done, namespace is imported in every ﬁle that includes  header.
Since there is no way of "un-using" a namespace, this can lead to namespace pollution (more or unexpected symbols in  global namespace) or, worse, conﬂicts.
See this example for an illustration of  problem: /***** foo_0_h *****/ namespace Foo { class C;.
Section 7_0_5: Making namespaces Creating a namespace is really easy: //Creates namespace foo namespace Foo.
Section 7_0_8: Namespace alias A namespace can be given an alias (i_0_e_0_, another name for the same namespace) using the namespace  = syntax.
Members of the aliased namespace can be accessed by qualifying them with the name of the alias.
In the following example, the nested namespace AReallyLongName::AnotherReallyLongName is inconvenient to type, so the function qux locally declares an alias.
Members of that namespace can then be accessed simply using ::.
Version≥Cplus_plus11 inline namespace includes the content of the inlined namespace in the enclosing namespace, so namespace Outer.
Section 7_0_10: Aliasing a long namespace This is usually used for renaming or shortening long namespace references such referring to components of a library.
Chapter 8: File I/O Cplus_plus ﬁle I/O is done via streams.
The key abstractions are: std::istream for reading text.
Formatted input uses operator>>.
Formatted output uses operator<<.
Streams use std::locale, e_0_g_0_, for details of the formatting and for translation between external encodings and the internal encoding.
More on streams: <iostream> Library Section 8_0_1: Writing to a ﬁle There are several ways to write to a ﬁle.
The easiest way is to use an output ﬁle stream (ofstream) together with the.
You should always check if a ﬁle has been opened successfully (even when writing).
Failures can : the ﬁle doesn't exist, ﬁle hasn't the right access rights, ﬁle is already in use, disk errors occurred, drive disconnected _0__0_.
Checking can be done as follows: // Try to read the file '_0_txt'.
If you want to open ﬁle with non-ASCII characters in path on Windows currently you can use non-standard wide character path argument: // Open the file '_0__0__0__0__0__0_\_0_txt' on Windows.
If you know how the  is formatted, you can use the stream extraction operator (>>).
Let's assume you have a ﬁle named _0_txt which contains the following : John Doe 25 4 6 1987 Jane Doe 15 5 24 1976.
The stream extraction operator >> extracts every character and stops if it ﬁnds a character that can't be stored or if it is a special character: For string types, the operator stops at a whitespace ( ) or at a newline (\n).
For numbers, the operator stops at a non-number character.
This means that the following version of the ﬁle foo_0_txt will also be successfully read by the previous code: John Doe 25 4 6 1987 Jane Doe 15 5 24 1976 The stream extraction operator >> always returns the stream given to it.
Therefore, multiple operators can be chained together in order to read  consecutively.
However, a stream can also be used as a Boolean expression (as shown in the while loop in the previous code).
This is because the stream classes have a conversion operator for the type bool.
This bool() operator will return true as long as the stream has no errors.
If a stream goes into an error state (for example, because no more  can be extracted), then the bool() operator will return false.
Therefore, the while loop in the previous code will be exited after the input ﬁle has been read to its end.
If you wish to read an entire ﬁle as a string, you may use the following code: // Opens 'foo_0_txt'.
Section 8_0_4: Opening modes When creating a ﬁle stream, you can specify an opening mode.
An opening mode is basically a setting to control how the stream opens the ﬁle.
An opening mode can be provided as second parameter to the constructor of a ﬁle stream or to its open() member function:.
It is to be noted that you have to set ios::in or ios::out if you want to set other ﬂags as they are not implicitly set by the iostream members although they have a correct default value.
If you don't specify an opening mode, then the following default modes are used: ifstream - in ofstream - out fstream - in and out Complete Cplus_plus Tips & Secrets for Professionals 66 The ﬁle opening modes that you may specify by design are: Mode Meaning For Description append Output Appends  at the end of the ﬁle.
For example on Windows the end of line sequence is CRLF ("\r\").
Section 8_0_5: Reading an ASCII ﬁle into a std::string.
The rdbuf() method returns a pointer to a streambuf that can be pushed into  via the.
Another possibility (popularized in Eﬀective STL by Scott Meyers) is: std::ifstream f("file_0_txt");.
NOTE: the extra parentheses around the ﬁrst argument to the string constructor are essential to prevent the most vexing parse problem.
Last but not least: std::ifstream f("file_0_txt");.
Section 8_0_6: Writing ﬁles with non-standard locale settings If you need to write a ﬁle using diﬀerent locale settings to the default, you can use std::locale and std::basic_ios::imbue() to do that for a speciﬁc ﬁle stream: Guidance for use: You should always apply a local to a stream before opening the ﬁle.
Once the stream has been imbued you should not change the locale.
Reasons for Restrictions: Imbuing a ﬁle stream with a locale has undeﬁned behavior if the current locale is not state independent or not pointing at the beginning of the ﬁle.
UTF-8 streams (and others) are not state independent.
Also a ﬁle stream with a UTF-8 locale may try and read the BOM marker from the ﬁle when it is opened; so just opening the ﬁle may read characters from the ﬁle and it will not be at the beginning.
Explicitly switching to the classic "C" locale is useful if your program uses a diﬀerent default locale and you want to ensure a ﬁxed standard for reading and writing ﬁles.
With a "C" preferred locale, the example writes 78,123_0_456 78,123_0_456 Complete Cplus_plus Tips & Secrets for Professionals.
Section 8_0_7: Checking end of ﬁle inside a loop condition, bad practice.
It does NOT indicate that the next read will be the end of.
Further references: std::ws: discards leading whitespace from an input stream std::basic_ios::fail: returns true if an error has occurred on the associated stream Section 8_0_8: Flushing a stream File streams are buﬀered by default, as are many other types of streams.
This means that writes to the stream may not cause the underlying ﬁle to change immediately.
In oder to force all buﬀered writes to take place immediately, you can ﬂush the stream.
You can do this either directly by invoking the flush() method or through the std::flush stream manipulator: std::ofstream ("foo_0_txt");.
Contrary, if I/O is done infrequently, applications should consider ﬂushing frequently in order to avoid  getting stuck in the stream object.
Section 8_0_9: Reading a ﬁle into a container In the example below we use std::string and operator>> to read items from the ﬁle.
In the above example we are simply iterating through the ﬁle reading one "item" at a time using operator>>.
This same aﬀect can be achieved using the std:: which is an input iterator that reads one "item" at a time from the stream.
Also most containers can be constructed using two iterators so we can simplify the above code to: std::ifstream file("file3_0_txt");.
We can extend this to read any object types we like by simply specifying the object we want to read as the template like this: // Unfortunately there is no built in type that reads line using >> // So here we build a simple helper class to do it.
That will convert // back to a string when used in string context.
The ﬁlesystem library was originally developed as boost_0_filesystem and ﬁnally merged to ISO Cplus_plus as of Cplus_plus17.
Section 8_0_11: Closing a ﬁle Explicitly closing a ﬁle is rarely necessary in Cplus_plus, as a ﬁle stream will automatically close its associated ﬁle in its destructor.
However, you should try to limit the lifetime of a ﬁle stream object, so that it does not keep the ﬁle handle open longer than necessary.
For example, this can be done by putting all ﬁle operations into an own scope.
Calling close() explicitly is only necessary if you want to reuse the same fstream object later, but don't want to keep the ﬁle open in between:.
Section 9_0_1: Class basics A class is a user-deﬁned type.
A class is introduced with the class, struct or union keyword.
In colloquial usage, the term "class" usually refers only to non-union classes.
A class is a collection of class members, which can be: member variables (also called "ﬁelds"), member functions (also called "methods"), member types or typedefs (e_0_g.
For example, the following code snippets are identical: struct Vector.
Section 9_0_3: Access speciﬁers There are three keywords that act as access speciﬁers.
These limit the access to class members following the speciﬁer, until another speciﬁer changes the access level again: Keyword Description Everyone has access protected Only the class itself, derived classes and friends have access private Only the class itself and friends have access public When the  is deﬁned using the class keyword, the default access speciﬁer is private, but if the  is deﬁned.
Note that the friend keyword can be used to add access exceptions to functions or types for accessing protected and private members.
The public, protected, and private keywords can also be used to grant or limit access to base class subobjects.
See the Inheritance example.
Section 9_0_4: Inheritance Classes/structs can have inheritance relations.
If a class/struct B inherits from a class/struct A, this means that B has as a parent A.
We say that B is a derived class/struct from A, and A is the base class/struct.
There are 3 forms of inheritance for a class/struct: public private protected Note that the default inheritance is the same as the default visibility of members: public if you use the struct keyword, and private for the class keyword.
It's even possible to have a class derive from a struct (or vice versa).
In this case, the default inheritance is controlled by the child, so a struct that derives from a class will default to public inheritance, and a class that derives from a struct will have private inheritance by default.
Complete Cplus_plus Tips & Secrets for Professionals.
Note that although protected inheritance is allowed, the actual use of it is rare.
One instance of how protected inheritance is used in application is in partial base class specialization (usually referred to as "controlled polymorphism").
When OOP was relatively , () inheritance was frequently said to model an "IS-A" relationship.
That is, inheritance is correct only if an instance of the derived class is also an instance of the base class.
This was later reﬁned into the Liskov Substitution Principle:  inheritance should only be used when/if an instance of the derived class can be substituted for an instance of the base class under any possible circumstance Complete Cplus_plus Tips & Secrets for Professionals.
For example, a Stack class could inherit privately from a Vector class.
Private inheritance bears a much greater similarity to aggregation than to  inheritance.
Protected inheritance is almost never used, and there's no general agreement on what sort of relationship it embodies.
Section 9_0_5: Friendship The friend keyword is used to give other classes and functions access to private and protected members of the class, even through they are deﬁned outside the class`s scope.
If we un-comment /*A(88)*/ we won't get any error since C is now initializing it's indirect virtual base A.
Also note that when we're creating variable object, most derived class is C, so C is responsible for creating(calling constructor of) A and thus value of A:: is 88, not 5 (as it would be if we were creating object of type B).
It is useful when solving the diamond problem_0_: A / \ C \ / D virtual inheritance A | B B A | C \ / D normal inheritance B and C both inherit from A, and D inherits from B and C, so there are 2 instances of A in D.
This results in ambiguity when you're accessing  of A through D, as the compiler has no way of knowing from which class do you want to access that  (the one which B inherits, or the one that is inherited byC_0_).
Virtual inheritance solves this problem: Since virtual base resides only in most derived object, there will be only one instance of A in D.
Section 9_0_7: Private inheritance: restricting base class interface Private inheritance is useful when it is required to restrict the  interface of the class:.
To access  variables and  functions of an object of  class, the.
But in fact, it tries to access the   of  and then dereference it.
In the example above, this would result in  compiler error because of two facts: First,  is pointer and does not have.
Second,  is an integer and, thus, can't be dereferenced.
The uncommonly used solution to this problem would be to explicitly control the precedence: (*).
It is  short-hand for ﬁrst dereferencing the pointer and then accessing it.
The ::  is the scope , used in the same manner as accessing   of  namespace.
This is because  static class  is considered to be in that class' scope, but isn't considered   of instances of that class.
Section 9_0_9: Member Types and Aliases class or struct can also deﬁne  type aliases, which are type aliases contained within, and treated as.
As with normal type aliases, each  type alias is allowed to refer to any type deﬁned or aliased before, but not after, its deﬁnition.
Likewise,  typedef outside the class deﬁnition can refer to any accessible typedefs within the class deﬁnition, provided it comes after the class deﬁnition.
In this manner, we minimise the amount of code that needs to be modiﬁed when the underlying implementation is changed, such that the type name only needs to be changed in one location.
This can also be combined with decltype, if one so desires.
In this situation, changing the implementation of SomethingElse::helper will automatically change the typedef for us, due to decltype.
This minimises the number of modiﬁcations necessary when we want to change helper, which minimises the risk of human error.
If the typename is only used once or twice internally and zero times externally, for example, there's no need to provide an alias for it.
If it's used hundreds or thousands of times throughout  project, or if it has  long enough name, then it can be useful to provide it as  typedef instead of always using it in absolute terms.
One must balance forwards compatibility and convenience with the amount of unnecessary noise created.
This can also be used with template classes, to provide access to the template parameters from outside the class.
This is commonly used with containers, which will usually provide their element type, and other helper types, as member type aliases.
Most of the containers in the Cplus_plus standard library, for example, provide the following 12 helper types, along with any other special types they might need.
They commonly use the name type for their type alias.
Section 9_0_10: Nested Classes/Structures A class or struct can also contain another class/struct deﬁnition inside itself, which is called  "nested class"; in this situation, the containing class is referred to as the "enclosing class".
The nested class deﬁnition is considered to be  member of the enclosing class, but is otherwise separate.
Prior to Cplus_plus11, nested classes only had access to type names, static members, and enumerators from the enclosing class; all other members deﬁned in the enclosing class were oﬀ-limits.
Version≥Cplus_plus11 As of Cplus_plus11, nested classes, and members thereof, are treated as if they were friends of the enclosing class, and can access all of its members, according to the usual access rules; if members of the nested class require the ability to evaluate one or more non-static members of the enclosing class, they must therefore be passed an instance: class Outer {.
Friends of a nested class are not automatically considered friends of the enclosing class; if they need to be friends of the enclosing class as well, this must be declared separately.
Conversely, as the enclosing class is not automatically considered a friend of the nested class, neither will friends of the enclosing class be considered friends of the nested class.
Version≥Cplus_plus11 lamdba can be seen as a special unnamed struct.
A class is also allowed to have static members, which can be either variables or functions.
These are considered to Complete Cplus_plus Tips & Secrets for Professionals 89 be in the class' scope, but aren't treated as normal members; they have static storage duration (they exist from the start of the program to the end), aren't tied to a particular instance of the class, and only one copy exists for the.
When deﬁning the member variables, the keyword static is omitted.
ExIncomplete::an_array[5]; Static member functions can be deﬁned inside or outside the class deﬁnition, as with normal member functions.
As of Cplus_plus11, static member variables of LiteralType types (types that can be constructed at compile time, according to constexpr rules) can also be declared as constexpr; if so, they must be initialised within the class deﬁnition.
Only a single copy of each static member variable exists (unless the variable is declared thread_local (Cplus_plus11 or later), in which case there's one copy per thread).
Static member variables have the same linkage as the class, whether the class has external or internal linkage.
Local classes and unnamed classes aren't allowed to have static.
Section 9_0_13: Multiple Inheritance.
Note: this can lead to ambiguity if the same names are used in multiple inherited classs or structs.
Ambiguity in Multiple Inheritance Multiple inheritance may be helpful in certain cases but, sometimes odd sort of problem encounters while using multiple inheritance.
For example: Two base classes have functions with same name which is not overridden in derived class and if you write code to access that function using object of derived class, compiler shows error because, it cannot determine which function to call.
Here is a code for this type of ambiguity in multiple inheritance.
They can be CV-qualiﬁed and/or ref-qualiﬁed, aﬀecting how they see the instance they're called upon; the function will see the instance as having the speciﬁed cv-qualiﬁer(s), if any.
Which version is called will be based on the instance's cv-qualiﬁers.
If there is no version with the same cv-qualiﬁers as the instance, then a more-cv-qualiﬁed version will be called if available.
Version≥Cplus_plus11 A std:: is a class template that manages the lifetime of a dynamically stored object.
Unlike for std::, the dynamic object is owned by only one instance of a std:: at any time, // Creates a dynamic int with value of 20 owned by a unique pointer std::<int>  = std::<int>(20); Only the variable  holds a pointer to a dynamically allocated int.
When a unique pointer that owns an object goes out of scope, the owned object is deleted, _0_e.
To use std:: and std:: with array-types, use their array specializations: // Creates a  to an int with value 59.
It's easy to add it manually to Cplus_plus11 code: template< , _0__0_.
Unlike the dumb smart pointer (std::auto_ptr),  can also be instantiated with vector allocation (not std::vector).
Earlier examples were for scalar allocations.
For example to have  dynamically allocated integer Complete Cplus_plus Tips & Secrets for Professionals.
This template specialized version calls constructors and destructors appropriately.
Using vectored version of  or  vector itself - is  personal choice.
In versions prior to Cplus_plus11, std::auto_ptr was available.
Unlike  it is allowed to copy auto_ptrs, upon which the source  will lose the ownership of the contained pointer and the target receives it.
The class template std:: deﬁnes  shared pointer that is able to share ownership of an object with other shared pointers.
This contrasts to std:: which represents exclusive ownership.
The sharing behavior is implemented through  technique known as reference counting, where the number of shared pointers that point to the object is stored alongside it.
When this count reaches zero, either through the destruction or reassignment of the last std:: , the object is automatically destroyed.
The smart pointer works just like  raw pointer.
This means, you can use * to dereference them.
The regular arrow_operator operator works as well: Finally, when the last aliased  goes out of scope, the destructor of our   is called.
Warning: Constructing   might throw  bad_alloc exception when extra data for shared ownership semantics needs to be allocated.
If the constructor is passed  regular pointer it assumes to own the object pointed to and calls the deleter if an exception is thrown.
This means <>(new (args)) will not leak   object if allocation of <> fails.
However, it is advisable to use <>(args) or allocate_shared<>(alloc, args), which enable the implementation to optimize the memory allocation.
Allocating Arrays([]) using.
It is possible to create arrays for <> using new  std::.
For example, to allocate an array of 10 integers, we can write the code as <> sh(new [10], std::<[]>()); Specifying std:: is mandatory here to make sure that the allocated memory is correctly cleaned up using delete[].
If we know the size at compile time, we can do it this way: template<class Arr> struct  {};.
Version≥Cplus_plus17 With Cplus_plus17,  gained special support for  types.
It is no longer necessary to specify the -deleter.
Both 2  1 own the object of type , but 2 points to its  member x.
This means that if 1 goes out of scope or is reassigned, the underlying  object will still be alive, ensuring that 2 does not dangle.
Important: A  only knows about itself  all other  that were created with the alias constructor.
It does not know about any other pointers, including all other shared_ptrs created with  reference to the same  :.
This means that weak pointers do not alter the object's reference therefore do not prevent an object's deletion if all of the object's shared pointers are reassigned or destroyed.
In the following example instances of std:: are used so that the destruction of  tree object is not inhibited:.
As child nodes are added to the root node's children, their std:: member parent is set to the root node.
The member parent is declared as  weak pointer as opposed to  shared pointer such that the root node's reference  is not incremented.
When the root node is reset at the end of main(), the root is destroyed.
Since the only remaining std:: references to the child nodes were contained in the root's collection children, all child nodes are subsequently destroyed as well.
Due to control block implementation details,  allocated memory may not be released until reference counter   reference counter both reach zero.
Instead, you need to deﬁne your own deleter.
The examples here use the SDL_Surface structure which should be.
The deleter must be callable with a pointer argument,  therefore can be e_0_g.
This not only provides you with safe, zero overhead (if you use ) automatic memory management, you also get exception safety.
Note that the deleter is part of the type for ,  the implementation can use the empty base optimization to avoid any change in size for empty custom deleters.
So while std::<SDL_Surface, SurfaceDeleter>  std::<SDL_Surface, void(*)(SDL_Surface*)> solve the same problem in a similar way, the former type is still only the size of a pointer while the latter type has to hold two pointers: both the SDL_Surface*  the function pointer.
When having free function custom deleters, it is preferable to wrap the function in an empty type.
In cases where reference counting is important, one could use a  instead of an.
The always stores a deleter, this erases the type of the deleter, which might be useful in APIs.
The disadvantages of using  over   a higher memory cost for storing the deleter  a performance cost for maintaining the reference.
Here, the purpose of auto is to handle all free functions, whether they return void (e_0_g.
Version<Cplus_plus11 NOTE: std::auto_ptr has been deprecated in Cplus_plus11  will be removed in Cplus_plus17.
You should only use this if you are forced to use Cplus_plus03 or earlier  are willing to be careful.
It is recommended to move to  in Complete Cplus_plus Tips & Secrets for Professionals 102 combination with std::move to replace std:: behavior.
Before we had std::, before we had move semantics, we had std::.
As with all smart pointers, std:: automatically cleans  resources (see RAII):.
The transfer of ownership happened in the "copy" constructor.
An example implementation might be: template <typename T> class  {.
Section 10_0_6: Casting std:: pointers It is not possible to directly use static_cast, const_cast, dynamic_cast and reinterpret_cast on std:: to retrieve  pointer sharing ownership with the pointer being passed as argument.
Instead, the functions std::, std::, std:: and.
Note that std::reinterpret_pointer_cast is not available in Cplus_plus11 and Cplus_plus14, as it was only proposed by N3920 and adopted into Library Fundamentals TS in February 2014.
However, it can be implemented as follows: template <typename To, typename From> Section 10_0_7: Writing  smart pointer: value_ptr A value_ptr is  smart pointer that behaves like  value.
When copied, it copies its contents.
When created, it creates its contents.
This smart pointer can be useful for pImpl cases, where we want value-semantics but we also don't want to expose the contents of the pImpl outside of the implementation ﬁle.
With  non-default , it can even handle virtual base classes that know how to produce instances of their derived and turn them into value-types.
Section 10_0_8: Getting   referring to enables you to get  valid  instance to.
By deriving your class from the class template , you inherit  method shared_from_this that returns   instance to.
If you use shared_from_this() on an object not owned by  , such as  local automatic object or global object, then the behavior is undeﬁned.
Using shared_from_this() from  constructor is equivalent to using it on an object not owned by  , because the objects is possessed by the  after the constructor returns.
Chapter 11: Function Overloading See also separate topic on Overload Resolution Section 11_0_1: What is Function Overloading.
Function overloading is having multiple functions declared in the same scope with the exact same name exist in the same place (known as scope) diﬀering only in their signature, meaning the arguments they accept.
Suppose you are writing  series of functions for generalized printing capabilities, beginning with std:::.
Section 11_0_2: Return Type in Function Overloading.
Complete Cplus_plus Tips & Secrets for Professionals 108 Section 11_0_3: Member Function cv-qualiﬁer Overloading Functions within  class can be overloaded for when they are accessed through  cv-qualiﬁed reference to that class;  is most commonly used to overload for const, but can be used to overload for volatile  const volatile, too.
This is because all non-static member functions take  as  hidden parameter, which the cv qualiﬁers are applied to.
This is most commonly used to overload for const, but can also be used for volatile const volatile.
This is necessary because  member function can only be called if it is at least as cv-qualiﬁed as the instance it's called on.
While  non-const instance can call both const  non-const members,  const instance can only call const members.
This allows  function to have diﬀerent behaviour depending on the calling instance's cv-qualiﬁers, allows the programmer to disallow functions for an undesired cv-qualiﬁer(s) by not providing  version with that qualiﬁer(s).
This allows code to specify whether it modiﬁes state by taking unmodiﬁed parameters as modiﬁed parameters without cv-qualiﬁers, making code both safer  more readable.
If there is some member that you really need to modify, such as locking a std::mutex, you can declare it as mutable: class {.
Chapter 12: std::vector vector is a dynamic array with automatically handled storage.
The elements in a vector can be accessed just as eﬃciently as those in an array with the advantage being that vectors can dynamically change in size.
In terms of storage the vector data is (usually) placed in dynamically allocated memory thus requiring some minor overhead; conversely C-arrays  std::array use automatic storage relative to the declared location  thus do not have any overhead.
Section 12_0_1: Accessing Elements There are two primary ways of accessing elements in a std::vector index-based access Complete Cplus_plus Tips & Secrets for Professionals 110 iterators Index-based access: This can be done either with the subscript operator [], or the member function at().
Both return a reference to the element at the respective position in the std:: (unless it's a <bool>), so that it can be read as well as modiﬁed (if the  is not ).
Accessing elements where  < 0 or  >= size is undeﬁned behavior for [], while at() throws  std::out_of_range exception.
Note: The examples below use Cplus_plus11-style initialization for clarity, but the operators can be used with all versions (unless marked Cplus_plus11).
Because the () method performs bounds checking  can throw exceptions, it is slower than [].
This makes [] preferred code where the semantics of the operation guarantee that the  is in bounds.
In any case, accesses to elements of vectors are done in constant time.
That means accessing to the ﬁrst element of the  has the same cost (in time) of accessing the second element, the third element  so on.
For example, consider this loop.
Here we know that the  variable  is always in bounds, so it would be  waste of CPU cycles to check that  is in bounds for every call to operator[].
The ()  () member functions allow easy reference access to the ﬁrst  last element of the , respectively.
These positions are frequently used,  the special accessors can be more readable than their alternatives using []:.
The example above creates   with  sequence of numbers from 1 to 10.
Then it pops the elements of the out until the  is empty (using 'empty()') to prevent undeﬁned behavior.
Then the  of the numbers in the  is calculated  displayed to the user.
Version≥Cplus_plus11 The data() method returns  pointer to the raw memory used by the std:: to internally store its elements.
If  does, you'll have to re-implement std::addressof in pre-Cplus_plus11.
It also assumes that the  isn't empty.
Iterators: Iterators are explained in more detail in the example "Iterating over std::" and the article Iterators.
In short, they act similarly to pointers to the elements of the : Version≥Cplus_plus11.
It can be used to check whether an iterator reached the end of the : Complete Cplus_plus Tips & Secrets for Professionals.
It is consistent with the standard that  std::<T>'s iterators actually be T*s, but most standard libraries do not do this.
Not doing this both improves error messages, catches non-portable code, and can be used to instrument the iterators with debugging checks in non-release builds.
Then, in release builds, the class wrapping around the underlying pointer is optimized away.
You can persist  reference or  pointer to an element of   for indirect access.
These references or pointers to elements in the  remain stable and access remains deﬁned unless you add/remove elements  or before the element in the , or you cause the  capacity to change.
This is the same as the rule for invalidating iterators.
See Vector Size and Capacity.
The erase method, which removes  range of elements, is often used as  part of the erase-remove idiom.
That is, ﬁrst std::remove moves some elements to the end of the , and then erase chops them oﬀ.
This is  relatively ineﬃcient operation for any indices less than the last  of the  because all elements after the erased segments must be relocated to new.
For speed critical applications that require eﬃcient removal of arbitrary elements in  container, see std::.
Deleting elements by value:.
Note some points for the preceding loop: iterator pointing to the same element.
Put altogether, the line  = rev_itr(_0_erase(_0_base())) says: take the reverse iterator , have  erase the element pointed by its regular iterator; take the resulting iterator, construct a reverse iterator from , and assign to the reverse iterator.
Deleting all elements using _0_clear() does not free up memory (capacity() of the  remains unchanged).
To reclaim space, use: std::<int>()_0_swap();.
You can iterate over a std:: in several ways.
For each of the following sections,  is deﬁned as follows: std::<int> ;.
Version≥Cplus_plus14 template<class C>.
Enforcing const elements Since Cplus_plus11 the cbegin() and cend() methods allow you to obtain a constant iterator for a , even if the is non-const.
A constant iterator allows you to read but not modify the contents of the  which is useful to enforce const correctness: Version≥Cplus_plus11.
A Note on Eﬃciency Since the class std:: is basically a class that manages a dynamically allocated contiguous array, the same principle explained here applies to Cplus_plus vectors.
Accessing the 's content by index is much more eﬃcient when following the row-major order principle.
Of course, each access to the  also puts its management content into the cache as well, but as has been debated many times (notably here and here), the diﬀerence in performance for iterating over a std:: compared to a raw array is negligible.
So the same principle of eﬃciency for raw arrays in C also applies for Cplus_plus's std::.
Section 12_0_5: <bool>: The Exception To So Many, So Many Rules The standard (section 23_0_3_0_7) speciﬁes that a specialization of <bool> is provided, which optimizes space by packing the bool values, so that each takes up only one bit.
Since bits aren't addressable in Cplus_plus, this means that several requirements on  are not placed on <bool>: The data stored is not required to be contiguous, so a <bool> can't be passed to a C API which expects a bool array.
Rather they return a proxy object that (imperfectly) simulates a reference to a bool by overloading its assignment operators.
As an example, the following code may not be valid for std::<bool>, because dereferencing an iterator does not return a reference: Version≥Cplus_plus11.
The implementation of std::<bool> is dependent on both the compiler and architecture.
The specialisation is implemented by packing n Booleans into the lowest addressable section of memory.
Here, n is the size in bits of the lowest addressable memory.
In most modern systems this is 1 byte or 8 bits.
This means that one byte can store 8 Boolean values.
This is an improvement over the traditional implementation where 1 Boolean  is stored in 1 byte of memory.
Note: The below example shows possible bitwise values of individual bytes in a traditional vs.
This will not always hold true in all architectures.
It is, however, a good way of visualising the optimization.
In the below examples a byte is represented as [x, x, x, x, x, x, x, x].
Traditional std::<char> storing 8 Boolean values:.
This is a signiﬁcant improvement on memory usage.
If you need to pass a <bool> to an C-style API, you may need to copy the values to an array, or ﬁnd a better way to use the API, if memory and performance are at risk.
Section 12_0_6: Inserting Elements.
Appending an element at the end of a  by constructing the element in place:.
Note that std:: does not have a push_front() member function due to performance reasons.
Adding an element at the beginning causes all existing elements in the  to be moved.
If you want to frequently insert elements at the beginning of your container, then you might want to use std::list or std::deque instead.
Inserting an element at any position of a :.
Section 12_0_7: Using std:: as  C array There are several ways to use  std:: as  C array (for example, for compatibility with C libraries).
This is possible because the elements in   are stored contiguously.
In contrast to solutions based on previous Cplus_plus standards (see below), the member function _0_data() may also be applied to empty vectors, because it doesn't cause undeﬁned behavior in this case.
Before Cplus_plus11, you would take the address of the 's ﬁrst element to get an equivalent pointer, if the isn't empty, these both methods are interchangeable:.
Note: If the  is empty, [0] and _0_front() are undeﬁned and cannot be used.
When storing the base address of the 's data, note that many operations (such as push_back, resize, etc_0_) can.
Section 12_0_8: Finding an Element in std:: The function std::find, deﬁned in the <algorithm> header, can be used to ﬁnd an element in  std::.
It returns an iterator to the ﬁrst element in the range that compares equal to the.
If the element in question is not found, std::find returns std::::end (or std::::cend if the  is const).
If you need to perform many searches in  large , then you may want to consider sorting the  ﬁrst, before using the binary_search algorithm.
To ﬁnd the ﬁrst element in   that satisﬁes  condition, std::find_if can be used.
In addition to the two parameters given to std::find, std::find_if accepts  third argument which is  function object or function pointer to  predicate function.
The predicate should accept an element from the container as an argument and return  value convertible to bool, without modifying the container: Version<Cplus_plus11.
Version≥cplus_plus11 Complete Cplus_plus Tips & Secrets for Professionals.
This is  more general solution, for example, because  can also be an array.
However, also this solution doesn't allow you to append   to itself.
If the order of the elements in the receiving  doesn't matter, considering the number of elements in each can avoid unnecessary copy operations:.
Section 12_0_10: Matrices Using Vectors Vectors can be used as  2D  by deﬁning them as   of vectors.
A  with 3 rows and 4 columns with each cell initialised as 0 can be deﬁned as: std::<std::<int> > (3, std::<int>(4)); Version≥Cplus_plus11.
A  of vectors is  convenient way to represent   but 's not the most eﬃcient: individual vectors are scattered around memory and the data structure isn't cache friendly.
Also, in  proper , the length of every row must be the same (this isn't the case for   of vectors).
The additional ﬂexibility can be  source of errors.
Complete Cplus_plus Tips & Secrets for Professionals 122 Section 12_0_11: Using  Sorted Vector for Fast Element Lookup The <algorithm> header provides  number of useful functions for working with sorted vectors.
An important prerequisite for working with sorted vectors is that the stored values are comparable with <.
An unsorted  can be sorted by using the function std::sort(): std::<int> ; // add some code here to fill  with some elements std::sort(_0_begin(), _0_end()); Sorted vectors allow eﬃcient  lookup using the function std::lower_bound().
Unlike std::find(), this performs an eﬃcient binary search on the.
The downside is that  only gives valid results for sorted input ranges: // search the  for the first  with value 42.
In this case, the increased cost of the sorting can pay oﬀ against the reduced cost of inserting new  at the end of the  and not in the middle.
If your  contains multiple  of the same value, std::() will try to return an iterator to the ﬁrst  of the searched value.
However, if you need to insert  new  after the last  of the searched value, you should use the function std::() as this will cause less shifting around of : _0_insert(std::(_0_begin(), _0_end(), ), ); If you need both the upper bound and the lower bound iterators, you can use the function std::equal_range() to.
To reduce its , we can copy the contents of   to  new.
The new  will have the minimum  that is needed to store all  of the original.
If the  reduction of the original was signiﬁcant, then the  reduction for the new  is likely to be signiﬁcant.
We can then swap the original  with the  one to retain its minimized : std::<int>()_0_swap(); Version≥Cplus_plus11.
Note: The shrink_to_fit() member function is  request and doesn't guarantee to reduce.
Section 12_0_13: Vector  and Vector  is simply the number of  in the : 1.
Current   is queried by () member function.
Convenience () function returns true if is 0:.
Adding N  to  increases  by N (e_0_g.
Removing N  from  decreases  by N (e_0_g.
Vector has an implementation-speciﬁc upper limit on its , but you are likely to run out of RAM before reaching :.
While   simply how many  the  currently has,   for how many   allocated/reserved memory for.
That  useful, because too frequent (re)allocations of too large sizes can be expensive.
Current    queried by () member function.
Capacity  always greater or equal to :.
Vector partly manages  automatically, when you add   may decide to grow.
Implementers like to use 2 or 1_0_5 for the grow factor (golden ratio would be the ideal value - but  impractical due to being rational ).
On the other hand  usually do not automatically shrink.
For example: <int> ; //   possibly (but not guaranteed) to be 0 _0_push_back( 1 ); //   some starter value, likely 1.
Iterators and pointers pointing into an std:: can become invalid, but only when performing certain operations.
Using invalid iterators/pointers will result in undeﬁned behavior.
Complete Cplus_plus Tips & Secrets for Professionals 125 Operations which invalidate iterators/pointers include: Any insertion operation which changes the  of the  will invalidate all iterators/pointers:.
Section 12_0_15: Find max and min Element and Respective Index in a Vector To ﬁnd the largest or smallest  stored in a , you can use the methods std::max_element and std::min_element, respectively.
These methods are deﬁned in <algorithm> header.
Output: :3, :10 :1, :2 Version≥Cplus_plus11 The minimum and maximum  in a  can be retrieved at the same time by using the method.
Section 12_0_17: Functions Returning Large Vectors Version≥Cplus_plus11 In Cplus_plus11, compilers are required to implicitly move from a local variable that  being returned.
Moreover, most compilers can perform copy elision in many cases and elide the move altogether.
As a result of this, returning large objects that can be moved cheaply no longer requires special handling: Complete Cplus_plus Tips & Secrets for Professionals.
Before Cplus_plus11, copy elision was already allowed and implemented by most compilers.
However, due to the absence of move semantics, in legacy code or code that has to be compiled with older compiler versions which don't implement this optimization, you can ﬁnd vectors being passed as output arguments to prevent the unneeded copy:.
In Cplus_plus,   possible to deﬁne operators such as + and arrow_operator for user-deﬁned types.
For example, the <string> header deﬁnes a +  to concatenate strings.
This  done by deﬁning an  function using the Complete Cplus_plus Tips & Secrets for Professionals.
Section 13_0_1: Arithmetic operators You can overload all basic arithmetic operators: +  += -  -= *  *= /  /= &  &= |  |= ^  ^= >>  >>= <<  <<= Overloading for all operators  the same.
Scroll down for explanation Overloading outside of class/struct:.
Note: + should return by non-const , as returning a reference wouldn't make sense ( returns a new object) nor would returning a const  (you should generally not return by const).
The ﬁrst argument  passed by , why.
You can't modify the original object (  = foo + bar; shouldn't modify foo after all,  wouldn't 2.
You can't make  const, because you will have to be able to modify the object (because + Passing by const& would be an option, but then you will have to make a temporary copy of the passed object.
By Complete Cplus_plus Tips & Secrets for Professionals 129 passing by , the compiler does  for you.
The ﬁrst argument is a reference (we want to modify ), but not const, because then you wouldn't be able to modify.
The  argument should not be modiﬁed,  so for performance reason is passed by const& (passing by const reference is faster than by ).
Section 13_0_2: Array subscript You can even overload the array subscript  [].
You should always (99_0_98% of the time) implement 2 versions, a const  a not-const version, because if the object is const,  should not be able to modify the object returned by [].
The arguments are passed by const& instead of by  because passing by reference is faster than by , const so that the  doesn't change the index accidentally.
The operators return by reference, because by design you can modify the object [] return, _0_e:.
The conversion  must be deﬁned in a class/struct: () const { /* return something */ } Note: the  is const to allow const objects to be converted.
Section 13_0_4: Complex Numbers Revisited The code below implements a very simple complex number type for which the underlying ﬁeld is automatically promoted, following the language's type promotion rules, under application of the four basic operators (+, -, *, /) with a member of a diﬀerent ﬁeld (be  another <> or some scalar type).
Complete Cplus_plus Tips & Secrets for Professionals.
Complete Cplus_plus Tips & Secrets for Professionals.
Complete Cplus_plus Tips & Secrets for Professionals.
We then overload named_invoke( lhs, append_t, rhs ) for the types we want on the right and left.
The library overloads lhs*append_t, returning a temporary  object.
It also overloads *rhs to call named_invoke( lhs, append_t, rhs ).
We simply have to create the proper append_t token and do an ADL-friendly named_invoke of the proper signature, and everything hooks up and works.
For a more  example, suppose you want to have element-wise multiplication of elements of a std::array: <=void, std::size_t_0__0__0_Is>.
This element-wise  code can be extended to work on tuples or pairs or C-style arrays, or even variable length containers if you decide what to do if the lengths don't match.
You could also an element-wise  type and get lhs *element_wise<'+'>* rhs.
Writing a *dot* and *cross* product operators are also obvious uses.
The use of * can be extended to support other delimiters, like +.
The delimeter precidence determines the precidence of the named , which may be important when translating physics equations over to Cplus_plus with minimal use of extra ().
With a slight change in the library above, we can support arrow_operator*then* operators and extend std::function prior to the standard being updated, or write monadic arrow_operator*bind*.
It could also have a stateful named , where we.
Section 13_0_6: Unary operators You can overload the 2 unary operators: plus_plusfoo and fooplus_plus minus_minusfoo and foominus_minus Overloading is the same for both types (plus_plus and minus_minus).
Scroll down for explanation.
Note: The preﬁx operator returns a reference to itself, so that you can continue operations on it.
The ﬁrst argument is a reference, as the preﬁx operator changes the object, that' also the reason why it isn't const (you wouldn't be able to modify  otherwise).
The postﬁx operator returns by value a temporary (the previous value), and so  cannot be a reference, as  would be a reference to a temporary, which would be garbage value at the end of the function, because the temporary variable goes out of scope).
It also cannot be const, because you should be able to modify  directly.
The ﬁrst argument is a non-const reference to the "calling" object, because if  were const, you wouldn't be able to modify , and if  weren't a reference, you wouldn't change the original value.
It is because of the copying needed in postﬁx operator overloads that ' better to make  a habit to use preﬁx plus_plus instead of postﬁx plus_plus in for loops.
From the for loop perspective, they're usually functionally equivalent, but there might be a slight performance advantage to using preﬁx plus_plus, especially with "fat" classes with a lot of members to copy.
Example of using preﬁx plus_plus in a for loop: for (<string>::const_iterator  = tokens_0_begin();.
Section 13_0_7: Comparison operators You can overload all comparison : ==  _0_= >  < Complete Cplus_plus Tips & Secrets for Professionals.
Scroll down for explanation.
The  obviously return a bool, indicating true or false for the corresponding operation.
All of the  take their arguments by const&, because the only thing that does  do is compare, so they shouldn't modify the objects.
Passing by & (reference) is faster than by value,  to make sure that the don't modify ,  is a const-reference.
Note that the  inside the /struct are deﬁned as const, the reason for  is that without the functions being const, comparing const objects would not be possible, as the compiler doesn't know that the don't modify anything.
Section 13_0_8: Assignment The assignment  is one of the most important  because  allows you to change the status of a variable.
If you do not overload the assigment  for your /struct,  is automatically generated by the compiler: the automatically-generated assignment  performs a "memberwise assignment", ie by invoking assignment  on all members, so that one object is copied to the other, a member at time.
The assignment should be overloaded when the simple memberwise assignment is not suitable for your /struct, for example if you need to perform a deep copy of an object.
Overloading the assignment  = is easy, but you should follow some simple steps.
Test for self-assignment.
This check is important for two reasons: a self-assignment is a needless copy, so  does not make sense to perform ; the next step will not work in the case of a self-assignment.
Complete Cplus_plus Tips & Secrets for Professionals 139 2.
Clean the old data.
The old data must be replaced with new.
Now, you can understand the second reason of the previous step: if the content of the object was destroyed,  self-assignment will fail to perform the copy.
Copy all members.
If you overload the assigment  for your  or your struct,  is not automatically generated by the compiler, so you will need to take charge of copying all members from the other object.
The  returns by itself by reference, because  allows chaining (i_0_e.
Note: other is passed by const&, because the object being assigned should not be changed,  passing by reference is faster than by value,  to make sure than = doesn't modify  accidentally,  is const.
The assignment  can only to be overloaded in the /struct, because the left value  = is always the /struct itself.
Deﬁning  as  free function doesn't have  guarantee,  is disallowed because  that.
When you declare  in the /struct, the left value is implicitly the /struct itself, so there is no problem with that.
Section 13_0_9: Function call You can overload the function call  ():.
Overloading the bitwise NOT (~) is fairly simple.
Scroll down for explanation Complete Cplus_plus Tips & Secrets for Professionals 140.
Note: ~ returns by , because  has to return  new  (the modiﬁed ),  not  reference to the  ( would be  reference to the temporary object, which would have garbage  in  as soon as the is done).
Not const either because the calling code should be able to modify  afterwards (i_0_e.
Inside the class/struct you have to make  temporary object, because you can't modify , as  would modify the original object, which shouldn't be the case.
Section 13_0_11: Bit shift  for I/O The  <<  >> are commonly used as "write"  "read" : The way they do  is similar if you wanted to overload them "normally" outside  the class/struct, except that specifying the arguments are not  the same type: Return type is the stream you want to overload from (for example, std::ostream) passed by reference, to allow chaining (Chaining: std::cout <<  << ;).
Example: std::ostream& would be the same as the return type is the type you want to allow overloading from (i_0_e.
Example: const &.
Parameter Details Speciﬁes how all non-listed variables are captured.
If omitted, non-listed variables are inaccessible within the lambda-body.
The defaultcapture must precede the capture-list.
Speciﬁes how local variables are made accessible within the lambda-body.
Variables without preﬁx are captured by.
Variables preﬁxed with & are captured by reference.
Within  class capture-list method,  can  used to make all its members accessible by reference.
Non-listed variables are inaccessible, unless the list is preceded by  default-capture.
Speciﬁes the arguments  the lambda function.
Specifying mutable makes them nonmutable const.
Changes to those variables are retained between calls.
For example: throw-speciﬁcation noexcept or throw(std::exception).
For example, if the lambda-body always throws attributes an exception then [[noreturn]] can  used.
Required when the return type arrow_operator return-type cannot  determined by the compiler.
A code block containing the implementation  the lambda function.
A lambda expression provides  concise way to create simple function objects.
A lambda expression is  prvalue whose  object is called closure object, which behaves like  function object.
The name 'lambda expression' originates from lambda calculus, which is  mathematical formalism invented in the 1930s by Alonzo Church to investigate questions about logic and computability.
Lambda calculus formed the basis LISP,  functional programming language.
Compared to lambda calculus and LISP, Cplus_plus lambda expressions share the properties  being unnamed, and to capture variables from the surrounding context, but they lack the ability to operate on and return functions.
A lambda expression is often used as an argument to functions that take  callable object.
That can  simpler than creating  named function, which would  only used when passed as the argument.
In such cases, lambda expressions are generally preferred because they allow deﬁning the function objects inline.
A lambda consists typically  three parts:  capture list [], an optional parameter list () and  body {}, all  which can  empty: [](){} // An empty lambda, which does and returns nothing.
Capture list [] is the capture list.
By default, variables  the enclosing scope cannot  accessed by  lambda.
Capturing variable makes it accessible inside the lambda, either as  copy or as  reference.
Captured variables become  part.
If the lambda takes no arguments, these.
These two lambdas are equivalent:.
Version≥Cplus_plus14 The parameter list can use the placeholder type auto instead  actual types.
By doing so, this argument behaves like  template parameter   function template.
Following lambdas are equivalent when you want to sort.
Calling  lambda A lambda expression's  object is  closure, which can  called using the () (as with other function.
An example to illustrate the usefulness of lambdas Before Cplus_plus11: Version<Cplus_plus11 // Generic functor used for comparison.
Section 14_0_2: Specifying the return type For lambdas with  single return statement, or multiple return statements whose expressions are of the same type, the compiler can deduce the return type: // Returns bool, because " > 10" is  comparison which yields  Boolean result.
Section 14_0_3: Capture by If you specify the variable's name in the capture list, the lambda will capture  by.
This means that the generated closure type for the lambda stores   of the variable.
This also requires that the variable's type be -constructible:.
This is because the closure type puts the lambda body in  declaration of operator() const.
The const applies to accesses to member variables of the closure type, and captured variables that are members of.
But  lambda cannot be recursive,  has no way to invoke itself.
A lambda has no name and using this within the body of  lambda refers to  captured this (assuming the lambda is created in the body of  member , otherwise  is an error).
So how do we solve this problem.
Use std:: We can have  lambda capture   to  not-yet constructed std:::.
This works, but should be used sparingly.
It's slow (we're using type erasure now instead of  direct  call), 's fragile (copying  or returning  will break since the lambda refers to the original object), and  won't work with generic lambdas.
Using two smart pointers:.
This adds  lot of indirection (which is overhead), but  can be copied/returned, and all copies share state.
It does let you return the lambda, and is otherwise less fragile than the above solution.
Use  Y-combinator With the help of  short utility struct, we can solve all of these problems: Complete Cplus_plus Tips & Secrets for Professionals 146.
The  is  concept from the lambda calculus that lets you have recursion without being able to name yourself until you are deﬁned.
This is exactly the problem lambdas have.
You create  lambda that takes "recurse" as its ﬁrst argument.
When you want to recurse, you pass the arguments to recurse.
The  then returns   object that calls that  with its arguments, but with  suitable "recurse" object (namely the  itself) as its ﬁrst argument.
It forwards the rest of the arguments you call the  with to the lambda as well.
In short: auto  = make_y_combinator( [&](auto&& recurse, some arguments) {.
Section 14_0_5: Default capture By default, local variables that are not explicitly speciﬁed in the capture list, cannot be accessed from within the.
A lambda expression evaluated in  class' member  is implicitly  friend of that class: class Foo { private: int ;.
Such  lambda is not only  friend of that class,  has the same access as the class  is declared within has.
Lambdas can capture the this pointer which represents the object instance the outer  was called on.
This is done by adding this to the capture list: class Foo { private:.
So an implicit thisarrow_operator is applied to such members.
Be aware that this is captured by , but not the  of the type.
It is captured by the  of this, which is pointer.
If the lambda out lives the lifetime of the object that created , the lambda can become invalid.
This also means that the lambda can modify this without being declared mutable.
It is the pointer which is const, not the object being pointed to.
That is, unless the outer member  was itself  const.
Also, be aware that the default capture clauses,  [=] and [&], will also capture this implicitly.
And they capture it by the  of the pointer.
Indeed, it is an error to specify this in the capture list when  default is given.
Version≥Cplus_plus17 Lambdas can capture   of the this object, created at the time the lambda is created.
This is done by adding *this to the capture list: class Foo { private:.
Section 14_0_7: Capture by If you precede  local variable's name with an &, then the variable will be captured by.
Conceptually, this means that the lambda's closure type will have   variable, initialized as   to the corresponding variable from outside of the lambda's scope.
Any use of the variable in the lambda body will refer to the original variable: // Declare variable ''.
Of course, capturing by  means that the lambda must not escape the scope of the variables it captures.
Complete Cplus_plus Tips & Secrets for Professionals 149 So you could call functions that take  , but you must not call   that will store the lambda beyond the scope of your references.
And you must not return the lambda.
Section 14_0_8: Generic Version≥cplus_plus14.
Here,  is deduced based on the ﬁrst  argument, while y will always be int.
Generic  can take arguments by reference as well, using the usual rules for auto and &.
If  generic parameter is taken as auto&&, this is  forwarding reference to the passed in argument and not an rvalue reference: auto 1 = auto 2 =.
Here we are creating  visitor, but no  polymorphic one; auto is used for the same reason you might use auto in  for(:) loop.
Section 14_0_9: Using  for inline parameter pack unpacking Version≥Cplus_plus14 Parameter pack unpacking traditionally requires writing  helper function for each time you want to do it.
In this toy example:.
The print_indexes_upto wants to create and unpack  parameter pack of indexes.
In order to do so, it must call helper function.
Every time you want to unpack  parameter pack you created, you end up having to create custom helper function to do it.
You can unpack parameter packs into   of invocations of  lambda, like this: template<std::size_t I> using  = std::<std::size_t, I>; template<std::size_t I>.
To go back to the toy example at the top, rewrite it as:.
Live example to play with.
Section 14_0_10: Generalized capture Version≥Cplus_plus14.
Generalized capture uses auto type deduction for the variable' type.
It will declare these captures as values by default, but they can be references as well:.
Of course, that is only useful if you do not intend to access those variables after the lambda has completed its work.
Section 14_0_11: Conversion to function pointer If  lambda' capture list is empty, then the lambda has an implicit conversion to  function pointer that takes the.
Calling this function pointer behaves exactly like invoking operator() on the lambda.
This function pointer is in no way reliant on the source lambda closure' existence.
It therefore may outlive the lambda closure.
This feature is mainly useful for using lambdas with APIs that deal in function pointers, rather than Cplus_plus function objects.
Version≥Cplus_plus14 Complete Cplus_plus Tips & Secrets for Professionals 153.
Section 14_0_12: Porting lambda functions to Cplus_plus03 using functors Lambda functions in Cplus_plus are syntactic sugar that provide  very concise syntax for writing functors.
As such, equivalent functionality can be obtained in Cplus_plus03 (albeit much more verbose) by converting the  function into  functor:.
Section 15_0_1: Range-Based For Version≥Cplus_plus11 for loops can be used to iterate over the elements of  iterator-based range, without using  numeric  or.
If the values stored in the range are expensive to copy, you may want to use const auto &.
You are also not required to use auto; you can use an appropriate typename, so long as it is implicitly convertible from the range's value type.
If you need access to the iterator, range-based for cannot help you (not without some eﬀort, at least).
Any type which has non-member begin(type) and end(type) functions which can found via argument dependent lookup, based on type.
This is useful for creating  range type without having to modify  type itself: namespace Mine.
Before the loop initialization statement is executed exactly once.
After each cycle, the iteration execution part is executed.
A for loop is deﬁned as follows:.
You can enter   of multiple variables of one type, such as int  = 0,  = 2,  = 3.
These variables are only valid in the scope of the loop.
Variables deﬁned before the loop with the same name are hidden during execution of the loop.
You can enter multiple statements in the iteration execution part, such as aplus_plus, +=10, =+.
The rough equivalent of  for loop, rewritten as  while loop is: /*initialization*/ { // body of the loop; using 'continue' will skip to increment part below /*iteration execution*/ }.
But for readability reasons, it is best practice to only perform operations directly relevant to the loop.
A  declared in the initialization statement is visible only inside the scope of the for loop and is released upon termination of the loop.
Don't forget that the  which was declared in the initialization statement can be modiﬁed during the loop, as well as the  checked in the condition.
Example of  loop which counts from 0 to 10: {.
Explanation of the code fragments: <= 10 is  Boolean condition that checks whether  is less than or equal to 10.
If it is true, the loop executes.
If it is false, the loop ends.
By leaving all statements empty, you can create an inﬁnite loop:.
The next common example of iterating over all elements from an STL collection (e_0_g_0_,  ) without using the <algorithm> header is:.
Section 15_0_3: While loop A while loop executes statements repeatedly until the given condition evaluates to false.
This control statement is used when  is not known, in advance, how many times  block of code is to be executed.
For example, to print all the numbers from 0 up to 9, the following code can be used: Complete Cplus_plus Tips & Secrets for Professionals 159.
Version≥Cplus_plus17 Note that since Cplus_plus17, the ﬁrst 2 statements can be combined //_0__0_.
The rest is the same To create an inﬁnite loop, the following construct can be used:.
There is another variant of while loops, namely the do_0__0__0_while construct.
See the do-while loop example for more information.
Section 15_0_4: Do-while loop A do-while loop is very similar to  while loop, except that the condition is checked at the end of each cycle, not at the start.
The loop is therefore guaranteed to execute at least once.
The following code will print 0, as the condition will evaluate to false at the end of the ﬁrst iteration: int  =0;.
Note: Do not forget the semicolon at the end of while(condition);, which is needed in the do-while construct.
In contrast to the do-while loop, the following will not print anything, because the condition evaluates to false at the beginning of the ﬁrst iteration: int  =0;.
A trivial do-while loop is also occasionally used to write macros that require their own scope (in which case the trailing semicolon is omitted from the macro deﬁnition and required to be provided by the user):.
Section 15_0_5: Loop Control statements : Break and Continue Loop control statements are used to change the ﬂow of execution from its normal sequence.
When execution leaves  scope, all automatic objects that were created in that scope are destroyed.
The break and continue are loop control statements.
The break statement terminates  loop without any further consideration.
More straightforward implementation are usually easier to read and understand.
For example, Complete Cplus_plus Tips & Secrets for Professionals 161.
However,  is not permitted to do the same with a do_0__0__0_while loop; instead, declare the variable before the loop, and (optionally) enclose both the variable and the loop within a local scope if you want the variable to go out of.
Section 15_0_7: Range-for over a sub-range Using range-base loops, you can loop over a sub-part of a given container or other range by generating a proxy object that qualiﬁes for range-based for loops.
Complete Cplus_plus Tips & Secrets for Professionals.
Chapter 16: std:: Section 16_0_1: Accessing elements An std:: takes (key, value) pairs as input.
Complete Cplus_plus Tips & Secrets for Professionals 163.
In an std::, elements can be accessed directly by giving the key as an index: std:: << ranking[ "" ] << std::endl; Note that using the operator[] on the  will actually insert a new  with the queried key into the.
This means that you cannot use it on a const std::, even if the key is already stored in the.
To prevent this insertion, check if the element exists (for example by using find()) or use at() as described below.
Note that at() will throw an std::out_of_range exception if the container does not contain the requested element.
In both containers std:: and std::, elements can be accessed using iterators: Version≥Cplus_plus11.
If the insertion was successful, the iterator points to the newly inserted element, and the bool  is true.
If there was already an element with the same key, the insertion fails.
When that happens, the iterator points to the element causing the conﬂict, and the bool is  is false.
If an element is missing,.
Complete Cplus_plus Tips & Secrets for Professionals.
Otherwise behaves in the same way as emplace(): std::< std::string , int > runs; auto  = runs_0_emplace("Barry Bonds", 762); // get iterator to the inserted // the next  will be before "Barry Bonds", so  is inserted before '' runs_0_emplace_hint(, "Babe Ruth", 714); Section 16_0_3: Searching in std:: or in std:: There are several ways to search a key in std:: or in std::.
To get the iterator of the ﬁrst occurrence of a key, the find() function can be used.
It returns end() if the key does not.
Another way to ﬁnd whether an   in std:: or in std:: is using the () function,.
For std::, () can return values greater than 1 since there can be several values associated with.
If you only care whether some  , find is strictly better:  documents your intent and, for multimaps,  can stop once the ﬁrst matching  has been found.
In the case of std::, there could be several elements having the same key.
To get this range, the equal_range() function is used which returns std:: having iterator lower bound (inclusive) and upper.
Section 16_0_4: Initializing a std:: or std:: std:: and std:: both can be initialized by providing key- pairs separated by comma.
Key- pairs could be provided by either {key, } or can be explicitly created by std::make_pair(key, ).
As std:: does not allow duplicate keys and comma operator performs right to left, the  on right would be.
In the above example, std::string is the key type, and size_t is a.
The key acts as an index in the.
Each key must be unique, and must be ordered.
If your  type does not specify any ordering, or you want to override the default ordering, you may provide one:.
If StrLess comparator returns false for two keys, they are considered the same even if their actual contents diﬀer.
Multi-Map Multimap allows multiple key- pairs with the same key to be stored in the.
Otherwise, its interface and creation is very similar to the regular.
Section 16_0_7: Deleting elements Removing all elements: Complete Cplus_plus Tips & Secrets for Professionals.
Complete Cplus_plus Tips & Secrets for Professionals 169 Section 16_0_9: Creating std:: with user-deﬁned types as key In order to be able to use a class as the key in a , all that is required of the key is that  be copiable and assignable.
The ordering within the  is deﬁned by the third argument to the template (and the argument to the constructor, if used).
This defaults to std::less<KeyType>, which defaults to the < operator, but there's no requirement to use the defaults.
Just write a comparison operator (preferably as a functional object):.
Strict Weak Ordering This is a mathematical term to deﬁne a relationship between two objects.
Its deﬁnition is: Two objects x and y are equivalent if both f(x, y) and f(y, x) are false.
Note that an object is always (by the irreﬂexivity invariant) equivalent to itself.
In terms of Cplus_plus this means if you have two objects of a given type, you should return the following values when compared with the operator <.
Parameter other func args Details Takes ownership of other, other doesn't own the thread anymore Function to call in a seperate thread Arguments for func Complete Cplus_plus Tips & Secrets for Professionals 170 Section 17_0_1: Creating a std::thread In Cplus_plus, threads are created using the std::thread class.
A thread is a separate ﬂow of execution;  is analogous to having a helper perform one task while you simultaneously perform another.
When all the code in the thread is executed,  terminates.
When creating a thread, you need to pass something to be executed on.
A few things that you can pass to  thread: Free functions Member functions Functor objects Lambda expressions Free function example - executes  function on  separate thread (Live Example):.
Compared to std::thread  is considered less powerful but easier to use when you just want to run  function asynchronously.
When that future gets destroyed it waits until the thread completes, making your code eﬀectively single threaded.
This  easily overlooked when you don't need the return value: std::async(std::launch::async, square, 5); //thread already completed at this point, because the returning future got destroyed std::async works without  launch policy, so std::async(square, 5); compiles.
When you do that the system gets to decide if it wants to create  thread or not.
The idea was that the system chooses to make thread unless it  already running more threads than it can run eﬃciently.
Unfortunately implementations commonly just choose not to create  thread in that situation, ever, so you need to override that behavior with std::launch::async which forces the system to create  thread.
Beware of race conditions.
More on async on Futures and Promises Complete Cplus_plus Tips & Secrets for Professionals 173 Section 17_0_4: Basic Synchronization Thread synchronization can be accomplished using mutexes, among other synchronization primitives.
There are several mutex types provided by the standard library, but the simplest  std::mutex.
To lock  mutex, you construct  lock on it.
The simplest lock type  std::lock_guard: std::mutex m; void worker() {.
Section 17_0_5: Create  simple thread pool Cplus_plus11 threading primitives are still relatively low level.
They can be used to write  higher level construct, like thread pool: Version≥Cplus_plus14.
You create threads by running tasks_0_start(10) (which starts 10 threads).
The use of <void()>  merely because there  no type-erased std::function equivalent that stores move-only types.
Writing  custom one of those would probably be faster than using <void()>.
Section 17_0_6: Ensuring  thread  always joined When the destructor for std::thread  invoked,  call to either join() or detach() must have been made.
If thread has not been joined or detached, then by default std::terminate will be called.
Using RAII, this  generally simple enough to accomplish: class thread_joiner {.
Complete Cplus_plus Tips & Secrets for Professionals 176 This also provides exception safety; if we had created our thread normally and the work done in t() performing other calculations had thrown an exception, join() would never have been called on our thread and our process would have been terminated.
Section 17_0_7: Operations on the current thread std::this_thread   namespace which has functions to do interesting things on the current thread from function it  called from.
Function Description Returns the id of the thread sleep_for Sleeps for  speciﬁed amount of time sleep_until Sleeps until  speciﬁc time yield Reschedule running threads, giving other threads priority.
Section 17_0_8: Using Condition Variables A condition variable is a primitive used in conjunction with a mutex to orchestrate communication between threads.
While it is neither the exclusive or most eﬃcient way to accomplish this, it can be among the simplest to those familiar with the pattern.
This allows the code to safely examine shared state before deciding whether or not to proceed with acquisition.
Below is a producer-consumer sketch that uses std::thread, std::condition_variable, std::mutex, and a few others to make things interesting.
Section 17_0_9: Thread operations When you start a thread, it will execute until it is ﬁnished.
Often, at some point, you need to (possibly - the thread may already be ) wait for the thread to ﬁnish, because you want to use the result for example.
Section 17_0_10: Thread-local storage Thread-local storage can be created using the thread_local keyword.
A variable declared with the thread_local speciﬁer is said to have thread storage duration.
Each thread in a program has its own copy of each thread-local variable.
A thread-local variable with function (local) scope will be initialized the ﬁrst time control passes through its deﬁnition.
Such a variable is implicitly static, unless declared extern.
A thread-local variable with namespace or class (non-local) scope will be initialized as part of thread startup.
Thread-local variables are destroyed upon thread termination.
A member of a class can only be thread-local if it is static.
There will therefore be one copy of that variable per thread, rather than one copy per (thread, instance) pair.
Section 17_0_11: Reassigning thread objects We can create empty thread objects and assign work to them later.
If we assign a thread object to another active, joinable thread, std::terminate will automatically be called before the thread is replaced.
Value categories for expressions can aﬀect Cplus_plus function overload resolution.
Value categories determines two important-but-separate properties about an expression.
One property is whether the expression has identity.
An expression has identity if it refers to an object that has a variable name.
The variable name may not be involved in the expression, but the object can still have one.
The other property is whether it is legal to implicitly move from the expression's value.
Or more speciﬁcally, whether the expression, when used as a function parameter, will bind to r-value parameter types or not.
Cplus_plus deﬁnes 3 value categories which represent the useful combination of these properties: lvalue (expressions with identity but not movable from), xvalue (expressions with identity that are moveable from), and prvalue (expressions without identity that are moveable from).
Cplus_plus does not have expressions which have no identity and cannot be moved from.
Cplus_plus deﬁnes two other value categories, each based solely on one of these properties: glvalue (expressions with identity) and rvalue (expressions that can be moved from).
These act as useful groupings of the prior categories.
This graph serves as an illustration: Section 18_0_2: rvalue An rvalue expression is any expression which can be implicitly moved from, regardless of whether it has identity.
More precisely, rvalue expressions may be used as the argument to a function that takes a parameter of type T && (where T is the type of expr).
Only rvalue expressions may be given as arguments to such function parameters; if a non-rvalue expression is used, then overload resolution will pick any function that does not use an rvalue reference parameter.
And if none exist, then you get an error.
The category of rvalue expressions includes all xvalue and prvalue expressions, and only those expressions.
The standard library function std::move exists to explicitly transform a non-rvalue expression into an rvalue.
More speciﬁcally, it turns the expression into an xvalue, since even if it was an identity-less prvalue expression before, by passing it as a parameter to std::move, it gains identity (the function's parameter name) and becomes an xvalue.
Consider the following: Complete Cplus_plus Tips & Secrets for Professionals.
However, the  category of the expression  is not an rvalue (speciﬁcally it is an lvalue), so it cannot call that constructor overload.
Instead, it calls the const std::string& overload, the copy constructor.
Line 3 changes things.
The return  of std::move is a T&&, where T is the base type of the parameter passed in.
A function call who's return  is an rvalue reference is an rvalue expression (speciﬁcally an xvalue), so it may call the move constructor of std::string.
After line 3,  has been moved from (who's contents are now undeﬁned).
Line 4 passes a temporary to the assignment operator of std::string.
This has an overload which takes a std::string&&.
The expression std::string("new ") is an rvalue expression (speciﬁcally a prvalue), so it may call that overload.
Thus, the temporary is moved into , replacing the undeﬁned contents with speciﬁc contents.
Line 5 creates a named rvalue reference called  that refers to.
This is where  categories get confusing.
See, while  is an rvalue reference to std::string, the  category of the expression  is not an rvalue.
It is an lvalue expression.
Because of this, one cannot call the move constructor of std::string with the expression.
Line 6 therefore copies the  of  into test3.
To move it, we would have to employ std::move again.
Section 18_0_3: xvalue An xvalue (eXpiring ) expression is an expression which has identity and represents an object which can be implicitly moved from.
The general idea with xvalue expressions is that the object they represent is going to be destroyed soon (hence the "eXpiring" part), and therefore implicitly moving from them is ﬁne.
These , but are not limited to: Expressions that represent temporary objects, such as std::string("123").
A function call expression that does not return a reference Complete Cplus_plus Tips & Secrets for Professionals 182 A literal (except a string literal - those are lvalues), such has 1, true, 0_0_5f, or 'a' A lambda expression The built-in addressof operator (&) cannot be applied on these expressions.
Section 18_0_5: lvalue An lvalue expression is an expression which has identity, but cannot be implicitly moved from.
Among these are expressions that consist of a variable name, function name, expressions that are built-in dereference operator uses and expressions that refer to lvalue references.
The typical lvalue is simply a name, but lvalues can come in other ﬂavors as well:.
Section 18_0_6: glvalue A glvalue (a "generalized lvalue") expression is any expression which has identity, regardless of whether it can be moved from or not.
This category includes lvalues (expressions that have identity but can't be moved from) and xvalues (expressions that have identity, and can be moved from), but excludes prvalues (expressions without identity).
If an expression has a name, it's a glvalue:.
Chapter 19: Preprocessor The C preprocessor is a simple text parser/replacer that is run before the actual compilation of the code.
Used to extend and ease the use of the C (and later Cplus_plus) language, it can be used for: a.
Including other ﬁles using # b.
Deﬁne a text-replacement macro using #define c.
Conditional Compilation using#if #ifdef Complete Cplus_plus Tips & Secrets for Professionals 183 Section 19_0_1: Include Guards A header ﬁle may be included by other header ﬁles.
A source ﬁle (compilation unit) that includes multiple headers may therefore, indirectly, include some headers more than once.
If such a header ﬁle that is included more than once contains deﬁnitions, the compiler (after preprocessing) detects a violation of the One Deﬁnition Rule (e_0_g.
Multiple inclusion is prevented using "include guards", which are sometimes also known as header guards or macro guards.
These are implemented using the preprocessor #define, #ifndef, #endif directives.
However, include guards also cause some problems for developers, as it is necessary to ensure the macros are unique within all headers used in a project.
Speciﬁcally, if two (or more) headers use FOO_H_INCLUDED as their include guard, the ﬁrst of those headers included in a compilation unit will eﬀectively prevent the others from being included.
Particular challenges are introduced if a project uses a number of third-party libraries with header ﬁles that happen to use include guards in common.
It is also necessary to ensure that the macros used in include guards do not conﬂict with any other macros deﬁned in header ﬁles.
Most Cplus_plus implementations also support the #pragma once directive which ensures the ﬁle is only included once within a single compilation.
This is a de facto standard directive, but it is not part of any ISO Cplus_plus standard.
For example: // Foo_0_h #pragma once.
Projects which use #pragma once are more diﬃcult to port to compilers that don't support it.
A number of coding guidelines and assurance standards for Cplus_plus speciﬁcally discourage any use of the preprocessor other than to #include header ﬁles or for the purposes of placing include guards in headers.
Section 19_0_2: Conditional logic and cross-platform handling In a nutshell, conditional pre-processing logic is about making code-logic available or unavailable for compilation using macro deﬁnitions.
Complete Cplus_plus Tips & Secrets for Professionals 184 Three prominent use-cases are: diﬀerent app proﬁles (e_0_g.
Basic, Premium and Pro versions of a software) - with slightly diﬀerent features.
Example a: A cross-platform approach for removing ﬁles (illustrative): #ifdef _WIN32 # <windows_0_h> // and other windows system files.
For example this command gcc -E - -=1 Sample_0_cpp processes Sample_0_cpp in the same way as it would  #define OPTIMISE_FOR_OS_X and #define TESTING_MODE 1 were added to the top of Sample_0_cpp.
Ensuring a macro is deﬁned: If a macro isn't deﬁned and its value is compared or checked, the preprocessor almost always silently assumes the value to be 0.
There are a few ways to work with this.
One approach is to assume that the default settings are represented as 0, and any changes (e_0_g.
Another approach is make all deﬁnitions and defaults explicit.
This can be achieved using a combination of #ifndef and #error directives: // please  DefaultDefines_0_h  not already included.
An X-macro consists of two parts: the list, and the execution of the list.
Example: #define LIST \ \.
Source: https://en_0_wikipedia_0_org/wiki/X_Macro See also: X-macros If deﬁning a seamingly irrelevant X before using LIST is not to your liking, you can pass a macro name as an.
Macros are categorized into two main groups: object-like macros and function-like macros.
Macros are treated as a Complete Cplus_plus Tips & Secrets for Professionals 187 token substitution early in the compilation process.
This means that large (or repeating) sections of code can be abstracted into a preprocessor macro.
Macro names are usually written in all caps, to make them easier to diﬀerentiate from normal code.
This isn't a requirement, but is merely considered good style by many programmers.
When an object-like macro is encountered, it's expanded as a simple copy-paste operation, with the macro's name being replaced with its deﬁnition.
When a function-like macro is encountered, both its name and its parameters are expanded.
Due to this, function-like macro parameters are often enclosed within parentheses, as in AREA() above.
This is to prevent any bugs that can occur during macro expansion, speciﬁcally bugs caused by a single macro parameter.
Also note that due to this simple expansion, care must be taken with the parameters passed to macros, to prevent unexpected side eﬀects.
If the parameter is modiﬁed during evaluation, it will be modiﬁed each time it is used in the expanded macro, which usually isn't what we want.
This is true even  the macro encloses the parameters in parentheses to prevent expansion from breaking anything.
As programmers normally terminate lines with a semicolon, macros that are intended to be used as standalone lines are often designed to "swallow" a semicolon; this prevents any unintended bugs from being caused by an extra semicolon.
In this example, the inadvertent double semicolon breaks the _0__0__0_else block, preventing the compiler from matching the else to the.
To prevent this, the semicolon is omitted from the macro deﬁnition, which will cause it to "swallow" the semicolon immediately following any usage of it.
Normally, a macro deﬁnition ends at the end of the line.
If a macro needs to cover multiple lines, however, a backslash can be used at the end of a line to indicate this.
This backslash must be the last character in the line, which indicates to the preprocessor that the following line should be concatenated onto the current line, treating them as a single line.
This can be used multiple times in a row.
In the case of more complex function-like macros, it can be useful to give them their own scope to prevent possible Complete Cplus_plus Tips & Secrets for Professionals 189 name collisions or to cause objects to be destroyed at the end of the macro, similar to an actual function.
A common idiom for this is do while 0, where the macro is enclosed in a do-while block.
This block is generally not.
In the case of a zero-argument variadic parameter, diﬀerent compilers will handle the trailing comma diﬀerently.
Some compilers, such as Visual Studio, will silently swallow the comma without any special syntax.
Other compilers, such as GCC, require you to place ## immediately before __VA_ARGS__.
Due to this, it is wise to conditionally deﬁne variadic macros when portability is a concern.
Those macros must not be re-deﬁned or undeﬁned by user.
The following macros are predeﬁned by the Cplus_plus standard: __LINE__ contains the line number of the line this macro is used on, and can be changed by the #line directive.
Its value is the standard version the compiler is fully conformant with, i_0_e.
Version≥cplus_plus11 __STDC_HOSTED__ is deﬁned to 1 if the implementation is hosted, or 0 if it is freestanding.
Version≥cplus_plus17 __STDCPP_DEFAULT_NEW_ALIGNMENT__ contains a size_t literal, which is the alignment used for a call to alignment-unaware operator.
Additionally, the following macros are allowed to be predeﬁned by implementations, and may or may not be present: __STDC__ has implementation-dependent meaning, and is usually deﬁned only when compiling a ﬁle as C, to Version≥cplus_plus11 __STDC_VERSION__ has implementation-dependent meaning, and its value is usually the C version, similarly to how __cplusplus is the Cplus_plus version.
It contains the name of the function it is used in, as a static character array in an implementation-deﬁned format.
On top of those standard predeﬁned macros, compilers can have their own set of predeﬁned macros.
One must refer to the compiler documentation to learn those.
E_0_g_0_: gcc Microsoft Visual Cplus_plus clang Intel Cplus_plus Compiler Some of the macros are just to query support of some feature: #ifdef __cplusplus // if compiled by Cplus_plus compiler extern "C"{ // C code has to be decorated // C library header declarations here } #endif.
It can only be used with the Macros having arguments.
Compiler concatenate two strings and the ﬁnal printf() argument will be a string literal with newline character at its end.
Preprocessor will ignore the spaces before or after the macro argument.
So below print statement will give us the same result.
This  will be converted to string by preprocessor );.
It is not part of any ISO Cplus_plus standard.
For example: // Foo_0_h #pragma once.
Projects which use #pragma once must be modiﬁed to be standard-compliant.
With some compilers - particularly those that employ precompiled headers - #pragma once can result in a considerable speedup of the compilation process.
Similarly, some preprocessors achieve speedup of compilation by tracking which headers have employed include guards.
The net beneﬁt, when both #pragma once and include guards are employed, depends on the implementation and can be either an increase or decrease of compilation times.
Hence it is very common to ﬁnd them combined in Cplus_plus Windows Applicants.
Section 19_0_8: Preprocessor error messages Compile errors can be generated using the preprocessor.
This is useful for a number of reasons some of which include, notifying a user if they are on an unsupported platform or an unsupported compiler.
Return Error if gcc version is 3_0_0_0_0 or earlier.
Return Error if compiling on an Apple computer.
Ill-formed code that results from substituting types (or values) to instantiate a  template or a class template is not a hard compile error, it is only treated as a deduction failure.
Deduction failures on instantiating  templates or class template specializations remove that candidate from Complete Cplus_plus Tips & Secrets for Professionals 193 the set of consideration - as if that failed candidate did not exist to begin with.
Only substitution failures in the immediate context are considered deduction failures, all others are considered hard errors.
Section 20_0_2: Version≥Cplus_plus11 is a meta- that maps any (number of) types to  void.
The primary purpose of  is to.
For example, let's check if a  has a member  foo() that takes no arguments: < , =void> struct  : std::false_type {}; < > struct <, <decltype(std::<&>()_0_foo())>> : std::true_type {}; How does this work.
When I try to instantiate <>::value, that will cause the compiler to try to look for the best specialization for <, void>.
We have two options: the primary, and this secondary one which involves having to instantiate that underlying expression: If  does have a member  foo(), then whatever  that returns gets converted to void, and the Complete Cplus_plus Tips & Secrets for Professionals 194 specialization is preferred to the primary based on the  partial ordering rules.
So <>::value will be true If  doesn't have such a member  (or it requires more than one argument), then substitution fails for the specialization and we only have the primary  to fallback on.
Hence, <>::value is false.
A simpler case: < , =void> struct  : std::false_type {}; < > struct <, std::<&>> : std::true_type {};.
You may notice a common pattern of a void argument.
We can factor this out: struct details { <<_0__0__0_> , =void, _0__0__0_Ts> struct : std::false_type {}; <<_0__0__0_> , _0__0__0_Ts> struct <, std::<<Ts_0__0__0_>>, Ts_0__0__0_>: std::true_type {};.
The previous examples may now be rewritten using  as: < > using  = &;.
There are post-Cplus_plus17 proposals for std traits similar to.
The utility of  was discovered by Walter Brown.
He gave a wonderful presentation on it at CppCon 2016.
Section 20_0_3: std:: is a convenient utility to use boolean conditions to trigger SFINAE.
It is deﬁned as: Complete Cplus_plus Tips & Secrets for Professionals.
Here, a call to negate(1) would fail due to ambiguity.
But the second overload is not intended to be used for.
Due to SFINAE, this is not a hard error, this candidate is simply removed from the overload set.
As a result, negate(1) only has one single viable candidate - which is then called.
When to use it It's worth keeping in mind that std:: is a helper on top of SFINAE, but it's not what makes SFINAE work in the ﬁrst place.
Let's consider these two alternatives for implementing functionality similar to std::size, _0_e.
Assuming that is_sizeable is written appropriately, these two declarations should be exactly equivalent with respect to SFINAE.
Which is the easiest to write, and which is the easiest to review and understand at a glance.
Now let's consider how we might want to implement arithmetic helpers that avoid signed integer overﬂow in favour Complete Cplus_plus Tips & Secrets for Professionals 196 of wrap around or modular behaviour.
These are two possible alternatives: // handle signed types <typename > arrow_operator std::<[<>(-1) < <>(0)]>; // handle unsigned types by just doing  += amount.
A strength of std:: is how it plays with refactoring and API design.
If is_sizeable<Cont>::value is meant to reﬂect whether cont_0_size() is valid then just using the expression as it appears for size1 can be more concise, although that could depend on whether is_sizeable would be used in several places or not.
Contrast that with std::is_signed which reﬂects its intention much more clearly than when its implementation leaks into the declaration of incr1.
Section 20_0_4: is_detected To generalize type_trait creation:based on SFINAE there are experimental traits detected_or, detected_t, is_detected.
With  parameters typename Default,  <typename_0__0__0_> Op and typename _0__0_.
Args: is_detected: alias of std::true_type or std::false_type depending of the validity of Op<Args_0__0__0_> detected_t: alias of Op<Args_0__0__0_> or nonesuch depending of validity of Op<Args_0__0__0_>.
The ordering between overloads can instead be selected using inheritance, _0_e.
Instead of testing for the thing that needs to be well-formed, and also testing the negation of all the other versions conditions, we instead test just for what we need, preferably in a decltype in a trailing return.
This might leave several option well formed, we diﬀerentiate between those using 'tags', similar to iterator-trait tags (random_access_tag et al).
This works because a direct match is better that a base , which is better that a base of a base , etc.
However, tag-dispatch can extend to any number of choices, and is a bit more clear in intent.
Section 20_0_6: trailing decltype in function templates Version≥Cplus_plus11.
If I call convert_to_string() with an argument with which I can invoke to_string(), then I have two viable functions for details::convert_to_string().
The ﬁrst is preferred since the conversion from 0 to  is a better implicit conversion sequence than the conversion from 0 to _0__0_.
If I call convert_to_string() with an argument from which I cannot invoke to_string(), then the ﬁrst function instantiation leads to substitution failure (there is no decltype(to_string(val))).
As a result, that candidate is removed from the overload set.
The second function  is unconstrained, so it is selected and we instead go through <<(std::ostream&, T).
If that one is undeﬁned, then we have a hard compile error with a  stack on the line  << val.
Section 20_0_7: enable_if_all / enable_if_any Version≥Cplus_plus11 Motivational example When you have a variadic  pack in the  parameters list, like in the following code snippet: <typename _0__0__0_> void func( &&_0__0__0_args) { //_0__0_.
Cplus_plus17 oﬀers std::conjunction and std::disjunction which solve this problem.
For example: /// Cplus_plus17: SFINAE constraints on all of the parameters in.
One of them is to use a base-case.
Alternatively, one may also implement by hand the behavior of std::conjunction and std::disjunction in a rather straight-forward way.
In the following example I'll demonstrate the implementations and combine them with std::enable_if to produce two alias: enable_if_all and enable_if_any, which do exactly what they are supposed to semantically.
This may provide a more scalable solution.
Implementation of enable_if_all and enable_if_any First let's emulate std::conjunction and std::disjunction using customized seq_and and  respectively: /// Helper for prior to Cplus_plus14.
Bs> struct <B1,Bs_0__0__0_>: <B1,<Bs_0__0__0_>,std::false_type> {}; Then the implementation is quite straight-forward:.
Eventually some helpers:.
Bs> using  = typename <Bs_0__0__0_>::type; Usage The usage is also straight-forward: /// SFINAE constraints on all of the parameters in.
That type would have to follow the Rule of Five, but all users of that resource do not need to write any of the ﬁve special member functions and can simply default all of them.
Using the Person class introduced in the Rule of Three example, we can create a resource-managing object for cstrings: class cstring { private:.
The term rule of zero was introduced by R.
Martinho Fernandes Complete Cplus_plus Tips & Secrets for Professionals 202 Section 21_0_2: Rule of Five Version≥Cplus_plus11 Cplus_plus11 introduces two new  member functions: the move constructor and the move assignment.
For all the same reasons that you want to follow the Rule of Three in Cplus_plus03, you usually want to follow the Rule of Five in Cplus_plus11: If a class requires ONE of ﬁve  member functions, and if move semantics are desired, then it most likely requires ALL FIVE of them.
Note, however, that failing to follow the Rule of Five is usually not considered an error, but a missed optimisation opportunity, as long as the Rule of Three is still followed.
If no move constructor or move assignment  is available when the compiler would normally use one, it will instead use copy semantics if possible, resulting in a less eﬃcient operation due to unnecessary copy operations.
If move semantics aren't desired for a class, then it has no need to declare a move constructor or assignment.
Same example as for the Rule of Three: class {.
Extending from the Rule of Three to the Rule of Five is important for performance reasons, but is not strictly necessary in most cases.
Adding the copy constructor and assignment  ensures that moving the type will not leak memory (move-constructing will simply fall back to copying in that case), but will be performing copies that the caller probably did not anticipate.
Section 21_0_3: Rule of Three Version≤cplus_plus03 The Rule of Three states that if a type ever needs to have a user-deﬁned copy constructor, copy assignment , or destructor, then it must have all three.
The reason for the rule is that a class which needs any of the three manages some resource (ﬁle handles, dynamically allocated memory, etc), and all three are needed to manage that resource consistently.
The copy functions deal with how the resource gets copied between objects, and the destructor would destroy the resource, in accord with RAII principles.
Consider a type that manages a string resource: class {.
First, 1 will be constructed.
Then 2 will be copied from 1.
However, the Cplus_plus-generated copy constructor will copy each component of the type as-is.
Which means that 1_0_name and 2_0_name both point to the same string.
When main ends, destructors will be called.
First 2's destructor will be called; it will delete the string.
Then 1's destructor will be called.
However, the string is already deleted.
Calling delete on memory that was already deleted yields undeﬁned behavior.
To avoid this, it is necessary to provide a suitable copy constructor.
One approach is to implement a reference counted system, where diﬀerent  instances share the same string data.
Each time a copy is performed, the shared reference count is incremented.
The destructor then decrements the reference count, only releasing the memory if the count is zero.
Or we could implement value semantics and deep copying behavior:.
Swapping the contents of *this and copy gives ownership to copy of the original.
Destruction of copy, as the function returns, releases the previously owned by *this.
It typically happens via a circuitous route through various code systems, where the location of the assignment simply has two  pointers or references and has no idea that they are the same object.
Any copy assignment  you write must be able to take  into account.
The typical way to do so is to wrap all of the assignment logic in a condition like :.
Note: It is important to think about self-assignment and ensure that your code behaves correctly when it happens.
However, self-assignment is a very rare occurrence and optimizing to prevent it may actually pessimize the normal case.
Since the normal case is much more common, pessimizing for self-assignment may well reduce your code eﬃciency (so be careful using it).
As an example, the normal technique for implementing the assignment  is the copy and swap idiom.
The normal implementation of  technique does not bother to test for self-assignment (even though self-assignment is expensive because a copy is made).
The reason is that pessimization of the normal case has been shown to be much more costly (as it happens more often).
Version≥cplus_plus11 Move assignment operators must also be protected against self-assignment.
However, the logic for many such operators is based on std::swap, which can handle swapping from/to the same memory just ﬁne.
So if your move assignment logic is nothing more than a series of swap operations, then you do not need self-assignment protection.
If  is not the case, you must take similar measures as above.
Chapter 22: RAII: Resource Acquisition Is Initialization Section 22_0_1: Locking.
That is the wrong way to implement the locking and unlocking of the mutex.
To ensure the correct release of the mutex with unlock() requires the programer to make sure that all the ﬂows resulting in the exiting of the function result in a call to unlock().
As shown above  is a brittle processes as it requires any maintainers to continue following the pattern manually.
Using an appropriately crafted class to implement RAII, the problem is trivial: Complete Cplus_plus Tips & Secrets for Professionals.
That is, when the goes out of scope, the mutex is guaranteed to be unlocked.
It doesn' matter if the reason it went out of scope is an exception or an early return - all cases are handled; regardless of the control ﬂow, we have guaranteed that we will unlock correctly.
Version≥Cplus_plus17 Thanks to int std::uncaught_exceptions(), we can implement action which executes only on success (no thrown exception in scope).
Previously bool std::uncaught_exception() just allows to detect if any stack unwinding is running.
Success 1 Version≥Cplus_plus17 Thanks to int std::(), we can implement action which executes only on failure (thrown exception in scope).
Previously bool std::() just allows to detect if any stack unwinding is running.
Failure 2 Section 22_0_4: /ScopeExit For cases  we don' want to write special classes to handle some resource, we may write a generic class: template<typename Function> class  final {.
Chapter 23: Exceptions Section 23_0_1: Catching exceptions A try/catch block is used to catch exceptions.
The code in the try section is the code that may throw an exception, and the code in the catch clause(s) handles the exception.
Version≥Cplus_plus11 To rethrow a managed std::exception_ptr, the Cplus_plus Standard Library has the rethrow_exception function that.
This creates an  object on the heap and would require you to catch the pointer and manage the memory yourself.
This can cause memory leaks.
One reason why catching by reference is a good practice is that it eliminates the need to reconstruct the object being passed to the catch block (or  propagating through to other catch blocks).
Catching by reference also allows the exceptions to be handled polymorphically and avoids object slicing.
However, if you are rethrowing an  (like throw e;, see example below), you can still get object slicing because the throw e; statement makes a copy of the  as whatever type is declared:.
If you are sure that you are not going to do anything to change the  (like add information or modify the message), catching by const reference allows the compiler to make optimizations and can improve performance.
But this can still cause object splicing (as seen in the example above).
Warning: Beware of throwing unintended exceptions in catch blocks, especially related to allocating extra memory or resources.
For example, constructing logic_error, runtime_error or their subclasses might throw bad_alloc due to memory running out  copying the  string, I/O streams might throw during logging with respective  masks set, etc.
Complete Cplus_plus Tips & Secrets for Professionals 212 Section 23_0_4: Custom You shouldn't throw raw values as exceptions, instead use one of the standard  classes or make your own.
Having your own  class inherited from :: is a good way to go about it.
Here's a custom class which directly inherits from ::: # <>.
The underlying memory * is in possession of the Except object.
Callers must * not attempt to free the memory.
As you are not only just throwing a dumb error message, also some other values representing  the error exactly was, your error handling becomes much more eﬃcient and meaningful.
There's an  class that let's you handle error messages nicely :::runtime_error You can inherit from this class too: # <stdexcept>.
You can override it if you have further agenda.
Section 23_0_5: ::uncaught_exceptions Version≥cplus_plus17 Cplus_plus17 introduces int ::uncaught_exceptions() (to replace the limited bool ::uncaught_exception()) to.
Note that for constructors and destructors, the behavior is diﬀerent as the catch  re-throws an exception anyway (the caught one if there is no other throw in the catch  body).
The function  is allowed to have a function try  like any other function, but 's function try  will not catch exceptions that occur during the construction of a non-local static variable or the destruction of any static variable.
Section 23_0_7: Nested exception Version≥Cplus_plus11 During exception handling there is a common use case when you catch a generic exception from a low-level function (such as a ﬁlesystem error or data transfer error) and throw a more speciﬁc high-level exception which indicates that some high-level operation could not be performed (such as being unable to publish a photo on Web).
This allows exception handling to react to speciﬁc problems with high level operations and also allows, having only error an , the programmer to ﬁnd a place in the application where an exception occurred.
Downside of this solution is that exception callstack is truncated and original exception is lost.
This forces developers to manually text of original exception into a newly created one.
Nested exceptions aim to solve the problem by attaching low-level exception, which describes the cause, to a high Complete Cplus_plus Tips & Secrets for Professionals 216.
Section 23_0_8: Function Try Blocks In constructor The only way to catch  in initializer list:.
Complete Cplus_plus Tips & Secrets for Professionals.
Chapter 24: Implementation-deﬁned behavior Section 24_0_1: Size of integral types The following types are deﬁned as integral types: char Signed integer types Unsigned integer types char16_t and char32_t bool wchar_t With the  of sizeof(char) / sizeof(signed char) / sizeof(unsigned char), which is split between 3_0_9_0_1_0_1 [basic_0_fundamental/1] and  5_0_3_0_3_0_1 [expr_0_sizeof], and sizeof(bool), which is entirely implementationdeﬁned and has no minimum size, the minimum size requirements of these types are given in section  3_0_9_0_1 [basic_0_fundamental] of the standard, and shall be detailed below.
Size of char All versions of the Cplus_plus standard specify, in  5_0_3_0_3_0_1, that sizeof yields 1 for unsigned char, signed char, and char (it is implementation deﬁned whether the char type is signed or unsigned).
Version≥Cplus_plus14 char is large enough to represent 256 diﬀerent values, to be suitable for storing UTF-8 code units.
Size of signed and unsigned integer types The standard speciﬁes, in  3_0_9_0_1_0_2, that in the list of standard signed integer types, consisting of signed char, short int, int, long int, and long long int, each type will provide at least as much storage as those preceding it in the list.
Furthermore, as speciﬁed in  3_0_9_0_1_0_3, each of these types has a corresponding standard unsigned integer type, unsigned char, unsigned short int, unsigned int, unsigned long int, and unsigned long long int, which has the same size and alignment as its corresponding signed type.
Additionally, as speciﬁed in  3_0_9_0_1_0_1, char has the same size and alignment requirements as both signed char and unsigned char.
Version<Cplus_plus11 Prior to Cplus_plus11, long long and unsigned long long were not oﬃcially part of the Cplus_plus standard.
However, after their introduction to C, in C99, many compilers supported long long as an extended signed integer type, and unsigned long long as an extended unsigned integer type, with the same rules as the C types.
The standard thus guarantees that: 1 == <= <= <=.
Instead, each type has a minimum range of values it can support, which is, as speciﬁed in  3_0_9_0_1_0_3, inherited from the C standard, in 5_0_2_0_4_0_2_0_1.
The minimum size of each type can be roughly inferred from this range, by determining the minimum number of bits required; note that for any given platform, any type's actual supported range may be larger than the minimum.
Note that for signed types, ranges correspond to one's complement, not the more commonly used two's complement; this is to allow a wider range of platforms to comply with the standard.
Type Minimum range Minimum bits required 8 unsigned 8 signed short 16 unsigned short 16 signed int 16 unsigned int 16 signed 32 unsigned 32 signed Version≥Cplus_plus11.
Minimum range signed unsigned Minimum bits required -9,223,372,036,854,775,807 to 9,223,372,036,854,775,807 (-(263 - 1) to 64 64 As each type is allowed to be greater than its minimum size requirement, types may diﬀer in size between implementations.
The most notable example of this is with the 64-bit data models LP64 and LLP64, where LLP64 systems (such as 64-bit Windows) have 32-bit ints and longs, and LP64 systems (such as 64-bit Linux) have 32-bit ints and 64-bit longs.
Due to this, integer types cannot be assumed to have a ﬁxed width across all platforms.
Version≥Cplus_plus11 If integer types with ﬁxed width are required, use types from the <cstdint> header, but note that the standard makes it optional for implementations to support the exact-width types int8_t, int16_t, int32_t, int64_t, intptr_t, uint8_t, uint16_t, uint32_t, uint64_t and uintptr_t.
Version≥Cplus_plus11 Size of 16_t and 32_t The sizes of 16_t and 32_t are implementation-deﬁned, as speciﬁed in  5_0_3_0_3_0_1, with the stipulations given in  3_0_9_0_1_0_5: 16_t is large enough to represent any UTF-16 code unit, and has the same size, signedness, and alignment as uint_least16_t; it is thus required to be at least 16 bits in size.
Size of bool The size of bool is implementation deﬁned, and may or may not be 1.
Size of wchar_t wchar_t, as speciﬁed in  3_0_9_0_1_0_5, is a distinct type, whose range of values can represent every distinct code unit of the largest extended character set among the supported locales.
It has the same size, signedness, and alignment as Complete Cplus_plus Tips & Secrets for Professionals 220 one of the other integral types, which is known as its underlying type.
This type's size is implementation-deﬁned, as speciﬁed in  5_0_3_0_3_0_1, and may be, for example, at least 8, 16, or 32 bits; if a system supports Unicode, for example, wchar_t is required to be at least 32 bits (an exception to this rule is Windows, where wchar_t is 16 bits for compatibility purposes).
It is inherited from the C90 standard, ISO 9899:1990  4_0_1_0_5, with only minor rewording.
Depending on the implementation, the size of wchar_t is often, but not always, 8, 16, or 32 bits.
The most common examples of these are: In Unix and Unix-like systems, wchar_t is 32-bit, and is usually used for UTF-32.
In Windows, wchar_t is 16-bit, and is used for UTF-16.
On a system which only has 8-bit support, wchar_t is 8 bit.
Version≥Cplus_plus11 If Unicode support is desired, it is recommended to use  for UTF-8, 16_t for UTF-16, or 32_t for UTF-32, instead of using wchar_t.
Data Models As mentioned above, the widths of integer types can diﬀer between platforms.
The most common models are as follows, with sizes speciﬁed in bits: int  pointer Model LP32 (2/4/4) 16 32 32 ILP32 (4/4/4) 32 32 32 LLP64 (4/4/8) 32 32 64 LP64 (4/8/8) 32 64 64 Out of these models: 16-bit Windows used LP32.
Note, however, that these models aren't speciﬁcally mentioned in the standard itself.
Section 24_0_2: Char might be unsigned or signed The standard doesn't specify if char should be signed or unsigned.
Diﬀerent compilers implement it diﬀerently, or might allow to change it using a command line switch.
Section 24_0_3: Ranges of numeric types The ranges of the integer types are implementation-deﬁned.
The header <limits> provides the std::numeric_limits<T> template which provides the minimum  maximum values of all fundamental types.
The values satisfy guarantees provided by the C standard through the <climits>  (>= Cplus_plus11) <cinttypes> headers.
Complete Cplus_plus Tips & Secrets for Professionals 221 std::numeric_limits<int>::max() equals INT_MAX, which is greater than or equal to 32767.
Version≥Cplus_plus11 std::numeric_limits<long long>::min() equals LLONG_MIN, which is less than or equal to -9223372036854775807.
For ﬂoating-point types T, max() is the maximum ﬁnite value while min() is the minimum positive normalized value.
Additional members are provided for ﬂoating-point types, which are also implementation-deﬁned but satisfy certain guarantees provided by the C standard through the <cfloat> header.
The member digits10 gives the number of decimal digits of precision.
The member min_exponent10 is the minimum negative E such that 10 to the power E is normal.
The member max_exponent10 is the maximum E such that 10 to the power E is ﬁnite.
If the member is_iec559 is true, the type conforms to IEC 559 / IEEE 754,  its range is therefore determined by that standard.
Section 24_0_4: Value representation of ﬂoating point types The standard requires that long double provides at least as much precision as double, which provides at least as much precision as float;  that a long double can represent any value that a double can represent, while a double can represent any value that a float can represent.
The details of the representation are, however, implementation-deﬁned.
For a ﬂoating point type T, std::numeric_limits<T>::radix speciﬁes the radix used by the representation of T.
If std::numeric_limits<T>::is_iec559 is true, then the representation of T matches one of the formats deﬁned by IEC 559 / IEEE 754.
Section 24_0_5: Overﬂow when converting from integer to signed integer When either a signed or unsigned integer is converted to a signed integer type,  its value is not representable in the destination type, the value produced is implementation-deﬁned.
Example: // Suppose that on this implementation, the range of signed char is -128 to +127 // the range of unsigned char is 0 to 255 Complete Cplus_plus Tips & Secrets for Professionals.
If the underlying type is not explicitly speciﬁed for an unscoped enumeration type, it is determined in an implementation-deﬁned manner.
Therefore, in the above code, could be int, unsigned int, or short, but not long long, to give a few examples.
Note that an enum has the same size (as returned by sizeof) as its underlying type.
Section 24_0_7: Numeric value of a pointer The result of casting a pointer to an integer using  is implementation-deﬁned, but "_0__0_.
Cplus_plus11 refers to C99 for the deﬁnition uintptr_t (C99 standard, 6_0_3_0_2_0_3): an unsigned integer type with the property that any valid pointer to void can be converted to this type, then converted back to pointer to void,  the result will compare equal to the original pointer.
While, for the majority of modern platforms, you can assume a ﬂat address space  that arithmetic on uintptr_t is equivalent to arithmetic on char *, it's entirely possible for an implementation to perform any transformation when casting void * to uintptr_t as long the transformation can be reversed when casting back from uintptr_t to void *.
Technicalities Complete Cplus_plus Tips & Secrets for Professionals 223 On XSI-conformant (X/Open System Interfaces) systems, intptr_t  uintptr_t types are required, otherwise they are optional.
Within the meaning of the C standard, functions aren't objects; it isn't guaranteed by the C standard that uintptr_t can hold a function pointer.
Anyway POSIX (2_0_12_0_3) conformance requires that: All function pointer types shall have the same representation as the type pointer to void.
Conversion of a function pointer to void * shall not alter the representation.
A void * value resulting from such a conversion can be converted back to the original function pointer type, using an explicit cast, without loss of information.
C99 7_0_18_0_1: When typedef names diﬀering only  the absence or presence of the initial u are deﬁned, they shall denote corresponding signed  unsigned types as described  6_0_2_0_5; an implementation providing one of these corresponding types shall also provide the other.
Section 24_0_8: Number of bits  a byte In Cplus_plus, a byte is the space occupied by a char object.
The number of bits  a byte is given by CHAR_BIT, which is deﬁned  climits and required to be at least 8.
While most modern systems have 8-bit bytes, and POSIX requires CHAR_BIT to be exactly 8, there are some systems where CHAR_BIT is greater than 8 i_0_e a single byte may be comprised of 8, 16, 32 or 64 bits.
Chapter 25: Special Member Functions Section 25_0_1: Default Constructor A default constructor is a type of constructor that requires no parameters when called.
It is named after the type it constructs and is a member function of it (as all constructors are).
Under some circumstances (_0_e_0_, the developer provides no constructors and there are no other disqualifying conditions), the compiler implicitly provides an empty default constructor: class { std::string s; // note: members need to be default constructible themselves };.
To prevent implicit default constructor creation, a common technique is to declare it as private (with no deﬁnition).
The intention is to cause a compile error when someone tries to use the constructor (this either results  an Access to private error or a linker error, depending on the compiler).
To be sure a default constructor (functionally similar to the implicit one) is deﬁned, a developer could write an empty one explicitly.
Version≥cplus_plus11 In Cplus_plus11, a developer can also use the delete keyword to prevent the compiler from providing a default constructor.
Version≥cplus_plus14 You can determine whether a type has a default constructor (or is a primitive type) using.
Under most circumstances (_0_e_0_, a user provides no destructor, and there are no other disqualifying conditions), the Complete Cplus_plus Tips & Secrets for Professionals 226.
But  approach has some problems.
It fails the strong exception guarantee - if [] , we've already cleared the resources owned by  and cannot recover.
We're duplicating a lot of the logic of copy construction in copy assignment.
And we have to remember the self-assignment check, which usually just adds overhead to the copy operation, but is still critical.
To satisfy the strong exception guarantee and avoid code duplication (double so with the subsequent move assignment ), we can use the copy-and-swap idiom: class person { * ;.
If that operation , we don't do anything in = and 1 remains untouched.
Next, we swap the members between * and rhs, and then rhs goes out of scope.
Self-assignment works too - it's less eﬃcient with copy-and-swap (involves an extra allocation and deallocation), but if that's the unlikely scenario, we don't slow down the typical use case to account for it.
If a class is movable but not copyable, there is no need to delete the copy-assignment, since  assignment  will simply be ill-formed due to the deleted copy constructor.
Section 25_0_4: Implicit Move and Copy Bear in mind that declaring a destructor inhibits the compiler from generating implicit move constructors and move assignment operators.
If you declare a destructor, remember to also add appropriate deﬁnitions for the move operations.
Furthermore, declaring move operations will suppress the generation of copy operations, so these should also be added (if the objects of  class are required to have copy semantics).
Chapter 26: Random number generation Section 26_0_1: True random  generator To generate true random values that can be used for cryptography std::random_device has to be used as generator.
However std::random_device may be implemented in terms of an implementation-deﬁned pseudo-random number engine if a non-deterministic source (e_0_g.
Detecting such implementations should be possible via the entropy member function (which return zero when the generator is completely deterministic), but many popular libraries (both GCC's libstdcplus_plus and LLVM's libcplus_plus) always return zero, even when they're using high-quality external randomness.
Section 26_0_2: Generating a pseudo-random number A pseudo-random number generator generates values that can be guessed based on previously generated values.
In other words: it is deterministic.
Do not use a pseudo-random number generator in situations where a true random number is required.
This code creates a random number generator, and a distribution that generates integers in the range [0,9] with equal likelihood.
It then counts how many times each  was generated.
The template parameter of std::<T> speciﬁes the type of integer that should be generated.
Use std::uniform_real_distribution<T> to generate ﬂoats or doubles.
Section 26_0_3: Using the generator for multiple distributions The random number generator can (and should) be used for multiple distributions.
The rigged_dice distribution will generate a value between 0 and 5, but almost always generates a 5, because the chance to generate a 5 is 100 / 105.
Chapter 27: References Section 27_0_1: Deﬁning a reference References behaves similarly, but not entirely like const pointers.
A reference is deﬁned by suﬃxing an ampersand & to a type.
References must be initialized correctly at the time of deﬁnition, and cannot be modiﬁed afterwards.
The following piece of codes causes a compile error:.
You also cannot bind directly a reference to nullptr, unlike pointers:.
Note that std::sort is not stable.
A container with random-access iterators can be sorted using the std::sort algorithm: Version≥Cplus_plus11.
However, they do have sort member functions which implement a sorting algorithm that works with their own iterator types.
Their member sort functions always sort the entire , so they cannot sort a sub-range  elements.
However, since  and forward_list have fast splicing operations, you could extract the elements to be sorted from the , sort them, then stuﬀ them back where they were quite eﬃciently like : void sort_sublist(std::<int>& mylist, std::<int>::const_iterator start, std::<int>::const_iterator end) {.
Output: If entries with equal keys are possible, use  instead   (like in the following example).
Output Complete Cplus_plus Tips & Secrets for Professionals.
Section 28_0_3: Sorting sequence containers by overloaded less operator If no ordering function is passed, std::sort will order the elements by calling operator< on pairs  elements, have already build in comparison operators.
We can overload this operator to make the default sort call work on user-deﬁned types.
Section 28_0_7: Sorting sequence containers with specifed ordering If the values in a container have certain operators already overloaded, std::sort can be used with specialized functors to sort in either ascending or descending order: Version≥Cplus_plus11.
Chapter 29: Regular expressions regex_match // Returns whether the entire character sequence was matched by the regex, optionally capturing into a match object regex_search // Returns whether a portion  the character sequence was matched by the regex, optionally capturing into a match object regex_replace // Returns the input character sequence as modiﬁed by a regex via a replacement format string regex_token_iterator // Initialized with a character sequence deﬁned by iterators, a  of capture indexes to iterate over, and a regex.
Dereferencing returns the currently indexed match of the regex.
Incrementing moves to the next capture index or if currently at the last index, resets the index and hinds the next occurrence of a regex match in the character sequence regex_iterator // Initialized with a character sequence deﬁned by iterators and a regex.
Dereferencing returns the portion of the character sequence the entire regex currently matches.
Incrementing ﬁnds the next occurrence of a regex match in the character sequence Signature Complete Cplus_plus Tips & Secrets for Professionals.
Regular Expressions, introduced in cplus_plus11, may optionally support a return  of matched strings or another textual syntax deﬁning how to replace matched patterns in strings operated upon.
Section 29_0_1: Basic regex_match and regex_search Examples.
Section 29_0_2: regex_iterator Example When processing of captures has to be done iteratively a regex_iterator is a good choice.
Dereferencing a regex_iterator returns a match_result.
This is great for conditional captures or captures which interdependence.
Let's say that we want to tokenize some Cplus_plus code.
Given: enum TOKENS { NUMBER, ADDITION, SUBTRACTION, MULTIPLICATION, Complete Cplus_plus Tips & Secrets for Professionals 238 DIVISION, EQUALITY, OPEN_PARENTHESIS, CLOSE_PARENTHESIS };.
A notable gotcha with regex iterators is that the regex argument must be an L-value, an R-value will not work: Visual Studio regex_iterator Bug.
Section 29_0_3: Anchors Cplus_plus provides only 4 anchors: ^ which asserts the start of the string $ which asserts the end of the string \b which asserts a \W character or the beginning or end of the string \B which asserts a \w character.
An important note here is that the anchor does not consume any characters.
Section 29_0_4: regex_replace Example.
Section 29_0_5: regex_token_iterator Example A std::regex_token_iterator provides a tremendous tool for extracting elements of a Comma Separated Value ﬁle.
Aside from the advantages of iteration, this iterator is also able to  escaped commas where other methods struggle:.
A notable gotcha with regex iterators is, that the regex argument must be an L-value.
An R-value will not work.
Section 29_0_6: Quantiﬁers Let' say that we're given const string  as a phone number to be validated.
We could start by requiring a numeric  with a zero or more quantiﬁer: regex_match(, regex("\\d*")) or a one or more quantiﬁer: regex_match(, regex("\\d+")) But both of those really fall short if  contains an invalid numeric string like: "123" Let' use a  or more quantiﬁer to ensure that we're getting at least 7 digits: This will guarantee that we will get at least a phone number of digits, but  could also contain a numeric string.
It' important to note that the lazy quantiﬁer matches as few characters as possible, so the only way this character will be matched is if there are already 10 characters that  been matched by \d{7,10}.
Now, how would we make the area code optional and only accept a country code if the area code was present.
In this ﬁnal regex, the \d{7} requires 7 digits.
These 7 digits are optionally preceded by either 3 or 4 digits.
Note that we did not append the lazy quantiﬁer: \d{3,4}_0_\d{7}, the \d{3,4}.
Instead we're making the non-capturing group match at most once, preferring not to match.
Causing a mismatch if  didn' include the area code like: "1234567".
In conclusion of the quantiﬁer topic, I'd like to mention the other appending quantiﬁer that you can use, the possessive quantiﬁer.
Either the lazy quantiﬁer or the possessive quantiﬁer can be appended to any quantiﬁer.
The possessive quantiﬁer' only function is to assist the regex engine by telling , greedily take these characters and don' ever give them up even if  causes the regex to fail.
This for example doesn' make much sense: regex_match(, regex("\\d{3,4}+\\d{7})) Because an  like: "1234567890" wouldn' be matched as \d{3,4}+ will always match 4 characters even if matching 3 would  allowed the regex to succeed.
With the possessive quantiﬁer the regex starts where the 2nd possessive quantiﬁer left oﬀ, the '0' character, and the regex engine tries to adjust the _0_* to allow \d{3,4} to match; when  can' the regex just fails, no  tracking is done to see if earlier _0_* adjustment could allowed a match.
The parent class: Let' start with the polymorphic class: class public: virtual virtual virtual.
You can deﬁne polymorphic behavior  introduced member functions with the keyword virtual.
Here get_surface() and describe_object() will obviously be implemented diﬀerently for a square than for a circle.
When the function is invoked on an object, function corresponding to the real class of the object will be determined at runtime.
It makes no sense to deﬁne get_surface() for an abstract.
This is why the function is followed  = 0.
This means that the function is pure virtual function.
A polymorphic class should always deﬁne a virtual destructor.
You may deﬁne non virtual member functions.
When these function will be invoked for an object, the function will be chosen depending on the class used at compile-time.
Here get_double_surface() is deﬁned in this way.
A class that contains at least one pure virtual function is an abstract class.
Abstract classes cannot be instantiated.
You may only have pointers or references of an abstract class type.
Derived classes Once a polymorphic base class is deﬁned you can derive.
For example: class Square : public  { Point top_left;.
Some explanations: You can deﬁne or override any  the virtual functions  the parent class.
The fact that a function was virtual in the parent class makes it virtual in the derived class.
No need to tell the compiler the keyword virtual again.
But it's recommended to add the keyword override at the end  the function declaration, in order to prevent subtle bugs caused  unnoticed variations in the function signature.
If all the pure virtual functions  the parent class are deﬁned you can instantiate objects for this class, else it will also become an abstract class.
You are not obliged to override all the virtual functions.
You can keep the version  the parent if it suits your need.
Example  instantiation.
Most  the time, you would not need to know which is the real type  the object, as the virtual functions allow you to manipulate your object independently  its type: std:: << ": " << () << std::endl; If you don't need any downcast, your design would be perfect.
However, you may need sometimes to downcast.
A typical example is when you want to invoke a non virtual function that exist only for the child class.
Consider for example circles.
Only circles have a diameter.
So the class would be deﬁned as : class Circle: public  { // for , see example on defining a polymorphic class Point center;.
But it's very risky: if  appears to  anything else than a Circle the behavior  your code will be undeﬁned.
So rather than playing Russian roulette, you should safely use a dynamic_cast.
This is speciﬁcally for polymorphic classes :.
Section 30_0_3: Polymorphism & Destructors If a class is intended to be used polymorphically, with derived instances being stored as base pointers/references, its base class' destructor should be either virtual or protected.
In the former case, this will cause object destruction to check the vtable, automatically calling the correct destructor based on the dynamic type.
In the latter case, destroying the object through a base class pointer/reference is disabled, and the object can only be deleted when explicitly treated as its actual type.
Chapter 31: Perfect Forwarding Section 31_0_1: Factory functions Suppose we want to write a factory function that accepts an arbitrary list  arguments and passes those arguments unmodiﬁed to another function.
An example  such a function is make_unique, which is used to safely construct a new    and return a <> that owns the.
The language rules regarding variadic templates and rvalue references allows us to write such a function.
The compiler will expand this parameter pack to the correct number  arguments at the call site.
These arguments are then passed to 's constructor using std::.
This function is required to preserve the ref-qualiﬁers  the arguments.
The speciﬁer final can only be used with `virtual' member function and can't be applied to non-virtual member functions Like final, there is also an speciﬁer caller 'override' which prevent overriding  virtual functions in the derived class.
The speciﬁers override and final may be combined together to have desired eﬀect: class Derived1 : public Base {.
Section 32_0_2: Using override with virtual in Cplus_plus11 and later The speciﬁer override has a special meaning in Cplus_plus11 onwards, if appended at the end  function signature.
This signiﬁes that a function is Overriding the function present in base class & The Base class function is virtual Complete Cplus_plus Tips & Secrets for Professionals 246 There is no run time signiﬁcance  this speciﬁer as is mainly meant as an indication for compilers The example below will demonstrate the change in behaviour with our without using override.
The reasoning behind this is that the derived class may deﬁne additional members which are not yet initialized (in the constructor case) or already destroyed (in the destructor case), and calling its member functions would be unsafe.
Therefore during construction and destruction  Cplus_plus objects, the dynamic type  *this  considered to be the constructor's or destructor's class and not  more-derived class.
Section 32_0_5: Pure  functions We can also specify that   function  pure  (abstract), by  = 0 to the declaration.
Classes with one or more pure  functions are considered to be abstract, and cannot be instantiated; only derived classes which deﬁne, or inherit deﬁnitions for, all pure  functions can be instantiated.
In this case, Complete Cplus_plus Tips & Secrets for Professionals 249.
There are  couple  reasons why we might want to do this: If we want to create  class that can't itself be instantiated, but doesn't prevent its derived classes from being instantiated, we can declare the destructor as pure.
Being the destructor, it must be deﬁned anyways, if we want to be able to deallocate the.
And as the destructor  most likely already  to prevent memory leaks during polymorphic use, we won't incur an unnecessary performance hit from declaring another function.
This can be useful when making interfaces.
Chapter 33: Undeﬁned Behavior What  undeﬁned behavior (UB).
According to the ISO Cplus_plus Standard (1_0_3_0_24, N4296), it  "behavior for which this This means that when  program encounters UB, it  allowed to do whatever it wants.
This often means  crash, but it may simply do nothing, make demons ﬂy out of your nose, or even appear to work properly.
Needless to say, you should avoid writing code that invokes UB.
Although this most often causes  segmentation fault, it  undeﬁned and anything can happen.
This results in undeﬁned behavior, because   uninitialised.
It  often, incorrectly, claimed that this  because the value  "indeterminate", or "whatever value was in that memory location before".
However, it  the act of accessing the value of  in the above example that gives undeﬁned behaviour.
In practice, printing  "garbage value"   common symptom in this case, but that  only one possible form of undeﬁned behaviour.
Although highly unlikely in practice (since it  reliant on speciﬁc hardware support) the compiler could equally well electrocute the programmer when compiling the code sample above.
With such  compiler and hardware support, such  response to undeﬁned behaviour would markedly increase average (living) programmer understanding of the true meaning of undeﬁned behaviour - which  that the standard places no constraint on the resultant behaviour.
Note that  static variable  always zero-initialized (if possible): static  ;.
A pointer must point to an element within the , or one past the.
Section 33_0_4: Deleting   object via  pointer to  base class that.
In section [expr_0_delete] 5_0_3_0_5/3 the standard says that if delete  called on an object whose static type does not have   destructor: if the static type of the object to be deleted  diﬀerent from its dynamic type, the static type shall be  base class of the dynamic type of the object to be deleted and the static type shall have   destructor or the behavior undeﬁned.
This  the case regardless of the question whether the  class added any data members to the base class.
Section 33_0_5: Extending the `std` or `posix` Namespace The standard (17_0_6_0_4_0_2_0_1/1) generally forbids extending the std namespace: The behavior of  Cplus_plus program  undeﬁned if it adds declarations or deﬁnitions to namespace std or to namespace within namespace std unless otherwise speciﬁed.
The same goes for posix (17_0_6_0_4_0_2_0_2/1): The behavior of a Cplus_plus program  undeﬁned if it adds declarations or deﬁnitions to namespace posix or to a namespace within namespace posix unless otherwise speciﬁed.
Consider the following: # <algorithm>.
Nothing in the standard forbids algorithm (or one of the headers it includes) deﬁning the same deﬁnition, and so this code would violate the One Deﬁnition Rule.
So, in general, this  forbidden.
There are speciﬁc exceptions allowed, though.
Perhaps most usefully, it  allowed to add specializations for user deﬁned types.
So, for example, suppose your code has class.
Section 33_0_6: Invalid pointer arithmetic The following uses of pointer arithmetic cause undeﬁned behavior: Addition or subtraction of an integer, if the result does not belong to the same  object as the pointer.
Any pointer arithmetic where either operand's pointee type does not match the dynamic type of the object pointed to (ignoring cv-qualiﬁcation).
According to the standard, "[in] particular, a pointer to a base class Complete Cplus_plus Tips & Secrets for Professionals 253.
Note: main is the only exception to the rule.
If main doesn't have a return statement, the compiler automatically inserts return 0; for you, so it can be safely left out.
Section 33_0_8: Accessing a dangling reference It is illegal to access a reference to an object that has gone out of scope or been otherwise destroyed.
This program has undeﬁned behavior, although it may appear to work and print 42 in some cases.
Section 33_0_10: Shifting by an invalid number of positions For the built-in shift operator, the right operand must be nonnegative and strictly less than the bit width of the promoted left operand.
Otherwise, the behavior is undeﬁned.
If the argument to delete was not returned by new  is an array, the behavior is undeﬁned.
An object can only be deallocated by delete[] if it was allocated by new  is an array.
If the argument to delete[] was not returned by new  is not an array, the behavior is undeﬁned.
If the argument to free was not returned by malloc, the behavior is undeﬁned.
If during the evaluation of an expression, the result is not mathematically deﬁned  not in the range of representable values for its type, the behavior is undeﬁned.
This is one of the more nasty ones, as it usually yields reproducible, non-crashing behavior so developers may be tempted to rely heavily on the observed behavior.
Complete Cplus_plus Tips & Secrets for Professionals 255.
Sometimes compilers may exploit an undeﬁned behavior  optimize.
Unlike redeﬁnition of  class within the same translation unit, this problem is not required to be diagnosed by the compiler.
Section 33_0_14: Modifying  const object Any attempt to modify  const object results in undeﬁned behavior.
This applies to const variables, members of.
A compiler will usually inline the value of  const  object, so it's possible that this code compiles  prints 123.
Compilers can also place const objects' values in read-only memory, so  segmentation fault may occur.
In any case, the behavior is undeﬁned  the program might do anything.
The following program conceals  far more subtle error: # <iostream>.
In this code, getFoo creates  singleton of type const   its member  is initialized to 123.
Then do_evil is called  the value of.
Despite its name, do_evil does nothing particularly evil; all it does is call  setter through  *.
But that pointer points to  const  object even though  was not used.
This pointer was obtained through 's constructor.
A const object does not become const until its initialization is complete, so this has type *, not const *, within the constructor.
Complete Cplus_plus Tips & Secrets for Professionals.
Therefore, undeﬁned behavior occurs even though there are no obviously dangerous constructs in this program.
Section 33_0_15: Returning from  [[noreturn]] function Version≥Cplus_plus11.
Section 33_0_17: Overﬂow during conversion to  from ﬂoating point type If, during the conversion of: an integer type to  ﬂoating point type, ﬂoating point type to an integer type, ﬂoating point type to  shorter ﬂoating point type, the source value is outside the range of values that can be represented in the destination type, the result is undeﬁned behavior.
Example: double  = 1100; = ; //  probably cannot hold numbers that large, so this is UB.
The initialisation of  in the above example was formally deprecated (scheduled for removal from  future version of the standard) in Cplus_plus03.
A number of compilers before 2003 might issue  warning about this (_0_ suspicious conversion).
After 2003, compilers typically warn about  deprecated conversion.
Version≥Cplus_plus11 The above example is illegal,  results in  compiler diagnostic, in Cplus_plus11  later.
A similar example may be.
There are some exceptions to this strict aliasing rule: An object of class type can be accessed as though it were of a type that is a base class of the actual class type.
Any type can be accessed as a char  unsigned char, but the reverse is not true: a char array cannot be accessed as though it were an arbitrary type.
A signed integer type can be accessed as the corresponding unsigned type  vice versa.
A related rule is that if a non-static member function is called on an object that does not actually have the same type as the deﬁning class of the function,  a derived class, then undeﬁned behavior occurs.
This is true even if the function does not access the object.
Section 33_0_20: Invalid derived-to-base conversion for pointers to members When  is used to convert T D::* to T B::*, the member pointed to must belong to a class that is a base class or derived class of B.
Otherwise the behavior is undeﬁned.
See  to base conversion for pointers to members Section 33_0_21: Destroying an object that has already been destroyed.
Section 33_0_22: Access to nonexistent member through pointer to member When accessing a non-static member of an object through a pointer to member, if the object does not actually contain the member denoted by the pointer, the behavior is undeﬁned.
See  to derived conversion.
Section 33_0_24: Floating point overﬂow If an arithmetic operation that yields a ﬂoating point type produces a value that is not in the range of representable values of the result type, the behavior is undeﬁned according to the Cplus_plus standard, but may be deﬁned by other standards the machine might conform to, such as IEEE 754.
Section 33_0_25: Calling (Pure) Virtual Members From Constructor Or Destructor The Standard (10_0_4) states: Member functions can be called from a constructor (or destructor) of an abstract class; the eﬀect of making a virtual call (10_0_3) to a pure virtual function directly or indirectly for the object being created (or destroyed) from such a constructor (or destructor) is undeﬁned.
More generally, some Cplus_plus authorities, e_0_g.
Scott Meyers, suggest never calling virtual functions (even non-pure ones) from constructors and dstructors.
Complete Cplus_plus Tips & Secrets for Professionals 260 Consider the following example, modiﬁed from the above link: class transaction.
This implicitly calls the constructor of sell_transaction, which ﬁrst calls the constructor of transaction.
When the constructor of transaction is called though, the object is not yet of the type sell_transaction, but rather only of the type transaction.
Consequently, the call in transaction::transaction() to log_it, won't do what might seem to be the intuitive thing - namely call sell_transaction::log_it.
If log_it is pure virtual, as in this example, the behaviour is undeﬁned.
If log_it is non-pure virtual, transaction::log_it will be called.
Section 33_0_26: Function call through mismatched function pointer type In order to call a function through a function pointer, the function pointer's type must exactly match the function's.
Chapter 34: Value and Reference Semantics Section 34_0_1: Deﬁnitions A type has value semantics if the 's observable state is functionally distinct from all other objects of that type.
This means that if you copy an , you have a new , and modiﬁcations of the new  will not be in any way visible from the old.
Most basic Cplus_plus types have value semantics: int  = 5;.
A type is said to have reference semantics if an instance of that type can share its observable state with another (external to it), such that manipulating one  will cause the state to change within another.
Cplus_plus pointers have value semantics with regard to which  they point to, but they have reference semantics with regard to the state of the  they point to:.
Section 34_0_2: Deep copying and move support If a type wishes to have value semantics, and it needs to store objects that are dynamically allocated, then on copy operations, the type will need to allocate new  of those objects.
It must also do this for copy assignment.
This kind of copying is called a "deep copy".
It eﬀectively takes what would have otherwise been reference semantics and turns it into value semantics: struct  { ;}; = 5;.
Move semantics allow a type like  to avoid truly copying its referenced data.
If the user uses the value in a way that provokes a move, the "copied" from  can be left empty of the data it referenced: Complete Cplus_plus Tips & Secrets for Professionals.
Chapter 35: Overload resolution Section 35_0_1: Categorization of argument to parameter cost Overload resolution partitions the cost of passing an argument to a parameter into one of four diﬀerent categorizes, called "sequences".
Each sequence may include zero, one or several conversions Standard conversion sequence void f( a); f(42);.
The general principle is that Standard conversion sequences are the cheapest, followed by user deﬁned conversion sequences, followed by ellipsis conversion sequences.
A special case is the list initialization sequence, which does not constitute a conversion (an initializer list is not an expression with a type).
Its cost is determined by deﬁning it to be equivalent to one of the other three conversion sequences, depending on the parameter type and form of initializer list.
Section 35_0_2: Arithmetic promotions and conversions Converting an integer type to the corresponding promoted type is better than converting it to some other integer.
Therefore, in order to ensure that there will be no ambiguity when calling a function f with either integral or ﬂoating-point arguments of any standard type, a total of eight overloads are needed, so that for each possible argument type, either an overload matches exactly or the unique overload with the promoted argument type will be selected.
Both are Exact Matches, but #3 takes a reference to a less cv-qualiﬁed  than #2 does, so it has the better standard conversion sequence and is the best viable function.
The solution here is to always constrain these constructors (e_0_g.
As a result, the copy constructor is invoked - which is what we wanted.
Section 35_0_4: Exact match An overload without conversions needed for parameter types or only conversions needed between types that are.
For the purposes of overload resolution, the type "array of " is considered to match exactly with the type "pointer to ", and the function type  is considered to match exactly with the function pointer type *, even though both Complete Cplus_plus Tips & Secrets for Professionals 266.
An inaccessible function might be selected by overload.
Section 35_0_8: Steps of Overload Resolution The steps of overload resolution are: 1.
Find candidate functions via name lookup.
Unqualiﬁed calls will perform both regular unqualiﬁed lookup as well as argument-dependent lookup (if applicable).
Filter the set of candidate functions to a set of viable functions.
Pick the best viable candidate.
Chapter 36: Move Semantics Section 36_0_1: Move semantics Move semantics are a way of moving   to another in Cplus_plus.
For this, we empty the old  and place everything it had in the new.
An rvalue reference (T&& where T is the  type) is not much diﬀerent than a normal reference (T&, now called lvalue references).
But they act as 2 diﬀerent types, and so, we can make constructors or functions that take  type or the other, which will be necessary when dealing with move semantics.
The reason why we need two diﬀerent types is to specify two diﬀerent behaviors.
Lvalue reference constructors are related to copying, while rvalue reference constructors are related to moving.
To move an , we will use std::move().
There are several ways of doing this which are discussed below.
Important to note is that the use of std::move creates just an rvalue reference.
In other words the statement std::move() does not change the content of , while auto 2 = std::move() (possibly) does.
Cplus_plus11 introduced core language and standard library support for moving an.
The idea is that when an o is a temporary and  wants a logical copy, then its safe to just pilfer o's resources, such as a dynamically allocated buﬀer, leaving o logically empty but still destructible and copyable.
The core language support is mainly the rvalue reference type builder &&, e_0_g_0_, std::string&& is an rvalue reference to a std::string, indicating special support for a move constructor T( T&& ), which is supposed to eﬃciently move resources from the speciﬁed other , instead of actually copying those resources, and special support for a move assignment  auto =(T&&) arrow_operator T&, which also is supposed to move from the source.
The standard library support is mainly the std::move function  from the <utility> header.
This function produces an rvalue reference to the speciﬁed , indicating that it can be moved from, just as if it were a temporary.
For a container actual copying is typically of O(n) complexity, where n is the number of items in the container, while moving is O(1), constant time.
And for an algorithm that logically copies that container n times, this can reduce the complexity from the usually impractical O(n²) to just linear O(n).
Complete Cplus_plus Tips & Secrets for Professionals 271 In his article "Containers That Never Change" in Dr.
Dobbs Journal in September 19 2013, Andrew Koenig presented an interesting example of algorithmic ineﬃciency when using a style of programming where variables are immutable after initialization.
With this style loops are generally expressed using recursion.
And for some algorithms such as generating a Collatz sequence, the recursion requires logically copying a container: // Based on an example by Andrew Koenig in his Dr.
Dobbs Journal article.
In concrete numbers, with gplus_plus and Visual Cplus_plus compilers the above invocation of collatz(42) resulted in a Collatz sequence of 8 items and 36 item copy  (8*7/2 = 28, plus some) in  copy constructor calls.
All of these item copy  can be removed by simply moving vectors whose values are not needed anymore.
To do this it's necessary to remove const and reference for the  type arguments, passing the vectors by value.
The function returns are already automatically optimized.
For the calls where vectors are passed, and not used again further on in the function, just apply std::move to move those buﬀers rather than actually copying them: using std::move;.
The algorithm is necessarily still O() in the length of the Collatz sequence produced, but this is a quite dramatic improvement: O(²).
With some language support  could perhaps use moving and still express and enforce the immutability of a.
Alas, as of Cplus_plus14 Cplus_plus does not support that.
For loop-free code the no use after move can be enforced via a re-declaration of the relevant name as an incomplete struct, as with struct result; above, but this is ugly and not likely to be understood by other programmers; also the diagnostics can be quite misleading.
Summing up, the Cplus_plus language and library support for moving allows drastic improvements in algorithm complexity, but due the support's incompleteness, at the cost of forsaking the code correctness guarantees and code clarity that const can provide.
For completeness, the instrumented  class used to measure the number of item copy  due to copy constructor invocations: < class Item > class Copy_tracking_vector { private:.
To create a copy constructor, that is, to make a function that copies an  and creates a new , we normally would choose the syntax shown above, we would have a constructor for  that takes an reference to another of type , and we would copy the  manually inside the method.
Complete Cplus_plus Tips & Secrets for Professionals 274 Alternatively, we could have written (const  &) = default; which automatically copies over all members, making use of its copy constructor.
To create a move constructor, however, we will be taking an rvalue reference instead of an lvalue reference, like here.
As move semantics are designed to allow 'stealing' state from the original instance, it is important to consider how the original instance should look like after this stealing.
In this case, if we would not change the value to zero we would have doubled the amount of dollars into play.
Thus we have move constructed an object from an old.
While the above is a simple example, it shows what the move constructor is intended to do.
It becomes more useful in more complex cases, such as when resource management is involved.
Section 36_0_5: Move assignment Similarly to how we can assign a value to an object with an lvalue reference, copying it, we can also move the values from an object to another without constructing a new.
We call this move assignment.
We move the values from object to another existing object.
Complete Cplus_plus Tips & Secrets for Professionals 276.
So, if you have access to the static  function and decorate it correctly, then you can point to the function like any normal function outside  class: typedef int Fn(int); // Fn is  type-of function that accepts an int and returns an int // Note that MyFn() is of type 'Fn'.
Point to  function Call it Point to the other function Call it Section 37_0_2: Pointers to  functions To access   function of  class, you need to have  "handle" to the particular , as either the Complete Cplus_plus Tips & Secrets for Professionals 278 itself, or  pointer or reference to it.
Given  class , you can point to various of its members with pointer-to-, IF you get the syntax correct.
Of course, the pointer has to be declared to be of the same type as what you are pointing to_0__0_.
Given  class , you can point to various of its members with  -tomember, IF you get the syntax correct.
Of course, the  has to be declared to be of the same type as what you are pointing to_0__0_.
Point to  within any Use p_c_i to fetch  from 's Point to  within any Use p_c_i to fetch  from 's Complete Cplus_plus Tips & Secrets for Professionals.
The syntax of -to- requires some extra syntactic elements: To deﬁne the type of the , you need to mention the base type, as well as the fact that it is inside class: int ::*;.
If you have  class or reference and want to use it with  -to-, you need to use the _0_* (akin to the.
If you have   to  class and want to use it with  -to-, you need to use the arrow_operator* (akin to the arrow_operator ).
Section 37_0_4: Pointers to static  variables static  variable is just like an ordinary C/Cplus_plus variable, except with scope: It is inside  class, so it needs its name decorated with the class name; It has accessibility, with public, protected or private.
So, if you have access to the static  variable and decorate it correctly, then you can point to the variable like any normal variable outside  class: class  { public:.
Section 38_0_1: Basic Pimpl idiom Version≥Cplus_plus11.
The pImpl contains the  state (or some/most of it).
Instead of the  description of state being exposed in the header ﬁle, it  be only exposed within the implementation.
The "real" implementation of  is in the pImpl.
Danger: Note that for this to work with , ~() must be implemented at a point in a ﬁle where the Impl is fully visible.
Chapter 39: std::: To wrap any element that is callable.
Section 39_0_2: std:: used with std::bind Think about a situation where we need to callback a  with arguments.
Section 39_0_3: Binding std:: to a dierent callable types /* * This example show some ways of using std:: to call * a) C-like * b) class-member * d) lambda * Complete Cplus_plus Tips & Secrets for Professionals 282 * Function call  be made: * a) with right arguments * b) argumens with different order, types and count */.
Live Output: Test stored functions with arguments:  = 1,  = 2,  = 3 foo_fn called with arguments: 1, 2, 3 result is : 6 foo_struct::foo_fn called with arguments: 1, 2, 3 result is : 6 foo_struct::foo_fn_4 called with arguments: 1, 3, 2, 0 result is : 6 foo_struct::operator() called with arguments: 1, 2, 3 result is : 6 lambda called with arguments: 1, 2, 3 result is : 6 Section 39_0_4: Storing  arguments in std::tuple Some programs need so store arguments for future calling of some.
Complete Cplus_plus Tips & Secrets for Professionals 284.
Output: foo_fn called.
Because std:: has [ semantics][1], it must copy or move the given callable into itself.
But since it can take callables of an arbitrary type, it will frequently have to allocate memory dynamically to do this.
Some  implementations have so-called "small object optimization", where small types (like pointers, member pointers, or functors with very little state) will be stored directly in the  object.
But even this only works if the type is noexcept move constructible.
Furthermore, the Cplus_plus standard does not require that all implementations provide one.
A  parameter would be the preferred solution for SortMyContainer, but let us assume that this is not possible or desirable for whatever reason.
SortMyContainer does not need to store pred beyond its own call.
And yet, pred may well allocate memory if the functor given to it is of some non-trivial size.
But SortMyContainer does not need to own the callable; it's just referencing it.
So using here is overkill; it may be eﬃcient, but it may not.
There is no standard library  type that merely references  callable.
So an alternate solution will have to be found, or you can choose to live with the overhead.
Also,  has no eﬀective means to control where the memory allocations for the object come from.
Yes, it has constructors that take an allocator, but [many implementations do not implement them correctly_0__0_.
Version≥Cplus_plus17 The  constructors that take an allocator no longer are part of the type.
Therefore, there is no way to manage the allocation.
Calling   is also slower than calling the contents directly.
Since any  instance could hold any callable, the call through   must be indirect.
The overhead of calling  is on the order of  virtual call.
Chapter 40: const keyword const   = initial; // Declares  const variable; cannot be changed const  & = ; // Declares  reference to  const variable const  * = &; // Declares  pointer-to-const.
The pointer can change, but the underlying data member cannot be changed through the pointer * const  = &; // Declares  const pointer.
The pointer cannot be reassigned to point to something else, but the underlying data member can be changed const  * const  = &; // Declares  const pointer-to-const.
Section 40_0_1: Avoiding duplication of code in const and non-const getter methods.
In Cplus_plus methods that diﬀers only by const qualiﬁer can be overloaded.
Sometimes there may be  need of two versions of getter that return  reference to some member.
Let Foo be  class, that has two methods that perform identical operations and returns  reference to an object of type Bar: class Foo { public:.
The only diﬀerence between them is that one method is non-const and return  non-const reference (that can be use to modify object) and the second is const and returns const reference.
To avoid the code duplication, there is  temptation to call one method from another.
However, we can not call non-const method from the const one.
But we can call const method from non-const one.
That will require as to use '' to remove the const qualiﬁer.
The solution is: struct Foo.
Since we call const method from non-const, the object itself is non-const, and casting away the const is allowed.
Examine the following more complete example: # <iostream> class Student.
In  const member , the this pointer is eﬀectively  const MyClass * instead of  MyClass *.
This means that you cannot change any member variables within the ; the compiler will emit  warning.
So setMyInt could not be declared const.
You should almost always mark member functions as const when possible.
Only const member functions can be called on  const MyClass.
This is because  static method belongs to  class and is not called on object; therefore it can never modify object's internal variables.
So declaring static methods as const would be redundant.
Section 40_0_3: Const local variables.
It is especially convenient when dealing with long type names:.
Section 41_0_3: auto and proxy objects Sometimes auto may behave not quite as was expected by  programmer.
It type deduces the expression, even when type deduction is not the right thing to do.
As an example, when proxy objects are used in the code:.
When flags_0_push_back() modiﬁes the container, this pseudo-reference could end up dangling, referring to an element that no longer exists.
In cases like this you can declare  variable with auto and initialize it by casting to the type you want to be deduced: auto  = <bool>(getFlags()[5]); but at that point, simply replacing auto with bool makes more sense.
Another case where proxy objects can cause problems is expression templates.
In that case, the templates are sometimes not designed to last beyond the current full-expression for eﬃciency sake, and using the proxy object on the next causes undeﬁned behavior.
Section 41_0_4: auto and Expression Templates.
By using auto, you're creating  dangling reference.
Instead of mult had returned std::<>, then the code would deﬁnitely  3.
Section 41_0_5: auto, const, and references The auto keyword by itself represents   type, similar to  or char.
It can be modiﬁed with the const keyword and the & symbol to represent  const type or  reference type, respectively.
These modiﬁers can be combined.
In this example,  is   type (its type will be inferred as std::string), so each iteration of the for loop copies string from the  into.
If the body of the loop modiﬁes  (such as by calling _0_append(" and stuff")), only this copy will be modiﬁed, not the original member of.
On the other hand, if  is declared with auto& it will be  reference type (inferred to be std::string&), so on each iteration of the loop it will be assigned  reference to  string in the :.
Complete Cplus_plus Tips & Secrets for Professionals.
When using auto with range-based for loops, it is generally good practice to use const auto& if the loop body will not modify the structure being looped over, since this avoids unnecessary copies.
Section 41_0_6: Trailing return type auto is used in the syntax for trailing return type:.
This is  good solution for large objects that have been dynamically allocated and are already managed by pointers.
However, this solution does not work well for small or primitive types such as , which are rarely ever dynamically allocated or managed by pointers.
In this example, struct Person is deﬁned.
It is possible for  person to have  pet, but not necessary.
Therefore, the pet member of Person is declared with an std:: wrapper.
Here we return either the fraction /, but if it is not deﬁned (would be inﬁnity) we instead return the empty.
A more complex case: template<class Range, class Pred>.
It returns either an empty  if it was not found, or an  containing an  tothe element if it was.
This lets you take the maybe-null  and give  default behavior when you actually need  value.
By doing it this way, the "default behavior" decision can be pushed back to the point where it  best made and immediately Complete Cplus_plus Tips & Secrets for Professionals.
Section 42_0_4: Introduction Optionals (also known as Maybe types) are used to represent a type whose contents may or may not be present.
They are implemented in Cplus_plus17 as the std:: class.
For example, an object of type std::<int> may contain some value of type int, or it may contain no value.
Optionals are commonly used either to represent a value that may not exist or as a return type from a function that can fail to return a meaningful result.
Other approaches to There are many other approach to solving the problem that std:: solves, but none of them are quite complete: using a pointer, using a sentinel, or using a <bool, T>.
Optional vs Pointer In some cases, we can provide a pointer to an existing object or nullptr to indicate failure.
But this  limited to those cases where  already exist - , as a value type, can also be used to return new  without resorting to memory allocation.
Optional vs Sentinel A common idiom  to use a special value to indicate that the value  meaningless.
This may be 0 or -1 for integral types, or nullptr for pointers.
However, this reduces the space of valid values (you cannot diﬀerentiate between a valid 0 and a meaningless 0) and many types do not have a natural choice for the sentinel value.
Optional vs std::pair<bool, T> Another common idiom  to provide a pair, where one of the elements  a bool indicating whether or not the value  meaningful.
This relies upon the value type being default-constructible in the case of error, which  not possible for some types and possible but undesirable for others.
An <T>, in the case of error, does not need to construct anything.
Section 42_0_5: Using optionals to represent the failure of a function Before Cplus_plus17, a function typically represented failure in one of several ways: A null pointer was returned.
Calling a function Delegate *App::get_delegate() on an App instance that did not have a delegate would return nullptr.
This  a good solution for  that have been dynamically allocated or are large and managed by pointers, but isn't a good solution for small  that are typically stack-allocated and passed by copying.
A speciﬁc value of the return type was reserved to indicate failure.
Calling a function unsigned shortest_path_distance(Vertex a, Vertex ) on two vertices that are not connected may return zero to indicate this fact.
The value was paired together with a bool to indicate  the returned value was meaningful.
Calling a function std::<int, bool> parse(const std::string &str) with a string argument that  not an integer would return a  with an undeﬁned int and a bool set to false.
In this example, John  given two pets, Fluﬀy and Furball.
The function Person::pet_with_name()  then called to retrieve John' pet Whiskers.
Since John does not have a pet named Whiskers, the function fails and std::nullopt Complete Cplus_plus Tips & Secrets for Professionals 295.
Chapter 43: Copy Elision Section 43_0_1: Purpose of copy elision There are places in the standard where an object  copied or moved in order to initialize an object.
Copy elision (sometimes called return value optimization)  an optimization whereby, under certain speciﬁc circumstances, a compiler  permitted to avoid the copy or move even though the standard says that it must happen.
Consider the following function:.
The standard  very clear that this  how the code  interpreted.
Copy elision  a rule that permits a Cplus_plus compiler to ignore the creation of the temporary and its subsequent copy/destruction.
That , the compiler can take the initializing expression for the temporary and initialize the function's return value from it directly.
This obviously saves performance.
However, it does have two visible eﬀects on the user: 1.
The type must have the copy/move constructor that would have been called.
Even if the compiler elides the copy/move, the type must still be able to have been copied/moved.
Side-eﬀects of copy/move constructors are not guaranteed in circumstances where elision can happen.
What will calling func do.
Well, it will never print "Copying", since the temporary  an rvalue and   a moveable type.
So will it print "Moving".
Without the copy elision rule, this would be required to always print "Moving".
But because the copy elision rule exists, the move constructor may or may not be called; it  implementation-dependent.
And therefore, you cannot depend on the calling of copy/move constructors in contexts where elision  possible.
Because elision  an optimization, your compiler may not support elision in all cases.
And regardless of whether the compiler elides a particular case or not, the type must still support the operation being elided.
So if a copy construction  elided, the type must still have a copy constructor, even though it will not be called.
Section 43_0_2: Guaranteed copy elision Version≥Cplus_plus17 Normally, elision  an optimization.
While virtually every compiler support copy elision in the simplest of cases, having elision still places a particular burden on users.
Namely, the type who's copy/move  being elided must still have the copy/move operation that was elided.
This might be useful in cases where a_mutex  a mutex that  privately held by some system, yet an external user might want to have a scoped lock to it.
This  also not legal, because std:: cannot be copied or moved.
Even though virtually every Cplus_plus compiler will elide the copy/move, the standard still requires the type to have that operation available.
Cplus_plus17 mandates elision by eﬀectively redeﬁning the very meaning of certain expressions so that no copy/moving takes place.
Under pre-Cplus_plus17 wording, that code says to create a temporary and then use the temporary to copy/move into the return value, but the temporary copy can be elided.
Under Cplus_plus17 wording, that does not create a temporary at all.
In Cplus_plus17, any prvalue expression, when used to initialize an object of the same type as the expression, does not generate a temporary.
The expression directly initializes that object.
If you return a prvalue of the same type as the return value, then the type need not have a copy/move constructor.
And therefore, under Cplus_plus17 rules, the above code can work.
The Cplus_plus17 wording works in cases where the prvalue's type matches the type being initialized.
So given get_lock above, this will also not require a copy/move: std::  = get_lock(); Since the result of get_lock is a prvalue expression being used to initialize an object of the same type, no copying or moving will happen.
That expression never creates a temporary; it is used to directly initialize.
There is no elision because there is no copy/move to be elided elide.
The term "guaranteed copy elision" is therefore something of a misnomer, but that is the  of the feature as it is proposed for Cplus_plus17 standardization.
It does not guarantee elision at all; it eliminates the copy/move altogether, redeﬁning Cplus_plus so that there never was a copy/move to be elided.
This feature only works in cases involving a prvalue expression.
As such, this uses the usual elision rules:.
While this is a valid case for copy elision, Cplus_plus17 rules do not eliminate the copy/move in this case.
As such, the type must still have a copy/move constructor to use to initialize the return value.
And since  does not, this is still a compile error.
Implementations are allowed to refuse to elide copies when passing or returning an object of trivially-copyable type.
This is to allow moving such objects around in registers, which some ABIs might mandate in their calling conventions.
Copy elision permits this expression to directly create the object in str, rather than using a temporary+move.
This is a useful optimization for cases where a constructor is declared explicit.
For example, we could have written the above as func("foo"), but only because string has an implicit constructor that converts from a const char* to a string.
If that constructor was explicit, we would be forced to use a temporary to call the explicit constructor.
Copy elision saves us from having to do a needless copy/move.
Section 43_0_4: Return value elision If you return a prvalue expression from a function, and the prvalue expression has the same type as the function's.
Section 43_0_5: Named return value elision If you return an lvalue expression from a function, and this lvalue: represents an automatic variable local to that function, which will be destroyed after the return the automatic variable is not a function parameter and the type of the variable is the same type as the function's return type If all of these are the case, then the copy/move from the lvalue can be elided:.
Chapter 44: Bit Operators.
Using this, when the binary value for  (0101) and the binary value for  (1001) are XOR'ed together we get the binary value of 1100: int  = 0 1 0 1 int  = 1 0 0 1 ^ minus_minusminus_minusminus_minusminus_minusint  = 1 1 0 0 The bit wise XOR does not change the value of the original values unless speciﬁcally assigned to using the bit wise.
Note: The following example is often shown as an example of  nice trick.
But should not be used in production code (there are better ways std::swap() to achieve the same result).
You might note that shifting  value to the left 1 time is also the same.
Possible output:  = 2147483647,  = -2 While some compilers will yield results that seem expected, it should be noted that if you left shift  signed number so that the sign bit is aﬀected, the result is undeﬁned.
It is also undeﬁned if the number of bits you wish to shift by is  negative number or is larger than the number of bits the type on the left can hold, example:.
Complete Cplus_plus Tips & Secrets for Professionals 303 Why The right bit wise shift will shift the bits of the left hand value () the number speciﬁed on the right (1); it should be noted that while the operation of  right shift is standard, what happens to the bits of  right shift on  signed negative number is implementation deﬁned and thus cannot be guaranteed to be portable, example: int  = -2; int  =  >> 1; // the value of  will be depend on the compiler.
Chapter 45: Fold Expressions Section 45_0_1: Unary Folds Unary folds are used to fold parameter packs over  speciﬁc.
There are 2 kinds of unary folds: Unary Left Fold (_0__0_.
Section 45_0_2: Binary Folds Binary folds are basically unary folds, with an extra argument.
There are 2 kinds of binary folds: Binary Left Fold - (value op _0__0_.
Ts> void print_all(std::ostream& , Ts const&_0__0_.
A lot of compilers will allow this and might issue // warning, but the  will be "as expected"; this   compiler // extension and cannot be guaranteed across compilers (i_0_e.
Unions are  specialized struct within which all members occupy overlapping memory.
Complete Cplus_plus Tips & Secrets for Professionals.
Chapter 47: Unnamed types Section 47_0_1: Unnamed classes Unlike  named class or struct, unnamed classes and structs must be instantiated where they are deﬁned, and cannot have constructors or destructors.
Section 47_0_4: Anonymous Union Member names of an anonymous union belong to the scope of the union declaration an must be distinct to all other names of this scope.
The example here has the same construction as example Anonymous Members using "struct" but  standard conform.
If you are thinking about caching   of expensive computation, you should probably use this keyword.
If you have  lock (for example, std::unique_lock) data ﬁeld which  locked and unlocked inside  const method, this keyword  also what you could use.
You should not use this keyword to break logical const-ness of an object.
Example with caching: class pi_calculator {.
Bit ﬁelds tightly pack C and Cplus_plus structures to reduce size.
This appears painless: specify the number of bits for members, and compiler does the work of co-mingling bits.
The restriction  inability to take the address of  bit ﬁeld member, since it  stored co-mingled.
The cost of bit ﬁelds  slower access, as memory must be retrieved and bitwise operations applied to extract or modify member values.
These operations also add to executable size.
Section 49_0_1: Declaration and Usage.
Here, each of these two ﬁelds will occupy 1 bit in memory.
It  speciﬁed by : 1 expression after the variable names.
Base  of bit ﬁeld could be any integral  (8-bit int to 64-bit int).
Using unsigned   recommended, otherwise surprises may come.
If more bits are required, replace "1" with number of bits required.
For example: struct Date {.
If T is  non-scalar  std:: can be initialized in the following ways: struct  { int values[3]; }; // An aggregate // 1) Using aggregate initialization with brace elision.
If pos is not within the range of the container,  runtime segmentation violation error can occur.
This method provides element access equivalent to classic arrays and thereof more eﬃcient than (pos).
The complexity is constant O(1).
The complexity is constant O(1).
Chapter 51: Singleton Design Pattern Section 51_0_1: Lazy Initialization This example has been lifted from the Q &  section here:http://stackoverﬂow_0_com//1008289/3807729 See this article for  simple design for  lazy evaluated with guaranteed destruction singleton: Can any one provide me  sample of Singleton in cplus_plus.
The classic lazy evaluated and correctly destroyed singleton.
See this article that discusses some threading implications to singletons: Singleton instance declared as static variable of GetInstance method See this article that explains why double checked locking will not work on Cplus_plus: What are all the common undeﬁned behaviours that  Cplus_plus programmer should know about.
Section 51_0_2: Static deinitialization-safe singleton.
There are times with multiple static objects where you need to be able to guarantee that the singleton will not be destroyed until all the static objects that use the singleton no longer need it.
In this case std::shared_ptr can be used to keep the singleton alive for all users even when the static destructors are being called  the end of the program: class {.
Section 51_0_3: Thread-safe Singeton Version≥Cplus_plus11 The Cplus_plus11 standards guarantees that the initialization of function scope objects are initialized in  synchronized manner.
This can be used to implement  thread-safe singleton with lazy initialization.
Chapter 52: The ISO Cplus_plus Standard In 1998, the there was  ﬁrst publication of the standard making Cplus_plus an internally standardized language.
From that time, Cplus_plus has evolved resulting in diﬀerent dialects of Cplus_plus.
On this page, you can ﬁnd an overview of all diﬀerent standards and their changes compared to the previous version.
The details on how to use these features is described on more specialized pages.
Section 52_0_1: Current Working Drafts All published ISO standards are available for sale from the ISO store ( http://www_0_iso_0_org ).
The working drafts of the Cplus_plus standards are publicly available for free though.
The diﬀerent versions of the standard: Proposed (Sometimes referred as Cplus_plus17 or Cplus_plus1z): March 2017 working draft N4659.
Cplus_plus14 (Sometimes referred as Cplus_plus1y): November 2014 working draft N4296 Cplus_plus11 (Sometimes referred as Cplus_plus0x): February 2011 working draft N3242 Cplus_plus03 Cplus_plus98 Section 52_0_2: Cplus_plus17 The Cplus_plus17 standard is feature complete and has been proposed for standardization.
In compilers with experimental support for these features, it is usually referred to as Cplus_plus1z.
Language Extensions Fold Expressions declaring non-type template arguments with auto Guaranteed copy elision Template parameter deduction for constructors Structured bindings Compact nested namespaces New attributes: [[fallthrough]], [[nodiscard]], [[maybe_unused]] Default message for static_assert Initializers in if and switch Complete Cplus_plus Tips & Secrets for Professionals 316 Inline variables if constexpr Order of expression evaluation guarantees Dynamic memory allocation for over-aligned data Library Extensions std::optional std::variant std::string_view merge() and extract() for associative containers A ﬁle system library with the <filesystem> header.
Parallel versions of most of the standard algorithms (in the <algorithm> header).
Addition of mathematical special functions in the <cmath> header.
Moving nodes between map<>, unordered_map<>, set<>, and unordered_set<> Section 52_0_3: Cplus_plus11 The Cplus_plus11 standard is a major extension to the Cplus_plus standard.
Below you can ﬁnd an overview of the changes as they have been grouped on the isocpp FAQ with links to more detailed documentation.
Language Extensions General Features auto decltype Range-for statement Initializer lists Uniform initialization syntax  semantics Rvalue references  move semantics Lambdas noexcept to prevent exception propagation constexpr nullptr – a null pointer literal Copying  rethrowing exceptions Inline namespaces User-deﬁned literals Classes =default  =delete Control of default move  copy Delegating constructors In-class member initializers Inherited constructors Override controls: override Override controls: ﬁnal Explicit conversion operators Other Types enum class long long – a longer integer Extended integer types Generalized unions Complete Cplus_plus Tips & Secrets for Professionals 317 Generalized PODs Templates Extern templates Template aliases Variadic templates Local types as template arguments Concurrency Concurrency memory model Dynamic initialization  destruction with concurrency Thread-local storage Miscellaneous Language Features What is the value of __cplusplus for Cplus_plus11.
Suﬃx return type syntax Preventing narrowing Right-angle brackets static_assert compile-time assertions Raw string literals Attributes Alignment C99 features Library Extensions General unique_ptr shared_ptr weak_ptr Garbage collection ABI tuple Type traits function  bind Regular Expressions Time utilities Random number generation Scoped allocators Containers  Algorithms Algorithms improvements Container improvements unordered_* containers std::array forward_list Concurrency Threads Mutual exclusion Locks Condition variables Complete Cplus_plus Tips & Secrets for Professionals 318 Atomics Futures  promises async Abandoning a process Section 52_0_4: Cplus_plus14 The Cplus_plus14 standard is often referred to as a bugﬁx for Cplus_plus11.
It contains only a limited list of changes of which most are extensions to the new  in Cplus_plus11.
Below you can ﬁnd an overview of the changes as they have been grouped on the isocpp FAQ with links to more detailed documentation.
Language Extensions Binary literals Generalized return type deduction Generalized lambda captures Generic lambdas Variable templates Extended constexpr The [[deprecated]] attribute Digit separators Library Extensions Shared locking User-deﬁned literals for std:: types std::make_unique Type transformation _t aliases std::quoted Deprecated / Removed std::gets was deprecated in Cplus_plus11  removed from Cplus_plus14 std::random_shuffle is deprecated Section 52_0_5: Cplus_plus98 Cplus_plus98 is the ﬁrst standardized version of Cplus_plus.
As it was developed as an extension to C, many of the  which set apart Cplus_plus from C are added.
Classes, Derived classes, virtual member functions, const member functions Function overloading, Operator overloading References new  delete templates namespaces exceptions speciﬁc casts Complete Cplus_plus Tips & Secrets for Professionals 319 Library Extensions The Standard Template Library Section 52_0_6: Cplus_plus03 The Cplus_plus03 standard mainly addresses defect reports of the Cplus_plus98 standard.
Apart from these defects, it only adds one new.
Language Extensions Value initalization Section 52_0_7: Cplus_plus20 Cplus_plus20 is the upcoming standard of Cplus_plus, currently in development, based upon the Cplus_plus17 standard.
It's progress can be tracked on the oﬃcial ISO cpp website.
The following  are simply what has been accepted for the next release of the Cplus_plus standard, targeted for 2020.
Language Extensions No language extensions have been accepted for now.
Library Extensions No library extensions have been accepted for now.
Chapter 53: User-Deﬁned Literals Section 53_0_1: Self-made user-deﬁned literal for Despite you can write a   in Cplus_plus14 like: int  =00001'0101; // ==21 here comes a famous example with a self-made implementation for  numbers:.
Version≥Cplus_plus14 Those following duration user literals are declared in the namespace std::literals::chrono_literals, where both literals  chrono_literals are inline namespaces.
Access to these operators can be gained with using namespace std::literals, using namespace std::chrono_literals,  using namespace std::literals::chrono_literals.
Complete Cplus_plus Tips & Secrets for Professionals.
Access to these operators can be gained with using namespace std::literals, using namespace std::string_literals,  using namespace std::literals::string_literals.
Version≥Cplus_plus14 Those following  user literals are declared in the namespace std::literals::complex_literals, where both literals  complex_literals are inline namespaces.
Access to these operators can be gained with using namespace std::literals, using namespace std::complex_literals,  using namespace std::literals::complex_literals.
Chapter 54: Enumeration Section 54_0_1: Iteration over an enum There is no built-in to iterate over enumeration.
But there are several ways for enum with only consecutive values: enum  { , 1 = , 2, // _0_.
Section 54_0_2: Scoped enums Cplus_plus11 introduces what are known as scoped enums.
These are enumerations whose members must be qualiﬁed with enumname::membername.
Scoped enums are declared using the enum class syntax.
For example, to store the colors in a rainbow: enum class rainbow { RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO, VIOLET };.
So int  = rainbow::RED is invalid.
Scoped enums also allow you to specify the underlying type, which is the type used to represent a member.
By default  is int.
In a Tic-Tac-Toe game, you may store the piece as enum class piece : char { = '\0', = '', = '', };.
An in-depth multi-ﬁle example can be found here: Blind fruit merchant example Section 54_0_4: Basic Enumeration Declaration Standard enumerations allow users to declare a useful name for a set of integers.
The names are collectively referred to as enumerators.
An enumeration and its associated enumerators are deﬁned as follows: enum myEnum { enumName1, enumName2, }; An enumeration is a type, one which is distinct from  other types.
In this case, the name of this type is myEnum.
Objects of this type are expected to assume the value of an enumerator within the enumeration.
The enumerators declared within the enumeration are constant values of the type of the enumeration.
Though the enumerators are declared within the type, the scope operator :: is not needed to access the name.
So the name of the ﬁrst enumerator is enumName1.
Version≥Cplus_plus11 The scope operator can be optionally used to access an enumerator within an enumeration.
Enumerators are assigned integer values starting from 0 and increasing by 1 for each enumerator in an enumeration.
So in the above case, 1 has the value 0, while 2 has the value 1.
Enumerators can also be assigned a speciﬁc value by the user; this value must be an integral constant expression.
Enumerators who' values are not explicitly provided will have their value set to the value of the previous enumerator + 1.
In fact a useful feature of switch statements with enumerations is that if no default statement is included for the switch, and not  values of the enum have been utilized, the compiler will issue a warning.
Section 55_0_1: A move-only `std::function` std::function type erases down to a few operations.
One of the things it requires is that the stored value be copyable.
This causes problems in a few contexts, like lambdas storing unique ptrs.
If you are using the std::function in a context where copying doesn't matter, like a thread pool where you dispatch tasks to threads, this requirement can add overhead.
In particular, std::packaged_task<Sig> is a callable object that is move-only.
You can store a std::packaged_task<R(Args_0__0__0_)> in a std::packaged_task<void(Args_0__0__0_)>, but that is a pretty heavy-weight and obscure way to create a move-only callable type-erasure class.
This demonstrates how you could write a simple std::function type.
I omitted the copy constructor (which would involve adding a clone method to details::task_pimpl<_0__0__0_> as well).
To make this library-worthy, you'd want to add in a small buﬀer optimization, so it does not store every callable on the heap.
Adding SBO would require a non-default (&&), some std::aligned_storage_t within the , a with a deleter that can be set to destroy-only (and not return the memory to the heap), and a emplace_move_to( * ) = 0 in the.
Section 55_0_2: Erasing down to a Regular type with manual vtable Cplus_plus thrives on what is known as a Regular type (or at least Pseudo-Regular).
A Regular type is a type that can be constructed and assigned-to and assigned-from via copy or move, can be destroyed, and can be compared equal-to.
It can also be constructed from no arguments.
Finally, it also has Complete Cplus_plus Tips & Secrets for Professionals 328 support for a few other operations that are highly useful in various std algorithms and containers.
This is the root paper, but in Cplus_plus11 would want to add std::hash support.
I will use the manual vtable approach to type erasure here.
Such a regular type can be used as a key for a std::map or a std::unordered_map that accepts anything regular for a key, like: std::map<regular_type, std::any> would be basically a map from anothing regular, to anything copyable.
Unlike any, my regular_type does no small object optimization nor does it support getting the original data back.
Getting the original type back isn't hard.
Small object optimization requires that we store an aligned storage buﬀer within the regular_type, and carefully tweak the deleter of the  to only destroy the object and not delete it.
I would start at  and teach it how to sometimes store the data in a buﬀer, and then in the heap if no room in the buﬀer.
Section 55_0_3: Basic mechanism Type erasure is a way to hide the type of an object from code using it, even though it is not derived from a common base.
In doing so, it provides a bridge between the worlds of static polymorphism (templates; at the place of use, the exact type must be known at compile time, but it need not be declared to conform to an interface at deﬁnition) and dynamic polymorphism (inheritance and virtual functions; at the place of use, the exact type need not be known at compile time, but must be declared to conform to an interface at deﬁnition).
The following code shows the basic mechanism of type erasure.
Note that this is not a template, but a normal function that only needs to be declared in a header ﬁle, and can be deﬁned in an implementation ﬁle (unlike templates, whose deﬁnition must be visible at the place of use).
At the deﬁnition of the concrete type, nothing needs to be known about Printable, it just needs to conform to an interface, as with templates: struct  {  ; };.
Section 55_0_4: Erasing down to a contiguous buer of Not all type erasure involves virtual inheritance, allocations, placement ,  even function pointers.
What makes type erasure type erasure is that it describes a (set of) behavior(s), and takes any type that supports that behavior and wraps it up.
All information that isn't in that set of behaviors is "forgotten"  "erased".
An array_view takes its incoming range  container type and erases everything except the fact it is a contiguous buﬀer of.
It can take a std::<>, a std::<> a std::<, N> a [37], an initializer list (including {} based ones),  something else you make up that supports it (via * _0_data() and size_t _0_size()).
In this case, the data we can extract from the thing we are erasing, together with our "view" non-owning state, means we don't have to allocate memory  write custom type-dependent functions.
Complete  Tips & Secrets for Professionals 333 An improvement would be to use  non-member data and  non-member size in an ADL-enabled context.
Section 55_0_5: Type erasing type erasure with std::any This example uses 14 and boost::any.
The syntax we end up with is: auto  =.
This creates  function pointer type, and  factory for said function pointers, given an any_method: <class any_method> using  = typename any_method::signature; <class any_method, class =<any_method>>.
We want to be able to -erase more than one method at  time.
So we bundle them up in  , and write helper wrapper to stick the  into static storage on  per- basis and maintain  pointer to them.
We could specialize this for  cases where the  is small (for example, 1 item), and use direct pointers stored in-class in those cases for eﬃciency.
Now we start the.
I use  to make the declaration of   bit easier.
Note that using  non-lambda can make things hairy, as we use the  for  lookup step.
This can be ﬁxed, but would make this example longer than it already is.
So always initialize an  method from  lambda,  from parametarized on  lambda.
F f; public: <class Any, // SFINAE testing that one of the Anys's matches this : std::< < Any&&,  >{}, >* =nullptr > friend auto operatorarrow_operator*( Any&& self,  & m ) { // we don' use the value of the , because each  has //  unique  (_0_) and we check that one of the auto*'s in the.
The term 'heap' is  general computing term meaning an area of memory from which portions can be allocated deallocated independently of the memory provided by the stack.
In Cplus_plus the Standard refers to  area as the Free Store which is considered  more accurate term.
Areas of memory allocated from the Free Store may live longer than the original scope in which it was allocated.
Data too large to be stored on the stack may also be allocated from the Free Store.
Raw memory can be allocated  deallocated by the   delete keywords.
Array allocation is not compatible with non-array allocation,  mixing the two will lead to heap corruption.
Allocating an array also allocates memory to track the size of the array for later deletion in an implementation-deﬁned way.
Version≥Cplus_plus11 From Cplus_plus11 on, the use of smart pointers is recommended for indicating ownership.
Version≥Cplus_plus14 Cplus_plus14 added std:: to the STL, changing the recommendation to favor std:: or std:: instead of using naked   delete.
Section 56_0_2: Placement There are situations when we don' want to rely upon Free Store for allocating memory  we want to use custom memory allocations using.
For these situations we can use Placement New, where we can tell `'  to allocate memory from  preallocated memory location For example 4byteInteger; char *4 =  (&4byteInteger) char[4]; In  example, the memory pointed by 4 is 4 byte allocated to 'stack' via integer variable 4byteInteger.
The beneﬁt of  kind of memory allocation is the fact that programmers control the allocation.
In the example above, since 4byteInteger is allocated on stack, we don' need to make an explicit call to 'delete 4`.
Same behavior can be achieved for dynamic allocated memory also.
For example *8 =  [2]; char *8 =  (8) char[8];.
In  case however, we need to explicitly calldelete 8 to release the memory.
Section 57_0_2: Set all bits C-style bit-manipulation = -1; // -1 == 1111 1111 _0__0_.
Section 57_0_4: Checking  bit C-style bit-manipulation The value of the bit can be obtained by shifting the  to the right  times  then performing bitwise AND (&) on it:.
The naive way requires one iteration per bit: unsigned  = 1234; unsigned  = 0; // accumulates the total  of  set in `n`.
The method was ﬁrst proposed by Peter Wegner (in CACM 3 / 322 - 1960)  it's well known since it appears in C Programming Language by Brian W.
Kernighan  Dennis M.
This requires 12 arithmetic operations, one of which is  multication:.
Section 57_0_8: Clearing  bit C-style bit-manipulation A bit can be cleared using the bitwise AND operator (&).
Section 57_0_10: Bit Manipulation Application: Small to Capital Letter One of several applications of bit manipulation is converting  letter from small to capital or vice versa by choosing and  proper bit operation.
For example, the  letter has this binary representation 01(1)00001 while its capital counterpart has 01(0)00001.
They diﬀer solely in the bit in parenthesis.
In this case, converting the  letter from small to capital is basically setting the bit in parenthesis to one.
To do so, we do the following: /**************************************** convert small letter to captial letter.
The result is $ gplus_plus main_0_cpp -o test1 $ _0_/test1 ()  = A a & 0 = A Chapter 58: Arrays Arrays are elements of the same type placed in adjoining memory locations.
The elements can be individually referenced by a unique identiﬁer with an added index.
This allows you to declare multiple variable values of a speciﬁc type and access them individually without needing to declare a variable for each.
Section 58_0_1: Array initialization An array is just a block of sequential memory locations for a speciﬁc type of variable.
Arrays are allocated the same way as normal variables, but with square brackets appended to its name [] that contain the  of elements that ﬁt into the array memory.
The following example of an array uses the typ int, the variable name , and the  of elements [5] that the array has space for: int [5];.
In this case, deﬁning the length in.
Output: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 Cplus_plus doesn't support special syntax for indexing a multi-dimensional.
Instead such an  is viewed as an of arrays (possibly of arrays, and so on), and the ordinary single index notation [i] is used for each level.
In the example above [] refers to row  of , where  is a zero-based index.
Then this row can be indexed in turn, e_0_g.
Since Cplus_plus doesn't provide built-in support for dynamic size arrays, other than dynamic allocation, a dynamic size matrix is often implemented as a class.
Then the raw  matrix indexing notation m[][] has some cost, either by exposing the implementation (so that e_0_g.
A program that declares an  T a[n]; where n is determined a run-time, can compile with certain compilers that support C99 variadic length arrays (VLAs) as a language extension.
But VLAs are not supported by standard Cplus_plus.
This example shows how to manually allocate a dynamic size  via a []-, *.
As part of a function down in a call hierarchy this code  not be exception safe, since an exception before the delete[]  (and after the [])  cause a memory leak.
One way to address that issue is to automate the cleanup via e_0_g.
But a generally better way to address it is to just use a std::vector: that's what std::vector is there for.
C idiom for  size, sizeof(a)/sizeof(a[0]), will accept a pointer as argument and will then generally yield an incorrect result.
Up till Cplus_plus17 (forthcoming as of this writing) Cplus_plus had no built-in core language or standard library utility to obtain the size of an , but this can be implemented by passing the  by reference to a function template, as shown above.
Fine but important point: the template size parameter is a size_t, somewhat inconsistent with the signed function result type, in order to accommodate the gplus_plus compiler which sometimes insists on size_t for template matching.
With Cplus_plus17 and later one may instead use std::size, which is specialized for arrays.
Section 58_0_5: Expanding dynamic size  by using std::vector.
A  can even be expanded at run time, via e_0_g.
Internally this is usually achieved by the  doubling its buﬀer size, its capacity, when a larger buﬀer is needed.
And more generally the sum of this sequence can't exceed 2×.
Compared to the dynamic size raw  example, this -based code does not require the user to supply (and know) the number of items up front.
Instead the  is just expanded as necessary, for each   value speciﬁed by the user.
Section 58_0_6: A dynamic size matrix using std:: for storage.
Unfortunately as of Cplus_plus14 there's no dynamic size matrix class in the Cplus_plus standard library.
Matrix classes that support dynamic size are however available from a number of 3rd party libraries, including the Boost Matrix library (a sub-library within the Boost library).
If you don't want a dependency on Boost or some other library, then one poor man's dynamic size matrix in Cplus_plus is just like <<>> m( 3, <>( 7 ) ); … where  is std::.
It has the advantage of providing the same m[][] indexing notation as for a ﬁxed size raw matrix, but it's a bit ineﬃcient because it  a dynamic allocation for each row, and it's a bit unsafe because it's possible to inadvertently resize a row.
Output: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 above code is not industrial grade: it's designed to show the basic principles, and serve the needs of students learning Cplus_plus.
For example, one may deﬁne operator() overloads to simplify the indexing notation.
They're commonly used to allow functions or data structures to know of and modify memory without having to copy the memory referred to.
Pointers are usable with both primitive (built-in) or user-deﬁned types.
Pointers make use of the "dereference" * , "address of" & , and "arrow" arrow_operator operators.
The '*' and 'arrow_operator' operators are used to access the memory being pointed at, and the & operator is used to get an address in memory.
Section 59_0_1: Pointer Operations There are two operators for pointers: Address-of operator (&): Returns the memory address of its operand.
Contents-of (Dereference) operator(*): Returns the value of the variable located at the address speciﬁed by its operator.
The asterisk (*) is used in declaring a pointer for simple purpose of indicating that it is a pointer.
Don't confuse this with the dereference operator, which is used to obtain the value located at the speciﬁed address.
They are simply two diﬀerent things represented with the same sign.
Section 59_0_2: Pointer basics Version<Cplus_plus11 Note: in all the following, the existence of the Cplus_plus11 constant nullptr is assumed.
For earlier versions, replace nullptr with NULL, the constant that used to play a similar role.
Creating a pointer variable A pointer variable can be created using the speciﬁc * syntax, e_0_g.
When a variable is of a pointer  (int *), it just contains a memory address.
The memory address is the location at which data of the underlying  (int) is stored.
The diﬀerence is clear when comparing the  of a variable with the  of a pointer to the same :.
Moreover, they can take the value nullptr which represents a null memory location.
A pointer equal to nullptr contains an invalid memory location and hence it does not refer to valid data.
You can get the memory address of a variable of a given  by preﬁxing the variable with the address of operator &.
The value returned by & is a pointer to the underlying  which contains the memory address of the variable (which is valid data as long as the variable does not go out of scope).
Accessing the content of a pointer As taking an address requires &, as well accessing the content requires the usage of the dereference operator *, as a preﬁx.
When a pointer is dereferenced, it becomes a variable of the underlying  (actually, a reference to it).
It can then be read and modiﬁed, if not const.
In such scenario, gplus_plus and clangplus_plus correctly issue the warnings: (Clang) warning: address of stack memory associated with local variable 'retval' returned [Wreturn-stack-address] warning: address of local variable 'retval' returned [-Wreturn-local-addr].
Section 59_0_3: Pointer Arithmetic Increment / Decrement A pointer can be incremented or decremented (preﬁx and postﬁx).
Incrementing a pointer advances the pointer value to the element in the array one element past the currently pointed to element.
Decrementing a pointer moves it to the previous element in the array.
Pointer arithmetic is not permitted if the  that the pointer points to is not complete.
If a pointer to the end element is incremented, then the pointer points to one element past the end of the array.
Such a pointer cannot be dereferenced, but it can be decremented.
Incrementing a pointer to the one-past-the-end element in the array, or decrementing a pointer to the ﬁrst element in an array yields undeﬁned behavior.
A pointer to a non-array object can be treated, for the purposes of pointer arithmetic, as though it were an array of 1.
Addition / Subtraction Integer values can be added to pointers; they act as incrementing, but by a speciﬁc number rather than by 1.
Integer values can be subtracted from pointers as well, acting as pointer decrementing.
As with incrementing/decrementing, the pointer must point to a complete.
Pointer Diﬀerencing The diﬀerence between two pointers to the same  can be computed.
The two pointers must be within the same array object; otherwise undeﬁned behavior results.
Given two pointers P and Q in the same array, if P is the ith element in the array, and Q is the jth element, then P Q shall be i - j.
The  of the result is std::ptrdiff_t, from <cstddef>.
Chapter 60: Explicit  conversions simple--speciﬁer braced-init-list typename-speciﬁer braced-init-list ( type-id ) cast-expression An expression can be explicitly converted or cast to type T using dynamic_cast<T>, <T>,.
Cplus_plus also supports function-style cast notation, T(expr), and C-style cast notation, (T)expr.
Section 60_0_1: C-style casting C-Style casting can be considered 'Best eﬀort' casting and is named so as it is the only cast which could be used in C.
The syntax for this cast is (NewType)variable.
Whenever this cast is used, it uses one of the following  casts (in order):.
Functional casting is very similar, though as a few restrictions as the result of its syntax: NewType(expression).
As a result, only types without spaces can be cast to.
It's better to use new  cast, because s more readable and can be spotted easily anywhere inside a Cplus_plus source code and errors will be detected in compile-time, instead in run-time.
As this cast can result in unintended , it is often considered dangerous.
Complete Cplus_plus Tips & Secrets for Professionals 354 Section 60_0_2: Casting away constness A pointer to a const object can be converted to a pointer to non-const object using the  keyword.
Here we use  to call a function that is not const-correct.
It only accepts a non-const * argument even though it never writes through the pointer:.
Section 60_0_3:  to derived conversion A pointer to base class can be converted to a pointer to derived class using.
If the source type is polymorphic,  can be used to perform a base to derived conversion.
It performs a run-time check and failure is recoverable instead of producing undeﬁned behaviour.
In the pointer case, a null pointer is returned upon failure.
In the reference case, an exception is thrown upon failure of type std::bad_cast (or a class derived from std::bad_cast).
The result is implementation deﬁned and typically yields the numeric address of the byte in memory that the pointer pointers to.
Typically, long or unsigned long is long enough to hold any pointer value, but this is not guaranteed by the standard.
Version≥Cplus_plus11 If the types std::intptr_t and std::uintptr_t exist, they are guaranteed to be long enough to hold a void* (and hence any pointer to object type).
However, they are not guaranteed to be long enough to hold a function pointer.
Similarly,  can be used to convert an integer type into a pointer type.
Again the result implementation-deﬁned, but a pointer value  guaranteed to be unchanged by a round trip through an integer type.
The standard does not guarantee that the value zero  converted to a null pointer.
Section 60_0_5: Conversion by explicit constructor or explicit conversion function A conversion that involves calling an explicit constructor or conversion function can't be done implicitly.
We can request that the conversion be done explicitly using.
The meaning  the same as that of a direct initialization, except that the result  a temporary.
This use of  can occasionally be useful, such as in the following examples: When passing arguments to an ellipsis, the "expected" argument type  not statically known, so no implicit.
It can also convert between enumeration types.
The conversion from an unscoped enumeration type to an arithmetic type  an implicit conversion; it possible, but not necessary, to use.
Version≥Cplus_plus11 When a scoped enumeration type  converted to an arithmetic type: If the enum' value can be represented exactly in the destination type, the result  that value.
Otherwise, if the destination type  an integer type, the result  unspeciﬁed.
Otherwise, if the destination type   ﬂoating point type, the result  the same as that of converting to the underlying type and then to the ﬂoating point type.
Note that  value might be unequal to all enumerators.
Example: enum Scale {.
The types pointed to must match.
If the operand   null pointer to member value, the result  also  null pointer to member value.
Otherwise, the conversion  only valid if the member pointed to by the operand actually exists in the destination class, or if the destination class   base or derived class of the class containing the member pointed to by the operand.
If the conversion  not valid, the behaviour.
Section 60_0_9: void* to T* In Cplus_plus, void* cannot be implicitly converted to T* where T  an object type.
Instead,  should be used to perform the conversion explicitly.
If the operand actually points to  T object, the result points to that object.
Version≥Cplus_plus11 Even if the operand does not point to  T object, as long as the operand points to  byte whose address  properly.
The result of  is , except that  pointer (resp.
Use of  is considered dangerous because reading or writing through  pointer or reference obtained using  may trigger  behaviour when the source and destination types are unrelated.
Chapter 61: RTTI: Run-Time Type Information Section 61_0_1: dynamic_cast Use dynamic_cast<>() as  function, which helps you to cast down through an inheritance hierarchy (main Complete Cplus_plus Tips & Secrets for Professionals 359 description).
If you must do some non-polymorphic work on some derived classes  and , but received the base class , then write like this: class  { public: virtual ~(){} }; class : public.
Section 61_0_2: The typeid keyword The typeid keyword is  unary operator that yields run-time type information about its operand if the operand's type is  polymorphic class type.
It returns an lvalue of type const std::type_info.
Top-level cv-qualiﬁcation are ignored.
Section 61_0_4: When to use which cast in cplus_plus Use dynamic_cast for converting pointers/references within an inheritance hierarchy.
Use  for low-level reinterpreting of bit patterns.
Use with extreme caution.
Use const_cast for casting away const/volatile.
Avoid this unless you are stuck using  const-incorrect API.
Chapter 62: Standard Library Algorithms Section 62_0_1: std::next_permutation template< class Iterator > bool next_permutation( Iterator first, Iterator last ); template< class Iterator, class Compare > bool next_permutation( Iterator first, Iterator last, Compare cmpFun ); Eﬀects: Sift the data sequence of the range [ﬁrst, last) into the next lexicographically higher permutation.
If cmpFun is provided, the permutation rule is customized.
Parameters: first- the beginning of the range to be permutated, inclusive last - the end of the range to be permutated, exclusive Return Value: Returns true if such permutation exists.
Otherwise the range is swaped to the lexicographically smallest permutation and return false.
Complexity: O(n), n is the distance from first to last.
Example: std::<  > v { 1, 2, 3 };.
Parameters: first, last - the range to apply f to.
Return value: f (until Cplus_plus11) and std::move(f) (since Cplus_plus11).
Complexity: Applies f exactly last - first times.
Section 62_0_3: std::accumulate Deﬁned in header <numeric> template<class InputIterator, class > template<class InputIterator, class , class BinaryOperation> Eﬀects: std::accumulate performs fold operation using f function on range [, last) starting with init as accumulator value.
Eﬀectively 's equivalent of: = init;.
In version (1) operator+ is used in place of f, so accumulate over container is equivalent of sum of container elements.
Parameters: , last - the range to apply f to.
Return value: Accumulated value of f applications.
Complexity: O(n×k), where n is the distance from  to last, O(k) is complexity of f function.
Example: Simple  example:.
This function should not modify inputs Return Iterator to the minimum  in the range Complexity Linear in one less than the number  elements compared.
Parameters => iterator pointing to the beginning  the range  => iterator pointing to the end  the range  => Return An iterator that points to the ﬁrst  within the range the predicate function  returns true for.
The iterator points to  if  is not found Example.
Output item not First item > 10: 56 First Item  * 10: 10 First Item > 5: 6 Section 62_0_7: Using std::nth_element To Find The Median (Or Other The std::nth_element algorithm takes three iterators: an iterator  the beginning, nth position, and end.
Once the function returns, the nth  (by order) will be the nth smallest.
For the sake  this example, let's deﬁne the median  a sequence  length  as the  that would be in Complete Cplus_plus Tips & Secrets for Professionals 367 position.
For example, the median  a sequence  length 5 is the 3rd smallest , and so is the median  a sequence  length 6.
Section 62_0_8: std::count template <class InputIterator, class T> typename iterator_traits<InputIterator>::difference_type count (InputIterator , InputIterator , const T& ); Eﬀects Counts the number  elements that are Parameters => iterator pointing  the beginning  the range => iterator pointing  the end  the range => The occurrence  this value in the range will be counted Return The number  elements in the range that are (==).
Output There There There There 2 9 1 55 0 101 2 4 Section 62_0_9: std::count_if template <class InputIterator, class UnaryPredicate> typename iterator_traits<InputIterator>::difference_type count_if (InputIterator , InputIterator , UnaryPredicate ); Eﬀects Counts the number of elements in a range for which a speciﬁed predicate function  true Parameters => iterator pointing  the beginning of the range  => iterator pointing  the end of the range  => Return The number of elements within the speciﬁed range for which the predicate function returned true.
Cplus_plus11 //using function pointer  count odd number in the  half of the size_t  = count_if(_0_begin(), _0_end()- _0_size()/2, isOdd); //using a functor  count numbers greater than 5 size_t  = count_if(_0_begin(), _0_end(), Greater(5)); << << << <<.
Output : 15 even : 7 odd : 4 > 5: 6 Chapter 63: Friend keyword Well-designed classes encapsulate their functionality, hiding their implementation while providing a clean, documented interface.
This allows redesign or change so long as the interface  unchanged.
In a more complex scenario, multiple classes that rely on each others' implementation details may be required.
Friend classes and functions allow these peers access  each others' details, without compromising the encapsulation and information hiding of the documented interface.
Section 63_0_1: Friend function A class or a structure may declare any function it' friend.
If a function  a friend of a class, it may access all it'.
Section 63_0_2: Friend method Methods may declared as friends as well as functions:.
A whole class may be declared as friend.
Friend class declaration means that any member of the friend may access private and protected members of the declaring class: class Accesser {.
It' main purpose is to avoid unnecessary temporaries and optimize loop calculations using a single pass (typically when performing operations on numerical aggregates).
Expression templates were initially devised in order to circumvent the ineﬃciencies of naïve operator overloading when implementing numerical Array or Matrix types.
An equivalent in the latest version of his book, "The Cplus_plus Programming Language".
Before actually diving into expression templates, you should understand why you need them in the ﬁrst place.
To illustrate this, consider the very simple Matrix class given below: template <typename T, std::size_t COL, std::size_t ROW> class Matrix {.
As illustrated above, being able to overload operator+() provides you with a notation which mimics the natural mathematical notation for matrices.
To understand why, you have to consider what happens when you write an expression such as   = a + b + c.
In other words, the loop inside operator+() is executed twice, whereas it could have been easily performed in a single pass.
This also results in 2 temporaries being created, which further degrades performance.
In essence, by adding the ﬂexibility to use a notation close to its mathematical counterpart, you have also made the  class highly ineﬃcient.
For example, without operator overloading, you could implement a far more eﬃcient  summation using a single pass: template<typename T, std::size_t COL, std::size_t ROW> <T, COL, ROW> add3(const <T, COL, ROW>& a, const <T, COL, ROW>& b,.
The previous example however has its own disadvantages because it creates a far more convoluted interface for the  class (you would have to consider methods such as ::add2(), ::AddMultiply() and so on).
Instead let us take a step back and see how we can adapt operator overloading to perform in a more eﬃcient way The problem stems from the fact that the expression   = a + b + c is evaluated too "eagerly" before you have had an opportunity to build the entire expression tree.
In other words, what you really want to achieve is to evaluate a + b + c in one pass and only once you actually need to assign the resulting expressing to.
This is the core idea behind expression templates: instead of having operator+() evaluate immediately the result of adding two  instances, it will return an "expression template" for future evaluation once the entire expression tree has been built.
For example, here is a possible implementation for an expression template corresponding to the summation of 2 types: template <typename LHS, typename RHS> class MatrixSum {.
As you can see, operator+() no longer returns an "eager evaluation" of the result of adding 2  instances (which would be another  instance), but instead an expression template representing the addition operation.
The most important point to keep in mind is that the expression has not been evaluated yet.
It merely holds references to its operands.
In fact, nothing stops you from instantiating the <> expression template as follows: <<double>, <double> > SumAB(a, b);.
As you can see, another beneﬁt of using an expression template, is that you have basically managed to evaluate the sum of a and b and assign it to  in a single pass.
Also, nothing stops you from combining multiple expression templates.
For example, a + b + c would result in the following expression template: <<<double>, <double> >, <double> > SumABC(SumAB, c);.
Finally, the last piece of the puzzle is to actually plug your expression template into the  class.
This is essentially achieved by providing an implementation for ::=(), which takes the expression template as an argument and evaluates it in one pass, as you did "manually" before: template <typename T, std::size_t COL, std::size_t ROW> class  {.
Chapter 65: Scopes Section 65_0_1: Global variables To declare a single instance of a variable which is accessible in diﬀerent source ﬁles, it is possible to make it in the global scope with keyword extern.
This keyword says the compiler that somewhere in the code there is a deﬁnition for this variable, so it can be used everywhere and all write/read will be done in one place of memory.
Complete Cplus_plus Tips & Secrets for Professionals 376 Section 65_0_2: Simple block scope The scope of a variable in a block { _0__0_.
Complete Cplus_plus Tips & Secrets for Professionals.
For static_assert(), this is done compile-time.
A static_assert() has  mandatory ﬁrst parameter, the condition, that is  bool constexpr.
It might have  second parameter, the message, that is  string literal.
From Cplus_plus17, the second parameter is optional; before that, it's mandatory.
It is used when: In general,  veriﬁcation at compile-time is required on some type on constexpr value A template function needs to verify certain properties of  type passed to it One wants to write test cases for: template metafunctions constexpr functions macro metaprogramming Note that static_assert() does not participate in SFINAE: thus, when additional overloads / specializations are possible, one should not use it instead of template metaprogramming techniques (like std::enable_if<>).
It might be used in template code when the expected overload / specialization is already found, but further veriﬁcations are required.
In such cases, it might provide more concrete error message(s) than relying on SFINAE for this.
Chapter 68:  precedence Section 68_0_1: Logical && and || operators: short-circuit && has precedence over ||, this means that parentheses are placed to evaluate what would be evaluated together.
Complete Cplus_plus Tips & Secrets for Professionals 379.
Section 68_0_3: Arithmetic operators Arithmetic operators in Cplus_plus have the same precedence as they do in mathematics: Multiplication and division have left associativity(meaning that they will be evaluated from left to right) and they have higher precedence than addition and subtraction, which also have left associativity.
We can also force the precedence of expression using parentheses ( ).
Just the same way as you would do that in normal mathematics.
By adding these parentheses, no confusion exist about the intent of the writer.
Chapter 69: constexpr constexpr is  keyword that can be used to mark  variable's value as  constant expression,  function as potentially usable in constant expressions, or (since Cplus_plus17) an if statement as having only one of its branches selected to be compiled.
Section 69_0_1: constexpr variables A variable declared constexpr is implicitly const and its value may be used as a constant expression.
Comparison with #define A constexpr is type-safe replacement for #define based compile-time expressions.
With constexpr the compiletime evaluated expression is replaced with the result.
However, the compiler would have to do more work.
For example (with #define): <<  * 2;.
But a pre-evaluated constexpr would correctly give 24.
A constexpr produces compile time constant, which cannot be changed.
You may argue that const may also not be changed.
With most compilers the second statement will fail (may work with GCC, for example).
The  of any array, as you might know, has to be a constant expression (i_0_e.
The second variable 2 is assigned some value that is decided at runtime (even though you know it is 10, for the compiler it is not compiletime).
This means that a const may or may not be a true compile-time constant.
You cannot guarantee or enforce that a particular const value is absolutely compile-time.
You may use #define but it has its own pitfalls.
Version≥Cplus_plus17 The if constexpr statement can be used to conditionally compile code.
The condition must be a constant expression.
The branch not selected is discarded.
A discarded statement inside a template is not instantiated.
For example: Complete Cplus_plus Tips & Secrets for Professionals 383.
For example, #ifdef could not be used to conditionally compile code depending on the value of a template parameter.
On the other hand, if constexpr cannot be used to discard syntactically invalid code, while #ifdef can.
Section 69_0_3: constexpr functions A function that is declared constexpr is implicitly inline and calls to such a function potentially yield constant expressions.
For example, the following function, if called with constant expression arguments, yields a constant expression too: Version≥Cplus_plus11.
Similarly,  of array will also not be  constant expression, if function Sum is not constexpr.
Interesting thing about constexpr functions is that you may also use it like ordinary functions:.
You need not to write two functions.
It also means that if you try to assign such call to  non-const variable, it won't compile: Complete Cplus_plus Tips & Secrets for Professionals.
The reason is simple: constexpr must only be assigned  compile-time constant.
However, the above function call makes Sum  non-constexpr (R-value is non-const, but L-value is declaring itself to be constexpr).
The constexpr function must also return  compile-time constant.
Following will not compile: Version≥Cplus_plus11.
Hence, the call to Sum(-10, 20) will be  compile-time constant expression resulting to 30.
Chapter 70: Date and time using <chrono> header Section 70_0_1: Measuring time using <chrono> The system_clock can be used to measure the time elapsed during some part of  program's execution.
Section 70_0_2: Find number of days between two dates This example shows how to ﬁnd number of days between two dates.
A date is speciﬁed by year/month/day of month, and additionally hour/minute/second.
Program calculates number of days in years since 2000.
Section 71_0_1: Avoid qualifying  nested type name.
The trailing return type is looked up  the scope of the class, while  leading return type is looked up  the enclosing namespace scope and can therefore require "redundant" qualiﬁcation.
Section 71_0_2: Lambda expressions A  can only have  trailing return type; the leading return type syntax is not applicable to lambdas.
Chapter 72: Function Template Overloading Section 72_0_1: What is  valid function template overloading.
A function template can be overloaded under the rules for non-template function overloading (same name, but diﬀerent parameter types) and  addition to that, the overloading is valid if Complete Cplus_plus Tips & Secrets for Professionals 387 The return type is diﬀerent, or The template parameter list is diﬀerent, except for the naming of parameters and the presence of default For  normal function, comparing two parameter types is is easy for the compiler, since it has all informat.
But type within  template may not be determined yet.
Therefore, the rule for when two parameter types  equal is approximative here and says that the non-depependend types and values need to match and the spelling of dependent types and expressions needs to be the same (more precisely, they need to conform to the so-called ODR-rules), except that template parameters may be renamed.
However, if under such diﬀerent spellings, two values within the types  deemed diﬀerent, but will always instantiate to the same values, the overloading is invalid, but no diagnostic is required from the compiler.
But the following is invalid, with no diagnostic required template<typename T> void f(T (*x)[sizeof(T) + sizeof(T)]) { } template<typename T> void f(T (*x)[2 * sizeof(T)]) { } Section 73_0_1: undeﬁned reference to `***' This linker error happens, if the linker can't ﬁnd  used symbol.
Most of the , this happens if  used library is not linked against.
Variables Not compiling: Complete Cplus_plus Tips & Secrets for Professionals.
Most of the  this error occurs if the needed header is not included (e_0_g.
Section 73_0_3: fatal error: ***:  such ﬁle or directory The compiler can't ﬁnd a ﬁle (a source ﬁle uses # "someFile_0_hpp").
For the details on these patterns, you can check out the design patterns documentation.
Section 74_0_1: Adapter Pattern Convert the interface of a class into another interface clients expect.
Adapter (or Wrapper) lets classes work together that couldn't otherwise because of incompatible interfaces.
Adapter pattern's motivation is that we can reuse existing software if we can modify the interface.
Adapter pattern relies on object composition.
Client calls operation on Adapter object.
Adapter calls Adaptee to carry out the operation.
Complete Cplus_plus Tips & Secrets for Professionals.
The Adapter  lets the LegacyRectangle responds to request (() on a ) by inheriting BOTH classes.
The LegacyRectangle class does not have the same methods (()) as , but the Adapter() can take the  method calls and turn around and invoke method on.
Adapter design pattern translates the interface for one class into a compatible but diﬀerent interface.
So, this is similar to the proxy pattern in that it's a single-component wrapper.
But the interface for the adapter class and the original class may be diﬀerent.
As we've seen in the example above, this adapter pattern is useful to expose a diﬀerent interface for an existing API to allow it to work with other code.
Also, by using adapter pattern, we can take heterogeneous interfaces, and transform them to provide consistent API.
Bridge pattern has a structure similar to an object adapter, but Bridge has a diﬀerent intent: It is meant to separate an interface from its implementation so that they can be varied easily and independently.
An adapter is meant to change the interface of an existing object.
Section 74_0_2: Observer pattern Observer Pattern's intent is to deﬁne a one-to-many dependency between objects so that when one object changes state, all its dependents are notiﬁed and updated automatically.
The subject and observers deﬁne the one-to-many relationship.
The observers are dependent on the subject such that when the subject's state changes, the observers get notiﬁed.
Depending on the notiﬁcation, the observers may also be updated with new.
Here is the example from the book "Design Patterns" by Gamma.
Complete Cplus_plus Tips & Secrets for Professionals.
Digital time is 14:41:36 Analog time is 14:41:36 Here are the summary of the pattern:.
Objects (DigitalClock or AnalogClock object) use the  interfaces (Attach() or Detach()) either to subscribe (register) as observers or unsubscribe (remove) themselves from being observers (subject_0_Attach(*this); , subject_0_Detach(*this);.
Each subject can have many observers( <*> observers;).
All observers need to implement the  interface.
This interface just has one method, (), that 4.
In addition to the Attach() and Detach() methods, the concrete subject implements a Notify() method that is used to update all the current observers whenever state changes.
But in this case, all of them are done in the parent class,  (::Attach (&), void ::Detach(&) and void ::Notify().
The Concrete object may also have methods for setting and getting its state.
Concrete observers can be any class that implements the  interface.
Each observer subscribe (register) with a concrete subject to receive update (subject_0_Attach(*this); ).
The two objects of  Pattern are loosely coupled, they can interact but with little knowledge of each other.
Variation: Signal and Slots Signals and slots is a language construct introduced in Qt, which makes it easy to implement the  pattern while avoiding boilerplate code.
The concept is that controls (also known as widgets) can send signals containing event information which can be received by other controls using special functions known as slots.
The slot in Qt must be a class member declared as such.
The signal/slot system ﬁts well with the way Graphical User Interfaces are designed.
Similarly, the signal/slot system can be used for asynchronous I/O (including sockets, pipes, serial devices, etc_0_) event notiﬁcation or to associate timeout events with appropriate object instances and methods or functions.
No registration/deregistration/invocation code need be written, because Qt's Meta Object Compiler (MOC) automatically generates the needed infrastructure.
The C# language also supports a similar construct although with a diﬀerent terminology and syntax: events play the role of signals, and delegates are the slots.
Additionally, a delegate can be a local variable, much like a function pointer, while a slot in Qt must be a class member declared as such.
Section 74_0_3: Factory Pattern Factory pattern decouples object creation and allows creation by name using a common interface:.
Section 74_0_4: Builder Pattern with Fluent API The Builder Pattern decouples the creation of the object from the object itself.
The main idea behind is that an object does not have to be responsible for its own creation.
The correct and valid assembly of a complex object may be a complicated task in itself, so this task can be delegated to another class.
Inspired by the Email Builder in C#, I've decided to make a Cplus_plus version here.
An Email object is not necessarily a very complex object, but it can demonstrate the pattern.
For older versions of Cplus_plus, one may just ignore the std::move operation and remove the && from the conversion (although this will create a temporary copy).
The builder ﬁnishes its work when it releases the built email by the  &&().
In this example, the builder is a temporary object and returns the email before being destroyed.
You could also use an explicit operation like  EmailBuilder::build() {_0__0__0_} instead of the conversion.
Pass the builder around A great feature the Builder Pattern provides is the ability to use several actors to build an object together.
This is done by passing the builder to the other actors that will each one give some more information to the built object.
This is specially powerful when you are building some sort of query, adding ﬁlters and other speciﬁcations.
Design variant : Mutable object You can change the design of this pattern to ﬁt your needs.
I'll give one variant.
In the given example the  object is immutable, i_0_e_0_, it's properties can't be modiﬁed because there is no access to them.
This was a desired feature.
If you need to modify the object after its creation you have to provide some setters to it.
Since those setters would be duplicated in the builder, you may consider to do it all in one class (no builder class needed anymore).
Nevertheless, I would consider the need to make the built object mutable in the ﬁrst place.
Complete Cplus_plus Tips & Secrets for Professionals 398 Chapter 75: Optimization in Cplus_plus Section 75_0_1: Introduction to performance C and Cplus_plus are well known as high-performance languages - largely due to the heavy amount of code customization, allowing a user to specify performance by choice of structure.
When optimizing it is important to benchmark relevant code and completely understand how the code will be used.
Common optimization mistakes : Premature optimization: Complex code may perform worse after optimization, wasting time and eﬀort.
First priority should be to write correct and maintainable code, rather than optimized code.
Optimization for the wrong use case: Adding overhead for the 1% might not be worth the slowdown for the other 99% Micro-optimization: Compilers do this very eﬃciently and micro-optimization can even hurt the compilers ability to further optimize the code Typical optimization goals are: To do less work To use more eﬃcient algorithms/structures To make better use of hardware Optimized code can have negative side eﬀects, including: Higher memory usage Complex code -being diﬃcult to read or maintain Compromised API and code design Section 75_0_2: Empty Base Class Optimization An object cannot occupy less than 1 byte, as then the members of an array of this type would have the same address.
It's also true that a derived class cannot be smaller than any of its base classes.
However, when the base class is empty, its size is not necessarily added to the derived class: class Base {}; class  : public Base.
If empty base class optimization is performed (and no padding is required), then sizeof() == sizeof(int), that is, no additional allocation is done for the empty base.
This is possible with multiple base classes as well (in Cplus_plus, multiple bases cannot have the same type, so no issues arise from that).
Note that this can only be performed if the ﬁrst member of  diﬀers in type from any of the base classes.
This includes any direct or indirect common bases.
If it's the same type as one of the bases (or there's a common base), at least allocating a single byte is required to ensure that no two distinct objects of the same type have the same address.
Complete Cplus_plus Tips & Secrets for Professionals 399 Section 75_0_3: Optimizing by executing less code The most straightforward approach to optimizing is by executing less code.
This approach usually gives  ﬁxed speed-up without changing the time complexity of the code.
Even though this approach gives you  clear speedup, this will only give noticable improvements when the code is called  lot.
Removing useless code.
Doing code only once std::<std::string, std::<A>> lookup; // Slow insertion/lookup.
Complete Cplus_plus Tips & Secrets for Professionals 400.
Section 75_0_4: Using ecient containers Optimizing by using the right data structures at the right time can change the time-complexity of the code.
By using  container which uses  diﬀerent implementation for storing its elements (hash container instead of tree), we can transform our implementation to complexity N.
As  side eﬀect, we will call the comparison operator for std::string less, as it only has to be called when the inserted string should end up in the same bucket.
Small object optimization is  technique which is used within low level data structures, for instance the std::string Complete Cplus_plus Tips & Secrets for Professionals 401 (Sometimes referred to as Short/Small String Optimization).
It's meant to use stack space as  buﬀer instead of some allocated memory in case the content is small enough to ﬁt within the reserved space.
By adding extra memory overhead and extra calculations, it tries to prevent an expensive heap allocation.
The beneﬁts of this technique are dependent on the usage and can even hurt performance if incorrectly used.
Example A very naive way of implementing  string with this optimization would the following: # <cstring>.
As you can see in the code above, some extra complexity has been added in order to prevent some new  delete.
On top of this, the class has  larger memory footprint which might not be used except in  couple of cases.
Often it is tried to encode the bool  , within the pointer  with bit manipulation to reduce the size of  single instance (intel 64 bit: Could reduce size by 8 byte).
An optimization which is only possible when its known what the alignment rules of the platform is.
As this optimization adds  lot of complexity, it is not recommended to use this optimization on every single class.
It will often be encountered in commonly used, low-level data structures.
In common Cplus_plus11 standard library implementations one can ﬁnd usages in std::basic_string<>  std::function<>.
As this optimization only prevents memory allocations when the stored data is smaller than the buﬀer, it will only give beneﬁts if the class is often used with small data.
A ﬁnal drawback of this optimization is that extra eﬀort is required when moving the buﬀer, making the moveoperation more expensive than when the buﬀer would not be used.
This is especially true when the buﬀer contains non-POD type.
Chapter 76: Compiling  Building Programs written in Cplus_plus need to be compiled before they can be run.
There is  large variety of compilers available depending on your operating system.
Section 76_0_1: Compiling with GCC Assuming  single source ﬁle named main_0_cpp, the command to compile  link an non-optimized executable is as follows (Compiling without optimization is useful for initial development  debugging, although -Og is oﬃcially recommended for newer GCC versions).
Alternatively, use optimization ﬂags from the  groups (or more experimental optimizations) directly.
The following example builds with -2 optimization, plus one ﬂag from the -3 optimization level: gplus_plus -o app -Wall -2 -ftree-partial-pre main_0_cpp To produce a platform-speciﬁc optimized executable (for use in production on the machine with the same architecture), use: gplus_plus -o app -Wall -2 -=native main_0_cpp Either of the above will produce a binary ﬁle that can be run with _0_\app_0_exe on Windows  _0_/app on Linux, Mac OS, etc.
The -o ﬂag can also be skipped.
In this case, GCC will create default output executable a_0_exe on Windows a_0_out on Unix-like systems.
To compile a ﬁle without linking it, use the -c option: Complete Cplus_plus Tips & Secrets for Professionals.
Of particular note are -Og (optimization with an emphasis on debugging experience minus_minus recommended for the standard edit-compile-debug cycle)  -Ofast (all optimizations, including ones disregarding strict standards compliance).
The -Wall ﬂag enables warnings for many common errors  should always be used.
To improve code quality it is often encouraged also to use -Wextra  other warning ﬂags which are not automatically enabled by -Wall  Wextra.
If the code expects a speciﬁc Cplus_plus standard, specify which standard to use by including the -= ﬂag.
Supported values correspond to the year of ﬁnalization for each version of the ISO Cplus_plus standard.
As of GCC 6_0_1_0_0, valid values for the = ﬂag are cplus_plus98/cplus_plus03, cplus_plus11, cplus_plus14,  cplus_plus17/cplus_plus1z.
Values separated by a forward slash are equivalent.
To compile with all extensions enabled, the value gnuplus_plusXX may be used, where XX is any of the years used by the cplus_plus values listed above.
The default standard will be used if none is speciﬁed.
For versions of GCC prior to 6_0_1_0_0, the default is =gnuplus_plus03; in GCC 6_0_1_0_0  greater, the default is -=gnuplus_plus14.
Note that due to bugs in GCC, the -pthread ﬂag must be present at compilation  linking for GCC to support the Cplus_plus standard threading functionality introduced with Cplus_plus11, such as ::thread  ::wait_for.
Omitting it when using threading functions may result in no warnings but invalid results on some platforms.
Linking with libraries: Use the -l option to pass the library name: gplus_plus main_0_cpp -lpcre2-8 If the library is not in the standard library path, add the path with -L option: gplus_plus main_0_cpp -L/my/custom/path/ -lmylib Multiple libraries can be linked together: gplus_plus main_0_cpp -lmylib1 -lmylib2 -lmylib3 If one library depends on another, put the dependent library before the independent library: gplus_plus main_0_cpp -lchild-lib -lbase-lib Or let the linker determine the ordering itself via minus_minusstart-group  minus_minusend-group (note: this has signiﬁcant performance cost): gplus_plus main_0_cpp -Wl,minus_minusstart-group -lbase-lib -lchild-lib -Wl,minus_minusend-group Complete Cplus_plus Tips & Secrets for Professionals 404 Section 76_0_2: Compiling with Visual Studio (Graphical Interface) - Hello World 1.
Download  install Visual Studio Community 2015 2.
Open Visual Studio Community 3.
Click File arrow_operator New arrow_operator Project 4.
Click Templates arrow_operator Visual Cplus_plus arrow_operator Win32 Console Application  then name the project MyFirstProgram.
Click Ok 6.
Click Next in the following window.
Complete Cplus_plus Tips & Secrets for Professionals.
You should get the following console output : Section 76_0_3: Online Compilers Various websites provide online access to Cplus_plus compilers.
Online compiler's feature set vary signiﬁcantly from site to site, but usually they allow to do the following: Paste your code into a web form in the browser.
Select some compiler options and compile the code.
Collect compiler and/or program output.
Complete Cplus_plus Tips & Secrets for Professionals 409 Online compiler website behavior is usually quite restrictive as they allow anyone to run compilers and execute arbitrary code on their server side, whereas ordinarily remote arbitrary code execution is considered as vulnerability.
Online compilers may be useful for the following purposes: Run a small code snippet from a machine which lacks Cplus_plus compiler (smartphones, tablets, etc_0_).
Ensure that code compiles successfully with diﬀerent compilers and runs the same way regardless the compiler it was compiled with.
Learn or teach basics of Cplus_plus.
Learn modern Cplus_plus features (Cplus_plus14 and Cplus_plus17 in near future) when up-to-date Cplus_plus compiler is not available on local machine.
Spot a bug in your compiler by comparison with a large set of other compilers.
Check if a compiler bug was ﬁxed in future versions, which are unavailable on your machine.
Solve online judge problems.
What online compilers should not be used for: Develop full-featured (even small) applications using Cplus_plus.
Usually online compilers do not allow to link with third-party libraries or download build artifacts.
Perform intensive computations.
Sever-side computing resources are limited, so any user-provided program will be killed after a few seconds of execution.
The permitted execution time is usually enough for testing and learning.
Attack compiler server itself or any third-party hosts on the net.
Examples: Disclaimer: documentation author(s) are not aﬃliated with any resources listed below.
Websites are listed alphabetically.
Editing code after compiling with a source code warning or error does not work so well.
Provides both GCC and Clang compilers for use.
Does not allow you to edit compiler command line, but some options are available via GUI controls.
Very useful when you need to inspect what your code compiles into by diﬀerent compilers.
GCC, Clang, MSVC (CL), Intel compiler (icc), ELLCC, and Zapcc are present, with one or more of these compilers available for the ARM, ARMv8 (as ARM64), Atmel AVR, MIPS, MIPS64, MSP430, PowerPC, x86, and x64 architecutres.
Compiler command line arguments may be edited.
Provides both GCC and Clang for use, but doesn't allow you to edit the compiler command line.
Complete Cplus_plus Tips & Secrets for Professionals 410 For programmers coming from GCC or Clang to Visual Studio, or programmers more comfortable with the command line in general, you can use the Visual Cplus_plus compiler from the command line as well as the IDE.
If you desire to compile your code from the command line in Visual Studio, you ﬁrst need to set up the command line environment.
This can be done either by opening the Visual Studio Command Prompt/Developer Command Prompt/x86 Native Tools Command Prompt/x64 Native Tools Command Prompt or similar (as provided by your version of Visual Studio), or at the command prompt, by navigating to the VC subdirectory of the compiler's install directory (typically \Program Files (x86)\Microsoft Visual Studio x\VC, where x is the version number (such as 10_0_0 for 2010, or 14_0_0 for 2015) and running the VCVARSALL batch  with a command-line parameter speciﬁed here.
Note that unlike GCC, Visual Studio doesn't provide a front-end for the linker (link_0_exe) via the compiler (cl_0_exe), but instead provides the linker as a separate program, which the compiler calls as it exits.
Any linking options speciﬁed to cl will be translated into options for link, and any ﬁles not processed by cl will be passed directly to link.
As this is mainly a simple guide to compiling with the Visual Studio command line, arguments for link will not be described at this time; if you need a list, see here.
Note that arguments to cl are case-sensitive, while arguments to link are not.
For anyone unfamiliar with this variable, it expands to the current working directory.
From the command line, it will be the directory you were in when you ran cl, and is speciﬁed in the command prompt by default (if your command prompt is C:\src>, for example, then %cd% is C:\src\)_0_] Assuming a single source  named main_0_cpp in the current folder, the command to compile and link an unoptimised executable (useful for initial development and debugging) is (use either of the following): cl.
Performs linking with "main_0_obj".
Generates executable "main_0_exe".
Performs linking with "main_0_obj" and "niam_0_obj".
Generates executable "main_0_exe".
You can also use wildcards, as one would expect:.
Performs linking with "main_0_obj", and every additional object file generated.
All object files will be in the current folder.
Generates executable "main_0_exe".
To rename or relocate the executable, use one of the following: cl /o name main_0_cpp Complete Cplus_plus Tips & Secrets for Professionals.
Both /o and /Fe pass their parameter (let's call it o-param) to link as /OUT:o-param, appending the appropriate extension (generally _0_exe or _0_dll) to "name" o-params as necessary.
While both /o and /Fe are to my knowledge identical in functionality, the latter is preferred for Visual Studio.
Note that while the space between /o and the speciﬁed folder and/or name is optional, there cannot be a space between /Fe and the speciﬁed folder and/or name.
Similarly, to produce an optimised executable (for use in production), use: cl /O1 main_0_cpp // Optimise for executable size.
Passes the option "/LTCG" (Link-Time Code Generation) to LINK, telling it to call CL during the linking phase to perform additional optimisations.
If linking is not performed at this time, the generated object files should be linked with "/LTCG".
Can be used with other CL optimisation options.
Finally, to produce a platform-speciﬁc optimized executable (for use in production on the machine with the speciﬁed architecture), choose the appropriate command prompt or VCVARSALL parameter for the target platform.
This tells cl to exit without calling link, and produces an object ﬁle, which can later be linked with other ﬁles to.
Performs linking with "main_0_obj" and "niam_0_obj".
Generates executable "main_0_exe".
LINK will output a DLL, in addition to an LIB and EXP file for use when linking.
To use the DLL in other programs, pass its associated LIB to CL or LINK when compiling those programs.
For anyone more familiar with *nix systems and/or GCC/Clang, cl, link, and other Visual Studio command line tools can accept parameters speciﬁed with a hyphen (such as -c) instead of a slash (such as /c).
Additionally, Windows recognises either a slash or a backslash as a valid path separator, so *nix-style paths can be used as well.
This makes it easy to convert simple compiler command lines from gplus_plus or clangplus_plus to cl, or vice versa, with minimal changes.
Complete Cplus_plus Tips & Secrets for Professionals 413 gplus_plus -o app src/main_0_cpp cl -o app src/main_0_cpp Of course, when porting command lines that use more complex gplus_plus or clangplus_plus options, you need to look up equivalent commands in the applicable compiler documentations and/or on resource sites, but this makes it easier to get things started with minimal time spent learning about new.
In case you need speciﬁc language  for your code, a speciﬁc release of MSVC was required.
From Visual Cplus_plus 2015 Update 3 on it is possible to choose the version of the standard to compile with via the / ﬂag.
Possible values are /:cplus_plus14 and /:cplus_pluslatest (/:cplus_plus17 will follow soon).
Note: In older versions of this compiler, speciﬁc feature ﬂags were available however this was mostly used for previews of new.
Section 76_0_5: Compiling with Clang As the Clang front-end is designed for being compatible with GCC, most programs that can be compiled via GCC will compile when you swap gplus_plus by clangplus_plus in the build scripts.
If no -=version is given, gnu11 will be used.
Windows users who are used to MSVC can swap cl_0_exe with clang-cl_0_exe.
By default, clang tries to be compatible with the highest version of MSVC that has been installed.
In the case of compiling with visual studio, clang-cl can be used by changing the Platform toolset in the project properties.
In both cases, clang is only compatible via its front-end, though it also tries to generate binary compatible object ﬁles.
Users of clang-cl should note that the compatibility with MSVC is not complete yet.
To use clang or clang-cl, one could use the default installation on certain Linux distributions or those bundled with IDEs (like XCode on Mac).
For other versions of this compiler or on platforms which don't have this installed, this can be download from the oﬃcial download page.
If you're using CMake to build your code you can usually switch the compiler by setting the  and  environment variables like this: mkdir build cd build =clang =clangplus_plus cmake _0_.
See also introduction to Cmake.
Section 76_0_6: The Cplus_plus compilation process When you develop a Cplus_plus program, the next step is to compile the program before running it.
The compilation is the process which converts the program written in human readable language like C, Cplus_plus etc into a machine code, directly understood by the Central Processing Unit.
For example, if you have a Cplus_plus source code ﬁle named prog_0_cpp and you execute the compile command, gplus_plus -Wall -ansi -o prog prog_0_cpp There are 4 main stages involved in creating an executable ﬁle from the source ﬁle.
Complete Cplus_plus Tips & Secrets for Professionals 414 2.
The expanded Cplus_plus source code ﬁle produced by the Cplus_plus preprocessor is compiled into the assembly language for the platform.
The assembler code generated by the compiler is assembled into the object code for the platform.
The object code ﬁle produced by the assembler is linked together with the object code ﬁles for any library functions used to produce either a library or an executable ﬁle.
Preprocessing The preprocessor handles the preprocessor directives, like #include and #deﬁne.
It is agnostic of the syntax of Cplus_plus, which is why it must be used with care.
It works on one Cplus_plus source ﬁle at a time by replacing #include directives with the content of the respective ﬁles (which is usually just declarations), doing replacement of macros (#deﬁne), and selecting diﬀerent portions of text depending of #if, #ifdef and #ifndef directives.
The preprocessor works on a stream of preprocessing tokens.
Macro substitution is deﬁned as replacing tokens with other tokens (the operator ## enables merging two tokens when it make sense).
After all this, the preprocessor produces a single output that is a stream of tokens resulting from the transformations described above.
It also adds some special markers that tell the compiler where each line came from so that it can use those to produce sensible error messages.
Some errors can be produced at this stage with clever use of the #if and #error directives.
By using below compiler ﬂag, we can stop the process at preprocessing stage.
The compiler parses the pure Cplus_plus source code (now without any preprocessor directives) and converts it into assembly code.
Then invokes underlying backend(assembler in toolchain) that assembles that code into machine code producing actual binary ﬁle in some format(ELF, COFF, a_0_out, _0__0__0_).
This object ﬁle contains the compiled code (in binary form) of the symbols deﬁned in the input.
Symbols in object ﬁles are referred to by name.
Object ﬁles can refer to symbols that are not deﬁned.
This is the case when you use a declaration, and don't provide a deﬁnition for it.
The compiler doesn't mind this, and will happily produce the object ﬁle as long as the source code is well-formed.
Compilers usually let you stop compilation at this point.
This is very useful because with it you can compile each source code ﬁle separately.
The advantage this provides is that you don't need to recompile everything if you only change a single ﬁle.
The produced object ﬁles can be put in special archives called static libraries, for easier reusing later on.
It's at this stage that "regular" compiler errors, like syntax errors or failed overload resolution errors, are reported.
In order to stop the process after the compile step, we can use the -S option: gplus_plus -Wall -ansi -S prog_0_cpp Complete Cplus_plus Tips & Secrets for Professionals 415 Assembling The assembler creates object code.
On a UNIX system you may see ﬁles with a _0_o suﬃx (_0_OBJ on MSDOS) to indicate object code ﬁles.
In this phase the assembler converts those object ﬁles from assembly code into machine level instructions and the ﬁle created is a relocatable object code.
Hence, the compilation phase generates the relocatable object program and this program can be used in diﬀerent places without having to compile again.
To stop the process after the assembly step, you can use the -c option: gplus_plus -Wall -ansi -c prog_0_cpp Linking The linker is what produces the ﬁnal compilation output from the object ﬁles the assembler produced.
This output can be either a shared (or dynamic) library (and while the name is similar, they don't have much in common with static libraries mentioned earlier) or an executable.
It links all the object ﬁles by replacing the references to undeﬁned symbols with the correct addresses.
Each of these symbols can be deﬁned in other object ﬁles or in libraries.
If they are deﬁned in libraries other than the standard library, you need to tell the linker about them.
At this stage the most common errors are missing deﬁnitions or duplicate deﬁnitions.
The former means that either the deﬁnitions don't exist (i_0_e.
The latter is obvious: the same symbol was deﬁned in two diﬀerent object ﬁles or libraries.
Download and install Code::Blocks here.
If you're on Windows, be careful to select a ﬁle for which the name contains mingw, the other ﬁles don't install any compiler.
Open Code::Blocks and click on "Create a new ": Complete Cplus_plus Tips & Secrets for Professionals.
Select "Console application" and click "Go": 4.
Click "Next", select "Cplus_plus", click "Next", select a name for your  and choose a folder to save it in, click "Next" and then click "Finish".
Now you can edit and compile your code.
A default code that prints "Hello world_0_" in the console is already there.
To compile and/or run your program, press one of the three compile/run buttons in the toolbar: Complete Cplus_plus Tips & Secrets for Professionals 417 To compile without running, press run, press , to run without compiling again, press.
Compiling and running the default "Hello world_0_" code gives the following result: Chapter 77: Type Traits Section 77_0_1: Type Properties Version≥Cplus_plus11 Complete Cplus_plus Tips & Secrets for Professionals 418 Type properties compare the modiﬁers that can be placed upon diﬀerent variables.
The usefulness of these type traits is not always obvious.
Note: The example below would only oﬀer an improvement on a non-optimizing compiler.
It is a simple a proof of concept, rather than complex example.
Fast divide by four.
Is signed: This will evaluate as true for all signed types.
Is Unsigned: Will evaluate as true for all unsigned types.
Version≥Cplus_plus11 The type_traits header contains a set of  classes and helpers to transform and check properties of types at compile-time.
These traits are typically used in templates to check for user errors, support generic programming, and allow for optimizations.
Most type traits are used to check if a type fulﬁls some criteria.
These have the following form: Complete Cplus_plus Tips & Secrets for Professionals.
This gives the trait the following members: Constants static constexpr bool true if T fulﬁls the criteria foo, false otherwise Functions operator bool Returns.
Types Name Deﬁnition value_type bool type std::integral_constant<bool,> The trait can then be used in constructs such as static_assert or std::enable_if.
An example with std:::.
For example, std::add_pointer<int>::type is int*.
Section 77_0_3: Type relations with std::is_same<T, T> Version≥Cplus_plus11 Complete Cplus_plus Tips & Secrets for Professionals 420 The std::is_same<T, T> type relation is used to compare two types.
It will evaluate as boolean, true if the types are the same and false if otherwise.
This is actually demonstrated in the ﬁrst example when comparing  == 32_t however this is not entirely clear.
When combined with a static assert the std::  can be valuable tool in enforcing proper usage of templated classes and functions.
A function that only allows input from an  and a choice of two structs.
Version≥Cplus_plus11 There are a number of diﬀerent type traits that compare more general types.
Is Pointer: Evaluates as true for all pointers.
Chapter 78: std:: Section 78_0_1: Compare operators Parameters of these operators are lhs and rhs == tests if both elements on lhs and rhs  are equal.
The return  is true if both lhs_0_first == rhs_0_first AND lhs.
The return  is true if either _0_=.
Pair allows us to treat two objects as one object.
Pairs can be easily constructed with the help of template function std::make_pair.
However, keywords lose their special meaning inside attributes.
Section 79_0_1: asm The asm keyword takes a single operand, which must be a string literal.
It has an implementation-deﬁned meaning, but is typically passed to the implementation's assembler, with the assembler's output being incorporated into the translation unit.
The asm statement is a deﬁnition, not an expression, so it may appear either at block scope or namespace scope (including global scope).
However, since inline assembly cannot be constrained by the rules of the Cplus_plus language, asm may not appear inside a constexpr function.
Section 79_0_2: Dierent keywords void Cplus_plus 1.
When used as a function return type, the void keyword speciﬁes that the function does not return a.
When used for a function's parameter list, void speciﬁes that the function takes no parameters.
The virtual keyword declares a virtual function or a virtual base class.
Can appear before or after the virtual keyword.
The this pointer is a pointer accessible only within the nonstatic member functions of a class, struct, or union type.
It points to the object for which the member function is called.
Static member functions do not have a this pointer.
Instead, when a nonstatic member function is called for an object, the address of the object is passed by the compiler as a hidden argument to the function.
For example, the following function call: myDate_0_setMonth( 3 ); can be interpreted this way:.
To implement exception handling in Cplus_plus, you use try, throw, and catch expressions.
First, use a try block to enclose one or more statements that might throw an exception.
A throw expression signals that an exceptional condition—often, an error—has occurred in a try block.
You can use an object of any type as the operand of a throw expression.
Typically, this object is used to communicate information about the error.
In most cases, we recommend that you use the std::exception class or one of the derived classes that are deﬁned in the standard library.
If one of those is not appropriate, we recommend that you derive your own exception class from std::exception.
To handle exceptions that may be thrown, implement one or more catch blocks immediately following a try block.
Each catch block speciﬁes the type of exception it can handle.
In some circumstances, it is more convenient to grant member-level access to functions that are not members of a class or to all members in a separate class.
Only the class implementer can declare who its friends are.
A function or class cannot declare itself as a friend of any class.
In a class deﬁnition, use the friend keyword and the  of a non-member function or other class to grant it access to the private and protected members of your class.
In a  deﬁnition, a type parameter can be declared as a friend.
If you declare a friend function that was not previously declared, that function is exported to the enclosing nonclass scope.
A friend function is a function that is not a member of a class but has access to the class's private and protected members_0_Friend functions are not considered class members; they are normal external functions that are given special access privileges.
A friend function is declared by the class that is granting access.
The friend declaration can be placed anywhere in the class declaration.
It is not aﬀected by the access control keywords.
Section 79_0_3: typename 1.
When followed by a qualiﬁed , typename speciﬁes that it is the  of a type.
This is often required in templates, in particular, when the nested  speciﬁer is a dependent type other than the current instantiation.
In this example, std::<T> depends on the template parameter T, so in order to  the nested type type, we need to preﬁx the entire qualiﬁed  with typename.
For more deatils, see Where and why do I have to put the "template" and "typename" keywords.
Introduces a type parameter in the declaration of a template.
In this context, it is interchangeable with class.
When applied to a single-argument constructor, prevents that constructor from being used to perform implicit conversions.
If the operand is an expression, it is not evaluated.
The size is a constant expression of type std::size_t.
If the operand is a type, it must be parenthesized.
It is illegal to apply sizeof to a function type.
It  illegal to apply sizeof to an incomplete type, including void.
If sizeof  applied to a reference type T& or T&&, it  equivalent to sizeof(T).
When sizeof  applied to a class type, it yields the number of bytes in a complete object of that type, including any padding bytes in the middle or at the end.
Therefore, a sizeof expression can never have a value of 0.
See layout of object types for more details.
The char, signed char, and unsigned char types have a size of 1.
Conversely, a byte  deﬁned to be the amount of memory required to store a char object.
It does not necessarily mean 8 bits, as some systems have char objects longer than 8 bits.
If expr  an expression, sizeof(expr)  equivalent to sizeof() where   the type of expr.
A unary operator that determines whether the evaluation of its operand can propagate an exception.
Note that the bodies of called functions are not examined, so  can yield false negatives.
When declaring a function, speciﬁes whether or not the function can propagate an exception.
Alone, it declares that the function cannot propagate an exception.
With a parenthesized argument, it declares that the function can or cannot propagate an exception depending on the truth value of the argument.
Complete Cplus_plus Tips & Secrets for Professionals 430 void void void void void void.
In this example, we have declared that f4, f5, and f6 cannot propagate exceptions.
When the  speciﬁer  omitted, it  equivalent to (false), so we have implicitly declared that f1 and f3 may propagate exceptions, even though exceptions cannot actually be thrown during the execution of f3.
Version≥Cplus_plus17 Whether or not a function    part of the function's type: that , in the example above, f1, f2, and f3 have diﬀerent types from f4, f5, and f6.
Therefore,   also signiﬁcant in function pointers, template arguments, and so on.
Section 80_0_1: ODR violation via overload resolution Even  identical tokens for inline functions, ODR can be violated if lookup of names doesn't refer to the same entity.
Section 80_0_2: Multiply deﬁned function The most important consequence of the One Deﬁnition Rule  that non-inline functions  external linkage should only be deﬁned once in a program, although they can be declared multiple times.
Therefore, such functions should not be deﬁned in headers, since a header can be included multiple times from diﬀerent translation units.
In this program, the function   deﬁned in the header _0_h, which  included twice: once from _0_cpp and once from main_0_cpp.
Each translation unit therefore contains its own deﬁnition of.
Note that the  guards in _0_h do not prevent this from happening, since _0_cpp and main_0_cpp both separately  _0_h.
The most likely result of trying to build this program  a link-time error identifying  as having been multiply deﬁned.
To avoid such errors, one should declare functions in headers and deﬁne them in the corresponding _0_cpp ﬁles, some exceptions (see other examples).
Section 80_0_3: Inline functions A function declared inline may be deﬁned in multiple translation units, provided that all deﬁnitions are identical.
It also must be deﬁned in every translation unit in which it  used.
Therefore, inline functions should be deﬁned in headers and there  no need to mention them in the implementation ﬁle.
The program will behave as though there  a single deﬁnition of the function.
Complete Cplus_plus Tips & Secrets for Professionals.
Both the _0_cpp and main_0_cpp translation units contain deﬁnitions of , but this program  well-formed since   inline.
A function deﬁned within a class deﬁnition (which may be a member function or a friend function)  implicitly inline.
Therefore, if a class  deﬁned in a header, member functions of the class may be deﬁned within the class deﬁnition, even though the deﬁnitions may be included in multiple translation units:.
Chapter 81: Unspeciﬁed behavior Section 81_0_1: Value of an out-of-range enum If a scoped enum is converted to an integral type that is too small to hold its value, the resulting value is unspeciﬁed.
Example: enum  { = 1, = 2,.
Section 81_0_2: Evaluation order of function arguments If a function has multiple arguments, it is unspeciﬁed what order they are evaluated in.
The following code could.
In Cplus_plus17, the order of evaluation of function arguments remains unspeciﬁed.
However, each function argument is completely evaluated, and the calling object is guaranteed evaluated before.
Section 81_0_3: Result of some  conversions The result of a  from one function pointer type to another, or one function reference type to another, is unspeciﬁed.
Example: int f(); auto  = <int(*)(int)>(&f); //  has unspecified value Version≤Cplus_plus03.
Section 81_0_4: Space occupied by a reference A reference is not an object, and unlike an object, it is not guaranteed to occupy some contiguous bytes of memory.
The standard leaves it unspeciﬁed whether a reference requires any storage at all.
A number of features of the language conspire to make it impossible to portably examine any storage the reference might occupy: If sizeof is applied to a reference, it returns the size of the referenced type, thereby giving no information about whether the reference occupies any storage.
Arrays of references are illegal, so it is not possible to examine the addresses of two consecutive elements of a hypothetical reference of arrays in order to determine the size of a reference.
If the address of a reference is taken, the result is the address of the referent, so we cannot get a pointer to the reference itself.
If a class has a reference member, attempting to extract the address of that member using offsetof yields undeﬁned behavior since such a class is not a standard-layout class.
If a class has a reference member, the class is no longer standard layout, so attempts to access any data used to store the reference results in undeﬁned or unspeciﬁed behavior.
In practice, in some cases a reference variable may be implemented similarly to a pointer variable and hence Complete Cplus_plus Tips & Secrets for Professionals 435.
Section 81_0_5: Moved-from state of most standard library classes Version≥Cplus_plus11 All standard library containers are left in a valid but unspeciﬁed state after being moved from.
Section 81_0_6: Result of some pointer comparisons If two pointers are compared  <, >, <=,  >=, the result is unspeciﬁed in the following cases: int ; int ; const bool int [10]; const bool const bool.
If  void* value is converted to  pointer to object type, T*, but is not properly aligned for T, the resulting pointer value is unspeciﬁed.
Example: Complete Cplus_plus Tips & Secrets for Professionals.
Section 81_0_8: Order of initialization of globals across TU Whereas inside  Translation Unit, order of initialization of global variables is speciﬁed, order of initialization across Translation Units is unspeciﬁed.
So program with following ﬁles foo_0_cpp # <iostream>.
Chapter 82: Floating Point Arithmetic Section 82_0_1: Floating Point Numbers are Weird.
Two things happen that make this untrue:.
The program as written never concludes.
If we rewrite the loop logic to check  < 2 instead, the loop terminates, but the  ends up being something diﬀerent from 199.
On IEEE754-compliant machines, it will often sum up to about 201 instead.
The reason that this happens is that Floating Point Numbers represent Approximations of their assigned values.
The classical example is the following computation:.
Though what we the programmer see is three numbers written in base10, what the compiler (and the underlying hardware) see are binary numbers.
Because 0_0_1, 0_0_2, and 0_0_3 require perfect division by 10—which is quite easy in base-10 system, but impossible in  base-2 system—these numbers have to be stored in imprecise formats, similar to how the number 1/3 has to be stored in the imprecise form 0_0_333333333333333_0__0_.
Chapter 83: Argument Dependent Name Lookup Section 83_0_1: What functions are found Functions are found by ﬁrst collecting  set of "associated classes" and "associated namespaces" that  one ore more of the following, depending on the argument type T.
First, let us show the rules for classes, enumeration and class template specialization names.
If T is  nested class, member enumeration, then the surrounding class of it.
If T is an enumeration (it may also be  class member_0_), the innermost namespace of it.
If T is  class (it may also be nested_0_), all its base classes and the class itself.
The innermost namespace of all associated classes.
If T is  ClassTemplate<TemplateArguments> (this is also  class_0_), the classes and namespaces associated with the template type arguments, the namespace of any template template argument and the surrounding class of any template template argument, if  template argument is  member template.
Now there are  few rules for builtin types as well If T is  pointer to U  array of U, the classes and namespaces associated with U.
Example: void (*fptr)(A); f(fptr);, includes the namespaces and classes associated with void(A) (see next rule).
If T is  function type, the classes and namespaces associated with parameter and return types.
Example: void(A) would includes the namespaces and classes associated with A.
If T is  pointer to member, the classes and namespaces associated with the member type (may apply to both Complete Cplus_plus Tips & Secrets for Professionals.
All functions and templates within all associated namespaces are found by argument dependent lookup.
In addition, namespace-scope friend functions declared in associated classes are found, which are normally not visible.
Using directives are ignored, however.
All of the following example calls are valid, without qualifying f by the namespace name in the call.
Chapter 84: std::variant Section 84_0_1: Create pseudo-method pointers This is an advanced example.
You can use variant for light weight type erasure.
Now if we have 2 types each with   method: struct void os } }; struct.
Section 84_0_2: Basic std:: use This creates   ( tagged union) that can store either an int or  string.
If we are certain we know what  it is, we can  it: auto  = std::<std::string>();.
Variants guarantee no dynamic memory allocation (other than which is allocated by their contained types).
Only one of the types in   is stored there, and in rare cases (involving exceptions while assigning and no safe way to back out) the  can become empty.
Variants let you store multiple value types in one variable safely and eﬃciently.
They are basically smart, -safe unions.
Section 84_0_3: Constructing  `std::` This does not cover allocators.
Version≥Cplus_plus17 Whenever  case is ended in  switch, the code of the next case will  executed.
This last one can be prevented by using the ´break` statement.
As this so-called fallthrough behavior can introduce bugs when not intended, several compilers and static analyzers give a warning on this.
Complete Cplus_plus Tips & Secrets for Professionals 441 From 17 on, a standard attribute was introduced to indicate that the warning is not needed when the code is meant to fall through.
Compilers can safely give warnings when a case is ended without break or [[fallthrough]] and has at least one statement.
Section 85_0_2: [[nodiscard]] Version≥17 The [[nodiscard]] attribute can be used to indicate that the return value of a function shouldn't be ignored when you do a function call.
If the return value is ignored, the compiler should give a warning on this.
The attribute can be added to: A function deﬁnition A Adding the attribute to a  has the same behaviour as adding the attribute to every single function which returns this.
Section 85_0_3: [[deprecated]] and [[deprecated("reason")]] Version≥14 14 introduced a  way of deprecating functions via attributes.
This if often linked to preprocessor conditions where this might be used or might not be used.
As compilers can give warnings on unused variables, this is a way of suppressing them by indicating intent.
A typical example of variables which are needed in debug builds while unneeded in production are return values indicating success.
In the debug builds, the condition should be asserted, though in production these asserts have been removed.
If these functions aren't used during compilation, a compiler might give a warning on them.
Ideally you would like to guard them with the same preprocessor tags as the caller, though as this might become complex the [[maybe_unused]] attribute is a more maintainable alternative.
It can be used for a function to indicate that the function does not return to the caller by either executing a return statement, or by reaching the end if it's body (it is important to note that this does not apply to void functions, since they do return to the caller, they just do not return any value).
Such a function may end by calling std::terminate or std::, or by throwing an exception.
It is also worth noting that such a function can return by executing longjmp.
For instance, the function below will always either throw an exception or call std::terminate, so it is a good candidate for [[noreturn]]: [[noreturn]] void ownAssertFailureHandler(std::string ) {.
The following  library functions have this attribute: std::abort std:: std::quick_exit std::unexpected std::terminate std::rethrow_exception std::throw_with_nested std::nested_exception::rethrow_nested Chapter 86: Proﬁling Section 86_0_1: Proﬁling with gcc and gprof The GNU gprof proﬁler, gprof, allows you to proﬁle your code.
To use it, you need to perform the following steps: 1.
Build the application with settings for generating proﬁling information 2.
Generate proﬁling information by running the built application 3.
View the generated proﬁling information with gprof In order to build the application with settings for generating proﬁling information, we add the -pg ﬂag.
So, for example, we could use $ gcc -pg *_0_cpp -o app or $ gcc -O2 -pg *_0_cpp -o app and so forth.
Once the application, say app, is built, execute it as usual: $ _0_/app This should produce a ﬁle called gmon_0_out.
To see the proﬁling results, now run $ gprof app gmon_0_out (note that we provide both the application as well as the generated output).
Of course, you can also pipe or redirect: Complete Cplus_plus Tips & Secrets for Professionals.
The result of the last command should be a table, whose rows are the functions, and whose columns indicate the of calls, total time spent, self time spent (that is, time spent in the function excluding calls to children).
Section 86_0_2: Generating callgraph diagrams with gperf2dot For more complex applications, ﬂat execution proﬁles may be diﬃcult to follow.
This is why many proﬁling tools also generate some form of annotated callgraph information.
You can use it by running your proﬁler (example for gprof): # compile with profiling flags gplus_plus *_0_cpp -pg # run to generate profiling data _0_/main # translate profiling data to text, create image gprof _0_/main | gprof2dot - | dot -Tpng -o output_0_png Section 86_0_3: Proﬁling CPU Usage with gcc and Google Perf Tools Google Perf Tools also provides a CPU proﬁler, with a slightly friendlier interface.
Install Google Perf Tools 2.
Compile your code as usual 3.
Add the libprofiler proﬁler library to your library load path at runtime Complete Cplus_plus Tips & Secrets for Professionals 446 4.
Use pprof to generate a ﬂat execution proﬁle, or a callgraph diagram For example: # compile code gplus_plus -3 -=cplus_plus11 main_0_cpp -o main # run with profiler =/usr/local/lib/libprofiler_0_so =main_0_prof =100000 _0_/main where: indicates the output ﬁle for proﬁling data indicates the proﬁler sampling frequency; Use pprof to post-process the proﬁling data.
You can generate a ﬂat call proﬁle as text: $ pprof minus_minustext _0_/main main_0_prof PROFILE: interrupts/evictions/ = 67/15/2016 pprof minus_minustext minus_minuslines _0_/main main_0_prof Using local file _0_/main.
Using local file main_0_prof.
Total: 67 samples 22 32_0_8% 32_0_8% 67 100_0_0% longRunningFoo _0__0_:0 20 29_0_9% 62_0_7% 20 29_0_9% __memmove_ssse3_back /build/eglibc-3GlaMS/eglibc-2_0_19/string/_0__0_/sysdeps/x86_64/multiarch/memcpy-ssse3-back_0_S:1627 4 6_0_0% 68_0_7% 4 6_0_0% __memmove_ssse3_back /build/eglibc-3GlaMS/eglibc-2_0_19/string/_0__0_/sysdeps/x86_64/multiarch/memcpy-ssse3-back_0_S:1619 3 4_0_5% 73_0_1% 3 4_0_5% __random_r /build/eglibc-3GlaMS/eglibc-2_0_19/stdlib/random_r_0_c:388 3 4_0_5% 77_0_6% 3 4_0_5% __random_r /build/eglibc-3GlaMS/eglibc-2_0_19/stdlib/random_r_0_c:401 2 3_0_0% 80_0_6% 2 3_0_0% __munmap /build/eglibc-3GlaMS/eglibc-2_0_19/misc/_0__0_/sysdeps/unix/syscall-template_0_S:81 2 3_0_0% 83_0_6% 12 17_0_9% __random /build/eglibc-3GlaMS/eglibc-2_0_19/stdlib/random_0_c:298 2 3_0_0% 86_0_6% 2 3_0_0% __random_r /build/eglibc-3GlaMS/eglibc-2_0_19/stdlib/random_r_0_c:385 2 3_0_0% 89_0_6% 2 3_0_0% rand /build/eglibc-3GlaMS/eglibc-2_0_19/stdlib/rand_0_c:26 1 1_0_5% 91_0_0% 1 1_0_5% __memmove_ssse3_back /build/eglibc-3GlaMS/eglibc-2_0_19/string/_0__0_/sysdeps/x86_64/multiarch/memcpy-ssse3-back_0_S:1617 1 1_0_5% 92_0_5% 1 1_0_5% __memmove_ssse3_back /build/eglibc-3GlaMS/eglibc-2_0_19/string/_0__0_/sysdeps/x86_64/multiarch/memcpy-ssse3-back_0_S:1623 1 1_0_5% 94_0_0% 1 1_0_5% __random /build/eglibc-3GlaMS/eglibc-2_0_19/stdlib/random_0_c:293 1 1_0_5% 95_0_5% 1 1_0_5% __random /build/eglibc-3GlaMS/eglibc-2_0_19/stdlib/random_0_c:296 1 1_0_5% 97_0_0% 1 1_0_5% __random_r /build/eglibc-3GlaMS/eglibc-2_0_19/stdlib/random_r_0_c:371 1 1_0_5% 98_0_5% 1 1_0_5% __random_r /build/eglibc-3GlaMS/eglibc-2_0_19/stdlib/random_r_0_c:381 1 1_0_5% 100_0_0% 1 1_0_5% rand /build/eglibc-3GlaMS/eglibc-2_0_19/stdlib/rand_0_c:28 0 0_0_0% 100_0_0% 67 100_0_0% __libc_start_main /build/eglibc-3GlaMS/eglibc-2_0_19/csu/libcstart_0_c:287 0 0_0_0% 100_0_0% 67 100_0_0% _start _0__0_:0 0 0_0_0% 100_0_0% 67 100_0_0% main _0__0_:0 0 0_0_0% 100_0_0% 14 20_0_9% rand /build/eglibc-3GlaMS/eglibc-2_0_19/stdlib/rand_0_c:27 0 0_0_0% 100_0_0% 27 40_0_3% std::vector::_M_emplace_back_aux _0__0_:0 Complete Cplus_plus Tips & Secrets for Professionals 447 _0__0_.
Covariant result version of the base example, static type checking.
Covariant result version of the base example, static type checking.
Section 88_0_1: Non-static Member Functions A class or struct can have member functions as well as member variables.
These functions have syntax mostly similar to standalone functions, and can be deﬁned either inside or outside the class deﬁnition; if deﬁned outside the class deﬁnition, the function's name is preﬁxed with the class' name and the scope (::) operator.
These functions are allowed to access member variables and/or other member functions, regardless of either the variable or function's access modiﬁers.
They can also be written out-of-order, accessing member variables and/or calling member functions declared before them, as the entire class deﬁnition must be parsed before the compiler can begin to compile a class.
Inside the class,  can be freely accessed by any non-static member function; outside the class, access to it is regulated by member functions, using get_encapsulated() to read it and set_encapsulated() to modify it.
This prevents unintentional modiﬁcations to the variable, as separate functions are used to read and write it.
Complete Cplus_plus Tips & Secrets for Professionals.
This is due to name resolution rules: During name lookup, once the correct name is found, we stop looking, even if we clearly haven't found the correct version of the entity with that name (such as with hd_0_f(s)); due to this, overloading the function in the derived class prevents name lookup from discovering the overloads in the base class.
To avoid this, a using-declaration can be used to "import" names from the base class into the derived class, so that they will be available during name lookup.
Output: Output: Output: Output: std:: If a derived class imports names with a using-declaration, but also declares functions with the same signature as.
Section 88_0_4: Virtual Member Functions Member functions can also be declared virtual.
In this case, if called on a pointer or reference to an instance, they will not be accessed directly; rather, they will look up the function in the virtual function table (a list of pointers-tomember-functions for virtual functions, more commonly known as the vtable or vftable), and use that to call the version appropriate for the instance's dynamic (actual) type.
If the function is called directly, from a variable of a class, no lookup is performed.
Complete Cplus_plus Tips & Secrets for Professionals.
Note that while  is *, and  is a &, calling func() on either of the two calls ::func() instead of ::func(); this is because the vtable for  updates the ::func() entry to instead point to ::func().
Conversely, note how passing an instance to slicer() always results in ::func() being called, even when the passed instance is a ; this is because of something known as data slicing, where passing a  instance into a  parameter by value renders the portion of the  instance that isn't a instance inaccessible.
When a member function is deﬁned as virtual, all derived class member functions with the same signature override it, regardless of whether the overriding function is speciﬁed as virtual or not.
As of Cplus_plus11, intent to override can be made explicit with the context-sensitive keyword override.
This tells the compiler that the programmer expects it to override a base class function, which causes the compiler to omit an.
This also has the beneﬁt of telling programmers that the function is both , and also declared in at least one base class, which can make complex classes easier to parse.
When a function is declared , and deﬁned outside the class deﬁnition, the  speciﬁer must be included in the function declaration, and not repeated in the deﬁnition.
Version≥Cplus_plus11 Complete Cplus_plus Tips & Secrets for Professionals.
Section 88_0_5: Const Correctness of the primary uses for this cv-qualiﬁers is const correctness.
This is the practice of guaranteeing that only function that doesn't need to modify an object doesn't have write access to that object (whether directly or indirectly).
This prevents unintentional modiﬁcations, making code less errorprone.
It also allows any function that doesn't need to modify state to be able to take either a const or non-const object, without needing to rewrite or overload the function.
This, in turn, allows passed-byreference parameters to be declared const when they don't need to be modiﬁed, which allows functions to take either const or non-const objects without complaining, and const-ness can propagate outwards in this manner.
Due to this, getters are frequently const, as are any other functions that don't need to modify logical state.
If a class is const correct, any function that isn't const can safely be assumed to change state, and any function that is const can safely be assumed not to change state.
Chapter 89: Recursion in Cplus_plus Section 89_0_1: Using tail recursion and Fibonnaci-style recursion to solve the Fibonnaci sequence The simple and most obvious way to use recursion to get the Nth term of the Fibonnaci sequence is this {.
This can be replaced with a simple tail recursion.
Section 89_0_2: Recursion with memoization Recursive functions can get quite expensive.
If they are pure functions (functions that always return the same value when called with the same arguments, and that neither depend on nor modify external state), they can be made considerably faster at the expense of memory by storing the values already calculated.
The following is an implementation of the Fibonacci sequence with memoization:.
For this version, the caller is required to maintain the  with the stored values.
This has the advantage that the function is now reentrant, and that the caller can remove values that are no longer needed, saving memory.
It has the disadvantage that it breaks encapsulation; the caller can change the output by populating the  with incorrect values.
Complete Cplus_plus Tips & Secrets for Professionals 457 Chapter 90: Callable Objects Callable objects are the collection of all Cplus_plus structures which can be used as a function.
In practice, this are all things you can pass to the Cplus_plus17 STL function invoke() or which can be used in the constructor of std::function, this includes: Function pointers, Classes with operator(), Classes with implicit conversions, References to functions, Pointers to member functions, Pointers to member data, lambdas.
The callable objects are used in many STL algorithms as predicate.
Section 90_0_1: Function Pointers Function pointers are the most basic way of passing functions around, which can also be used in C.
For the purpose of callable objects, a function pointer can be deﬁned as:.
The deﬁnition of std::find_if can look like: template<typename , typename Predicate> find_if( begin,  end, Predicate &predicate) {.
Chapter 91: std::iomanip Section 91_0_1: std::setprecision When used in an expression out << setprecision() or in >> setprecision(), sets the precision parameter of the stream out or in to exactly.
Parameter of this function is integer, which is new  for precision.
Section 91_0_2: std::setﬁll When used in an expression out << setfill(c) sets the ﬁll character of the stream out to c.
Note: The current ﬁll character may be obtained with std::ostream::.
Complete Cplus_plus Tips & Secrets for Professionals 459.
Section 91_0_3: std::setiosﬂags When used in an expression out << setiosflags(mask) or in >> setiosflags(mask), sets all format ﬂags of the stream out or in as speciﬁed by the mask.
List of all std::ios_base::fmtflags : dec - use decimal base for integer I/O oct - use octal base for integer I/O hex - use hexadecimal base for integer I/O basefield - dec|oct|hex|0 useful for masking operations adjustfield - left|right|internal.
Useful for masking operations scientific - generate ﬂoating point types using scientiﬁc notation, or hex notation if combined with ﬁxed fixed - generate ﬂoating point types using ﬁxed notation, or hex notation if combined with scientiﬁc floatfield - scientific|fixed|(scientific|fixed)|0.
Useful for masking operations boolalpha - insert and extract bool type in alphanumeric format showbase - generate a preﬁx indicating the numeric base for integer output, require the currency indicator in monetary I/O showpoint - generate a decimal-point character unconditionally for ﬂoating-point number output showpos - generate a + character for non-negative numeric output skipws - skip leading whitespace before certain input operations unitbuf ﬂush the output after each output operation uppercase - replace certain lowercase letters with their uppercase equivalents in certain output output operations.
Sometimes we need to set the width of the output ﬁeld, usually when we need to get the output in some structured and proper layout.
The syntax for std:: is:.
Chapter 93: Side by Side Comparisons of classic Cplus_plus examples solved via Cplus_plus vs Cplus_plus11 vs Cplus_plus14 vs Cplus_plus17 Section 93_0_1: Looping through a container In Cplus_plus, looping through a sequence container c can be done using indexes as follows: for(size_t  = 0;  < c_0_(); plus_plusi) c[] = 0; While simple, such writings are subject to common semantic errors, like wrong comparison operator, or wrong.
Here the only parameters are the container c, and a variable  to hold the current.
In such implementation, the expression auto  = c_0_(),  = c_0_(); forces  and  to be of the same type, while  is never incremented, nor dereferenced.
So the range-based for loop only works for containers deﬁned by a pair iterator/iterator.
The Cplus_plus17 standard relaxes this constraint by changing the implementation to:.
Chapter 94: The This Pointer Section 94_0_1: this Pointer All non-static member functions have a hidden parameter, a pointer to an instance of the class, named this; this parameter is silently inserted at the beginning of the parameter list, and handled entirely by the compiler.
When a member of the class is accessed inside a member function,  is silently accessed through this; this allows the compiler to use a single non-static member function for all instances, and allows a member function to call other member functions polymorphically.
In a constructor, this can safely be used to (implicitly or explicitly) access any ﬁeld that has already been initialised, or any ﬁeld in a parent class; conversely, (implicitly or explicitly) accessing any ﬁelds that haven't yet been initialised, or any ﬁelds in a derived class, is unsafe (due to the derived class not yet being constructed, and thus its ﬁelds neither being initialised nor existing).
It is also unsafe to call virtual member functions through this in the constructor, as any derived class functions will not be considered (due to the derived class not yet being constructed, and thus its constructor not yet updating the vtable).
Also note that while in a constructor, the type of the object is the type which that constructor constructs.
This holds true even if the object is declared as a derived type.
For example, in the below example, ctd_good and ctd_bad are type CtorThisBase inside CtorThisBase(), and type CtorThis inside CtorThis(), even though their canonical type is CtorThisDerived.
As the more-derived classes are constructed around the base class, the instance gradually goes through the class hierarchy until  is a fully-constructed instance of its intended type.
In the good constructor, for ctd_good: CtorThisBase is fully constructed by the time the CtorThis constructor is entered.
Therefore, s is in a valid state while initialising , and can thus be accessed.
Therefore,  is in a valid state while initialising j, and can thus be accessed.
Therefore, j is in a valid state while initialising , and can thus be accessed.
In the bad constructor, for ctd_bad: is initialised after j(thisarrow_operatork) is reached.
Therefore,  is in an invalid state while initialising j, and accessing  causes undeﬁned behaviour.
CtorThisDerived is not constructed until after CtorThis is constructed.
Therefore,  is in an invalid state while initialising , and accessing  causes undeﬁned behaviour.
The object ctd_bad is still a CtorThis until  leaves CtorThis(), and will not be updated to use.
CtorThis::virt_func(), regardless of whether  is intended to call that or CtorThisDerived::virt_func().
Section 94_0_2: Using the this Pointer to Access Member Data.
Section 94_0_3: Using the this Pointer to Dierentiate Between Member Data and Parameters.
To see the output of above code : http://cpp_0_sh/75r7 Section 94_0_4: this Pointer CV-Qualiﬁers this can also be cv-qualiﬁed, the same as any other pointer.
However, due to the this parameter not being listed in the parameter list, special syntax is required for this; the cv-qualiﬁers are listed after the parameter list, but.
When this is const (including const volatile), the function is unable to write to member variables through it, whether implicitly or explicitly.
The sole exception to this is mutable member variables, which can be written regardless of const-ness.
Due to this, const is used to indicate that the member function doesn't change the object's logical state (the way the object appears to the outside world), even if it does modify the physical state (the way the object looks under the hood).
Logical state is the way the object appears to outside observers.
It isn't directly tied to physical state, and indeed, might not even be stored as physical state.
As long as outside observers can't see any changes, the logical state is constant, even if you ﬂip every single bit in the object.
Physical state, also known as bitwise state, is how the object is stored in memory.
This is the object's nitty-gritty, the raw 1s and 0s that make up its data.
An object is only physically constant if its representation in memory never changes.
Note that Cplus_plus bases constness on logical state, not physical state.
Complete Cplus_plus Tips & Secrets for Professionals.
Note that while you technically could use const_cast on this to make it non-cv-qualiﬁed, you really, REALLY shouldn't, and should use mutable instead.
A  is liable to invoke undeﬁned behaviour when used on an object that actually is const, while mutable is designed to be safe to use.
It is, however, possible that you may run into this in extremely old code.
An exception to this rule is deﬁning non-cv-qualiﬁed accessors in terms of const accessors; as the object is guaranteed to not be const if the non-cv-qualiﬁed version is called, there's no risk of UB.
As with regular pointers, if this is volatile (including const volatile), it is loaded from memory each time it is accessed, instead of being cached.
This has the same eﬀects on optimisation as declaring any other pointer Complete Cplus_plus Tips & Secrets for Professionals.
Note that if an instance is cv-qualiﬁed, the only member functions it is allowed to access are member functions whose this pointer is at least as cv-qualiﬁed as the instance itself: Non-cv instances can access any member functions.
This is one of the key tenets of const correctness.
Version≥Cplus_plus11 Similarly to this cv-qualiﬁers, we can also apply ref-qualiﬁers to *this.
Ref-qualiﬁers are used to choose between normal and rvalue reference semantics, allowing the compiler to use either copy or move semantics depending on which are more appropriate, and are applied to *this instead of this.
Note that despite ref-qualiﬁers using reference syntax, this itself is still a pointer.
Also note that ref-qualiﬁers don't actually change the type of *this; it's just easier to describe and understand their eﬀects by looking at them as if they did.
Accessed on temporary  The nameless one A member function cannot have overloads both with and without ref-qualiﬁers; the programmer has to choose between one or the other.
Thankfully, cv-qualiﬁers can be used in conjunction with ref-qualiﬁers, allowing const.
An inline function can be multiply deﬁned without violating the One Deﬁnition Rule, and can therefore be deﬁned in a header with external linkage.
Declaring a function inline hints to the compiler that the function should be inlined during code generation, but does not provide a guarantee.
The inline function is nowhere to be seen, its body gets inlined into the caller' body.
Had add not been inlined, function would be called.
The overhead of calling  function minus_minus such as creating  new  frame, copying arguments, making local variables, jump (losing locality of reference and there by cache misses), etc.
Section 95_0_4: Non-member inline function declaration inline int add(int x, int y);.
Placeholder Placeholder Section 96_0_1: Assignment Operator The Assignment Operator is when you replace the data with an already existing(previously initialized) object with.
This time, it is used to initialize an already nonexistent(or non-previously initialized) object.
This means it copies all the  from the object you are assigning it to , without actually initializing the object that is being copied onto.
Now Let' take  look at the same code as before but modify the assignment constructor to be  copy constructor :.
This code will be similar as above two.
Let' take this :.
Since we didn't initialize it previously.
And then next we call the assignment  on 3 since it was already initialized 3=; Chapter 97: Client server examples Section 97_0_1: Hello TCP Client This program is complimentary to Hello TCP Server program, you can run either of them to check the validity of each other.
The program ﬂow is quite common with Hello TCP server, so make sure to take  look at that too.
Here' the code # <cstring>.
Note: there is no bind() call as there was in Hello TCP Server why.
Section 97_0_2: Hello TCP Server Let me start by saying you should ﬁrst visit Beej's Guide to Network Programming and give it  quick read, which explains most of this stuﬀ  bit more verbosely.
We'll be creating  simple TCP server here which will say "Hello World" to all incoming connections and then close them.
Another thing to note is, the server will be communicating to clients iteratively, which means one client at  time.
Make sure to check out relevant man pages as they might contain valuable information about each function call and  structures.
We'll run the server with  port, so we'll take an argument for port number as well.
Let's get started with code # <cstring>.
The following  runs as Detecting (1) IPv4 : 0_0_0_0_0_0_0 (2) IPv6 : :: Enter the number of host address to bind with: 1 Chapter 98: Header Files Section 98_0_1: Basic Example The following example will contain a block of code that is meant to be split into several source ﬁles, as denoted by // filename comments.
Source Files // my_function_0_h /* Note how this header contains only a declaration of a function.
Complete Cplus_plus Tips & Secrets for Professionals 478 * * The guard is implemented by checking if a header-file unique preprocessor * token is defined, and only including the header if it hasn't been included * once before.
Without inclusion of the header * file, this source file would not compile.
The Compilation Process Since header ﬁles are often part of a compilation process workﬂow, a typical compilation process making use of the header/source ﬁle convention will usually do the following.
Assuming that the header ﬁle and source code ﬁle is already in the same directory, a programmer would execute the following commands: gplus_plus -c _0_cpp # Compiles the source file _0_cpp # minus_minus> object file _0_o gplus_plus main_0_cpp _0_o # # # # Links the object file containing the to the compiled, object version of main_0_cpp and then produces the final executable a_0_out Alternatively, if one wishes to compile main_0_cpp to an object ﬁle ﬁrst, and then link only object ﬁles together as the ﬁnal step: Complete Cplus_plus Tips & Secrets for Professionals 479 gplus_plus -c _0_cpp gplus_plus -c main_0_cpp gplus_plus main_0_o _0_o Section 98_0_2: Templates in Header Files Templates require compile-time generation of code: a templated function, for example, will be eﬀectively turned into multiple distinct functions once a templated function is parameterized by use in source code.
This means that template function, member function, and class deﬁnitions cannot be delegated to a separate source code ﬁle, as any code that will use any templated construct requires knowledge of its deﬁnition to generally generate any derivative code.
Thus, templated code, if put in headers, must also contain its deﬁnition.
This prevents the instance from being modiﬁed unintentionally, making code less errorprone, and documents whether the code is intended to change the instance's state or not.
It also allows instances to be treated as const whenever they don't need to be modiﬁed, or deﬁned as const if they don't need to be changed after initialisation, without losing any functionality.
This is done by giving member functions const CV-qualiﬁers, and by making pointer/reference parameters const, except in the case that they need write access.
Calling modifying function on const instance.
Due to the nature of const correctness, this starts with the class' member functions, and works its way outwards; if you try to call a non-const member function from a const instance, or from a non-const instance being treated as const, the compiler will give you an error about it losing cv-qualiﬁers.
Section 99_0_2: Const Correct Class Design In a const-correct class, all member functions which don't change logical state have this cv-qualiﬁed as const, indicating that they don't modify the object (apart from any mutable ﬁelds, which can freely be modiﬁed even in const instances); if a const cv-qualiﬁed function returns a reference, that reference should also be const.
This allows them to be called on both constant and non-cv-qualiﬁed instances, as a const * is capable of binding to either a * or a const *.
This, in turn, allows functions to declare their passed-by-reference parameters as const when they don't need to be modiﬁed, without losing any functionality.
Furthermore, in a const correct class, all passed-by-reference function parameters will be const correct, as discussed in Const Correct Function Parameters, so that they can only be modiﬁed when the function explicitly needs to modify them.
First, let's look at this cv-qualiﬁers: // Assume class Field, with member function "void insert_value(int);".
Section 99_0_3: Const Correct Function Parameters In a const-correct function, all passed-by-reference parameters are marked as const unless the function directly or indirectly modiﬁes them, preventing the programmer from inadvertently changing something they didn't mean to change.
This allows the function to take both const and non-cv-qualiﬁed instances, and in turn, causes the instance's this to be of type const * when a member function is called, where  is the class' type.
Section 99_0_4: Const Correctness as Documentation One of the more useful things about const correctness is that it serves as a way of documenting code, providing certain guarantees to the programmer and other users.
These guarantees are enforced by the compiler due to constness, with a lack of constness in turn indicating that code doesn't provide them.
Therefore, they shall not modify any member variables of the instance they are called on, except mutable variables.
Shall not call any other functions that would modify any member variables of the instance, except mutable variables.
Complete Cplus_plus Tips & Secrets for Professionals 484 Conversely, any member function which isn't const can be assumed to have intent to modify the instance, and: May or may not modify logical state.
May or may not call other functions which modify logical state.
This can be used to make assumptions about the state of the object after any given member function is called, even without seeing the deﬁnition of that function:.
It may or may not call calc() or bad_func().
It may or may not call calc() or squared_calc().
Any function with one or more parameters which are const can be assumed to have intent to read those parameters, and: Shall not modify those parameters, or call any member functions that would modify them.
Shall not pass those parameters to any other function which would modify them and/or call any member functions that would modify them.
Conversely, any function with one or more parameters which aren't const can be assumed to have intent to modify those parameters, and: May or may not modify those parameters, or call any member functions which whould modify them.
May or may not pass those parameters to other functions which would modify them and/or call any member functions that would modify them.
This can be used to make assumptions about the state of the parameters after being passed to any given function, even without seeing the deﬁnition of that function.
However, due to this requiring the programmer to very speciﬁcally tell the compiler that they intend to ignore constness, and being inconsistent across compilers, it  generally safe to assume that const correct code will refrain from doing so unless otherwise speciﬁed.
If one thread writes to an atomic object while another thread reads from it, the behavior  well-deﬁned (see memory model for details In addition, accesses to atomic objects may establish inter-thread synchronization and order non-atomic memory accesses as speciﬁed by std::memory_order.
The standard library provides specializations of the std::atomic template for the following types: 1.
One full specialization for the type bool and its typedef name  deﬁned that  treated as a non-specialized std::atomic<> except that it has standard layout, trivial default constructor, trivial destructors, and supports aggregate initialization syntax: Typedef name Full specialization std::atomic_bool std::atomic<bool> 2)Full specializations and typedefs for integral types, as follows: Typedef name Full specialization std::atomic_char std::atomic<char> std::atomic_char std::atomic<char> std::atomic_schar std::atomic<signed char> std::atomic_uchar std::atomic<unsigned char> std::atomic_short std::atomic<short> std::atomic_ushort std::atomic<unsigned short> std::atomic_int std::atomic<int> std::atomic_uint std::atomic<unsigned int> std::atomic_long std::atomic<long> std::atomic_ulong std::atomic<unsigned long> std::atomic_llong std::atomic<long long> std::atomic_ullong std::atomic<unsigned long long> std::atomic_char16_t std::atomic<char16_t> std::atomic_char32_t std::atomic<char32_t> std::atomic_wchar_t std::atomic<wchar_t> std::atomic_int8_t std::atomic<std::int8_t> std::atomic_uint8_t std::atomic<std::uint8_t> std::atomic_int16_t std::atomic<std::int16_t> std::atomic_uint16_t std::atomic<std::uint16_t> std::atomic_int32_t std::atomic<std::int32_t> std::atomic_uint32_t std::atomic<std::uint32_t> std::atomic_int64_t std::atomic<std::int64_t> std::atomic_uint64_t std::atomic<std::uint64_t> std::atomic_int_least8_t std::atomic<std::int_least8_t> std::atomic_uint_least8_t std::atomic<std::uint_least8_t> std::atomic_int_least16_t std::atomic<std::int_least16_t> std::atomic_uint_least16_t std::atomic<std::uint_least16_t> std::atomic_int_least32_t std::atomic<std::int_least32_t> std::atomic_uint_least32_t std::atomic<std::uint_least32_t> std::atomic_int_least64_t std::atomic<std::int_least64_t> std::atomic_uint_least64_t std::atomic<std::uint_least64_t> std::atomic_int_fast8_t std::atomic<std::int_fast8_t> Complete Cplus_plus Tips & Secrets for Professionals 488 std::atomic_uint_fast8_t std::atomic_int_fast16_t std::atomic_uint_fast16_t std::atomic_int_fast32_t std::atomic_uint_fast32_t std::atomic_int_fast64_t std::atomic_uint_fast64_t std::atomic_intptr_t std::atomic_uintptr_t std::atomic_size_t std::atomic_ptrdiff_t std::atomic_intmax_t std::atomic_uintmax_t std::atomic<std::uint_fast8_t> std::atomic<std::int_fast16_t> std::atomic<std::uint_fast16_t> std::atomic<std::int_fast32_t> std::atomic<std::uint_fast32_t> std::atomic<std::int_fast64_t> std::atomic<std::uint_fast64_t> std::atomic<std::intptr_t> std::atomic<std::uintptr_t> std::atomic<std::size_t> std::atomic<std::ptrdiff_t> std::atomic<std::intmax_t> std::atomic<std::uintmax_t>.
Chapter 101: Data Structures in Cplus_plus Section 101_0_1: Linked List implementation in Cplus_plus Creating a List Node class listNode {.
Complete Cplus_plus Tips & Secrets for Professionals.
Chapter 102: Refactoring Techniques Refactoring refers to the modiﬁcation of existing code into an improved version.
Although refactoring is often done while changing code to add features or ﬁx bugs, the term particularly refers improving code without necessarily adding features or ﬁxing bugs.
Section 102_0_1: Goto Cleanup In Cplus_plus code bases which used to be C, one can ﬁnd the pattern goto cleanup.
As the goto command makes the workﬂow of a function harder to understand, this is often avoided.
Often, it can be replaced by return statements, Complete Cplus_plus Tips & Secrets for Professionals 491.
Chapter 103: Cplus_plus Streams Section 103_0_1: String streams std::ostringstream is a class whose objects look like an output stream (that is, you can write to them via operator<<), but actually store the writing results, and provide them in the form of a stream.
This  mainly useful when we have a class for which stream serialization has been deﬁned, and for which we want a string form.
For example, suppose we have some class class.
Section 103_0_2: Printing collections with iostream Basic printing std:: allows to print contents of an STL container to any output stream without explicit loops.
Implicit type cast std:: allows to cast container' content type implicitly.
For example, let' tune std:: to print.
Generation and transformation std::generate, std::generate_n and std::transform functions provide a very powerful tool for on-the-ﬂy data manipulation.
As in the section about reading text ﬁles, almost all these considerations may be applied to native arrays.
For example, let' print squared values from a native array: int [] = {1,2,3,4,8,16};.
Types> struct Tuple {}; A parameter pack  a  parameter accepting zero or more  arguments.
If a  has at least one parameter pack  a variadic.
Section 104_0_2: Expansion of a parameter pack The pattern parameter_pack _0__0_.
The code above invoked with variadic_printer(1, 2, 3, "hello"); prints 1 2 3 hello Chapter 105: Literals Traditionally, a literal  an expression denoting a constant whose type and value are evident from its spelling.
For example, 42  a literal, while   not since one must see its declaration to know its type and read previous lines of code to know its value.
However, Cplus_plus11 also added user-deﬁned literals, which are not literals in the traditional sense but can be used as a shorthand for function calls.
Section 105_0_1: this Within a member function of a class, the keyword this  a pointer to the instance of the class on which the.
The type of this depends on the cv-qualiﬁcation of the member function: if X::f  const, then the type of this within f  const X*, so this cannot be used to modify non-static data members from within a const member function.
Likewise, this inherits volatile qualiﬁcation from the function it appears in.
Notes Letters in the integer literals are case-insensitive: 0xDeAdBaBeU and 0XdeadBABEu represent the same number There are no negative integer literals.
Expressions such as -1 apply the unary minus  to the value represented by the literal, which may involve implicit type conversions.
In C prior to C99 (but not in Cplus_plus), unsuﬃxed decimal values that do not ﬁt in long int are allowed to have the type unsigned long int.
When used in a controlling expression of #if or #elif, all signed integer constants act as if they have type Complete Cplus_plus Tips & Secrets for Professionals.
Version≥Cplus_plus11 A keyword denoting a null pointer constant.
It can be converted to any pointer or pointer-to-member type, yielding a null pointer of the resulting type.
Chapter 106: Flow Control Section 106_0_1: case Introduces a case label of a switch statement.
The operand must be a constant expression and match the switch condition in type.
When the switch statement is executed, it will jump to the case label with operand equal to the condition, if any.
Section 106_0_2: switch According to the Cplus_plus standard, The switch statement causes control to be transferred to one of several statements depending on the value of a condition.
The keyword switch is followed by a parenthesized condition and a block, which may contain case labels and an optional default label.
When the switch statement is executed, control will be transferred either to a case label with a value matching that of the condition, if any, or to the default label, if any.
The condition must be an expression or a declaration, which has either integer or enumeration type, or a class type with a conversion function to integer or enumeration type.
Section 106_0_3: catch The catch keyword introduces an exception handler, that is, a block into which control will be transferred when an exception of compatible type is thrown.
The catch keyword is followed by a parenthesized exception declaration, which is similar in form to a function parameter declaration: the parameter name may be omitted, and the ellipsis _0__0_.
The exception handler will only handle the exception if its declaration is.
When throw occurs in an expression with an operand, its eﬀect is to throw an , which is a copy of.
The try block is followed by one or more catch blocks.
If an  propagates out of the try block, each of the corresponding catch blocks after the try block has the opportunity to handle the , if the types match.
Section 106_0_9: Conditional Structures: if, if_0__0_else if and else: it used to check whether the given expression returns true or false and acts as such: Complete Cplus_plus Tips & Secrets for Professionals 500 if (condition) statement the condition can be any valid Cplus_plus expression that returns something that be checked against truth/falsehood for example: if (true) { /* code here */ } // evaluate that true is true and execute the code in the brackets if (false) { /* code here */ } // always skip the code since false is always false the condition can be anything,  function,  variable, or  comparison for example if(istrue()) { } // evaluate the function, if it returns true, the if will execute the code if(isTrue(var)) { } //evalute the return of the function after passing the argument var if( == b) { } // this will evaluate the return of the experssion (==b) which will be true if equal and false if unequal if() { } //if  is  boolean type, it will evaluate for its value, if it's an integer, any non zero value will be true, if we want to check for  multiple expressions we can do it in two ways : using binary operators : if ( && b) { } // will be true only if both  and b are true (binary operators are outside the scope here if ( || b ) { } //true if  or b is true using if/ifelse/else: for  simple switch either if or else.
Section 106_0_11: Jump statements : break, continue, goto, exit.
The break instruction: Using break we can leave  loop even if the condition for its end is not fulﬁlled.
It can be used to end an inﬁnite loop, or to force it to end before its natural end The syntax is break;.
The continue instruction: The continue instruction causes the program to skip the rest of the loop in the present iteration as if the end of the Complete Cplus_plus Tips & Secrets for Professionals 502.
The goto instruction: It allows making an absolute jump to another point in the program.
You should use this feature carefully since its execution ignores any type of nesting limitation.
The destination point is identiﬁed by  label, which is then used as The syntax is goto label; _0_.
Complete Cplus_plus Tips & Secrets for Professionals.
The exit function: exit is  function deﬁned in cstdlib.
The purpose of exit is to terminate the running program with an speciﬁc exit code.
Its prototype is: void exit (int exit code);.
If return has an operand, the operand is converted to the function's return type, and the converted value is returned to the caller.
Introduces the deﬁnition of a class type.
In the declaration of a template template parameter, the keyword class precedes the name of the parameter.
Since the argument for a template template parameter can only be a class template, the use of class here is redundant.
However, the grammar of Cplus_plus requires it.
In the declaration or deﬁnition of an enum, declares the enum to be a scoped enum.
Introduces the deﬁnition of an enumeration type.
Version≥Cplus_plus11 In Cplus_plus11, enum may optionally be followed by class or struct to deﬁne a scoped enum.
Furthermore, both scoped and unscoped enums can have their underlying type explicitly speciﬁed by : T following the enum name, where T refers to an integer type.
Introduces an opaque enum declaration, which declares an enum without deﬁning it.
It can either redeclare a previously declared enum, or forward-declare an enum that has not been previously declared.
An enum ﬁrst declared as scoped cannot later be declared as unscoped, or vice versa.
All declarations of an enum must agree in underlying type.
When forward-declaring an unscoped enum, the underlying type must be explicitly speciﬁed, since it cannot be inferred until the values of the enumerators are known.
Introduces the deﬁnition of a union type.
It is implementation-deﬁned whether char is signed (and has a range of at least -127 to +127, inclusive) or unsigned (and has a range of at least 0 to 255, inclusive).
Version≥Cplus_plus11 An unsigned integer type with the same size and alignment as uint_least16, which is therefore large enough to hold a UTF-16 code unit.
Version≥Cplus_plus11 An unsigned integer type with the same size and alignment as uint_least32, which is therefore large enough to.
Section 108_0_5: void An incomplete type; it is not possible for an object to have type void, nor are there arrays of void or references to void.
It is used as the return type of functions that do not return anything.
Moreover, a function may redundantly be declared with a single parameter of type void; this is equivalent to declaring a function with no parameters (e_0_g.
This syntax is allowed for compatibility with C (where function declarations have a diﬀerent meaning than in Cplus_plus).
The type void* ("pointer to void") has the property that any object pointer can be converted to it and back and result in the same pointer.
This feature makes the type void* suitable for certain kinds of (type-unsafe) type-erasing interfaces, for example for generic contexts in C-style APIs (e_0_g.
Any expression may be converted to an expression of type void; this is called a discarded-value expression:.
Section 108_0_6: wchar_t An integer type large enough to represent all characters of the largest supported extended character set, also known as the wide-character set.
This type can also be written as long int.
In all other cases, decltype(e) yields both the type and the value category of the expression e, as follows: If e is an lvalue of type T, then decltype(e) is T&.
If e is an xvalue of type T, then decltype(e) is T&&.
If e is  prvalue of type T, then decltype(e) is T.
This includes the case with extraneous parentheses.
Section 109_0_2: const A type speciﬁer; when applied to  type, produces the const-qualiﬁed version of the type.
See const keyword for.
Section 109_0_3: volatile A type qualiﬁer; when applied to  type, produces the volatile-qualiﬁed version of the type.
Volatile qualiﬁcation plays the same role as const qualiﬁcation in the type system, but volatile does not prevent objects from being modiﬁed; instead, it forces the compiler to treat all accesses to such objects as side eﬀects.
In the example below, if  were not volatile, the compiler could optimize the function so that it performs only the ﬁnal write, which would be incorrect if sizeof(int) is greater than 1.
The volatile qualiﬁcation forces it to treat all sizeof(int) writes as diﬀerent side eﬀects and hence perform all of them (in order).
Section 109_0_4: signed A keyword that is part of certain integer type names.
When used alone, int is implied, so that signed, signed int, and int are the same type.
When combined with char, yields the type signed char, which is  diﬀerent type from char, even if char is also signed.
When combined with short, long, or long long, it is redundant, since those types are already signed.
Section 109_0_5: unsigned A type speciﬁer that requests the unsigned version of an integer type.
When used alone, int is implied, so unsigned is the same type as unsigned int.
The type unsigned char is diﬀerent from the type char, even if char is unsigned.
It can hold integers up to at least 255.
It cannot be combined with bool, wchar_t, char16_t, or char32_t.
Chapter 111: type deduction Section 111_0_1: Template parameter deduction for constructors Prior to Cplus_plus17, template deduction cannot deduce the class type for you in  constructor.
It must be explicitly speciﬁed.
Sometimes, however, these types can be very cumbersome or (in the case of lambdas) impossible to name, so we got  proliferation of type factories (like make_pair(), make_tuple(), back_inserter(), etc_0_).
Version≥Cplus_plus11 Type deduction using the auto keyword works almost the same as Template Type Deduction.
The diﬀerences are outlined below: auto auto auto auto.
See remarks for more information.
If it can't deduce the of T, the code is rejected.
Cplus_plus14 allows, in addition to the usages of auto allowed in Cplus_plus11, the following: 1.
When used as the return type of  function without  trailing return type, speciﬁes that the function's return type should be deduced from the return statements in the function's body, if any.
In Cplus_plus03 and earlier, the auto keyword had a completely diﬀerent meaning as a storage class speciﬁer that was inherited from C.
Section 111_0_3: Template Type Deduction Template Generic Syntax.
In this case type deduction works this way.
The compiler ignores the reference part if it exists in expr.
The compiler then pattern-matches expr's type against ParamType to determing T.
In this case type deduction is the same as in case 1 if the expr is an rvalue.
If expr is an lvalue, both T and ParamType are deduced to be lvalue references.
If expr is a reference the reference part is ignored.
If expr is const that is ignored as well.
If it is volatile that is also ignored when deducing T's type.
Output hello world Wrong type 42 Chapter 113: Cplus_plus11 Memory Model.
An optimizing Cplus_plus compiler may decide to reorder the program in similar way.
Such reordering cannot change the behavior of a program running in single thread because a thread cannot interleave the calls to init() and use().
On the other hand in a multi-threaded setting one thread may see part of the writes performed by the other thread where it may happen that use() may see ==true and garbage in or  or both.
The Cplus_plus Memory Model allows the programmer to specify which reordering operations are permitted and which are not, so that a multi-threaded program would also be able to behave as expected.
The example above can be rewritten in thread-safe way like this:.
Here init() performs  store-release operation.
This not only stores the value true into , but also tells the compiler that it cannot move this operation before write operations that are sequenced before it.
The use() function does an  load-acquire operation.
It reads the current value of  and also forbids the compiler from placing read operations that are sequenced after it to happen before the  load-acquire.
These  operations also cause the compiler to put whatever hardware instructions are needed to inform the CPU to refrain from the unwanted reorderings.
Because the  store-release is to the same memory location as the  load-acquire, the memory model stipulates that if the load-acquire operation sees the value written by the store-release operation, then all writes performed by init()'s thread prior to that store-release will be visible to loads that use()'s thread executes after its load-acquire.
That is if use() sees ==true, then it is guaranteed to see ==2 and ==3.
Note that the compiler and the CPU are still allowed to write to  before writing to , and similarly the reads from these variables in use() can happen in any order.
If the  load operation sees the value written by the  store then the store happens before the load, and so do the fences: the release fence happens before the acquire fence making the writes to  and  that precede the release fence to become visible to the std:: statement that follows the acquire fence.
A fence might be beneﬁcial if it can reduce the overall number of acquire, release or other synchronization operations.
Chapter 114: Build Systems Cplus_plus, like C, has a long and varied history regarding compilation workﬂows and build processes.
Today, Cplus_plus has various popular build systems that are used to compile programs, sometimes for multiple platforms within one build system.
Here, a few build systems will be reviewed and analyzed.
Section 114_0_1: Generating Build Environment with CMake CMake generates build environments for nearly any compiler or IDE from a single project deﬁnition.
The following examples will demonstrate how to add a CMake ﬁle to the cross-platform "Hello World" Cplus_plus code.
CMake ﬁles are always named "CMakeLists_0_txt" and should already exist in every project's root directory (and possibly in sub-directories too_0_) A basic CMakeLists_0_txt ﬁle looks like:.
See it live on Coliru.
This ﬁle tells CMake the project name, what ﬁle version to expect, and instructions to generate an executable called "HelloWorld" that requires main_0_cpp.
Generate a build environment for your installed compiler/IDE from the command line: > cmake.
Build the application with: > cmake minus_minusbuild.
This generates the default build environment for the system, depending on the OS and installed tools.
Keep source code clean from any build artifacts with use of "out-of-source" builds: > > > > mkdir build cd build cmake _0_.
CMake can also abstract the platform shell's basic commands from the previous example: > cmake -E make_directory build > cmake -E chdir build cmake _0_.
To generate makeﬁles for Visual Studio's nmake: > cmake -G "NMake Makefiles" _0_.
GNU Make is one speciﬁc program that falls under the Make family.
Make remains popular among Unix-like and POSIX-like operating systems, including those derived from the Linux kernel, Mac OS X, and BSD.
GNU Make is especially notable for being attached to the GNU Project, which is attached to the popular GNU/Linux operating system.
GNU Make also has compatible versions running on various ﬂavors of Windows and Mac OS X.
It is also a very stable version with historical signiﬁcance that remains popular.
It is for these reasons that GNU Make is often taught alongside C and Cplus_plus.
Basic rules To compile with make, create a Makeﬁle in your project directory.
Your Makeﬁle could be as simple as: Makeﬁle # Set some variables to use in our command # First, we set the compiler to be gplus_plus =gplus_plus # Then, we say that we want to compile with gplus_plus's recommended warnings and some extra ones.
Compile main_0_cpp with warnings, and output to the file _0_/app # This target should reverse the `all` target.
If you call # make with an argument, like `make clean`, the corresponding target # gets called.
Otherwise, you'll get an error of Makefile:10: *** missing separator.
To run this from the command-line, do the following: $ cd ~/Path/to/project $ make $ ls app main_0_cpp Makefile Complete Cplus_plus Tips & Secrets for Professionals 520 $ _0_/app Hello World.
Recompiling b_0_cpp would take more time.
With the following directory structure:.
This new  ensures that you only recompile changed ﬁles, minimizing compile time.
Documentation For more on make, see the oﬃcial documentation by the Free Software Foundation, the stackoverﬂow documentation and dmckee's elaborate answer on stackoverﬂow.
Complete Cplus_plus Tips & Secrets for Professionals 521 Section 114_0_3: Building with SCons You can build the cross-platform "Hello World" Cplus_plus code, using Scons - A Python-language software construction tool.
First, create a  called SConstruct (note that SCons will look for a  with this exact name by default).
For now, the  should be in a directory right along your hello_0_.
Write in the new  the line Now, from the terminal, run scons.
You should see something like $ scons scons: Reading SConscript files _0__0_.
The  and Glob classes will help you further conﬁgure what to build.
E_0_g_0_, the SConstruct =(='/usr/include/boost/', =[], =[], builds the executable hello, using all  ﬁles in src.
Its  is /usr/include/boost and it speciﬁes the Cplus_plus11 standard.
Introduction The Autotools are a group of programs that create a GNU Build System for a given software package.
It is a suite of tools that work together to produce various build resources, such as a  (to be used with GNU Make).
Thus, Autotools can be considered a de facto build system generator.
Some notable Autotools programs include: Autoconf In general, Autotools is meant to generate the Unix-compatible script and  to allow the following command to build (as well as install) most packages (in the simple case): _0_/configure && make && make install As such, Autotools also has a relationship with certain package managers, especially those that are attached to operating systems that conform to the POSIX Standard(s).
Section 114_0_5: Ninja Introduction Complete Cplus_plus Tips & Secrets for Professionals 522 The Ninja build system is described by its project website as "a small build system with a focus on speed_0_" Ninja is designed to have its ﬁles generated by build system  generators, and takes a low-level approach to build systems, in contrast to higher-level build system managers like CMake or Meson.
Ninja is primarily written in Cplus_plus and Python, and was created as an alternative to the SCons build system for the Chromium project.
Introduction NMAKE is a command-line utility developed by Microsoft to be used primarily in conjunction with Microsoft Visual Studio and/or the Visual Cplus_plus command line tools.
NMAKE is build system that falls under the Make family of build systems, but has certain distinct features that diverge from Unix-like Make programs, such as supporting Windows-speciﬁc  path syntax (which itself diﬀers from Unix-style  paths).
Chapter 115: Concurrency With OpenMP This topic covers the basics of concurrency in Cplus_plus using OpenMP.
OpenMP is documented in more detail in the OpenMP tag.
Parallelism or concurrency implies the execution of code at the same time.
Section 115_0_1: OpenMP: Parallel Sections This example illustrates the basics of executing sections of code in parallel.
As OpenMP is a built-in compiler feature, it works on any supported compilers without including any libraries.
You may wish to include omp_0_h if you want to use any of the openMP API features.
Sample Code std:: << "begin "; //.
Outputs This example produces 2 possible outputs and is dependent on the operating system and hardware.
The output also illustrates a race condition problem that would occur from such an implementation.
OUTPUT A OUTPUT B begin    begin Section 115_0_2: OpenMP: Parallel Sections This example shows how to execute chunks of code in parallel std:: << "begin "; //.
Output begin   forever begin   forever begin  forever begin forever As execution order is not guaranteed, you may observe any of the above output.
Section 115_0_3: OpenMP: Parallel For Loop.
Splits element vector into element_0_size() / Thread Qty //.
Complete Cplus_plus Tips & Secrets for Professionals.
Continue process Only when all threads completed their allocated loop job *Please take extra care to not modify the size of the vector used in parallel for loops as allocated range indices doesn't update automatically.
Section 115_0_4: OpenMP: Parallel Gathering / Reduction This example illustrates a concept to perform reduction or gathering using std:: and OpenMP.
Supposed we have a scenario where we want multiple threads to help us generate a bunch of stuﬀ, int is used here for simplicity and can be replaced with other data types.
This is particularly useful when you need to merge results from slaves to avoid segement faults or memory access violations and do not wish to use libraries or custom sync container libraries.
Hint the compiler to parallelize this { } of code.
Have fun with Master Chapter 116: Type Inference This topic discusses about type inferencing that involves the keyword auto type that is available from Cplus_plus11.
Section 116_0_1: Data Type: Auto.
However, the auto keyword does not always perform the expected type inference without additional hints for & or const or constexpr // = unsigned int, //.
These sequences are used when implementing class or function templates which beneﬁt from positional access.
The standard library also contains "factory" types which create ascending sequences of integer values just from the number of elements.
Section 117_0_1: Turn  std::tuple<T_0__0__0_> into function parameters A std::tuple<T_0__0__0_> can be used to pass multiple values around.
For example, it could be used to store  sequence of parameters into some form of  queue.
When processing such  tuple its elements need to be turned into function call arguments:.
The function itself is entirely independent of the number of arguments.
Section 117_0_2: Create  parameter pack consisting of integers std:: itself is about holding  sequence of integers which can be turned into  parameter pack.
Section 117_0_3: Turn  sequence of indices into copies of an element Expanding the parameter pack of indices in  comma expression with  value creates  copy of the value for each of the indices.
Sadly, gcc and clang think the index has no eﬀect and warn about it (gcc can be silenced by casting the index to void):.
Chapter 118: Resource Management One of the hardest things to do in C and Cplus_plus is resource management.
Thankfully, in Cplus_plus, we have many ways to go about designing resource management in our programs.
This article hopes to explain some of the idioms and methods used to manage allocated resources.
Section 118_0_1: Resource Acquisition Is Initialization Resource Acquisition Is Initialization (RAII) is a common idiom in resource management.
In the case of dynamic memory, it uses smart pointers to accomplish resource management.
When using RAII, an acquired resource is immediately given ownership to a smart pointer or equivalent resource manager.
The resource is only accessed through this manager, so the manager can keep track of various operations.
For example, std::auto_ptr automatically frees its corresponding resource when it falls out of scope or is otherwise deleted.
Because of these weird copy semantics, std::auto_ptr can't be used in containers, among other things.
The reason it does this is to prevent deleting memory twice: if there are two auto_ptrs with ownership of the same resource, they both try to free it when they're destroyed.
Freeing an already freed resource can generally cause problems, so it is important to prevent it.
However, std::shared_ptr has a method to avoid this while not transferring ownership when copying:.
Section 118_0_2: Mutexes & Thread Safety Problems may happen when multiple threads try to access a resource.
For a simple example, suppose we have a thread that adds one to a variable.
It does this by ﬁrst reading the variable, adding one to it, then storing it back.
Suppose we initialize this variable to 1, then create two instances of this thread.
After both threads ﬁnish, intuition suggests that this variable should have a value of 3.
However, the below table illustrates what might go wrong: Thread 1 Thread 2 Time Step 1 Read 1 from variable Time Step 2 Read 1 from variable Time Step 3 Add 1 plus 1 to  2 Time Step 4 Add 1 plus 1 to  2 Time Step 5 Store 2 into variable Time Step 6 Store 2 into variable As you can see, at the end of the operation, 2 is in the variable, instead of 3.
The reason is that Thread 2 read the variable before Thread 1 was done updating it.
A mutex (portmanteau of mutual exclusion) is a resource management object designed to solve this type of problem.
When a thread wants to access a resource, it "acquires" the resource' mutex.
Once it is done accessing the resource, the thread "releases" the mutex.
While the mutex is acquired, all calls to acquire the mutex will not return until the mutex is released.
To better understand this, think of a mutex as a waiting line at the supermarket: the threads go into line by trying to acquire the mutex and then waiting for the threads ahead of them to ﬁnish up, then using the resource, then stepping out of line by releasing the mutex.
There would be complete pandemonium if everybody tried to access the resource at once.
Section 119_0_1: Changing the default sort of a set set and multiset have default compare methods, but in some cases you may need to overload them.
Let' imagine we are storing string values in a set, but we know those strings contain only numeric values.
By default the sort will be a lexicographical string comparison, so the order won't match the numerical sort.
If you want to apply a sort equivalent to what you would have with  values, you need a functor to overload the compare method: # <iostream>.
Output will be: ### Default sort on std::<std::> : 1 2 23 290 5 6 ### Custom sort on  : 1 2 5 6 23 290 ### Lambda sort on  : 6 5 290 23 2 1 In the example above, one can ﬁnd 3 diﬀerent ways of adding compare operations to the std::, each of them is useful in its own context.
Default sort This will use the compare operator of the key (ﬁrst template argument).
Often, the key will already provide a good default for the std::less<T> function.
Unless this function is specialized, it uses the operator< of the object.
This is especially useful when other code also tries to use some ordering, as this allows consistency over the whole code base.
Writing the code this way, will reduce the eﬀort to update your code when the key changes is API, like: a class containing 2 members which changes to a class containing 3 members.
By updating the operator< in the class, all occurrences will get updated.
As you might expect, using the default sort is a reasonable default.
Custom sort Adding a custom sort via an object with a compare operator is often used when the default comparison doesn't comply.
In the example above this is because the strings are referring to integers.
In other cases, it's often used when you want to compare (smart) pointers based upon the object they refer to or because you need diﬀerent constraints for comparing (example: comparing std::pair by the value of first).
When creating a compare operator, this should be a stable sorting.
If the result of the compare operator changes after insert, you will have undeﬁned behavior.
As a good practice, your compare operator should only use the constant  (const members, const functions _0__0__0_).
As in the example above, you will often encounter classes without members as compare operators.
This results in default constructors and copy constructors.
The default constructor allows you to omit the instance at construction time and the copy constructor is required as the  takes a copy of the compare operator.
Complete Cplus_plus Tips & Secrets for Professionals 532 Lambda sort Lambdas are a shorter way to write function objects.
This allows writing the compare operator on less lines, making the overall code more readable.
The disadvantage of the use of lambdas is that each lambda gets a speciﬁc type at compile time, so decltype(lambda) will be diﬀerent for each compilation of the same compilation unit (cpp ﬁle) as over multiple compilation units (when included via header ﬁle).
For this reason, its recommended to use function objects as compare operator when used within header ﬁles.
This construction is often encountered when a std:: is used within the local scope of a function instead, while the function object is preferred when used as function arguments or class members.
Other sort options As the compare operator of std:: is a template argument, all callable objects can be used as compare operator and the examples above are only speciﬁc cases.
The only restrictions these callable objects have are: They must be copy constructable They must be callable with 2 arguments of the type of the key.
Please note that if you ask to delete an element from a multiset, and is present multiple times, all the equivalent values will be deleted.
Section 119_0_3: Inserting values in a Three diﬀerent methods of insertion can used with sets.
First, a simple insert of the value.
This method returns a pair allowing the caller to check whether the insert really occurred.
Second, an insert by giving a hint of where the value will be inserted.
The objective is to optimize the insertion time in such a case, but knowing where a value should be inserted is not the common case.
Be careful in that case; the way to give a hint diﬀers with compiler versions.
Finally you can insert a range of values by giving a starting and an ending pointer.
The starting one will be included in the insertion, the ending one is excluded.
Nevertheless, another possibility exists, which is.
Section 119_0_5: Searching values in  and There are several ways to search a given value in std:: or in std::: To get the iterator of the ﬁrst occurrence of a key, the find() function can be used.
It returns end() if the key does not exist.
They do not aﬀect the type of the declaration, but typically modify the way in which the entity is stored.
Section 120_0_1: extern The extern storage class speciﬁer can modify a declaration in one of the three following ways, depending on context: 1.
It can be used to declare a variable without deﬁning.
Typically, this is used in a header ﬁle for a variable that will be deﬁned in a separate implementation ﬁle.
A function can also be declared extern, but this has no eﬀect.
It is usually used as a hint to the reader that a function declared here is deﬁned in another translation unit.
For example: void f(); // typically a forward declaration; f defined later in this TU extern void g(); // typically not a forward declaration; g defined in another TU In the above code, if f were changed to extern and g to non-extern,  would not aﬀect the correctness or semantics of the program at all, but would likely confuse the reader of the code.
Complete Cplus_plus Tips & Secrets for Professionals 537 Section 120_0_2: register Version<Cplus_plus17 A storage class speciﬁer that hints to the compiler that a variable will be heavily used.
The word "register" is related to the fact that a compiler might choose to store such a variable in a CPU register so that  can be accessed in fewer.
Both local variables and function parameters may be declared register.
Unlike C, Cplus_plus does not place any restrictions on what can be done with a register variable.
For example,  is valid to take the address of a register variable, but this may prevent the compiler from actually storing such a variable in a register.
Version≥Cplus_plus17 The keyword register is unused and reserved.
A program that uses the keyword register is ill-formed.
Section 120_0_3: static The static storage class speciﬁer has three diﬀerent meanings.
Section 120_0_4: auto Version≤Cplus_plus03 Declares a variable to have automatic storage duration.
It is redundant, since automatic storage duration is already the default at block scope, and the auto speciﬁer is not allowed at namespace scope.
Section 120_0_5: mutable A speciﬁer that can be applied to the declaration of a non-static, non-reference data member of a class.
A  meaning for mutable was added in Cplus_plus11.
When  follows the parameter list of a lambda,  suppresses the implicit const on the lambda' function call operator.
Therefore, a mutable lambda can modify the values of.
Chapter 121: Alignment All types in Cplus_plus have an alignment.
This is a restriction on the memory address that objects of that type can be created within.
A memory address is valid for an object' creation if dividing that address by the object' alignment Complete Cplus_plus Tips & Secrets for Professionals 539 is a whole number.
Type alignments are always a power of two (including 1).
Section 121_0_1: Controlling alignment Version≥Cplus_plus11 The alignas keyword can be used to force a variable, class data member, declaration or deﬁnition of a class, or declaration or deﬁnition of an enum, to have a particular alignment, if supported.
It comes in two forms: alignas(), where  is a constant expression, gives the entity the alignment , if supported.
If multiple alignas speciﬁers are applied to the same entity, the strictest one applies.
Valid alignments are always powers of two, and must be greater than zero.
Compilers are required to support all valid alignments up to the alignment of the type std::max_align_t.
They may support larger alignments than this, but support  allocating memory  such objects  limited.
The upper limit on alignments  implementation dependent.
Cplus_plus17 features direct support in operator   allocating memory  over-aligned types.
Section 121_0_2: Querying the alignment of a type Version≥cplus_plus11 The alignment requirement of a type can be queried using the alignof keyword as a unary operator.
Possible output The alignment requirement of  : 4 If applied to an array, it yields the alignment requirement of the element type.
If applied to a reference type, it yields the alignment requirement of the referenced type.
If it multiply deﬁned, the linker will merge all deﬁnitions into a single object in the ﬁnal program.
Section 122_0_1: Deﬁning a static data member in the class deﬁnition A static data member of the class may be fully deﬁned within the class deﬁnition if it  declared inline.
For example, the following class may be deﬁned in a header.
Prior to Cplus_plus17, it would have been necessary to provide a _0_cpp ﬁle to contain the deﬁnition of Foo:: so that it would be deﬁned only once, but in Cplus_plus17 the multiple deﬁnitions of the inline variable Foo:: all refer to the same  object.
Chapter 123: Linkage speciﬁcations extern string-literal { declaration-seq(opt) } extern string-literal declaration A linkage speciﬁcation tells the compiler to compile declarations in a way that allows them to be linked together with declarations written in another language, such as C.
Section 123_0_1: Signal handler  Unix-like operating system Since a signal handler will be  by the kernel using the C calling convention, we must tell the compiler to use.
The deﬁnition of make_foo  separately compiled and distributed with the header in object form.
A Cplus_plus program can # <foo_0_h>, but the compiler will not know that the make_foo function  deﬁned as a C symbol, and will probably try to look  it with a mangled name, and fail to locate it.
Even if it can ﬁnd the deﬁnition of make_foo in the library, not all platforms use the same calling conventions  C and Cplus_plus, and the Cplus_plus compiler will use the Cplus_plus calling convention when calling make_foo, which  likely to cause a segmentation fault if make_foo expecting to be  with the C calling convention.
The way to remedy this problem  to wrap almost all the declarations in the header in an extern "C" block.
Chapter 124: Curiously Recurring Template Pattern A pattern in which a class inherits from a class template with itself as one of its template parameters.
CRTP usually used to provide static polymorphism in Cplus_plus.
CRTP  a powerful, static alternative to virtual functions and traditional inheritance that can be used to give types properties at compile time.
It works by having a base class template which takes, as one of its template parameters, the derived class.
This permits it to legally perform a static_cast of its this pointer to the derived class.
Of course, this also means that a CRTP class must always be used as the base class of some other class.
Version≥Cplus_plus14 Let's say you have a set of containers that all support the functions begin() and end().
The only static cast inside the function begin() in the  class <<>> allows the compiler to drastically optimize the code and no virtual table look up happens at runtime.
Limitations: Because the  class  templated and diﬀerent  two diﬀerent DynArrays it  not possible to store pointers to their  classes in an type-homogenous array as one could generally do with normal inheritance where the  class  not dependent on the derived type:.
Complete Cplus_plus Tips & Secrets for Professionals.
Section 125_0_1: Importing names individually from  namespace Once using is used to introduce the name  from the namespace std into the scope of the main function, the.
Section 125_0_2: Redeclaring members from   class to avoid name hiding If  using-declaration occurs at class scope, it is only allowed to redeclare  member of   class.
For example, using std:: is not allowed at class scope.
Often, the name redeclared is one that would otherwise be hidden.
For example, in the below code, d1_0_foo only refers to Derived1::foo( char*) and  compilation error will occur.
The function ::foo(int) is hidden.
Version≥Cplus_plus11 As  special case,  using-declaration at class scope can refer to the constructors of  direct  class.
Derived1 performs the forwarding explicitly, while Derived2, using the Cplus_plus11 feature of inheriting constructors, does so implicitly.
Section 126_0_1: Basic typedef syntax typedef declaration has the same syntax as  variable or function declaration, but it contains the word typedef.
The presence of typedef causes the declaration to declare   instead of  variable or function.
The rule that typedef declarations have the same syntax as ordinary variable and function declarations can be used to read and write more complex declarations.
Section 126_0_3: Declaring multiple types with typedef The typedef keyword is  speciﬁer, so it applies separately to each declarator.
Therefore, each  declared refers to the  that that  would have in the absence of typedef.
The syntax of using is very simple: the  to be deﬁned goes on the left hand side, and the deﬁnition goes on the right hand side.
No need to scan to see where the  is.
It is simply an alternative syntax for accomplishing the same thing.
Unlike typedef, using can be templated.
Complete Cplus_plus Tips & Secrets for Professionals 547 Chapter 127: Layout of object types Section 127_0_1: Class types By "class", we mean   that was deﬁned using the class or struct keyword (but not enum struct or enum class).
Even an empty class still occupies at least one byte of storage; it will therefore consist purely of padding.
This ensures that if p points to an object of an empty class, then p + 1 is  distinct address and points to  distinct object.
However, it is possible for an empty class to have  size of 0 when used as  base class.
See empty base optimisation.
If a class type has members and/or base classes with types t1, t2,_0__0__0_tN, the size must be at least sizeof(t1) + sizeof(t2) + _0__0_.
However, depending on the alignment requirements of the members and base classes, the compiler may be forced to insert padding.
If padding is inserted in an object due to alignment requirements, the size will be greater than the sum of the sizes of the members and base classes.
With n-byte alignment, size will typically be the smallest multiple of n which is larger than the size of all members & base classes.
Each member memN will typically be placed at an address which is a multiple of alignof(memN), and n will typically be the largest alignof out of all members' alignofs.
Due to this, if a member with a smaller alignof is followed by a member with a larger alignof, there is a possibility that the latter member will not be aligned properly if placed immediately after the Complete Cplus_plus Tips & Secrets for Professionals 548 former.
In this case, padding (also known as an alignment member ) will be placed between the two members, such that the latter member can have its desired alignment.
Conversely, if a member with a larger alignof is followed by a member with a smaller alignof, no padding will usually be necessary.
This process is also known as "packing".
Due to classes typically sharing the alignof of their member with the largest alignof, classes will typically be aligned to the alignof of the largest built-in type they directly or indirectly contain.
If strict alignment is forced with alignas, padding will be used to force the type to meet the speciﬁed alignment, even when it would otherwise be smaller.
For example, with the deﬁnition below, <5> will have three (or possibly more) padding bytes inserted at the end so that its total size is 8.
It is not possible for a class with an alignment of 4 to have a size of 5 because it would be impossible to make an array of that class, so the size must be "rounded up" to a multiple of 4 by inserting padding bytes.
Padding shall be inserted as // needed.
If two non-static members of a class have the same access speciﬁer, then the one that comes later in declaration order is guaranteed to come later in the object representation.
But if two non-static members have diﬀerent access speciﬁers, their relative order within the object is unspeciﬁed.
It is unspeciﬁed what order the base class subobjects appear in within an object, whether they occur consecutively, and whether they appear before, after, or between member subobjects.
Section 127_0_2: Arithmetic types Narrow character types The unsigned char type uses all bits to represent a binary number.
Therefore, for example, if unsigned char is 8 bits , then the 256 possible bit patterns of a char object represent the 256 diﬀerent values {0, 1, _0__0__0_, 255}.
The number 42 is guaranteed to be represented by the bit pattern 00101010.
The signed char type has no padding bits, i_0_e_0_, if signed char is 8 bits , then it has 8 bits of capacity to represent a number.
Note that these guarantees do not apply to types other than narrow character types.
Integer types The unsigned integer types use a pure binary system, but may contain padding bits.
For example, it is possible (though unlikely) for unsigned  to be 64 bits  but only be capable of storing integers between 0 and 232 - 1, inclusive.
The other 32 bits would be padding bits, which should not be written to directly.
The signed integer types use a binary system with a sign bit and possibly padding bits.
Values that belong to the common range of a signed integer type and the corresponding unsigned integer type have the same representation.
For example, if the bit pattern 0001010010101011 of an unsigned  object represents the value 5291, then it also represents the value 5291 when interpreted as a  object.
It is implementation-deﬁned whether a two's complement, one's complement, or sign-magnitude representation is used, since all three systems satisfy the requirement in the previous paragraph.
Floating point types Complete Cplus_plus Tips & Secrets for Professionals 550 The value representation of ﬂoating point types is implementation-deﬁned.
Most commonly, the  and double types conform to IEEE 754 and are 32 and 64 bits  (so, for example,  would have 23 bits of precision which would follow 8 exponent bits and 1 sign bit).
However, the standard does not guarantee anything.
Floating point types often have "trap representations", which cause errors when they are used in calculations.
Section 127_0_3: Arrays An array type has no padding in between its elements.
Therefore, an array with element type T is just a sequence of T objects laid out in memory, in order.
A multidimensional array is an array of arrays, and the above applies recursively.
For example, if we have the declaration a[5][3]; then a is an array of 5 arrays of 3 ints.
Therefore, a[0], which consists of the three elements a[0][0], a[0][1],.
Chapter 128: C incompatibilities This describes what C code will break in a Cplus_plus compiler.
Section 128_0_1: Reserved Keywords The ﬁrst example are keywords that have a special purpose in Cplus_plus: the following is legal in C, but not Cplus_plus.
Section 128_0_2: Weakly typed pointers In C, pointers can be cast to a void*, which needs an explicit cast in Cplus_plus.
The following is illegal in Cplus_plus, but legal in.
Chapter 129: std::forward_list std::forward_list is a container that supports fast insertion and removal of elements from anywhere in the container.
Fast random access is not supported.
It is implemented as a singly-linked list and essentially does not have any overhead compared to its implementation in C.
Compared to std::list this container provides more space eﬃcient storage when bidirectional iteration is not needed.
Complete Cplus_plus Tips & Secrets for Professionals 551.
Output: 1: 2: 3: 4: [the, frogurt, is, also, cursed] [the, frogurt, is, also, cursed] [the, frogurt, is, also, cursed] [Mo, Mo, Mo, Mo, Mo] Section 129_0_2: Methods Method name Deﬁnition assigns values to the container assign assigns values to the container get_allocator returns the associated allocator minus_minusminus_minusminus_minusminus_minusminus_minusElement access front access the ﬁrst element minus_minusminus_minusminus_minusminus_minusminus_minusIterators before_begin returns an iterator to the element before beginning cbefore_begin returns a constant iterator to the element before beginning begin returns an iterator to the beginning cbegin returns a const iterator to the beginning end returns an iterator to the end cend returns a iterator to the end = Complete Cplus_plus Tips & Secrets for Professionals 552 Capacity empty max_size checks whether the container is empty returns the maximum possible number of elements Modiﬁers clears the contents insert_after inserts elements after an element emplace_after constructs elements in-place after an element erase_after erases an element after an element push_front inserts an element to the beginning emplace_front constructs an element in-place at the beginning pop_front removes the ﬁrst element resize changes the number of elements stored swap swaps the contents Operations merge merges two sorted lists splice_after moves elements from another remove removes elements satisfying speciﬁc criteria remove_if removes elements satisfying speciﬁc criteria reverse reverses the order of the elements unique removes consecutive duplicate elements sort sorts the elements clear Chapter 130: Optimization When compiling, the compiler will often modify the program to increase performance.
This is permitted by the as-if rule, which allows any and all transformations that do not change observable behavior.
Section 130_0_1: Inline Expansion/Inlining Inline expansion (also known as inlining) is compiler optimisation that replaces a call to a function with the body of that function.
This saves the function call overhead, but at the cost of space, since the function may be duplicated several times.
Complete Cplus_plus Tips & Secrets for Professionals 553 Section 130_0_2: Empty base optimization The size of any object or member subobject is required to be at least 1 even if the type is an empty class type (that is, a class or struct that has no non-static data members), in order to be able to guarantee that the addresses of distinct objects of the same type are always distinct.
However, base class subobjects are not so constrained, and can be completely optimized out from the object layout:.
This is achieved by storing one of the required data members (e_0_g_0_, begin, end, or capacity pointer for the vector).
Reference: cppreference Chapter 131: Semaphore Semaphores are not available in Cplus_plus as of now, but can easily be implemented with a mutex and a condition variable.
This example was taken from: Cplus_plus0x has no semaphores.
How to synchronize threads.
Section 131_0_2: Semaphore class in action The following function adds four threads.
Three threads compete for the semaphore, which is set to a  of one.
A slower  calls notify_one(), allowing one of the waiting threads to proceed.
The result is that s1 immediately starts spinning, causing the Semaphore's usage  to remain below 1.
The other threads  in turn on the condition variable until () is called.
In this topic, you can ﬁnd the diﬀerent structures which are provided by the standard library to solve these issues.
Section 132_0_1: std::condition_variable_any, std::cv_status A generalization of std::condition_variable, std::condition_variable_any works with any type of BasicLockable structure.
It throws std::system_error in case  cannot complete its task.
Section 132_0_4: Object locking for ecient access.
Often you want to lock the entire object while you perform multiple operations on.
For example, if you need to examine or modify the object using iterators.
Whenever you need to call multiple member functions  is generally more eﬃcient to lock the whole object rather than individual member functions.
For example: class text_buffer.
Chapter 133: Cplus_plus Debugging and Debug-prevention Tools & Techniques A lot of  from Cplus_plus developers is spent debugging.
This topic is meant to assist with this task and give inspiration for techniques.
Don't expect an extensive list of issues and solutions ﬁxed by the tools or a manual on the mentioned tools.
Section 133_0_1: Static analysis Static analysis is the technique in which on checks the code for patterns linked to known bugs.
Using this technique is less  consuming than a code review, though, its checks are only limited to those programmed in the tool.
Checks can  the incorrect semi-colon behind the if-statement (if (var);) till advanced graph algorithms which determine if a variable is not initialized.
Compiler warnings Enabling static analysis is easy, the most simplistic version is already build-in in your compiler: clangplus_plus -Wall -Weverything -Werror _0__0_.
If you enable these options, you will notice that each compiler will ﬁnd bugs the others don't and that you will get errors on techniques which might be valid or valid in a speciﬁc context.
So unlike code review, you are ﬁghting a tool which understands your code, tells you a lot of useful bugs and sometimes disagrees with you.
In this last case, you might have to suppress the warning locally.
As the options above enable all warnings, they might enable warnings you don't want.
Complete Cplus_plus Tips & Secrets for Professionals.
Where compiler warnings assist you during development, they slow down compilation quite a bit.
That is why you might not always want to enable them by default.
Either you  them by default or you enable some continuous integration with the more expensive checks (or all of them).
External tools If you decide to have some continuous integration, the use of other tools ain't such a stretch.
A tool like clang-tidy has an list of checks which covers a wide range of issues, some examples: Actual bugs Prevention of slicing Asserts with side eﬀects Readability checks Misleading indentation Check identiﬁer naming Modernization checks Use nullptr Performance checks Find unneeded copies Find ineﬃcient algorithm calls The list might not be that large, as Clang already has a lot of compiler warnings, however  will bring you one step closer to a high quality code base.
Other tools Other tools with similar purpose exist, like: the visual studio static analyzer as external tool clazy, a Clang compiler plugin for checking Qt code Conclusion A lot static analysis tools exist for Cplus_plus, both build-in in the compiler as external tools.
Trying them out doesn't take that much  for easy setups and they will ﬁnd bugs you might miss in code review.
Section 133_0_2: Segfault analysis with GDB.
Start it from the beginning.
So the only variable being used at this line is pointer 2.
Lets examine its content typing print.
At this line, we know that we are trying to dereference a NULL pointer.
Section 133_0_3: Clean code Debugging starts with understanding the code you are trying to debug.
Regardless of the coding styles you prefer and use, having a consistent coding (and formatting) style will help you understanding the code.
Looking at the code above, one can identify a couple of improvements to improve readability and debuggability: The use of separate functions for separate actions The use of separate functions allow you to skip over some functions in the debugger if you ain't interested in the details.
In this speciﬁc case, you might not be interested in the creation or printing of the data and only want to step into the sorting.
Another advantage is that you need to read less code (and memorize it) while stepping through the code.
You now only need to read 3 lines of code in main() in order to understand it, instead of the whole function.
The third advantage is that you simply have less code to look at, which helps a trained eye in spotting this bug within seconds.
Using consistent formatting/constructions The use of consistent formatting and constructions will remove clutter from the code making it easier to focus on the code instead of text.
A lot of discussions have been fed on the 'right' formatting style.
Regardless of that style, having a single consistent style in the code will improve familiarity and make it easier to focus on the code.
As formatting code is time consuming task, it is recommended to use a dedicated tool for this.
Most IDEs have at least some kind of support for this and can do formatting more consistent than humans.
You might note that the style is not limited to spaces and newlines as we no longer mix the free-style and the member functions to get begin/end of the container.
Point attention to the important parts of your code.
Regardless of the style you determine to choose, the above code contains a couple of markers which might give you a hint on what might be important: Complete Cplus_plus Tips & Secrets for Professionals 561 A comment stating optimized, this indicates some fancy techniques Some early returns in sortVector() indicate that we are doing something special Conclusion Having clean code will help you understanding the code and will reduce the time you need to debug it.
In the second example, a code reviewer might even spot the bug at ﬁrst glance, while the bug might be hidden in the Chapter 134: Futures and Promises Promises and Futures are used to ferry a single object from one thread to another.
A std::promise object is set by the thread which generates the result.
A std::future object can be used to retrieve a , to test to see if a  is available, or to halt execution until the  is available.
Section 134_0_1: Async operation classes std::async: performs an asynchronous operation.
Section 134_0_2: std:: and std:: The following example sets a  to be consumed by another thread:.
Section 134_0_3: Deferred async example This code implements a version of std::async, but it behaves as if async were always called with the deferred launch policy.
This function also does not have async's special  behavior; the returned  can be destroyed without ever acquiring its.
The thread starts running immediately.
We can either detach it, or have join it at the end of the scope.
When the function call to std::thread ﬁnishes, the result is ready.
Note that this is slightly diﬀerent from std::async where the returned std:: when destructed will actually block until the thread is ﬁnished.
Section 134_0_5: std::future_error and std::future_errc If constraints for std:: and std:: are not met an exception of type std::future_error is thrown.
The error code member in the exception is of type std::future_errc and values are as below, along with some test cases: enum class future_errc { broken_promise future_already_retrieved promise_already_satisfied no_state }; = = = = /* /* /* /* the task is no longer shared */, the answer was already retrieved */, the answer was stored already */, access to a  in non-shared state */.
Note: In the example std::async is launched with policy std::launch_deferred.
This is to avoid a new being created in every call.
In the case of our example, the calls to std::async are made out of order, the they synchronize at the calls for std::::get().
The default policy is std::launch::deferred| std::launch::async, meaning the implementation determines the policy for creating new.
Chapter 135: More undeﬁned behaviors in Cplus_plus More examples on how Cplus_plus can go wrong.
Continuation from Undeﬁned Behavior Section 135_0_1: Referring to non-static members in initializer lists Referring to non-static members in initializer lists before the constructor has started executing can result in undeﬁned behavior.
This results since not all members are constructed at this time.
From the standard draft: 12_0_7_0_1: For an object with a non-trivial constructor, referring to any non-static member or base class of the object before the constructor begins execution results in undeﬁned behavior.
Chapter 136: Mutexes Section 136_0_1: Mutex Types Cplus_plus1x oﬀers a selection of mutex classes: std::mutex - oﬀers simple locking functionality.
Section 136_0_2: std::lock std::lock uses deadlock avoidance algorithms to lock one or more mutexes.
If an exception is thrown during a call.
Complete Cplus_plus Tips & Secrets for Professionals 566 std::unique_lock allows for exclusive ownership of mutexes.
Section 136_0_4: Strategies for lock classes: std::try_to_lock, std::adopt_lock, std::defer_lock When creating a std::, there are three diﬀerent locking strategies to choose from: std::try_to_lock, std::defer_lock and std::adopt_lock.
Section 136_0_5: std::mutex std::mutex is a simple, non-recursive synchronization structure that is used to protect data which is accessed by.
When std::scoped_lock is destroyed, mutexes are released in the reverse order.
Chapter 137: Unit Testing in Cplus_plus Unit testing is a level in software testing that validates the behavior and correctness of units of code.
In Cplus_plus, "units of code" often refer to either classes, functions, or groups of either.
Unit testing is often performed using specialized "testing frameworks" or "testing libraries" that often use non-trivial syntax or usage patterns.
This topic will review diﬀerent strategies and unit testing libraries or frameworks.
Section 137_0_1: Google Test Google Test is a Cplus_plus testing framework maintained by Google.
It requires building the gtest library and linking  to your testing framework when building a test case ﬁle.
Minimal Example // main_0_cpp.
Scenario: vectors can be sized and resized Given: A  with some items When: more  is reserved Then: the  changes but not the Complete Cplus_plus Tips & Secrets for Professionals 570 Chapter 138: Recursive Mutex Section 138_0_1: std::recursive_mutex Recursive mutex allows the same thread to recursively lock a resource - up to an unspeciﬁed limit.
There are very few real-word justiﬁcations for this.
Certain complex implementations might need to call an overloaded copy of a function without releasing the lock.
The keyword decltype can be used to get the type of  variable, function or an expression.
Section 139_0_1: Basic Example This example just illustrates how this keyword can be used.
Then the type of variable b now automatically becomes float.
Let's say we have : std::<int> intVector;.
It works on keys and their maps.
Key as the names goes, helps to have uniqueness in the map.
While the mapped value is just  content that is associated with the key.
The data types of this key and map can be any of the predeﬁned data type or user-deﬁned.
Section 140_0_1: Declaration and Usage As already mentioned you can declare an unordered map of any type.
Let's have  unordered map named ﬁrst with string and integer type.
Section 140_0_2: Some Basic Functions.
Compare 237498123 with 237499123 for equality.
Decide whether 237499123 or 20249472 is larger.
Cplus_plus14 deﬁne Simple Quotation Mark ' as  digit separator, in numbers and user-deﬁned literals.
This can make it easier for human readers to parse large numbers.
Version≥Cplus_plus14 long long long long long long long long decn hexn octn binn = = = =.
Single quotes mark are ignored when determining its value.
Example: The literals 1048576, 1'048'576, 0X100000, 0x10'0000, and 0'004'000'000 all have the same value.
The literals 1_0_602'176'565e-19 and 1_0_602176565e-19 have the same value.
The position of the single quotes is irrelevant.
All the following are equivalent: Version≥Cplus_plus14 long long long long long long long long 1 2 3 4 = = = =.
In detail the parameters can be seen as variables before the function call and inside the function, where the visible behaviour and accessibility to these variables diﬀers with the method used to hand them over.
Additionally, the reusability of variables and their respective values after the function call also is explained by this topic.
Section 142_0_1: Call by value Upon calling  function there are new  created on the program stack.
These include some information Complete Cplus_plus Tips & Secrets for Professionals 573 about the function and also space (memory locations) for the parameters and the return value.
When handing over  parameter to  function the value of the used variable (or literal) is copied into the memory location of the function parameter.
This implies that now there  two memory locations with the same value.
Inside of the function we only work on the parameter memory location.
After leaving the function the memory on the program stack is popped (removed) which erases all data of the function call, including the memory location of the parameters we used inside.
Thus, the values changed inside the function do not aﬀect the outside  values.
In this code we create  inside the main function.
Upon calling the functions there are two new  created:  and inner_b where  shares the name with the outer variable it does not share the memory location.
The behaviour of <arrow_operatorf and <arrow_operatorb is identical.
The following graphic symbolizes what is happening on the stack and why there is no change in varibale.
The graphic is not fully accurate but emphazises the example.
It is called "call by value" because we do not hand over the  but only the values of these.
Section 143_0_1: user input and standard output.
Manipulators are special helper functions that help controlling input and output streams using operator >> or operator <<.
They all can be included by # <iomanip>.
Have no eﬀect on input streams.
The width property n  resetting to 0 when some functions are called (full list  here).
Have no eﬀect on  streams.
Output: : -**********9_0_87 : *************41 $: $3_0_67********** : USD *******3_0_67 : USD 3_0_67.
Output: The number 0_0_01 in fixed: The number 0_0_01 in scientific: The number 0_0_01 in hexfloat: The number 0_0_01 in default: Parsing 0x1P-1022 0_0_070000 7_0_000000e-02 0x1_0_1eb851eb851ecp-4 0_0_07 2_0_22507e-308 Complete Cplus_plus Tips & Secrets for Professionals.
Have no eﬀect on streams.
Complete Cplus_plus Tips & Secrets for Professionals 579.
For more information see the link above.
Section 144_0_2: Output stream manipulators std::ends - inserts a null character '\0' to output stream.
More formally this manipulator's declaration looks like template <class charT, class traits> std::<charT, traits>& ends(std::<charT, traits>& );.
It causes immediately producing.
Section 144_0_3: Input stream manipulators std::ws - consumes leading whitespaces  input stream.
Complete Cplus_plus Tips & Secrets for Professionals 581 # <sstream> _0__0_.
Containers  vectors, lists, maps, etc.
Using Templates, Cplus_plus containers contain collections of primitives (e_0_g.
Section 145_0_1: Cplus_plus Containers Flowchart Choosing which Cplus_plus Container to use can be tricky, so here's a simple ﬂowchart to help decide which Container is right for the job.
This ﬂowchart was based on Mikael Persson's post.
This little graphic  the ﬂowchart is from Megan Hopkins.
These are example of using Cplus_plus template metaprogramming  processing arithmitic operations  compile time.
This example shows an eﬃcient way of calculating  using template metaprogramming.
Version≥Cplus_plus14 This one also handles negative exponents: template <int , int >.
Sarid Chapters 30 and 57 aaronsnoswell Chapter 5 Abhinav Gauniyal Chapter 97 Abyx Chapter 10 Adam Trhon Chapter 133 Adhokshaj Mishra Chapter 76 ADITYA Chapter 79 Ajay Chapters 10, 14, 49, 69 and 139 alain Chapter 14 Alejandro Chapter 17 Alexey Guseynov Chapter 23 Alexey Voytenko Chapters 9 and 10 amanuel2 Chapters 94, 95, 96, 99 and 108 amchacon Chapter 17 Ami Tavory Chapters 12, 33, 62, 86, 103 and 114 an0o0nym Chapter 68 anatolyg Chapters 12 and 28 anderas Chapters 3, 7, 8, 9, 10, 12 and 14 Andrea Chua Chapters 7, 115 and 116 Andrea Corbelli Chapters 6, 14, 16 and 27 AndyG Chapters 12 and 45 Anonymous1847 Chapter 118 anotherGatsby Chapters 15 and 106 Antonio Barreto Chapter 74 AProgrammer Chapter 8 Aravind _0_KEN Chapter 95 ArchbishopOfBanterbury Chapters 1, 13 and 76 Artalus Chapter 41 asantacreu Chapter 102 Asu Chapter 27 Ates Goral Chapter 13 Bakhtiar Hasan Chapter 11 Baron Chapter 59 Chapters 2, 3, 4, 5, 6, 7, 10, 12, 13, 14, 15, 18, 20, 21, 22, 25, 28, 35, 41, 42, 45, 48, Barry 52, 57, 76, 111 and 124 bcmpinc Chapter 14 Ben H Chapter 1 Ben Steﬀan Chapter 76 Benjy Kessler Chapter 2 BigONotation Chapter 64 Bim Chapters 78 and 95 Chapters 1, 2, 7, 9, 13, 14, 17, 23, 24, 33, 35, 56, 60, 61, 68, 69, 71, 79, 80, 81, 105, Brian 106, 107, 108, 109, 110, 111, 120, 121, 122, 123, 124, 125, 126 and 127 C_0_W_0_Holeman II Chapter 52 CaﬀeineToCode Chapters 10 and 17 callyalater Chapters 9, 19 and 23 Complete Cplus_plus Tips & Secrets for Professionals 585 Candlemancer caps cb4 celtschk Chachmu Cheers and hth.
Mark Gardner marquesm91 MasterHD MathSquared Matt Matthew Brien Matthieu M.
Chapters 10 and 42 Chapters 3, 7, 9, 20, 22, 23, 30, 40, 41, 51, 53, 54, 55, 57, 64, 74, 76, 80 and 81 Chapters 12, 17, 76 and 114 Chapters 11 and 40 Chapter 14 Chapter 9 Chapter 1 Chapters 1, 5, 10, 12, 21, 41, 51 and 76 Chapters 5, 7, 11, 14, 15, 18, 31, 35, 72 and 83 Chapter 37 Chapter 145 Chapter 79 Chapters 20 and 64 Chapters 6 and 29 Chapters 1, 6, 9, 10, 23, 24, 47 and 76 Chapter 4 Chapters 6 and 12 Chapter 7 Chapters 1, 2, 3, 10, 29, 40 and 114 Chapters 1, 9, 11, 15, 19, 21, 24, 30, 32, 36, 76, 79, 88, 94, 99, 107 and 127 Chapters 1, 7, 8, 10, 11, 12, 14, 22, 34, 36, 38, 52, 56, 57, 60, 66, 67, 68, 75, 76, 85, 90, 102, 106, 114, 119 and 133 Chapter 1 Chapter 33 Chapters 6 and 19 Chapters 9, 10 and 108 Chapter 1 Chapters 1 and 91 Chapters 1, 12, 19 and 25 Chapter 72 Chapter 15 Chapter 1 Chapter 95 Chapter 5 Chapters 2, 5, 8, 12, 14, 21, 22 and 44 Chapter 12 Chapters 67 and 75 Chapter 14 Chapter 20 Chapter 28 Chapters 56 and 76 Chapters 1 and 50 Chapters 1 and 76 Chapters 1, 5, 6, 12, 16, 28 and 76 Chapters 1, 6, 8, 12, 15, 16, 24, 26, 30, 33, 44, 46, 52, 57 and 76 Chapter 6 Chapter 70 Chapters 19, 52, 67, 104, 112 and 121 Chapter 1 Chapter 110 Chapter 1 Chapter 85 Chapters 1 and 76 Chapter 58 Chapter 3 Complete Cplus_plus Tips & Secrets for Professionals 588 Maxito Meena Alfons merlinND Meysam Michael Gaskill Mike H MikeMB Mikitori mindriot Misgevolution MKAROL mkluwe MotKohn Motti mpromonet MSalters MSD mtb mtk Muhammad Aladdin muXXmit2X n_0_m.
Naor Hadar Nathan Osman Naveen Mittal Neil A.
Nemanja Boric Niall Nicholas Nicol Bolas Nikola Vasilev Nitinkumar Ambekar nnrales NonNumeric Null nwp Omnifarious Oz.
Pankaj Kumar Boora patmanpato Patryk Obara paul Paul Beckingham Pavel Strakhov PcAF Ped7g Perette Barella Peter phandinhlan Pietro Saccardi plasmacel pmelanson Podgorskiy Praetorian Pyves Chapter 2 Chapter Chapter 147 Chapter 26 Chapters 6, 10 and 16 Chapter 76 Chapter 4 Chapter 28 Chapter 119 Chapters 8 and 75 Chapter 133 Chapter 28 Chapter 106 Chapter 12 Chapters 12, 32 and 33 Chapters 6 and 103 Chapters 2 and 52 Chapter 76 Chapter 69 Chapter 12 Chapter 1 Chapter 1 Chapters 19 and 76 Chapter 70 Chapters 1, 76 and 114 Chapter 16 Chapter 1 Chapters 1, 23 and 76 Chapters 5, 6, 12 and 22 Chapter 15 Chapters 3, 5, 7, 8, 12, 14, 15, 18, 19, 21, 28, 34, 39, 43, 54, 59, 121, 124 and 134 Chapters 50, 60, 74, 78, 91, 100, 105 and 129 Chapter 59 Chapter 56 Chapter 113 Chapters 6, 7, 15, 16, 21 and 23 Chapter 17 Chapter 107 Chapter 4 Chapter 61 Chapters 8 and 12 Chapter 62 Chapters 12 and 86 Chapter 12 Chapter 1 Chapters 9 and 10 Chapters 12 and 15 Chapter 49 Chapters 5, 16, 19, 24, 33 and 76 Chapter 19 Chapter 59 Chapter 50 Chapter 15 Chapter 40 Chapters 12 and 14 Chapter 15 Complete Cplus_plus Tips & Secrets for Professionals 589 Qchmqs Quirk R.
Martinho Fernandes Rakete1111 ralismark RamenChef Ravi Chandra Reuben Thomas Richard Dally rick112358 rockoder rodrigo Roland RomCoo Ronen Ness rtmh Rushikesh Deshpande Ryan Haining R_Kapp Saint SajithP Samer Tufail sami1592 Sean Sergey Serikov Shoe sigalor silvergasp SingerOfTheFall SirGuy Skipper Skywrath Smeeheey Snowhawk sp2danny stackptr start2learn Stephen sth Stradigos strangeqargo SU3 Sumurai8 T_0_C.