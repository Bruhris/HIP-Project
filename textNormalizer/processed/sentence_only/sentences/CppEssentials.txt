Cplus_plus Essentials Sharam Hekmat PragSoft Corporation www_0_pragsoft_0_com Contents.
Preliminaries A Simple Cplus_plus Program Compiling a Simple Cplus_plus Program How Cplus_plus Compilation Works Variables Simple Input/Output Comments Memory Integer Numbers Real Numbers Characters Strings Names Exercises 1 2 3 4 5 7 9 10 11 12 13 14 15 16 2.
Expressions Arithmetic Operators Relational Operators Logical Operators Bitwise Operators Increment/Decrement Operators Assignment Operator Conditional Operator Comma Operator The sizeof Operator Operator Precedence Simple Type Conversion Exercises 17 18 19 20 21 22 23 24 25 26 27 28 29 www_0_pragsoft_0_com.
Statements Simple and Compound Statements The if Statement The switch Statement The while Statement The do Statement The for Statement The continue Statement The break Statement The goto Statement The return Statement Exercises 30 31 32 34 36 37 38 40 41 42 43 44 4.
Functions A Simple Function Parameters and Arguments Global and Local Scope Scope Operator Auto Variables Register Variables Static Variables and Functions Extern Variables and Functions Symbolic Constants Enumerations Runtime Stack Inline Functions Recursion Default Arguments Variable Number of Arguments Command Line Arguments Exercises 45 46 48 49 50 51 52 53 54 55 56 57 58 59 60 61 63 64 5.
Arrays, Pointers, and References Arrays Multidimensional Arrays Pointers Dynamic Memory Pointer Arithmetic Function Pointers References Typedefs Exercises 65 66 68 70 71 73 75 77 79 80 Cplus_plus Essentials Copyright © 2005 PragSoft 6.
Classes A Simple Class Inline Member Functions Example: A Set Class Constructors Destructors Friends Default Arguments Implicit Member Argument Scope Operator Member Initialization List Constant Members Static Members Member Pointers References Members Class  Members Arrays Class Scope Structures and Unions Bit Fields Exercises 82 83 85 86 90 92 93 95 96 97 98 99 101 102 104 105 106 108 110 112 113 7.
Overloading Function Overloading Operator Overloading Example: Set Operators Type Conversion Example: Binary Number Class Overloading << for Output Overloading >> for Input Overloading [] Memberwise Initialization Memberwise Assignment Overloading new  delete Overloading arrow_operator, *,  & Overloading plus_plus  -Exercises 115 116 117 119 121 124 127 128 129 131 133 135 136 138 142 143 8.
Derived Classes An illustrative Class A Simple Derived Class 145 146 150 www_0_pragsoft_0_com.
Templates Function  Definition Function  Instantiation Example: Binary Search Class  Definition Class  Instantiation Nontype Parameters Class  Specialization Class  Members Class  Friends Example: Doubly-linked Lists Derived Class Templates Exercises 170 171 172 174 176 177 178 179 180 181 182 186 187 10.
Exception Handling Flow Control The Throw Clause The Try Block  Catch Clauses Function Throw Lists Exercises 188 189 190 192 194 195 11.
The IO Library The Role of streambuf Stream Output with ostream Stream Input with istream Using the ios Class Stream Manipulators File IO with fstreams Array IO with strstreams Example: Program Annotation 196 198 199 201 204 209 210 212 214 Cplus_plus Essentials.
The Preprocessor Preprocessor Directives Macro Definition Quote and Concatenation Operators File Inclusion Conditional Compilation Other Directives Predefined Identifiers Exercises 218 219 220 222 223 224 226 227 228 Solutions to Exercises.
Preface Since its introduction less than a decade ago, Cplus_plus has experienced growing acceptance as a practical object-oriented programming language suitable for teaching, research, and commercial software development.
The language has also rapidly evolved during this period and acquired a number of new  (e_0_g_0_, templates and exception handling) which have added to its richness.
This book serves as an introduction to the Cplus_plus language.
It teaches how to program in Cplus_plus and how to properly use its.
It does not attempt to teach object-oriented design to any depth, which I believe is best covered in a book in its own right.
In designing this book, I have strived to achieve three goals.
First, to produce a concise introductory text, free from unnecessary verbosity, so that beginners can develop a good understanding of the language in a short period of time.
Second, I have tried to combine a tutorial style (based on explanation of concepts through examples) with a reference style (based on a flat structure).
As a result, each chapter consists of a list of relatively short sections (mostly one or two pages), with no further subdivision.
This, I hope, further simplifies the reader's task.
Finally, I have consciously avoided trying to present an absolutely complete description of Cplus_plus.
While no important topic has been omitted, descriptions of some of the minor idiosyncrasies have been avoided for the sake of clarity and to avoid overwhelming beginners with too much information.
Experience suggests that any small knowledge gaps left as a result, will be easily filled over time through selfdiscovery.
Intended Audience This book introduces Cplus_plus as an object-oriented programming language.
No previous knowledge of C or any other programming language is assumed.
Copyright © 2005 PragSoft who have already been exposed to a high-level programming language (such as C or Pascal) will be able to skip over some of the earlier material in this book.
Although the book is primarily designed for use in undergraduate computer science courses, it will be equally useful to professional programmers and hobbyists who intend to learn the language on their own.
The entire book can be easily covered in 10-15 lectures, making it suitable for a one-term or one-semester course.
It can also be used as the basis of an intensive 4-5 day industrial training course.
Structure of the Book The book is divided into 12 chapters.
Each chapter has a flat structure, consisting of an unnumbered sequence of sections, most of which are limited to one or two pages.
The aim is to present each new  in a confined space so that it can be quickly grasped.
Each chapter ends with a list of exercises.
Answers to all of the exercises are provided in an appendix.
Readers are encouraged to attempt as many of the exercises as feasible and to compare their solutions against the ones provided.
For the convenience of readers, the sample programs presented in this book (including the solutions to the exercises) and provided in electronic form.
Preliminaries This chapter introduces the basic elements of a Cplus_plus program.
We will use simple examples  show the structure of Cplus_plus programs and the way they are compiled.
Elementary concepts such as constants, variables, and their storage in memory will also be discussed.
The following is a cursory description of the concept of programming for the benefit of those who are new  the subject.
Programming A digital computer is a useful tool for solving a great variety of problems.
A solution  a problem is called an algorithm; it describes the sequence of steps be performed for the problem  be solved.
A simple example of a problem and an algorithm for it would be: Problem: Algorithm: Sort a list of names in ascending lexicographic order.
Call the given list list1; create an empty list, list2,  hold the sorted list.
Repeatedly find the 'smallest' name in list1, remove it from list1, and make it the next entry of list2, until list1 is empty.
An algorithm is expressed in abstract terms.
To be intelligible  a computer, it needs  be expressed in a language understood by it.
The only language really understood by a computer is its own machine language.
Programs expressed in the machine language are said  be executable.
A program written in any other language needs  be first translated  the machine language before it can be executed.
A machine language is far too cryptic  be suitable for the direct use of programmers.
A further abstraction of this language is the assembly language which provides mnemonic names for the instructions and a more intelligible notation for the data.
An assembly language program is translated  machine language by a translator called an assembler.
Even assembly languages are difficult  work with.
High-level languages such as Cplus_plus provide a much more convenient notation for implementing algorithms.
They liberate programmers from having  think in very low-level terms, and help them  focus on the algorithm instead.
A program written in a high-level language is translated  assembly language by a translator called a compiler.
The assembly code produced by the compiler is then assembled  produce an executable program.
Iostream_0_h is a standard Cplus_plus header file and contains definitions for input and output.
A function may have zero or more parameters; these always appear after the function name, between a pair of brackets.
The word void appearing between the brackets indicates that main has no parameters.
The return type for main is int (i_0_e_0_, an integer number).
All Cplus_plus programs must have exactly one main function.
Program execution always begins from main.
A statement is a computation step which may produce a value.
The end of a statement is always marked with a semicolon (;).
This statement causes the string "Hello World\n"  be sent  the output stream.
A string is any sequence of characters enclosed in double-quotes.
The last character in this string (\n) is a newline character which is similar  a carriage return on a type writer.
A stream is an object which performs input or output.
Cout is the standard output stream in Cplus_plus (standard output usually means your computer monitor screen).
The symbol << is an output operator which takes an output stream as its left operand and an expression as its right operand, and causes the value of the latter  be 5.
Copyright © 2005 PragSoft Compiling a Simple Cplus_plus Program Dialog 1_0_1 shows how the program in Listing 1_0_1 is compiled and run in a typical UNIX environment.
User input appears in bold and system response in plain.
The UNIX command line prompt appears as a dollar symbol ($).
Dialog 1_0_1 1 2 3 4 $ CC hello_0_cc $ a_0_out Hello World $ Annotation 1 The command for invoking the AT&T Cplus_plus translator in a UNIX environment is CC.
The argument to this command (hello_0_cc) is the name of the file which contains the program.
As a convention, the file name should end in _0_c, _0_C, or 2 The result of compilation is an executable file which is by default named a_0_out.
To run the program, we just use a_0_out as a command.
The CC command accepts a variety of useful options.
An option appears as name, where name is the name of the option (usually a single letter).
Some options take arguments.
For example, the output option (-o) allows you to specify a name for the executable file produced by the compiler instead of a_0_out.
Bookmark not defined.
Dialog 1_0_2 1 2 3 4 $ CC hello_0_cc -o hello $ hello Hello World $ Although the actual command may be different depending on the make of the compiler, a similar compilation procedure is used under MS-DOS.
Windowsbased Cplus_plus compilers offer a user-friendly environment where compilation is as simple as choosing a menu command.
The naming convention under MS-DOS and Windows is that Cplus_plus source file names should end in _0_cpp.
First, the Cplus_plus preprocessor goes over the program text and carries out the instructions specified by the preprocessor directives (e_0_g_0_, #).
The result is a modified program text which no longer contains any directives.
Then, the Cplus_plus compiler translates the program code.
The compiler may be a true Cplus_plus compiler which generates native (assembly or machine) code, or just a translator which translates the code into C.
In the latter case, the resulting C code is then passed through a C compiler to produce native object code.
In either case, the outcome may be incomplete due to the program referring to library routines which are not defined as a part of the program.
For example, Listing 1_0_1 refers to the << operator which is actually defined in a separate IO library.
Finally, the linker completes the object code by linking it with the object code of any library modules that the program may have referred to.
The final result is an executable file.
Figure 1_0_1 illustrates the above steps for both a Cplus_plus translator and a Cplus_plus native compiler.
In practice all these steps are usually invoked by a single command (e_0_g_0_, CC) and the user will not even see the intermediate files generated.
Figure 1_0_1 Cplus_plus Compilation Cplus_plus Program Cplus_plus TRANSLATOR Cplus_plus Program Cplus_plus NATIVE COMPILER C Code C COMPILER Object Code LINKER.
Copyright © 2005 PragSoft Variables A variable is a symbolic name for a memory location in which data can be stored and subsequently recalled.
Variables are used for holding data values so that they can be utilized in various computations in a program.
All variables have two important attributes:.
A type which is established when the variable is defined (e_0_g_0_, integer, real, character).
Once defined, the type of a Cplus_plus variable cannot be changed.
A  which can be changed by assigning a new  to the variable.
The kind of values a variable can assume depends on its type.
For example, an integer variable can only take integer values (e_0_g_0_, 2, 100, -12).
Listing 1_0_2 illustrates the uses of some simple variable.
As a general rule, a variable is defined by specifying its type first, followed by the variable name, followed by a semicolon.
As illustrated by this line, multiple variables of the same type can be defined at once by separating them with commas.
It assigns the  5 to the variable Therefore, after this statement is executed,  denotes the 5.
The resulting  is stored in.
When run, the program will produce the following output: = 1445_0_625 When a variable is defined, its  is undefined until it is actually assigned one.
For example,  has an undefined  (i_0_e_0_, whatever happens to be in the memory location which the variable denotes at the time) until line 9 is executed.
The assigning of a  to a variable for the first time is called initialization.
It is important to ensure that a variable is initialized before it is used in any computation.
It is possible to define a variable and initialize it at the same time.
This is considered a good programming practice, because it pre-empts the possibility of using the variable prior to it being initialized.
Listing 1_0_3 is a revised version of Listing 1_0_2 which uses this technique.
For all intents and purposes, the two programs are equivalent.
Copyright © 2005 PragSoft Simple Input/Output The most common way in which a program communicates with the outside world is through simple, character-oriented Input/Output (IO) operations.
Cplus_plus provides two useful operators for this purpose: >> for input and << for output.
We have already seen examples of output using <<.
Listing 1_0_4 also illustrates the use of >> for input.
The input operator >> takes an input stream as its left operand (cin is the standard Cplus_plus input stream which corresponds to data entered via the keyboard) and a variable (to which the input data is copied) as its right operand.
When run, the program will produce the following output (user input appears in bold): What is the hourly pay rate.
This is illustrated by Listing 1_0_5 which now allows the input of both the daily work hours and the hourly pay rate.
The two values should be separated by white space (i_0_e_0_, one or more space or tab characters).
This statement is equivalent to: (cin >> ) >> ; Because the result of >> is its left operand, (cin >> ) evaluates to cin which is then used as the left operand of the next >> operator.
It outputs "  = ", followed by the value of , followed by a newline character.
This statement is equivalent to: (( << "  = ") << ) << '\n'; evaluates to  which is then used as the left operand of the next << operator, etc.
When run, the program will produce the following output: What are the work hours and the hourly pay rate.
Copyright © 2005 PragSoft Comments A comment is a piece of descriptive text which explains some aspect of a program.
Program comments are totally ignored by the compiler and are only intended for human readers.
Cplus_plus provides two types of comment delimiters:.
Anything after // (until the end of the line on which it appears) is considered a comment.
Anything enclosed by the pair /* and */ is considered a comment.
Listing 1_0_6 illustrates the use of both forms.
Listing 1_0_6 1 2 3 4 5 6 7 8 9 10 11 12 13 # <iostream_0_h> /* This program calculates the weekly gross pay for a worker, based on the total number of hours worked and the hourly pay rate.
The following two points, in particular, should be noted:.
A comment should be easier to read and understand than the code which it tries to explain.
A confusing or unnecessarily-complex comment is worse than no comment at all.
Over-use of comments can lead to even less readability.
A program which contains so much comment that you can hardly see the code can by no means be considered readable.
Use of descriptive names for variables and other entities in a program, and proper indentation of the code can reduce the need for using comments.
The best guideline for how to use comments is to simply apply common sense.
This memory can be thought of as a contiguous sequence of bits, each of which is capable of storing a binary digit (0 or 1).
Typically, the memory is also divided into groups of 8 consecutive bits (called bytes).
The bytes are sequentially addressed.
Therefore each byte can be uniquely identified by its address (see Figure 1_0_2).
Figure 1_0_2 Bits and bytes in memory.
Byte Address _0__0_.
Byte 1217 Byte _0__0_.
For example, the variable definition int  = 65000; causes the compiler to allocate a few bytes to represent.
The exact number of bytes allocated and the method used for the binary representation of the integer depends on the specific Cplus_plus implementation, but let us say two bytes encoded as a 2's complement integer.
The compiler uses the address of the first byte at which  is allocated to refer to it.
The above assignment causes the value 65000 to be stored as a 2's complement integer in the two bytes allocated (see Figure 1_0_3).
Figure 1_0_3 Representation of an integer in memory.
Memory While the exact binary representation of a data item is rarely of interest to a programmer, the general organization of memory and use of addresses for referring to data items (as we will see later) is very important.
Copyright © 2005 PragSoft Integer Numbers An integer variable may be defined to be of type short, int, or long.
The only difference is that an int uses more or at least the same number of bytes as a short, and a long uses more or at least the same number of bytes as an int.
For example, on the author's PC, a short uses 2 bytes, an int also 2 bytes, and a long 4 bytes.
By default, an integer variable is assumed to be signed (i_0_e_0_, have a signed representation so that it can assume positive as well as negative values).
However, an integer can be defined to be unsigned by using the keyword unsigned in its definition.
The keyword signed is also allowed but is redundant.
A literal integer (e_0_g_0_, 1984) is always assumed to be of type int, unless it has an L or l suffix, in which case it is treated as a long.
Also, a literal integer can be specified to be unsigned using the suffix U or u.
The decimal notation is the one we have been using so far.
An integer is taken to be octal if it is preceded by a zero (0), and hexadecimal if it is preceded by a 0x or 0X.
Octal numbers use the base 8, and can therefore only use the digits 0-7.
Hexadecimal numbers use the base 16, and therefore use the letter A-F (or a-f) to represent, respectively, 10-15.
Octal and hexadecimal numbers are calculated as follows: 0134 = 1 × 82 + 3 × 81 + 4 × 80 = 64 + 24 + 4 = 92 0x5 = 5 × 161 + 12 × 160 = 80 + 12 = 92 ¨ www_0_pragsoft_0_com.
The latter uses more bytes and therefore offers a greater range and accuracy for representing real numbers.
For example, on the author's PC, a float uses 4 and a double uses 8 bytes.
A literal real (e_0_g_0_, 0_0_06) is always assumed to be of type double, unless it has an F or f suffix, in which case it is treated as a float, or an L or l suffix, in which case it is treated as a long double.
The latter uses more bytes than a double for better accuracy (e_0_g_0_, 10 bytes on the author's PC).
For example, 0_0_002164 may be written in the scientific notation as: 2_0_164-3 or 2_0_164e-3 The letter  (or e) stands for exponent.
The scientific notation is interpreted as follows: 2_0_164-3 = 2_0_164 × 10-3 ¨ 12.
Copyright © 2005 PragSoft Characters A character variable is defined to be of type char.
A character variable occupies a single byte which contains the code for the character.
This code is a numeric value and depends on the character coding system being used (i_0_e_0_, is machine-dependent).
The most common system is ASCII (American Standard Code for Information Interchange).
For example, the character A has the ASCII code 65, and the character a has the ASCII code 97.
By the default (on most systems) char means signed char.
However, on some systems it may mean unsigned char.
A signed character variable can hold numeric values in the range -128 through 127.
An unsigned character variable can hold numeric values in the range 0 through 255.
As a result, both are often used to represent small integers in programs (and can be assigned numeric values like integers): signed char unsigned char.
A literal character is written by enclosing the character between a pair of single quotes (e_0_g_0_, 'A').
Nonprintable characters are represented using escape sequences.
Literal characters may also be specified using their numeric code value.
The general escape sequence \ooo (i_0_e_0_, a backslash followed by up to three octal digits) is used for this purpose.
For example (assuming ASCII): '\12' '\11' '\101' '\0'.
A string variable is defined to be of type char* (i_0_e_0_, a pointer to character).
A pointer is simply the address of a memory location.
A string variable, therefore, simply contains the address of where the first character of a string appears.
For example, consider the definition: char * = "HELLO"; Figure 1_0_4 illustrates how the string variable  and the string "HELLO" might appear in memory.
Figure 1_0_4 A string and a string variable in memory.
A literal string is written by enclosing its characters between a pair of double quotes (e_0_g_0_, "HELLO").
The compiler always appends a null character to a literal string to mark its end.
The characters of a string may be specified using any of the notations for specifying literal characters.
A long string may extend beyond a single line, in which case each of the preceding lines should be terminated by a backslash.
For example: "Example to show \ the use of backslash for \ The backslash in this context means that the rest of the string is continued on the next line.
The above string is equivalent to the single line string: A common programming error results from confusing a single-character string (e_0_g_0_, "A") with a single character (e_0_g_0_, 'A').
The former consists of two bytes (the character 'A' followed by the character '\0'), whereas the latter consists of a single byte.
The shortest possible string is the null string ("") which simply consists of the null character.
Copyright © 2005 PragSoft Names Programming languages use names to refer to the various entities that make up a program.
We have already seen examples of an important category of such names (i_0_e_0_, variable names).
Other categories include: function names, type names, and macro names, which will be described later in this book.
Names are a programming convenience, which allow the programmer to organize what would otherwise be quantities of plain data into a meaningful and human-readable collection.
As a result, no trace of a name is left in the final executable  generated by a compiler.
For example, a temperature variable eventually becomes a few bytes of memory which is referred to by the executable by its address, not its name.
Cplus_plus imposes the following rules for creating valid names (also called identifiers ).
A name should consist of one or more characters, each of which may be a letter (i_0_e_0_, 'A'-'Z' and 'a'-'z'), a digit (i_0_e_0_, '0'-'9'), or an underscore character ('_'), except that the first character may not be a digit.
Upper and lower case letters are distinct.
For example: salary salary2 2salary _salary Salary.
But the limit is usually so large that it should not cause a concern (e_0_g_0_, 255 characters).
Certain words are reserved by Cplus_plus for specific purposes and may not be used as identifiers.
These are called reserved words or keywords and are summarized in Table 1_0_1: Table 1_0_1 Cplus_plus keywords.
Its behavior should resemble this: Temperature in : 41 41 degrees  = 5 degrees Celsius 1_0_2.
Which of the following represent valid identifiers.
Age of a person.
Expressions This chapter introduces the built-in Cplus_plus operators for composing expressions.
An expression is any computation which yields a value.
When discussing expressions, we often use the term evaluation.
For example, we say that an expression evaluates to a certain value.
Usually the final value is the only reason for evaluating the expression.
However, in some cases, the expression may also produce side-effects.
These are permanent changes in the program state.
In this sense, Cplus_plus expressions are different from mathematical expressions.
Cplus_plus provides operators for composing arithmetic, relational, logical, bitwise, and conditional expressions.
It also provides operators which produce useful sideeffects, such as assignment, increment, and decrement.
We will look at each category of operators in turn.
We will also discuss the precedence rules which govern the order of operator evaluation in a multi-operator expression.
These are summarized in Table 2_0_2.
Operator + * / % Name Addition Subtraction Multiplication Division Remainder Example 12 + 4_0_9 3_0_98 - 4 2 * 3_0_4 9 / 2_0_0 13 % 3.
Generally, if both operands are integers then the result will be an integer.
However, if one or both of the operands are reals then the result will be a real (or double to be exact).
When both operands of the division operator (/) are integers then the division is performed as an integer division and not the normal division we are used to.
Integer division always results in an integer outcome (_0_e_0_, the result is always rounded down).
Unintended integer divisions are a common source of programming errors.
To obtain a real division when both operands are integers, you should cast one of the operands to be real: double.
The remainder operator (%) expects integers for both of its operands.
It returns the remainder of integer-dividing the operands.
For example 13%3 is calculated by integer dividing 13 by 3 to give an outcome of 4 and a remainder of 1; the result is therefore 1.
It is possible for the outcome of an arithmetic operation to be too large for storing in a designated variable.
This situation is called an overflow.
The outcome of an overflow is machine-dependent and therefore undefined.
For example: unsigned.
Copyright © 2005 PragSoft Relational Operators Cplus_plus provides six relational operators for comparing numeric quantities.
These are summarized in Table 2_0_3.
Relational operators evaluate to 1 (representing the true outcome) or 0 (representing the false outcome).
Table 2_0_3 Relational operators.
Operator == _0_= < <= > >= Name Equality Inequality Less Than Less Than or Equal Greater Than Greater Than or Equal Example 5 == 5 5 _0_= 5 5 < 5_0_5 5 <= 5 5 > 5_0_5 6_0_3 >= 5.
In , =<  => are both invalid  do not mean anything.
The operands of a relational operator must evaluate to a number.
Characters are valid operands since they are represented by numeric values.
For example (assuming ASCII coding): 'A' < 'F' The relational operators should not be used for comparing strings, because this will result in  string addresses being compared, not  string contents.
For example,  expression causes  address of "HELLO" to be compared to  address of "BYE".
As these addresses are determined by  compiler (in a machine-dependent manner), outcome may be 0 or may be 1,  is therefore undefined.
Cplus_plus provides library functions (e_0_g_0_, strcmp) for  lexicographic comparison of string.
These will be described later in  book.
These are summarized in Table 2_0_4.
Like  relational operators, logical operators evaluate to 1 or 0.
Logical negation is a unary operator, which negates  logical value of its single operand.
If its operand is nonzero it produce 0,  if it is 0 it produces 1.
Logical  produces 0 if one or both of its operands evaluate to 0.
Logical or produces 0 if both of its operands evaluate to 0.
Note that here we talk of zero  nonzero operands (not zero  1).
In general, any nonzero value can be used to represent  logical true, whereas only zero represents  logical false.
The following are, therefore, all valid logical expressions: _0_20 10 && 5 10 || 5_0_5 10 && 0.
Copyright © 2005 PragSoft Bitwise Operators Cplus_plus provides six bitwise operators for manipulating  individual bits in an integer quantity.
These are summarized in Table 2_0_5.
Table 2_0_5 Bitwise operators.
Operator ~ & | ^ << >> Name Bitwise Negation Bitwise And Bitwise Or Bitwise Exclusive Or Bitwise Left Shift Bitwise Right Shift Example ~'\011' '\011' & '\027' '\011' | '\027' '\011' ^ '\027' '\011' << 2 '\011' >> 2.
Bitwise negation is a unary operator which reverses the bits in its operands.
Bitwise and compares the corresponding bits of its operands and produces a 1 when both bits are 1, and 0 otherwise.
Bitwise or compares the corresponding bits of its operands and produces a 0 when both bits are 0, and 1 otherwise.
Bitwise exclusive or compares the corresponding bits of its operands and produces a 0 when both bits are 1 or both bits are 0, and 1 otherwise.
Bitwise left shift operator and bitwise right shift operator both take a bit sequence as their left operand and a positive integer quantity n as their right operand.
The former produces a bit sequence equal to the left operand but which has been shifted n bit positions to the left.
The latter produces a bit sequence equal to the left operand but which has been shifted n bit positions to the right.
Vacated bits at either end are set to 0.
Table 2_0_6 illustrates bit sequences for the sample operands and results in Table 2_0_5.
To avoid worrying about the sign bit (which is machine dependent), it is common to declare a bit sequence as an unsigned quantity: unsigned char  = '\011'; unsigned char  = '\027'; Table 2_0_6.
How the bits are calculated.
Example Octal Value ~ & | ^ << 2 >> 2 011 027 366 001 037 036 044 002 Bit Sequence 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 1 0 0 1 1 0 1 1 0 0 1 0 0 0 1 1 0 0 0 1 1 0 1 1 1 0 0 1 1 0 1 1 0 1 1 1 0 1 1 0 0 0 ¨ www_0_pragsoft_0_com.
These are summarized in Table 2_0_7.
The examples assume the following variable definition: int  = 5; Table 2_0_7 Increment and decrement operators.
Operator plus_plus plus_plus minus_minus Name Example plus_plusk kplus_plus minus_minusk kminus_minus + + + + 10 10 10 10.
The difference is significant.
When used in prefix form, the operator is first applied and the outcome is then used in the expression.
When used in the postfix form, the expression is evaluated first and then the operator applied.
Both operators may be applied to integer as well as real variables, although in practice real variables are rarely useful in this form.
Copyright © 2005 PragSoft Assignment Operator The assignment operator is used for storing a value at some memory location (typically denoted by a variable).
Its left operand should be an lvalue, and its right operand may be an arbitrary expression.
The latter is evaluated and the outcome is stored in the location denoted by the lvalue.
An lvalue (standing for left value) is anything that denotes a memory location in which a value may be stored.
The only kind of lvalue we have seen so far in this book is a variable.
Other kinds of lvalues (based on pointers and references) will be described later in this book.
The assignment operator has a number of variants, obtained by combining it with the arithmetic and bitwise operators.
These are summarized in Table 2_0_8.
The examples assume that n is an integer variable.
Operator = += -= *= /= %= &= |= ^= <<= >>= Example Equivalent To n n n n n n n n n n n n n n n n n n n n n = 25 += 25 -= 25 *= 25 /= 25 %= 25 &= 0xF2F2 |= 0xF2F2 ^= 0xF2F2 <<= 4 >>= 4 = = = = = = = = = = n n n n n n n n n n + 25 - 25 * 25 / 25 % 25 & 0xF2F2 | 0xF2F2 ^ 0xF2F2 << 4 >> 4 An assignment operation is itself an expression whose value is the value stored in its left operand.
An assignment operation can therefore be used as the right operand of another assignment operation.
Any number of assignments can be concatenated in this fashion to form one expression.
It has the general form: operand1.
If the result is nonzero then operand2 is evaluated and its value is the final result.
Otherwise, operand3 is evaluated and its value is the final result.
For example, in int  = ( <.
Because a conditional operation is itself an expression, it may be used as an operand of another conditional operation, that is, conditional expressions may be nested.
For example: int  = 1,  = 2,  =3; : ( <.
Copyright © 2005 PragSoft Comma Operator Multiple expressions can be combined into one expression using the comma operator.
The comma operator takes two operands.
It first evaluates the left operand and then the right operand, and returns the value of the latter as the final outcome.
Otherwise, nCountplus_plus is evaluated and the value of  is stored in.
It takes a single operand which may be a type name (e_0_g_0_, int) or an expression (e_0_g_0_, 100) and returns the size of the specified entity in bytes.
The outcome is totally machine-dependent.
Listing 2_0_7 illustrates the use of sizeof on the built-in types we have encountered so far.
Listing 2_0_7 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # <iostream_0_h> int main { cout cout cout cout cout cout cout << << << << << << << "char "char* "short "int "long "float "double cout << "1_0_55 cout << "1_0_55L cout << "HELLO size size size size size size size = = = = = = = << << << << << << <<.
When run, the program will produce the following output (on the author's PC): * 1_0_55 1_0_55 = = = = = = = = = = 1 bytes 2 bytes 2 bytes 2 bytes 4 bytes 4 bytes 8 bytes 8 bytes 10 bytes 6 bytes ¨ 26.
Copyright © 2005 PragSoft Operator Precedence The order in which operators are evaluated in an expression is significant and is determined by precedence rules.
These rules divide the Cplus_plus operators into a number of precedence levels (see Table 2_0_9).
Operators in higher levels take precedence over operators in lower levels.
Table 2_0_9 Operator precedence levels.
Level Highest Lowest.
Left to Right For example, in == b + c * d c * d is evaluated first because * has  higher precedence  +  ==.
The result is  added to  because + has  higher precedence  ==,   == is evaluated.
Precedence rules can be overridden using brackets.
For example, rewriting the above expression as == ( + c) * d causes + to be evaluated before *.
Operators with the same precedence level are evaluated in the order specified by the last column of Table 2_0_9.
For example, in =  += c the evaluation order is right to left, so first  += c is evaluated, followed by  = ¨ www_0_pragsoft_0_com Chapter 2: Expressions 27 Simple Type Conversion to any of the other types.
For example: (int) 3_0_14 // converts 3_0_14 to an int to give 3 (long) 3_0_14 // converts 3_0_14 to  long to give 3L (double) 2 // converts 2 to  double to give 2_0_0 (char) 122 // converts 122 to  char whose code is 122 (unsigned short) 3_0_14 // gives 3 as an unsigned short As shown by these examples, the built-in type identifiers can be used as type operators.
Type operators are unary (i_0_e_0_, take one operand)  appear inside brackets to the left of their operand.
This is called explicit type conversion.
When the type name is just one word, an alternate notation may be used in which the brackets appear around the operand:.
In the last example,  +  involves mismatching types, so  is first converted to double (promoted)   added to.
The result is  double which does not match the type of  on the left side of the assignment, so it is converted to int (demoted) before being assigned to.
The above rules represent some simple but common cases for type conversion.
More complex cases will be examined later in the book after we have discussed other data types  classes.
Copyright © 2005 PragSoft Exercises 2_0_5 2_0_6 Write expressions for the following:.
To test if  number n is even.
To give the number of characters in  null-terminated string literal s.
Add extra brackets to the following expressions to explicitly show the order in which the operators are evaluated: 2_0_7 What will be the value of each of the following variables after its initialization: double long char char k c c = = = =.
Write  program which inputs  positive integer   outputs 2 raised to the power of.
Statements This chapter introduces the various forms of Cplus_plus statements for composing programs.
Statements represent the lowest-level building blocks of  program.
Roughly speaking, each statement represents  computational step which has certain side-effect.
A running program spends all of its time executing statements.
The order in which statements are executed is called flow control (or control flow).
This term reflect the fact that the currently executing statement has the control of the CPU, which when completed will be handed over (flow) to another statement.
Flow control in a program is typically sequential, from one statement to the next, but may be diverted to other paths by branch statements.
Flow control is an important consideration because it determines what is executed during a run and what is not, therefore affecting the overall outcome of the program.
Like many other procedural languages, Cplus_plus provides different forms of statements for different purposes.
Declaration statements are used for defining variables.
Assignment-like statements are used for simple, algebraic computations.
Branching statements are used for specifying alternate paths of execution, depending on the outcome of a logical condition.
Loop statements are used for specifying computations which need to be repeated until a certain logical condition is satisfied.
Flow control statements are used to divert the execution path to another part of the program.
We will discuss these in turn.
Copyright © 2005 PragSoft Simple and Compound Statements A simple statement is a computation terminated by a semicolon.
The last example represents a useless statement, because it has no side-effect ( is added to 5 and the result is just discarded).
Although the null statement has no side-effect, as we will see later in the chapter, it has some genuine uses.
Multiple statements can be combined into a compound statement by enclosing them within braces.
Compound statements are useful in two ways: () they allow us to put multiple they allow us to introduce a new  in the program.
A  is a part of the program text within which a variable remains defined.
For example, the  of , , and  in the above example is from where they are defined till the closing brace of the compound statement.
Outside the compound statement, these variables are not defined.
Because a compound statement may contain variable definitions and defines a for them, it is also called a block.
The  of a Cplus_plus variable is limited to the block immediately enclosing it.
Blocks and  rules will be described in more detail when we discuss functions in the next chapter.
The if statement provides a way of expressing this, the general form of which is: statement; First expression is evaluated.
If the outcome is nonzero then statement is executed.
For example, when dividing two values, we may want to check that the denominator is nonzero: = sum / ;.
A variant form of the if statement allows us to specify two alternative statements: one which is executed if a condition is satisfied and one which is executed if the condition is not satisfied.
This is called the if-else statement and has the general form: statement1 ; else statement2 ; First expression is evaluated.
If the outcome is nonzero then statement 1 is.
Copyright © 2005 PragSoft Given the similarity between the two alternative parts, the whole statement can be simplified to: =  * creditRate;.
If statements may be nested by having an if statement appear inside another if.
Copyright © 2005 PragSoft The switch Statement The switch statement provides a way of choosing between a set of alternatives, based on the value of an expression.
The general form of the switch statement is: switch (expression) { case constant1 : statements; _0__0_.
First expression (called the switch tag) is evaluated, and the outcome is compared to each of the numeric constants (called case labels), in the order they appear, until a match is found.
The statements following the matching case are then executed.
Note the plural: each case may be followed by zero or more statements (not just one statement).
Execution continues until either a break statement is encountered or all intervening statements until the end of the switch statement are executed.
The final default case is optional and is exercised if none of the earlier cases provide a match.
For example, suppose we have parsed a binary arithmetic operation into its three components and stored these in variables operator, operand1, and operand2.
The following switch statement performs the operation and stored the in.
As illustrated by this example, it is usually necessary to include a break statement at the end of each case.
The break terminates the switch statement by jumping to the very end of it.
There are, however, situations in which it makes sense to have a case without a break.
For example, if we extend the above statement to also allow x to be used as a multiplication , we will have: www_0_pragsoft_0_com.
Because case 'x' has no break statement (in fact no statement at all_0_), when this case is satisfied, execution proceeds to the statements of the next case and the multiplication is performed.
It should be obvious that any switch statement can also be written as multiple if-else statements.
The above statement, for example, may be written as: = operand1 + operand2; = operand1 - operand2;.
In general, preference should be given to the switch version when possible.
The if-else approach should be reserved for situation where a switch cannot do the job (e_0_g_0_, when the conditions involved are not simple equality expressions, or when the case labels are not numeric constants).
Copyright © 2005 PragSoft The while Statement The while statement (also called while loop) provides a way of repeating an statement while a condition holds.
It is one of the three flavors of iteration in Cplus_plus.
The general form of the while statement is: statement; First expression (called the loop condition) is evaluated.
If the outcome is nonzero then statement (called the loop body) is executed and the whole process is repeated.
Otherwise, the loop is terminated.
For example, suppose we wish to calculate the  of all numbers from 1 to some integer denoted by n.
For n set to 5, Table 3_0_10 provides a trace of the loop by listing the values of the variables involved and the loop condition.
Table 3_0_10 While loop trace.
Iteration First Second Third Fourth Fifth Sixth 1 2 3 4 5 6 n 5 5 5 5 5 5 <= n 1 1 1 1 1 0 += iplus_plus 1 3 6 10 15 It is not unusual for a while loop to have an empty body (_0_e_0_, a null statement).
The following loop, for example, sets  to its greatest odd factor.
The loop condition not only tests that  is even, it also divides by two and ensures that the loop will terminate should  be zero.
The general form of the do statement is: do statement; while (expression); First statement is executed and then expression is evaluated.
If the outcome of the latter is nonzero then the whole process is repeated.
Otherwise, the loop is terminated.
The do loop is less frequently used than the while loop.
It is useful for situations where we need the loop body to be executed at least once, regardless of the loop condition.
For example, suppose we wish to repeatedly read a value and print its square, and stop when the value is zero.
This can be expressed as the following loop:.
Unlike the while loop, the do loop is never used in situations where it would have a null body.
Although a do loop with a null body would be equivalent to a similar while loop, the latter is always preferred for its superior readability.
Copyright © 2005 PragSoft The for Statement The for statement (also called for loop) is similar to the while statement, but has two additional components: an expression which is evaluated only once before everything else, and an expression which is evaluated once at the end of each iteration.
The general form of the for statement is: statement; First expression1 is evaluated.
Each time round the loop, expression2 is evaluated.
If the outcome is nonzero then statement is executed and expression3 is evaluated.
Otherwise, the loop is terminated.
The general for loop is equivalent to the following while loop:.
The following for loop, for example, calculates the  of all integers from 1 to.
In this example,  is usually called the loop variable.
Cplus_plus allows the first expression in a for loop to be a variable definition.
In the above loop, for example,  can be defined inside the loop itself: += ; Contrary to what may appear, the scope for  is not the body of the loop, but the.
For example, removing the first and the third expression gives us something identical to a while loop:.
Removing all the expressions gives us an infinite loop.
This loop's condition is.
In other words, loops can be nested.
For example, << '(' <<  << ',' <<  << ")\"; produces the product of the set {1,2,3} with itself, giving the output: ¨ 40.
Copyright © 2005 PragSoft The continue Statement The continue statement terminates the current iteration of a loop and instead jumps to the next iteration.
It applies to the loop immediately enclosing the continue statement.
It is an error to use the continue statement outside a loop.
In while and do loops, the next iteration commences from the loop condition.
In a for loop, the next iteration commences from the loop's third expression.
For example, a loop which repeatedly reads in a number, processes it but ignores negative numbers, and terminates when the number is zero, may be expressed as:.
When the continue statement appears inside nested loops, it applies to the loop immediately enclosing it, and not to the outer loops.
For example, in the following set of nested loops, the continue applies to the for loop, and not the while loop:.
It causes a jump out of these constructs, and hence terminates them.
Like the continue statement, a break statement only applies to the loop or switch immediately enclosing it.
It is an error to use the break statement outside a loop or a switch.
For example, suppose we wish to read in a user password, but would like to allow the user a limited number of attempts: for ( = 0;  < attempts; plus_plusi) {.
Here we have assumed that there is a function called Verify which checks a password and returns true if it is correct, and false otherwise.
Rewriting the loop without a break statement is always possible by using an additional logical variable () and adding it to the loop condition:.
Copyright © 2005 PragSoft.
The goto statement provides the lowest-level of jumping.
It has the general form: goto label; where label is an identifier which marks the jump destination of goto.
The label should be followed by a colon and appear before a statement within the same function as the goto statement itself.
For example, the role of the break statement in the for loop in the previous section can be emulated by a goto: for ( = 0;  < attempts; plus_plusi) {.
Because goto provides a free and unstructured form of jumping (unlike break and continue), it can be easily misused.
Most programmers these days avoid using it altogether in favor of clear programming.
Nevertheless, goto does have some legitimate (though rare) uses.
Because of the potential complexity of such cases, furnishing of examples is postponed to the later parts of the book.
It has the general form: return expression; where expression denotes the value returned by the function.
The type of this value.
The return value of main is what the program returns to the operating system when it completes its execution.
Under UNIX, for example, it its conventional to return 0 from main when the program executes without errors.
Otherwise, a non-zero error code is returned.
When a function has a non-void return value (as in the above example), failing to return a value will result in a compiler warning.
The actual return value will be undefined in this case (_0_e_0_, it will be whatever value which happens to be in its corresponding memory location at the time).
Copyright © 2005 PragSoft Exercises 3_0_10 Write a program which inputs a person's  (in centimeters) and  (in kilograms) and outputs one of the messages: underweight, normal, or overweight, using the criteria: Underweight: Normal: Overweight: 3_0_11 < /2_0_5 /2_0_5 <=  <= /2_0_3 /2_0_3 < Assuming that  is 20, what will the following code fragment output when executed.
For example, 25/12/61 becomes: December 25, 1961 3_0_13.
Write a program which inputs an octal number and outputs its decimal equivalent.
The following example illustrates the expected behavior of the program: Input an octal number: 214 3_0_15 Write a program which produces a simple multiplication table of the following format for integers in the range 1 to 9: 1  1 = 1 1  2 = 2 _0__0_.
Functions This chapter describes user-defined functions as one of the main building blocks of Cplus_plus programs.
The other main building block — user-defined classes — will be discussed in Chapter 6.
A function provides a convenient way of packaging a computational recipe, so that it can be used as often as required.
A function definition consists of two specifies how it may be used.
It consists of three entities:.
This is simply a unique identifier.
The function parameters (also called its signature).
This is a set of zero or more typed identifiers used for passing values to and from the function.
This specifies the type of value the function returns.
A function which returns nothing should have the return type void.
The body of a function contains the computational steps (statements) that comprise the function.
Using a function involves 'calling' it.
A function call consists of the function name followed by the call operator brackets '()', inside which zero or more comma-separated arguments appear.
The number of arguments should match the number of function parameters.
Each argument is an expression whose type should match the type of the corresponding parameter in the function interface.
When a function call is executed, the arguments are first evaluated and their resulting values are assigned to the corresponding parameters.
Finally, the function return value (if any) is passed to the caller.
Since a call to a function whose return type is non- void yields a return value, the call is an expression and may be used in other expressions.
By contrast, a call to a function whose return type is void is a statement.
Listing 4_0_8 1 2 3 4 5 6 7 Annotation.
This line defines the function interface.
It starts with the return type of the function (int in this case).
The function name appears next followed by its parameter list.
Power has two parameters (base and exponent) which are of types int and unsigned int, respectively Note that the syntax for parameters is similar to the syntax for defining variables: type identifier followed by the parameter name.
However, it is not possible to follow a type identifier with multiple comma-separated parameters:.
This line is a local variable definition.
This brace marks the end of the function body.
Listing 4_0_9 illustrates how this function is called.
The effect of this call is that first the argument values 2 and 8 are, respectively, assigned to the parameters base and exponent, and then the function body is evaluated.
Copyright © 2005 PragSoft In general, a function should be declared before its is used.
A function declaration simply consists of the function prototype, which specifies the function name, parameter types, and return type.
Line 2 in Listing 4_0_10 shows how may be declared for the above program.
Although a function may be declared without its parameter names, int  (int, unsigned int); this is not recommended unless the role of the parameters is obvious_0_.
Listing 4_0_10 1 # <iostream_0_h> 2 int  (int base, unsigned int exponent); // function declaration 3 4 5 6.
Because a function definition contains a prototype, it also serves as a declaration.
Therefore if the definition of a function appears before its use, no additional declaration is needed.
Use of function prototypes is nevertheless encouraged for all circumstances.
Collecting these in a separate header file enables other programmers to quickly access the functions without having to read their entire definitions.
A value parameter receives a copy of the value of the argument passed to it.
As a , if the function makes any changes to the parameter, this will not affect the argument.
As far as this function is concerned,  behaves just like a local variable inside the function.
When the function is called and  passed to it,  receives a copy of the value of.
As a , although  is set to 0 by the function, this does not affect.
The program produces the following output: = 0; = 10; A reference parameter, on the other hand, receives the argument passed to it and works on it directly.
Any changes made by the function to a reference parameter is in effect directly applied to the argument.
Reference parameters will be further discussed in Chapter 5.
Within the context of function calls, the two styles of passing arguments are, respectively, called pass-by-value and pass-by-reference.
It is perfectly valid for a function to use pass-by-value for some of its parameters and pass-by-reference for others.
Copyright © 2005 PragSoft Global and Local Scope Everything defined at the program scope level (_0_e_0_, outside functions and classes) is said to have a global scope.
Thus the sample functions we have seen so far all have a global scope.
Variables may also be defined at the global scope: int  = 1994;.
Uninitialized global variables are automatically initialized to zero.
Since global entities are visible at the program level, they must also be unique at the program level.
This means that the same global variable or function may not be defined more than once at the global level.
Each block in a program defines a local scope.
Thus the body of a function represents a local scope.
The parameters of a function have the same scope as the function body.
Variables defined within a local scope are visible to that scope only.
Hence, a variable need only be unique within its own scope.
Local scopes may be nested, in which case the inner scopes override the outer scopes.
For example, in int xyz;.
Generally, the lifetime of a variable is limited to its scope.
So, for example, global variables last for the duration of program execution, while local variables are created when their scope is entered and destroyed when their scope is exited.
The memory space for global variables is reserved prior to program execution commencing, whereas the memory space for local variables is allocated on the fly during program execution.
For example, in int error;.
This problem is overcome using the unary scope operator :: which takes a global entity as argument: int ;.
Copyright © 2005 PragSoft Auto Variables Because the lifetime of a local variable is limited and is determined automatically, these variables are also called automatic.
The storage class specifier auto may be used to explicitly specify a local variable to be automatic.
When the program code refers to a variable (e_0_g_0_, in an expression), the compiler generates machine code which accesses the memory location denoted by the variable.
For frequently-used variables (e_0_g_0_, loop variables), efficiency gains can be obtained by keeping the variable in a register instead thereby avoiding memory access for that variable.
The storage class specifier register may be used to indicate to the compiler that the variable should be stored in a register if possible.
For example: += ; Here, each time round the loop,  is used three times: once when it is compared to n, once when it is added to , and once when it is incremented.
Therefore it makes sense to keep  in a register for the duration of the loop.
Note that register is only a hint to the compiler, and in some cases the compiler may choose not to use a register when it is asked to do so.
One reason for this is that any machine has a limited number of registers and it may be the case that they are all in use.
Even when the programmer does not use register declarations, many optimizing compilers try to make an intelligent guess and use registers where they are likely to improve the performance of the program.
Use of register declarations can be left as an after thought; they can always be added later by reviewing the code and inserting it in appropriate places.
Copyright © 2005 PragSoft Static Variables and Functions It is often useful to confine the accessibility of a global variable or function to a single file.
This is facilitated by the storage class specifier static.
For example, consider a puzzle game program which consists of three files for game generation, game solution, and user interface.
The game solution file would contain a Solve function and a number of other functions ancillary to Solve.
Because the latter are only for the private use of Solve, it is best not to make them accessible outside the file: static int FindNextRoute (void) // only accessible in this file.
A local variable in a function may also be defined as static.
The variable will remain only accessible within its local scope; however, its lifetime will no longer be confined to this scope, but will instead be global.
In other words, a static local variable is a global variable which is only accessible within its local scope.
Static local variables are useful when we want the value of a local variable to persist across the calls to the function in which it appears.
For example, consider an Error function which keeps a  of the errors and aborts the program when the exceeds a preset limit:.
Otherwise, the compiler may object to the variable as undefined.
This is facilitated by an extern declaration.
For example, the declaration.
This is called a variable declaration (not definition) because it does not lead to any storage being allocated for.
It is a poor programming practice to include an initializer for an extern variable, since this causes it to become a variable definition and have storage allocated for it:.
If there is another definition for  elsewhere in the program, it will eventually clash with this one.
Function prototypes may also be declared as extern, but this has no effect when a prototype appears at the global scope.
It is more useful for declaring function prototypes inside a function.
Copyright © 2005 PragSoft Symbolic Constants Preceding a variable definition by the keyword const makes that variable readonly (_0_e_0_, a symbolic constant).
A constant must be initialized to some value when it is defined.
For example: const int = 128;.
This is useful for declaring a set of closely-related constants.
For example, enum {, south, , west}; introduces four enumerators which have integral values starting from 0 (i_0_e_0_,.
The default numbering of enumerators can be overruled by explicit initialization: enum { = 10, south,  = 0, west}; Here, south is 11 and west is 1.
An enumeration can also be named, where the name becomes a user-defined type.
This is useful for defining variables which can only be assigned a limited set of values.
For example, in enum Direction {, south, , west};.
Enumerations are particularly useful for naming the cases of a switch statement.
Copyright © 2005 PragSoft Runtime Stack Like many other modern programming languages, Cplus_plus function call execution is based on a runtime stack.
When a function is called, memory space is allocated on this stack for the function parameters, return value, and local variables, as well as a local stack area for expression evaluation.
The allocated space is called a stack frame.
When a function returns, the allocated stack frame is released so that it can be reused.
For example, consider a situation where main calls a function called Solve which in turn calls another function called Normalize: {.
Figure 4_0_5 Function call stack frames.
For most functions, this overhead is negligible compared to the actual computation the function performs.
For a value denoted by n, this may be expressed as: However, instead of replicating this expression in many places in the program, it is better to define it as a function:.
The function version has a number of advantages.
First, it leads to a more readable program.
Second, it is reusable.
And third, it avoid undesirable sideeffects when the argument is itself an expression with side-effects.
The disadvantage of the function version, however, is that its frequent use can lead to a considerable performance penalty due to the overheads associated with calling a function.
For example, if Abs is used within a loop which is iterated thousands of times, then it will have an impact on performance.
The overhead can be avoided by defining Abs as an inline function:.
The effect of this is that when Abs is called, the compiler, instead of generating code to call Abs, expands and substitutes the body of Abs in place of the call.
While essentially the same computation is performed, no function call is involved and hence no stack frame is allocated.
Because calls to an inline function are expanded, no trace of the function itself will be left in the compiled code.
Therefore, if a function is defined inline in one file, it may not be available to other files.
Consequently, inline functions are commonly placed in header files so that they can be shared.
Like the register keyword, inline is a hint which the compiler is not obliged to observe.
Generally, the use of inline should be restricted to simple, frequently used functions.
A function which contains anything more than a couple of statements is unlikely to be a good candidate.
Use of inline for excessively long and complex functions is almost certainly ignored by the compiler.
Copyright © 2005 PragSoft Recursion A function which calls itself is said to be recursive.
Recursion is a general programming technique applicable to problems which can be defined in terms of themselves.
Take the factorial problem, for instance, which is defined as:.
Factorial of a positive number  is  times the factorial of -1.
The second line clearly indicates that factorial is defined in terms of itself and hence can be expressed as a recursive function:.
For  set to 3, Table 4_0_11 provides a trace of the calls to Factorial.
The stack frames for these calls appear sequentially on the runtime stack, one after the other.
Table 4_0_11 Factorial(3) execution trace.
Call == 0 First 3 0 Second 2 0 Third 1 0 Fourth 0 1.
Returns 6 2 1 1 A recursive function must have at least one termination condition which can be satisfied.
Otherwise, the function will call itself indefinitely until the runtime stack overflows.
The Factorial function, for example, has the termination condition  == 0 which, when satisfied, causes the recursive calls to fold back.
As a general rule, all recursive functions can be rewritten using iteration.
In situations where the number of stack frames involved may be quite large, the iterative version is preferred.
In other cases, the elegance and simplicity of the recursive version may give it the edge.
For factorial, for example, a very large argument will lead to as many stack frames.
An iterative version is therefore preferred in this case:.
For example, consider a function for reporting errors: void Error (char *message, int  = 0);.
As the first call illustrates, a default argument may be overridden by explicitly specifying an argument.
Default arguments are suitable for situations where certain (or all) function parameters frequently take the same values.
In Error, for example,  0 errors are more common than others and therefore a good candidate for default argument.
A less appropriate use of default arguments would be: int Power (int base, unsigned int  = 1); Because 1 (or any other value) is unlikely to be a frequently-used one in this situation.
To avoid ambiguity, all default arguments must be trailing arguments.
The following declaration is therefore illegal:.
A default argument need not necessarily be a constant.
Arbitrary expressions can be used, so long as the variables used in the expression are available to the scope of the function definition (e_0_g_0_, global variables).
The accepted convention for default arguments is to specify them in function declarations, not function definitions.
Because function declarations appear in header files, this enables the user of a function to have control over the default arguments.
Thus different default arguments can be specified for different situations.
It is, however, illegal to specify two different default arguments for the same function in a file.
Copyright © 2005 PragSoft Variable Number of Arguments It is sometimes desirable, if not necessary, to have functions which take a variable number of arguments.
A simple example is a function which takes a set of menu options as arguments, displays the menu, and allows the user to choose one of the options.
To be general, the function should be able to accept any number of options as arguments.
This may be expressed as int Menu (char *option1 _0__0__0_); which states that Menu should be given one argument or more.
Menu can access its arguments using a set of macro definitions in the header file stdarg_0_h, as illustrated by Listing 4_0_11.
The relevant macros are highlighted in bold.
Listing 4_0_11 1 #include <iostream_0_h> 2 #include <stdarg_0_h> 3 4 5 6 7.
Args is initialized by calling va_start.
The second argument to va_start must be the last function parameter explicitly declared in the function header (i_0_e_0_, 1 here).
The second argument to va_arg must be the expected type of that argument (i_0_e_0_, * here).
For this technique to work, the last argument must be a 0, marking the end of the argument list.
Va_arg is called repeatedly until this 0 is reached.
The sample call will produce the following output: 1.
Open file 2.
Close file 3.
Revert to saved file 4.
Delete file 5.
Copyright © 2005 PragSoft Command Line Arguments When a program is executed under an operating system (such as DOS or UNIX), it can be passed zero or more arguments.
These arguments appear after the program executable name and are separated by blanks.
Because they appear on the same line as where operating system commands are issued, they are called command line arguments.
As an example, consider a program named sum which prints out the sum of a set of numbers provided to it as command line arguments.
Dialog 4_0_3 illustrates how two numbers are passed as arguments to sum ($ is the UNIX prompt).
Dialog 4_0_3 1 2 3 $ sum 10_0_4 12_0_5 22_0_9 $ Command line arguments are made available to a Cplus_plus program via the main.
The first parameter, argc, denotes the number of arguments passed to the program (including the name of the program itself).
The second parameter, argv, is an array of the string constants which represent the arguments.
For example, given the command line in Dialog 4_0_3, we have: argc is 3 argv[0] is.
Arrays, Pointers, and References This chapter introduces the array, pointer, and reference data types and illustrates their use for defining variables.
An array consists of a set of objects (called its elements), all of which are of the same type and are arranged contiguously in memory.
In general, only the array itself has a symbolic name, not its elements.
Each element is identified by an index which denotes the position of the element in the array.
The number of elements in an array is called its dimension.
The dimension of an array is fixed and predetermined; it cannot be changed during program execution.
Arrays are suitable for representing composite data which consist of many similar, individual items.
Examples : a list of names, a table of world cities and their current temperatures, or the monthly transactions for a bank account.
A pointer is simply the address of an object in memory.
Generally, objects can be accessed in two ways: directly by their symbolic name, or indirectly through a pointer.
The act of getting to an object via a pointer to it, is called dereferencing the pointer.
Pointer variables are defined to point to objects of a specific type so that when the pointer is dereferenced, a typed object is obtained.
Pointers are useful for creating dynamic objects during program execution.
Unlike normal (global and local) objects which are allocated storage on the runtime stack, a dynamic object is allocated memory from a different storage area called the heap.
Dynamic objects do not obey the normal scope rules.
Their scope is explicitly controlled by the programmer.
A reference provides an alternative symbolic name (alias) for an object.
Accessing an object through a reference is exactly the same as accessing it through its original name.
References offer the power of pointers and the convenience of direct access to objects.
They are used to support the call-by-reference style of function parameters, especially when large objects are being passed to functions.
For example, an array representing 10 height measurements (each being an integer quantity) may be defined as: int [10]; The individual elements of the array are accessed by indexing the array.
The first array element always has the index 0.
Therefore, [0] and [9] denote, respectively, the first and last element of.
Each of elements can be treated as an integer variable.
So, for example, to set the third element to 177, we may write: [2] = 177; Attempting to access a nonexistent array element (e_0_g_0_, [-1] or [10]) leads to a serious runtime error (called 'index out of bounds' error).
Processing of an array usually involves a loop which goes through the array element by element.
Listing 5_0_13 illustrates this using a function which takes an array of integers and returns the average of its elements.
Listing 5_0_13 1 const int  = 3; 2 3 4 5 6 7 8.
When a complete initializer is used, the array dimension becomes redundant, because the number of elements is implicit in the initializer.
The first definition of.
Another situation in which the dimension can be omitted is for an array function parameter.
For example, the Average function above can be improved by rewriting it so that the dimension of  is not fixed to a constant, but specified by an additional parameter.
Listing 5_0_14 illustrates this.
Listing 5_0_14 2 { 3 double  = 0; 4 5 6 7.
It is easy to calculate the dimension of an array using the sizeof operator.
For example, given an array ar whose element type is Type, the dimension of ar is: ¨.
The organization of the array in memory is still the same (a contiguous sequence of elements), but the programmer's perceived organization of the elements is different.
For example, suppose we wish to represent the  seasonal temperature for three major Australian capital cities (see Table 5_0_12).
Table 5_0_12 Average seasonal temperature.
Spring 26 24 28 Sydney Melbourne Brisbane Summer 34 32 38 Autumn 22 19 25 Winter 17 13 20 This may be represented by a two-dimensional array of integers: int seasonTemp[3][4]; The organization of this array in memory is as 12 consecutive integer elements.
The programmer, however, can imagine it as three rows of four integer entries each (see Figure 5_0_6).
Figure 5_0_6 Organization of seasonTemp in memory.
Third row As before, elements are accessed by indexing the array.
A separate index is needed for each dimension.
For example, Sydney's  summer temperature (first row, second column) is given by [0][1].
The array may be initialized using a nested initializer:.
For example, it makes it possible to initialize only the first element of each row and have the rest default to zero: 68 Cplus_plus Essentials.
Processing a multidimensional array is similar to a one-dimensional array, but uses nested loops instead of a single loop.
Listing 5_0_15 illustrates this by showing a function for finding the highest temperature in.
Listing 5_0_15 1 const int rows 2 const int columns 3 4 5 6 7 8 9 10 11 12 13 14 15 16.
A pointer variable is defined to 'point to' data of a specific type.
For example: int char.
The symbol & is the address operator; it takes a variable as argument and returns the memory address of that variable.
The effect of the above assignment is that the address of num is assigned to 1.
Therefore, we say that 1 points to num.
Figure 5_0_7 illustrates this diagrammatically.
Figure 5_0_7 A simple integer pointer.
The symbol * is the dereference operator; it takes a pointer as argument and returns the contents of the location to which it points.
In general, the type of a pointer must match the type of the data it is set to point to.
A pointer of type void*, however, will match any type.
This is useful for defining pointers which may point to data of different types, or whose type is originally unknown.
A pointer may be cast (type converted) to another type.
For example, 2 = (char*) 1; converts 1 to char pointer before assigning it to 2.
Regardless of its type, a pointer may be assigned the value 0 (called the null pointer).
The null pointer is used for initializing pointers, and for marking the end of pointer-based data structures (e_0_g_0_, linked lists).
Copyright © 2005 PragSoft Dynamic Memory In addition to the program stack (which is used for storing global variables and stack frames for function calls), another memory area, called the heap, is provided.
The heap is used for dynamically allocating memory blocks during program execution.
As a result, it is also called dynamic memory.
Similarly, the program stack is also called static memory.
Two operators are used for allocating and deallocating memory blocks on the heap.
The new  takes a type as argument and allocated a memory block for an object of that type.
It returns a pointer to the allocated block.
For example, * = new ; * = new [10]; allocate, respectively, a block for storing a single integer and a block large enough for storing an array of 10 characters.
Memory allocated from the heap does not obey the same scope rules as normal variables.
The latter remains allocated until explicitly released by the programmer.
The delete  is used for releasing memory blocks allocated by.
It takes a pointer as argument and releases the memory block to which it points.
Note that when the block to be deleted is an array, an additional [] should be included to indicate this.
The significance of this will be explained later when we discuss classes.
Should delete be applied to a pointer which points to anything but a dynamically-allocated object (e_0_g_0_, a variable on the stack), a serious runtime error may occur.
It is harmless to apply delete to the 0 pointer.
Dynamic objects are useful for creating data which last beyond the function call which creates them.
Listing 5_0_16 illustrates this using a function which takes a string parameter and returns a copy of the string.
Because the null character is not included in the count, we add 1 to the total and allocate an array of characters of that size.
Because of the limited memory resources, there is always the possibility that dynamic memory may  exhausted during program execution, especially when many large blocks are allocated and none released.
Should   unable to allocate a block of the requested size, it will return 0 instead.
It is the responsibility of the programmer to deal with such possibilities.
The exception handling mechanism of Cplus_plus (explained in Chapter 10) provides a practical method of dealing with such problems.
Copyright © 2005 PragSoft Pointer Arithmetic In Cplus_plus one can add an integer quantity to or subtract an integer quantity from a pointer.
This is frequently used by programmers and is called pointer arithmetic.
Pointer arithmetic is not the same as integer arithmetic, because the outcome depends on the size of the object pointed to.
For example, suppose that an  is represented by 4 bytes.
Figure 5_0_8 illustrates this diagrammatically.
Figure 5_0_8 Pointer arithmetic.
Similarly, the elements of  can  referred to as *, *( + 1), *( + 2), and *( + 3).
Another form of pointer arithmetic allowed in Cplus_plus involves subtracting two.
Pointer arithmetic is very handy when processing the elements of an array.
Listing 5_0_17 shows as an example a string copying function similar to strcpy.
This condition becomes 0 when the final null character of src is copied to dest.
In turns out that an array variable (such as ) is itself the address of the first element of the array it represents.
Hence the elements of  can also referred to using pointer arithmetic on , that is, [i] is equivalent to *( + i).
The difference between  and  is that  is a constant, so it cannot  made to point to anything else, whereas  is a variable and can made to point to any other integer.
Listing 5_0_18 shows how the HighestTemp function (shown earlier in Listing 5_0_15) can  improved using pointer arithmetic.
Listing 5_0_18 2 { 3 int  = 0; 4 5 6 7 8 9.
In this way, the function is not restricted to a specific array size.
HighestTemp can  simplified even further by treating temp as a onedimensional array of row * column integers.
This is shown in Listing 5_0_19.
Listing 5_0_19 2 { 3 int  = 0; 4 5 6 7 8.
Copyright © 2005 PragSoft Function Pointers It is possible to take the address of a function and store it in a function pointer.
The pointer can then be used to indirectly call the function.
For example, int (*)(const char*, const char*); defines a function pointer named  which can hold the address of any function that takes two constant character pointers as arguments and returns an integer.
The string comparison library function strcmp, for example, is such.
A common use of a function pointer is to pass it as an argument to another function; typically because the latter requires different versions of the former in different circumstances.
A good example is a binary search function for searching through a sorted array of strings.
This function may use a comparison function (such as strcmp) for comparing the search string against the array strings.
For example, strcmp is case-sensitive.
If we wanted to do the search in a non-case-sensitive manner then a different comparison function would be needed.
As shown in Listing 5_0_20, by making the comparison function a parameter of the search function, we can make the latter independent of the former.
The search list is denoted by table which is an array of strings of dimension n.
The search item is denoted by item.
This is repeated until the two ends of the search span (denoted by  and ) collide, or until a match is found.
The following example shows how BinSearch may be called with passed as the comparison function: *[] = {"Boston", "London", "Sydney", "Tokyo"};.
Copyright © 2005 PragSoft References A reference introduces an alias for an object.
The notation for defining references.
After this definition 1 and 2 both refer to the same object, as if they were the same variable.
It should be emphasized that a reference does not create a copy of an object, but merely a symbolic alias for it.
Hence, after 1 = 0_0_16; both 1 and 2 will denote the value 0_0_16.
The 1 in the first and the 1 in the third line are likely to be the same object (most compilers do constant optimization and allocate both 1's in the same memory location).
So although we expect  to be 3, it could turn out to be 4.
However, by forcing  to be a copy of 1, the compiler guarantees that the object denoted by will be different from both 1's.
The most common use of references is for function parameters.
Reference parameters facilitates the pass-by-reference style of arguments, as opposed to the pass-by-value style which we have used so far.
To observe the differences, consider the three swap functions in Listing 5_0_21.
Although Swap1 swaps  and , this has no effect on the arguments passed to the function, because Swap1 receives a copy of the arguments.
What happens to the copy does not affect the original.
By dereferencing the pointers, Swap2 gets to the original values and swaps them.
The parameters become aliases for the arguments passed to the function and therefore swap them as intended.
Swap3 has the added advantage that its call syntax is the same as Swap1 and involves no addressing or dereferencing.
The following main function illustrates the differences:.
When run, it will produce the following output: 10, 20 20, 10 10, 20 78.
Copyright © 2005 PragSoft Typedefs Typedef is a syntactic facility for introducing symbolic names for data types.
Just as a reference defines an alias for an object, a typedef defines an alias for a type.
Its main use is to simplify otherwise complicated type declarations as an aid to improved readability.
Here are a few examples:.
The effect of these definitions is that String becomes an alias for char*, Name becomes an alias for an array of 12 chars, and uint becomes an alias for unsigned int.
Therefore: String Name uint.
This makes BinSearch's signature arguably simpler.
The following table specifies the major contents of four brands of breakfast cereals.
Define a two-dimensional array to capture this data: Top Flake Cornabix Oatabix Ultrabran Fiber 12g 22g 28g 32g Sugar 25g 4g 5g 7g Fat 16g 8g 9g 2g Salt 0_0_4g 0_0_3g 0_0_5g 0_0_2g Write a function which outputs this table element by element.
Bubble sort involves repeated scans of the list, where during each scan adjacent items are compared and swapped if out of order.
A scan which involves no swapping indicates that the list is sorted.
Classes This chapter introduces the class construct of Cplus_plus for defining new  types.
A concrete representation of the objects of the.
A set of operations for manipulating the objects.
Added to these is the restriction that, other than the designated operations, no other operation should be able to manipulate the objects.
For this reason, we often say that the operations characterize the , that is, they decide what can and what cannot happen to the objects.
For the same reason, proper  types as such are often called abstract  types – abstract because the internal representation of the objects is hidden from operations that do not belong to the.
A class definition consists of two parts: header and body.
The class header specifies the class name and its base classes.
Two types of  are supported:.
Data  have the syntax of variable definitions and specify the representation of class objects.
Member functions have the syntax of function prototypes and specify the class operations, also called the class interface.
Class  fall under one of three different access permission categories:.
Protected  are only accessible by the class  and the of a derived class.
The  type defined by a class is used in exactly the same way as a built-in type.
Copyright © 2005 PragSoft A Simple Class Listing 6_0_22 shows the definition of a simple class for representing points in two dimensions.
Listing 6_0_22 1 class Point { 2 int xVal, yVal; 3 public: 4.
A class definition always begins with the keyword class, followed by the class name.
An open brace marks the beginning of the class body.
The default access permission for a class member is private.
Both xVal and yVal are therefore private.
Both have two integer parameters and a void return type.
The order in which the  and member functions of a class are presented is largely irrelevant.
The above class, for example, may be equivalently written as:.
Listing 6_0_23 shows the separate definition of SetPt and OffsetPt.
The function name should be preceded by the class name and a double-colon.
This identifies SetPt as being a member of Point.
The function interface must match its earlier interface definition within the class (i_0_e_0_, take two integer parameters and have the return type void).
Once a class is defined in this way, its name denotes a new  type, allowing us to define variables of that type.
Member functions are called using the dot notation: pt_0_SetPt(10,20) calls SetPt for the object pt, that is, pt is an implicit argument to SetPt.
By making  and  private  of the class, we have ensured that a user of the class cannot manipulate them directly:.
This will not compile.
At this stage, we should clearly distinguish between object and class.
A class denotes a type, of which there is only one.
An object is an element of a particular type (class), of which there may be many.
For example, Point pt1, pt2, pt3; defines three objects (pt1, pt2, and pt3) all of the same class (Point).
Furthermore, operations of a class are applied to objects of that class, but never the class itself.
A class is therefore a concept that has no concrete existence other than that reflected by its objects.
In the class Point, for example, both member functions are very short (only two statements).
Defining these to be inline improves the efficiency considerably.
A member function is defined to be inline by inserting the keyword inline before its definition.
This example shows how a set may be defined as a class.
For simplicity, we will restrict ourselves to sets of integers with a finite number of elements.
Listing 6_0_24 shows the Set class definition.
Listing 6_0_24 1 #include <iostream_0_h> 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 const.
AddElem adds a new  to the set.
If the  is already in the set then nothing happens.
Should this result in an overflow then the  is not inserted.
The parameter of this function is a reference to the destination set.
Two sets are equal if they contain exactly the same elements (the order of which is immaterial).
Copyright © 2005 PragSoft 12 Intersect compares two sets to produce a third set (denoted by its last parameter) whose elements are in both sets.
For example, the intersection of {2,5,3} and {7,5,2} is {2,5}.
For example, the union of {2,5,3} and {7,5,2} is {2,5,3,7}.
For example, a set containing the numbers 5, 2, and 10 is printed as {5,2,10}.
Only the first  entries in elems are considered to be valid elements.
The separate definition of the member functions of a class is sometimes referred to as the implementation of the class.
The implementation of the Set class is as follows.
When run, the program will produce the following output: 1 2 2 20 1 1 1.
This is supported by special member functions called constructors.
A constructor always has the same name as the class itself.
For example, class Point {.
Now we can define objects of type  and initialize them at once.
This is in fact compulsory for classes that contain constructors that require arguments:.
The Set class can be improved by using a constructor instead of EmptySet: class Set {.
This has the distinct advantage that the programmer need no longer remember to call EmptySet.
The constructor ensures that every set is initially empty.
The Set class can be further improved by giving the user control over the maximum size of a set.
To do this, we define elems as an integer pointer rather than an integer array.
The constructor can then be given an argument which specifies the desired size.
This means that maxCard will no longer be the same for all Set objects and therfore needs to become a data member itself: class Set { public: Set (const int size); //_0__0_.
It is important to note that an object' constructor is applied when the object is created.
This in turn depends on the object' scope.
For example, a global object is created as soon as program execution commences; an automatic object is created when its scope is entered; and a dynamic object is created when the new operator is applied to it.
A destructor always has the same name as the class itself, but is preceded with a ~ symbol.
Unlike constructors, a class may have at most one destructor.
A destructor never takes any arguments and has no explicit return type.
Destructors are generally useful for classes which have pointer data members which point to memory blocks allocated by the class itself.
In such cases it is important to release member-allocated memory before the object is destroyed.
A destructor can do just that.
For example, our revised version of Set uses a dynamically-allocated array for the  member.
This memory should be released by a destructor: class Set { public: //_0__0_.
When Foo is called, the constructor for  is invoked, allocating storage for and initializing its data members.
Next the rest of the body of Foo is executed.
Finally, before Foo returns, the destructor for  is invoked, deleting the storage occupied by _0_.
Hence, as far as storage allocation is concerned, behaves just like an automatic variable of a built-in type, which is created when its scope is entered and destroyed when its scope is left.
In general, an object' constructor is applied just before the object is destroyed.
This in turn depends on the object' scope.
For example, a global object is destroyed when program execution is completed; an automatic object is destroyed when its scope is left; and a dynamic object is destroyed when the delete operator is applied to it.
Copyright © 2005 PragSoft Friends Occasionally we may need to grant a function access to the nonpublic members of a class.
Such an access is obtained by declaring the function a friend of the class.
There are two possible reasons for requiring this access:.
It may be the only correct way of defining the function.
It may be necessary if the function is to be implemented efficiently.
Examples of the first case will be provided in Chapter 7, when we discuss overloaded input/output operators.
An example of the second case is discussed below.
Suppose that we have defined two variants of the Set class, one for sets of integers and one for sets of reals: class IntSet { public:.
Although this works, the overhead of calling AddElem for every member of the set may be unacceptable.
The implementation can be improved if we could gain access to the private members of both IntSet and RealSet.
This can be arranged by declaring SetToReal as a friend of RealSet.
Although a friend declaration appears inside a class, that does not make the function a member of that class.
In general, the position of a friend declaration in a class is irrelevant: whether it appears in the private, protected, or the public section, it has the same meaning.
Copyright © 2005 PragSoft Default Arguments As with global functions, a member function of a class may have default arguments.
The same rules apply: all default arguments should be trailing arguments, and the argument should be an expression consisting of objects defined within the scope in which the class appears.
For example, a constructor for the Point class may use default arguments to provide more variations of the way a Point object may be defined: class Point {.
Given this constructor, the following definitions are all valid: Point Point Point.
For example, in Point pt(10,20); pt_0_OffsetPt(2,2);.
Using this, OffsetPt can be rewritten as:.
Use of this in this particular example is redundant.
There are, however, programming cases where the use of the this pointer is essential.
We will see examples of such cases in Chapter 7, when discussing overloaded operators.
The this pointer can be used for referring to member functions in exactly the same way as it is used for data members.
It is important to bear in mind, however, that this is defined for use within member functions of a class only.
In particular, it is undefined for global functions (including global friend functions).
Copyright © 2005 PragSoft Scope Operator When calling a member function, we usually use an abbreviated syntax.
The full form uses the binary scope operator :: to indicate that OffsetPt is a member of Point.
In some situations, using the scope operator is essential.
For example, the case where the name of a class member is hidden by a local variable (e_0_g_0_, member function parameter) can be overcome using the scope operator: class  { public:.
The latter are referred to explicitly as :: and ::.
The first approach involves initializing the data members using assignments in the body of a constructor.
For example: class Image { public: Image.
For example: class Image { public: Image.
The effect of this declaration is that  is initialized to w and  is initialized to h.
The only difference between this approach and the previous one is that here members are initialized before the body of the constructor is executed.
A member initialization list may be used for initializing any data member of a class.
It is always placed between the constructor header and body.
A colon is used to separate it from the header.
It should consist of a comma-separated list of data members whose initial value appears within a pair of brackets.
Copyright © 2005 PragSoft Constant Members A class data member may defined as constant.
For example: class Image { const int.
As one would expect, no member function is allowed to assign to a constant data member.
A constant data member is not appropriate for defining the dimension of an array data member.
For example, in class Set { public: Set //_0__0_.
The reason for this being that maxCard is not bound to a value during compilation, but when the program is run and the constructor is invoked.
Member functions may also be defined as constant.
This is used to specify which member functions of a class may be invoked for a constant object.
For example, class Set { public: Bool void //_0__0_.
Set Member AddElem.
To do so, the keyword const is inserted after the function header, both inside the class and in the function definition.
A constant object can only be modified by the constant member functions of the class:.
Given that a constant member function is allowed to be invoked for constant objects, it would be illegal for it to attempt to modify any of the class data members.
Constructors and destructors need never be defined as constant members, since they have permission to operate on constant objects.
They are also exempted from the above rule and can assign to a data member of a constant object, unless the data member is itself a constant.
Copyright © 2005 PragSoft Static Members A data member of a class can be defined to be static.
This ensures that there will be exactly one copy of the member, shared by all objects of the class.
For example, consider a Window class which represents windows on a bitmap display: class Window { static Window.
Here, no matter how many objects of type  are defined, there will be only one instance of.
Like other static variables, a static data member is by default initialized to 0.
It can be initialized to an arbitrary value in the same scope where the member function definitions appear: *:: = &myWindow; The alternative is to make such variables global, but this is exactly what static members are intended to avoid; by including the variable in a class, we can ensure that it will be inaccessible to anything outside the class.
Member functions can also be defined to be static.
Semantically, a static member function is like a global function which is a friend of the class, but inaccessible outside the class.
It does not receive an implicit argument and hence cannot refer to this.
Static member functions are useful for defining call-back routines whose parameter lists are predetermined and outside the control of the programmer.
For example, the  class might use a call-back function for repainting exposed areas of the window:.
Because static members are shared and do not rely on the this pointer, they are best referred to using the class::member syntax.
For example,  and PaintProc would be referred to as :: and ::PaintProc.
Public static members can be referred to using this syntax by nonmember functions (e_0_g_0_, global functions).
It is possible to obtain and manipulate the address of a member function of a class in a similar fashion.
As before, the idea is to make a function more flexible by making it independent of another function.
The syntax for defining a pointer to a member function is slightly more complicated, since the class name must also be included in the function pointer type.
For example, typedef int (Table::*Compare)(const char*, const char*); defines a member function pointer type called Compare for a class called Table.
This type will match the address of any member function of Table which takes two constant character pointers and returns an int.
Compare may be used for passing a pointer to a Search member of Table: class Table { public: Table int Search int int private: int char.
The definition of Table includes two sample comparison member functions which can be passed to Search.
Search has to use a slightly complicated syntax for invoking the comparison function via comp:.
Copyright © 2005 PragSoft Note that comp can only be invoked via a Table object (the this pointer is used in this case).
None of the following attempts, though seemingly reasonable,.
The above class member pointer syntax applies to all members except for static.
Static members are essentially global entities whose scope has been limited to a class.
Pointers to static members use the conventional syntax of global entities.
In general, the same protection rules apply as before: to take the address of a class member (data or function) one should have access to it.
For example, a function which does not have access to the private members of a class cannot take the address of any of those members.
Copyright © 2005 PragSoft Class  Members A data member of a class may be of a user-defined type, that is, an object of another class.
For example, a Rectangle class may be defined using two Point data members which represent the -left and bottom-right corners of the rectangle: class Rectangle { public: Rectangle (int left, int , int right, int bottom);.
The constructor for Rectangle should also initialize the two object members of the class.
Assuming that Point has a constructor, this is done by including topLeft and botRight in the member initialization list of the constructor for Rectangle:.
If the constructor for Point takes no parameters, or if it has default arguments for all of its parameters, then the above member initialization list may be omitted.
Of course, the constructor is still implicitly called.
The order of initialization is always as follows.
First, the constructor for topLeft is invoked, followed by the constructor for botRight, and finally the constructor for Rectangle itself.
First the destructor for Rectangle (if any) is invoked, followed by the destructor for botRight, and finally for topLeft.
The reason that topLeft is initialized before botRight is not that it appears first in the member initialization list, but because it appears before botRight in the class itself.
Therefore, defining the constructor as follows would not change the initialization (or destruction) order:.
For example, a pentagon can be defined as an array of 5 points: [5]; This definition assumes that  has an 'argument-less' constructor (i_0_e_0_, one which can be invoked without arguments).
The constructor is applied to each element of the array.
The array can also be initialized using a normal array initializer.
Each entry in the initialization list would invoke the constructor with the desired arguments.
When the initializer has less entries than the array dimension, the remaining elements are initialized by the argument-less constructor.
When the constructor can be invoked with a single argument, it is sufficient to just specify the argument.
Unless the [] is included, delete will have no way of knowing that denotes an array of points and not just a single point.
The destructor (if any) is applied to the elements of the array in reverse order before the array is deleted.
Omitting the [] will cause the destructor to be applied to just the first element of the array: delete ;.
Since the objects of a dynamic array cannot be explicitly initialized at the time of creation, the class must have an argument-less constructor to handle the implicit initialization.
When this implicit initialization is insufficient, the programmer can explicitly reinitialize any of the elements later:.
For example, a general polygon class has no way of knowing in advance how many vertices a polygon may have: class Polygon { public: //_0__0_.
All the class members belong to the class scope and thus hide entities with identical names in the enclosing scope.
At the global scope.
This leads to a global class, whereby it can be referred to by all other scopes.
The great majority of Cplus_plus classes (including all the examples presented so far in this chapter) are defined at the global scope.
At the class scope of another class.
This leads to a nested class, where a class is contained by another class.
At the local scope of a block or function.
This leads to a local class, where the class is completely contained by a block or function.
A nested class is useful when a class is used only by one other class.
Copyright © 2005 PragSoft defines  as nested by Rectangle.
The member functions of  may be defined either inline inside the  class or at the global scope.
The latter would require further qualification of the member function names by preceding them with Rectangle::.
A local class must be completely defined inside the scope in which it appears.
All of its functions members, therefore, need to be defined inline inside the class.
This implies that a local scope is not suitable for defining anything but very simple classes.
For example, struct  {.
The struct construct originated in C, where it could only contain data members.
It has been retained mainly for backward compatibility reasons.
In C, a structure can have an initializer with a syntax similar to that of an array.
Cplus_plus allows such initializers for structures and classes all of whose data members are public: class  { public: char.
The initializer consists of values which are assigned to the data members of the structure (or class) in the order they appear.
This style of initialization is largely superseded by constructors.
Furthermore, it cannot be used with a class that has a constructor.
A union is a class all of whose data members are mapped to the same address within its object (rather than sequentially as is the case in a class).
The size of an object of a union is, therefore, the size of its largest data member.
The main use of unions is for situations where an object may assume values of different types, but only one at a time.
For example, consider an interpreter for a simple programming language, called P, which supports a number of data types such as: integers, reals, strings, and lists.
A value in this language may be defined to be of the type: 110 Cplus_plus Essentials Copyright © 2005 PragSoft union Value long double char Pair.
Assuming that a long is 4 bytes, a double 8 bytes, and a pointer 4 bytes, an object of type Value would be exactly 8 bytes, i_0_e_0_, the same as the size of a double or a Pair object (the latter being equal to two pointers).
An object in P can be represented by the class, class Object {.
For example, when type is set to strObj, val_0_string is used for referring to its value.
Because of the unique way in which its data members are mapped to memory, a union may not have a static data member or a data member which requires a constructor.
Like a structure, all of the members of a union are by default public.
The keywords private, public, and protected may be used inside a struct or a union in exactly the same way they are used inside a class for defining private, public, and protected members.
For example, in data communication, data is transferred in discrete units called packets.
In addition to the user data that it carries, each packet also contains a header which is comprised of network-related information for managing the transmission of the packet across the network.
To minimize the cost of transmission, it is desirable to minimize the space taken by the header.
Figure 6_0_9 illustrates how the header fields are packed into adjacent bits to achieve this.
Figure 6_0_9 Header fields of a packet.
Because a bit field does not necessarily start on a byte boundary, it is illegal to take its address.
For the same reason, a bit field cannot be defined as static.
Use of enumerations can make working with bit fields easier.
For example, given the enumerations enum PacketType {dataPack, controlPack, supervisoryPack}; enum Bool.
Copyright © 2005 PragSoft Exercises 6_0_31 Explain why the Set parameters of the Set member functions are declared as references.
A complex number has the general form a + ib, where a is the real part and b is the imaginary part (i stands for imaginary).
Complex arithmetic rules are as follows: = =.
Use a nested class, Option, to represent the set elements.
Define a constructor, a destructor, and the following member functions for Menu:.
Insert which inserts a new  at a given position.
Provide a default argument so that the item is appended to the end.
Delete which deletes an existing.
Use a nested class, Element, to represent the set elements.
Define a constructor, a destructor, and the following member functions for Sequence:.
Insert which inserts a new  into its sort position.
Find which searches the sequence for a given  and returns true if it finds it, and false otherwise.
Define class named BinTree for storing sorted strings as a binary tree.
Define the same set of member functions as for Sequence from the previous exercise.
Use this function to define a constructor for BinTree which takes a sequence as argument.
Define an inline member function which returns the ID.
How will you keep track of the last allocated ID.
Overloading This chapter discusses the overloading of functions and operators in Cplus_plus.
The term overloading means 'providing multiple definitions of'.
Overloading of functions involves defining distinct functions which share the same name, each of which has a unique signature.
Function overloading is appropriate for:.
Defining functions which essentially do the same thing, but operate on different data types.
Providing alternate interfaces to the same function.
Function overloading is purely a programming convenience.
Operators are similar to functions in that they take operands (arguments) and return a value.
Most of the built-in Cplus_plus operators are already overloaded.
For example, the + operator can be used to add two integers, two reals, or two addresses.
Therefore, it has multiple definitions.
The built-in definitions of the operators are restricted to built-in types.
Additional definitions can be provided by the programmer, so that they can also operate on user-defined types.
Each additional definition is implemented by a function.
The overloading of operators will be illustrated using a number of simple classes.
We will discuss how  conversion rules can be used to reduce the need for multiple overloadings of the same operator.
We will present examples of for container classes, and the pointer operators.
We will also discuss memberwise initialization and assignment, and the importance of their correct implementation in classes which use dynamically-allocated data members.
Unlike functions and operators, classes cannot be overloaded; each class must have a unique name.
However, as we will see in Chapter 8, classes can be altered and extended through a facility called inheritance.
Also functions and classes can be written as templates, so that they become independent of the data types they employ.
We will discuss templates in Chapter 9.
Function Overloading Consider a function, GetTime, which returns in its parameter(s) the current time of the day, and suppose that we require two variants of this function: one which returns the time as seconds from midnight, and one which returns the time as hours, minutes, and seconds.
Given that these two functions serve the same purpose, there is no reason for them to have different names.
Cplus_plus allows functions to be overloaded, that is, the same function to have more than one definition:.
Copyright © 2005 PragSoft Operator Overloading Cplus_plus allows the programmer to define additional meanings for its predefined operators by overloading them.
For example, we can overload the + and operators for adding and subtracting  objects: class  { public:.
If λ is a binary operator:.
However, if λ is a unary operator: www_0_pragsoft_0_com.
Table 7_0_10 summarizes the Cplus_plus operators which can be overloaded.
The remaining five operators cannot be overloaded:.
Cplus_plus does not support the definition of new  tokens, because this can lead to ambiguity.
Furthermore, the precedence rules for the predefined operators is fixed and cannot be altered.
For example, no matter how you overload *, it will always have a higher precedence than +.
Equivalence rules do not hold for overloaded operators.
For example, overloading + does not  +=, unless the latter is also explicitly overloaded.
To avoid the copying of large objects when passing them to an overloaded , references should be used.
Pointers are not suitable for this purpose because an overloaded  cannot operate exclusively on pointers.
Copyright © 2005 PragSoft Example: Set The Set class was introduced in Chapter 6.
Most of the Set member functions are better defined as overloaded operators.
Listing 7_0_25 illustrates.
Listing 7_0_25 1 #include <iostream_0_h> 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 const.
Here, we have decided to define the  functions as global friends.
They could have just as easily been defined as member functions.
The implementation of these functions is as follow.
When run, the program will produce the following output: 1 2 20 1 1 1.
Copyright © 2005 PragSoft Type Conversion The normal built-in type conversion rules of the language also apply to functions and operators.
Any other type conversion required in addition to these must be explicitly defined by the programmer.
For example, suppose we want to overload + for the Point type so that it can be used to add two points, or to add an integer value to both coordinates of a point:.
To make + commutative, we have defined two functions for adding an integer to a point: one for when the integer is the first operand, and one for when the integer is the second operand.
It should be obvious that if we start considering other types in addition to int, this approach will ultimately lead to an unmanageable variations of the.
A better approach is to use a constructor to convert the object to the same type as the class itself so that one   can handle the job.
In this case, we need a constructor which takes an int, specifying both coordinates of a point: class  {.
The temporary object is then destroyed.
The overall effect is an implicit type conversion from int to.
The final value of  is therefore (15,25).
What if we want to do the opposite conversion, from the class type to another type.
In this case, constructors cannot be used because they always return an object of the class to which they belong.
Instead, one can define a member function which explicitly converts the object to the desired type.
For example, given a Rectangle class, we can define a type conversion function which converts a rectangle to a point, by overloading the type in Rectangle: class Rectangle {.
This  is defined to convert a rectangle to a point, whose coordinates represent the width and height of the rectangle.
Therefore, in the code fragment Rectangle.
The type conversion  can also be applied explicitly using the normal type cast notation.
A constructor defined for X which takes a single argument of type Y will implicitly convert Y objects to X objects when needed.
One of the disadvantages of user-defined type conversion methods is that, unless they are used sparingly, they can lead to programs whose behaviors can be very difficult to predict.
There is also the additional risk of creating ambiguity.
Ambiguity occurs when the compiler has more than one option open to it for applying user-defined type conversion rules, and therefore unable to choose.
All such cases are reported as errors by the compiler.
To illustrate possible ambiguities that can occur, suppose that we also define a type conversion constructor for Rectangle (which takes a  argument) as well as overloading the + and - operators: class Rectangle {.
Listing 7_0_26 1 #include <iostream_0_h> 2 #include <string_0_h> 3 4 5 6 7 8 9 10 11 12 13.
Addition is done bit by bit.
For simplicity, no attempt is made to detect overflows.
The implementation of these functions is as follows: {.
The first of these converts 5 to , does the addition, and then converts the  result to int, before sending it to.
This is equivalent to: << (int) ::operator+(2,(5)) << '\';.
The output produced by the program is evidence that the conversions are performed correctly: 0000000000001011 0000000000011010 0000000000100101 16 6 ¨ 126.
Copyright © 2005 PragSoft Overloading << for Output The simple and uniform treatment of output for built-in types is easily extended to user-defined types by further overloading the <<.
For any given userdefined type T, we can define an << function which outputs objects of type T: ostream&  << (ostream&, T&); The first parameter must be a reference to ostream so that multiple uses of << can be concatenated.
The second parameter need not be a reference, but this is more efficient for large objects.
For example, instead of the  class's Print member function, we can overload the <<  for the class.
Because the first operand of << must be an ostream object, it cannot be overloaded as a member function.
It should therefore be defined as a global function:.
Without the use of overloaded <<, the last example would have to be written as (assuming that \ has been removed from Print):.
For any given user-defined type T, we can define an >> function which inputs objects of type T: istream&  >> (istream&, T&); The first parameter must be a reference to istream so that multiple uses of >> can be concatenated.
The second parameter must be a reference, since it will be modified by the function.
Continuing with the  class example, we overload the >>  for the input of bit streams.
Again, because the first operand of >> must be an istream object, it cannot be overloaded as a member function:.
Copyright © 2005 PragSoft Overloading [] Listing 7_0_27 defines a simple associative vector class.
An associative vector is a one-dimensional array in which elements can be looked up by their contents rather than their position in the array.
In AssocVec, each element has a string name (via which it can be looked up) and an associated integer.
Listing 7_0_27 1 #include <iostream_0_h> 2 #include <string_0_h> 3 4 5 6 7 8 9 10 11 12 13 14 15 class AssocVec { public:.
The function which overloads [] must have exactly one parameter.
Given a string index, it searches the vector for a match.
If a matching index is found then a reference to its associated value is returned.
Otherwise, a new  is created and a reference to this value is returned.
Each vector  consists of a string (denoted by index) and an integer value (denoted by value).
The implementation of the member functions is as follows:.
Note that, because ::[] must return a valid reference, a reference to a  static integer is returned when the vector is full or when new fails.
A reference expression is an lvalue and hence can appear on both sides of an assignment.
If a function returns a reference then a call to that function can be assigned to.
This is why the return type of ::operator[] is defined to be a reference.
Using  we can now create associative vectors that behave very much like normal vectors:.
Listing 7_0_28 defines a matrix class.
A matrix is a table of values (very similar to a two-dimensional array) whose size is denoted by the number of rows and columns in the table.
An example of a simple 2 x 3 matrix would be: 10 20 30 21 52 19 = The standard mathematical notation for referring to matrix elements uses brackets.
For example,  20 of  (_0_e_0_, in the first row and second column) is referred to as (1,2).
Matrix algebra provides a set of operations for manipulating matrices, which includes addition, subtraction, and multiplication.
Listing 7_0_28 1 #include <iostream_0_h> 2 3 4 5 6 7 8 9 10 class Matrix { public: 11 12 13 14 15 private: friend friend friend friend Matrix (const short rows, const short cols);.
The function which overloads () may have zero or more parameters.
It returns a reference to the specified 's.
Copyright © 2005 PragSoft Memberwise Initialization Consider the following definition of the overloaded +  for Matrix: { Matrix (p_0_, p_0_);.
This form of initialization is called memberwise initialization because the special constructor initializes the object member by member.
If the data members of the object being initialized are themselves objects of another class, then those are also memberwise initialized, etc.
As a result of the default memberwise initialization, the  data member of both objects will point to the same dynamically-allocated block.
Hence the destructor deletes the block pointed to by _0_, leaving the returned object's  data member pointing to an invalid block.
This ultimately leads to a runtime failure (typically a bus error).
Figure 7_0_11 illustrates.
Figure 7_0_11 pointers.
The danger of the default memberwise initialization of objects with A memberwise copy of  is made After  is destroyed Matrix Memberwise Copy of Dynamic Block Memberwise Copy of Invalid Block Memberwise initialization occurs in the following situations: www_0_pragsoft_0_com Chapter 7: Overloading.
When defining and initializing an object in a declaration statement that uses another object as its initializer, e_0_g_0_,   =  in Foo below.
When passing an object argument to a function (not applicable to a reference or pointer argument), e_0_g_0_,  in Foo below.
When returning an object value from a function (not applicable to a reference or pointer return value), e_0_g_0_, return  in Foo below.
The problems caused by the default memberwise initialization of other classes can be avoided by explicitly defining the constructor in charge of memberwise initialization.
For any given class X, the constructor always has the form: X::X (const X&);.
Copyright © 2005 PragSoft Memberwise Assignment Objects of  same class are assigned to one another by an internal overloading of =  which is automatically generated by  compiler.
For example, to handle  assignment in.
This is identical in its approach to memberwise initialization and is called memberwise assignment.
It suffers from exactly  same problems, which in turn can be overcome by explicitly overloading  =.
For example, for class,  following overloading  = would be appropriate: {.
As a result, they impose different memory requirements.
Small objects, in particular, are not efficiently handled by  default versions  new  delete.
Every block allocated by new  some overhead used for housekeeping purposes.
For large objects this is not significant, but for small objects  overhead may be even bigger than  block itself.
In addition, having too many small blocks can severely slow down subsequent allocation  deallocation.
The performance  a program that dynamically creates many small objects can be significantly improved by using a simpler memory management strategy for those objects.
The dynamic storage management operators new  delete can be overloaded for a class, in which case they override  global definition  these operators when used for objects  that class.
As an example, suppose we wish to overload new  delete for  Point class, so that Point objects are allocated from an array: # <stddef_0_h>.
New should always return a void*.
The parameter  new   size   block to be allocated (in bytes).
The corresponding argument is always automatically passed by compiler.
The first parameter  delete   block to be deleted.
The second parameter is optional    size   allocated block.
The corresponding arguments are automatically passed by  compiler.
Since ,   used are static they do not affect  size  a object (it is still two integers).
These are initialized as follows: :: *:: = new [];.
New takes  next available block from   returns its address.
Delete frees a block by inserting it in front   linked-list denoted by When  reaches ,    returns  first block in  linked-list, but fails (returns 0) when  linked-list is empty:.
Calling   any other type as argument will invoke global definition  ,  if  call occurs inside a member function.
The functions which overload   delete for a class are always assumed by  compiler to be static, which means that they will not have access to  this pointer  therefore  nonstatic class members.
This is because when these operators are invoked for an object   class,  object does not exist:  is invoked before  object is constructed,  delete is called after it has been destroyed.
This can be  to do some extra pointer processing,  is facilitated by overloading unary operators arrow_operator, *,  &.
For classes that do not overload arrow_operator, this  is always binary:  left operand is a pointer to a class object   right operand is a class member name.
When  left operand  arrow_operator is an object or reference  type  (but not pointer),  is expected to have overloaded arrow_operator as unary.
In this case, arrow_operator is first applied to  left operand to produce a result p.
If p is a pointer to a class Y then p is  as  left operand  binary arrow_operator   right operand is expected to be a member  Y.
Otherwise, p is  as  left operand  unary arrow_operator   whole procedure is repeated for class Y.
Consider  following classes that overload arrow_operator:.
In other words, A::operatorarrow_operator is applied to obj to give p, B::operatorarrow_operator is applied to p to give q,  since q is a pointer to ,  final result is q>xVal.
Unary operators *  & can also be overloaded so that  semantic correspondence between arrow_operator, *,  & is preserved.
As an example, consider a library system which represents a book record as a raw string of  following format: 138.
Copyright © 2005 PragSoft Each field starts  a field specifier (e_0_g_0_, %A specifies an author)  ends  a null character (_0_e_0_, \0).
The fields can appear in any order.
Also, some fields may be missing from a record, in which case a default value must be.
For efficiency reasons we may want to keep the data in this format but use the following structure whenever we need to access the fields of a record: struct Book short short.
To reduce the frequency of mappings from  to , we have  a simple  memory of 10 records.
The corresponding static members are initialized as follows: short short.
If the book is not in the , RawToBook loads the book at the current position in the : { * = ; return  + ; =  <.
The overloaded operators arrow_operator, *,  & are easily defined in terms of RawToBook:.
The identical definitions for arrow_operator  & should not be surprising since arrow_operator is unary in this context  semantically equivalent to &.
The following test case demonstrates that the operators behave as expected.
It sets up two book records and prints each using different operators.
It will produce the following output: Peters, Blue Earth, Phedra, Sydney, 0, 1981 F.
Jackson, Pregnancy, Miles, City_0_, 0, 1987 ¨ www_0_pragsoft_0_com.
To distinguish between the two, the postfix version is specified to take an extra integer argument.
For example, the prefix and postfix versions of plus_plus may be overloaded for the Binary class as follows: class Binary { //_0__0_.
Although we have chosen to define these as global friend functions, they can also be defined as member functions.
Both are easily defined in terms of the + operator defined earlier:.
It will produce the following output: 0000000000001100 0000000000011010 0000000000011011 The prefix and postfix versions of minus_minus may be overloaded in exactly the same way.
Copyright © 2005 PragSoft Exercises 7_0_40 Write overloaded versions of a Max function which compares two integers, two reals, or two strings, and returns the 'larger' one.
Overload the following two operators for the  class:.
For simplicity, assume that the first operand is always greater than the second operand.
In practice, sparse matrices of sizes up to 500 × 500 are not uncommon.
On a machine which uses a 64-bit representation for reals, storing such a matrix as an array would require 2 megabytes of storage.
Define a SparseMatrix class which uses a linked-list to record only nonzero elements,  overload the +, -,  * operators for it.
Also define an appropriate memberwise initialization constructor  memberwise assignment operator for the class.
Note that two versions of the constructor  = are required, one for initializing/assigning to a String using a char*,  one for memberwise initialization/assignment [] should index a string character using its position.
A bit vector is a vector with binary elements, that is, each element is either a 0 or a 1.
Small bit vectors are conveniently represented by unsigned integers.
For example, an unsigned char can represent a bit vector of 8 elements.
Larger bit vectors can be defined as arrays of such smaller bit vectors.
Complete the implementation of the Bitvec class, as defined below.
It should allow bit vectors of any size to be created  manipulated using the associated operators.
Derived Classes In practice, most classes are not entirely unique, but rather variations of existing ones.
Consider, for example, a class named RecFile which represents a file of records,  another class named SortedRecFile which represents a sorted file of records.
These two classes would have much in common.
For example, they would have similar member functions such as Insert, Delete,  Find, as well as similar data members.
In fact, SortedRecFile would be a specialized version of RecFile with the added property that its records are organized in sorted order.
Most of the member functions in both classes would therefore be identical, while a few which depend on the fact that file is sorted would be different.
For example, Find would be different in SortedRecFile because it can take advantage of the fact that the file is sorted to perform a binary search instead of the linear search performed by the Find member of RecFile.
Given the shared properties of these two classes, it would be tedious to have to define them independently.
Clearly this would lead to considerable duplication of code.
The code would not only take longer to write it would also be harder to maintain: a change to any of the shared properties would have to be consistently applied to both classes.
Object-oriented programming provides a facility called inheritance to address this problem.
Under inheritance, a  can inherit the properties of an existing.
Inheritance makes it possible to define a variation of a  without redefining the new  from scratch.
Shared properties are defined only once, and reused as often as desired.
In Cplus_plus, inheritance is supported by derived classes.
A derived  is like an ordinary , except that its definition is based on one or more existing classes, called base classes.
A derived  can share selected properties (function as well as data members) of its base classes, but makes no changes to the definition of any of its base classes.
A derived  can itself be the base  of another derived.
The inheritance relationship between the classes of a program is called a  hierarchy.
A derived  is also called a subclass, because it becomes a subordinate of the base  in the hierarchy.
Similarly, a base  may be called a superclass, because from it many other classes may be derived.
The two classes are defined in Listing 8_0_29 and support the creation of a directory of personal contacts.
Listing 8_0_29 1 #include <iostream_0_h> 2 #include <string_0_h> 3 4 5 6 7 8 9 10 11 Contact { public: 12 13 14 15 16 private: char char char }; 17 18 19 20 21 22 23 24 25.
Contact captures the details (i_0_e_0_, name, address, and telephone number) of a personal.
Copyright © 2005 PragSoft 22 Insert inserts a new  into the directory.
This will overwrite an existing (if any) with identical name.
If none exists then Lookup returns the index of the slot where such an entry should be inserted.
Lookup is defined as private because it is an auxiliary function used only by Insert, Delete, and Find.
The implementation of the member function and friends is as follows: :: (const  *,.
When run, it will produce the following output: Deleted Jack ¨ www_0_pragsoft_0_com.
SmartDir is best defined as a derivation of ContactDir, as illustrated by Listing 8_0_30.
Listing 8_0_30 1 class SmartDir : public ContactDir { 2 public: 3 SmartDir(const int max) : ContactDir(max) { = 0;} 4 * Recent (void); 5 * Find (const  *); 6 7 8 private:.
A colon separates the two.
Here, ContactDir is specified to be the base class from which SmartDir is derived.
The keyword public before ContactDir specifies that ContactDir is used as a public base class.
This  pointer is set to point to the  of the last looked-up entry.
Because ContactDir is a public base class of SmartDir, all the public members of ContactDir become public members of SmartDir.
This means that we can invoke a member function such as Insert on a SmartDir object and this 150 Cplus_plus Essentials Copyright © 2005 PragSoft will simply be a call to ContactDir::Insert.
Similarly, all the private members of ContactDir become private members of SmartDir.
In accordance with the principles of information hiding, the private members of ContactDir will not be accessible by SmartDir.
Therefore, SmartDir will be unable to access any of the data members of ContactDir as well as the private member function Lookup.
SmartDir redefines the Find member function.
This should not be confused with overloading.
There are two distinct definitions of this function: ContactDir::Find and SmartDir::Find (both of which have the same signature, though they can have different signatures if desired).
Invoking Find on a SmartDir object causes the latter to be invoked.
As illustrated by the definition of Find in SmartDir, the former can still be invoked using its full.
The following code fragment illustrates that SmartDir behaves the same as ContactDir, but also keeps track of the most recently looked-up entry: SmartDir.
An object of type SmartDir contains all the data members of ContactDir as well as any additional data members introduced by SmartDir.
Figure 8_0_12 illustrates the physical make up of a ContactDir and a SmartDir object.
Figure 8_0_12 Base and derived class objects.
ContactDir object SmartDir object.
Figure 8_0_13 illustrates the UML notation that we will be using in this book.
Each class is represented by a box which is labeled with the class name.
Inheritance between two classes is illustrated by a directed line drawn from the derived class to the base class.
A line with a diamond shape at one end depicts composition (i_0_e_0_, a class object is composed of one or more objects of another class).
The number of objects contained by another object is depicted by a label (e_0_g_0_, n).
Figure 8_0_13 A simple class hierarchy ContactDir n.
SmartDir Figure 8_0_13 is interpreted as follows.
A ContactDir is composed of zero or more  objects.
SmartDir is derived from ContactDir.
Copyright © 2005 PragSoft Constructors and Destructors A derived class may have constructors and a destructor.
Since a derived class may provide data members on top of those of its base class, the role of the constructor and destructor is to, respectively, initialize and destroy these additional members.
When an object of a derived class is created, the base class constructor is applied to it first, followed by the derived class constructor.
When the object is destroyed, the destructor of the derived class is applied first, followed by the base class destructor.
In other words, constructors are applied in order of derivation and destructors are applied in the reverse order.
For example, consider a class C derived from B which is in turn derived from A.
Figure 8_0_14 illustrates how an object  of type C is created and destroyed.
C::~C The constructor of a derived class whose base class constructor requires arguments should specify these in the definition of its constructor.
To do this, the derived class constructor explicitly invokes the base class constructor in its member initialization list.
For example, the SmartDir constructor passes its argument to the ContactDir constructor in this way: { /* _0__0_.
The idea is that private members should be completely hidden so that they cannot be tampered with by the class clients.
This restriction may prove too prohibitive for classes from which other classes are likely to be derived.
Denying the derived class access to the base class private members may convolute its implementation or even make it impractical to define.
The restriction can be relaxed by defining the base class private members as protected instead.
As far as the clients of a class are concerned, a protected member is the same as a private member: it cannot be accessed by the class clients.
However, a protected base class member can be accessed by any class derived from it.
For example, the private members of ContactDir can be made protected by substituting the keyword protected for private: class ContactDir { //_0__0_.
As a result, Lookup and the data members of ContactDir are now accessible to SmartDir.
The access keywords private, public, and protected can occur as many times as desired in a class definition.
Each access keyword specifies the access characteristics of the members following it until the next access keyword: class Foo { public: // public members_0__0_.
Copyright © 2005 PragSoft Private, Public, and Protected Base Classes A base class may be specified to be private, public, or protected.
Unless so specified, the base class is assumed to be private: class A { private:.
A A A A is is is is a a a a private base class of B private base class of C public base class of D protected base class of E The behavior of these is as follows (see Table 8_0_13 for a summary):.
All the members of a private base class become private members of the derived class.
So x, Fx, y, Fy, z, and Fz all become private members of B and C.
The members of a public base class keep their access characteristics in the derived class.
So, x and Fx becomes private members of D, y and Fy become public members of D, and z and Fz become protected members of D.
The private members of a protected base class become private members of the derived class.
Whereas, the public and protected members of a protected base class become protected members of the derived class.
So, x and Fx become private members of E, and y, Fy, z, and Fz become protected members of E.
Base class access inheritance rules.
Base Class Private Member Public Member Protected Member Private Derived private private private Public Derived private public protected Protected Derived private protected protected It is also possible to individually exempt a base class member from the access changes specified by a derived class, so that it retains its original access characteristics.
To do this, the exempted member is fully named in the derived class under its original access characteristic.
For example: class C : private A {.
The obvious advantage of this is that the search speed can be improved by using the binary search algorithm instead of linear search.
The actual search is performed by the Lookup member function.
Therefore we need to redefine this function in SortedDir so that it uses the binary search algorithm.
We can also redefine these so that they refer to SortedDir::Lookup instead.
If we follow this approach, the value of inheritance becomes rather questionable, because we would have practically redefined the whole class.
What we really want to do is to find a way of expressing this: Lookup should be tied to the type of the object which invokes it.
If the object is of type SortedDir then invoking Lookup (from anywhere, even from within the member functions of ContactDir) should mean SortedDir::Lookup.
Similarly, if the object is of type ContactDir then calling Lookup (from anywhere) should mean ContactDir::Lookup.
This can be achieved through the dynamic binding of Lookup: the decision as to which version of Lookup to call is made at runtime depending on the type of the object.
In Cplus_plus, dynamic binding is supported by virtual member functions.
A member function is declared as virtual by inserting the keyword virtual before its prototype in the base class.
Any member function, including constructors and destructors, can be declared as virtual.
Lookup should be declared as virtual in ContactDir: class ContactDir {.
Only nonstatic member functions can be declared as virtual.
A virtual function redefined in a derived class must have exactly the same prototype as the one in the base class.
Virtual functions can be overloaded like other member functions.
Listing 8_0_31 shows the definition of SortedDir as a derived class of ContactDir.
Copyright © 2005 PragSoft 1 2 3 4 5 6 class SortedDir : public ContactDir { public: SortedDir (const int max) : ContactDir(max) {} protected:.
The new  of Lookup is as follows:.
It will produce the following output: www_0_pragsoft_0_com.
Alternatively, a derived class may have multiple base classes.
This is referred to as multiple inheritance.
For example, suppose we have defined two classes for, respectively, representing lists of options and bitmapped windows: class OptionList {.
Under multiple inheritance, a derived class inherits all of the members of its base classes.
As before, each of the base classes may be private, public, or protected.
The same base member access principles apply.
Figure 8_0_15 illustrates the class hierarchy for Menu.
Figure 8_0_15 The Menu class hierarchy OptionList Window Menu Since the base classes of Menu have constructors that take arguments, the constructor for the derived class should invoke these in its member initialization list: 158 Cplus_plus Essentials.
The order in which the base class constructors are invoked is the same as the order in which they are specified in the derived class header (not the order in which they appear in the derived class constructor's member initialization list).
For Menu, for example, the constructor for OptionList is invoked before the constructor for Window, even if we change their order in the constructor:.
The destructors are applied in the reverse order: ~Menu, followed by ~Window, followed by ~OptionList.
The obvious implementation of a derived class object is to contain one object from each of its base classes.
Figure 8_0_16 illustrates the relationship between a Menu object and its base class objects.
Figure 8_0_16 Base and derived class objects.
OptionList object OptionList data members Window object Menu object Window data members OptionList data members Window data members Menu data members In general, a derived class may have any number of base classes, all of which.
For example, suppose that both OptionList and Window have a member function called Highlight for highlighting a specific part of either object type: class OptionList {.
The ambiguity is resolved by making the call explicit: m_0_Window::Highlight(0); Alternatively, we can define a Highlight member for Menu which in turn calls the.
Copyright © 2005 PragSoft Type Conversion For any derived class there is an implicit type conversion from the derived class to any of its public base classes.
This can be used for converting a derived class object to a base class object, be it a proper object, a reference, or a pointer: Menu Window Window Window.
Such conversions are safe because the derived class object always contains all of its base class objects.
The first assignment, for example, causes the Window component of menu to be assigned to.
By contrast, there is no implicit conversion from a base class to a derived class.
The reason being that such a conversion is potentially dangerous due to the fact that the derived class object may have data members not present in the base class object.
The extra data members will therefore end up with unpredictable values.
All such conversions must be explicitly cast to confirm the programmer's intention: Menu Menu.
For example, given class Menu : public OptionList, public Window {.
This can be represented as a table, as illustrated by Table 8_0_14.
Table 8_0_14 Message transmission time (in seconds).
Sydney Melbourne Perth Sydney 0_0_00 2_0_34 15_0_36 Melbourne 3_0_55 0_0_00 9_0_32 Perth 12_0_45 10_0_31 0_0_00 The row and column indices for this table are strings rather than integers, so the Matrix class (Chapter 7) will not be adequate for representing the table.
We need a way of mapping strings to indices.
This is already supported by the AssocVec class (Chapter 7).
As shown in Listing 8_0_32, Table1 can be defined as a derived class of Matrix and AssocVec.
Listing 8_0_32 1 class Table1 : Matrix, AssocVec { 2 public: 3 Table1 4 : Matrix(entries, entries), 5.
Copyright © 2005 PragSoft 1 2 3 4 5 6 7 8 9 10 11 12 13 class Table2 : Matrix public:.
The answer lies in the relationship of table to matrix and associative vector:.
A table is a form of matrix.
A table is not an associative vector, but rather uses an associative vector to manage the association of its row and column labels with positional indexes.
In general, an is-a relationship is best realized using inheritance, because it implies that the properties of one object are shared by another object.
On the other hand, a uses-a (or has-a) relationship is best realized using composition, because it implies that one object is contained by another object.
Table2 is therefore the preferred solution.
It is worth considering which of the two versions of table better lends itself to generalization.
One obvious generalization is to remove the restriction that the table should be square, and to allow the rows and columns to have different labels.
To do this, we need to provide two sets of indexes: one for rows and one for columns.
Hence we need two associative vectors.
It is arguably easier to expand Table2 to do this rather than modify Table1 (see Listing 8_0_34).
Figure 8_0_17 shows the class hierarchies for the three variations of table.
Figure 8_0_17 Matrix Variations of table.
For a derived class which also has class object data members, the order of object construction is as follows.
First the base class constructors are invoked in the order in which they appear in the derived class header.
Then the class object data members are initialized by their constructors being invoked in the same order in which they are declared in the class.
Finally, the derived class constructor is invoked.
As before, the derived class object is destroyed in the reverse order of construction.
Figure 8_0_18 illustrates this for a Table3 object.
Figure 8_0_18 Table3 object construction and destruction order.
Copyright © 2005 PragSoft Virtual Base Classes Recall the Menu class and suppose that its two base classes are also multiply derived: class OptionList : public Widget, List { /*_0__0__0_*/ }; class Window : public Widget, Port.
This is not desirable (because a menu is considered a single widget) and may lead to ambiguity.
For example, when applying a widget member function to a menu object, it is not clear as to which of the two widget objects it should be applied.
The problem is overcome by making Widget a virtual base class of OptionList and Window.
A base class is made virtual by placing the keyword virtual before its name in the derived class header: class OptionList : virtual public Widget, List class Window : virtual public Widget, Port.
This ensures that a Menu object will contain exactly one Widget object.
In other words, OptionList and Window will share the same Widget object.
An object of a class which is derived from a virtual base class does not directly contain the latter's object, but rather a pointer to it (see Figure 8_0_19b and 8_0_19c).
This enables multiple occurrences of a virtual class in a hierarchy to be collapsed into one (see Figure 8_0_19d).
If in a class hierarchy some instances of a base class X are declared as virtual and other instances as nonvirtual, then the derived class object will contain an X object for each nonvirtual instance of X, and a single X object for all virtual occurrences of X.
A virtual base class object is initialized, not necessarily by its immediate derived class, but by the derived class farthest down the class hierarchy.
This rule ensures that the virtual base class object is initialized only once.
For example, in a menu object, the widget object is initialized by the Menu constructor (which overrides the invocation of the Widget constructor by OptionList or Window): Menu::Menu (int n, Rect &bounds) :.
Figure 8_0_19 Nonvirtual and virtual base classes.
Widget data members.
OptionList data members OptionList data members (c) Window object with Widget as virtual Widget data members Widget data members Port data members Port data members Window data members Window data members Menu data members (d) Menu object with Widget as virtual List data members OptionList data members Widget data members Port data members Window data members Menu data members If in a class hierarchy a virtual base is declared with conflicting access characteristics (i_0_e_0_, any combination of private, protected, and public), then the most accessible will dominate.
For example, if Widget were declared a private base class of OptionList, and a public base class of Window, then it would still be a public base class of Menu.
Copyright © 2005 PragSoft Overloaded Operators Except for  assignment operator, a derived class inherits all  overloaded operators of its base classes.
An  overloaded by  derived class itself hides  overloading of  same  by  base classes (in exactly  same way member functions of a derived class hide member functions of base classes).
Memberwise initialization and assignment (see Chapter 7) extend to derived classes.
For any given class  derived from X, memberwise initialization is handled by an automatically-generated (or user-defined) constructor of  form: :: (const &); Similarly, memberwise assignment is handled by an automatically-generated (or user-defined) overloading of  = : Memberwise initialization (or assignment) of a derived class object involves memberwise initialization (or assignment) of its base classes as well as its class object members.
Special care is needed when a derived class relies on  overloading of new and delete operators for its base class.
For example, recall  overloading of these two operators for  Point class in Chapter 7, and suppose that we wish to use them for a derived class: class Point3D : public Point { public:.
Because  implementation of Point:: new  that requested block  be  size of a Point object, its inheritance by Point3D class leads to a problem: it fails to account for  extra space needed by data member of  latter (i_0_e_0_, depth).
To avoid this problem, an overloading of new  attempt to allocate exact amount of storage specified by its size parameter, rather than assuming a predefined size.
Similarly, an overloading of delete  note  size specified by its second parameter and attempt to release exactly those many bytes.
Because each day has a binary value, Year is easily derived from BitVec: enum Month { Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec }; class Year : public public: Year void WorkDay void OffDay Bool Working short Day protected: short.
Complete  Year class by implementing its member functions.
Derive a class named LinearEqns from Matrix and for this purpose and define following member functions for it:.
A constructor which accepts  as a matrix, and a destructor.
Generate which randomly generates a system of linear equations as a matrix M.
It  take a positive integer (coef) as argument and generate a set of equations, ensuring that  range of  coefficients does not exceed coef.
Use a random number generator (e_0_g_0_, random under UNIX) to generate coefficients.
To ensure that  is a solution for  equations denoted by M, last element of a row k is denoted by: M k , + 1 = ∑ M k , × =1.
Solve which uses Gaussian elimination to solve  equations generated by Generate.
Solve   output  of Matrix to display augmented matrix each time  elements below a pivot are eliminated.
In certain applications we may need to construct sets of such enumerations.
Copyright © 2005 PragSoft example, in a parser, each parsing routine may be passed a set of symbols that not be skipped when  parser attempts to recover from a syntax error.
Derive a class named EnumSet from BitVec to facilitate this.
EnumSet  overload the following operators: 8_0_49.
An abstract class is a class which is never used directly but provides a skeleton for other classes to be derived from it.
Typically, all the member functions of an abstract are virtual  have dummy implementations.
The following is a simple example of an abstract class: class Database { public: virtual void virtual void virtual Data }; Insert Delete Search.
First derive a B-tree class from Database  then derive a B*-tree from B-tree: class BTree : public Database { /*_0__0__0_*/ }; class BStar : public BTree { /*_0__0__0_*/ }; See Comer (1979) for a description of B-tree  B*-tree.
For the purpose of this exercise, use the built-in type int for Key  double for Data.
Templates This chapter describes the template facility of Cplus_plus for defining functions classes.
Templates facilitate the generic definition of functions  classes so that they are not tied to specific implementation types.
They are invaluable in that they dispense with the burden of redefining a function or class so that it will work with yet another data type.
A function template defines an algorithm.
An algorithm is a generic recipe for accomplishing a task, independent of the particular data types used for its implementation.
For example, the binary search algorithm operates on a sorted array of items, whose exact type is irrelevant to the algorithm.
Binary search can therefore be defined as a function template with a type parameter which denotes the type of the array items.
This template then becomes a blueprint for generating executable functions by substituting a concrete type for the type parameter.
This process is called instantiation  its outcome is a conventional function.
A class template defines a parameterized type.
A parameterized type is a data type defined in terms of other data types, one or more of which are unspecified.
Most data types can be defined independently of the concrete data types used in their implementation.
For example, the stack data type involves a set of items whose exact type is irrelevant to the concept of stack.
Stack can therefore be defined as a class template with a type parameter which specifies the type of the items to be stored on the stack.
This template can then be instantiated, by substituting a concrete type for the type parameter, to generate executable stack classes.
Templates provide direct support for writing reusable code.
This in turn makes them an ideal tool for defining generic libraries.
We will present a few simple examples to illustrate how templates are defined, instantiated,  specialized.
We will describe the use of nontype parameters in class templates,  discuss the role of class members, friends,  derivations in the context of class templates.
Copyright © 2005 PragSoft Function Template Definition A function template definition (or declaration) is always preceded by a template clause, which consists of the keyword template  a list of one or more type parameters.
For example, template <class T> T Max (T, T); declares a function template named Max for returning the maximum of two objects.
T denotes an unspecified (generic) type.
Max is specified to compare two objects of the same type  return the larger of the two.
Both arguments  the return value are therefore of the same type T.
The definition of a function template is very similar to a normal function, except that the specified type parameters can be referred to within the definition.
The definition of Max is shown in Listing 9_0_35.
Listing 9_0_35 1 2 3 4 5 template <class T>.
A type parameter is an arbitrary identifier whose scope is limited to the function itself.
Type parameters always appear inside <>.
Each type parameter consists of the keyword class followed by the parameter name.
When multiple type parameters are used, they should be separated by commas.
Each specified type parameter must actually be referred to in the function prototype.
The keyword class cannot be factored out: template <class T1, class T2, class T3> T3 Relation(T1, T2); // ok.
For example, given the earlier template definition of , the code fragment.
In the second call, both arguments are reals, hence T is bound to double.
In the final call, both arguments are characters, hence T is bound to char.
A total of three functions are therefore generated by the compiler to handle these cases: int double char.
When the compiler encounters a call to a template function, it attempts to infer the concrete type to be substituted for each type parameter by examining the type of the arguments in the call.
The compiler does not attempt any implicit type conversions to ensure a match.
As a result, it cannot resolve the binding of the same type parameter to reasonable but unidentical types.
For example: (10, 12_0_6); would be considered an error because it requires the first argument to be converted to double so that both arguments can match T.
The same restriction even applies to the ordinary parameters of a function template.
For example, consider the alternative definition of  in Listing 9_0_36 for finding the maximum value in an array of.
The ordinary parameter n denotes the number of array elements.
A matching argument for this parameter must be of type int: unsigned  = 4;.
Copyright © 2005 PragSoft 1 2 3 4 5 6 7 8 9 template <class > { = vals[0];.
As illustrated by Listings 9_0_35 and 9_0_36, function templates can be overloaded in exactly the same way as normal functions.
The same rule applies: each overloaded definition must have a unique signature.
Both definitions of  assume that the > operator is defined for the type substituted in an instantiation.
When this is not the case, the compiler flags it as an error:.
Binary search is better defined as a function template so that it can be used for searching arrays of any type.
Listing 9_0_20 provides a template definition.
Listing 9_0_37 1 template <class Type> 3 { 4 int  = 0;.
It introduces Type as a type parameter, the scope for which is the entire definition of the BinSearch function.
Instantiating BinSearch with Type bound to a built-in type such as int has the desired effect.
For example, int [] = {10, 12, 30, 38, 52, 100}; << BinSearch(52, , 6) << '\n';.
Copyright © 2005 PragSoft Now let us instantiate BinSearch for a user-defined type such as RawBook (see Chapter 7).
First, we need to ensure that the comparison operators are defined for our user-defined type: class RawBook { public: //_0__0_.
The code fragment [] = { ("%APeters\0%TBlue.
For example, <class Type> class Stack; declares a class  named Stack.
A class  clause follows the same syntax rules as a function  clause.
The definition of a class  is very similar to a normal class, except that the specified type parameters can be referred to within the definition.
The definition of Stack is shown in Listing 9_0_38.
Listing 9_0_38 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 <class > class Stack {.
The member functions of Stack are defined inline except for Push.
The << is also overloaded to display the stack contents for testing purposes.
These two are defined as follows: <class > { stack[] = val;.
Except for within the class definition itself, a reference to a class  must include its  parameter list.
This is why the definition of Push and << use the name Stack<> instead of Stack.
For example, given the earlier  definition of , it is easy to generate stacks of a variety of types through instantiation: <int>.
The combination of a class  and arguments for all of its type parameters (e_0_g_0_, <int>) represents a valid type specifier.
If a class  is used as a part of the definition of another class (or function ), then the former' type parameters can be bound to the latter'  parameters.
For example: <class >.
Value parameters (of defined types) may also be used.
Listing 9_0_39 shows a variation of the  class, where the maximum size of the stack is denoted by a  parameter (rather than a data member).
Listing 9_0_39 1 2 3 4 5 6 7 8 9 10 11 12 template <class , int maxSize> class  { public: (void) : stack(new [maxSize]), (-1) {} {delete [] stack;} void Push ( &val); void Pop {if ( >= 0) minus_minustop;} &Top {return stack[];} private:.
For example, Push is now defined as follows: template <class , int maxSize> {.
The type of the value must match the type of value parameter exactly.
The value itself must be a constant expression which can be evaluated at compile-time.
For example: <int, 10> <int, 10u> <int, 5+5> int  = 10;.
Copyright © 2005 PragSoft Class  Specialization The algorithms defined by the member functions of a class template may be inappropriate for certain types.
For example, instantiating the  class with the type * may lead to problems because the Push function will simply push a string pointer onto the stack without copying it.
As a result, if the original string is destroyed the stack entry will be invalid.
Such cases can be properly handled by specializing the inappropriate member functions.
Like a global function template, a member function of a class template is specialized by providing an implementation of it based on a particular type.
Pop needs to be specialized as well: {.
Although the friend declaration of << is necessary, because this is a nonmember function, its earlier definition suffices.
The use of constant and reference members is exactly as before.
Static data members are shared by the objects of an instantiation.
There will therefore be an instance of each static data member per instantiation of the class template.
As an example, consider adding a static data member to the  class to enable Top to return a value when the stack is empty: template <class > class  { public: //_0__0_.
This is instantiated for each instantiation of.
Alternatively, an explicit instance of this initialization may be provided for each instantiation of.
A <int> instantiation, for example, could use the following initialization of : int <int>:: = 0; ¨.
Copyright © 2005 PragSoft Class  Friends When a function or class is declared as a friend of a class , the friendship can take one of there forms, as illustrated by the following example.
Consider the  class  and a function  named : <class T> void  (T&); We wish to define a class named Sample and declare  and  as its friends.
The following makes a specific instance of  and  friends of all instances of Sample: <class T>.
This means that, for example, <int> and <int> are friends of Sample<int>, but not Sample<double>.
The extreme case of making all instances of  and  friends of all instances of Sample is expressed as: <class T>.
A linked-list represents one of the simplest and most popular forms of container types.
It consists of a set of elements, each of which contains a pointer to the next element in the list.
In a doubly-linked list, each element also contains a pointer to the previous element in the list.
Figure 9_0_20 illustrates a doubly-linked list of integers.
Figure 9_0_20 A doubly-linked list of integers.
Last Because a container class can conceivably contain objects of any type, it is best defined as a class.
Listing 9_0_40 show the definition of doubly-linked lists as two class templates.
Listing 9_0_40 1 #include <iostream_0_h> 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31.
Value {return val;} ListElem* Prev {return ;} ListElem * Next {return ;} friend class <>;// one-to-one friendship.
Insert (const Type&);.
Member (const Type&); friend ostream&  <<(ostream&, &); protected:.
ListElem<Type> *; //  element in the list };.
It consists of a value whose type is denoted by the type parameter Type, and two pointers which point to the previous and  elements in the list.
Note that these two are declared of type <Type>* and not *, because the declaration is outside the  class.
Insert, Remove, and Element are all defined as virtual to allow a class derived from  to override them.
All of the member functions of  are defined inline.
The definition of member functions is as follows: <class Type>.
Copyright © 2005 PragSoft.
It will produce the following output: = < 10 20 30 > 20 is in Removed 20 < 10 30 > ¨ www_0_pragsoft_0_com.
As an example of a derived class , consider deriving a Set class from Given that a set consists of unique elements only (i_0_e_0_, no repetitions), all we need to do is override the Insert member function to ensure this (see Listing 9_0_24).
Listing 9_0_41 1 2 3 4 5 6 <class > class Set : public <> { public: virtual void {if (_0_Member(val)) <>::Insert(val);} };.
Copyright © 2005 PragSoft Exercises 9_0_50 Define a Swap function  for swapping two objects of the same type.
Provide a specialization of the function for strings.
Provide a specialization of the class for strings.
Exception Handling An exception is a run-time error.
Proper handling of exceptions is an important programming issue.
This is because exceptions can and do happen in practice and programs are generally expected to behave gracefully in face of such exceptions.
Unless an exception is properly handled, it is likely to result in abnormal program termination and potential loss of work.
For example, an undetected division by zero or dereferencing of an invalid pointer will almost certainly terminate the program abruptly.
Exception handling consists of three things: (i) the detecting of a run-time error, (ii) raising an exception in response to the error, and (ii) taking corrective action.
The latter is called recovery.
Some exceptions can be fully recovered from so that execution can proceed unaffected.
For example, an invalid argument value passed to a function may be handled by substituting a reasonable default value for it.
Other exceptions can only be partially handled.
For example, exhaustion of the heap memory can be handled by abandoning the current operation and returning to a state where other operations (such as saving the currently open files to avoid losing their contents) can be attempted.
Cplus_plus provides a language facility for the uniform handling of exceptions.
Under this scheme, a section of code whose execution may lead to run-time errors is labeled as a try block.
Any fragment of code activated during the execution of a try block can raise an exception using a throw clause.
All exceptions are typed (i_0_e_0_, each exception is denoted by an object of a specific type).
A try block is followed by one or more catch clauses.
Each catch clause is responsible for the handling of exceptions of a particular type.
When an exception is raised, its type is compared against the catch clauses following it.
If a matching clause is found then its handler is executed.
Otherwise, the exception is propagated up, to an immediately enclosing try block (if any).
The process is repeated until either the exception is handled by a matching catch clause or it is handled by a default handler.
Copyright © 2005 PragSoft Flow Control Figure 10_0_21 illustrates the flow of control during exception handling.
It shows a function e with a try block from which it calls f; f calls another function g from its own try block, which in turn calls h.
Each of the try blocks is followed by a  of catch clauses.
Function h throws an exception of type B.
The enclosing try block's catch clauses are examined (i_0_e_0_, A and E); neither matches B.
The exception is therefore propagated to the catch clauses of the enclosing try block (i_0_e_0_, C and D), which do not match B either.
Propagating the exception further up, the catch clauses following the try block in e (i_0_e_0_, A, B, and C) are examined next, resulting in a match.
At this point flow of control is transferred from where the exception was raised in h to the catch clause in e.
The intervening stack frames for h, g, and f are unwound: all automatic objects created by these functions are properly destroyed by implicit calls to their destructors.
Figure 10_0_21 Flow control in exception handling.
A E throw B Two points are worth noting.
First, once an exception is raised and handled by a matching catch clause, the flow of control is not returned to where the exception was raised.
The best that the program can do is to re-attempt the code that resulted in the exception (e_0_g_0_, call f again in the above example).
Second, the only role of a catch clause in life is to handle exceptions.
If no exception is raised during the execution of a try block, then the catch clauses following it are simply ignored.
An exception is raised by a throw clause, which has the general form throw object; where object is an object of a built-in or user-defined type.
Since an exception is matched by the type of object and not its value, it is customary to define classes for this exact purpose.
For example, recall the Stack class template discussed in Chapter 9 (see Listing 10_0_42).
Listing 10_0_42 1 2 3 4 5 6 7 8 9 10 11 12 13 14 template <class Type> class Stack { public: Stack (int max); {delete [] stack;} void Push (Type &val); void Pop (void); Type& Top (void); friend ostream&  << (ostream&, <Type>); private:.
The constructor parameter  may be given a nonsensical value.
Also, the constructor's attempt at dynamically allocating storage for  may fail due to heap exhaustion.
We raise exceptions BadSize and HeapFail in response to these: template <class > {.
We raise an Overflow exception in response to this: Cplus_plus Essentials Copyright © 2005 PragSoft template <class > {.
An attempt to pop from an empty  results in an underflow.
We raise an Underflow exception in response to this: template <class > {.
Attempting to examine the  element of an empty  is clearly an error.
We raise an Empty exception in response to this: template <class > {.
Suppose that we have defined a class named Error for exception handling purposes.
The above exceptions are easily defined as derivations of Error: class class class class class class Error BadSize HeapFail Overflow Underflow Empty : : : : : { /* public public public public public.
In other words, a try block is like a compound statement preceded by the try keyword.
A try block is followed by catch clauses for the exceptions which may be raised during the execution of the block.
The role of the catch clauses is to handle the respective exceptions.
A catch clause (also called a handler) has the general form { statements } where type is the type of the object raised by the matching exception, par is optional and is an identifier bound to the object raised by the exception, and statements represents zero or more semicolon-terminated statements.
For example, continuing with our  class, we may write:.
When an exception is raised by the code within the try block, the catch clauses are examined in the order they appear.
The first matching catch clause is selected and its statements are executed.
The remaining catch clauses are ignored.
A catch clause (of type C) matches an exception (of type E) if: 192.
Both are pointers and one can be converted to another by implicit type conversion rules.
Because of the way the catch clauses are evaluated, their order of appearance is significant.
Care should be taken to place the types which are likely to mask other types last.
For example, the clause type void* will match any pointer and should therefore appear after other pointer type clauses: try { //_0__0_.
The statements in a catch clause can also throw exceptions.
The case where the matched exception is to be propagated up can be signified by an empty throw:.
An exception which is not matched by any catch clause after a try block, is propagated up to an enclosing try block.
This process is continued until either the exception is matched or no more enclosing try block remains.
The latter causes the predefined function terminate to be called, which simply terminates the program.
This function has the following type: typedef void (*TermFun)(void);.
TermFun set_terminate(TermFun); Set_terminate returns the previous setting.
This enables function users to quickly determine the list of exceptions that their code will have to handle.
A function prototype may be appended with a throw list for this purpose: type function (parameters) throw (exceptions); where exceptions denotes a list of zero or more comma-separated exception types which function may directly or indirectly throw.
The list is also an assurance that function will not throw any other exceptions.
For example, throw (InvalidKey, BadFile, const char*); specifies that Encrypt may throw an InvalidKey, BadFile, or const char*.
It is generally expected to at least define throw lists for frequently-used functions.
Should a function throw an exception which is not specified in its throw list, the predefined function unexpected is called.
The default behavior of unexpected is to terminate the program.
This can be overridden by calling set_unexpected (which has the same signature as set_terminate) and passing the replacing function as its argument: TermFun set_unexpected(TermFun); As before, set_unexpected returns the previous setting.
Copyright © 2005 PragSoft Exercises 10_0_54 Consider the following function which is used for receiving a packet in a network system: {.
That connection c is active.
Connection::Active() will return true if this is the case.
That no errors have occurred in the transmission of the packet.
Packet::Valid() will return true if this is the case.
That the packet type is known (the default case is exercised otherwise).
Define suitable exceptions for the above and modify ReceivePacket so that it throws an appropriate exception when any of the above cases is not satisfied.
Also define a throw list for the function.
When the sizes of the operands of + and - are not identical.
When the number of the columns of the first operand of * does not match the number of rows of its second operand.
When heap storage is exhausted.
The IO Library Cplus_plus has no built-in Input/Output (IO) capability.
Instead, this capability is provided by a library.
The standard Cplus_plus IO library is called the iostream library.
The definition of the library classes is divided into three header files.
An additional header file defines a set of manipulators which act on streams.
These are summarized by Table 11_0_15.
Figure 11_0_22 relates these header files to a class hierarchy for a UNIX-based implementation of the iostream class hierarchy.
The highest-level classes appear unshaded.
A user of the iostream library typically works with these classes only.
Table 11_0_16 summarizes the role of these high-level classes.
The library also provides four predefined stream objects for the common use of programs.
These are summarized by Table 11_0_17.
Table 11_0_15 Iostream header files.
Header File iostream_0_h.
Table 11_0_16 Highest-level iostream classes.
Form of IO Standard IO File IO Array of char IO Table 11_0_17 196 Description Defines a hierarchy of classes for low-level (untyped characterlevel) IO and high-level (typed) IO.
This includes the definition of the ios, istream, ostream, and iostream classes.
Derives a set of classes from those defined in iostream_0_h for file IO.
This includes the definition of the ifstream, ofstream, and fstream classes.
Derives a set of classes from those defined in iostream_0_h for IO with respect to character arrays.
This includes the definition of the istrstream, ostrstream, and strstream classes.
Defines a set of manipulator which operate on streams to produce useful effects.
Input and Output istream ifstream istrstream ostream ofstream ostrstream iostream fstream strstream Predefined streams.
Stream Type cin cout clog cerr istream ostream ostream ostream Cplus_plus Essentials Buffered Yes Yes Yes No Description Copyright © 2005 PragSoft A stream may be used for input, output, or both.
The act of reading data from an input stream is called extraction.
It is performed using the >> operator (called the extraction operator) or an iostream member function.
Similarly, the act of writing data to an output stream is called insertion, and is performed using the << operator (called the insertion operator) or an iostream member function.
We therefore speak of 'extracting data from an input stream' and 'inserting data into an output stream'.
Figure 11_0_22 Iostream class hierarchy.
The upper layer deals with formatted IO of typed objects (built-in or user-defined).
The lower layer deals with unformatted IO of streams of characters, and is defined in terms of streambuf objects (see Figure 11_0_23).
All stream classes contain a pointer to a streambuf object or one derived from it.
Figure 11_0_23 Two-layer IO model.
Under normal circumstances, the user need not worry about or directly work with streambuf objects.
These are indirectly employed by streams.
However, a basic understanding of how a streambuf operates makes it easier to understand some of the operations of streams.
Think of a streambuf as a sequence of characters which can grow or shrink.
Depending on the type of the stream, one or two pointers are associated with this sequence (see Figure 11_0_24):.
A put pointer points to the position of the next character to be deposited into the sequence as a result of an insertion.
A get pointer points to the position of the next character to be fetched from the sequence as a result of an extraction.
For example, ostream only has a put pointer, istream only has a get pointer, and iostream has both pointers.
Figure 11_0_24 Streambuf put and get pointers.
Therefore, the stream classes provide constructors which take a streambuf* argument.
All stream classes overload the insertion and extraction operators for use with a streambuf* operand.
The insertion or extraction of a streambuf causes the entire stream represented by it to be copied.
Use of the insertion operator << for stream output was introduced in Chapter 1, and employed throughout this book.
The overloading of the insertion operator for user-defined types was discussed in Chapter 7.
This section looks at the ostream member functions.
The put member function provides a simple method of inserting a single character into an output stream.
For example, assuming that os is an ostream object, os_0_put('a'); inserts 'a' into os.
An optional second argument to.
These are defined as a public enumeration in the ios class.
Table 11_0_18 summarizes the ostream member functions.
All output functions with an ostream& return type, return the stream for which they are invoked.
Multiple calls to such functions can be concatenated (i_0_e_0_, combined into one statement).
For example, www_0_pragsoft_0_com Chapter 11: The IO Library.
Member functions of ostream.
Copyright © 2005 PragSoft Stream Input with istream Istream provides formatted input capability.
Use of the extraction operator >> for stream input was introduced in Chapter 1.
The overloading of the extraction operator for user-defined types was discussed in Chapter 7.
This section looks at the istream member functions.
The get member function provides a simple method of extracting a single character from an input stream.
For example, assuming that is is an istream object, int  = is_0_get(); extracts and returns the character denoted by the get pointer of is, and advances the get pointer.
A variation of get, called peek, does the same but does not advance the get pointer.
In other words, it allows you to examine the next input character without extracting it.
The effect of a call to get can be canceled by calling putback which deposits the extracted character back into the stream: is_0_putback(); The return type of get and peek is an int (not char).
This is because the end-offile character (EOF) is usually given the value -1.
The behavior of get is different from the extraction operator in that the former does not skip blanks.
For example, an input line consisting of x y (i_0_e_0_, 'x', space, 'y', newline) would be extracted by four calls to get.
See Table 11_0_19 for a summary.
The read member function extracts a string of characters from an input stream.
For example, char buf[64]; is_0_read(buf, 64); extracts up to 64 characters from is and deposits them into buf.
Of course, if EOF is encountered in the process, less characters will be extracted.
The actual number of characters extracted is obtained by calling gcount.
A variation of read, called getline, allows extraction of characters until a user-specified delimiter is encountered.
For example, is_0_getline(buf, 64, '\t'); is similar to the above call to read but stops the extraction if a tab character is encountered.
The delimiter, although extracted if encountered within the specified number of characters, is not deposited into buf.
The delimiters itself is also extracted and discarded.
The position of an input stream get pointer can be queried using tellg and adjusted using seekg.
For example, is_0_seekp(is_0_tellg() - 10); moves the get pointer 10 characters backward.
An optional second argument to.
Table 11_0_19 summarizes the istream member functions.
All input functions with an istream& return type, return the stream for which they are invoked.
Multiple calls to such functions can therefore be concatenated.
Table 11_0_19 Member functions of istream.
The constructor associates a streambuf (or its derivation) with the class to provide an input stream.
The first version extracts the next character (including EOF).
The second and third versions are similar but instead deposit the character into their parameter.
The last version extracts and deposit characters into the given streambuf until the delimiter denoted by its last parameter is encountered.
The delimiter, if encountered and extracted, is not deposited into the array.
It uses a streambuf for buffering of data and maintains operational information on the state of the streambuf (i_0_e_0_, IO errors).
It also keeps formatting information for the use of its client classes (e_0_g_0_, istream and ostream).
The definition of ios contains a number of public enumerations whose values are summarized by Table 11_0_20.
The io_state values are used for the state data member which is a bit vector of IO error flags.
The formatting flags are used for the x_flags data member (a bit vector).
The open_mode values are bit flags for specifying the opening mode of a stream.
The  values specify the seek direction for seekp and seekg.
Table 11_0_20 Useful public enumerations in ios.
When state is set to this value, it means that all is ok.
End-of-file has been reached.
An invalid operation has been attempted.
The last IO operation attempted has failed.
An unrecoverable error has taken place.
Provides formatting flags.
Left-adjust the output.
Right-adjust the output.
Output padding indicator.
Convert to decimal.
Convert to octal.
Convert to hexadecimal.
Show the base on output.
Show the decimal point on output.
Use upper case for hexadecimal output.
Show the + symbol for positive integers.
Use the floating notation for reals.
Use the scientific notation for reals.
Skip blanks (white spaces) on input.
Flush all streams after insertion.
Provides values for stream opening mode.
Stream open for input.
Stream open for output.
Append data to the end of the file.
Upon opening the stream, seek to EOF.
Truncate existing file.
Open should fail if file already exists.
Open should fail if file does not already exist.
Binary file (as opposed to default text file).
Provides values for relative seek.
Seek relative to the beginning of the stream.
Seek relative to the current put/get pointer position.
Seek relative to the end of the stream.
Copyright © 2005 PragSoft IO operations may result in IO errors, which can be checked for using a number of ios member functions.
For example, good returns nonzero if no error.
The opposite shorthand is provided through the overloading of the void* so that it returns zero when fail returns nonzero.
This makes it possible to check for errors in the following fashion: // no error occurred The entire error bit vector can be obtained by calling rdstate, and cleared by.
For example, s_0_setstate(ios::eofbit | ios::badbit); sets the eofbit and badbit flags.
Ios also provides various formatting member functions.
For example, precision can be used to change the precision for displaying floating point numbers: _0_precision(4); << 233_0_123456789 << '\n';.
Also, the specified width applies only to the next object to be output.
By default, spaces are used to pad the object up to the specified minimum size.
The padding character can be changed using fill.
The second argument is typically one of: ios::basefield ≡ ios::dec | ios::oct | ios::hex ios::adjustfield ≡ ios::left | ios::right | ios::internal ios::floatfield ≡ ios::scientific | ios::fixed.
Copyright © 2005 PragSoft Formatting flags can be reset by calling unsetf, and set as a whole or examined by calling flags.
For example, to disable the skipping of leading blanks for an input stream such as cin, we can write: cin_0_unsetf(ios::skipws); Table 11_0_21 summarizes the member functions of ios.
Member functions of ios.
Both return the previous setting.
The second version sets the formatting flags to a given value (flags(0) restores default formats), and return the previous setting.
The second version ties the stream denoted by its parameter to this stream and returns the previously-tied stream.
When two streams are tied the use of one affects the other.
For example, because cin, cerr, and clog are all tied to , using any of the first three causes  to be flushed first.
Copyright © 2005 PragSoft Stream Manipulators A manipulator is an identifier that can be inserted into an output stream or extracted from an input stream in order to produce a desired effect.
For example, endl is a commonly-used manipulator which inserts a newline into an output stream and flushes it.
Manipulator endl ends flush dec hex ws.
Stream Type output output output input/output input/output input/output input input/output input/output input/output input/output input/output input/output Description Inserts a newline character and flushes the stream.
Inserts a null-terminating character.
Sets the conversion base to decimal.
Sets the conversion base to hexadecimal.
Sets the conversion base to octal.
Extracts blanks (white space) characters.
Sets the conversion base to one of 8, 10, or 16.
Clears the status flags denoted by the argument.
Sets the status flags denoted by the argument.
Sets the padding character to the argument.
Sets the floating-point precision to the argument.
Sets the field width to the argument.
Because the classes defined in this file are derived from iostream classes, fstream_0_h also includes iostream_0_h.
A file can be opened for output by creating an ofstream object and specifying the file name and mode as arguments to the constructor.
For example, ofstream log("log_0_dat", ios::out); opens a file named log_0_dat for output (see Table 11_0_20 for a list of the open.
First, however, we should check that the file is opened as expected:.
Because ifstream is derived from istream, all the public member functions of the latter can also be invoked for ifstream objects.
The fstream class is derived from iostream and can be used for opening a file for input as well as output.
Table 11_0_23 Member functions of ofstream, ifstream, and fstream.
The first version makes an ofstream which is not attached to a file.
The second version makes an ofstream and connects it to an open file descriptor.
The third version does the same but also uses a userspecified buffer of a given size.
The last version makes an ofstream and opens and connects a specified file to it for writing.
Insertion and extraction on such streams causes the data to be moved into and out of its character array.
Because these classes are derived from iostream classes, this file also includes iostream_0_h.
The three highest-level array IO classes (ostrstream, istrstream, strstream) are very similar to the file IO counterparts (ofstream, ifstream, fstream).
As before, they are derived from iostream classes and therefore inherit their member functions.
An ostrstream object is used for output.
It can be created with either a dynamically-allocated internal buffer, or a user-specified buffer:.
The static version (ssta) is more appropriate for situations where the user is certain of an upper bound on the stream buffer size.
In the dynamic version, the object is responsible for resizing the buffer as needed.
After all the insertions into an ostrstream have been completed, the user can obtain a pointer to the stream buffer by calling : char * = odyn_0_(); This freezes odyn (disabling all future insertions).
If  is not called before odyn goes out of scope, the class destructor will destroy the buffer.
However, when is called, this responsibility rests with the user.
Therefore, the user should make sure that when  is no longer needed it is deleted: delete ;.
The advantage of the former is that extraction operations will not attempt to go beyond the end of data array.
Table 11_0_24 summarizes the member functions of ostrstream, istrstream, and strstream (in addition to those inherited from their base classes).
We would like to write a tool which takes the output of the compiler and uses it to annotate the lines in the program file which are reported to contain errors, so that, for example, instead of the above we would have something like: 0021 =  * y +; Error: invalid expression.
Listing 11_0_43 provides a function which performs the proposed annotation.
Annotation 6 Annotate takes two argument: inProg denotes the program file name and inData denotes the name of the file which contains the messages generated by the compiler.
When a match is found, we reset the get pointer of data back to the beginning of the stream, ignore characters up to the space character before the line number, extract the line number into lineNo, and then ignore the remaining characters up to the comma following the line number (i_0_e_0_, where the actual error message starts).
Note that as a result of the re-arrangements, the line number is effectively removed from the error message and displayed next to the program line.
Copyright © 2005 PragSoft Listing 11_0_43 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16.
Chapter 11: The IO Library 215 prog_0_dat: #defone size 100 {.
Copyright © 2005 PragSoft Exercises 11_0_56 Use the istream member functions to define an overloaded version of the >> operator for the Set class (see Chapter 7) so that it can input sets expressed in the.
Your program should be able to copy text as well as binary files.
A line which contains an unbalanced bracket should be reported by a message such as the following sent to standard output: '{' on line 15 has no matching '}' ¨.
The Preprocessor Prior to compiling a program source file, the Cplus_plus compiler passes the file through a preprocessor.
The role of the preprocessor is to transform the source file into an equivalent file by performing the preprocessing instructions contained by it.
These instructions facilitate a number of features, such as: file inclusion, conditional compilation, and macro substitution.
Figure 12_0_25 illustrates the effect of the preprocessor on a simple file.
It shows the preprocessor performing the following:.
Removing program comments by substituting a single white space for each comment.
Performing the file inclusion (#include) and conditional compilation (#ifdef, etc_0_) commands as it encounters them.
It compares these names against the identifiers in the program, and does a substitution when it finds a match.
The preprocessor performs very minimal error checking of the preprocessing instructions.
Because it operates at a text level, it is unable to check for any sort of language-level syntax errors.
This function is performed by the compiler.
Figure 12_0_25 The role of the preprocessor.
Copyright © 2005 PragSoft Preprocessor Directives Programmer instructions to the preprocessor (called directives) take the general form: # directive tokens The # symbol should be the first non-blank character on the line (i_0_e_0_, only spaces and tabs may appear before it).
Blank symbols may also appear between the # and directive.
The following are therefore all valid and have exactly the same effect: #define size 100 #define size 100 # define size 100 A directive usually occupies a single line.
A line whose last non-blank character is \, is assumed to continue on the line following it, thus making it possible to define multiple line directives.
For example, the following multiple line and single line directives have exactly the same effect: #define CheckError \.
A directive line may also contain comment; these are simply ignored by the preprocessor.
A # appearing on a line on its own is simply ignored.
Table 12_0_25 summarizes the preprocessor directives, which are explained in detail in subsequent sections.
Most directives are followed by one or more tokens.
A token is anything other than a blank.
Table 12_0_25 Preprocessor directives.
Directive #define #undef #include #ifdef #ifndef #endif #if #else #elif #line #error #pragma Explanation Defines a macro Undefines a macro Textually includes the contents of a file Makes compilation of code conditional on a macro being defined Makes compilation of code conditional on a macro not being defined Marks the end of a conditional compilation block Makes compilation of code conditional on an expression being nonzero Specifies an else part for a #ifdef, #ifndef, or #if directive Combination of #else and #if Change current line number and file name Outputs an error message Is implementation-specific ¨.
A plain macro has the general form: #define identifier tokens It instructs the preprocessor to substitute tokens for every occurrence of identifier in the rest of the file (except for inside strings).
The substitution tokens can be anything, even empty (which has the effect of removing identifier from the rest of the file).
Plain macros are used for defining symbolic constants.
For example: #define size #define word #define bytes 512 long Because macro substitution is also applied to directive lines, an identifier defined by.
Given the above definitions, the code fragment word  = size * bytes;.
Use of macros for defining symbolic constants has its origins in C, which had no language facility for defining constants.
In Cplus_plus, macros are less often used for this purpose, because consts can be used instead, with the added benefit of proper type checking.
A parameterized macro has the general form #define identifier(parameters) tokens where parameters is a list of one or more comma-separated identifiers.
There should be no blanks between the identifier and (.
Otherwise, the whole thing is interpreted as a plain macro whose substitution tokens part starts from (.
For example, defines a parameterized macro for working out the maximum of two quantities.
A parameterized macro is matched against a call to it, which is syntactically very similar to a function call.
A call must provide a matching number of arguments.
Additionally, every occurrence of a parameter in the substituted tokens is substituted by the corresponding argument.
This is called macro expansion.
For example, the call = Max ( - 2, k +6);.
Note that the ( in a macro call may be separated from the macro identifier by blanks.
It is generally a good idea to place additional brackets around each occurrence of a parameter in the substitution tokens (as we have done for Max).
This protects the macro against undesirable operator precedence effects after macro expansion.
Overlooking the fundamental difference between macros and functions can lead to subtle programming errors.
Because macros work at a textual level, the semantics of macro expansion is not necessarily equivalent to function call.
For example, the macro call is expanded to which means that i may end up being incremented twice.
Where as a function version of Max would ensure that i is only incremented once.
Two facilities of Cplus_plus make the use of parameterized macros less attractive than in C.
First, Cplus_plus inline functions provide the same level of code efficiency as macros, without the semantics pitfalls of the latter.
Second, Cplus_plus templates provide the same kind of flexibility as macros for defining generic functions and classes, with the added benefit of proper syntax analysis and type checking.
Macros can also be redefined.
However, before a macro is redefined, it should be undefined using the #undef directive.
For example: #undef size #define size #undef Max 128 Use of #undef on an undefined identifier is harmless and has no effect.
The quote operator (#) is unary and takes a macro parameter operand.
It transforms its operand into a string by putting double-quotes around it.
For example, consider a parameterized macro which checks for a pointer to be nonzero and outputs a warning message when it is zero: \ Use of the # operator allows the expression given as argument to CheckPtr to be literally printed as a part of the warning message.
Note that defining the macro as.
The concatenation operator (##) is binary and is used for concatenating two tokens.
For example, given the definition internal##var.
It is very useful for writing translators and code generators, as it makes it easy to build an identifier out of fragments.
Copyright © 2005 PragSoft File Inclusion A file can be textually included in another file using the #include directive.
For example, placing inside a file f causes the contents of contents_0_h to be included in f in exactly the position where the directive appears.
The included file is usually expected to reside in the same directory as the program file.
Otherwise, a full or relative path to it should be specified.
When including system header files for standard libraries, the file name should be enclosed in <> instead of double-quotes.
For example: # <iostream_0_h> When the preprocessor encounters this, it looks for the file in one or more prespecified locations on the system (e_0_g_0_, the directory /usr//cpp on a UNIX system).
On most systems the exact locations to be searched can be specified by the user, either as an argument to the compilation command or as a system environment variable.
File inclusions can be nested.
For example, if a file f includes another file g which in turn includes another file h, then effectively f also includes h.
Although the preprocessor does not care about the ending of an included file (i_0_e_0_, whether it is _0_h or _0_cpp or _0_cc, etc_0_), it is customary to only  header files in other files.
Multiple inclusion of files may or may not lead to compilation problems.
For example, if a header file contains only macros and declarations then the compiler will not object to their reappearance.
But if it contains a variable definition, for example, the compiler will flag it as an error.
The next section describes a way of avoiding multiple inclusions of the same file.
It is usually used as a portability tool for tailoring the program code to specific hardware and software architectures.
Table 12_0_26 summarizes the general forms of these directives (code denotes zero or more lines of program text, and expression denotes a constant expression).
Table 12_0_26 General forms of conditional compilation directives.
Form #ifdef identifier code #endif #ifndef identifier code #endif #if expression code #endif #ifdef identifier code1 #else code2 #endif #if expression1 code1 #elif expression2 code2 #else code3 Explanation If identifier is a #defined symbol then code is included in the compilation process.
If identifier is not a #defined symbol then code is included in the compilation process.
If expression evaluates to nonzero then code is included in the compilation process.
If identifier is a #defined symbol then code1 is included in the compilation process and code2 is excluded.
Otherwise, code2 is included and code1 is excluded.
Similarly, #else can be used with #ifndef and #if.
If expression1 evaluates to nonzero then only code1 is included in the compilation process.
Otherwise, if expression2 evaluates to nonzero then only code2 is included.
As before, the #else part is optional.
Also, any number of #elif directives may appear after a #if directive.
DisplayBetaDialog(); #else CheckRegistration(); #endif // Ensure Unit is at least 4 bytes wide:.
Copyright © 2005 PragSoft One of the common uses of #if is for temporarily omitting code.
This is often done during testing and debugging when the programmer is experimenting with suspected areas of code.
Although code may also be omitted by commenting its out (i_0_e_0_, placing /* and */ around it), this approach does not work if the code already contains /*_0__0__0_*/ style comments, because such comments cannot be nested.
Code is omitted by giving #if an expression which always evaluates to zero: #if 0 _0__0__0_code to be omitted #endif The preprocessor provides an operator called defined for use is expression arguments of #if and #elif.
For example, #if defined BETA has the same effect as: #ifdef BETA However, use of defined makes it possible to write compound logical expressions.
For example: #if defined ALPHA || defined BETA Conditional compilation directives can be used to avoid the multiple of inclusion of files.
For example, given an include file called file_0_h, we can avoid multiple inclusions of file_0_h in any other file by adding the following to file_0_h: #ifndef _file_h_ #define _file_h_ contents of file_0_h goes here #endif When the preprocessor reads the first inclusion of file_0_h, the symbol _file_h_ is undefined, hence the contents is included, causing the symbol to be defined.
Subsequent inclusions have no effect because the #ifndef directive causes the contents to be excluded.
The #line directive is used to change the current line number and file name.
It has the general form: #line number file where file is optional.
For example, makes the compiler believe that the current line number is 20 and the current file name is file_0_h.
The change remains effective until another #line directive is encountered.
The directive is useful for translators which generate Cplus_plus code.
It allows the line numbers and file name to be made consistent with the original input file, instead of any intermediate Cplus_plus file.
The #error directive is used for reporting errors by the preprocessor.
It has the general form #error error where error may be any sequence of tokens.
When the preprocessor encounters this, it outputs error and causes compilation to be aborted.
It should therefore be only used for reporting errors which make further compilation pointless or impossible.
For example: #ifndef UNIX #error This software requires the UNIX OS.
It is used by compiler vendors to introduce nonstandard preprocessor features, specific to their own implementation.
Examples from the SUN Cplus_plus compiler include: // align name and val starting addresses to multiples of 8 bytes: char name[9]; double val; // call MyFunction at the beginning of program execution: ¨ 226.
Copyright © 2005 PragSoft Predefined Identifiers The preprocessor provides a small set of predefined identifiers which denote useful information.
The standard ones are summarized by Table 12_0_27.
Most implementations augment this list with many nonstandard predefined identifiers.
Table 12_0_27 Standard predefined identifiers.
The predefined identifiers can be used in programs just like program constants.
For example, #define (p) \ cout << __FILE__ << ": assertion on line " \ defines an assert macro for testing program invariants.
Assuming that the sample call ( _0_= 0); appear in file prog_0_cpp on line 50, when the stated condition fails, the following message is displayed: prog_0_cpp: assertion on line 50 failed.
An infinite loop structure called forever.
Pascal style repeat-until loop.
Define parameterized macros for the following:.
Swapping two values.
Finding the center of a rectangle whose top-left and bottom-right coordinates are given (requires two macros).
Redefine the above as inline functions or function templates as appropriate.
Defining Small as an unsigned char when the symbol PC is defined, and as unsigned short otherwise.
Including the file debug_0_h in another file when release is 0, or beta_0_h when release is 1, or final_0_h when release is greater than 1.
Write a macro named When which returns the current date and time as a string (e_0_g_0_, "25 Dec 1995, 12:30:55").
Similarly, write a macro named Where which returns the current location in a file as a string (e_0_g_0_, "file_0_h: line 25").
It will output the message  is negative.
This is because the else clause is associated with the if clause immediately preceding it.
The indentation in the code fragment << " is small\"; else << " is negative\"; is therefore misleading, because it is understood by the compiler as: << " is small\"; else.
The value   and y will be unchanged because Swap uses value parameters.
Consequently, it swaps a copy   and y and not the originals.
Jan, Feb, Mar, Apr, May, Jun,.
Declaring Set parameters as references avoids their being copied in a call.
Call-byreference is generally more efficient than call-by-value when the objects involved are larger than the built-in type objects.
Option*& Next (void) {return next;} private:.
Copyright © 2005 PragSoft.
FreeSubtree InsertNode DeleteNode FindNode PrintNode.
A static data member is  to keep track of the last allocated ID (see lastId below).
Rows (void) {return rows;} int Cols.
String& String& char& int www_0_pragsoft_0_com String String String ~String = = [] Length.
Copyright © 2005 PragSoft.
A B-tree consists of a set of nodes, where each node may contain up to 2 records and have 2+1 children.
The number  is called the order of the tree.
Every node in the tree (except for the root node) must have at least  records.
This ensures that at least 50% of the storage capacity is utilized.
Furthermore, a nonleaf node that contains m records must have exactly m+1 children.
The most important property of a B-tree is that the insert and delete operations are designed so that the tree remains balanced at all times.
Item { = 0;} Item (Key, Data); Key& KeyOf {return key;} Data& {return data;} {return ;} friend ostream& << (ostream&, Item&);.
Copyright © 2005 PragSoft.
Page *bufP; // buffer page for distribution/merging virtual void virtual Item* virtual Item* FreePages SearchAux.
A B*- is a B- in which most nodes are at least 2/3 full (instead of 1/2 full).
Instead of splitting a node as soon as it becomes full, an attempt is made to evenly distribute the contents of the node and its neighbor(s) between them.
A node is split only when one or both of its neighbors are full too.
A B*- www_0_pragsoft_0_com Solutions to Exercises 275 facilitates more economic utilization of the available store, since it ensures that at least 66% of the storage occupied by the  is actually.
As a result, the height of the  is smaller, which in turn improves the search speed.
The search and delete operations are exactly as in a B-; only the insertion operation is different.
FreeSubtree InsertNode DeleteNode FindNode PrintNode private:.
InsertNode(, subtreearrow_operatorright); } template <class >.
Copyright © 2005 PragSoft.
Copyright © 2005 PragSoft template <class Key, class > <Key, >* <Key, >:: { int.
PType Type Bool Valid }; class Connection { public:.
Bool Active }; class InactiveConn class InvalidPack class UnknownPack.