Access student data files and other study tools on cengagebrain_0_com.
For detailed instructions visit http://solutions_0_cengage_0_com/ctdownloads/ Store your Data Files on a USB drive for maximum efficiency in organizing and working with the files.
Macintosh users should use a program to expand WinZip or PKZip archives.
Ask your instructor or lab coordinator for assistance.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Cplus_plus PROGRAMMING: PROGRAM DESIGN INCLUDING DATA STRUCTURES SEVENTH EDITION D_0_S.
MALIK Australia  Brazil  Japan  Korea  Mexico  Singapore  Spain  United Kingdom  United States Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
This is an electronic version of the print textbook.
Due to electronic rights restrictions, some third party content may be suppressed.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
The publisher reserves the right to remove content from this title at any time if subsequent rights restrictions require it.
For valuable information on pricing, previous editions, changes to current editions, and alternate formats, please visit www_0_cengage_0_com/highered to search by ISBN#, author, title, or keyword for materials in your areas of interest.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Cplus_plus Programming: Program Design Including Data Structures, Seventh Edition D_0_S.
Malik Product Director: Kathleen McMahon Senior Product Manager: Jim Gish Senior Content Developer: Alyssa Pratt Product Assistant: Gillian Daniels Content Project Manager: Jennifer Feltri-George Art Director: GEX Publishing Services Print Buyer: Julio Esperas Cover Designer: GEX Publishing Services ª Cengage Learning WCN: 02-200-203 ALL RIGHTS RESERVED.
No part of this work covered by the copyright herein may be reproduced, transmitted, stored or used in any form or by any means—graphic, electronic, or mechanical, including but not limited to photocopying, recording, scanning, digitizing, taping, Web distribution, information networks, or information storage and retrieval systems, or of the United States except as permitted under Section Copyright Act—without the prior written permission of the publisher.
For product information and technology assistance, contact us at Cengage Learning Customer & Sales Support, www_0_cengage_0_com/ support.
For permission to use material from this text or product, submit all requests online at www_0_cengage_0_com/permissions.
Cover Photo: ª OlegDoroshin/Shutterstock_0_com Further permissions questions can be emailed to permissionrequest@cengage_0_com.
Proofreader: Andrea Schein Indexer: Sharon Hilgenberg Compositor: Integra Software Services Library of Congress Control Number: ISBN- : minus_minus.
Cengage Learning First Stamford Place, 4th Floor Stamford, CT USA Cengage Learning is a leading provider of customized learning solutions with office locations around the globe, including Singapore, the United Kingdom, Australia, Mexico, Brazil, and Japan.
Locate your local office at: www_0_cengage_0_com/global Cengage Learning products are represented in Canada by Nelson Education, Ltd.
Purchase any of our products at your local college store or at our preferred online store: www_0_cengagebrain_0_com Some of the product names and company names used in this book have been used for identification purposes only and may be trademarks or registered trademarks of their respective manufacturers and sellers.
Microsoft product screenshots used with permission from Microsoft Corporation.
Unless otherwise credited, all art and tables ª 2015 Cengage Learning, produced by Integra.
Cengage Learning reserves the right to revise this publication and make changes from time to time in its content without notice.
Any fictional data related to persons or companies or URLs used throughout this book is intended for instructional purposes only.
At the time this book was printed, any such data was fictional and not belonging to any real persons or companies.
The programs in this book are for instructional purposes only.
They have been tested with care, but are not guaranteed for any particular intent beyond educational purposes.
The author and the publisher do not offer any warranties or representations, nor do they accept any liabilities with respect to the programs.
Printed in the United States of America 1 2 3 4 5 6 7 20 19 18 17 16 15 14 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
TO My Parents Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
B RIEF C ONTENTS ª HunThomas/Shutterstock_0_com PREFACE 1.
An Overview of Computers and Programming Languages 2.
Basic Elements of Cplus_plus xxxv 1 27 3.
User-Defined Simple Data Types, Namespaces, and the string Type 465.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
APPENDIX G Memory Size on a System and Random Number Generator 1603.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
TABLE OF C ONTENTS.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Table of Contents Input (Read) Statement Variable Initialization | ix 63 66 Increment and Decrement Operators.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Table of Contents.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Table of Contents.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Table of Contents Functions and Enumeration Types Declaring Variables When Defining the Enumeration Type Anonymous Data Types typedef Statement xv 473 474 475 475 Programming Example: The Game of Rock, Paper, and Scissors 477.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Cplus_plus Programming: Program Design Including Data Structures, Seventh Edition Integral Data Type and Array Indices Other Ways to Declare Arrays 541 542 Searching an Array for a Specific Item Sorting 542 545 Auto Declaration and Range-Based For Loops 549 String Comparison Reading and Writing Strings String Input String Output Specifying Input/Output Files at Execution Time string Type and Input/Output Files 550 553 554 554 556 557 557 Parallel Arrays 558 Two- and Multidimensional Arrays Accessing Array Components Two-Dimensional Array Initialization during Declaration Two-Dimensional Arrays and Enumeration Types Initialization Print Input Sum by Row Sum by Column Largest Element in Each Row and Each Column Passing Two-Dimensional Arrays as Parameters to Functions Arrays of Strings Arrays of Strings and the string Type Another Way to Declare a Two-Dimensional Array Multidimensional Arrays 559 561 562 563 566 566 567 567 567 568 568 572 572 572 573 574 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Table of Contents.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Cplus_plus Programming: Program Design Including Data Structures, Seventh Edition Assignment Operator and Classes Class Scope Functions and Classes Reference Parameters and Class Objects Implementation of Member Functions Accessor and Mutator Functions Order of public and private Members of a Class Constructors Invoking a Constructor Invoking the Default Constructor Invoking a Constructor with Parameters Constructors and Default Parameters Classes and Constructors: A Precaution In-line Initialization of Data Members and the Default Constructor Arrays of Class  (Variables) and Constructors Destructors 657 658 658 658 659 664 668 669 671 671 672 675 675 676 677 679 Data Abstraction, Classes, and Abstract Data Types 680.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Table of Contents.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Table of Contents.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Table of Contents.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Cplus_plus Programming: Program Design Including Data Structures, Seventh Edition Insert the Last Node Header File of the Unordered Linked List 17 1100 1105 Ordered Linked Lists Search the List Insert a Node Insert First and Insert Last Delete a Node Header File of the Ordered Linked List 1106 1107 1108 1112 1113 1114 Print a Linked List in Reverse Order printListReverse 1117 1119 Doubly Linked Lists Default Constructor isEmptyList Destroy the List Initialize the List Length of the List Print the List Reverse Print the List Search the List First and Last Elements 1120 1123 1123 1123 1124 1124 1124 1124 1125 1125 Circular Linked Lists.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Table of Contents.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Cplus_plus Programming: Program Design Including Data Structures, Seventh Edition Removing Recursion: Nonrecursive Algorithm to Print a Linked List Backward 18 1211 Queues Queue Operations Implementation of Queues as Arrays Linked Implementation of Queues Queue Derived from the class unorderedLinkedListType 1215 1216 1218 1227 1232 Application of Queues: Simulation Designing a Queuing System Customer Server Server List Waiting Customers Queue Main Program 1233 1234 1235 1238 1241 1245 1247 Quick Review.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Table of Contents.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Table of Contents.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Table of Contents.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Table of Contents.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
P REFACE ª HunThomas/Shutterstock_0_com WELCOME TO THE SEVENTH EDITION OF Cplus_plus Programming: Program Design Including Data Structures.
Designed for a two semester (CS1 and CS2) Cplus_plus course, this text will provide a breath of fresh air to you and your students.
The CS1 and CS2 courses serve as the cornerstone of the Computer Science curriculum.
My primary goal is to motivate and excite all introductory programming students, regardless of their level.
Motivation breeds excitement for learning.
Motivation and excitement are critical factors that lead to the success of the programming student.
This text is a culmination and development of my classroom notes throughout more than fifty semesters of teaching successful programming to Computer Science students.
Warning: This text can be expected to create a serious reduction in the demand for programming help during your office hours.
Other side effects include significantly diminished student dependency on others while learning to program.
Cplus_plus Programming: Program Design Including Data Structures started as a collection of brief examples, exercises, and lengthy programming examples to supplement the books that were in use at our university.
It soon turned into a collection large enough to develop into a text.
The approach taken in this book is, in fact, driven by the students' demand for clarity and readability.
The material was written and rewritten until the students felt comfortable with it.
Most of the examples in this book resulted from student interaction in the classroom.
As with any profession, practice is essential.
Cooking students practice their recipes.
Budding violinists practice their scales.
New programmers must practice solving problems and writing code.
We do not simply list the Cplus_plus syntax followed by an example; we dissect the "why_0_" behind all the concepts.
The crucial question of "why_0_" is answered for every topic when first introduced.
This technique offers a bridge to learning Cplus_plus.
Students must understand the "why_0_" in order to be motivated to learn.
Traditionally, a Cplus_plus programming neophyte needed a working knowledge of another programming language.
This book assumes no prior programming experience.
However, some adequate mathematics background such as college algebra is required.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
A special feature of the seventh edition is the mapping of end-of-chapter with their respective learning objective(s) listed at the beginning of the chapter.
The first part of Chapter 4 is reorganized by introducing the if and if_0__0__0_else structures earlier.
Also, the first part of Chapter 5 is rewritten.
This edition also introduces some features of Cplus_plus11, such as range-based for loops, in Chapter 8, and illustrates how to use them to process the elements of an array, in Chapters 8 and 12, and on sequence containers, in Chapter 21.
We have also included various new , such as Examples 2-19, 3-12, 3-13, 3-14, 4-14, 6-5, 6-16, 8-7, 10-11, 11-4, 13-1, and 21-6.
Approach The  language Cplus_plus, which evolved from C, is no longer considered an industry-only language.
Numerous colleges and universities use Cplus_plus for their first  language course.
Cplus_plus is a combination of structured  and object-oriented , and this book addresses both types.
This book is intended for a two-semester course, CS1 and CS2, in Computer Science.
The first 10 or 11 chapters can be covered in the first course and the remaining in the second course.
In July 1998, ANSI/ISO Standard Cplus_plus was officially approved.
This book focuses on ANSI/ ISO Standard Cplus_plus.
Even though the syntax of Standard Cplus_plus and ANSI/ISO Standard Cplus_plus is very similar, Chapter 7 discusses some of the features of ANSI/ISO Standard Cplus_plus that are not available in Standard Cplus_plus.
Chapter 1 briefly reviews the history of computers and  languages.
The reader can quickly skim through this chapter and become familiar with some of the hardware components and the software parts of the computer.
This chapter contains a section on processing a Cplus_plus program.
This chapter also describes structured and object-oriented.
Chapter 2 discusses the basic elements of Cplus_plus.
After completing this chapter, students become familiar with the basics of Cplus_plus and are ready to write programs that are complicated enough to do some computations.
Input/output is fundamental to any  language.
It is introduced early, in Chapter 3, and is covered in detail.
Chapters 4 and 5 introduce control structures to alter the sequential flow of execution.
Chapter 6 studies user-defined functions.
It is recommended that readers with no prior background spend extra time on Chapter 6.
Several  are provided to help readers understand the concepts of parameter passing and the scope of an identifier.
Chapter 7 discusses the user-defined simple data type (enumeration type), the namespace mechanism of ANSI/ISO Standard Cplus_plus, and the string type.
The earlier versions of C did not include the enumeration type.
Enumeration types have very limited use; their main purpose is to make the program readable.
This book is organized such that readers can skip Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Preface | xxxvii the section on enumeration types during the first reading without experiencing any discontinuity, and then later go through this section.
Chapter 8 discusses arrays in detail.
This chapter also introduces range-based for loops, a feature of Cplus_plus11 Standard, and explains how to use them to process the elements of an array.
Limitations of ranged-based for loops on arrays passed as parameters to functions are also discussed.
Chapter 8 also discusses a sequential search algorithm and a selection sort algorithm.
Chapter 9 introduces records (structs).
The introduction of structs in this book is similar to C structs.
This chapter is optional; it is not a prerequisite for any of the remaining chapters.
Chapter 10 begins the study of object-oriented  (OOP) and introduces classes.
The first half of this chapter shows how classes are defined and used in a program.
The second half of the chapter introduces abstract data types (ADTs).
This chapter shows how classes in Cplus_plus are a natural way to implement ADTs.
Chapter 11 continues with the fundamentals of object-oriented design (OOD) and OOP, and discusses inheritance and composition.
It explains how classes in Cplus_plus provide a natural mechanism for OOD and how Cplus_plus supports OOP.
Chapter 11 also discusses how to find the objects in a given problem.
Chapter 12 studies pointers in detail.
After introducing pointers and how to use them in a program, this chapter highlights the peculiarities of classes with pointer data members and how to avoid them.
Moreover, this chapter discusses how to create and work with dynamic two-dimensional arrays, and also explains why ranged-based for loops cannot be used on dynamic arrays.
Chapter 12 also discusses abstract classes and a type of polymorphism accomplished via virtual functions.
Chapter 13 continues the study of OOD and OOP.
In particular, it studies polymorphism in Cplus_plus.
Chapter 13 specifically discusses two types of polymorphism—overloading and templates.
Chapter 14 discusses exception handling in detail.
Chapter 15 introduces and discusses recursion.
This is a stand-alone chapter, so it can be studied anytime after Chapter 9.
Chapters 16 and 17 are devoted to the study of data structures.
Discussed in detail are linked lists in Chapter 16 and stacks and queues in Chapter 17.
The  code developed in these chapters is generic.
These chapters effectively use the fundamentals of OOD.
Chapter 18 discusses various searching and sorting algorithms.
In addition to showing how these algorithms work, it also provides relevant analysis and results concerning the performance of the algorithms.
The algorithm analysis allows the user to decide which algorithm to use in a particular application.
This chapter also includes several sorting algorithms.
The instructor can decide which algorithms to cover.
Chapter 19 provides an introduction to binary trees.
Various traversal algorithms, as well as the basic properties of binary trees, are discussed and illustrated.
Special binary trees, called binary search trees, are introduced.
Searching, as well as item insertion and deletion from a binary search tree, are described and illustrated.
Chapter 19 also discusses nonrecursive binary tree traversal algorithms.
Furthermore, to enhance the flexibility of traversal algorithms, it shows how to construct and pass functions as parameters to other functions.
This chapter also discusses AVL (height balanced) trees in detail.
Because of text length considerations, discussion on AVL trees is provided as a separate section and is available on the Web site accompanying this book.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
After introducing the basic graph theory terminology, the representation of graphs in computer memory is discussed.
This chapter also discusses graph traversal algorithms, the shortest path algorithm, and the minimal spanning tree algorithm.
Topological sort is also discussed in this chapter and is available on the Web site accompanying this book.
Cplus_plus is equipped with a powerful library—the Standard Template Library (STL)—of data structures and algorithms that can be used effectively in a wide variety of applications.
Chapter 21 describes the STL in detail.
After introducing the three basic components of the STL, it shows how sequence containers are used in a program.
Special containers, such as stacks and queues, are also discussed.
The latter half of this chapter shows how various STL algorithms can be used in a program.
This chapter is fairly long; depending on the availability of time, the instructor can at least cover the sequence containers, iterators, the classes stack and queue, and certain algorithms.
Appendix A lists the reserved words in Cplus_plus.
Appendix B shows the precedence and associativity of the Cplus_plus operators.
Appendix C lists the ASCII (American Standard Code for Information Interchange) and EBCDIC (Extended Binary Coded Decimal Interchange Code) character sets.
Appendix D lists the Cplus_plus operators that can be overloaded.
Appendix E has three objectives.
First, we discuss how to convert a number from decimal to binary and binary to decimal.
We then discuss binary and random access files in detail.
Finally, we describe the naming conventions of the header files in both ANSI/ISO Standard Cplus_plus and Standard Cplus_plus.
Appendix F discusses some of the most widely used library routines, and includes the names of the standard Cplus_plus header files.
The programs in Appendix G show how to print the memory size for the built-in data types on your system as well as how to use a random number generator.
Appendix H gives selected references for further study.
Appendix I provides the answers to odd-numbered exercises in the book.
In Figure 1, dotted lines mean that the preceding chapter is used in one of the sections of the chapter and is not necessarily a prerequisite for the next chapter.
For example, Chapter 8 covers arrays in detail.
In Chapters 9 and 10, we show the relationship between arrays and structs and arrays and classes, respectively.
However, if Chapter 10 is studied before Chapter 8, then the section dealing with arrays in Chapter 10 can be skipped without any discontinuation.
This particular section can be studied after studying Chapter 8.
It is recommended that the first six chapters be covered sequentially.
After covering the first six chapters, if the reader is interested in learning OOD and OOP early, then Chapter 10 can be studied right after Chapter 6.
Chapter 7 can be studied anytime after Chapter 6.
After studying the first six chapters in sequence, some of the approaches are: 1.
Study chapters in the sequence: 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21.
Study chapters in the sequence: 8, 10, 12, 13, 11, 15, 16, 17, 14, 18, 19, 20, 21 Study chapters in the sequence: 10, 8, 12, 13, 11, 15, 16, 17, 14, 18, 19, 20, 21.
As the chapter dependency diagram shows, Chapters 17 and 18 can be covered in any sequence.
However, typically, Chapters 17 and 18 are studied in sequence.
Ideally, one should study Chapters 16, 17, 18, and 19 in sequence.
Chapters 20 and 21 can be studied in any sequence.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Figure 1 shows the dependency of the chapters.
Chapter dependency diagram Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
BOOK Four-color interior design shows accurate Cplus_plus code and related comments.
One video is available for each chapter on the optional CourseMate that accompanies this text.
Each video is designed to explain how a program works.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
More than 400 visual diagrams, both extensive and exhaustive, illustrate difficult concepts.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Numbered Examples illustrate the key concepts with their relevant code.
The programming code in these examples is followed by a Sample Run.
An explanation then follows that describes what each line in the code does.
Notes highlight important facts about the concepts introduced in the chapter.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Examples are where everything in the chapter comes together.
These examples teach problem-solving skills and include the concrete stages of input, output, problem analysis and algorithm design, class design, and a program listing.
All programs are designed to be methodical, consistent, and user-friendly.
Each Programming Example starts with a problem analysis that is followed by the algorithm design and/or class design, and every step of the algorithm is coded in Cplus_plus.
In addition to helping students learn problemsolving techniques, these detailed programs show the student how to implement concepts in an actual Cplus_plus program.
We strongly recommend that students study the Programming Examples carefully in order to learn Cplus_plus effectively.
Students typically learn much from completely worked-out programs.
Further, programming examples considerably reduce students' need for help outside the classroom and bolster students' self-confidence.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Exercises further reinforce learning and ensure that students have, in fact, mastered the material.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Exercises challenge students to write Cplus_plus programs with a specified outcome.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
S UPPLEMENTAL R ESOURCES ª HunThomas/Shutterstock_0_com CourseMate Make the most of your study time with everything you need to succeed in one place.
Read your textbook, highlight and take notes, review flashcards, watch videos, and take practice quizzes online.
Learn more at www_0_cengage_0_com/coursemate.
The Cplus_plus Programming CourseMate includes the following features:.
Videos step you through programs in each chapter, while integrated quizzes provide immediate feedback to gauge your understanding.
Lab Manual lets you apply material with a wealth of practical, hands-on exercises.
Interactive Quizzes and Study Games drill key chapter concepts, while openended Assignments develop critical thinking skills.
Instructors may add CourseMate to the textbook package, or students may purchase CourseMate directly through www_0_cengagebrain_0_com.
Source Code The source code, in ANSI/ISO Standard Cplus_plus, is available for students to download at www_0_cengagebrain_0_com and through the CourseMate available for this text.
These files are also available to instructors at sso_0_cengage_0_com.
The input files needed to run some of the programs are also included with the source code.
Instructor Resources The following supplemental materials are available when this book is used in a classroom setting.
All teaching tools are available with this book at sso_0_cengage_0_com.
An instructor account is required.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Supplemental Resources | xlvii Electronic Instructor's Manual The Instructor's Manual follows the text chapter-by-chapter and includes material to assist in planning and organizing an effective, engaging course.
The Manual includes Overviews, Chapter Objectives, Teaching Tips, Quick Quizzes, Class Discussion Topics, Additional Projects, Additional Resources, and Key Terms.
A Sample Syllabus is also available.
Test Bank Cengage Learning Testing Powered by Cognero is a flexible, online system that allows you to:.
Slides may be used to guide classroom presentation, to make available to students for chapter review, or to print as classroom handouts.
Instructors can add their own slides for additional topics that they introduce to the class, as well as customize the slides with the complete Figure Files from the text.
Solution Files The solution files for all Programming Exercises, in ANSI/ISO Cplus_plus, are available for instructor download at sso_0_cengage_0_com.
The input files needed to run some of the Programming Exercises are also included with the solution files.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
A CKNOWLEDGEMENTS ª HunThomas/Shutterstock_0_com There are many people that I must thank who, one way or another, contributed to the success of this book.
First, I would like to thank all the students who, during the preparation, were spontaneous in telling me if certain portions needed to be reworded for better understanding and clearer reading.
Next, I would like to thank those who e-mailed numerous comments to improve upon the sixth edition.
I am also very grateful to the reviewers who reviewed earlier versions of this book and offered many critical suggestions on how to improve it.
I owe a great deal to the following reviewers who made helpful, critical suggestions for improving this edition of the text: Terry Hoffer: City College Montana State University; Douglas Kranch: North Central State College; Xiangdong Li: New York City College of Technology; and Jeffrey Miller: Occidental College.
Next, I express thanks to Jim Gish, Senior Product Manager, for recognizing the importance and uniqueness of this project.
All this would not have been possible without the careful planning of Senior Content Developer, Alyssa Pratt, and Product Development Manager, Leigh Hefferon.
I extend my sincere thanks to Alyssa, as well as to Content Project Manager, Jennifer Feltri-George.
I also thank Shanthi Guruswamy of Integra Software Services for assisting us in keeping the project on schedule.
I would like to thank Chris Scriver and Serge Palladino of Cengage Learning for patiently and carefully testing the code and discovering typos and errors.
This book is dedicated to my parents, who I thank for their blessings.
Finally, I am thankful for the support of my wife Sadhana and especially my daughter Shelly.
They cheered me up whenever I was overwhelmed during the writing of this book.
I welcome any comments concerning the text.
Comments may be forwarded to the following e-mail address: malik@creighton_0_edu.
Malik Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Become aware of Standard Cplus_plus, ANSI/ISO Standard Cplus_plus, and Cplus_plus11 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Students in elementary school regularly "surf " the Internet and use computers to design and implement their classroom projects.
Many people use the Internet to look for information and to communicate with others.
This is all made possible by the use of various software, also known as computer programs.
Without software, a computer cannot work.
Software is developed by using programming languages.
Cplus_plus is one of the programming languages, which is well suited for developing software to accomplish specific tasks.
The main objective of this book is to help you learn Cplus_plus programming language to write programs.
Before you begin programming, it is useful to understand some of the basic terminology and different components of a computer.
We begin with an overview of the history of computers.
A Brief Overview of the History of Computers The first device known to carry out calculations was the abacus.
The abacus was invented in Asia but was used in ancient Babylon, China, and throughout Europe until the late middle ages.
The abacus uses a system of sliding beads in a rack for addition and subtraction.
In 1642, the French philosopher and mathematician Blaise Pascal invented the calculating device called the Pascaline.
It had eight movable dials on wheels and could calculate sums up to eight figures long.
Both the abacus and Pascaline could perform only addition and subtraction operations.
Later in the 17th century, Gottfried von Leibniz invented a device that was able to add, subtract, multiply, and divide.
In 1819, Joseph Jacquard, a French weaver, discovered that the weaving instructions for his looms could be stored on cards with holes punched in them.
While the cards moved through the loom in sequence, needles passed through the holes and picked up threads of the correct color and texture.
A weaver could rearrange the cards and change the pattern being woven.
In essence, the cards programmed a loom to produce patterns in cloth.
The weaving industry may seem to have little in common with the computer industry.
However, the idea of storing information by punching holes on a card proved to be of great importance in the later development of computers.
In the early and mid-1800s, Charles Babbage, an English mathematician and physical scientist, designed two calculating machines: the difference engine and the analytical engine.
The difference engine could perform complex operations such as squaring numbers automatically.
Babbage built a prototype of the difference engine, but did not build the actual device.
The first complete difference engine was completed in London in 2002, 153 years after it was designed.
It consists of 8,000 parts, weighs five tons, and measures 11 feet long.
A replica of the difference engine was completed in 2008 and is on display at the Computer History Museum in Mountain View, California (http://www_0_computerhistory_0_org/ babbage/).
Most of Babbage's work is known through the writings of his colleague Ada Augusta, Countess of Lovelace.
Augusta is considered the first computer programmer.
At the end of the 19th century, The United States Census officials needed help in accurately tabulating the census data.
Herman Hollerith invented a calculating machine that ran on electricity and used punched cards to store data.
Hollerith's machine was immensely successful.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Elements of a Computer System | 3 Hollerith founded the Tabulating Machine Company, which later became the computer and technology corporation known as IBM.
The first computer-like machine was the Mark I.
It was built, in 1944, jointly by IBM and Harvard University under the leadership of Howard Aiken.
Punched cards were used to feed data into the machine.
The Mark I was 52 feet long, weighed 50 tons, and had 750,000 parts.
In 1946, the Electronic Numerical Integrator and Calculator (ENIAC) was built at the University of Pennsylvania.
It contained 18,000 vacuum tubes and weighed some 30 tons.
The computers that we know today use the design rules given by John von Neumann in the late 1940s.
His design included components such as an arithmetic logic unit, a control unit, memory, and input/output devices.
These components are described in the next section.
Von Neumann's computer design makes it possible to store the programming instructions and the data in the same memory space.
In 1951, the Universal Automatic Computer (UNIVAC) was built and sold to the The United States Census Bureau.
In 1956, the invention of transistors resulted in smaller, faster, more reliable, and more energy-efficient computers.
This era also saw the emergence of the software development industry, with the introduction of FORTRAN and COBOL, two early programming languages.
In the next major technological advancement, transistors were replaced by small-sized integrated circuits, or "chips_0_" Chips are much smaller and more efficient than transistors, and with today's new  it can be made to contain thousands of circuits on a single chip.
They give computers tremendous processing speed.
In 1970, the microprocessor, an entire central processing unit (CPU) on a single chip, was invented.
In 1977, Stephen Wozniak and Steven Jobs designed and built the first Apple computer in their garage.
In 1981, IBM introduced its personal computer (PC).
In the 1980s, clones of the IBM PC made the personal computer even more affordable.
By the mid-1990s, people from many walks of life were able to afford them.
Computers continue to become faster and less expensive as  advances.
Modern-day computers are powerful, reliable, and easy to use.
They can accept spoken-word instructions and imitate human reasoning through artificial intelligence.
Expert systems assist doctors in making diagnoses.
Mobile computing applications are growing significantly.
Using hand-held devices, delivery drivers can access global positioning satellites (GPS) to verify customer locations for pickups and deliveries.
Cell phones permit you to check your e-mail, make airline reservations, see how stocks are performing, access your bank accounts, and communicate with family and friends via social media.
Although there are several categories of computers, such as mainframe, midsize, and micro, all computers share some basic elements, described in the next section.
Elements of a Computer System A computer is an electronic device capable of performing commands.
The basic commands that a computer performs are input (get data), output (display result), storage, and performance of arithmetic and logical operations.
There are two main components of a computer Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 1: An Overview of Computers and Programming Languages system: hardware and software.
In the next few sections, you will learn a brief overview of these components.
Let's look at hardware first.
Hardware Major hardware components include the central processing unit (CPU); main memory (MM), also called random access memory (RAM); input/output devices; and secondary storage.
Some examples of input devices are the keyboard, mouse, and secondary storage.
Examples of output devices are the screen, printer, and secondary storage.
Let's look at each of these components in greater detail.
Central Processing Unit and Main Memory The central processing unit is the "brain" of a computer and the most expensive piece of hardware in a computer.
The more powerful the CPU, the faster the computer.
Arithmetic and logical operations are carried out inside the CPU.
Figure 1-1(a) shows some hardware components.
Central Processing Main Memory Secondary Storage Input Device Output Device.
Memory Hardware components of a computer and main memory Main memory, or random access memory, is connected directly to the CPU.
All programs must be loaded into main memory before they can be executed.
Similarly, all data must be brought into main memory before a program can manipulate it.
When the computer is turned off, everything in main memory is lost.
Main memory is an ordered sequence of cells, called memory cells.
Each cell has a unique location in main memory, called the address of the cell.
These addresses help you access the information stored in the cell.
Figure 1-1(b) shows main memory with some data.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The Language of a Computer | 5 Today's computers come with main memory consisting of millions to billions of cells.
Although Figure 1-1(b) shows data stored in cells, the content of a cell can be either a programming instruction or data.
Moreover, this figure shows the data as numbers and letters.
However, as explained later in this chapter, main memory stores everything as sequences of 0s and 1s.
The memory addresses are also expressed as sequences of 0s and 1s.
SECONDARY STORAGE Because programs and data must be loaded into the main memory before processing and because everything in main memory is lost when the computer is turned off, information stored in main memory must be saved in some other device for permanent storage.
The device that stores information permanently (unless the device becomes unusable or you change the information by rewriting it) is called secondary storage.
To be able to transfer information from main memory to secondary storage, these components must be directly connected to each other.
Examples of secondary storage are hard disks, flash drives, and CD-ROMs.
Input /Output Devices For a computer to perform a useful task, it must be able to take in data and programs and display the results of calculations.
The devices that feed data and programs into computers are called input devices.
The keyboard, mouse, scanner, camera, and secondary storage are examples of input devices.
The devices that the computer uses to display results are called output devices.
A monitor, printer, and secondary storage are examples of output devices.
Software Software are programs written to perform specific tasks.
For example, word processors are programs that you use to write letters, papers, and even books.
All software is written in programming languages.
There are two types of programs: system programs and application programs.
System programs control the computer.
The system program that loads first when you turn on your computer is called the operating system.
Without an operating system, the computer is useless.
The operating system handles the overall activity of the computer and provides services.
Some of these services include memory management, input/output activities, and storage management.
The operating system has a special program that organizes secondary storage so that you can conveniently access information.
Some well-known operating systems are Windows 8, Mac OS X, Linux, and Android.
Application programs perform a specific task.
Word processors, spreadsheets, and games are examples of application programs.
The operating system is the program that runs application programs.
The Language of a Computer When you press A on your keyboard, the computer displays A on the screen.
But what is actually stored inside the computer's main memory.
What is the language of the computer.
How does it store whatever you type on the keyboard.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 1: An Overview of Computers and Programming Languages Remember that a computer is an electronic device.
Electrical signals are used inside the computer to process information.
There are two types of electrical signals: analog and digital.
Analog signals are continuously varying continuous wave forms used to represent such things as sound.
Audio tapes, for example, store data in analog signals.
Digital signals represent information with a sequence of 0s and 1s.
A 0 represents a low voltage, and a 1 represents a high voltage.
Digital signals are more reliable carriers of information than analog signals and can be copied from one device to another with exact precision.
You might have noticed that when you make a copy of an audio tape, the sound quality of the copy is not as good as the original tape.
On the other hand, when you copy a CD, the copy is the same as the original.
Computers use digital signals.
Because digital signals are processed inside a computer, the language of a computer, called machine language, is a sequence of 0s and 1s.
The digit 0 or 1 is called a binary digit, or bit.
Sometimes a sequence of 0s and 1s is referred to as a binary code or a binary number.
Bit: A binary digit 0 or 1.
A sequence of eight bits is called a byte.
Table 1-1 summarizes the terms used to describe various numbers of.
Byte Bits/Bytes 8 bits Kilobyte.
TB 1024 GB ¼ 210 GB ¼ 240  ¼ 1,099,511,627,776 Petabyte PB 1024 TB ¼ 210 TB ¼ 250  ¼ 1,125,899,906,842,624 Exabyte EB 1024 PB ¼ 210 PB ¼ 260  ¼ 1,152,921,504,606,846,976 Zettabyte ZB 1024 EB ¼ 210 EB ¼ 270  ¼ 1,180,591,620,717,411,303,424 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The Evolution of Programming Languages | 7 Every letter, number, or special symbol (such as * or {) on your keyboard is encoded as a sequence of bits, each having a unique representation.
The most commonly used encoding scheme on personal computers is the seven-bit American Standard Code for Information Interchange (ASCII).
The ASCII data set consists of 128 characters numbered 0 through 127.
That is, in the ASCII data set, the position of the first character is 0, the position of the second character is 1, and so on.
In this scheme, A is encoded as the binary number 1000001.
In fact, A is the 66th character in the ASCII character code, but its position is 65 because the position of the first character is 0.
Furthermore, the binary number 1000001 is the binary representation of 65.
The character 3 is encoded as 0110011.
Note that in the ASCII character set, the position of the character 3 is 51, so the character 3 is the 52nd character in the ASCII set.
It also follows that 0110011 is the binary representation of 51.
For a complete list of the printable ASCII character set, refer to Appendix C.
The number system that we use in our daily life is called the decimal system, or base 10.
Because everything inside a computer is represented as a sequence of 0s and 1s, that is, binary numbers, the number system that a computer uses is called binary, or base 2.
We indicated in the preceding paragraph that the number 1000001 is the binary representation of 65.
Appendix E describes how to convert a number from base 10 to base 2 and vice versa.
Inside the computer, every character is represented as a sequence of eight bits, that is, as a byte.
Now the eight-bit binary representation of 65 is 01000001.
Note that we added 0 to the left of the seven-bit representation of 65 to convert it to an eight-bit representation.
Similarly, we add one 0 to the binary value of 51 to get its eight-bit binary representation 00110011.
ASCII is a seven-bit code.
Therefore, to represent each ASCII character inside the computer, you must convert the seven-bit binary representation of an ASCII character to an eight-bit binary representation.
This is accomplished by adding 0 to the left of the seven-bit ASCII encoding of a character.
Hence, inside the computer, the character A is represented as 01000001, and the character 3 is represented as 00110011.
There are other encoding schemes, such as EBCDIC (used by IBM) and Unicode, which is a more recent development.
EBCDIC consists of 256 characters; Unicode consists of 65,536 characters.
To store a character belonging to Unicode, you need 16 bits or two.
Unicode was created to represent a variety of characters and is continuously expanding.
It consists of characters from languages other than English.
The Evolution of Programming Languages The most basic language of a computer, the machine language, provides program instructions in bits.
Even though most computers perform the same kinds of operations, the designers of the computer may have chosen different sets of binary codes to perform the operations.
Therefore, the machine language of one machine is not necessarily the same as the machine language of another machine.
The only consistency among computers is that in any modern computer, all data is stored and manipulated as binary codes.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 1: An Overview of Computers and Programming Languages Early computers were programmed in machine language.
To see how instructions are written in machine language, suppose you want to use the equation: = rate  hours to calculate weekly.
Further, suppose that the binary code 100100 stands for load, 100110 stands for multiplication, and 100010 stands for store.
In machine language, you might need the following sequence of instructions to calculate weekly : 100100 010001 100110 010010 100010 010011 To represent the weekly  equation in machine language, the programmer had to remember the machine language codes for various operations.
Also, to manipulate data, the programmer had to remember the locations of the data in the main memory.
This need to remember specific codes made programming not only very difficult, but also error prone.
Assembly languages were developed to make the programmer's job easier.
In assembly language, an instruction is an easy-to-remember form called a mnemonic.
For example, suppose LOAD stands for the machine code 100100, MULT stands for the machine code 100110 (multiplication), and STOR stands for the machine code 100010.
Using assembly language instructions, you can write the equation to calculate the weekly as follows: LOAD MULT STOR rate hours As you can see, it is much easier to write instructions in assembly language.
However, a computer cannot execute assembly language instructions directly.
The instructions first have to be translated into machine language.
A program called an assembler translates the assembly language instructions into machine language.
Assembler: A program that translates a program written in assembly language into an equivalent program in machine language.
Moving from machine language to assembly language made programming easier, but a programmer was still forced to think in terms of individual machine instructions.
The next step toward making programming easier was to devise high-level languages that were closer to natural languages, such as English, French, German, and Spanish.
Basic, FORTRAN, COBOL, C, Cplus_plus, C#, and Java are all high-level languages.
You will learn the high-level language Cplus_plus in this book.
In Cplus_plus, you write the weekly  equation as follows: = rate * hours; The instruction written in Cplus_plus is much easier to understand and is self-explanatory to a novice user who is familiar with basic arithmetic.
As in the case of assembly language, Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Processing a Cplus_plus Program | 9 however, the computer cannot directly execute instructions written in a high-level language.
To execute on a computer, these Cplus_plus instructions first need to be translated into machine language.
A program called a compiler translates instructions written in high-level languages into machine code.
Compiler: A program that translates instructions written in a high-level language into the equivalent machine language.
Processing a Cplus_plus Program In the previous sections, we discussed machine language and high-level languages and showed a Cplus_plus statement.
Because a computer can understand only machine language, you are ready to review the steps required to process a  written in Cplus_plus.
Recall that a computer can understand only machine language.
Therefore, in order to run this  successfully, the code must first be translated into machine language.
In this section, we review the steps required to execute programs written in Cplus_plus.
The following steps, as shown in Figure 1-2, are necessary to process a Cplus_plus.
You use a text editor to create a Cplus_plus  following the rules, or syntax, of the high-level language.
This  is called the source code, or source.
The  must be saved in a text file that has the extension _0_cpp.
For example, if you saved the preceding in the file named FirstCPPProgram, then its complete name is FirstCPPProgram_0_cpp.
Source : A  written in a high-level language.
The Cplus_plus  given in the preceding section contains the statement # <iostream>.
In a Cplus_plus , statements that begin with the symbol # are called preprocessor directives.
These statements are processed by a  called preprocessor.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 1: An Overview of Computers and Programming Languages After processing preprocessor directives, the next step is to verify that the obeys the rules of the programming language—that is, the  is syntactically correct—and translate the  into the equivalent machine language.
The compiler checks the source  for syntax errors and, if no error is found, translates the  into the equivalent machine language.
The equivalent machine language  is called an object.
Object : The machine language version of the high-level language.
The programs that you write in a high-level language are developed using an integrated development environment (IDE).
The IDE contains many programs that are useful in creating your.
For example, it contains the necessary code () to display the results of the  and several mathematical functions to make the programmer's job somewhat easier.
Therefore, if certain code is already available, you can use this code rather than writing your own code.
Once the  is developed and successfully compiled, you must still bring the code for the resources used from the IDE into your  to produce a final  that the computer can execute.
This prewritten code () resides in a place called the library.
A called a linker combines the object  with the programs from libraries.
Linker: A  that combines the object  with other programs in the library and is used in the  to create the executable code.
You must next load the executable  into main memory for execution.
A  called a loader accomplishes this task.
Loader: A  that loads an executable  into main memory.
The final step is to execute the.
Figure 1-2 shows how a typical Cplus_plus  is processed.
Cplus_plus Program Editor Step 1.
Compiler Syntax Error Step 3.
Processing a Cplus_plus Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming with the Problem Analysis–Coding–Execution Cycle | 11 As a programmer, you mainly need to be concerned with Step 1.
That is, you must learn, understand, and master the rules of the programming language to create source programs.
As noted earlier, programs are developed using an IDE.
Well-known IDEs used to create programs in the high-level language Cplus_plus  Visual Cplus_plus 2012 Express and Visual Studio 2012 (from Microsoft), and Cplus_plus Builder (from Borland).
You can also use DevCplus_plus IDE from Bloodshed Software to create and test Cplus_plus programs.
These IDEs contain a text editor to create the source , a compiler to check the source for syntax errors, a  to link the object code with the IDE resources, and a  to execute the.
These IDEs are quite user friendly.
When you compile your , the compiler not only identifies the syntax errors, but also typically suggests how to correct them.
Moreover, with just a simple command, the object code is linked with the resources used from the IDE.
For example, the command that does the linking on Visual Cplus_plus 2012 Express and Visual Studio 2012 is Build or Rebuild.
The Web site http://msdn_0_microsoft_0_com/en-us/library/vstudio/ms235629_0_aspx explains how to use Visual Cplus_plus 2012 Express and Visual Studio 2012 to create a Cplus_plus.
Programming with the Problem Analysis–Coding–Execution Cycle Programming is a process of problem solving.
Different people use different techniques to solve problems.
Some techniques are nicely outlined and easy to follow.
They not only solve the problem, but also give insight into how the solution is reached.
These problemsolving techniques can be easily modified if the domain of the problem changes.
To be a good problem solver and a good programmer, you must follow good problem-solving techniques.
One common problem-solving technique includes analyzing a problem, outlining the problem requirements, and designing steps, called an algorithm, to solve the problem.
Algorithm: A step-by-step problem-solving process in which a solution is arrived at in a finite amount of time.
In a programming environment, the problem-solving process requires the following three steps: 1.
Analyze and outline the problem and its solution requirements, and design an algorithm to solve the problem.
Implement the algorithm in a programming language, such as Cplus_plus, and verify that the algorithm works.
Maintain the program by using and modifying it if the problem domain changes.
Figure 1-3 summarizes the first two steps of this programming process.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Problem Analysis Algorithm Design Coding Preprocessor Compiler Library Error No Error Linker Loader.
Error No Error Results FIGURE 1-3 Problem analysis–coding–execution cycle To develop a program to solve a problem, you start by analyzing the problem.
You then design the algorithm; write the program instructions in a high-level language, or code the program; and enter the program into a computer system.
Analyzing the problem is the first and most important step.
This step requires you to do the following: 1.
Thoroughly understand the problem.
Understand the problem requirements.
Requirements can include whether the program requires interaction with the user, whether it manipulates data, Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming with the Problem Analysis–Coding–Execution Cycle |.
If the program manipulates data, the programmer must know what the data is and how it is represented.
That is, you need to look at sample data.
If the program produces output, you should know how the results should be generated and formatted.
If the problem is complex, divide the problem into subproblems and repeat Steps 1 and 2.
That is, for complex problems, you need to analyze each subproblem and understand each subproblem's requirements.
After you carefully analyze the problem, the next step is to design an algorithm to solve the problem.
If you break the problem into subproblems, you need to design an algorithm for each subproblem.
Once you design an algorithm, you need to check it for correctness.
You can sometimes test an algorithm's correctness by using sample data.
At other times, you might need to perform some mathematical analysis to test the algorithm's correctness.
Once you have designed the algorithm and verified its correctness, the next step is to convert it into an equivalent programming code.
You then use a text editor to enter the programming code or the program into a computer.
Next, you must make sure that the program follows the language's syntax.
To verify the correctness of the syntax, you run the code through a compiler.
If the compiler generates error messages, you must identify the errors in the code, remove them, and then run the code through the compiler again.
When all the syntax errors are removed, the compiler generates the equivalent machine code, the linker links the machine code with the system's resources, and the loader places the program into main memory so that it can be executed.
The final step is to execute the program.
The compiler guarantees only that the program follows the language's syntax.
It does not guarantee that the program will run correctly.
During execution, the program might terminate abnormally due to logical errors, such as division by zero.
Even if the program terminates normally, it may still generate erroneous results.
Under these circumstances, you may have to reexamine the code, the algorithm, or even the problem analysis.
Your overall programming experience will be successful if you spend enough time to complete the problem analysis before attempting to write the programming instructions.
Usually, you do this work on paper using a pen or pencil.
Taking this careful approach to programming has a number of advantages.
It is much easier to find errors in a program that is well analyzed and well designed.
Furthermore, a carefully analyzed and designed program is much easier to follow and modify.
Even the most experienced programmers spend a considerable amount of time analyzing a problem and designing an algorithm.
Throughout this book, you will not only learn the rules of writing programs in Cplus_plus, but you will also learn problem-solving techniques.
Most of the chapters contain programming examples that discuss programming problems.
These programming examples teach techniques of how to analyze and solve problems, design algorithms, code the algorithms into Cplus_plus, and also help you understand the concepts discussed in the chapter.
To gain the full benefit of this book, we recommend that you work through these programming examples.
Next, we provide examples of various problem-analysis and algorithm-design techniques.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 1: An Overview of Computers and Programming Languages EXAMPLE 1-1 In this example, we design an algorithm to find the  and  of a rectangle.
To find the  and  of a rectangle, you need to know the rectangle's length and width.
The  and  of the rectangle are then given by the following formulas: = 2 = length   width The algorithm to find the  and  of the rectangle is: 1.
Get the length of the rectangle.
Get the width of the rectangle.
Find the  using the following equation: = 2 4.
Find the  using the following equation: = length  width EXAMPLE 1-2 In this example, we design an algorithm that calculates the sales tax and the price of an item sold in a particular state.
The sales tax is calculated as follows: The state's portion of the sales tax is 4%, and the city's portion of the sales tax is 1_0_5%.
If the item is a luxury item, such as a car more than $50,000, then there is a 10% luxury tax.
To calculate the price of the item, we need to calculate the state's portion of the sales tax, the city's portion of the sales tax, and, if it is a luxury item, the luxury tax.
Suppose salePrice denotes the selling price of the item,  denotes the state's sales tax,  denotes the city's sales tax, luxuryTax denotes the luxury tax, salesTax denotes the total sales tax, and amountDue denotes the final price of the item.
To calculate the sales tax, we must know the selling price of the item and whether the item is a luxury item.
The  and  can be calculated using the following formulas: = salePrice  0_0_04 = salePrice  0_0_015 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming with the Problem Analysis–Coding–Execution Cycle | 15 Next, you can determine  as follows: = salePrice  0_0_1 otherwise = 0 Next, you can determine  as follows: =  +  + Finally, you can calculate  as follows: = salePrice + The algorithm to determine  and  is, therefore: 1.
Get the selling price of the item.
Determine whether the item is a luxury item.
Find the state's portion of the sales tax using the formula: = salePrice 4.
Find  using the formula: =  +  + 7.
Find  using the formula: = salePrice + EXAMPLE 1-3 Watch the Video In this example, we design an algorithm that calculates the monthly paycheck of a salesperson at a local department store.
Every salesperson has a base salary.
The salesperson also receives a bonus at the end of each month, based on the following criteria: If the salesperson has been with the store for five years or less, the bonus is $10 for each year that he or she has worked there.
If the salesperson has been with the store for more than five years, the bonus is $20 for each year that he or she has worked there.
The salesperson can earn an additional bonus as follows: If the total sales made Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 1: An Overview of Computers and Programming Languages by the salesperson for the month are at least $5,000 but less than $10,000, he or she receives a 3% commission on the sale.
If the total sales made by the salesperson for the month are at least $10,000, he or she receives a 6% commission on the sale.
To calculate a salesperson's monthly paycheck, you need to know the base salary, the number of years that the salesperson has been with the company, and the total sales made by the salesperson for that month.
Suppose baseSalary denotes the base salary, noOfServiceYears denotes the number of years that the salesperson has been with the store,  denotes the , totalSales denotes the total sales made by the salesperson for the month, and denotes the additional.
You can determine the  as follows: = 10  noOfServiceYears otherwise = 20  noOfServiceYears Next, you can determine the additional  of the salesperson as follows: = 0 otherwise if (totalSales is greater than or equal to 5000 and otherwise Following the above discussion, you can now design the algorithm to calculate a salesperson's monthly paycheck: 1.
Calculate  using the following formula: = 10  noOfServiceYears otherwise = 20  noOfServiceYears 4.
Calculate  using the following formula: = 0 otherwise if (totalSales is greater than or equal to 5000 and otherwise Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming with the Problem Analysis–Coding–Execution Cycle |.
The objective is to randomly generate an integer greater than or equal to 0 and less than 100.
Then prompt the player (user) to guess the number.
If the player guesses the number correctly, output an appropriate message.
Otherwise, check whether the guessed number is less than the random number.
If the guessed number is less than the random number generated, output the message, "Your guess is lower than the number.
Guess again_0_"; otherwise, output the message, "Your guess is higher than the number.
Then prompt the player to enter another number.
The player is prompted to guess the random number until the player enters the correct number.
The first step is to generate a random number, as described above.
Cplus_plus provides the means to do so, which is discussed in Chapter 5.
Suppose num stands for the random number and guess stands for the number guessed by the player.
After the player enters the guess, you can compare the guess with the random number as follows: otherwise You can now design an algorithm as follows: 1.
Generate a random number and call it num.
Repeat the following steps until the player has guessed the correct number: a.
Prompt the player to enter guess.
Check the value of guess.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 1: An Overview of Computers and Programming Languages EXAMPLE 1-5 There are 10 students in a class.
Each student has taken five tests, and each test is worth 100 points.
We want to design an algorithm to calculate the grade for each student, as well as the class average.
The grade is assigned as follows: If the average test score is greater than or equal to 90, the grade is A; if the average test score is greater than or equal to 80 and less than 90, the grade is B; if the average test score is greater than or equal to 70 and less than 80, the grade is C; if the average test score is greater than or equal to 60 and less than 70, the grade is D; otherwise, the grade is F.
Note that the data consists of students' names and their test scores.
This is a problem that can be divided into subproblems as follows: There are five tests, so you design an algorithm to find the average test score.
Next, you design an algorithm to determine the grade.
The two subproblems are to determine the average test score and to determine the grade.
Let us first design an algorithm to determine the  test score.
To find the  test score, add the five test scores and then divide the sum by 5.
Therefore, the algorithm is the following: 1.
Get the five test scores.
Add the five test scores.
Suppose sum stands for the sum of the test scores.
Suppose  stands for the  test score.
Then = sum / 5; Next, you design an algorithm to determine the.
Suppose  stands for the assigned to a student.
The following algorithm determines the : if  is greater than or equal to 90 = A otherwise if  is greater than or equal to 80 = B otherwise if  is greater than or equal to 70 = C otherwise if  is greater than or equal to 60 = D otherwise = F You can use the solutions to these subproblems to design the main algorithm as follows: 1.
Get student's name.
Use the algorithm as discussed above to find the  test score.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming with the Problem Analysis–Coding–Execution Cycle | 19 c.
Use the algorithm as discussed above to find the.
Update  by adding the current student's  test score.
Determine the class  as follows: =  / 10 A programming exercise in Chapter 8 asks you to write a Cplus_plus program to calculate the test score and  for each student in a class.
Earlier in this chapter, we described the problem analysis, coding, and execution cycle.
In this section, we gave various examples to illustrate the problem analysis and coding cycle.
It must be pointed out that problem analysis is the most important part of programming.
Once you have analyzed the problem and written the necessary steps of the solution in your native language, then, as you will see throughout the text, writing the Cplus_plus code to implement your solution is relatively easy.
In addition, soon you will recognize that the steps of your solutions can be effecively translated into a Cplus_plus code.
Furthermore, a good problem analysis will lead to a better and cleaner program.
Even though we have not yet introduced the syntax of Cplus_plus, to illustrate how to write a Cplus_plus code corresponding to the steps of your solution, let us consider the algorithm designed in Example 1-1.
Suppose length, width, perimeter, and area represents the length, width, perimeter, and area of a rectangle.
Here are the four steps of the algorithm and their corresponding Cplus_plus statement: Algorithm Step.
Consider the first statement.
In Cplus_plus, cin stands for common input.
During program execution, the code associated with it instructs the user to input data and if the user enters a valid datum, then that datum will be stored in the memory, that is, will become the value of length.
The Cplus_plus code in Step 3 uses the values of length and width to compute the , which then is assigned to.
In order to write a complete Cplus_plus program to compute the  and , you need to know the basic structure of a Cplus_plus program, which will be introduced in the next chapter.
However, if you are curious to know how the complete Cplus_plus program looks, you can visit the Web site accompanying this book and look at the programming code stored in the file Ch1_Example_1-1_Code_0_cpp.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 1: An Overview of Computers and Programming Languages Programming Methodologies Two popular approaches to programming design are the structured approach and the object-oriented approach, which are outlined below.
Structured Programming Dividing a problem into smaller subproblems is called structured design.
Each subproblem is then analyzed, and a solution is obtained to solve the subproblem.
The solutions to all of the subproblems are then combined to solve the overall problem.
This process of implementing a structured design is called structured programming.
The structured-design approach is also known as top-down design, bottom-up design, stepwise refinement, and modular programming.
Object-Oriented Programming Object-oriented design (OOD) is a widely used programming methodology.
In OOD, the first step in the problem-solving process is to identify the components called objects, which form the basis of the solution, and to determine how these objects interact with one another.
For example, suppose you want to write a program that automates the video rental process for a local video store.
The two main objects in this problem are the video and the customer.
After identifying the objects, the next step is to specify for each object the relevant data and possible operations to be performed on that data.
For example, for a video object, the data might include:.
An object combines data and operations on the data into a single unit.
In OOD, the final program is a collection of interacting objects.
A programming language that implements OOD is called an object-oriented programming (OOP) language.
You will learn about the many advantages of OOD in later chapters.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Methodologies | 21 Because an object consists of data and operations on that data, before you can design and use objects, you need to learn how to represent data in computer memory, how to manipulate data, and how to implement operations.
In Chapter 2, you will learn the basic data types of Cplus_plus and discover how to represent and manipulate data in computer memory.
Chapter 3 discusses how to input data into a Cplus_plus program and output the results generated by a Cplus_plus program.
To create operations, you write algorithms and implement them in a programming language.
Because a data element in a complex program usually has many operations, to separate operations from each other and to use them effectively and in a convenient manner, you use functions to implement algorithms.
After a brief introduction in Chapters 2 and 3, you will learn the details of functions in Chapter 6.
Certain algorithms require that a program make decisions, a process called selection.
Other algorithms might require certain statements to be repeated until certain conditions are met, a process called repetition.
Still other algorithms might require both selection and repetition.
You will learn about selection and repetition mechanisms, called control structures, in Chapters 4 and 5.
Also, in Chapter 8, using a mechanism called an array, you will learn how to manipulate data when data items are of the same type, such as items in a list of sales figures.
Finally, to work with objects, you need to know how to combine data and operations on the data into a single unit.
In Cplus_plus, the mechanism that allows you to combine data and operations on the data into a single unit is called a class.
You will learn how classes work, how to work with classes, and how to create classes in the chapter Classes and Data Abstraction (later in this book).
As you can see, you need to learn quite a few things before working with the OOD methodology.
To make this learning easier and more effective, this book purposely divides control structures into two chapters (Chapter 4—selection; Chapter 5— repetition).
For some problems, the structured approach to program design will be very effective.
Other problems will be better addressed by OOD.
For example, if a problem requires manipulating sets of numbers with mathematical functions, you might use the structured design approach and outline the steps required to obtain the solution.
The Cplus_plus library supplies a wealth of functions that you can use effectively to manipulate numbers.
On the other hand, if you want to write a program that would make a candy machine operational, the OOD approach is more effective.
Cplus_plus was designed especially to implement OOD.
Furthermore, OOD works well with structured design.
Both the structured design and OOD approaches require that you master the basic components of a programming language to be an effective programmer.
In Chapters 2 to 8, you will learn the basic components of Cplus_plus, such as data types, input/output, control structures, user-defined functions, and arrays, required by either type of programming.
We develop and illustrate how these concepts work using the structured programming approach.
Starting with the chapter Classes and Data Abstraction, we develop and use the OOD approach.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 1: An Overview of Computers and Programming Languages ANSI/ISO Standard Cplus_plus The programming language Cplus_plus evolved from C and was designed by Bjarne Stroustrup at Bell Laboratories in the early 1980s.
From the early 1980s through the early 1990s, several Cplus_plus compilers were available.
Even though the fundamental features of Cplus_plus in all compilers were mostly the same, the Cplus_plus language, referred to in this book as Standard Cplus_plus, was evolving in slightly different ways in different compilers.
As a consequence, Cplus_plus programs were not always portable from one compiler to another.
To address this problem, in the early 1990s, a joint committee of the American National Standards Institute (ANSI) and International Organization for Standardization (ISO) was established to standardize the syntax of.
In mid-1998, ANSI/ISO  language were approved.
Most of today's compilers comply with these new.
Over the last several years, the  committee met several times to further standardize the syntax of.
In 2011, the second  of  was approved.
The main objective of this , referred to as 11, is to make the  code cleaner and more effective.
For example, the new  introduces the data type long long to deal with large integers, auto declaration of variables using initialization statements, enhancing the functionality of for loops to effectively work with arrays and containers, and new algorithms.
Some of these new  features are introduced in this book.
This book focuses on the syntax of  as approved by ANSI/ISO, referred to as ANSI/ ISO Standard.
QUICK REVIEW 1.
A computer is an electronic device capable of performing arithmetic and logical operations.
A computer system has two components: hardware and software.
The central processing unit (CPU) and the main memory are examples of hardware components.
All programs must be brought into main memory before they can be executed.
When the power is switched off, everything in main memory is lost.
Secondary storage provides permanent storage for information.
Hard disks, flash drives, and CD-ROMs are examples of secondary storage.
Input to the computer is done via an input device.
Two common input devices are the keyboard and the mouse.
The computer sends its output to an output device, such as the computer screen or a printer.
Software are programs run by the computer.
The operating system handles the overall activity of the computer and provides services.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Quick Review | 11.
Every computer directly understands its own machine language.
A bit is a binary digit, 0 or 1.
A byte is a sequence of eight bits.
A sequence of 0s and 1s is referred to as a binary code or a binary number.
One kilobyte (KB) is 210 ¼ 1024 bytes; one megabyte (MB) is 220 ¼ 1,048,576 bytes; one gigabyte (GB) is 230 ¼ 1,073,741,824 bytes; one terabyte (TB) is 240 ¼ 1,099,511,627,776 bytes; one petabyte (PB) is 250 ¼ 1,125,899,906,842,624 bytes; one exabyte (EB) is 260 ¼ 1,152,921,504,606,846,976 bytes; and one zettabyte (ZB) is 270 ¼ 1,180,591,620,717,411,303,424 bytes.
Assembly language uses easy-to-remember instructions called mnemonics.
Assemblers are programs that translate a program written in assembly language into machine language.
Compilers are programs that translate a program written in a high-level language into machine code, called object code.
A linker links the object code with other programs provided by the integrated development environment (IDE) and used in the program to produce executable code.
Typically, six steps are needed to execute a  program: edit, preprocess, compile, link, load, and execute.
A loader transfers executable code into main memory.
An algorithm is a step-by-step problem-solving process in which a solution is arrived at in a finite amount of time.
The problem-solving process has three steps: analyze the problem and design an algorithm, implement the algorithm in a programming language, and maintain the program.
In structured design, a problem is divided into smaller subproblems.
Each subproblem is solved, and the solutions to all of the subproblems are then combined to solve the problem.
In object-oriented design (OOD), a program is a collection of interacting objects.
An object consists of data and operations on that data.
The ANSI/ISO Standard  syntax was approved in mid-1998.
The second  of , 11, was approved in 2011.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 1: An Overview of Computers and Programming Languages EXERCISES The number in parentheses at the end of an exercise refers to the learning objective listed at the beginning of the chapter.
Mark the following statements as true or false.
The calculating device Pascaline could perform only addition and A program written in a high-level programming language is called a source A linker links and loads the object code from main memory into the CPU Describe the three steps of the problem-solving process in a programming What are the advantages of problem analysis and algorithm design over directly writing a Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The four test scores and their respective weights are given in the following testScore1 weightTestScore1 _0__0_.
For example, sample data is as follows: 75 95 85 65 16.
After marking up the prices, each item is put on sale at a discount of 10%.
Design an algorithm to find the selling price of an item sold at the The volume of a sphere is (4_0_0/3_0_0)pr3 and the surface is 4_0_0pr2, where r is the radius of the sphere.
Given the radius, design an algorithm that computes the volume and surface area of the sphere.
Also using the Cplus_plus statements provided for Example 1-1, write the Cplus_plus statement corresponding to each statement in Tom and Jerry opened a new  service.
They provide three types of services: mowing, fertilizing, and planting trees.
The cost of mowing is $35_0_00 per 5000 square yards, fertilizing is $30_0_00 per application, and planting a tree is $50_0_00.
Write an algorithm that prompts the user to enter the area of the , the number of fertilizing applications, and the number of trees to be planted.
The algorithm then determines the billing amount.
If the total cost of the items ordered, at one time, is $200 or more, then the shipping and handling is free; otherwise, the shipping and handling is $10 per item.
Design an algorithm that prompts Jason to enter the number of items ordered and the price of each item.
The algorithm then outputs the total billing amount.
Your algorithm must use a loop (repetition structure) to get the price of each item.
If a customer withdraws more than $300, the service charge is 4% of the amount over $300.
If the customer does not have sufficient money in the account, the ATM informs the customer about the insufficient funds and gives the customer the option to withdraw the money for a service charge of $25_0_00.
If there is no Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 1: An Overview of Computers and Programming Languages money in the account or if the account balance is negative, the ATM does not allow the customer to withdraw any money.
If the amount to be withdrawn is greater than $500, the ATM informs the customer about the maximum amount that can be withdrawn.
Write an algorithm that allows the customer to enter the amount to be withdrawn.
The algorithm then checks the total amount in the account, dispenses the money to the customer, and debits the Design an algorithm to find the real roots of a quadratic equation of the form A student spends a majority of his weekend playing and watching sports, thereby tiring him out and leading him to oversleep and often miss his Monday 8 AM math class.
Suppose that the tuition per semester is $25,000 and the average semester consists of 15 units.
If the math class meets three days a week, one hour each day for 15 weeks, and is a four unit course, how much does each hour of math class cost the student.
Design an algorithm that computes the cost You are given a list of students names and their test scores.
Design an algorithm that does the following: a.
Calculates the average test scores.
Determines and prints the names of all the students whose test scores are below the average test score.
Determines the highest test score.
Prints the names of all the students whose test scores are the same as the highest test score.
The second subproblem determines and prints the names of all the students whose test scores are below the average test score.
The third subproblem determines the highest test score.
The fourth subproblem prints the names of all the students whose test scores are the same as the highest test score.
The main Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Become familiar with the basic components of a Cplus_plus program, including functions, special symbols, and identifiers 2.
Explore how to properly structure a program, including using comments to document a program 14.
Learn how to write a Cplus_plus program Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
As your objective is to learn the Cplus_plus programming language, two questions naturally arise.
First, what is a computer program.
Second, what is programming.
A computer program, or a program, is a sequence of statements whose objective is to accomplish a task.
Programming is a process of planning and creating a program.
These two definitions tell the truth, but not the whole truth, about programming.
It may very well take an entire book to give a good and satisfactory definition of programming.
You might gain a better grasp of the nature of programming from an analogy, so let us turn to a topic about which almost everyone has some knowledge—cooking.
A recipe is also a program, and everyone with some cooking experience can agree on the following: 1.
It is usually easier to follow a recipe than to create one.
Some  are easy to follow and some are not easy to follow.
Some  produce reliable results and some do not.
You must have some knowledge of how to use cooking tools to follow a recipe to completion.
To create good new , you must have a lot of knowledge and a good understanding of cooking.
These same six points are also true about programming.
Let us take the cooking analogy one step further.
Suppose you need to teach someone how to become a chef.
Would you first introduce the person to good food, hoping that a taste for good food develops.
Would you have the person follow recipe after recipe in the hope that some of it rubs off.
Or would you first teach the use of tools and the nature of ingredients, the foods and spices, and explain how they fit together.
Just as there is disagreement about how to teach cooking, there is disagreement about how to teach programming.
Learning a programming language is like learning to become a chef or learning to play a musical instrument.
All three require direct interaction with the tools.
You cannot become a good chef just by reading.
Similarly, you cannot become a musician by reading books about musical instruments.
The same is true of programming.
You must have a fundamental knowledge of the language, and you must test your programs on the computer to make sure that each program does what it is supposed to do.
A Quick Look at a Cplus_plus Program In this chapter, you will learn the basic elements and concepts of the Cplus_plus programming language to create Cplus_plus programs.
In addition to giving examples to illustrate various concepts, we will also show Cplus_plus programs to clarify these concepts.
In this section, we provide an example of a Cplus_plus program that computes the perimeter and area of a Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
A Quick Look at a Cplus_plus Program | 29 rectangle.
At this point you need not be too concerned with the details of this program.
You only need to know the effect of an output statement, which is introduced in this program.
In Example 1-1 (Chapter 1), we designed an algorithm to find the perimeter and area of a rectangle.
Given the length and width of a rectangle, the Cplus_plus program, in Example 2-1, computes and displays the perimeter and area.
Sample Run: (When you compile and execute this program, the following five lines are Program to compute and output the  and  of a.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 2: Basic Elements of Cplus_plus These lines are displayed by the execution of the following statements: << " of a _0_" << endl; cout cout cout cout << << << <<.
It causes the computer to evaluate the expression after the pair of symbols << and display the result on the screen.
A Cplus_plus program can contain various types of expressions such as arithmetic and strings.
For example,  +  is an arithmetic expression.
Anything in double quotes is a string.
For example, "Program to compute and output the  and " is a string.
Similarly, " of a _0_" is also a string.
Typically, a string evaluates to itself.
Arithmetic expressions are evaluated according to rules of arithmetic operations, which you typically learn in an arithmetic course.
Later in this chapter, we will explain how arithmetic expressions and strings are formed and evaluated.
Also note that in an output statement, endl causes the insertion point to move to the beginning of the next line.
Also, on the screen, the insertion point is where the cursor is_0_) Therefore, the preceding statement causes the system to display the following line on the screen.
Program to compute and output the  and  of a.
Let us now consider the following statement: << " = " <<  << endl; This output statement consists of two expressions.
The first expression, ( the first <<), is " = " and the second expression, ( the second <<), consists of the identifier The expression " = " is a string and evaluates to itself.
Because the value assigned to  in the program is 6_0_0,  evaluates to 6_0_0.
Therefore, the output of the preceding statement is: = 6 Note that the value of  is output as 6 not as 6_0_0.
We will explain in the next chapter how to force the program to output the value of  as 6_0_0.
The meaning of the remaining output statements is similar.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
A Quick Look at a Cplus_plus Program |.
We will elaborate on this statement later in this chapter.
Before we identify various parts of a Cplus_plus program, let's look at one more output statement.
Consider the following statement: << "7 + 8 = " << 7 + 8 << endl; In this output statement, the  "7 + 8 = ", which is a string, evaluates to itself.
Let us consider the second , 7 + 8.
This  consists of the numbers 7 and 8, and the Cplus_plus arithmetic operator +.
Therefore, the result of the  7 + 8 is the sum of 7 and 8, which is 15.
Thus, the output of the preceding statement is: 7 + 8 = 15 In this chapter, until we explain how to properly construct a Cplus_plus program, we will be using output statements such as the preceding ones to explain various concepts.
After finishing Chapter 2, you should be able to write Cplus_plus programs well enough to do some computations and show results.
Next, let us note the following about the previous Cplus_plus program.
A Cplus_plus program is a collection of functions, one of which is the function main.
Roughly speaking, a function is a set of statements whose objective is to accomplish something.
The preceding program consists of only the function main; all Cplus_plus programs require a function main.
The first four lines of the program begins with the pair of symbols // (shown in green), which are comments.
Comments are for the user; they typically explain the purpose of the programs, that is, the meaning of the statements.
It means that if you do not this statement, then  should be used as std:: and endl should be used as std::endl.
We will elaborate on this later in this chapter.
Next consider the following line: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Chapter 2: Basic Elements of Cplus_plus This is the heading of the function main.
The next line consists of a left brace.
This marks the beginning of the (body) of the function main.
The right brace (at the last line of the program) matches this left brace and marks the end of the body of the function main.
We will explain the meaning of the other terms, such as the ones shown in blue, later in this book.
Note that in Cplus_plus, << is an operator, called the stream insertion operator.
Before ending this section, let us identify certain parts of the Cplus_plus program in Figure 2-1.
An output statement instructs the system to display results.
Various parts of a Cplus_plus program Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
A Quick Look at a Cplus_plus Program | 33 One of the terms that you will encounter throughout the text and that is also identified in Figure 2-1 is variable.
Therefore, we introduce this term in this section.
Recall from Chapter 1 that all data must be loaded into main memory before it can be manipulated.
For example, given the  and , the program in Figure 2-1 computes and outputs the  and  of a.
This means that the values of  and must be stored in main memory.
Also, recall from Chapter 1 that main memory is an ordered sequence of cells and every cell has an address.
Inside the computer, the address of a memory cell is in binary.
Once we store the values of  and , and because these values might be needed in more than one place in a program, we would like to know the locations where these values are stored and how to access those memory locations.
Cplus_plus makes it easy for a programmer to specify the locations because the programmer can supply an alphabetic name for each of those locations.
Of course, we must follow the rules to specify the names.
For example, in the program in Figure 2-1, we are telling the system to allocate four memory spaces and name them , , , and , respectively.
Also during program execution, the system will allocate four memory locations large enough to store decimal numbers and those memory locations will be named , , , and , respectively, see Figure 2-2.
Memory allocation The statement  = 6_0_0; will cause the system to store 6_0_0 in the memory location associated with the name (or identified by the name) , see Figure 23.
Examples 2-14 and 2-19 further illustrate how data is manipulated in variables.
Memory spaces after the statement  = 6_0_0; executes As we proceed through this chapter, we will explain the meaning of the remaining parts identified in Figure 2-1.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 2: Basic Elements of Cplus_plus The Basics of a Cplus_plus Program In the previous section, we gave an example of a Cplus_plus program and also identified certain parts of the program.
In general, a Cplus_plus program is a collection of one or more subprograms, called functions.
Roughly speaking, a subprogram or a function is a collection of statements, and when it is activated, or executed, it accomplishes something.
Some functions, called predefined or standard functions, are already written and are provided as part of the system.
But to accomplish most tasks, programmers must learn to write their own functions.
Thus, if a Cplus_plus program has only one function, it must be the function main.
Until Chapter 6, other than using some of the predefined functions, you will mainly deal with the function main.
By the end of this chapter, you will have learned how to write programs consisting only of the function main.
If you have never seen a program written in a programming language, the Cplus_plus program in Example 2-1 may look like a foreign language.
To make meaningful sentences in a foreign language, you must learn its alphabet, words, and grammar.
To write meaningful programs, you must learn the programming language's special symbols, words, and syntax rules.
The syntax rules tell you which statements (instructions) are legal or valid, that is, which are accepted by the programming language and which are not.
You must also learn semantic rules, which determine the meaning of the instructions.
The programming language's rules, symbols, and special words enable you to write programs to solve problems.
Programming language: A set of rules, symbols, and special words.
In the remainder of this section, you will learn about some of the special symbols of a Cplus_plus program.
Additional special symbols are introduced as other concepts are encountered in later chapters.
Similarly, syntax and semantic rules are introduced and discussed throughout the book.
Comments The program that you write should be clear not only to you, but also to the reader of your program.
Part of good programming is the inclusion of comments in the program.
Typically, comments can be used to identify the authors of the program, give the date when the program is written or modified, give a brief explanation of the program, and explain the meaning of key statements in a program.
In the programming examples, for the programs that we write, we will not include the date when the program is written, consistent with the standard convention for writing such books.
Comments are for the reader, not for the compiler.
So when a compiler compiles a program to check for the syntax errors, it completely ignores comments.
Throughout this book, comments are shown in green.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The Basics of a Cplus_plus Program |.
The program in Example 2-1 contains the following comments: //**************************************************************.
Single-line comments begin with // and can be placed anywhere in the line.
Everything encountered in that line after // is ignored by the compiler.
For example, consider the following statement: << "7 + 8 = " << 7 + 8 << endl;.
This comment could be meaningful for a beginning programmer.
Multiple-line comments are enclosed between /* and */.
The compiler ignores anything that appears between /* and */.
For example, the following is an example of a multiple-line comment: /* You can include comments that can occupy several lines.
Cplus_plus's tokens are divided into special symbols, word symbols, and identifiers.
Following are some of the special symbols: +.
The second row consists of punctuation marks taken from English grammar.
Note that the comma is also a special symbol.
In Cplus_plus, commas are used to separate items in a list.
Semicolons are also special symbols and are used to end a Cplus_plus statement.
Note that a blank, which is not shown above, is also a special symbol.
You create a blank symbol by pressing the space bar (only once) on the keyboard.
The third row consists of Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 2: Basic Elements of Cplus_plus tokens made up of two characters that are regarded as a single symbol.
No character can come between the two characters in the token, not even a blank.
A second category of tokens is reserved word symbols.
Some of the reserved word symbols include the following: int, float, double, char, const, void, return Reserved words are also called keywords.
The letters that make up a reserved word are always lowercase.
Like the special symbols, each is considered to be a single symbol.
Furthermore, reserved words cannot be redefined within any program; that is, they cannot be used for anything other than their intended use.
For a complete list of reserved words, see Appendix A.
Throughout this book, reserved words are shown in blue.
Identifiers A third category of tokens is identifiers.
Identifiers are names of things that appear in programs, such as variables, constants, and functions.
All identifiers must obey Cplus_plus's rules for identifiers.
Some identifiers are predefined; others are defined by the user.
In the Cplus_plus program in Example 2-1,  is a predefined identifier and length is a user-defined identifier.
Two predefined identifiers that you will encounter frequently are  and cin.
You have already seen the effect of.
Later in this chapter, you will learn how cin, which is used to input data, works.
Unlike reserved words, predefined identifiers can be redefined, but it would not be wise to do so.
Identifiers can be made of only letters, digits, and the underscore character; no other symbols are permitted to form an identifier.
Cplus_plus is case sensitive—uppercase and lowercase letters are considered different.
Thus, the identifier NUMBER is not the same as the identifier number.
Similarly, the identifiers X and x are different.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The Basics of a Cplus_plus Program | 37 In Cplus_plus, identifiers can be of any length.
EXAMPLE 2-2 2 The following are legal identifiers in Cplus_plus: first conversion payRate counter1 Table 2-1 shows some illegal identifiers and explains why they are illegal and also gives a correct identifier.
TABLE 2-1 Examples of Illegal Identifiers.
The exclamation mark cannot be used in an identifier.
Hello one + two The symbol + cannot be used in an identifier.
When the linker links the object program with the system resources provided by the integrated development environment (IDE), certain errors could occur.
Therefore, it is advisable that you should not begin identifiers in your program with an underscore ( _ ).
Whitespaces Every Cplus_plus program contains whitespaces.
Whitespaces include blanks, tabs, and newline characters.
In a Cplus_plus program, whitespaces are used to separate special symbols, reserved words, and identifiers.
Whitespaces are nonprintable in the sense that when they are printed on a white sheet of paper, the space between special symbols, reserved words, and identifiers is white.
Proper utilization of whitespaces in a program is important.
They can be used to make the program more readable.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Different programs manipulate different data.
A program designed to calculate an employee's paycheck will add, subtract, multiply, and divide numbers, and some of the numbers might represent hours worked and pay rate.
Similarly, a program designed to alphabetize a class list will manipulate names.
You wouldn't use a cherry pie recipe to help you bake cookies.
Similarly, you wouldn't use a program designed to perform arithmetic calculations to manipulate alphabetic characters.
Furthermore, you wouldn't multiply or subtract names.
Reflecting these kinds of underlying differences, Cplus_plus categorizes data into different types, and only certain operations can be performed on particular types of data.
Although at first it may seem confusing, by being so type conscious, Cplus_plus has built-in checks to guard against errors.
Data type: A set of values together with a set of allowed operations.
Cplus_plus data types fall into the following three categories:.
Simple data type Structured data type Pointers For the next few chapters, you will be concerned only with simple data types.
Simple Data Types The simple data type is the fundamental data type in Cplus_plus because it becomes a building block for the structured data type, which you will start learning about in Chapter 8.
There are three categories of simple data:.
Integral, which is a data type that deals with integers, or numbers without a decimal part.
Floating-point, which is a data type that deals with decimal numbers.
Enumeration, which is a user-defined data type The enumeration type is Cplus_plus's method for allowing programmers to create their own simple data types.
This data type will be discussed in Chapter 7.
Integral data types are further classified into the following categories: char, short, int, long, bool, unsigned char, unsigned short, unsigned int, unsigned long, long long, and unsigned long long.
Every data type has a different set of values associated with it.
For example, the char data type is used to represent integers between – 128 and 127.
The int data type is used to represent integers between –2147483648 and 2147483647, and the data type short is used to represent integers between –32768 and 32767.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Data Types | 39 Which data type you use depends on how big a number your program needs to deal with.
In the early days of programming, computers and main memory were very expensive.
Only a small amount of memory was available to execute programs and manipulate the data.
As a result, programmers had to optimize the use of memory.
Because writing a program and making it work is already a complicated process, not having to worry about the size of memory makes for one less thing to think about.
To effectively use memory, a programmer can look at the type of data to be used by a program and thereby figure out which data type to use.
Different compilers may allow different ranges of values.
Check your compiler's documentation.
To find the exact size of the integral data types on a particular system, you can run a program given in Appendix G (Memory Size of a System).
Furthermore,  find the maximum and minimum values of these data types, you can run another program given in Appendix F (Header File climits).
Also, the data type long long is available in Cplus_plus11.
This discussion also applies  other integral data types.
Integers in Cplus_plus, as in mathematics, are numbers such as the following: -6728, -67, 0, 78, 36782, +763 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due  electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right  remove additional content at any time if subsequent rights restrictions require it.
Chapter 2: Basic Elements of Cplus_plus Note the following two rules from these examples: 1.
Positive integers do not need a + sign in front of them.
No commas are used within an integer.
Recall that in Cplus_plus, commas are used  separate items in a list.
So 36,782 would be interpreted as two integers: 36 and 782.
Also, true and false are called the logical (Boolean) values.
The central purpose of this data type is  manipulate logical (Boolean) expressions.
Logical (Boolean) expressions will be formally defined and discussed in detail in Chapter 4.
In Cplus_plus, bool, true, and false are reserved words.
Thus, the char data type can represent every key on your keyboard.
When using the char data type, you enclose each character represented within single quotation marks.
Examples of values belonging  the char data type include the following: 'A', 'a', '0', '*', '+', '$', '&', ' ' Note that a blank space is a character and is written as ' ', with a space between the single quotation marks.
The data type char allows only one symbol  be placed between the single quotation marks.
Thus, the value 'abc' is not of the type char.
Furthermore, even  '_0_='and similar special symbols are considered  be one symbol, they are not regarded as possible values of the data type char.
All the individual symbols located on the keyboard that are printable may be considered as possible values of the char data type.
Several different character data sets are currently in use.
The most common are the American Standard Code for Information Interchange (ASCII) and Extended BinaryCoded Decimal Interchange Code (EBCDIC).
The ASCII character set has 128 values.
The EBCDIC character set has 256 values and was created by IBM.
Both character sets are described in Appendix C.
Each of the 128 values of the ASCII character set represents a different character.
For example, the value 65 represents 'A', and the value 43 represents '+'.
Thus, each character has a predefined ordering represented by the numeric value associated with the character.
This ordering is called a collating sequence, in the set.
The collating sequence is used when you compare characters.
For example, the value representing 'B' is 66, so 'A' is smaller than 'B'.
Similarly, '+' is smaller than 'A' because 43 is smaller than 65.
The 14th character in the ASCII character set is called the newline character and is represented as '\n'.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due  electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right  remove additional content at any time if subsequent rights restrictions require it.
Data Types | 41 character set is 13 because the position of the first character is 0_0_) Even  the newline character is a combination of two characters, it is treated as one character.
Similarly, the horizontal tab character is represented in Cplus_plus as '\t' and the null character is represented as '\0' (backslash followed by zero).
Furthermore, the first 32 characters in the ASCII character set are nonprintable.
To facilitate the discussion, let us review a concept from a high school or college algebra course.
You may be familiar with scientific notation.
To represent decimal numbers, Cplus_plus uses a form of scientific notation called floatingpoint notation.
Table 2-3 shows how Cplus_plus might print a set of decimal numbers using one machine's interpretation of floating-point notation.
In the Cplus_plus floating-point notation, the letter E stands for the exponent.
TABLE 2-3 Examples of Decimal Numbers in Scientific and Cplus_plus Floating-Point Notations.
As in the case of integral data types, the data types float, double, and long double differ in the set of values it can represent.
On most newer compilers, the data types double and long double are the same.
Therefore, only the data types float and double are described here.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 2: Basic Elements of Cplus_plus float: The data type float is used in Cplus_plus to represent any decimal number between -3_0_4 *1038 and 3_0_4 *1038.
The memory allocated for a value of the float data type is four bytes.
The memory allocated for a value of the double data type is eight bytes.
The maximum and minimum values of the data types float and double are system dependent.
To find these values on a particular system, you can check your compiler's documentation or, alternatively, you can run a program given in Appendix F (Header File cfloat).
Other than the set of values, there is one more difference between the data types float and double.
The maximum number of significant digits—that is, the number of decimal places—in float values is six or seven.
The maximum number of significant digits in values belonging to the double type is 15.
For values of the double type, for better precision, some compilers might give more than 15 significant digits.
Check your compiler's documentation.
The maximum number of significant digits is called the precision.
Sometimes float values are called single precision, and values of type double are called double precision.
If you are dealing with decimal numbers, for the most part you need only the float type; if you need accuracy to more than six or seven decimal places, you can use the double type.
In Cplus_plus, by default, floating-point numbers are considered type double.
Therefore, if you use the data type float to manipulate floating-point numbers in a program, certain compilers might give you a warning message, such as "truncation from double to float_0_" To avoid such warning messages, you should use the double data type.
For illustration purposes and to avoid such warning messages in programming examples, this book mostly uses the data type double to manipulate floating-point numbers.
Data Types, Variables, and Assignment Statements Now that we know how to define an identifier, what a data type is, and the term variable, we can show how to declare a variable.
When we declare a variable, not only do we specify the name of the variable, we also specify what type of data a variable can store.
A syntax rule to declare a variable is: dataType identifier; Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Arithmetic Operators, Operator Precedence, and Expressions.
That is,  is a that can store an int value.
Similarly,  is a  that can store a value of type double; and  is a  that can store a value of type char.
One way to store a value in a  is by using an assignment statement, which takes the following form: = expression; where expression is evaluated and its value is assigned to.
We will discuss assignment statements in detail later in this chapter.
Arithmetic Operators, Operator Precedence, and Expressions One of the most important uses of a computer is its ability to calculate.
You can use the standard arithmetic operators to manipulate integral and floating-point data types.
There are five arithmetic operators: Arithmetic Operators: + (addition),  (subtraction or negation), * (multiplication), / These operators work as follows:.
You can use the operators +, -, *, and / with both integral and floatingpoint data types.
These operators work with integral and floating-point data the same way as you learned in a college algebra course.
That is, integral division truncates any fractional part;.
You use % with only the integral data type, to find the remainder in ordinary division.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 2: Basic Elements of Example 2-3 shows how the operators / and % work with the integral data types.
EXAMPLE 2-3 Arithmetic Expression Result.
Therefore, 5 / 2 with the integral operands evaluates to the quotient, which is 2.
Therefore, 34 % 5 evaluates to the remainder, which is 4.
Therefore, 4 % 6 evaluates to the remainder, which is 4.
EXAMPLE 2-4 Given length in inches, we write a program  determines  outputs the equivalent length in feet  (remaining) inches.
Now there are 12 inches in a foot.
Therefore, 100 inches equals 8 feet  4 inches; , 55 inches equals 4 feet  7 inches.
From these examples, it follows  we can effectively use the operators /  % to accomplish our task.
The desired program is as follows: // Given length in , this program outputs the equivalent // length in feet  remaining inch().
Arithmetic Operators, Operator Precedence,  Expressions.
Note  each time you run this program, it will output the value of 100.
To convert some other value of , you need to edit this program  store a different value in the , which is not very convenient.
Later in this chapter we will illustrate how to statements in a program  will instruct the user to enter different values.
However, if you are curious to know at this point, then replace the statement.
Consider the following expressions, which you have been accustomed to working with since high school: -5, 8 – 7, 3 + 4, 2 + 3 * 5, 5_0_6 + 6_0_2 * 3,  x + 2 * 5 + 6 / y, where x y are unknown numbers.
These are examples of arithmetic expressions.
The numbers appearing in the expressions are called operands.
The numbers  are used to evaluate an operator are called the operands for  operator.
Operators  have only one operand are called unary operators.
Operators  have two operands are called binary operators.
Unary operator: An operator  has only one operand.
Binary operator: An operator  has two operands.
Moreover, in the expression +27, the operator + indicates  the number 27 is positive.
Here, + has only one operand so acts as a unary operator.
From the preceding discussion, it follows  –  + are both unary  binary arithmetic operators.
However, as arithmetic operators, *, /,  % are binary  so must have two operands.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook /or eChapter(s).
Editorial review has deemed  any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
According to the order of precedence rules for arithmetic operators, *, / , % are at a higher level of precedence than +, Note  the operators *, /,  % have the same level of precedence.
Similarly, the operators +  - have the same level of precedence.
When operators have the same level of precedence, the operations are performed from left to right.
To avoid confusion, you can use parentheses to group arithmetic expressions.
For example, using the order of precedence rules, 3 *7 - 6 + 2 *5 / 4 + 6 means the following: = = = = = (((3 * 7) - 6) + ((2 * 5) / 4 )) + 6 ((21 - 6) + (10 / 4)) + 6 (Evaluate ((21 - 6) + 2) + 6 (Evaluate (15 + 2) + 6 (Evaluate 17 + 6 (Evaluate 23 (Evaluate /.
Note  the use of parentheses in the second example clarifies the order of precedence.
You can also use parentheses to override the order of precedence rules.
Because arithmetic operators, using the precedence rules, are evaluated from left to right, unless parentheses are present, the associativity of the arithmetic operators is said to be from left to right.
However, you should use this ability carefully.
There is a difference between the character '8'  the integer 8.
The integer value of '8' is 56, which is the ASCII collating sequence of the character '8'.
When evaluating arithmetic , 8 + 7 = 15; '8' + '7' = 56 + 55, which yields 111;  '8' + 7 = 56 + 7, which yields 63.
These examples illustrate that many things can go wrong when you are performing character arithmetic.
If you must employ them, use arithmetic operations on the char data type with caution.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook /or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Arithmetic Operators, Operator Precedence,  Expressions.
Sample Run: 2 + 5 = 7 13 + 89 = 102 34 - 20 = 14 45 - 90 = -45 2 * 7 = 14 5 / 2 = 2 14 / 7 = 2 34 % 5 = 4 4 % 6 = 4 5_0_0 + 3_0_5 = 8_0_5 3_0_0 + 9_0_4 = 12_0_4 16_0_3 - 5_0_2 = 11_0_1 4_0_2 * 2_0_5 = 10_0_5 5_0_0 / 2_0_0 = 2_0_5 34_0_5 / 6_0_0 = 5_0_75 34_0_5 / 6_0_5 = 5_0_30769 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook /or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 2: Basic Elements of Cplus_plus You should be careful when evaluating the mod operator with negative integer operands.
You might not get the answer you expect.
Also -34 % -5 = -4,  in the division –34 / –5, the quotient is 6  the remainder is –4.
Expressions There are three types of arithmetic  in Cplus_plus:.
Integral —all operands in the expression are integers.
An integral expression yields an integral result.
Floating-point (decimal) —all operands in the expression are floating-points (decimal numbers).
A floating-point expression yields a floating-point result.
Mixed —the expression contains both integers  decimal numbers.
Looking at some examples will help clarify these definitions.
EXAMPLE 2-6 Consider the following Cplus_plus integral : 2 + 3 * 5 3 + x - y / 7 x + 2 * (y - z) + 18 In these , x, y,  z are variables of type int.
EXAMPLE 2-7 Consider the following Cplus_plus floating-point expressions: 12_0_8 * 17_0_5 - 34_0_50 x * 10_0_5 + y - 16_0_2 Here, x and y are variables of type double.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Arithmetic Operators, Operator Precedence, and Expressions.
As before, when operators have the same precedence, the expression is evaluated from left to right.
You can always use parentheses to group operands and operators to avoid confusion.
Next, we discuss mixed expressions.
Mixed Expressions An expression that has operands of different data types is called a mixed expression.
A mixed expression contains both integers and floating-point numbers.
The following expressions are examples of mixed expressions: 2 + 3_0_5 6 / 4 + 3_0_9 5_0_4 * 2 - 13_0_6 + 18 / 2 In the first expression, the operand + has one integer operand and one floating-point operand.
In the second expression, both operands for the operator / are integers, the first operand of + is the result of 6 / 4, and the second operand of + is a floating-point number.
The third  is an even more complicated mix of integers and floatingpoint numbers.
The obvious question is: How does Cplus_plus evaluate mixed expressions.
Two rules apply when evaluating a mixed expression: 1.
When evaluating an operator in a mixed expression: a.
If the operator has the same types of operands (that is, either both integers or both floating-point numbers), the operator is evaluated according to the type of the operands.
Integer operands thus yield an integer result; floating-point numbers yield a floating-point number.
If the operator has both types of operands (that is, one is an integer and the other is a floating-point number), then during calculation, the integer is changed to a floating-point number with the decimal part of zero and the operator is evaluated.
The result is a floating-point number.
The entire expression is evaluated according to the precedence rules; the multiplication, division, and modulus operators are evaluated before the addition and subtraction operators.
Operators having the same level of precedence are evaluated from left to right.
Grouping using parentheses is allowed for clarity.
From these rules, it follows that when evaluating a mixed expression, you concentrate on one operator at a time, using the rules of precedence.
If the operator to be evaluated has operands of the same data type, evaluate the operator using Rule 1(a).
That is, an operator with integer operands will yield an integer result, and an operator with floating-point operands will yield a floating-point result.
If the operator to be evaluated has one integer operand and one floating-point operand, before evaluating this operator, convert the integer operand to a floating-point number with the decimal part of 0.
The following examples show how to evaluate mixed expressions.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 2: Basic Elements of Cplus_plus EXAMPLE 2-8 Mixed Expression Evaluation.
Sample Run: 3 / 2 + 5_0_5 = 6_0_5 15_0_6 / 2 + 5 = 12_0_8 4 + 5 / 2_0_0 = 6_0_5 4 * 3 + 7 / 5 - 25_0_5 = -12_0_5 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
In the previous section, you learned that when evaluating an arithmetic expression, if the operator has mixed operands, the integer value is changed to a floating-point value with the zero decimal part.
When a value of one data type is automatically changed to another data type, an implicit type coercion is said to have occurred.
As the examples in the preceding section illustrate, if you are not careful about data types, implicit type coercion can generate unexpected results.
To avoid implicit type coercion, Cplus_plus provides for explicit type conversion through the use of a cast operator.
The cast operator, also called type conversion or type casting, takes the following form: First, the expression is evaluated.
Its value is then converted to a value of the type specified by dataTypeName.
In Cplus_plus,  is a reserved word.
When converting a floating-point (decimal) number to an integer using the cast operator, you simply drop the decimal part of the floating-point number.
That is, the floating-point number is truncated.
Example 2-9 shows how cast operators work.
Be sure you understand why the last two expressions evaluate as they do.
EXAMPLE 2-9 Expression.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 2: Basic Elements of Cplus_plus.
Note that the value of the expression <>(25) is 25_0_0.
This is  we have not yet discussed how to output decimal numbers with 0 decimal parts to show the decimal point and the trailing zeros.
Chapter 3 explains how to output decimal numbers in a desired format.
Similarly, the output of other decimal numbers with zero decimal parts is without the decimal point and the 0 decimal part.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
However,  is more stable than C-like casting.
You can also use cast operators to explicitly convert char data values into  data values and  data values into char data values.
To convert char data values into  data values, you use a collating sequence.
For example, in the ASCII character set, <>('A') is 65 and <>('8') is 56.
Earlier in this chapter, you learned how arithmetic expressions are formed and evaluated in Cplus_plus.
If you want to use the value of one expression in another expression, first you must save the value of the expression.
There are many reasons to save the value of an expression.
Some expressions are complex and may require a considerable amount of computer time to evaluate.
By calculating the values once and saving them for further use, you not only save computer time and create a program that executes more quickly, you also avoid possible typographical errors.
In Cplus_plus, expressions are evaluated, and if the value is not saved, it is lost.
That is, unless it is saved, the value of an expression cannot be used in later calculations.
Later in this chapter, you will learn how to save the value of an expression and use it in subsequent calculations.
Before leaving the discussion of data types, let us discuss one more data type—string.
It is not directly available for use in a program like the simple data types discussed earlier.
To use this data type, you need to access program components from the library, which will be discussed later in this chapter.
The data type string is a feature of ANSI/ISO Standard Cplus_plus.
Prior to the ANSI/ISO Cplus_plus language standard, the standard Cplus_plus library did not provide a string data type.
Compiler vendors often supplied their own programmer-defined string type, and the syntax and semantics of string operations often varied from vendor to vendor.
A string is a sequence of zero or more characters.
Strings in Cplus_plus are enclosed in quotation marks.
A string containing no characters is called a null or empty string.
The following are examples of strings.
Note that "" is the empty string.
Every character in a string has a relative position in the string.
The position of the first character is 0, the position of the second character is 1, and so on.
The length of a string is the number of characters in it.
When determining the length of a string, you must also count any spaces in the string.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 2: Basic Elements of Cplus_plus EXAMPLE 2-10 String Position of a Character in the String.
Position Position Position Position Position of of of of of 'W' is 0.
The string type is very powerful and more complex than simple data types.
It provides not only the physical space required to store the string, but many operations to manipulate strings.
For example, it provides operations to find the length of a string, extract part of a string, and compare strings.
You will learn about this data type over the next few chapters.
Variables, Assignment Statements, and Input Statements As noted earlier, the main objective of a Cplus_plus program is to perform calculations and manipulate data.
Recall that data must be loaded into main memory before it can be manipulated.
In this section, you will learn how to put data into the computer's memory.
Storing data in the computer's memory is a two-step process: 1.
Instruct the computer to allocate memory.
Include statements in the program to put data into the allocated memory.
Allocating Memory with Constants and Variables When you instruct the computer to allocate memory, you tell it not only what names to use for each memory location, but also what type of data to store in those memory locations.
Knowing the location of data is essential, because data stored in one memory location might be needed at several places in the program.
As you saw earlier, knowing what data type you have is crucial for performing accurate calculations.
It is also critical to Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Variables, Assignment Statements, and Input Statements | 55 know whether your data needs to remain fixed throughout program execution or whether it should change.
NAMED CONSTANTS Some data must stay the same throughout a program.
For example, the conversion formula that converts inches into centimeters is fixed, because 1 inch is always equal to 2_0_54 centimeters.
When stored in memory, this type of data needs to be protected from accidental changes during program execution.
In Cplus_plus, you can use a named constant to instruct a program to mark those memory locations in which data is fixed throughout program execution.
Named constant: A memory location whose content is not allowed to change during program execution.
To allocate memory, we use Cplus_plus's declaration statements.
The syntax to declare a named constant is: const dataType  = value; In Cplus_plus, const is a reserved word.
It should be noted that a named constant is initialized and declared all in one statement and that it must be initialized when it is declared because from this statement on the compiler will reject any attempt to change the value.
EXAMPLE 2-11 Consider the following Cplus_plus statements:.
The first statement tells the compiler to allocate memory (eight bytes) to store a value of type double, call this memory space , and store the value 2_0_54 in it.
Throughout a program that uses this statement, whenever the conversion formula is needed, the memory space  can be accessed.
The meaning of the other statements is similar.
Note that the  for a named constant is in uppercase letters.
Even though there are no written rules, Cplus_plus programmers typically prefer to use uppercase letters to name a named constant.
Moreover, if the name of a named constant is a combination of more than one word, called a run-together word, then the words are typically separated using an underscore.
For example, in the preceding example, is a run-together word.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 2: Basic Elements of Cplus_plus As noted earlier, the default type of floating-point numbers is double.
Therefore, if you declare a named constant of type float, then you must specify that the value is of type float as follows: const float  = 2_0_54f; Otherwise, the compiler will generate a warning message.
Notice that 2_0_54f says that it is a float.
Recall that the memory size for float values is four bytes; for double values, eight bytes.
Because memory size is of little concern these days, as indicated earlier, we will mostly use the type double to work with floating-point values.
Using a named constant to store fixed data, rather than using the data  itself, has one major advantage.
If the fixed data changes, you do not need to edit the entire program and change the old  to the new  wherever the old  is used.
In addition, by storing a  and referring to that memory location whenever the  is needed, you avoid typing the same  again and again and prevent accidental typos.
If you misspell the name of the constant 's location, the computer will warn you through an error message, but it will not warn you if the  is mistyped.
VARIABLES Earlier in this chapter, we introduced the term variable and how to declare it.
We now review this concept and also give the general syntax to declare variables.
In some programs, data needs to be modified during program execution.
For example, after each test, the average test score and the number of tests taken changes.
Similarly, after each pay increase, the employee's salary changes.
This type of data must be stored in those memory cells whose contents can be modified during program execution.
In Cplus_plus, memory cells whose contents can be modified during program execution are called variables.
Variable: A memory location whose content may change during program execution.
The syntax for declaring one variable or multiple variables is: dataType , ,.
Variables, Assignment Statements, and Input Statements | 57 The first statement tells the compiler to allocate eight bytes of memory space to store a  of the type double and call it amountDue.
The second and third statements have similar conventions.
The fourth statement tells the compiler to allocate two different memory spaces, each four bytes, to store a  of the type int; name the first memory space x; and name the second memory space y.
The fifth statement tells the compiler to allocate memory space and call it name.
As in the case of naming named constants, there are no written rules for naming variables.
However, Cplus_plus programmers typically use lowercase letters to declare variables.
If a variable name is a combination of more than one word, then the first letter of each word, except the first word, is uppercase.
In Cplus_plus, you must declare all identifiers before you can use them.
If you refer to an without declaring it, the compiler will generate an error message (syntax error), indicating that the  is not declared.
Therefore, to use either a named constant or a variable, you must first declare it.
Now that data types, variables, and constants have been defined and discussed, it is possible to offer a formal definition of simple data types.
A data type is called simple if the variable or named constant of that type can store only one  at a time.
For example, if x is an int , at a given time, only one  can be stored in x.
Putting Data into Variables Now that you know how to declare variables, the next question is: How do you put data into those variables.
In Cplus_plus, you can place data into a  in two ways: 1.
Use Cplus_plus's assignment statement.
Use input (read) statements.
Assignment Statement The assignment statement takes the following form: = expression; In an assignment statement, the  of the expression should match the data type of the.
The expression on the right side is evaluated, and its  is assigned to the  (and thus to a memory location) on the left side.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 2: Basic Elements of A  is said to be initialized the first time a  is placed in the.
Recall that in , = is called the assignment operator.
EXAMPLE 2-13 Suppose you have the following  declarations:.
For each of these statements, the computer  evaluates the expression on the right and then stores that  in a memory location named by the identifier on the left.
The statement stores the  4 in 1, the second statement stores 9 in 2, the third statement stores 20_0_00 in , and the fourth statement stores the character D in.
The fifth statement assigns the string "It is a sunny day_0_" to the.
The following  program shows the effect of the preceding statements: // This program illustrates how data in the variables are.
Variables, Assignment Statements, and Input Statements |.
Sample Run: 1 = 4 2 = 9 = 20 = D = It is a sunny day.
For the most part, the preceding program is straightforward.
Let us take a look at the output statement: << " 1 = " << 1 << endl; This output statement consists of the string " 1 = ", the operator <<, and the 1.
Here,  the  of the string " 1 = " is output, and then the  of the 1 is output.
The meaning of the other output statements is similar.
A  statement such as ¼  + 2; means "evaluate whatever is in , add 2 to it, and assign the new  to the memory location _0_" The expression on the right side must be evaluated ; that  is then assigned to the memory location specified by the  on the left side.
Thus, the sequence of  statements: = 6;.
Note that if  has not been initialized, the statement  =  + 2 might give unexpected results and/or the complier might generate a warning message indicating that the  has not been initialized.
In general, referencing or using the contents of a  before it is initialized should be avoided.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 2: Basic Elements of EXAMPLE 2-14 Suppose that 1, 2, and 3 are int variables and the following statements are executed in sequence.
The following table shows the values of the variables after the execution of each statement.
The orange color in a box shows Values of the Variables/ Statement Before Statement 1 After Statement 1.
This  is assigned to 1, which replaces the old of 1.
This  is assigned to 3, which replaces the old  of 3.
Thus, after the execution of the statement in  5, 1 = 45, 2 = 45, and 3 = 2.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Variables, Assignment Statements, and Input Statements | 61 Tracing values through a sequence, called a walk-through, is a valuable tool to learn and practice.
Try it in the sequence above.
You will learn more about how to walk through a sequence of Cplus_plus statements later in this chapter.
The following is a legal statement in Cplus_plus: =  = z; In this statement, first the  of z is assigned to , and then the new  of  is assigned to.
Because the assignment , =, is evaluated from right to left, the associativity of the assignment  is said to be from right to left.
Saving and Using the Value of an Expression Now that you know how to declare variables and put data into them, you can learn how to save the  of an expression.
You can then use this  in a later expression without using the expression itself, thereby answering the question raised earlier in this chapter.
To save the  of an expression and use it in a later expression, do the following: 1.
Declare a variable of the appropriate data type.
For example, if the result of the expression is an integer, declare an int variable.
Assign the  of the expression to the variable that was declared, using the assignment statement.
This action saves the  of the expression into the variable.
Wherever the  of the expression is needed, use the variable holding the.
The following example further illustrates this concept.
EXAMPLE 2-15 Suppose that you have the following declaration: int a, b, c, ; int , ; Further suppose that you want to evaluate the expressions –b + (b2 – 4ac) and –b –(b2 – 4ac) and assign the values of these expressions to  and , respectively.
Because the expression b2 – 4ac appears in both expressions, you can first calculate the  of this expression and save its  in.
You can then use the  of to evaluate the expressions, as shown by the following statements:.
You also learned that after declaring a variable, you can use an assignment statement to initialize it.
It is possible to initialize and declare variables at the same time.
Before we discuss how to use an input (read) statement, we address this important issue.
Declaring and Initializing Variables When a variable is declared, Cplus_plus may not automatically put a meaningful  in it.
In other words, Cplus_plus may not automatically initialize variables.
For example, the int and double variables may not be initialized to 0, as happens in some programming languages.
This does not mean, however, that there is no  in a variable after its declaration.
When a variable is declared, memory is allocated for it.
Recall from Chapter 1 that main memory is an ordered sequence of cells, and each cell is capable of storing a.
Also, recall that the machine language is a sequence of 0s and 1s, or bits.
Therefore, data in a memory cell is a sequence of bits.
These bits are nothing but electrical signals, so when the computer is turned on, some of the bits are 1 and some are 0.
The state of these bits depends on how the system functions.
However, when you instruct the computer to store a particular  in a memory cell, the bits are set according to the data being stored.
During data manipulation, the computer takes the  stored in particular cells and performs a calculation.
If you declare a variable and do not store a  in it, the memory cell still has a —usually the  of the setting of the bits from their last use—and you have no way to know what this  is.
If you only declare a variable and do not instruct the computer to put data into the variable, the  of that variable is garbage.
However, the computer does not warn us, regards whatever values are in memory as legitimate, and performs calculations using those values in memory.
Using a variable in an expression without initializing it produces erroneous results.
To avoid these pitfalls, Cplus_plus allows you to initialize variables while they are being declared.
For example, consider the following Cplus_plus statements in which variables are declared and then initialized:.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Variables, Assignment Statements, and Input Statements |.
The  Cplus_plus statement declares two int variables,  and , and stores 13 in and 10 in.
The meaning of the other statements is similar.
In reality, not all variables are initialized during declaration.
It is the nature of the program or the programmer's choice that dictates which variables should be initialized during declaration.
The key point is that all variables must be initialized before they are used.
Input (Read) Statement Previously, you learned how to put data into variables using the assignment statement.
In this section, you will learn how to put data into variables from the standard input device, using Cplus_plus's input (or read) statements.
In most cases, the standard input device is the keyboard.
When the computer gets the data from the keyboard, the user is said to be acting interactively.
Putting data into variables from the standard input device is accomplished via the use of cin and the  >>.
The syntax of cin together with >> is: cin >> variable >> variable _0__0__0_; This is called an input (read) statement.
In Cplus_plus, >> is called the stream extraction.
In a syntax, the shading indicates the part of the definition that is optional.
Furthermore, throughout this book, the syntax is enclosed in yellow boxes.
EXAMPLE 2-16 Suppose that miles is a variable of type double.
Further suppose that the input is 73_0_65.
Consider the following statement: cin >> miles; This statement causes the computer to get the input, which is 73_0_65, from the standard input device and stores it in the variable miles.
That is, after this statement executes, the of the variable miles is 73_0_65.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 2: Basic Elements of Cplus_plus Example 2-17 further explains how to input numeric data into a program.
Next, consider the following statement: cin >> feet >> inches; This statement  stores the number 23 into the variable feet and then the number 7 into the variable inches.
Notice that when these numbers are entered via the keyboard, they are separated with a blank.
In fact, they can be separated with one or more blanks or lines or even the tab character.
The following Cplus_plus program shows the effect of the preceding input statements: // This program illustrates how input statements work.
Sample Run: In this sample run, the user input is shaded.
Enter two integers separated by one or more spaces: 23 7 = 23 = 7 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Variables, Assignment Statements, and Input Statements | 65 The Cplus_plus program in Example 2-18 illustrates how to read strings and numeric data.
Sample Run: In this sample run, the user input is shaded.
Enter  name, last name, , and , separated by spaces.
Sheila Mann 23 120_0_5 Name: Sheila Mann : 23 : 120_0_5 The preceding program works as follows: The statements in Lines 1 to 4 declare the variables firstName and  of type string,  of type int, and  of type double.
The statement in Line 5 is an output statement and tells the user what to do.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 2: Basic Elements of Cplus_plus The statement in Line 6  reads and stores the string Sheila into the variable firstName and then skips the space after Sheila and reads and stores the string Mann into the variable.
Next, the statement in Line 7  skips the blank after Mann and reads and stores 23 into the variable  and then skips the blank after 23 and reads and stores 120_0_5 into the variable.
The statements in Lines 8, 9, and 10 produce the third, fourth, and fifth lines of the sample run.
During programming execution, if more than one value is entered in a line, these values must be separated by at least one blank or tab.
Alternately, one value per line can be entered.
Variable Initialization Remember, there are two ways to initialize a variable: by using the assignment statement.
In (a),  and  are initialized using assignment statements, and in (b), these executes,  and  are initialized to the same value unless you edit the source code, change the value, recompile, and run.
On the other hand, in (b), each time the program runs, you are prompted to enter values for  and.
Therefore, a read statement is much more versatile than an assignment statement.
Sometimes it is necessary to initialize a variable by using an assignment statement.
This is especially true if the variable is used only for internal calculation and not for reading and storing data.
Recall that Cplus_plus does not automatically initialize variables when they are declared.
Some variables can be initialized when they are declared, whereas others must be initialized using either an assignment statement or a read statement.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Variables, Assignment Statements, and Input Statements | 67 When the program is compiled, some of the newer IDEs might give warning messages if the program uses the value of a variable without first properly initializing that variable.
In this case, if you ignore the warning and execute the program, the program might terminate abnormally with an error message.
Suppose you want to store a character into a char variable using an input statement.
During program execution, when you enter the character, you do not  the single quotes.
For example, suppose that ch is a char variable.
Consider the following input statement: cin >> ch; If you want to store K into ch using this statement, during program execution, you only enter K.
Similarly, if you want to store a string into a string variable using an input statement, during program execution, you enter only the string without the double quotes.
Also, suppose that the following statements execute in the order given.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Chapter 2: Basic Elements of Cplus_plus In addition, suppose the input is: 10_0_5 4_0_0 Amy A This line has four values, 10_0_5, 4_0_0, Amy, and A, and each value is separated from the others by a blank.
Let's now determine the values of the declared variables after the last statement executes.
To explicitly show how a particular statement changes the value of a variable, the values of the variables after each statement executes are shown.
This statement replaces the old  of with this new.
Read two numbers, which are 10_0_5 and 4_0_0, and store the first number into , and the second into.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Variables, Assignment Statements, and Input Statements | After St.
Values of the Variables/Statement 2 6.
This statement replaces the old of  with this new.
This statement replaces the old of  with this new.
Store 62_0_5 into This statement replaces the old value of  with this new value.
Read the next input, A, from the keyboard and store it into ch.
When something goes wrong in a program and the results it generates are not what you expected, you should do a walk-through of the statements that assign values to your variables.
Example 2-19 illustrates how to do a walk-through of your program.
This is a very effective debugging technique.
The Web site accompanying this book contains a Cplus_plus program that shows the effect of the 10 statements listed at the beginning of Example 2-19.
The program is named Example 2_19_0_cpp.
If you assign the value of an expression that evaluates to a floating-point value—without using the cast operator—to a variable of type int, the fractional part is dropped.
In this case, the compiler most likely will issue a warning message about the implicit type conversion.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 2: Basic Elements of Cplus_plus Increment and Decrement Operators Now that you know how to declare a variable and enter data into a variable, in this section, you will learn about two more operators: the increment and decrement operators.
These operators are used frequently by Cplus_plus programmers and are useful programming tools.
Suppose  is an int variable.
The statement: =  + 1; increments the value of  by 1.
To execute this assignment statement, the computer first evaluates the expression on the right, which is  + 1.
It then assigns this value to the variable on the left, which is.
As you will see in later chapters, such statements are frequently used to  how many times certain things have happened.
To expedite the execution of such statements, Cplus_plus provides the increment operator, plus_plus (two plus signs), which increases the value of a variable by 1, and the decrement operator, –– (two minus signs), which decreases the value of a variable by 1.
Increment and decrement operators each have two forms, pre and post.
The syntax of the increment operator is: Pre-increment: plus_plusvariable Post-increment: variableplus_plus The syntax of the decrement operator is: Pre-decrement: ––variable Post-decrement: variable–– Let's look at some examples.
Because both the increment and decrement operators are built into Cplus_plus, the value of the variable is quickly incremented or decremented without having to use the form of an assignment statement.
Now, both the pre- and post-increment operators increment the value of the variable by 1.
Similarly, the pre- and post-decrement operators decrement the value of the variable by 1.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Increment and Decrement Operators.
The difference becomes apparent when the variable using these operators is employed in an expression.
Suppose that  is an int variable.
If plus_plusx is used in an expression, first the  of  is incremented by 1, and then the new  of  is used to evaluate the expression.
On the other hand, if xplus_plus is used in an expression, first the current  of  is used in the expression, and then the  of  is incremented by 1.
The following example clarifies the difference between the pre- and post-increment operators.
Suppose that  and  are int variables.
Consider the following statements: = 5; = plus_plusx; The first statement assigns the  5 to.
To evaluate the second statement, which uses the pre-increment operator, first the  of  is incremented to 6, and then this , 6, is assigned to.
After the second statement executes, both  and  have the  6.
The equivalent results would occur with this set of statements:.
As before, the first statement assigns 5 to.
In the second statement, the post-increment operator is applied to.
To execute the second statement, first the  of , which is 5, is used to evaluate the expression, and then the  of  is incremented to 6.
Finally, the of the expression, which is 5, is stored in.
After the second statement executes, the  of  is 6, and the  of  is 5.
The equivalent results would occur with this set of statements:.
As you see, the only difference between the pre- and post-increment statements is when the incrementing takes place: before the assignment or after.
The following example further illustrates how the pre and post forms of the increment operator work.
EXAMPLE 2-20 Suppose  and  are int variables and = 5; = 2 + (plus_plusa); Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
The first statement assigns 5 to.
To execute the second statement, first the expression 2 +(plus_plusa) is evaluated.
Because the pre-increment operator is applied to , first the of  is incremented to 6.
Then 2 is added to 6 to get 8, which is then assigned to.
Therefore, after the second statement executes,  is 6 and  is 8.
Output In the preceding sections, you have seen how to put data into the computer's memory and how to manipulate that data.
We also used certain output statements to show the results on the standard output device.
This section explains in some detail how to further use output statements to generate the desired results.
The standard output device is usually the screen.
In Cplus_plus, output on the standard output device is accomplished via the use of  and the operator <<.
The general syntax of  together with << is: << expression or  << expression or _0__0__0_; This is called an output statement.
In Cplus_plus, << is called the stream insertion operator.
Generating output with  follows two rules: 1.
The expression is evaluated, and its  is printed at the current insertion point on the output device.
A  is used to format the output.
The simplest  is endl (the last character is the letter el), which causes the insertion point to move to the beginning of the next line.
On the screen, the insertion point is where the cursor is.
The next example illustrates how an output statement works.
In an output statement, string or an expression involving only one variable or  single  evaluates to itself.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Output | 73 When an output statement outputs char values, it outputs only the character without the single quotes (unless the single quotes are part of the output statement).
EXAMPLE 2-21 Consider the following statements.
The output is shown to the right of each statement.
Look at the output of statement 9.
Recall that in Cplus_plus, the newline character is '\n'; it causes the insertion point to move to the beginning of the next line before printing.
Therefore, when \n appears in  string in an output statement, it causes the insertion point to move to the beginning of the next line on the output device.
This fact explains why Hello and.
In Cplus_plus, \ is called the escape character and \n is called the newline escape sequence.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 2: Basic Elements of Cplus_plus Recall that all variables must be properly initialized; otherwise, the value stored in them may not make much sense.
Also recall that Cplus_plus does not automatically initialize variables.
If  is an int variable, then the output of the Cplus_plus statement: <<  << endl;.
EXAMPLE 2-22 Consider the following Cplus_plus program: // This program illustrates how output statements work.
The line numbers are shown in this column to make it easy to see which output corresponds to which statement.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Output | 75 Output of Statement at 7 1_0_5 Hello.
Look at the output of the statements in Lines 7, 8, 9, and 10.
The statement in Line 7 outputs the result of 3 + 5, which is 8, and moves the insertion point to the beginning of the next line.
The statement in Line 8 outputs the string 3 + 5.
Note that the statement in Line 8 consists only of the string 3 + 5.
Therefore, after printing 3 + 5, the insertion point stays positioned after 5; it does not move to the beginning of the next line.
Next the output of the statement in Line 9 outputs  space and ** at the insertion point, which was positioned after 5.
The output statement in Line 10 contains only the manipulator endl, which moves the insertion point to the beginning of the next line.
Therefore, when the statement in Line 11 executes, the output starts at the beginning of the line.
Note that in this output, the column "Output of Statement at" does not contain Line 10.
This is due to the fact that the statement in Line 10 does not produce any printable output.
It simply moves the insertion point to the beginning of the next line.
Next, the statement in Line 11 outputs the value of 2 + 3 * 6, which is 20.
The manipulator endl then moves the insertion point to the beginning of the next line.
Outputting or accessing the value of  variable in an expression does not destroy or modify the contents of the variable.
Let us now take  close look at the newline character, '\n'.
Now consider the following Cplus_plus statements: << "Hello there_0_\n";.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Chapter 2: Basic Elements of Cplus_plus The output of these Cplus_plus statements is: Hello there.
My name is James.
When \n is encountered in the string, the insertion point is positioned at the beginning of the next line.
Note also that \n may appear anywhere in the string.
For example, the output of the statement: << "Hello \nthere.
My name is James.
Also, note that the output of the statement:.
Output | 77 In each case, the output of the statements is: Hello.
My name is James.
Obviously, you will use an output statement to produce this output.
However, in the programming code, this statement may not fit in one line as part of the output statement.
Also, note that  is no manipulator  at the end of the first statement.
Here, two output statements are used to output the sentence in one line.
Equivalently, you can use the following output statement to output this sentence: << "We can go _0_" << ; In this statement, note that  is no semicolon at the end of the first line, and the identifier does not appear at the beginning of the second line.
Because  is no semicolon at the end of the first line, this output statement continues at the second line.
Also, note the double quotation marks at the beginning and end of the sentences on each line.
The string is broken into two strings, but both strings are part of the same output statement.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
However, the following statement would be incorrect: << "It is sunny, warm, and not a windy day.
That is, in programming code, a string cannot be broken into more than one line by using the return (Enter) key on your keyboard.
Recall that the newline character is \n, which causes the insertion point to move to the beginning of the next line.
There are many escape sequences in Cplus_plus, which allow you to control the output.
Table 2-4 lists some of the commonly used escape sequences.
TABLE 2-4 Commonly Used Escape Sequences Escape Sequence Description.
Return Cursor moves to the beginning of the current line (not \\.
Double quotation mark is printed The following example shows the effect of some of these escape sequences.
EXAMPLE 2-26 The output of the statement: << "The newline escape sequence is \\" << ; is: The newline escape sequence is \ Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Preprocessor Directives |.
Therefore, the preceding statement is equivalent to the following output statement:.
The Web site accompanying this text contains the Cplus_plus program that shows the effect of the statements in Example 2-26.
The program is named Example2_26_0_cpp.
To use cin and  in a program, you must include a certain header file.
The next section explains what this header file is, how to include a header file in a program, and why you need header files in a program.
Chapter 3 will provide a detailed explanation of cin and.
Preprocessor Directives Only a small number of operations, such as arithmetic and assignment operations, are explicitly defined in Cplus_plus.
Many of the functions and symbols needed to run a Cplus_plus program are provided as a collection of libraries.
Every library has a name and is referred to by a header file.
For example, the descriptions of the functions needed to perform input/output (I/O) are contained in the header file iostream.
Similarly, the descriptions of some very useful mathematical functions, such as power, absolute, and sine, are contained in the header file cmath.
If you want to use I/O or math functions, you need to tell the computer where to find the necessary code.
You use preprocessor directives and the names of header files to tell the computer the locations of the code provided in libraries.
Preprocessor directives are processed by a program called a preprocessor.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
All preprocessor commands begin with #.
There are no semicolons at the end of preprocessor commands because they are not Cplus_plus statements.
To use a header file in a Cplus_plus program, use the preprocessor directive.
The general syntax to  a header file (provided by the IDE) in a Cplus_plus program is: # <headerFileName>.
Preprocessor directives to  header files are placed as the first line of a program so that the identifiers declared in those header files can be used throughout the program.
Appendix F describes some of the commonly used header files.
Individual programmers can also create their own header files, which is discussed in the chapter Classes and Data Abstraction, later in this book.
Note that the preprocessor commands are processed by the preprocessor before the program goes through the compiler.
From Figure 1-2 (Chapter 1), we can conclude that a Cplus_plus system has three basic components: the program development environment, the Cplus_plus language, and the Cplus_plus library.
All three components are integral parts of the Cplus_plus system.
The program development environment consists of the six steps shown in Figure 1-2.
As you learn the Cplus_plus language throughout the book, we will discuss components of the Cplus_plus library as we need them.
In ANSI/ISO Standard Cplus_plus, these identifiers are declared in the header file iostream, but within a namespace.
The name of this namespace is std.
For now, you need to know only how to use cin and  and, in fact, any other identifier from the header file There are several ways you can use an identifier declared in the namespace std.
One way to use cin and  is to refer to them as std::cin and std:: throughout the program.
Another option is to  the following statement in your program: using namespace std; Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Creating a Cplus_plus Program | 81 This statement should appear after the statement # <iostream>.
You can then refer to cin and  without using the prefix std::.
To simplify the use of cin and , this book uses the second form.
That is, to use cin and  in a program, the programs will contain the following two statements: # <iostream> using namespace std; In Cplus_plus, namespace and using are reserved words.
The namespace mechanism is a feature of ANSI/ISO Standard Cplus_plus.
As you learn more Cplus_plus programming, you will become aware of other header files.
For example, the header file cmath contains the specifications of many useful mathematical functions.
Similarly, the header file iomanip contains the specifications of many useful functions and manipulators that help you format your output in a specific manner.
However, just like the identifiers in the header file iostream, the identifiers in ANSI/ISO Standard Cplus_plus header files are declared within a namespace.
The name of the namespace in each of these header files is std.
Therefore, whenever certain features of a header file in ANSI/ISO Standard Cplus_plus are discussed, this book will refer to the identifiers without the prefix std::.
Moreover, to simplify the accessing of identifiers in programs, the statement using namespace std; will be included.
Also, if a program uses multiple header files, only one using statement is needed.
This using statement typically appears after all the header files.
Using the string Data Type in a Program Recall that the string data type is a programmer-defined data type and is not directly available for use in a program.
To use the string data type, you need to access its definition from the header file string.
Therefore, to use the string data type in a program, you must  the following preprocessor directive: # <string> Creating a Cplus_plus Program In previous sections, you learned enough Cplus_plus concepts to write meaningful programs.
You are now ready to create a complete Cplus_plus program.
A Cplus_plus program is a collection of functions, one of which is the function main.
Therefore, if a Cplus_plus program consists of only one function, then it must be the function main.
Moreover, a function is a set of instructions designed to accomplish a specific task.
Until Chapter 6, you will deal mainly with the function main.
The statements to declare variables, the statements to manipulate data (such as assignments), and the statements to input and output data are placed within the function main.
The statements to declare named constants are usually placed outside of the function main.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The statement return 0; must be included in the function main and must be the last statement.
If the statement return 0; is misplaced in the body of the function main, the results generated by the program may not be to your liking.
The full meaning of the statement return 0; will be discussed in Chapter 6.
For now, think of this statement as the end-of-program statement.
In Cplus_plus, return is a reserved word.
A Cplus_plus program might use the resources provided by the IDE, such as the necessary code to input the data, which would require your program to  certain header files.
You can, therefore, divide a Cplus_plus program into two parts: preprocessor directives and the program.
The preprocessor directives tell the compiler which header files to  in the program.
The program contains statements that accomplish meaningful results.
Taken together, the preprocessor directives and the program statements constitute the Cplus_plus source code.
Recall that to be useful, source code must be saved in a file with the file extension _0_cpp.
For example, if the source code is saved in the file firstProgram, then the complete name of this file is firstProgram_0_cpp.
The file containing the source code is called the source code file or source file.
When the program is compiled, the compiler generates the object code, which is saved in a file with the file extension _0_obj.
When the object code is linked with the system resources, the executable code is produced and saved in a file with the file extension _0_exe.
Typically, the name of the file containing the object code and the name of the file containing the executable code are the same as the name of the file containing the source code.
For example, if the source code is located in a file named firstProg_0_cpp, the name of the file containing the object code is firstProg_0_obj, and the name of the file containing the executable code is firstProg_0_exe.
The extensions as given in the preceding paragraph—that is, _0_cpp, _0_obj, and _0_exe—are system dependent.
Moreover, some IDEs maintain programs in the form of projects.
The name of the project and the name of the source file need not be the same.
It is possible that the name of the executable file is the name of the project, with the extension _0_exe.
To be certain, check your system or IDE documentation.
Because the programming instructions are placed in the function main, let us elaborate on this function.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Creating a Cplus_plus Program | 83.
The statements enclosed between the curly braces ( {and }) form the body of the function main.
The body of the function main contains two types of statements:.
Declaration statements Executable statements Declaration statements are used to declare things, such as variables.
In Cplus_plus, identifiers, such as variables, can be declared anywhere in the program, but they must be declared before they can be used.
EXAMPLE 2-27 The following statements are examples of variable declarations: int , b, c; double x, y; Executable statements perform calculations, manipulate data, create output, accept input, and so on.
Some executable statements that you have encountered so far are the assignment, input, and output statements.
EXAMPLE 2-28 The following statements are examples of executable statements:.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Debugging: Understanding and Fixing Syntax Errors.
The statement in 2 uses the using namespace statement so that identifiers declared in the header file iostream, such as cin, , and endl, can be used without using the prefix std::.
The statement in  3 declares the named constant  and sets its  to 12.
The statement in  4 contains the heading of the function main, and the left brace in  5 marks the beginning of the function main.
The statements in Lines 6 and 7 declare the variables  and.
The statement in  8 sets the  of  to 18, and the statement in  9 outputs the  of.
Next, the statement in  10 prompts the user to enter an integer.
The statement in  11 reads and stores the integer into the variable , which is 15 in the sample run.
The statement in  12 positions the cursor on the screen at the beginning of the next line.
The statement in  13 outputs the  of.
The statement in  14 evaluates the expression: +  + 2 * and assigns the  of this expression to the variable , which is 60 in the sample run.
The statement in  15 outputs the new  of.
The statement in  16 contains the return statement, which is the last executable statement.
The right brace in  17 marks the end of the function main.
Debugging: Understanding and Fixing Syntax Errors The previous sections of this chapter described the basic components of  Cplus_plus program.
When you type  program, typos and unintentional syntax errors are likely to occur.
Therefore, when you compile  program, the compiler will identify the syntax error.
In this section, we show how to identify and fix syntax errors.
Consider the following Cplus_plus program: 1.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Chapter 2: Basic Elements of Cplus_plus 6.
We have numbered the statements for easy reference_0_) This program contains syntax errors.
When you compile this program, the compiler produces the following errors.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Debugging: Understanding and Fixing Syntax Errors.
It is best to try to correct the errors in top-down fashion because the first error may confuse the compiler and cause it to flag multiple subsequent errors when actually there was only one error on an earlier line.
So, let's first consider the following error: c:\examplech2_syntax_errors_0_cpp(9): error C2146: syntax error : missing ';' before identifier '' The expression examplech2_syntax_errors_0_cpp(9) indicates that there is an error in Line 9.
The remaining part of this error specifies that there is a missing ; before the identifier.
If we look at Line 7, we find that there is a missing semicolon at the end of the statement int.
Therefore, we must insert ; at the end of the statement in Line 7.
Next, consider the second error: c:\examplech2_syntax_errors_0_cpp(11): error C2065: '' : undeclared identifier This error occurs in Line 11, and it specifies that the identifier  is undeclared.
When we look at the code, we find that this identifier has not been declared.
So we must declare  as an int variable.
The error: c:\examplech2_syntax_errors_0_cpp(11): error C2065: '' : undeclared identifier occurs in Line 13, and it specifies that the identifier  is undeclared.
As in the previous error, we must declare.
Note that once we declare  and recompile, this and the previous error will disappear.
The next error is: c:\examplech2_syntax_errors_0_cpp(13): error C2563: mismatch in formal parameter list This error occurs in Line 13, and it indicates that some formal parameter list is mismatched.
For a beginner, this error is somewhat hard to understand.
This error becomes clear if you look at the next error, part of which is: c:\examplech2_syntax_errors_0_cpp(13): function overload.
So we must correct this error.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 2: Basic Elements of Cplus_plus.
However, at this point, the explanation given, especially for a beginner, is somewhat unclear.
However, if you look at the statement return ; in Line 15 and remember the syntax of the function main as well as all the programs given in this book, we find that the number 0 is missing, that is, this statement must be return 0; From the errors reported by the compiler, we see that the compiler not only identifies the errors, but it also specifies the line numbers where the errors occur and the types of the errors.
We can effectively use this information to fix syntax errors.
After correcting all of the syntax errors, a correct program is:.
It is possible that the list of errors reported by the compiler is longer than the program itself.
This is because, as indicated above, a syntax error in one line can cause syntax errors in subsequent lines.
In situations like this, correct the syntax errors in the order they are listed and compile your program, if necessary, after each correction.
You will see how quickly the syntax errors list shrinks.
The important thing is not to panic.
In the next section, we describe some simple rules that you can follow so that your program is properly structured.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Program Style and Form.
Before beginning to write programs, however, you need to learn their proper structure, among other things.
Using the proper structure for a Cplus_plus program makes it easier to understand and subsequently modify the program.
There is nothing more frustrating than trying to follow and perhaps modify a program that is syntactically correct but has no structure.
In addition, every Cplus_plus program must satisfy certain rules of the language.
A Cplus_plus program must contain the function main.
It must also follow the syntax rules, which, like grammar rules, tell what is right and what is wrong and what is legal and what is illegal in the language.
Other rules serve the purpose of giving precise meaning to the language; that is, they support the language's semantics.
The following sections are designed to help you learn how to use the Cplus_plus programming elements you have learned so far to create a functioning program.
These sections cover the syntax; the use of blanks; the use of semicolons, brackets, and commas; semantics; naming identifiers; prompt lines; documentation, including comments; and form and style.
Syntax The syntax rules of a language tell what is legal and what is not legal.
Errors in syntax are detected during compilation.
For example, consider the following Cplus_plus statements: int x;.
When these statements are compiled, a compilation error will occur at Line 2 because the semicolon is missing after the declaration of the variable.
A second compilation error will occur at Line 4 because the identifier w is used but has not been declared.
As discussed in Chapter 1, you enter a program into the computer by using a text editor.
When the program is typed, errors are almost unavoidable.
Therefore, when the program is compiled, you are most likely to see syntax errors.
It is quite possible that a syntax error at a particular place might lead to syntax errors in several subsequent statements.
It is very common for the omission of a single character to cause four or five error messages.
However, when the first syntax error is removed and the program is recompiled, subsequent syntax errors caused by this syntax error may disappear.
Therefore, you should correct syntax errors in the order in which the compiler lists them.
As you become more familiar and experienced with Cplus_plus, you will learn how to quickly spot and fix syntax errors.
Also, compilers not only discover syntax errors, but also hint and sometimes tell the user where the syntax errors are and how to fix them.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 2: Basic Elements of Cplus_plus Use of Blanks In Cplus_plus, you use one or more blanks to separate numbers when data is input.
Blanks are also used to separate reserved words and identifiers from each other and from other symbols.
Blanks must never appear within a reserved word or identifier.
Use of Semicolons, Brackets, and Commas All Cplus_plus statements must end with a semicolon.
The semicolon is also called a statement terminator.
Note that curly braces, { and }, are not Cplus_plus statements in and of themselves, even though they often appear on a line with no other code.
You might regard brackets as delimiters, because they enclose the body of a function and set it off from other parts of the program.
Brackets have other uses, which will be explained in Chapter 4.
Recall that commas are used to separate items in a list.
For example, you use commas when you declare more than one variable following a data type.
Semantics The set of rules that gives meaning to a language is called semantics.
For example, the order-of-precedence rules for arithmetic operators are semantic rules.
If a program contains syntax errors, the compiler will warn you.
What happens when a program contains semantic errors.
It is quite possible to eradicate all syntax errors in a program and still not have it run.
And if it runs, it may not do what you meant it to do.
For example, the following two lines of code are both syntactically correct expressions, but they have different meanings: 2 + 3 *5 and: (2 + 3) * 5 If you substitute one of these lines of code for the other in a program, you will not get the same results—even though the numbers are the same, the semantics are different.
You will learn about semantics throughout this book.
Program Style and Form.
The identifiers in the second set of statements, such as , are usually called self-documenting identifiers.
As you can see, self-documenting identifiers can make comments less necessary.
Consider the self-documenting identifier annualsale.
This identifier is called a run-together.
In using self-documenting identifiers, you may inadvertently include run-together words, which may lessen the clarity of your documentation.
You can make run-together words easier to understand by either capitalizing the beginning of each new or by inserting an underscore just before a new.
For example, you could use either annualSale or annual_sale to create an identifier that is more clear.
Recall that earlier in this chapter, we specified the general rules for naming named constants and variables.
For example, an identifier used to name a named constant is all uppercase.
If this identifier is a run-together , then the words are separated with the underscore character, such as.
Prompt Lines Part of good documentation is the use of clearly written prompts so that users will know what to do when they interact with a program.
There is nothing more frustrating than sitting in front of a running program and not having the foggiest notion of whether to enter something or what to enter.
Prompt lines are executable statements that inform the user what to do.
For example, consider the following Cplus_plus statements, in which num is an int variable:.
If the program contained only the second statement, users would have no idea that they must enter an integer, and the computer would wait forever for the input.
The preceding output statement is an example of a prompt line.
In a program, whenever input is needed from users, you must include the necessary prompt lines.
Furthermore, these prompt lines should include as much information as Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 2: Basic Elements of Cplus_plus possible about what input is acceptable.
For example, the preceding prompt line not only tells the user to input a number, but also informs the user that the number should be between 1 and 10.
Documentation The programs that you write should be clear not only to you, but also to anyone else.
Therefore, you must properly document your programs.
You use comments to document programs.
Comments should appear in a program to explain the purpose of the program, identify who wrote it, and explain the purpose of particular statements or groups of statements.
Form and Style You might be thinking that Cplus_plus has too many rules.
However, in practice, the rules give Cplus_plus a great degree of freedom.
For example, consider the following two ways of declaring variables: int feet, inches;.
The computer would have no difficulty understanding either of these formats, but the first form is easier to read and follow.
Of course, the omission of a single comma or semicolon in either format may lead to all sorts of strange error messages.
What about blank spaces.
Where are they significant and where are they meaningless.
Consider the following two statements: int a,b,c; and.
The lack of a blank between int and the a changes the reserved  int and the  a into a new , inta.
The clarity of the rules of syntax and semantics frees you to adopt formats that are pleasing to you and easier to understand.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Program Style and Form.
This program is syntactically correct; the Cplus_plus compiler would have no difficulty reading and compiling this program.
However, this program is very hard to read.
The program that you write should be properly indented and formatted.
Note the difference when the program is reformatted:.
As you can see, this program is easier to read.
Your programs should be properly indented and formatted.
To document the variables, programmers typically declare one variable per line.
Also, always put a space before  after an operator.
When you type your program using an IDE, typically, your program is automatically indented.
More on Assignment Statements The assignment statements you have seen so far are called simple assignment statements.
In certain cases, you can use special assignment statements called compound assignment statements to write simple assignment statements in a more concise notation.
Corresponding to the five arithmetic  +, -, *, /,  %, Cplus_plus provides five compound : +=, -=, *=, /=,  %=, respectively.
Consider the following simple assignment statement, in which   y are int variables: =  * y;.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook /or eChapter(s).
More on Assignment Statements | 95.
EXAMPLE 2-31 This example shows several compound assignment statements that are equivalent to simple assignment statements.
Simple Assignment Statement.
Therefore, you cannot immediately convert this statement into a compound assignment statement.
In fact, the equivalent compound assignment statement is:.
We recommend avoiding such compound expressions.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook /or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Convert Length Write a program that takes as input given lengths expressed in feet  inches.
The program should then convert  output the lengths in centimeters.
Assume that the given lengths in feet  inches are integers.
Watch the Video PROBLEM ANALYSIS AND ALGORITHM DESIGN Input.
Equivalent length in centimeters.
The lengths are given in feet  inches,  you need to find the equivalent length in centimeters.
One  is equal to 2_0_54 centimeters.
The first thing the program needs to do is convert the length given in feet  inches to all inches.
Then, you can use the conversion formula, 1  = 2_0_54 centimeters, to find the equivalent length in.
To convert the length from feet  inches to inches, you multiply the number of feet by 12, as 1 foot is equal to 12 inches,  add the given inches.
For example, suppose the input is 5 feet  7 inches.
You then find the total inches as follows: = (12 * feet) + inches = 12 * 5 + 7 = 67 You can then apply the conversion formula, 1  = 2_0_54 , to find the length in.
Get the length in feet  inches.
Convert the length into total inches.
Convert total inches into.
Variables The input for the program is two numbers: one for feet  one for inches.
Thus, you need two variables: one to store feet  the other to store inches.
Because the program will first convert the given length into inches, you need another  to store the total inches.
You also need a  to store the equivalent length in In summary, you need the following variables:.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: Convert Length | 97 Named To calculate the equivalent length in , you need to multiply the total Constants inches by 2_0_54.
Instead of using the value 2_0_54 directly in the program, you will declare this value as a named constant.
Similarly, to find the total inches, you need to multiply the feet by 12 and add the inches.
Instead of using 12 directly in the program, you will also declare this value as a named constant.
Using a named constant makes it easier to modify the program later.
We also determined the necessary variables and named constants.
We can now expand the algorithm given in the section Problem Analysis and Algorithm Design to solve the problem given at the beginning of this programming example.
Prompt the user for the input.
Echo the input—that is, output what the program read as input.
This is also a good way to ensure that 4.
Find the length in inches.
Output the length in inches.
Convert the length to.
Output the length in.
Putting It Now that the problem has been analyzed and the algorithm has been designed, the Together next step is to translate the algorithm into Cplus_plus code.
Because this is the first complete Cplus_plus program you are writing, let's review the necessary steps in sequence.
The program will begin with comments that document its purpose and functionality.
As there is both input to this program (the length in feet and inches) and output (the equivalent length in ), you will be using system resources for input/output.
In other words, the program will use input statements to get data into the program and output statements to print the results.
Because the data will be entered from the keyboard and the output will be displayed on the screen, the program must include the header file iostream.
Thus, the first statement of the program, after the comments as described above, will be the preprocessor directive to include this header file.
This program requires two types of memory locations for data manipulation: named constants and variables.
Typically, named constants hold special data, such as Depending on the nature of a named constant, it can be Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 2: Basic Elements of Cplus_plus placed before the function main or within the function main.
If a named constant is to be used throughout the program, then it is typically placed before the function main.
We will comment further on where to put named constants within a program in Chapter 6, when we discuss user-defined functions in general.
Until then, usually, we will place named constants before the function main so that they can be used throughout the program.
This program has only one function, the function main, which will contain all of the programming instructions in its body.
In addition, the program needs variables to manipulate data, and these variables will be declared in the body of the function main.
The reasons for declaring variables in the body of the function main are explained in Chapter 6.
The body of the function main will also contain the Cplus_plus statements that implement the algorithm.
Therefore, the body of the function main has the following form: {.
Begin the program with comments for documentation.
Include header files, if any are used in the program.
Declare named constants.
Write the definition of the function main.
Programming Example: Make Change |.
Sample Run: In this sample run, the user input is shaded.
Enter two integers, one for feet, one for : 15 7 The numbers you entered are 15 for feet and 7 for.
The total number of  = 187 The number of  = 474_0_98 PROGRAMMING EXAMPLE: Make Change Write a program that takes as input any change expressed in cents.
It should then compute the number of half-dollars, quarters, dimes, nickels, and pennies to be returned, returning as many half-dollars as possible, then quarters, dimes, nickels, and pennies, in that order.
For example, 483 cents should be returned as 9 halfdollars, 1 quarter, 1 nickel, and 3 pennies.
Input Change in cents.
Equivalent change in half-dollars, quarters, dimes, nickels, and pennies.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
To find the number of half-dollars, you divide 646 by 50, the value of a half-dollar, and find the quotient, which is 12, and the remainder, which is 46.
The quotient, 12, is the number of half-dollars, and the remainder, 46, is the remaining change.
Next, divide the remaining change by 25 to find the number of quarters.
Since the remaining change is 46, division by 25 gives the quotient 1, which is the number of quarters, and a remainder of 21, which is the remaining change.
This process continues for dimes and nickels.
To calculate the remainder in an integer division, you use the mod operator, %.
Applying this discussion to 646 cents yields the following calculations: 1.
VARIABLES Get the  in cents.
Find the number of half-.
Calculate the remaining.
Find the number of.
Calculate the remaining.
Find the number of.
Calculate the remaining.
Find the number of.
Calculate the remaining , which is the number of.
From the previous discussion and algorithm, it appears that the program will need variables to hold the number of half-, , and so on.
However, the numbers of half-, , and so on are not used in later calculations, so the program can simply output these values without saving each of them in a variable.
The only thing that keeps changing is the , so the program actually needs only one variable: int ; Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Programming Example: Make  | NAMED CONSTANTS To calculate the equivalent , the program performs calculations using the values of a half-dollar, which is 50; a quarter, which is 25; a dime, which is 10; and a nickel, which is 5.
Because these data are special and the program uses these values more than once, it makes sense to declare them as named constants.
Using named constants also simplifies later modification of the program: const const const const MAIN ALGORITHM 101 int int int int.
Using the variables and named constants specified earlier, while writing the steps of the main algorithm, we also give the corresponding Cplus_plus statements.
Compute and print the number of half-.
Corresponding Cplus_plus Statement 10.
Compute and print the number of.
Sample Run: In this sample run, the user input is shaded.
Enter  in cents: 583 The The The The The The number number number number number you entered is 583 of half-dollars to be returned is 11 of quarters to be returned is 1 of dimes to be returned is 0 of nickels to be returned is 1 of pennies to be returned is 3 QUICK REVIEW 1.
A Cplus_plus program is a collection of functions.
A single-line comment starts with the pair of symbols // anywhere in the line.
Multiline comments are enclosed between /* and */.
The compiler ignores comments.
Reserved words cannot be used as identifiers in a program.
All reserved words in Cplus_plus consist of lowercase letters (see Appendix A).
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 2: Basic Elements of Cplus_plus In Cplus_plus, identifiers are names of things.
A Cplus_plus identifier consists of letters, digits, and underscores and must begin with a letter or underscore.
Whitespaces  blanks, tabs, and newline characters.
A data type is a set of values together with a set of allowed operations.
Cplus_plus data types fall into the following three categories: simple, structured, and pointers.
There are three categories of simple data: integral, floating-point, and enumeration.
Integral data types are classified into the following categories: char, short, int, long, bool, unsigned char, unsigned short, unsigned int, unsigned long, long long, and unsigned long long.
The values belonging to int data type are 2147483648 (¼ 231) to 2147483647 (¼ 231  1).
The data type bool has only two values: true and false.
The most common character sets are ASCII, which has 128 values, and EBCDIC, which has 256 values.
The collating sequence of a character is its preset number in the character data set.
Cplus_plus provides three data types to manipulate decimal numbers: float, double, and long double.
The data type float is used in Cplus_plus to represent any real number between -3_0_4 * 1038 and 3_0_4 * 1038.
The memory allocated for a value of the float data type is four bytes.
The data type double is used in Cplus_plus to represent any real number between -1_0_7 * 10308 and 1_0_7 * 10308.
The memory allocated for a value of the double data type is eight bytes.
The arithmetic operators in Cplus_plus are addition (+), subtraction (-), multiplication (*), division (/), and modulus (%).
The modulus operator, %, takes only integer operands.
Arithmetic expressions are evaluated using the precedence rules and the associativity of the arithmetic operators.
All operands in an integral expression, or integer expression, are integers, and all operands in a floating-point expression are decimal numbers.
A mixed expression is an expression that consists of both integers and decimal numbers.
When evaluating an operator in an expression, an integer is converted to a floating-point number, with a decimal part of 0, only if the operator has mixed operands.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Quick Review | 28.
A string is a sequence of zero or more characters.
Strings in Cplus_plus are enclosed in double quotation marks.
A string containing no characters is called a null or empty string.
Every character in a string has a relative position in the string.
The position of the first character is 0, the position of the second character is 1, and so on.
The length of a string is the number of characters in it.
During program execution, the contents of a named constant cannot be changed.
A named constant is declared by using the reserved word const.
A named constant must be initialized when it is declared.
All variables must be declared before they can be used.
Cplus_plus does not automatically initialize variables.
Every variable has a name, a , a data type, and a size.
When a new  is assigned to a variable, the old  is lost.
Only an assignment statement or an input (read) statement can change the of a variable.
In Cplus_plus, >> is called the stream extraction operator.
Input from the standard input device is accomplished by using cin and the stream extraction operator >>.
When data is input in a program, the data items, such as numbers, are usually separated by blanks, lines, or tabs.
In Cplus_plus, << is called the stream insertion operator.
Output of the program to the standard output device is accomplished by using cout and the stream insertion operator <<.
The manipulator endl positions the insertion point at the beginning of the next line on an output device.
Outputting or accessing the  of a variable in an expression does not destroy or modify the contents of the variable.
The character \ is called the escape character.
The sequence \n is called the newline escape sequence.
All preprocessor commands start with the symbol #.
The preprocessor commands are processed by the preprocessor before the program goes through the compiler.
The preprocessor command #include <iostream> instructs the preprocessor to include the header file iostream in the program.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 2: Basic Elements of Cplus_plus To use cin and cout, the program must include the header file iostream and either include the statement using namespace std; or refer to these identifiers as std::cin  std::cout.
All Cplus_plus statements end with a semicolon.
The semicolon in Cplus_plus is called the statement terminator.
A Cplus_plus system has three components: environment, language,  the standard libraries.
Standard libraries are not part of the Cplus_plus language.
They contain functions to perform operations, such as mathematical operations.
A file containing a Cplus_plus program usually ends with the extension _0_cpp.
Prompt lines are executable statements that tell the user what to do.
Corresponding to the five arithmetic  +, -, *, /,  %, Cplus_plus provides five compound : +=, -=, *=, /=,  %=, respectively.
EXERCISES The number in parentheses at the end of an exercise refers to the learning objective listed at the beginning of the chapter.
Mark the following statements as true or false.
In  mixed expression, all the operands are converted to floating-point = 5.
After the statement  = xplus_plus; executes,  is 5 = 5.
After the statement plus_plusa; executes, the  of  is still 5 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook /or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Weekly Quiz h.
Chapter 2: Basic Elements of Cplus_plus = = = = =.
Assume that a.
Declare int variables  and.
Declare and initialize an int variable temp to 10 and a char variable ch to 'A'.
Update the value of an int variable  by adding 5 to it.
Declare and initialize a  variable payRate to 12_0_50.
Copy the value of an int variable firstNum into an int variable tempNum.
Swap the contents of the int variables  and.
Output the contents of , , and the expression  + 12 /  - 18.
Declare a char variable  and set the value of  to 'A'.
Declare int variables to store four integers.
Copy the value of a  variable  to the nearest integer into an int variable.
The character that represents 65.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Assign the value B+ to the variable.
Assign the string seventh edition to the variable str.
Increment the value of the int variable  by 1.
Suppose , , and z are int variables and w and t are  variables.
What value is assigned to each of these variables after the last statement z w t 16.
What value is assigned to each of = = = = = wplus_plus = 15.
Suppose    are int variables,    double variable,   = 32, = 16,   = 4_0_5.
What  the output  the following statements.
Give meaningful identifiers for the following variables  write  proper.
A A A A A variable variable variable variable variable to to to to to store store store store store the the the the the first name   student.
Output the tab character.
Output double quotation mark.
Declare int variables num1  num2.
Prompt the user to input two integers.
Input the first number in num1  the second number in num2.
Output num1, num2,  2  num1 minus num2.
Your output must identify each number  the expression.
The following program has syntax errors.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The following program has syntax errors.
On each successive const  =  = '*' const int  = 71;.
Chapter 2: Basic Elements of Cplus_plus The following program has syntax errors and/or the statements are in the incorrect order.
On each successive line, assume that any using namespace std;.
What value is assigned to each variable after each statement executes.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Miller 34 62_0_5 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Write  program that produces the following output: ********************************** * Programming Assignment 1 * * Computer Programming I * * Author: _0__0_.
If necessary, adjust the positions and the  of the stars to produce  rectangle.
Write  program that produces the following output: CCCCCCCCC plus_plus CC plus_plus CC plus_plusplus_plusplus_plusplus_plusplus_plusplus_plusplus_plus CC plus_plusplus_plusplus_plusplus_plusplus_plusplus_plusplus_plus CC plus_plus CCCCCCCCC plus_plus plus_plus plus_plus plus_plusplus_plusplus_plusplus_plusplus_plusplus_plusplus_plus+ plus_plusplus_plusplus_plusplus_plusplus_plusplus_plusplus_plus+ plus_plus plus_plus Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Write a Cplus_plus statement that includes the header file iostream.
Write a Cplus_plus statement that allows you to use cin, , and endl without the prefix std::.
Write Cplus_plus statement(s) that declare the following variables: 1, 2, 3, and average of type int.
Write Cplus_plus statements that store 125 into 1, 28 into 2, and -25 into 3.
Write a Cplus_plus statement that stores the average of 1, 2, and 3, into average.
Write Cplus_plus statement(s) that output the values of 1, 2, 3, and average.
Compile and run your program.
Repeat Exercise 3 by declaring 1, 2, and 3, and average of type double.
Consider the following Cplus_plus program in which the statements are in the incorrect order.
Rearrange the statements so that it prompts the user to input the radius of a circle and outputs the area and circumference of the circle.
Write Cplus_plus statements that  the header files iostream and string.
Write a Cplus_plus statement that allows you to use cin, , and endl without the prefix std::.
Write Cplus_plus statements that declare the following variables: name of type string and studyHours of type double.
Write Cplus_plus statements that prompt and input a string into name and a double value into studyHours.
Write a Cplus_plus statement that outputs the values of name and studyHours and the value of studyHours is 4_0_5, the output is: Hello, Donald.
Compile and run your program.
Write a program that prompts the user to input a decimal number and outputs the number rounded to the nearest integer.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Write Cplus_plus statements that  the header files iostream and string.
Write a Cplus_plus statement that allows you to use cin, , and endl without the prefix std::.
Write Cplus_plus statements that declare and initialize the following named constants: SECRET of type int initialized to 11 and RATE of type double initialized to 12_0_50.
Write Cplus_plus statements that declare the following variables: 1, 2, and newNum of type int; name of type string; and hoursWorked and wages of type double.
Write Cplus_plus statements that prompt the user to input two integers and store the first number in 1 and the second number in 2.
Write a Cplus_plus statement(s) that outputs the values of 1 and 2, indicating which is 1 and which is 2.
For example, if 1 is 8 and 2 is 5, then the output is: The value of 1 = 8 and the value of 2 = 5.
Write a Cplus_plus statement that multiplies the value of 1 by 2, adds the value of 2 to it, and then stores the result in newNum.
Then, write a Cplus_plus statement that outputs the value of newNum.
Write a Cplus_plus statement that updates the value of newNum by adding the value of the named constant SECRET to it.
Then, write a Cplus_plus statement that outputs the value of newNum with an appropriate message.
Write Cplus_plus statements that prompt the user to enter a person's last name and then store the last name into the variable name.
Write Cplus_plus statements that prompt the user to enter a decimal number between 0 and 70 and then store the number entered into hoursWorked.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Write Cplus_plus statements that produce the following output: Name: Pay Rate: $ Hours Worked: Salary: $.
Write a Cplus_plus program that tests each of the Cplus_plus statements that you wrote in parts a through l.
Place the statements at the appropriate place in the Cplus_plus program segment given at the beginning of this problem.
Test run your program (twice) on the following input data: a.
Write a program that prompts the user to enter five test scores and then prints Write a program that prompts the user to input five decimal numbers.
The program should then add the five decimal numbers, convert the sum to the nearest integer, and print the result.
Write a program that prompts the capacity, in gallons, of an automobile fuel tank and the miles per gallon the automobile can be driven.
The program outputs the number of miles the automobile can be driven without refueling.
Write a Cplus_plus program that prompts the user to input the elapsed time for an event in seconds.
The program then outputs the elapsed time in hours, minutes, and seconds.
The program then outputs the To make a profit, a local store marks up the prices of its items by a certain percentage.
Write a Cplus_plus program that reads the original price of the item sold, the percentage of the marked-up price, and the sales tax rate.
The program then outputs the original price of the item, the percentage of the Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
This is due to the fact that, typically, a manufacturer uses 1000 bytes as the value of 1K bytes, 1000K bytes as the value of 1MB, 1000MB as the value of 1GB.
Therefore, a 40GB byte hard drive contains 40,000,000,000 bytes.
However, in computer memory, as given in Table 1-1 (Chapter 1), 1KB is equal to 1024 bytes, and so on.
So the actual storage on a 40GB hard drive is approximately 37_0_25GB.
Write a program to implement and test the algorithm that you designed for Exercise 17 of Chapter 1.
A milk carton can hold 3_0_78 liters of milk.
Each morning, a dairy farm ships cartons of milk to a local grocery store.
The cost of producing one liter of milk is $0_0_38, and the profit of each carton of milk is $0_0_27.
Write a program that does the following: a.
Chapter 2: Basic Elements of Cplus_plus Prompts the user to enter the total amount of milk produced in the morning.
Outputs the number of milk cartons needed to hold milk.
Outputs the profit for producing milk.
Redo Programming Exercise 16 so that the user can also input the cost of producing one liter of milk and the profit on each carton of milk.
You found an exciting summer job for five weeks.
It pays, say, $15_0_50 per hour.
Suppose that the total tax you pay on your summer job income is 14%.
After paying the taxes, you spend 10% of your net income to buy new  and other accessories for the next school year and 1% to buy school supplies.
After buying  and school supplies, you use 25% of the remaining money to buy savings bonds.
For each dollar you spend to buy savings bonds, your parents spend $0_0_50 to buy additional savings bonds for you.
Write a program that prompts the user to enter the pay rate for an hour and the number of hours you worked each week.
The program then outputs the following: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Exercises a.
The money you spend on  and other accessories.
The money you spend on school supplies.
The money you spend to buy savings bonds.
The money your parents spend to buy additional savings bonds for you.
Write a program that prompts the user to input a number of quarters, dimes, and nickels.
The program then outputs the total value of the coins in pennies.
Newton's law states that the force, F, between two bodies of masses M1 and M2 is given by:   M M F ¼ k d1 2 2 ; in which k is the gravitational constant and d is the distance between the bodies.
The value of k is approximately 6_0_6710-8 dyn.
Write a program that prompts the user to input the masses of the bodies and the distance between the bodies.
The program then outputs the force between the bodies.
One metric ton is approximately 2205 pounds.
Write a program that prompts the user to input the amount of rice, in pounds, a bag can hold.
The program outputs the number of bags needed to store one metric ton of rice.
Cindy uses the services of a brokerage firm to buy and sell stocks.
The firm charges 1_0_5% service charges on the total amount for each transaction, buy or sell.
When Cindy sells stocks, she would like to know if she gained or lost on a particular investment.
Write a program that allows Cindy to input the number of shares sold, the purchase price of each share, and the selling price of each share.
The program outputs the amount invested, the total service charges, amount gained or lost, and the amount received after selling the stock.
A piece of wire is to be bent in the form of a rectangle to put around a picture frame.
The length of the picture frame is 1_0_5 times the width.
Write a program that prompts the user to input the length of the wire and outputs the length and width of the picture frame.
Repeat Exercise 23, but the wire is to be bent in the form of a circle.
In this case, the user specifies the length of the wire and the program outputs the radius and area of the circle.
Also declare Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 2: Basic Elements of Cplus_plus A room has one door, two windows, and a built-in bookshelf and it needs to be painted.
Suppose that one gallon of paint can paint 120 square feet.
Write the program that prompts the user to input the lengths and widths of the door, each window, the bookshelf; and the length, width, and height of the room (in feet).
The program outputs the amount of paint needed to paint the walls of the room.
Modify Exercise 25 so that the user can also specify the area that can be painted with one gallon of paint.
In an elementary school, a mixture of equal amounts of nuts and dried fruit is provided during lunch.
Suppose that the number of calories in each pound of nuts is 0_0_70 times the number of calories in each pound of dried fruit.
Write a program that prompts the user to input the number of students in the elementary school, the number of calories required for each student from the mixture, and the number of calories in each pound of nuts.
The program outputs the amount of nuts and dried fruit needed for the students.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Become familiar with file input and output Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
You used cin and the extraction operator >> to get data from the keyboard, and cout and the insertion operator << to send output to the screen.
Because I/O operations are fundamental to any programming language, in this chapter, you will learn about Cplus_plus's I/O operations in more detail.
First, you will learn about statements that extract input from the standard input device and send output to the standard output device.
You will then learn how to format output using manipulators.
In addition, you will learn about the limitations of the I/O operations associated with the standard input/output devices and learn how to extend these operations to other devices.
I/O Streams and Standard I/O Devices A program performs three basic operations: it gets data, it manipulates the data, and it outputs the results.
In Chapter 2, you learned how to manipulate numeric data using arithmetic operations.
In later chapters, you will learn how to manipulate nonnumeric data.
Because writing programs for I/O is quite complex, Cplus_plus offers extensive support for I/O operations by providing substantial prewritten I/O operations, some of which you encountered in Chapter 2.
In this chapter, you will learn about various I/O operations that can greatly enhance the flexibility of your programs.
In Cplus_plus, I/O is a sequence of bytes, called a stream, from the source to the destination.
The bytes are usually characters, unless the program requires other types of information, such as a graphic image or digital speech.
Therefore, a stream is a sequence of characters from the source to the destination.
There are two types of streams: Input stream: A sequence of characters from an input device to the computer.
Output stream: A sequence of characters from the computer to an output device.
Recall output output header that the standard input device is usually the keyboard, and the standard device is usually the screen.
To receive data from the keyboard and send to the screen, every Cplus_plus program must use the header file iostream.
This file contains, among other things, the definitions of two data types, istream (input stream) and ostream (output stream).
The header file also contains two variable declarations, one for cin (pronounced "see-in"), which stands for common input, and one for cout (pronounced "see-out"), which stands for common output.
These variable declarations are similar to the following Cplus_plus statements: istream cin;.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
I/O Streams and Standard I/O Devices.
Without the statement using namespace std;, you refer to these identifiers as std::cin and std::cout.
In Chapter 7, you will learn about the meaning of the statement using namespace std; in detail.
Variables of type istream are called input stream variables; variables of type ostream are called output stream variables.
A stream variable is either an input stream variable or an output stream variable.
Because cin and cout are already defined and have specific meanings, to avoid confusion, you should never redefine them in programs.
The variable cin has access to operators and functions that can be used to extract data from the standard input device.
You have briefly used the extraction operator >> to input data from the standard input device.
The next section describes in detail how the extraction operator >> works.
In the following sections, you will learn how to use the functions get, ignore, peek, and putback to input data in a specific manner.
Suppose payRate is a double variable.
Consider the following Cplus_plus statement: cin >> payRate; When the computer executes this statement, it inputs the next number typed on the keyboard and stores this number in payRate.
Therefore, if the user types 15_0_50, the value stored in payRate is 15_0_50.
The extraction operator >> is binary and thus takes two operands.
The left-side operand must be an input stream variable, such as cin.
Because the purpose of an input statement is to read and store values in a memory location and because only variables refer to memory locations, the right-side operand is a variable.
The extraction operator >> is defined only for putting data into variables of simple data types.
Therefore, the right-side operand of the extraction operator >> is a variable of the simple data type.
However, Cplus_plus allows the programmer to extend the definition of the extraction operator >> so that data can also be put into other types of variables by using an input statement.
You will learn this mechanism in Chapter 13 later in this book.
The syntax of an input statement using cin and the extraction operator >> is: cin >> variable >> variable_0__0__0_;.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Chapter 3: Input/Output As you can see in the preceding syntax, a single input statement can read more than one data item by using the operator >> several times.
Every occurrence of >> extracts the next data item from the input stream.
For example, you can read both payRate and hoursWorked via a single input statement by using the following code: cin >> payRate >> hoursWorked;.
When scanning for the next input, >> skips all whitespace characters.
Recall that whitespace characters consist of blanks and certain nonprintable characters, such as tabs and the newline character.
Thus, whether you separate the input data by lines or blanks, the extraction operator >> simply finds the next input data in the input stream.
For example, suppose that payRate and hoursWorked are double variables.
Consider the following input statement: cin >> payRate >> hoursWorked; Whether the input is: 15_0_50 48_0_30 or: 15_0_50 48_0_30 or: 15_0_50 48_0_30 the preceding input statement would store 15_0_50 in payRate and 48_0_30 in hoursWorked.
Note that the first input is separated by a blank, the second input is separated by a tab, and the third input is separated by a line.
Now suppose that the input is 2.
How does the extraction operator >> distinguish between the character 2 and the number 2.
The right-side operand of the extraction operator >> makes this distinction.
If the right-side operand is a variable of the data type char, the input 2 is treated as the character 2 and, in this case, the ASCII value of 2 is stored.
If the right-side operand is a variable of the data type int or double, the input 2 is treated as the number 2.
Next, consider the input 25 and the statement: cin >> a; where a is a variable of some simple data type.
If a is of the data type char, only the single character 2 is stored in a.
If a is of the data type int, 25 is stored in a.
If a is of the data type Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
I/O Streams and Standard I/O Devices.
Table 3-1 summarizes this discussion by showing the valid input for a variable of the simple data type.
TABLE 3-1 Valid Input for a Variable of the Simple Data Type.
If the actual data input is an integer, the input is converted to a decimal number with the zero decimal part.
When reading data into a char variable, after skipping any leading whitespace characters, the extraction operator >> finds and stores only the next character; reading stops after a single character.
To read data into an int or double variable, after skipping all leading whitespace characters and reading the plus or minus sign (if any), the extraction operator >> reads the digits of the number, including the decimal point for floating-point variables, and stops when it finds a whitespace character or a character other than a digit.
The following statements show how the extraction operator >> works.
A AB Value Stored in Memory = 'A' = 'A', 'B' is held for later input 3.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
For statement 1, data is entered on the same line separated by blanks.
For statement 2, data is entered on two lines; the first two input values are separated by two blank spaces, and the third input is on the next line.
For statement 3, all three input values are separated by lines, and for statement 4, all three input values are on the same line, but there is no space between them.
Note that the second input is  nonnumeric character.
These statements work as follows.
Statements 1, 2, and 3 are easy to follow.
Let us look at statement 4.
In statement 4, first the extraction operator >> extracts 57 from the input stream and stores it in.
Then, the extraction operator >> extracts the character 'A' from the input stream and stores it in.
Next, 26_0_9 is extracted and stored in.
Note that statements 1, 2, and 3 illustrate that regardless of whether the input is separated by blanks or by lines, the extraction operator >> always finds the next input.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
I/O Streams and Standard I/O Devices.
Next, 'B' is extracted and stored in.
Finally, 34 is extracted and stored in.
Statement 2 works similarly.
In statement 3, 11 is stored in , and 34 is stored in , but the input stream does not have enough input data to fill each variable.
In this case, the computer waits (and waits, and waits.
The computer does not continue to execute until the next value is entered.
In statement 4, the first right-side operand of the extraction operator >> is  variable of the type int, and the input is 78_0_49.
Now for int variables, after inputting the digits of the number, the reading stops at the first whitespace character or  character other than digit.
Therefore, the operator >> stores 78 into.
The next right-side operand of >> is the variable , which is of the type double.
Therefore, the operator >> stores the value _0_49 as 0_0_49 into.
In statement 5, the first right-side operand of the extraction operator >> is  char variable, so the first nonwhitespace character, '2', is extracted from the input stream.
The character '2' is stored in the variable.
The next right-side operand of the extraction operator >> is an int variable, so the next input value, 56, is extracted and stored in.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 3: Input/Output In statement 6, the first right-side operator of the extraction operator >> is an int variable, so the first data item, 256, is extracted from the input stream and stored in.
Now the computer waits for the next data item for the variable.
In statement 7, '' is stored into 1.
The extraction operator >> then skips the blank, and 'B' is stored in 2.
Recall that during program execution, when entering character data such as letters, you do not enter the single quotes around the character.
What happens if the input stream has more data items than required by the program.
After the program terminates, any values left in the input stream are discarded.
When you enter data for processing, the data values should correspond to the data types of the variables in the input statement.
Recall that when entering  number for  double variable, it is not necessary for the input number to have  decimal part.
If the input number is an integer and has no decimal part, it is converted to  decimal value.
The computer, however, does not tolerate any other kind of mismatch.
For example, entering char value into an int or double variable causes serious errors, called input failure.
Input failure is discussed later in this chapter.
The extraction operator, when scanning for the next input in the input stream, skips whitespace such as blanks and the newline character.
However, there are situations when these characters must also be stored and processed.
For example, if you are processing text in  line-by-line fashion, you must know where in the input stream the newline character is located.
Without identifying the position of the newline character, the program would not know where one line ends and another begins.
The next few sections teach you how to input data into  program using the input functions, such as get, ignore, putback, and peek.
These functions are associated with the data type istream and are called istream member functions.
I/O functions, such as get, are typically called stream member functions or stream functions.
Before you can learn about the input functions get, ignore, putback, peek, and other I/O functions that are used in this chapter, you need to first understand what  function is and how it works.
You will study functions in detail and learn how to write your own in Chapter 6.
Using Predefined Functions in  Program As noted in Chapter 2,  function, also called  subprogram, is  set of instructions.
When function executes, it accomplishes something.
The function main, as you saw in Chapter 2, executes automatically when you run  program.
Other functions execute Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Using Predefined Functions in  Program | 131 only when they are activated—that is, called.
Cplus_plus comes with  wealth of functions, called predefined functions, that are already written.
In this section, you will learn how to use some predefined functions that are provided as part of the Cplus_plus system.
Later in this chapter, you will learn how to use stream functions to perform  specific I/O operation.
Recall from Chapter 2 that predefined functions are organized as  collection of libraries, called header files.
Therefore, to use  particular function, you need to know the name of the function and  few other things, which are described shortly.
That is, (x, y) =ﬃﬃﬃﬃﬃﬃﬃ xy.
For example, (2_0_0, 3_0_0) = 2_0_03_0_0 = 8_0_0 and ﬃ 0_0_5 (4_0_0, 0_0_5) = 4_0_0 = 4:0 = 2_0_0.
The numbers x and y that you use in the function  are called the arguments or parameters of the function.
For example, in (2_0_0, 3_0_0), the parameters are 2_0_0 and 3_0_0.
An expression such as (2_0_0, 3_0_0) is called  function call, which causes the code attached to the predefined function  to execute and, in this case, computes 2_0_03_0_0.
The header file cmath contains the specification of the function.
To use  predefined function in  program, you need to know the name of the header file containing the specification of the function and include that header file in the program.
In addition, you need to know the name of the function, the number of parameters the function takes, and the type of each parameter.
You must also be aware of what the function is going to do.
For example, to use the function , you must include the header file cmath.
The function  has two parameters, which are decimal numbers.
The function calculates the first parameter to the power of the second parameter.
More specifically, we use some math functions, from the header file cmath, and the string function length, from the header file string.
Note that the function length determines the length of a string.
EXAMPLE 3-4 //How to use predefined functions.
If (x1,y1) and (x2,y2) are the coordinates of two //points in the X-Y plane, then the distance between these points is.
Sample Run: In this sample run, the user input is shaded.
Line 7: Enter the radius of the sphere: 3 Line 11: The volume of the sphere is: 113_0_098 Line 12: Enter the coordinates of two points in the X-Y plane: 4 7 9 -5 Line 16: The  between the points (4, 7) and (9, -5) is: 13 Line 18: The number of characters, including blanks, in "Programming with Cplus_plus" is: 20 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Using Predefined Functions in a Program | 133 The preceding program works as follows.
The statements in Lines 1 to 6 declare the variables used in the program.
The statement in Line 7 prompts the user to enter the radius of the sphere, and the statement in Line 8 stores the radius in the variable sphereRadius.
The statement in Line 10 uses the function  to compute and store the volume of the sphere in the variable.
The statement in Line 11 outputs the volume.
The statement in Line 12 prompts the user to enter the coordinates of two points in the X-Y plane, and the statement in Line 13 stores the coordinates in the variables point1X, point1Y, point2X, and point2Y, respectively.
The statement in Line 15 uses the functions sqrt and  to determine the  between the points.
The statement in Line 16 outputs the  between the points.
The statement in Line 17 stores the string "Programming with Cplus_plus" in.
The statement in Line 18 uses the string function  to determine and output the  of.
Note how the function  is used.
Later in this chapter we will explain the meaning of expressions such as _0_().
Because I/O is fundamental to any programming language and because writing instructions to perform a specific I/O operation is not a job for everyone, every programming language provides a set of useful functions to perform specific I/O operations.
In the remainder of this chapter, you will learn how to use some of these functions in a program.
As a programmer, you must pay close attention to how these functions are used so that you can get the most out of them.
The first function you will learn about here is the function get.
Now consider the following statement: cin >> ch1 >> ch2 >> num; When the computer executes this statement, 'A' is stored in ch1, the blank is skipped by the extraction operator >>, the character '2' is stored in ch2, and 5 is stored in num.
However, what if you intended to store 'A' in ch1, the blank in ch2, and 25 in num.
It is clear that you cannot use the extraction operator >> to input this data.
As stated earlier, sometimes you need to process the entire input, including whitespace characters, such as blanks and the newline character.
For example, suppose you want to Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 3: Input/Output process the entered data on a line-by-line basis.
Because the extraction operator >> skips the newline character and unless the program captures the newline character, the computer does not know where one line ends and the next begins.
The variable cin can access the stream function get, which is used to read character data.
The get function inputs the very next character, including whitespace characters, from the input stream and stores it in the memory location indicated by its argument.
The function get comes in many forms.
Next, we discuss the one that is used to read a character.
The syntax of cin, together with the get function to read a character, follows: cin_0_get(varChar); In the cin_0_get statement, varChar is a char variable.
The effect of the preceding statement would be to store the next input character in the variable varChar.
Now consider the following input again: A 25 To store 'A' in ch1, the blank in ch2, and 25 in num, you can effectively use the get.
Because this form of the get function has only one argument and reads only one character and you need to read two characters from the input stream, you need to call this function twice.
Notice that you cannot use the get function to read data into the variable num because num is an int variable.
The preceding form of the get function reads values of only the char data type.
The preceding set of cin_0_get statements is equivalent to the following statements:.
For the next few chapters, you need only the form of the function get introduced here.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Using Predefined Functions in a Program | 135 cin and the ignore Function When you want to process only partial data (say, within a line), you can use the stream function ignore to discard a portion of the input.
The syntax to use the function ignore is: cin_0_ignore(intExp, chExp); Here, intExp is an integer expression yielding an integer value, and chExp is a char expression yielding a char value.
In fact, the value of the expression intExp specifies the maximum number of characters to be ignored in a line.
Suppose intExp yields a value of, say 100.
This statement says to ignore the next 100 characters or ignore the input until it encounters the character specified by chExp, whichever comes first.
To be specific, consider the following statement: cin_0_ignore(100, '\n'); When this statement executes, it ignores either the next 100 characters or all characters until the newline character is found, whichever comes first.
For example, if the next 120 characters do not contain the newline character, then only the first 100 characters are discarded and the next input data is the character 101.
However, if the 75th character is the newline character, then the first 75 characters are discarded and the next input data is the 76th character.
Similarly, the execution of the statement: cin_0_ignore(100, 'A'); results in ignoring the first 100 characters or all characters until the character 'A' is found, whichever comes first.
EXAMPLE 3-5 Consider the declaration: int a, b; and the input: 25 67 89 43 72 12 78 34.
The third statement, cin >> b;, stores 12 (from the next line) in b.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 3: Input/Output.
Consider the declaration: char ch1, ch2; and the input:.
The first statement, cin >> ch1;, stores 'H' in ch1.
The second statement, cin_0_ignore(100, '_0_');, results in discarding all characters until.
Thus, the extraction operator skips the space after.
Suppose that we have the following statement:.
The first statement, cin >> ch1;, stores 'H' in ch1.
The second statement, cin_0_ignore(5, '_0_');, results in discarding the next five characters, that is, until t.
The third statement, cin >> ch2;, stores the character 't' (from the same line) in ch2.
When the function ignore is used without any arguments, then it only skips the very next character.
For example, the following statement will skip the very next character: cin_0_ignore(); This statement is typically used to skip the newline character.
The putback and peek Functions Suppose you are processing data that is a mixture of numbers and characters.
Moreover, the numbers must be read and processed as numbers.
You have also looked at many sets of sample data and cannot determine whether the next input is a character or a number.
You could read the entire data set character by character and check whether a certain character is a digit.
If a digit is found, you could then read the remaining digits of the number and somehow convert these characters into numbers.
This programming code would be somewhat complex.
Fortunately, Cplus_plus provides two very useful stream functions that can be used effectively in these types of situations.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Using Predefined Functions in a Program | 137 The stream function putback lets you put the last character extracted from the input stream by the get function back into the input stream.
The stream function peek looks into the input stream and tells you what the next character is without removing it from the input stream.
By using these functions, after determining that the next input is a number, you can read it as a number.
You do not have to read the digits of the number as characters and then convert these characters to that number.
The peek function returns the next character from the input stream but does not remove the character from that stream.
In other words, the function peek looks into the input stream and checks the identity of the next input character.
Moreover, after checking the next input character in the input stream, it can store this character in a designated memory location without removing it from the input stream.
That is, when you use the peek function, the next input character stays the same, even though you now know what it is.
The syntax to use the function peek is: = istreamVar_0_peek(); Here, istreamVar is an input stream variable, such as cin, and  is a char variable.
Notice how the function peek is used.
First, the function peek is used in an assignment statement.
It is not a stand-alone statement like get, ignore, and putback.
Second, the function peek has empty parentheses.
Until you become comfortable with using a function and learn how to write one, pay close attention to how to use a predefined function.
The following example illustrates how to use the peek and putback functions.
Sample Run: In this sample run, the user input is shaded.
Line 1: Enter a string: abcd Line Line Line Line Line.
The user input, abcd, allows you to see the effect of the functions get, putback, and peek in the preceding program.
The statement in Line 1 prompts the user to enter a string.
In Line 2, the statement cin_0_get(); extracts the first character from the input stream and stores it in the variable.
So after Line 2 executes, the value of  is 'a'.
The  statement in Line 4 outputs the value of.
The statement cin_0_get(); in Line 5 extracts the next character from the input stream, which is 'b', and stores it in.
At this point, the value of  is 'b'.
The  statement in Line 6 outputs the value of.
The cin_0_putback(); statement in Line 7 puts the previous character extracted by the get function, which is 'b', back into the input stream.
Therefore, the next character to be extracted from the input stream is 'b'.
The cin_0_get(); statement in Line 8 extracts the next character from the input stream, which is still 'b', and stores it in.
Now the value of  is 'b'.
The statement in Line 9 outputs the value of  as 'b'.
In Line 10, the statement  = cin_0_peek(); checks the next character in the input stream, which is 'c', and stores it in.
The value of  is now 'c'.
The  statement in Line Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Using Predefined Functions in a Program |.
The cin_0_get(); statement in Line 12 extracts the next character from the input stream and stores it in.
The  statement in Line 13 outputs the value of , which is still 'c'.
Note that the statement  = cin_0_peek(); in Line 10 did not remove the character 'c' from the input stream; it only peeked into the input stream.
The output of Lines 11 and 13 demonstrates this functionality.
The Dot Notation between I/O Stream Variables and I/O Functions: A Precaution In the preceding sections, you learned how to manipulate an input stream to get data into a program.
You also learned how to use the functions get, ignore, peek, and putback.
It is important that you use these functions exactly as shown.
For example, to use the get function, you used statements such as the following: cin_0_get(); Omitting the dot—that is, the period between the variable cin and the function name.
Similarly, missing parentheses, as in cin_0_getch;, result in a syntax error.
Also, remember that you must use the input functions together with an input stream variable.
If you try to use any of the input functions alone—that is, without the input stream variable—the compiler might generate an error message such as "undeclared _0_" For example, the statement get(); could result in a syntax error.
As you can see, several functions are associated with an istream variable, each doing a specific job.
Recall that the functions get, ignore, and so on are members of the data type istream.
Called the dot notation, the dot separates the input stream variable name from the member, or function, name.
In fact, in Cplus_plus, the dot is an operator called the member access operator.
Cplus_plus has a special name for the data types istream and ostream.
The data types istream and ostream are called classes.
The variables cin and  also have special names, called objects.
Therefore, cin is called an istream object, and  is called an ostream object.
In fact, stream variables are called stream objects.
You will learn these concepts in Chapter 11 later in this book.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 3: Input/Output Input Failure Many things can go wrong during program execution.
A program that is syntactically correct might produce incorrect results.
For example, suppose that a part-time employee's paycheck is calculated by using the following formula: = payRate * hoursWorked; If you accidentally type + in place of *, the calculated  would be incorrect, even though the statement containing a + is syntactically correct.
What about an attempt to read invalid data.
For example, what would happen if you tried to input a letter into an int variable.
If the input data did not match the corresponding variables, the program would run into problems.
For example, trying to read a letter into an int or double variable would result in an input failure.
Consider the following statements: int a, b, c; double x;.
If the input were: 35 67_0_93 48 then the input statement: cin >> a >> x > >b; would result in storing 35 in a, 67_0_93 in x, and 48 in b.
Because the next variable c is of the data type int, the computer tries to read.
The input stream then enters a state called the fail state.
What actually happens when the input stream enters the fail state.
Once an input stream enters the fail state, all further I/O statements using that stream are ignored.
Unfortunately, the program quietly continues to execute with whatever values are stored in variables and produces incorrect results.
The program in Example 3-8 illustrates an input failure.
This program on your system may produce different results.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Input Failure |.
Sample Runs: In these sample runs, the user input is shaded.
Sample Run 1 Line 5: Enter , , , and : Sam 35 q56 6_0_2 Line Line Line Line 8: : Sam 9: : 35 10: : 0 11: : 0 The statements in Lines 1, 2, 3, and 4 declare the variables , , , and , and also initialize the variable , , and.
The statement in Line 5 prompts the user to enter a person's , , , and ; the statement in Line 6 inputs these values into variables , , , and , respectively.
In this sample run, the third input is q56 and the cin statement tries to input this into the variable.
However, the input q56 begins with the character 'q' and  is a variable of type int, so cin enters the fail state.
Note that the printed values of the variables  and  are unchanged, as shown by the output of the statements in Lines 10 and 11.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Next the cin statement tries to input the decimal point into , which is an int variable.
So the input stream enters the fail state and the values of  and  are unchanged, as shown by the output of the statements in Lines 10 and 11.
The clear Function When an input stream enters the fail state, the system ignores all further I/O using that stream.
You can use the stream function clear to restore the input stream to a working state.
The syntax to use the function clear is: istreamVar_0_clear(); Here, istreamVar is an input stream variable, such as cin.
After using the function clear to return the input stream to a working state, you still need to clear the rest of the garbage from the input stream.
This can be accomplished by using the function ignore.
Example 3-9 illustrates this situation.
EXAMPLE 3-9 //Input failure and the clear function.
Sample Run: In this sample run, the user input is shaded.
Line 5: Enter , , , and : Sam 35 q56 6_0_2 Line Line Line Line 8: : Sam 9: : 35 10: : 0 11: : 0 Line 14: Enter , , , and : Sam 35 156 6_0_2 Line Line Line Line 17: 18: 19: 20: : Sam : 35 : 156 : 6_0_2 The statements in Lines 1, 2, 3, and 4 declare the variables , , , and , and also initialize the variable , , and.
The statement in Line 5 prompts the user to enter a person's , , , and ; the statement in Line 6 inputs these values into variables , , , and , respectively.
As in Example 3-8, when the cin statement tries to input q56 into , it enters the fail statement.
The statement in Line 12 restores the input stream by using the function clear, and the statement in Line 13 ignores the rest of the input.
The statement in Line 14 again prompts the user to input a person's , , , and ; the statement in Line 15 stores these values in , , , and , respectively.
Next, the statements in Lines 17 to 20 output the values of , , , and.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 3: Input/Output Output and Formatting Output Other than writing efficient programs, generating the desired output is one of a programmer's highest priorities.
Chapter 2 briefly introduced the process involved in generating output on the standard output device.
More precisely, you learned how to use the insertion operator << and the manipulator endl to display results on the standard output device.
However, there is a lot more to output than just displaying results.
Sometimes, floatingpoint numbers must be output in a specific way.
For example, a paycheck must be printed to two decimal places, whereas the results of a scientific experiment might require the output of floating-point numbers to six, seven, or perhaps even ten decimal places.
Also, you might like to align the numbers in specific columns or fill the empty space between strings and numbers with a character other than the blank.
For example, in preparing the table of contents, the space between the section heading and the page number might need to be filled with dots or dashes.
In this section, you will learn about various output functions and manipulators that allow you to format your output in a desired way.
Recall that the syntax of  when used together with the insertion operator << is: << expression or  << expression or _0__0__0_; Here, expression is evaluated, its value is printed, and  is used to format the output.
The simplest  that you have used so far is endl, which is used to move the insertion point to the beginning of the next line.
Other output manipulators that are of interest include setprecision, fixed, showpoint, and setw.
The next few sections describe these manipulators.
Usually, the default output of floating-point numbers is scientific notation.
Some integrated development environments (IDEs) might use a maximum of six decimal places for the default output of floating-point numbers.
However, when an employee's paycheck is printed, the desired output is a maximum of two decimal places.
To print floating-point output to two decimal places, you use the setprecision  to set the precision to 2.
The general syntax of the setprecision  is: where n is the number of decimal places.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Output and Formatting Output.
Notice that the number of decimal places, or the precision value, is passed as an argument to setprecision.
To use the  setprecision, the program must  the header file iomanip.
Thus, the following  statement is required: # <iomanip> fixed Manipulator To further control the output of floating-point numbers, you can use other manipulators.
To output floating-point numbers in a fixed decimal format, you use the fixed.
The following statement sets the output of floating-point numbers in a fixed decimal format on the standard output device: << fixed; After the preceding statement executes, all floating-point numbers are displayed in the fixed.
For example, to disable the  fixed on the standard output device, you use the following statement: _0_unsetf(ios::fixed); After the  fixed is disabled, the output of the floating-point numbers returns.
On some compilers, the statements  << fixed; and  << scientific;.
The following example shows how the manipulators scientific and fixed work without using the  setprecision.
Sample Run: = 35_0_45,  = 15,  = 531_0_75,  = 0_0_01 Scientific : = 3_0_545000e+001,  = 1_0_500000e+001,  = 5_0_317500e+002,  = 1 _0_000000e-002 Fixed decimal : = 35_0_450000,  = 15_0_000000,  = 531_0_750000,  = 0_0_010000 The sample run shows that when the value of  and  are printed without setting the scientific or fixed manipulators, the trailing zeros are not shown and, in the case of , the decimal point is also not shown.
After setting the manipulators, the values are printed to six decimal places.
In the next section, we describe the  showpoint to force the system to show the decimal point and trailing zeros.
We will then give an example to show how to use the manipulators setprecision, fixed, and showpoint to get the desired output.
In this case, when you instruct the computer to output the decimal number in a fixed decimal format, the output may not show the decimal point and the decimal part.
To force the output to show the decimal point and Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Output and Formatting Output.
Sample Run: 10: 11: 12: 13: 14: = 12_0_67 = 12_0_00 = 6051_0_80 = 3_0_14 15: 16: 17: 18: 19: = 12_0_670 = 12_0_000 = 6051_0_797 = 3_0_142 20: 21: 22: 23: 24: = 12_0_6700 = 12_0_0000 = 6051_0_7969 = 3_0_1416 25: 12_0_670, 12_0_00, 3_0_14159 In this program, the statement in  2 includes the header file iomanip, and the statement in  4 declares the named constant  and sets the value to eight decimal places.
The statements in Lines 7 and 8 declare and initialize the variables  and to store the  of the base and the  of a cylinder.
The statement in 10 sets the output of floating-point numbers in a  decimal format with a decimal point and trailing zeros.
The statements in Lines 11, 12, 13, and 14 output the values of , , , and  to two decimal places.
The statements in Lines 16, 17, 18, and 19 output the values of , , , and  to three decimal places.
The statements in Lines 21, 22, 23, and 24 output the values of , , , and  to four decimal places.
The statement in  25 outputs the value of  to three decimal places, the value of  to two decimal places, and the value of  to five decimal places.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Output and Formatting Output.
The value of printed in  16 contains a trailing 0.
This is because the stored value of has only two decimal places; a 0 is printed at the third decimal place.
In a similar manner, the value of  is printed in Lines 12, 17, and 22.
Also, notice how the statements in Lines 13, 18, and 23 calculate and output  to two, three, and four decimal places.
Note that the value of  printed in  24 is rounded.
The statement in  25 first sets the output of floating-point numbers to three decimal places and then outputs the value of  to three decimal places.
After printing the value of , the statement in  25 sets the output of floating-point numbers to two decimal places and then outputs the value of  to two decimal places.
Next, it sets the output of floating-point numbers to five decimal places and then outputs the value of  to five decimal places.
If you omit the statement in  9 and recompile and run the program, you will see the default output of the decimal numbers.
More specifically, the value of the expression that calculates the  might be printed in the scientific notation.
The manipulator  is used to output the value of an expression in a specific number of columns.
The value of the expression can be either a string or a number.
The expression (n) outputs the value of the next expression in n columns.
The output is rightjustified.
Thus, if you specify the number of columns to be 8, for example, and the output requires only four columns, the first four columns are left blank.
Furthermore, if the number of columns specified is less than the number of columns required by the output, the output automatically expands to the required number of columns; the output is not truncated.
For example, if  is an int variable, the following statement outputs the value of  in five columns on the standard output device: << (5) <<  << ;.
EXAMPLE 3-12 //Example: This example illustrates how the function.
Sample Run: 123456789012345678901234567890 245 245 55 35_0_45 3_0_76 55 24535_0_45 245 35_0_45 245 3_0_76.
The statement in Line 10 sets the output of floating-point numbers in a  decimal format with a decimal point and trailing zeros.
The output of the statement in Line 11 shows the column positions when the specific values are printed; it is the first line of output.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Additional Output Formatting Tools.
Because  has only three digits, only three columns are needed to output its value.
Therefore, the first two columns are left blank in the second line of output.
The statement in Line 13 sets the output of floating-point numbers to two decimal places.
The statement in Line 14 outputs the value of  in the first five columns, the value of in the next five columns, the value of  in the next six columns, and the value of in the next seven columns.
Because  contains four digits and a decimal point, five columns are required to output the value of.
Also, because the  function sets the output of  in six columns, the first column is left blank.
Similarly, the value of is output in seven columns leaving the first three columns blank.
The fourth line of output is blank because the manipulator  appears twice in the statement in Line 14.
The statement in Line 15 outputs the values of  in the first five columns,  in the next five columns, the value of  in the next four columns, and  in the following seven columns, creating the fifth line of output.
Note that to output the value of  at least five columns are required, but the program only specifies four columns, so the output of  is expanded to the required number of columns.
Also note that after printing the value of , the value of  is printed at the current cursor position (see the fifth line of output).
The statement in Line 16 sets the output of  in two columns.
However, the value of  contains three digits, so the value of  is expanded to the right number of columns.
After printing the value of , the value of  is printed in the next six columns followed by the value of  in the next seven columns.
The statement in Line 17 sets the output of  in two columns.
However, the value of  contains three digits, so the value of  is expanded to the right number of columns.
After printing the value of , the value of the string "" is printed in the next seven columns followed by the value of.
Because to output the value of the number of columns is not specified, after printing the string "" the value of  is printed (see the last line of the output).
Additional Output Formatting Tools In the previous section, you learned how to use the manipulators setprecision, , and showpoint to control the output of floating-point numbers and how to use the manipulator to display the output in specific columns.
Even though these manipulators are adequate to produce an elegant report, in some situations, you may want to do more.
In this section, you will learn additional formatting tools that give you more control over your output.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 3: Input/Output unused columns to the left are filled with spaces.
The output stream variables can use the manipulator setfill to fill the unused columns with a character other than a space.
The syntax to use the manipulator setfill is: << setfill(ch);.
To use the manipulator setfill, the program must  the header file iomanip.
The program in Example 3-13 illustrates the effect of using setfill in a program.
EXAMPLE 3-13 //Example: This program illustrates how the function.
Additional Output Formatting Tools << << << <<.
Sample Run: 123456789012345678901234567890 Jessica 3_0_75 7850 ***Jessica***3_0_75****7850 ***Jessica###3_0_75####7850 @@@Jessica###3_0_75^^^^7850 Jessica 3_0_75 7850 The statements in Lines 7, 8, and 9 declare and initialize the variables , , and to "Jessica", 3_0_75, and 7850, respectively.
The output of the statement in Line 10—the first line of output—shows the column position when the subsequent statements output the values of the variables.
The statement in Line 11, sets the output of decimal numbers in a  decimal format with a decimal point with two decimal places.
The statement in Line 12 outputs the value of  in ten columns, the value of  in seven columns, and the value of  in eight columns.
In this statement, the filling character is the blank character, as shown in the second line of output.
The statement in Line 13 sets the filling character to *.
The statement in Line 14 outputs the value of  in ten columns, the value of  in seven columns, and the value of in eight columns.
Because "Jessica" is a string of length 7 and ten columns are assigned to output its value, the first three columns are unused and are, therefore, filled by the filling character *.
Similarly, the columns unused by the values of and  are filled by *.
The output of the statement in Line 15—the fourth line of output—is similar to the output of the statement in Line 14, except that the filling character for  and is #.
In the output of the statement in Line 16 (the fifth line of output), the filling character for  is @, the filling character for  is #, and the filling character for  is ^.
The manipulator  sets these filling characters.
The statement in Line 17 sets the filling character to blank.
The statement in Line 18 outputs the values of , , and  using the filling character blank, as shown in the sixth line of output.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 3: Input/Output left and right Manipulators Recall that if the number of columns specified in the  manipulator exceeds the number of columns required by the next expression, the default output is right-justified.
Sometimes, you might want the output to be left-justified.
To left-justify the output, you use the manipulator left.
The syntax to set the manipulator left is: << left;.
Disabling the manipulator left returns.
For example, the following statement.
Additional Output Formatting Tools.
Sample Run: 123456789012345678901234567890 Jessica 3_0_75 7850 Jessica***3_0_75***7850**** Jessica***3_0_75###7850#### Jessica@@@3_0_75###7850^^^^ Jessica 3_0_75 7850 The output of this program is the same as the output of Example 3-13.
The only difference here is that for the statements in Lines 13 through 17, the output is leftjustified.
You are encouraged to do a walk-through of this program.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 3: Input/Output This chapter discusses several stream functions and stream manipulators.
To use stream functions such as get, ignore, fill, and clear in a program, the program must the header file iostream.
There are two types of manipulators: those with parameters and those without parameters.
Manipulators with parameters are called parameterized stream manipulators.
For example, manipulators such as setprecision, , and  are parameterized.
On the other hand, manipulators such as endl, , scientific, , and left do not have parameters.
To use a parameterized stream manipulator in a program, you must  the header file iomanip.
Manipulators without parameters are part of the iostream header file and, therefore, do not require inclusion of the header file iomanip.
Input/Output and the string Type You can use an input stream variable, such as cin, and the extraction operator >> to read a string into a variable of the data type string.
For example, if the input is the string "Shelly", the following code stores this input into the string variable :.
Recall that the extraction operator skips any leading whitespace characters and that reading stops at a whitespace character.
As a consequence, you cannot use the extraction operator to read strings that contain blanks.
For example, suppose that the variable is defined as noted above.
If the input is: Alice Wonderland then after the statement: cin >> ; executes, the value of the variable  is "Alice".
The syntax to use the function getline is: getline(istreamVar, strVar); where istreamVar is an input stream variable and strVar is a string variable.
The reading is delimited by the newline character '\n'.
The function getline reads until it reaches the end of the current line.
The newline character is also read but not stored in the string variable.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Debugging: Understanding Logic Errors and Debugging with  Statements |.
If the input is 29 characters:.
All 29 characters, including the first four blanks, are stored into.
Similarly, you can use an output stream variable, such as , and the insertion operator << to output the contents of a variable of the data type string.
Debugging: Understanding Logic Errors and Debugging with  Statements In the debugging section of Chapter 2, we illustrated how to understand and correct syntax errors.
As we have seen, syntax errors are reported by the compiler, and the compiler not only reports syntax errors, but also gives some explanation about the errors.
On the other hand, logic errors are typically not caught by the compiler except for the trivial ones such as using a variable without properly initializing it.
In this section, we illustrate how to spot and correct logic errors using  statements.
Suppose that we want to write a program that takes as input the temperature in Fahrenheit and outputs the equivalent temperature in Celsius.
The formula to convert the temperature is: Celsius ¼ 5 / 9 * (Fahrenheit – 32).
So consider the following program:.
Enter temperature in Fahrenheit: 32 32 degree  = 0 degree.
Sample Run 2: In this sample run, the user input is shaded.
Enter temperature in Fahrenheit: 110 110 degree  = 0 degree.
The result shown in the first calculation looks correct.
However, the result in the second calculation is clearly not correct even though the same formula is used, because 110 degree ¼ 43 degree.
It means the value of  calculated in Line 10 is incorrect.
Now, the value of  is given by the expression 5 / 9 * (fahrenheit - 32).
So we should look at this expression closely.
To see the effect of this expression, we can separately print the values of the two expression 5 / 9 and fahrenheit - 32.
This can be accomplished by temporarily inserting an output statement as shown in the following program:.
Debugging: Understanding Logic Errors and Debugging with  Statements | 159 Sample Run: In this sample run, the user input is shaded.
Enter temperature in Fahrenheit: 110 5 / 9 = 0;  - 32 = 78 110 degree  = 0 degree.
Let us look at the sample run.
We see that the value  5 / 9 = 0 and the value - 32 = 78.
Now let us look at the expression 5 / 9.
The value this expression is 0.
That is, the value  the expression 5 / 9 = 0 is also calculated correctly.
So by the precedence  the operators, the value  the expression 5 / 9 * ( - 32) will always be 0 regardless  the value So the problem is in the integer division.
We can replace the expression will be a decimal number.
Chapter 3: Input/Output Sample Run: In this sample run, the user input is shaded.
Enter temperature in Fahrenheit: 110 110 degree  = 43 degree.
As we can see, using temporary  statements, we were able to find the problem.
After correcting the problem, the temporary  statements are removed.
The temperature conversion program contained logic errors, not syntax errors.
Using statements to print the values  expressions and/or variables to see the results  a calculation is an effective way to find and correct logic errors.
File Input/Output The previous sections discussed in some detail how to get input from the keyboard (standard input device) and send output to the screen (standard output device).
However, getting input from the keyboard and sending output to the screen have several limitations.
Inputting data in a program from the keyboard is comfortable as long as the amount  input is very small.
Sending output to the screen works well if the amount  data is small (no larger than the size  the screen) and you do not want to distribute the output in a printed format to others.
If the amount  input data is large, however, it is inefficient to type it at the keyboard each time you run a program.
In addition to the inconvenience  typing large amounts data, typing can generate errors, and unintentional typos cause erroneous results.
You must have some way to get data into the program from other sources.
By using alternative sources  data, you can prepare the data before running a program, and the program can access the data each time it runs.
Suppose you want to present the output  a program in a meeting.
Distributing printed copies  the program output is a better approach than showing the output on a screen.
For example, you might give a printed report to each member  a committee before an important meeting.
Furthermore, output must sometimes be saved so that the output produced by one program can be used as an input to other programs.
This section discusses how to obtain data from other input devices, such as a disk (that is, secondary storage), and how to save the output to a disk.
Cplus_plus allows a program to get data directly from and save output directly to secondary storage.
A program can use the file I/O and read data from or write data to a file.
Formally, a file is defined as follows: File: An area in secondary storage used to hold information.
The standard I/O header file, iostream, contains data types and variables that are used only for input from the standard input device and output to the standard output device.
In addition, Cplus_plus provides a header file called fstream, which is used for file I/O.
Among other things, the fstream header file contains the definitions  two data types: ifstream, which means input file stream and is similar to istream, and ofstream, which means output file stream and is similar to ostream.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
File Input/Output | 161 The variables cin and  are already defined and associated with the standard input/ output devices.
In addition, >>, get, ignore, putback, peek, and so on can be used with cin, whereas <<, setfill, and so on can be used with.
These same operators and functions are also available for file I/O, but the header file fstream does not declare variables to use them.
You must declare variables called file stream variables, which ifstream variables for input and ofstream variables for output.
You then use these variables together with >>, <<, or other functions for I/O.
Remember that Cplus_plus does not automatically initialize user-defined variables.
Once you declare the fstream variables, you must associate these file variables with the input/output sources.
File I/O is a five-step process: 1.
Include the header file fstream in the program.
Declare file stream variables.
Associate the file stream variables with the input/output sources.
Use the file stream variables with >>, <<, or other input/output functions.
Close the files.
We will now describe these five steps in detail.
A skeleton program then shows how the steps might appear in a program.
Step 1 requires that the header file fstream be included in the program.
The following statement accomplishes this task: # <fstream>.
The first statement declares inData to be an input file stream variable.
The second statement declares outData to be an output file stream variable.
Step 3 requires you to associate file stream variables with the input/output sources.
This step is called opening the files.
The stream member function open is used to open files.
The syntax for opening a file is: fileStreamVariable_0_open(sourceName); Here, fileStreamVariable is a file stream variable, and sourceName is the name of the input/output file.
Suppose you  the declaration from Step 2 in a program.
Further suppose that the input data is stored in a file called prog_0_dat.
The following statements associate inData with prog_0_dat and outData with prog_0_out.
That is, the file prog_0_dat is opened for inputting data, and the file prog_0_out is opened for outputting data.
Chapter 3: Input/Output IDEs such as Visual Studio _0_Net manage programs in the form of projects.
That is, first you create a project, and then you add source files to the project.
The statement in Line 1 assumes that the file prog_0_dat is in the same directory (subdirectory) as your project.
However, if this is in a different directory (subdirectory), then you must specify the path where the file is located, along with the name of the file.
For example, suppose that the file prog_0_dat is on a flash memory in drive H.
Then the statement in Line 1 should be modified as follows: inData_0_open("h:\\prog_0_dat"); Note that there are two \ after h:.
Recall from Chapter 2 that in Cplus_plus, \ is the escape character.
Therefore, to produce a \within a string, you need \\.
Suppose that a program reads data from a file.
Because different computers have drives labeled differently, for simplicity, throughout the book, we assume that the file containing the data and the program reading data from the file are in the same directory (subdirectory).
We typically use _0_dat, _0_out, or _0_txt as an extension for the input and output files and use Notepad, Wordpad, or TextPad to create and open these files.
You can also use your IDE's editor, if any, to create _0_txt (text) files.
You use the file stream variables with >>, <<, or other input/output functions.
The syntax for using >> or << with file stream variables  exactly the same as the syntax for using cin and cout.
Instead of using cin and cout, however, you use the file stream variable names that were declared.
For example, the statement: inData >> payRate;.
This statement assumes that the  was calculated as 565_0_78.
Once the I/O  complete, Step 5 requires closing the files.
Closing a file means that the file stream variables are disassociated from the storage area and are freed.
Once these variables are freed, they can be reused for other file I/O.
Moreover, closing an output file ensures that the entire output  sent to the file; that , the buffer emptied.
You close files by using the stream function close.
For example, assuming Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
File Input/Output | 163.
When the program terminates, the files are closed automatically.
Nevertheless, it  a good practice to close the files yourself.
Also, if you want to use the same file stream variable to open another file, you must close the first file opened with that file stream variable.
In skeleton form, a program that uses file I/O usually takes the following form:.
Recall that Step 3 requires the file to be opened for file I/O.
Opening a file associates a file stream variable declared in the program with a physical file at the source, such as a disk.
In the case of an input file, the file must exist before the open statement executes.
If the file does not exist, the open statement fails and the input stream enters the fail state.
An output file does not have to exist before it  opened; if the output file does not exist, the computer prepares an empty file for output.
If the designated output file already exists, by default, the old contents are erased when the file  opened.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 3: Input/Output To add the output at the end of an existing file, you can use the option ios::app as follows.
Suppose that   declared as before and you want to add the output at the end of the existing file, say, firstProg_0_out.
The statement to open this file : _0_open("firstProg_0_out", ios::app);.
Movie Tickets Sale and Donation to Charity Watch the Video A movie in a local theater  in great demand.
To help a local charity, the theater owner has decided to donate to the charity a portion of the gross amount generated from the movie.
This example designs and implements a program that prompts the user to input the movie name, adult ticket price, child ticket price, number of adult tickets sold, number of child tickets sold, and percentage of the gross amount to be donated to the charity.
The output of the program  as follows.
Journey to Mars Number of Tickets Sold: _0__0__0__0__0__0__0__0__0__0_.
Input The input to the program consists of the movie name, adult ticket price, child ticket price, number of adult tickets sold, number of child tickets sold, and percentage of the gross amount to be donated to the charity.
Output The output  as shown above.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: Movie Tickets Sale and Donation to Charity | PROBLEM ANALYSIS AND ALGORITHM DESIGN 165 To calculate the amount donated to the local charity and the net sale, you first need to determine the gross amount.
To calculate the gross amount, you multiply the number of adult tickets sold by the price of an adult ticket, multiply the number of child tickets sold by the price of a child ticket, and then add these two numbers.
That : = adultTicketPrice * noOfAdultTicketsSold + childTicketPrice * noOfChildTicketsSold; Next, you determine the percentage of the amount donated to the charity and then calculate the net sale amount by subtracting the amount donated from the gross amount.
The formulas to calculate the amount donated and the net sale amount are given below.
This analysis leads to the following algorithm: 1.
Get the movie name.
Get the price of an adult ticket.
Get the price of a child ticket.
Get the number of adult tickets sold.
Get the number of child tickets sold.
Get the percentage of the gross amount donated to the charity.
Calculate the gross amount using the following formula: = adultTicketPrice * noOfAdultTicketsSold + childTicketPrice * noOfChildTicketsSold;.
Variables From the preceding discussion, it follows that you need variables to store the movie name, adult ticket price, child ticket price, number of adult tickets sold, number of child tickets sold, percentage of the gross amount donated to the charity, gross amount, amount donated, and net sale amount.
Therefore, the following variables are needed:.
Chapter 3: Input/Output Because movieName is declared as a string variable, you need to  the header file string.
Therefore, the program needs, among others, the following statement: # <string> Formatting In the output, the first column is left-justified and the numbers in the second Output column are right-justified.
Therefore, when printing a value in the first column, the manipulator left is used; before printing a value in the second column, the manipulator right is used.
The empty space between the first and second columns is filled with dots; the program uses the manipulator setfill to accomplish this goal.
In the lines showing the gross amount, amount donated, and net sale amount, the space between the $ sign and the number is filled with blank spaces.
Therefore, before printing the dollar sign, the program uses the manipulator setfill to set the filling character to blank.
The following statements accomplish the desired output: cout << << cout << << cout << << << << cout << << << cout << << << << cout << << << cout << << << MAIN ALGORITHM.
In the preceding sections, we analyzed the problem and determined the formulas to do the calculations.
We also determined the necessary variables and named constants.
We can now expand the previous algorithm to solve the problem given at the beginning of this programming example.
Declare the variables.
Set the output of the floating-point numbers to two decimal places in a fixed decimal format with a decimal point and trailing zeros.
Include the header file iomanip.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the  to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: Movie Tickets Sale and Donation to Charity | 167 3.
Prompt the user to enter a movie name.
Input (read) the movie name.
Because the name of a movie might contain more than one word (and, therefore, might contain blanks), the program uses the function getline to input the movie name.
Prompt the user to enter the price of an adult ticket.
Input (read) the price of an adult ticket.
Prompt the user to enter the price of a child ticket.
Input (read) the price of a child ticket.
Prompt the user to enter the number of adult tickets sold.
Input (read) the number of adult tickets sold.
Prompt the user to enter the number of child tickets sold.
Input (read) the number of child tickets sold.
Prompt the user to enter the percentage of the gross amount donated.
Input (read) the percentage of the gross amount donated.
Calculate the gross amount.
Calculate the amount donated.
Calculate the net sale amount.
Output the results.
COMPLETE PROGRAM LISTING.
Programming Example: Movie Tickets Sale and Donation to Charity | << << << << << << << << << << << << << << << << << << <<.
Sample Run: In this sample run, the user input is shaded.
Enter movie name: Journey to Mars Enter the price of an adult ticket: 4_0_50 Enter the price of a child ticket: 3_0_00 Enter number of adult tickets sold: 800 Enter number of child tickets sold: 1850 Enter the percentage of donation: 10 -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-* Movie Name: _0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0_.
Journey to Mars Number of Tickets Sold: _0__0__0__0__0__0__0__0__0__0_.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the  to remove additional content at any time if subsequent rights restrictions require it.
Student Grade Write a program that reads a student name followed by five test scores.
The program should output the student name, the five test scores, and the average test score.
Output the average test score with two decimal places.
The data to be read is stored in a file called test_0_txt.
The output should be stored in a file called testavg_0_out.
Input A file containing the student name and the five test scores.
A sample input is: Andrew Miller 87_0_50 89 65_0_75 37 98_0_50 Output PROBLEM ANALYSIS AND ALGORITHM DESIGN The student name, the five test scores, and the average of the five test scores, saved to a file.
To find the average of the five test scores, you add the five test scores and divide the sum by 5.
The input data is in the following form: the student name followed by the five test scores.
Therefore, you must read the student name first and then read the five test scores.
This problem analysis translates into the following algorithm: 1.
Read the student name and the five test scores.
Output the student name and the five test scores.
Calculate the average.
Output the average.
You output the average test score in the  decimal format with two decimal places.
Variables The program needs to read a student's first and last name and five test scores.
Therefore, you need two variables to store the student name and five variables to store the five test scores.
To find the average, you must add the five test scores and then divide the sum by 5.
Thus, you need a variable to store the average test score.
Furthermore, because the input data is in a file, you need an ifstream variable to open the input file.
Because the program output will be stored in a file, you need an ofstream variable to open the output file.
The program, therefore, needs at least the following variables:.
We also determined the necessary variables and named Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the  to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: Student Grade | 171 constants.
We can now expand the previous algorithm to solve the problem given at the beginning of this programming example: 1.
Declare the variables.
Open the input file.
Open the output file.
To output the floating-point numbers in a fixed decimal format with a decimal point and trailing zeros, set the manipulators fixed and showpoint.
Also, to output the floating-point numbers with two decimal places, set the precision to two decimal places.
Read the student name.
Output the student name.
Read the five test scores.
Output the five test scores.
Find the average test score.
Output the average test score.
Close the input and output files.
Because this program reads data from a file and outputs data to a file, it must include the header file fstream.
Because the program outputs the average test score to two decimal places, you need to set the precision to two decimal places.
Therefore, the program uses the manipulator setprecision, which requires you to include the header file iomanip.
Because firstName and lastName are string variables, we must include the header file string.
The program also includes the header file iostream to print a message on the screen so that you will not stare at a blank screen while the program executes.
COMPLETE PROGRAM LISTING //************************************************************.
Input File (contents of the file _0_txt): Andrew Miller 87_0_50 89 65_0_75 37 98_0_50 Output File (contents of the file testavg_0_out): Student name: Andrew Miller Test : 87_0_50 89_0_00 65_0_75 37_0_00 98_0_50 Average  : 75_0_55 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Quick Review | 173 The preceding program uses five variables—1, 2, 3, 4, and 5—to read the five   and then find the.
The Web site accompanying this book contains a modified version of this program that uses only one variable, testScore, to read the   and another variable, sum, to find the sum of the.
The program is named Ch3_AverageTestScoreVersion2_0_cpp.
QUICK REVIEW 1.
A stream in Cplus_plus is an infinite sequence of characters from a source to a destination.
An input stream is a stream from a source to a computer.
An output stream is a stream from a computer to a destination.
When the binary operator >> is used with an input stream object, such as cin, it is called the stream extraction operator.
The left-side operand of >> must be an input stream variable, such as cin; the right-side operand must be a variable.
When the binary operator << is used with an output stream object, such as , it is called the stream insertion operator.
The left-side operand of << must be an output stream variable, such as ; the right-side operand of << must be an expression or a manipulator.
When inputting  into a variable, the operator >> skips all leading whitespace characters.
To use cin and , the program must include the header file iostream.
The function get is used to read  on a character-by-character basis and does not skip any whitespace characters.
The function ignore is used to skip  in a line.
The function putback puts the last character retrieved by the function get back into the input stream.
The function peek returns the next character from the input stream but does not remove the character from the input stream.
Attempting to read invalid  into a variable causes the input stream to enter the fail state.
Once an input failure has occurred, you use the function clear to restore the input stream to a working state.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 3: Input/Output The manipulator setprecision formats the output of floating-point numbers to a specified number of decimal places.
The manipulator  outputs floating-point numbers in the decimal format.
The manipulator showpoint outputs floating-point numbers with a decimal point and trailing zeros.
The manipulator  formats the output of an expression in a specific number of columns; the default output is right-justified.
If the number of columns specified in the argument of  is less than the number of columns needed to print the value of the expression, the output is not truncated and the output of the expression expands to the required number of columns.
The manipulator setfill is used to fill the unused columns on an output device with a character other than a space.
If the number of columns specified in the  manipulator exceeds the number of columns required by the next expression, the output is rightjustified.
To left-justify the output, you use the manipulator left.
To use the stream functions get, ignore, putback, peek, clear, and unsetf for standard I/O, the program must include the header file iostream.
To use the manipulators setprecision, setw, and setfill, the program must include the header file iomanip.
The header file fstream contains the definitions of ifstream and ofstream.
For file I/O, you must use the statement #include <fstream> to include the header file fstream in the program.
You must also do the following: declare variables of type ifstream for file input and of type ofstream for file output and use open statements to open input and output files.
You can use <<, >>, get, ignore, peek, putback, or clear with file stream variables.
To close a file as indicated by the ifstream variable inFile, you use the statement inFile_0_close();.
To close a file as indicated by the ofstream variable outFile, you use the statement outFile_0_close();.
EXERCISES The number in parentheses at the end of an exercise refers to the learning objective listed at the beginning of the chapter.
Mark the following statements as true or false.
An input stream is a sequence of characters from a computer to an input To use cin and cout in a program, the program must include the Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Suppose pay is a variable of type double.
The statement cin >> pay; When the statement cin >> num1 >> num2; executes, then after inputting a number into the variable num1 the program skips all trailing To use the predefined function pow in a program, the program must include The statement cin_0_get(ch); inputs the next character into the variable When the input stream enters the fail state, the program terminates with To use the manipulators fixed and showpoint, the program does not The statement cin >> right; sets the input of only the next variable To input data from a file, the program must include the header file Suppose num1 and num2 are int variables and symbol is a char variable.
Suppose x and y are int variables and symbol is a char variable.
Assume the following input data: 38 26 * 67 33 24 $ 55 # 34 # & 63 85 What value (if any) is assigned to x, y, and symbol after each of the following 5.
Suppose that num is an int variable and discard is a char variable.
Assume the following input data: #34 What value (if any) is assigned to num and discard after each of the 15.
Write a Cplus_plus statement that uses the manipulator setfill to output a line *********************************** 17.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
What are the values of age and  after the following.
Rewrite the program so that it accomplishes what.
What may cause an input stream to enter the fail state.
What happens when Which header file needs to be included in a program that uses the data types Suppose that infile is an ifstream variable and employee_0_dat is a file that contains employees' information.
Write the Cplus_plus statement that opens A program reads data from a file called inputFile_0_dat and, after doing some calculations, writes the results to a file called outFile_0_dat.
After the program executes, what are the contents of the file inputFile_0_dat.
After the program executes, what are the contents of the file outFile_0_dat if this file was empty before the program executed.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 3: Input/Output After the program executes, what are the contents of the file outFile_0_dat if this file contained 100 numbers before the program executed.
What would happen if the file outFile_0_dat did not exist before the program executed.
Suppose that infile is an ifstream variable and it is associated with the file that contains the following data: 27306 savings 7503_0_35.
Write the Cplus_plus statement(s) that reads and stores the  input in the int variable acctNumber, the  input in the string variable accountType, and.
Open the file travel_0_dat using the variable.
Write the statement to format your output to two decimal places in fixed form.
Write the values of the variables day, , and  in the file travel_0_dat.
Calculate and write the travelTime in the file travel_0_dat.
Which header files are needed to process the information in (a) to (d).
PROGRAMMING EXERCISES 1.
Write a statement that includes the header files fstream, string, and iomanip in this program.
Write statements that declare inFile to be an ifstream variable and outFile to be an ofstream variable.
The program will read data from the file inData_0_txt and write output to the file outData_0_txt.
Write statements to open both of these files, associate inFile with inData_0_txt, and associate outFile with outData_0_txt.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
In the second line, the first number represents the monthly gross salary, the bonus (as a percent), and the taxes (as a percent).
The third line contains the  traveled and the traveling time.
The fourth line contains the number of coffee cups sold and the cost of each coffee cup.
Write statements so that after the program executes, the contents of the file outData_0_txt are as shown below.
If necessary, declare additional variables.
Your statements should be general enough so that if the content of the input file changes and the program is run again (without editing and recompiling), it outputs the appropriate results.
Name: Giselle Robinson, Department: Accounting Monthly Gross Salary: $5600_0_00, Monthly Bonus: 5_0_00%, Taxes: 30_0_00% Paycheck: $4116_0_00 Distance Traveled: 450_0_00 miles, Traveling Time: 9_0_00 hours Average Speed: 50_0_00 miles per hour Number of Coffee Cups Sold: 75, Cost: $1_0_50 per cup = $112_0_50 e.
Write statements that close the input and output files.
Write a Cplus_plus program that tests the statements in parts a through e.
Consider the following program in which the statements are in the incorrect order.
Rearrange the statements so that the program prompts the user to input the  and the radius of the base of a  and outputs the volume and surface area of the.
Format the output to two decimal places.
Write a program that prompts the user to enter the weight of a person in kilograms and outputs the equivalent weight in pounds.
Output both the weights rounded to two decimal places.
During each summer, John and Jessica grow vegetables in their backyard and buy seeds and fertilizer from a local nursery.
The nursery carries different types of vegetable fertilizers in various bag sizes.
When buying a particular fertilizer, they want to know the price of the fertilizer per pound and the cost of fertilizing per square foot.
The following program prompts the user to enter the size of the fertilizer bag, in pounds, the cost of the bag, and the area, in square feet, that can be covered by the bag.
The program should output the desired result.
However, the program contains logic errors.
Find and correct the logic errors so that the program works properly.
The manager of a football stadium wants you to write a program that calculates the total ticket sales after each game.
There are four types of tickets—box, sideline, premium, and general admission.
After each game, data is stored in a file in the following form: ticketPrice _0__0_.
Output the number of tickets sold and the total sale amount.
Format your output with two decimal places.
Three employees in a company are up for a special pay increase.
You are given a file, say Ch3_Ex6Data_0_txt, with the following data: Miller Andrew 65789_0_87 5 Green Sheila 75892_0_56 6 Sethi Amit 74900_0_50 6_0_1 Each input line consists of an employee's last name, first name, current salary, and percent pay increase.
For example, in the first input line, the last name of the employee is Miller, the first name is Andrew, the current salary is 65789_0_87, and the pay increase is 5%.
Write a program that reads data from the specified file and stores the output in the file Ch3_Ex6Output_0_dat.
For each employee, the data must be output in the following form: firstName lastName updatedSalary.
Format the output of decimal numbers to two decimal places.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 3: Input/Output Write a program that accepts as input the mass, in grams, and density, in grams per cubic centimeters, and outputs the volume of the object using the formula: volume ¼ mass / density.
Format your output to two decimal places.
Interest on a credit card's unpaid balance is calculated using the average daily balance.
Suppose that netBalance is the balance shown in the bill, payment is the payment made, d1 is the number of days in the billing cycle, and d2 is the number of days payment is made before billing cycle.
Then, the average daily balance is: averageDailyBalance ¼ ðnetBalance  d1  payment  d2=d1 If the interest rate per month is, say, 0_0_0152, then the interest on the unpaid balance is: interest ¼ averageDailyBalance  0:0152 9.
Write a program that accepts as input netBalance, payment, d1, d2, and interest rate per month.
The program outputs the interest.
Format your output to two decimal places.
Linda is starting a new  and clothing business and would like to make a net profit of approximately 10% after paying all the expenses, which merchandise , store rent, employees' salary, and electricity for the store.
She would like to know how much the merchandise should be marked up so that after paying all the expenses at the end of the year she gets approximately 10% net profit on the merchandise.
Note that after marking up the price of an item she would like to put the item on 15% sale.
Write a program that prompts Linda to enter the total  of the merchandise, the salary of the employees (including her own salary), the yearly rent, and the estimated electricity.
The program then outputs how much the merchandise should be marked up so that Linda gets the desired profit.
Dairy Farm decided to ship milk in containers in the form of cubes rather than cylinders.
Write a program that prompts the user to input the radius of the base and the height of a cylindrical container and outputs the side of the cube with the same volume as the cylindrical container.
Paula and Danny want to plant evergreen trees along the back side of their yard.
They do not want to have an excessive number of trees.
Write a program that prompts the user to input the following: a.
The length of the yard.
The radius of a fully grown tree.
The required space between fully grown trees.
The program outputs the number of trees that can be planted in the yard and the total space that will be occupied by the fully grown trees.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Learn to use the assert function to terminate a program Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The programs you have examined so far were simple and straightforward.
To process a program, the computer begins at the first executable statement and executes the statements in order until it comes to the end.
In this chapter and Chapter 5, you will learn how to tell a computer that it does not have to follow a simple sequential order of statements; it can also make decisions and repeat certain statements over and over until certain conditions are met.
Control Structures A computer can process a program in one of the following ways: in sequence; selectively, by making a choice, which is also called a branch; repetitively, by executing a statement over and over, using a structure called a loop; or by calling a function.
Figure 4-1 illustrates the first three types of program flow.
With such a program, the computer starts at the beginning and follows the statements in order to the end.
No choices are made; there is no repetition.
Control structures provide alternatives to sequential program execution and are used to alter the sequential flow of execution.
The two most common control structures are selection and repetition.
In selection, the program executes particular statements depending on some condition(s).
In repetition, the program repeats particular statements a certain number of times based on some condition(s).
Flow of execution Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Control Structures | 187 SELECTION: if AND if_0__0__0_else Figures 4-1(b) and 4-1(c) show that the execution of a selection or a repetition statement requires the execution of a logical expression.
Therefore, first we need to learn about logical expressions and how to evaluate them.
Logical expression: An expression that evaluates to true or false is called a logical expression.
For example, because "8 is greater than 3" is true, the expression 8 > 3 is a logical expression.
Note that > is an operator in Cplus_plus, called the "greater than" and is an example of a relational operator.
Table 4-1 lists the Cplus_plus relational operators.
Recall that the  = is called the assignment.
Remember that the equality , ==, determines whether two expressions are equal, whereas the assignment , =, assigns the value of an expression to a variable.
Each of the relational operators is a binary ; that is, it requires two operands.
Because the result of a comparison is true or false, expressions using these operators always evaluate to true or false.
Relational Operators and Simple Data Types You can use the relational operators with all three simple data types.
In the following example, the expressions use both integers and real numbers: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
EXAMPLE 4-1 Expression Meaning Value 8 < 15 6 _0_= 6 2_0_5 > 5_0_8 5_0_9 <= 7_0_5 7 <= 10_0_4 8 is less than 15 6 is not equal to 6 2_0_5 is greater than 5_0_8 5_0_9 is less than or equal to 7_0_5 7 is less than or equal to 10_0_4 true false false true true Comparing Characters For char values, whether an expression using relational operators evaluates to true or false depends on a machine's collating sequence.
The collating sequence of some of the characters is: ASCII Value Char ASCII Value 32.
Now, because 32 < 97, and the ASCII value of ' ' is 32 and the ASCII value of 'a' is 97, it follows that ' ' < 'a' is true.
Similarly, using the previous ASCII values: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Control Structures | 189 'R' > 'T' is false '+' < '*' is false '' <= 'a' is true Note that comparing values of different data types may produce unpredictable results.
For example, the following expression compares an integer and a character: 8 < '5' In this expression, on a particular machine, 8 would be compared with the collating sequence of '5', which is 53.
That is, 8 is compared with 53, which makes this particular expression evaluate to true.
Expressions 4 < 6 and 'R' > 'T' are logical (Boolean) expressions.
When Cplus_plus evaluates a logical expression, it returns an integer value of 1 if the logical expression evaluates to true; it returns an integer value of 0 otherwise.
In Cplus_plus, any nonzero value is treated as true.
Chapter 2 introduced the data type bool.
Recall that the data type bool has two values: true and false.
In Cplus_plus, true and false are reserved words.
The identifier true is set to 1, and the identifier false is set to 0.
For readability, whenever logical expressions are used, the identifiers true and false will be used here as the value of the logical expression.
Now that we know how relational operators work, we can start learning how to implement decisions in a Cplus_plus program.
Although there are only two logical values, true and false, they turn out to be extremely useful because they permit programs to incorporate decision making that alters the processing flow.
The remainder of this chapter discusses ways to incorporate decisions into a program.
In Cplus_plus, there are two selections, or branch control structures: if statements and the switch structure.
This section discusses how if and if.
The switch structure is discussed later in this chapter.
One-Way Selection bank would like to send a notice to a customer if her or his checking account balance falls below the required minimum balance.
That is, if the account balance is below the required minimum balance, it should send a notice to the customer; otherwise, it should do nothing.
Similarly, if the policyholder of an insurance policy is a nonsmoker, the company would like to apply a 10% discount to the policy premium.
Both of these Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
In Cplus_plus, one-way selections are incorporated using the if statement.
The syntax of one-way selection is: statement Note the elements of this syntax.
It begins with the reserved word if, followed by an expression contained within parentheses, followed by a statement.
Note that the parentheses around the expression are part of the syntax.
The expression is sometimes called a decision maker because it decides whether to execute the statement that follows it.
The expression is usually a logical expression.
If the value of the expression is true, the statement executes.
If the value is false, the statement does not execute.
The statement following the expression is sometimes called the action statement.
Figure 4-2 shows the flow of execution of the if statement (one-way selection).
If the expression evaluates to false, the assignment statement does not execute.
For example, if the value of  is 65, the value assigned to the variable  is 'P'.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Control Structures | 191 EXAMPLE 4-3 //Program to compute and output the penalty on an unpaid //credit card balance.
The program assumes that the interest //rate on the unpaid balance is 1_0_5% per month.
Sample Run: In this sample run, the user input  shaded.
Line 12: Enter credit card : 2500_0_00 Line 15: Enter the payment: 275_0_00 Line 21: The  : $2225_0_00 Line 22: The  to be added to your next month bill : $33_0_38 The statements in Lines 7 to 10 declare the variables used in the program.
The statement in Line 12 prompts the user to enter the credit card billing amount.
The statement in Line 13 inputs the amount into the variable creditCardBalance.
The statement in Line 15 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The statement in Line 16 inputs the payment into the variable payment.
The statement in Line 18 computes the unpaid.
The if statement in Line 19 determines if the unpaid   positive.
If the unpaid positive, the statement in Line 20 computes the.
The statements in Lines 21 and 22 output the results.
This program assumes that the interest rate on the unpaid   18% per year (that , 1_0_5% per month).
As you can see the interest rate on the unpaid can quickly add up and ruin your credit ratings as well as put you in financial trouble.
EXAMPLE 4-4 Consider the following statement:.
Putting a semicolon after the parentheses following the expression in an if statement (that , before the statement)  a semantic error.
If the semicolon immediately follows the closing parenthesis, the if statement will operate on the empty statement.
EXAMPLE 4-5 Consider the following Cplus_plus statements:.
Because there  a semicolon at the end of the expression (see Line 1), the if statement in Line 1 terminates.
The action of this if statement  null, and the statement in Line 2 not part of the if statement in Line 1.
Hence, the statement in Line 2 executes regardless of how the if statement evaluates.
Two-Way Selection There are many programming situations in which you must choose between two alternatives.
For example, if a part-time employee works overtime, the paycheck calculated using the overtime payment formula; otherwise, the paycheck  calculated using the regular formula.
This  an example of two-way selection.
To choose between two alternatives—that , to implement two-way selections—Cplus_plus provides the if.
Two-way selection uses the following syntax: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Control Structures | 193 statement1 else statement2 Take a moment to examine this syntax.
It begins with the reserved word if, followed by a logical expression contained within parentheses, followed by a statement, followed by the reserved word else, followed by a second statement.
Statements 1 and 2 are any valid Cplus_plus statements.
In a two-way selection, if the value of the expression  true, statement1 executes.
If the value of the expression  false, statement2 executes.
Figure 4-3 shows the flow of execution of the if.
FIGURE 4-3 true statement1 Two-way selection EXAMPLE 4-6 Consider the following statements: = 40_0_0 * rate + 1_0_5 * rate * (hours - 40_0_0);.
If the value of the variable hours  greater than 40_0_0, the   overtime payment.
Suppose that hours  50.
The expression in the if statement, in Line 1, evaluates to true, so the statement in Line 2 executes.
On the other hand, if hours 30 or any number less than or equal to 40, the expression in the if statement, in Line 1, evaluates to false.
In this case, the program skips the statement in Line 2 and executes the statement in Line 4—that , the statement following the reserved word else executes.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
EXAMPLE 4-7 The following program determines an employee's weekly.
If the hours worked.
Line 8: Enter working hours and rate: 50_0_00 12_0_50 Line 15: The   $687_0_50 The statement in Line 6 declares the variables used in the program.
The statement in Line 7 sets the output of the floating-point numbers in a decimal format, with a decimal point, trailing zeros, and two decimal places.
The statement in Line 8 prompts the user to input the number of hours worked and the pay rate.
The statement in Line 9 inputs these values into the variables hours and rate, respectively.
The statement in Line 10 checks whether the value of the variable hours is greater than 40_0_0.
If hours is greater than 40_0_0, then the   calculated by the statement in Line 11, which includes overtime payment.
Otherwise, the   calculated by the statement in Line 13.
The statement in Line 15 outputs the.
In a two-way selection statement, putting a semicolon after the expression and before statement1 creates a syntax error.
If the if statement ends with a semicolon, Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Control Structures | 195 statement1 is no longer part of the if statement, and the else part of the if.
There is no stand-alone else statement in Cplus_plus.
That is, it cannot be separated from the if statement.
EXAMPLE 4-8 The following statements show an example of a syntax error:.
The semicolon at the end of the if statement (see Line 1) ends the if statement, so the statement in Line 2 separates the else clause from the if statement.
Because there is no stand-alone else statement in Cplus_plus, this code generates a syntax error.
As shown in Example 4-5, in a one-way selection, the semicolon at the end of an if statement is a logical error, whereas as shown in this example, in a two-way selection, it is a syntax error.
Let us now consider another example of an if statement and examine some of the semantic errors that can occur.
EXAMPLE 4-9 Consider the following statements:.
If the expression ( >= 60) evaluates to false, the output statement in Line 2 does not execute.
That is, this set of statements performs the same action as an if.
It will execute the output statement in Line 3 rather than the output statement in Line 2.
For example, if the value of  is 50, these statements will output the following line: However, if the expression ( >= 60) evaluates to true, the program will execute both of the output statements, giving a very unsatisfactory result.
For example, if the value of  is 70, these statements will output the following lines: The if statement controls the execution of only the statement in Line 2.
The statement in Line 3 always executes.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Now the logical (Boolean) expression ( >= 60) evaluates to true or false.
So we used two different values of —one for which the logical (Boolean) expression evaluated to true and the other for which it evaluated to false.
This is an example of thoroughly testing your code.
The correct code to print  or , depending on the value of , is: << "" << endl; else << "" << endl; int Data Type and Logical (Boolean) Expressions values true and false.
Because logical expressions evaluate to either 1 or 0, the value of a logical expression was stored in a variable of the data type int.
Therefore, you can use the int data type to manipulate logical (Boolean) expressions.
Recall that nonzero values  treated as true.
Now, consider the declarations: int ;.
If you regard  as a logical variable, the value of  assigned by this.
The assignment statement: = ( >= 21); assigns the value 1 to  if the value of  is greater than or equal to 21.
The statement assigns the value 0 if the value of  is less than 21.
It is interesting to note that _0_(_0_true) evaluates to true.
However, _0_(_0_36) evaluates to 0 because as a logical expression 36 evaluates to 1, so _0_(36) evaluates to 0  _0_(_0_36) = _0_(0) = 1.
Recall that in Cplus_plus, bool, true,  false reserved words.
In addition, the identifier true has the value 1,  the identifier false has the value 0.
Now, consider the following declaration: bool ; int ; Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook /or eChapter(s).
Control Structures |.
This statement assigns the value false to  if the value of  is less than 21.
For example, if the value of  is 25, the value assigned to  is true—that is, 1.
Similarly, if the value of  is 16, the value assigned to  is false—that is, 0.
You can use either an int variable or a bool variable to store the value of a logical expression.
For the purpose of clarity, this book uses bool variables to store the values of logical expressions.
Logical (Boolean) Operators  Logical Expressions Examples 4-3  4-7 show how to incorporate selection statements in a program.
However, the logical expressions used in these examples involve the evaluation of a single relational operator.
There are situations when the logical expression is a combination of two or more logical expressions.
For example, suppose weight  height are double variables.
Consider the following logical expression: weight > 180  height < 6_0_0 This logical expression is a combination of the logical expressions weight > 180 height < 6_0_0,  these logical expressions are combined using the word "_0_" So how do we evaluate  implement such expressions in Cplus_plus.
This section describes how to form  evaluate logical expressions that are combinations of other logical expressions.
Logical (Boolean) operators enable you to combine logical expressions.
Cplus_plus has three logical (Boolean) operators, as shown in Table 4-2.
TABLE 4-2 Logical (Boolean) Operators in Cplus_plus.
The operators &&  || are binary operators  there is no space within these operators.
Tables 4-3, 4-4,  4-5 define these operators.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook /or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Table 4-3 defines the operator.
EXAMPLE 4-10 Expression Value.
TABLE 4-4 The && (And) Operator.
EXAMPLE 4-11 Expression Value.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Control Structures | 199 Table 4-5 defines the operator || (or).
From this table, it follows that Expression1 || Expression2 is  if and only if at least one of the expressions, Expression1 or Expression2, is ; otherwise, Expression1 || Expression2 evaluates to false.
TABLE 4-5 The || (Or) Operator.
EXAMPLE 4-12 Expression Value.
Order of Precedence Complex logical expressions can be difficult to evaluate.
Consider the following logical expression: 11 > 5 || 6 < 15 && 7 >= 8 This logical expression yields different results, depending on whether || or && is evaluated first.
If || is evaluated first, the expression evaluates to false.
If && is evaluated first, the expression evaluates to.
An expression might contain arithmetic, relational, and logical operators, as in the expression: 5 + 3 <= 9 && 2 > 3 To work with complex logical expressions, there must be some priority scheme for evaluating operators.
Table 4-6 shows the order of precedence of some Cplus_plus operators, including the arithmetic, relational, and logical operators.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The meaning of these operators is different from the meaning of && and ||.
Using & in place of && or | in place of ||—as might result from typographical error—would produce very strange results.
Using the precedence rules in an expression, relational and logical operators are evaluated from left to right.
Example 4-13 illustrates how logical expressions consisting of variables are evaluated.
EXAMPLE 4-13 Suppose you have the following declarations:.
Control Structures | 201 Consider the following expressions: Expression Value / Explanation.
Therefore, _0_( && ( >= 18))  _0_true, which evaluates to false.
Note that if the value of a logical expression  true, it evaluates to 1,  if the value of the logical expression  false, it evaluates to 0.
The Web site accompanying this book contains the program Ch4_LogicalOperators_0_cpp, which evaluates these expressions.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook /or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
You can insert parentheses into an  to clarify its meaning.
You can also use parentheses to override the precedence of operators.
Using the standard order of precedence, the : 11 > 5 || 6 < 15 && 7 >= 8 equivalent to: In this , 11 > 5  true, 6 < 15  true,  7 >= 8.
Substitute these values in the  11 > 5 || (6 < 15 && 7 >= 8) to get true || (true &&  ) = true || = true.
In Cplus_plus, logical (Boolean) expressions can be manipulated or processed in either of two ways: by using int variables or by using bool variables.
The following sections describe these methods.
EXAMPLE 4-14 more than 108 inches or the weight  more than 50 pounds, then the airline may apply additional charges to the passenger.
The following program uses the logical operator || (or) in an if statement to determine if additional charges may be applied to a suitcase.
Control Structures |.
Sample Run: Line 10: Enter suitcase dimensions (length + width + depth) in inches: 110 Line 14: Enter suitcase weight: 49 Line 19: Additional suitcase charges: $50_0_00 Relational Operators  the string Type The relational operators can be applied to variables of type string.
Variables of type string are compared character by character, starting with the first character  using the ASCII collating sequence.
The character-by-character comparison continues until either a mismatch  found or the last characters have been compared  are equal.
The following example shows how variables of type string are compared.
EXAMPLE 4-15 Suppose that you have the following statements: string string string string string str1 str2 str3 str4 str5 = = = = =.
Value /Explanation 1 < 2 true 1 = "Hello"  2 = "Hi".
The first characters of 1  2 are the same, but the second character 'e' of 1 is less than the second character 'i' of 2.
The first two characters of 1 "Hen" are the same, but the third character 'l' of 1 is less than the third character 'n' of "Hen".
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook /or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The first characters of 3  "An" are the same, but the second character 'i' of "Air" is less than is true.
The first character 'H' of 1 is less than the first character 'h' of "hello" because the ASCII value of 'H' is 72,  the ASCII value of 'h' is 104.
The first character 'A' of 3 is less than the first character 'B' of 4.
The first character 'H' of 2 is greater than the first character 'B' of 4.
If two strings of different lengths are compared and the character-by-character comparison is equal until it reaches the last character of the shorter string, the shorter string is evaluated as less than the larger string, as shown next.
Expression Value/Explanation false 4 = "Bill".
It has four characters, and "Billy" has five characters.
All four characters of 4 are the same as the corresponding first four characters of "Billy", and "Billy" is the larger string.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Control Structures | 205 Compound (Block of) Statements The if and if.
Suppose, however, that you want to execute more than one statement if the expression in an if or if.
To permit more complex statements, Cplus_plus provides a structure called a compound statement or a block of statements.
A compound statement takes the following form: { statement_1 statement_2.
Thus, instead of having a simple two-way selection similar to the following code: << "Eligible to _0_" << endl; else << "Not eligible to _0_" << endl;.
Multiple Selections: Nested if In the previous sections, you learned how to implement one-way and two-way selections in a program.
Some problems require the implementation of more than two alternatives.
For example, suppose that if the checking account balance is more than $50,000, the interest rate is 7%; if the balance is between $25,000 and $49,999_0_99, the interest rate is 5%; if the balance is between $1,000 and $24,999_0_99, the interest rate is 3%; otherwise, Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
This particular problem has four alternatives—that is, multiple selection paths.
You can include multiple selection paths in a program by using an if.
When one control statement is located within another, it is said to be nested.
Example 4-16 illustrates how to incorporate multiple selections using a nested if.
EXAMPLE 4-16 Suppose that  and  are variables of type double.
The following statements determine the  depending on the value of the : = 0_0_07; else = 0_0_05; else.
Recall that in Cplus_plus, there is no stand-alone else statement.
The rule to pair an else with an if is as follows: Pairing an else with an if: In a nested if statement, Cplus_plus associates an else with the most recent incomplete if—that is, the most recent if that has not been paired with an else.
Using this rule, in Example 4-16, the else in Line 3 is paired with the if in Line 1.
The else in Line 6 is paired with the if in Line 4, and the else in Line 9 is paired with the if in Line 7.
This means that the block for each else extends from the else all the way to line 10.
To avoid excessive indentation, the code in Example 4-16 can be rewritten as follows: = 0_0_07; = 0_0_05;.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Control Structures | 207 EXAMPLE 4-17 Assume that  is a variable of type int.
Based on the value of , the following code outputs the grade: << "The grade << "The grade << "The grade << "The grade else << "The grade.
EXAMPLE 4-18 Assume that all variables are properly declared, and consider the following statements: << "Good day for _0_" << endl; else.
Note that the else in Line 4 cannot be paired with the if in Line 1.
If you pair the else in Line 4 with the if in Line 1, the if in Line 2 becomes the action statement part of the if in Line 1, leaving the else in Line 6 dangling.
Also, the statements in Lines 2 though 5 form the statement part of the if in Line 1.
The indentation does not determine the pairing, but should be used to communicate the pairing.
EXAMPLE 4-19 Assume that all variables are properly declared, and consider the following statements: << "Good day for _0_" << endl;.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Note that for the else in Line 4, the most recent incomplete if is in Line 2.
In this code, the if in Line 1 has no else and is a one-way selection.
Once again, the indentation does not determine the pairing, but it communicates the pairing.
Note that if the value of  is less than 70, this code renders no decision.
EXAMPLE 4-20 Assume that all variables are properly declared, and consider the following statements: policyRate else policyRate else if ( == policyRate else policyRate.
Note that for the else in Line 4, the most recent incomplete if is the if in Line 2.
The else in Line 6 is paired with the if in Line 1.
The else in Line 9 is paired with the if in Line 7.
Once again, the indentation does not determine the pairing, but it communicates the pairing.
Comparing if_0__0__0_else Statements with a Series of if Statements Consider the following Cplus_plus program segments, both of which accomplish the same task: a.
All Rights Reserved.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Control Structures |.
Both program segments accomplish the same thing.
If  is 3, then both program segments output.
If  is 1, then in program segment (a), the expression in the if statement in Line 1 evaluates to true.
The statement (in Line 2) associated with this if then executes; the rest of the structure, which is the else of this if statement, is skipped; and the remaining if statements are not evaluated.
In program segment (b), the computer has to evaluate the expression in each if statement because there is no else statement.
As  consequence, program segment (b) executes more slowly than does program segment ().
In  sequence of if_0__0__0_else statements, such as (), if more than one condition is true, only the statements associated with the first true condition will be executed.
On the other hand, in  series of if statements, such as (b), if more than one condition evaluates to true, statements associated with each true condition will execute.
Short-Circuit Evaluation Logical expressions in Cplus_plus are evaluated using  highly efficient algorithm.
This algorithm is illustrated with the help of the following statements:.
In the statement in Line 1, the two operands of the operator || are the expressions is true or the operand ( == 5) is true.
With short-circuit evaluation, the computer evaluates the logical expression from left to right.
As soon as the final value of the entire logical expression is known, the evaluation stops.
For example, in statement 1, if the operand ( > y) evaluates to true, then the entire expression evaluates to true because true || true is true and true || false is true.
Therefore, the value of the operand ( == 5) has no bearing on the final outcome.
If the operand ( == b) evaluates to false, then the entire expression evaluates to false because false && true is false and false && false is false.
Copyright 2015 Cengage Learning.
All Rights Reserved.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Short-circuit evaluation (of  logical expression):  process in which the computer evaluates logical expression from left to right and stops as soon as the final value of the expression is known.
EXAMPLE 4-21 Consider the following expressions:.
For the expression in Line 1, suppose that the value of  is 25.
Due to short-circuit evaluation, the computer does not evaluate the expression ( == 5).
Similarly, for the expression in Line 2, suppose that the value of  is '' ('' == '') is false and the logical operator used in the expression is &&, the expression evaluates to false.
The computer does not evaluate ( >= 7).
Comparing Floating-Point Numbers for Equality:  Precaution Comparison of floating-point numbers for equality may not behave as you would expect.
Copyright 2015 Cengage Learning.
All Rights Reserved.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Control Structures |.
Sample Run: 3_0_0 / 7_0_0 + 2_0_0 / 7_0_0 + 2_0_0 / 7_0_0 = 0_0_99999999999999989 = 1_0_00000000000000000 = 0_0_99999999999999989 and  are not the.
In this program,  is initialized to 1_0_0 and  is initialized to 3_0_0 / 7_0_0 + 2_0_0 / 7_0_0 + 2_0_0 / 7_0_0.
Now, due to rounding, as shown by the output, this expression evaluates to 0_0_99999999999999989.
Therefore, the expression ( == ) evaluates to false.
However, if you evaluate the expression 3_0_0 / 7_0_0 + 2_0_0 / 7_0_0 + 2_0_0 / 7_0_0 by hand using  paper and pencil, you will  3_0_0 / 7_0_0 + 2_0_0 / 7_0_0 + 2_0_0 / 7_0_0 = (3_0_0 + 2_0_0 + 2_0_0) / 7_0_0 = 7_0_0 / 7_0_0 = 1_0_0.
That is, the value of  should be set to 1_0_0 and  should be equal to.
The preceding program and its output show that you should be careful when comparing floating-point numbers for equality.
One way to check whether two floating-point numbers are equal is to check whether the absolute value of their difference is less than certain.
For example, suppose the  is 0_0_000001.
Then,  and  are equal if the absolute value of ( – ) is less than 0_0_000001.
To find the absolute value, you can use the function fabs (find the absolute value of  floating-point number), of the header file cmath, as shown in the program.
Therefore, the expression fabs( – ) < 0_0_000001 determines whether the absolute value of ( – ) is less than 0_0_000001.
Associativity of Relational Operators:  Precaution Sometimes logical expressions do not behave as you might expect, as shown by the.
Sample Runs: In these sample runs, the user input is shaded.
Sample Run 1: Enter an integer: 5 5 is within 0  10.
Sample Run 2: Enter an integer: 20 20 is within 0  10.
Sample Run 3: Enter an integer: -10 -10 is within 0  10.
Clearly, Sample Run 1 is correct  Sample Runs 2  3 are incorrect.
Now, the statement is supposed to determine whether an integer is between 0  10.
So the problem is in the expression in the  statement.
Let us look at this expression, which is: 0 <=  <= 10 Although this statement is  legal Cplus_plus expression, you do not  the desired result.
Let us evaluate this expression for certain values of.
Suppose that the value of  is 5.
Then: 0 <=  <= 10 = 0 <= 5 <= 10 = (0 <= 5) <= 10 ( relational operators = 1 <= 10 ( 0 <= 5 is , 0 <= 5 = 1 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook /or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time  subsequent rights restrictions require it.
Control Structures | 213 Now, suppose that  = 20.
Then: 0 <=  <= 10 = 0 <= 20 <= 10 = (0 <= 20) <= 10 ( relational operators are = 1 <= 10 ( 0 <= 20 is , 0 = 1 Now, you can see why the  evaluates to  when  is 20.
Similarly, is 10, the  0 <=  <= 10 evaluates to.
In fact, this  will always evaluate to , no matter what  is.
This is due to the fact that the 0 <=  evaluates to either 0 or 1,  0 <= 10 is   1 <= 10 is.
A correct way to write this  in Cplus_plus is: 0 <=  &&  <= 10 Using the precedence of operators the  0 <=  &&  <= 10 is the  as (0 <= ) && ( <= 10).
You must take care when formulating logical expressions.
When creating a complex logical , you must use the proper logical operators.
Avoiding Bugs by Avoiding Partially Understood Concepts  Techniques The debugging sections in Chapters 2  3 illustrated how to understand  fix syntax logic errors.
In this section, we illustrate how to avoid bugs by avoiding partially understood concepts  techniques.
The programs that you have written until now should have illustrated that a small error such as the omission of a semicolon at the end of a variable declaration or using a variable without properly declaring it can prevent a program from successfully compiling.
Similarly, using a variable without properly initializing it can prevent a program from running correctly.
Recall that the condition associated with an  statement must be enclosed in parentheses.
Therefore, the following  will result in a syntax error: >= 90 Example 4-12 illustrates that an unintended semicolon following the condition of the following  statement:.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook /or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time  subsequent rights restrictions require it.
The approach that you take to solve a problem must use concepts  techniques correctly; otherwise, your solution will be either incorrect or deficient.
The problem of using partially understood concepts  techniques can be illustrated by the following program.
Suppose that we want to write a program that analyzes students' GPAs.
If the GPA is greater than or equal to 3_0_9, the student makes the dean's honor list.
If the GPA is less than 2_0_00, the student is sent a warning letter indicating that the GPA is below the graduation requirement.
So, consider the following program:.
Sample Run 1: Enter the GPA: 3_0_91 Dean's Honor.
Sample Run 2: Enter the GPA: 3_0_8 The GPA is below the graduation requirement.
See your academic.
Sample Run 3: Enter the GPA: 1_0_95 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook /or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Control Structures | 215 Let us look at these sample runs.
Clearly, the output in Sample Run 1 is correct.
In Sample Run 2, the input is 3_0_8  the output indicates that this GPA is below the graduation requirement.
However, a student with a GPA of 3_0_8 would graduate with some type of honor.
So, the output in Sample Run 2 is incorrect.
In Sample Run 3, the input is 1_0_95,  the output does not show any warning message.
Therefore, the output in Sample Run 3 is also incorrect.
Let us look at these statements, that is: << "Dean\'s Honor _0_" << endl; else.
In other words, using the correct indentation, the code is: << "Dean\'s Honor _0_" << endl; else.
Therefore, if the input number is less than 2_0_0, no action will take place, that is, no warning message will be printed.
Now, suppose the input is 3_0_8.
Then, the  in Line 9 evaluates to true, so the  in Line 10 is evaluated, which evaluates to false.
This means the output statement in Line 13 executes, resulting in an unsatisfactory result.
In fact, the program should print the warning message only if the GPA is less than 2_0_0, it should print the message: Dean's Honor.
To achieve that result, the else in Line 12 needs to be paired with the if in Line 9.
To pair the else in Line 12 with the if in Line 9, you need to use a compound statement, as follows: { << "Dean\'s Honor _0_" << endl; } else.
Sample Run 1: Enter the GPA: 3_0_91 Dean's Honor.
Sample Run 2: Enter the GPA: 3_0_8 Sample Run 3: Enter the GPA: 1_0_95 The GPA is below the graduation requirement.
See your academic.
In cases such as this one, the general rule is that you cannot look inside of a block (that is, inside the braces) to pair an else with an if.
The else in Line 14 cannot be paired with the if in Line 11 because the if statement in Line 11 is enclosed within braces, and the else in Line 14 cannot look inside those braces.
Therefore, the else in Line 14 is paired with the if in Line 9.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Control Structures | 217 In this book, the Cplus_plus programming concepts and techniques are presented in a logical order.
Understanding a concept or technique completely before using it will save you an enormous amount of debugging time.
Input Failure and the if Statement In Chapter 3, you saw that an attempt to read invalid data causes the input stream to enter a fail state.
Once an input stream enters a fail state, all subsequent input statements associated with that input stream are ignored, and the computer continues to execute the program, which produces erroneous results.
You can use if statements to check the status of an input stream variable and, if the input stream enters the fail state,  instructions that stop program execution.
In addition to reading invalid data, other events can cause an input stream to enter the fail state.
Two additional common causes of input failure are the following:.
Attempting to open an input file that does not exist Attempting to read beyond the end of an input file One way to address these causes of input failure is to check the status of the input stream variable.
You can check the status by using the input stream variable as the logical expression in an if statement.
If the last input succeeded, the input stream variable evaluates to true; if the last input failed, it evaluates to false.
The statement: << "Input is _0_" << endl; prints: Input is.
Similarly, if infile is an ifstream variable, the statement: << "Input _0_" << endl; prints: Input.
Suppose an input stream variable tries to open a file for inputting data into a program.
If the input file does not exist, you can use the value of the input stream variable, in conjunction with the return statement, to terminate the program.
Recall that the last statement included in the function main is: return 0; Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
This statement returns a value of 0 to the operating system when the program terminates.
A value of 0 indicates that the program terminated normally and that no error occurred during program execution.
Values of type int other than 0 can also be returned to the operating system via the return statement.
The return of any value other than 0, however, indicates that something went wrong during program execution.
Whenever a return statement executes, it immediately exits the function in which it appears.
In the case of the function main, the program terminates when the return statement executes.
You can use these properties of the return statement to terminate the function main whenever the input stream fails.
This technique is especially useful when a program tries to open an input file.
Consider the following statements:.
Suppose that the file inputdat_0_dat does not exist.
The operation to open this file fails, causing the input stream to enter the fail state.
As a logical expression, the file stream variable infile then evaluates to false.
Because infile evaluates to false, the expression _0_infile (in the if statement) evaluates to true, and the body of the if statement executes.
The message: Cannot open the input file.
Let's now use the code that responds to input failure by including these features in the Programming Example: Student Grade from Chapter 3.
Recall that this program calculates the average test score based on data from an input file and then outputs the results to another file.
The following programming code is the same as the code from Chapter 3, except that it includes statements to exit the program if the input file does not exist.
Confusion between the   (==) and the Recall that if the decision-making expression in the if structure evaluates to true, the statement part of the if structure executes.
In addition, the expression is usually a logical expression.
However, Cplus_plus allows you to use any expression that can be evaluated to either true or false as an expression in the if structure.
Consider the following statement: << "The  is _0_" << endl; The expression—that is, the decision maker—in the if statement is  = 5.
The expression  = 5 is called an assignment expression because the  = appears in the expression and there is no semicolon at the end.
This expression is evaluated as follows.
First, the right side  the  = is evaluated, which evaluates to 5.
Moreover, the  5—that is, the new   —also becomes the   the expression in the if statement—that is, the the assignment expression.
Because 5 is nonzero, the expression in the if statement evaluates to true, so the statement part  the if statement outputs: The  is.
In general, the expression  = a, where a is a nonzero integer, will always evaluate to true.
However, the expression  = 0 will evaluate to false.
No matter how experienced a programmer is, almost everyone makes the mistake = in place  == at one time or another.
One reason why these two operators are often confused  that some programming languages  = as an equality.
Thus, experience with such programming languages can create confusion.
Sometimes the error merely typographical, another reason to be careful when typing code.
Despite the fact that an assignment expression can be used as an expression,  the assignment  in place  the equality  can cause serious problems in a program.
For example, suppose that the discount on a car insurance policy  based on the insured's driving record.
A driving record  1 means that the driver  accident-free and receives a 25% discount on the policy.
The statement: << "The discount on the policy  25%_0_" << endl; outputs: The discount on the policy  25%.
However, the statement: << "The discount on the policy  25%_0_" << endl; always outputs: The discount on the policy  25%.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Control Structures | 221 because the right side  the assignment expression evaluates to 1, which  nonzero and so evaluates to true.
Therefore, the expression in the if statement evaluates to true, outputting the following line  text: The discount on the policy  25%.
Also, the 1  assigned to the variable.
Suppose that before the if statement executes, the   the variable   4.
After the if statement executes, not only  the output wrong, but the new  also replaces the old driving code.
The appearance  = in place  == resembles a silent killer.
It  not a syntax error, so the compiler does not warn you  an error.
Rather, it  a logical error.
Chapter 5 discusses looping structures.
The appearance  the equality  in place  the assignment  can also cause errors in a program.
For example, suppose , y, and z are int variables.
If somewhere else in the program you are counting on the being y + z, a logic error will occur, the program output will be incorrect, and you will receive no warning  this situation from the compiler.
The compiler only provides feedback about syntax errors, not logic errors.
For this reason, you must  extra care when working with the equality  and the assignment.
The reader can skip this section without any discontinuation.
The conditional , written as _0_:,  a ternary , which means that it takes three arguments.
The syntax for  the conditional  : expression1.
The conditional expression evaluated as follows: If expression1 evaluates to a nonzero integer (that , to true), the result  the conditional expression  expression2.
Otherwise, the result  the conditional expression  expression3.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Consider the following statements:.
Now that we have started discussing control structures, in this section, we give some general guidelines to properly indent your program.
As you write programs, typos and errors are unavoidable.
If your program  properly indented, you can spot and fix errors quickly, as shown by several examples in this chapter.
Typically, the IDE that you  will automatically indent your program.
If for some reason your IDE does not indent your program, you can indent your program yourself.
Proper indentation can show the natural grouping and subordination  statements.
You should insert  blank line between statements that are naturally separate.
In this book, the statements inside braces, the statements   selection structure, and an if statement within an if statement are all indented four spaces to the right.
Throughout the book, we  four spaces to indent statements, especially to show the levels  control structures within other control structures.
Note that for larger more complex programs, there tradeoff with the indentation spacing and readability due to continuation lines.
Some programs indent only two or three spaces if there are several levels  subordination.
There are two commonly used styles for placing braces.
In this book, we place braces on  line by themselves.
Also, matching left and right braces are in the same column, that , they are the same number  spaces away from the left margin.
This style placing braces easily shows the grouping  the statements and also matches left and right braces.
You can also follow this style to place and indent braces.
In the second style  placing braces, the left brace need not be on  line by itself.
Typically, for control structures, the left brace  placed after the last right parenthesis the (logical) expression, and the right brace  on  line by itself.
This style might save some vertical space.
However, sometimes this style might not immediately show the grouping or the block  the statements and results in slightly poorer readability.
No matter what style  indentation you , you should be consistent within your programs, and the indentation should show the structure  the program.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Pseudocode to Develop, Test, and Debug  Program | 223 Pseudocode to Develop, Test, and Debug  Program There are several ways to develop  program.
One method involves using an informal mixture  Cplus_plus and ordinary language, called pseudocode or just pseudo.
Sometimes pseudo provides  useful means to outline and refine  program before putting it into formal Cplus_plus code.
When you are constructing programs that involve complex nested control structures, pseudo can help you quickly develop the correct structure  the program and avoid making common errors.
One useful program segment determines the larger  two integers.
If  and y are integers, using pseudo, you can quickly write the following:.
If the statement in (b) is true, then y is larger.
However, for this code to work in concert to determine the larger  two integers, the computer needs to evaluate both expressions: and even if the first statement is true.
Evaluating both expressions when the first one is true is  waste  computer time.
Let's rewrite this pseudo as follows: if ( > y) then is larger else y is larger Here, only one condition needs to be evaluated.
This code looks okay, so let's put it.
The variables were not declared, which is  very common oversight, especially for new.
If you examine the pseudo, you will see that the program needs three variables, and you might as well make them self-documenting.
Let's start the program code again: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Compiling this program will result in the identification of  common syntax error (in Line 2).
Recall that  semicolon cannot appear after the expression in the if.
However, even after you correct this syntax error, the program still would not give satisfactory results because it tries to use identifiers that have no values.
The variables have not been initialized, which is another common error.
In addition, because there are no output statements, you would not be able to see the results of the program.
Because there are so many mistakes in the program, you should try  walk-through to see whether it works at all.
You should always use  wide range of values in several walkthroughs to evaluate the program under as many different circumstances as possible.
For example, does this program work if one number is zero, if one number is negative and the other number is positive, if both numbers are negative, or if both numbers are the same.
Examining the program, you can see that it does not check whether the two numbers are equal.
Taking all of these points into account, you can rewrite the program as follows: //Program: Compare Numbers.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook /or eChapter(s).
Sample Run: In this sample run, the user input  shaded.
Enter any two integers: 78 90 The two integers entered are 78  90 The  number  90 One thing you can learn from the preceding program  that you must first develop a program using paper  pencil.
Although a program that  first written on a piece of paper not guaranteed to run successfully on the first try, this step  still a good starting point.
On paper, it  easier to spot errors  improve the program, especially with large programs.
The first selection structure, which  implemented with if  if.
The second selection structure, which does not require the evaluation of a logical expression,  called the switch structure.
Cplus_plus's switch structure gives the computer the power to choose from among many alternatives.
A general syntax of the switch statement : { case value1: statements1 break; case value2: statements2 break;.
In a switch structure, first the expression  evaluated.
The value of the expression  then used to choose Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook /or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Recall that in a syntax, shading indicates an optional part of the definition.
Although it need not be, the expression  usually an identifier.
Whether it  an identifier or an expression, the value can be only integral.
The expression  sometimes called the selector.
Its value determines which statement  selected for execution.
A particular case value should appear only once.
One or more statements may follow a case label, so you do not need to use braces to turn multiple statements into a single compound statement.
The general diagram to show the syntax of the switch statement  not straightforward because following a case label a statement /or a break statement may or may not appear.
Keeping these in mind, Figure 4-4 shows the flow of execution of a switch statement.
Note that in the figure following a case value, the box containing statement /or the box containing break may or may not appear.
Following the figure, we give the general rules that a switch statement follows.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook /or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
When the value of the expression  matched against a case value (also called a label), the statements execute until either a break statement  found or the end of the switch structure reached.
If the value of the expression does not match any of the case values, the statements following the default label execute.
If the switch structure has no default label  if the value of the expression does not match any of the case values, the action of the switch statement  null.
A break statement causes an immediate exit from the switch structure.
EXAMPLE 4-22 Consider the following statements, in which grade  a variable of type char: { case 'A': << "The break; case 'B': << "The break; case 'C': << "The break; case 'D': << "The break; case 'F': cout << "The break; default:.
In this switch statement, the expression, grade, is a variable of type char, which is an integral type.
The possible values of grade are 'A', 'B', 'C', 'D', and 'F'.
Each case label specifies a different action to take, depending on the value of grade.
If the value of grade is 'A', the output is: The grade point is 4_0_0.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
EXAMPLE 4-23 The following program illustrates the effect of the break statement.
It asks the user to input a number between 0 and 7.
In each of these sample runs, the user input is shaded.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sample Run 2: Enter an integer between 0 and 7: 2 The number you entered is 2 Cplus_plus's switch.
Sample Run 3: Enter an integer between 0 and 7: 4 The number you entered is 4 Out of the switch.
Sample Run 4: Enter an integer between 0 and 7: 5 The number you entered is 5 This program shows the effect of the break.
Sample Run 5: Enter an integer between 0 and 7: 7 The number you entered is 7 of the break.
Sample Run 6: Enter an integer between 0 and 7: 8 The number you entered is 8 The number is out of.
A walk-through of this program, using certain values of the switch expression num, can help you understand how the break  functions.
If the value of num is 0, the value of the switch expression matches the case value 0.
All statements following case 0: execute until a break  appears.
The first break  appears in Line 13, just before the case value of 4.
Even though the value of the switch expression does not match any of the case values 1, 2, or 3, the statements following these values execute.
When the value of the switch expression matches a case value, all statements execute until a break is encountered, and the program skips all case labels in between.
Similarly, if the value of num is 3, it matches the case value of 3, and the statements following this Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
If the value of num is 4, it matches the case value of 4.
In this situation, the action is empty because only the break , in Line 15, follows the case value of 4.
EXAMPLE 4-24 Although a switch 's case values (labels) are limited, the switch expression can be as complex as necessary.
For example, consider the following switch : { case 0: case 1: case 2: case 3: case 4: case 5: = 'F';.
Assume that  is an int variable with values between 0 and 100.
Each of these values corresponds to the  'F'.
Therefore, in this switch , the action statements of case 0, case 1, case 2, case 3, case 4, and case 5 are all the same.
Rather than write the   = 'F'; followed by the break statement for each of the case values of 0, 1, 2, 3, 4, and 5, you can simplify the programming code by first specifying all of the case values (as shown in the preceding code) and then specifying the desired action statement.
The case values of 9 and 10 follow similar conventions.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Consider the following statements: switch (age { case 1: << << break; case 0: << << }.
If the value of  is 25, the expression  >= 18 evaluates to 1—that is, true.
If the expression evaluates to 1, the statements following the case label 1 execute.
If the value of  is 14, the expression  >= 18 evaluates to 0—that is, false—and the statements following the case label 0 execute.
You can use true and false, instead of 1 and 0, respectively, in the case labels, and rewrite the preceding switch statement as follows: switch ( { case true: << << break; case false: << << }.
As you can see from the preceding examples, the switch statement is an elegant way to implement multiple selections.
You will see the use of a switch statement in the programming example at the end of this chapter.
Even though no fixed rules exist that can be applied to decide whether to use an if.
If multiple selections involve a range of values, you can use either a switch structure (wherein you convert each range to a finite set of values), or an if_0__0__0_else structure.
For instance, in Example 4-24, the value of  depends on the value of.
Because  is an int variable, 60 values correspond to the  of 'F'.
If you list all 60 values as case values, the switch statement could be very long.
However, dividing by 10 reduces these 60 values to only 6 values: 0, 1, 2, 3, 4, and 5.
If the range of values consists of infinitely many values and you cannot reduce them to a set containing a finite number of values, you must use the if.
For example, if happens to be a double variable and fractional scores are possible, the number of values between 0 and 60 is infinite.
However, you can use the expression static_cast<int> () / 10 and still reduce this infinite number of values to just six values.
Avoiding Bugs by Avoiding Partially Understood Concepts Earlier in this chapter, we discussed how a partial understanding of a concept or technique can lead to errors in a program.
In this section, we give another example to illustrate the problem of using partially understood concepts and techniques.
In Example 4-24, we illustrate how to assign a  based on a test  between 0 and 100.
Next, consider the following program that assigns a  based on a test :.
Sample Runs: In these sample runs, the user input is shaded.
Sample Run 1: Enter the test : 110 Invalid test.
Sample Run 2: Enter the test : -70 Invalid test.
Sample Run 3: Enter the test : 75 The grade is The grade is The grade is Invalid test.
From these sample runs, it follows that if the value of testScore is less than 0 or greater than 100, the program produces correct results, but if the value of testScore is between 0 and 100, say 75, the program produces incorrect results.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
As in Sample Run 3, suppose that the value of  is 75.
So, as we indented, it should print The grade is.
However, the output is: The grade is.
Clearly only at most one  statement is associated with each case label.
The problem is a result of having only a partial understanding of how the switch structure works.
Therefore, after executing the statement(s) associated with the matching case label, execution continues with the statement(s) associated with the next case label, resulting in the printing of four unintended lines.
To output results correctly, the switch structure must  a break statement after each  statement, except the last  statement.
We leave it as an exercise for you to modify this program so that it outputs correct results.
Once again, we can see that a partially understood concept can lead to serious errors in a program.
Therefore, taking time to understand each concept and technique completely will save you hours of debugging time.
Terminating a Program with the assert Function Certain types of errors that are very difficult to catch can occur in a program.
For example, division by zero can be difficult to catch using any of the programming techniques you have examined so far.
Cplus_plus includes a predefined function, assert, that is useful in stopping program execution when certain elusive errors occur.
In the case of division by zero, you can use the assert function to ensure that a program terminates with an appropriate error message indicating the type of error and the program location where the error occurred.
Consider the following statements:.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Terminating a Program with the assert Function | 235 In the first statement, if the denominator is 0, logically you should not perform the division.
During execution, however, the computer would try to perform the division.
If the denominator is 0, the program would terminate with an error message stating that an illegal operation has occurred.
The second statement is designed to compute  only if hours is greater than 0 and is positive and less than or equal to 15_0_50.
The third statement is designed to execute certain statements only if  is an uppercase letter.
For all of these statements (for that matter, in any situation), if conditions are not met, it would be useful to halt program execution with a message indicating where in the program an error occurred.
You could handle these types of situations by including output and return statements in your program.
However, Cplus_plus provides an effective method to halt a program if required conditions are not met through the assert function.
The syntax to use the assert function is: assert(expression); Here, expression is any logical expression.
If expression evaluates to true, the next statement executes.
If expression evaluates to false, the program terminates and indicates where in the program the error occurred.
The specification of the assert function is found in the header file cassert.
Therefore, for a program to use the assert function, it must  the following statement: # <cassert> statement using the assert function is sometimes called an assert statement.
Returning to the preceding statements, you can rewrite statement 1 ( = numerator / denominator;) using the assert function.
Because  should be calculated only if denominator is nonzero, you  an assert statement before the assignment statement as follows: assert(denominator); = numerator / denominator; Now, if denominator is 0, the assert statement halts the execution of the program with an error message similar to the following: Assertion failed: denominator, file c:\temp\assert function\assertfunction_0_cpp, line 20 This error message indicates that the assertion of denominator failed.
The error message also gives the name of the file containing the source code and the line number where the assertion failed.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Assertion failed:  _0_= 0, file c:\temp\assert function\assertfunction_0_cpp, line 20 You can also rewrite statement 2 using an assertion statement as follows:.
As you can see, the assert statement not only halts the program, but also identifies the expression where the assertion failed, the name of the file containing the source code, and the line number where the assertion failed.
Although assert statements are useful during program development, after a program has been developed and put into use, if an assert statement fails for some reason, an end user would have no idea what the error means.
Therefore, after you have developed and tested a program, you might want to remove or disable the assert statements.
In a very large program, it could be tedious, and perhaps impossible, to remove all of the assert statements that you used during development.
In addition, if you plan to modify a program in the future, you might like to keep the assert statements.
Therefore, the logical choice is to keep these statements but to disable them.
You can disable assert statements by using the following preprocessor directive: #define NDEBUG This preprocessor directive #define NDEBUG must be placed before the directive.
Watch the Video Cable Company Billing This programming example demonstrates a program that calculates a customer's bill for a local cable company.
There are two types of customers: residential and business.
There are two rates for calculating a cable bill: one for residential customers and one for business customers.
For residential customers, the following rates apply:.
Bill processing fee: $4_0_50 Basic service fee: $20_0_50 Premium channels: $7_0_50 per channel Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: Cable Company Billing.
Bill processing fee: $15_0_00 Basic service fee: $75_0_00 for first 10 connections, $5_0_00 for each additional connection Premium channels: $50_0_00 per channel for any number of connections The program should ask the user for an account number (an integer) and a customer code.
Assume that R or r stands for a residential customer, and B or b stands for a business customer PROBLEM ANALYSIS AND ALGORITHM DESIGN Input The customer's account number, customer code, number of premium channels to which the user subscribes, and, in the case of business customers, number of basic service connections.
Output Customer's account number and the billing amount.
The purpose of this program is to calculate and print the billing amount.
To calculate the billing amount, you need to know the customer for whom the billing amount is calculated (whether the customer is residential or business) and the number of premium channels to which the customer subscribes.
In the case of a business customer, you also need to know the number of basic service connections and the number of premium channels.
Other data needed to calculate the bill, such as the bill processing fees and the cost of a premium channel, are known quantities.
The program should print the billing amount to two decimal places, which is standard for monetary amounts.
This problem analysis translates into the following algorithm: 1.
Set the precision to two decimal places.
Prompt the user for the account number and customer type.
Based on the customer type, determine the number of premium channels and basic service connections, compute the bill, and print the bill: a.
If the customer type is R or r, i.
Prompt the user for the number of premium channels.
Compute the bill.
Print the bill.
If the customer type is B or b, i.
Prompt the user for the number of basic service connections and number of premium channels.
Compute the bill.
Print the bill.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Variables Because the program will ask the user to input the customer account number, customer code, number of premium channels, and number of basic service connections, you need variables to store all of this information.
Also, because the program will calculate the billing amount, you need a variable to store the billing amount.
Thus, the program needs at least the following variables to compute and print the bill:.
Named As you can see, the bill processing fees, the cost of a basic service connection, and the Constants cost of a premium channel are fixed, and these values are needed to compute the bill.
Although these values are constants in the program, the cable company can change them with little warning.
To simplify the process of modifying the program later, instead of using these values directly in the program, you should declare them as named constants.
Based on the problem analysis, you need to declare the following named constants:.
The following statement calculates the billing amount for a residential customer: =  + + numOfPremChannels * ; To compute the business bill, you need to know the number of basic service connections and the number of premium channels to which the user subscribes.
If the number of basic service connections is less than or equal to 10, the cost of the Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: Cable Company Billing.
If the number of basic service connections exceeds 10, you must add the cost for each connection over 10.
The following statement calculates the business billing amount: =  + + numOfPremChannels * ; else =  + * + numOfPremChannels * ; MAIN ALGORITHM Based on the preceding discussion, you can now write the main algorithm.
To output floating-point numbers in a fixed decimal format with a decimal point and trailing zeros, set the manipulators fixed and showpoint.
Also, to output floating-point numbers with two decimal places, set the precision to two decimal places.
Recall that to use these manipulators, the program must include the header file iomanip.
Prompt the user to enter the account number.
Get the customer account number.
Prompt the user to enter the customer code.
Get the customer code.
If the customer code is r or R, a.
Prompt the user to enter the number of premium channels.
Get the number of premium channels.
Calculate the billing amount.
Print the account number and the billing amount.
If the customer code is b or B, a.
Prompt the user to enter the number of basic service connections.
Get the number of basic service connections.
Prompt the user to enter the number of premium channels.
Get the number of premium channels.
Calculate the billing amount.
Print the account number and the billing amount.
If the customer code is something other than r, R, b, or B, output an error message.
For Steps 6 and 7, the program uses a switch statement to calculate the bill for the desired customer.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: Cable Company Billing { case 'r': case 'R':.
Sample Run: In this sample run, the user input is shaded.
This program computes a cable.
Enter account number (an integer): 12345 Enter customer : R or r (Residential), B or b (Business): b Enter the number of basic service connections: 16 Enter the number of premium channels: 8 Account number: 12345 Amount due: $520_0_00 QUICK REVIEW 1.
Control structures alter the normal flow of control.
The two most common control structures  selection  repetition.
Selection structures incorporate decisions in a program.
The relational   == (equality), < (less ), <= (less  or equal to), > (greater ), >= (greater  or equal to),  _0_= (not equal to).
Including a space within the relational  ==, <=, >=,  _0_= creates a syntax error.
Characters  compared using a machine's collating sequence.
Logical expressions evaluate to 1 (or a nonzero value) or 0.
The logical value 1 (or any nonzero value) is treated as true; the logical value 0 is treated as false.
There  two selection structures in Cplus_plus.
One-way selection takes the following form: statement 10.
If expression is true, the statement executes; otherwise, the statement does not execute.
Two-way selection takes the following form: statement1 else statement2 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook /or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Including a semicolon before the statement in a one-way selection creates a semantic error.
In this case, the action of the if statement is empty.
Including a semicolon before statement1 in a two-way selection creates a syntax error.
There is no stand-alone else statement in Cplus_plus.
An else is paired with the most recent if that has not been paired with any other else.
In Cplus_plus, int variables can be used to store the value of a logical expression.
In Cplus_plus, bool variables can be used to store the value of a logical expression.
A sequence of statements enclosed between curly braces, {  }, is called a compound statement or block of statements.
A compound statement is treated as a single statement.
You can use the input stream variable in an if statement to determine the state of the input stream.
Using the assignment operator in place of the equality operator creates a semantic error.
This can cause serious errors in the program.
The switch structure is used to handle multiway selection.
The execution of a break statement in a switch statement immediately exits the switch structure.
If certain conditions  not met in a program, the program can be terminated using the assert function.
EXERCISES The number in parentheses at the end of an exercise refers to the learning objective listed at the beginning of the chapter.
Mark the following statements as true or false: a.
The order in which statements execute in a program is called the flow a one-way selection, if a semicolon is placed after the expression in Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook /or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The expression: g.
The expression in a switch statement should evaluate to a value of the a.
Determine whether the following expressions evaluate to true or a.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook /or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Suppose that , , ,   are int variables   = 25,  = 3,  = 12,.
How does the output in Exercise 10 change  the statement in Line 4 = ( ==.
Write Cplus_plus statements that output First Year  the standing  'F', b.
Write Cplus_plus statements that output First Year or Sophomore  the standing  '1' or '2', Junior or Senior  the standing  '3' or If the number of items bought  less than 5, then the shipping charges are $7_0_00 for each item bought;  the number of items bought  at least 5, but less than 10, then the shipping charges are $3_0_00 for each item bought;  the number of items bought  at least 10, there are no shipping charges.
What  the output of the program in Exercise 17,   = 10 What  the output of the program in Exercise 17,   = 20 and Suppose that sale and bonus are double variables.
Assign the value to fine as follows:  0 <  <= 5, the value assigned to fine $20_0_00;  5 <  <= 10, the value assigned to fine  $75_0_00; 10 <  <= 15, the value assigned to fine  $150_0_00; > 15, the value assigned to fine  $150_0_00 plus $20_0_00 per ( >= 90); << " = 10%" << endl; a.
What  the output  the value of   95.
Justify your answer.
What  the output  the value of   85.
Justify your answer.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time  subsequent rights restrictions require it.
Answer the following questions:.
What is the output in (i) and (ii)  the value of  is 70.
What is the value of  after the  statement executes.
What is the output in (i) and (ii)  the value of  is 80.
What is the value of  after the  statement executes.
Rewrite the following expressions using the conditional operator.
What is the value of   the value of is 3000.
What is the value of   the value of is 5000.
What is the value of   the value of is 6500.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
State whether the following are valid switch statements.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
What is the output if the input is 12.
What is the output if the input is 4.
What is the output if the input is 3.
What is the output if the input is 25.
What What What What is is is is the the the the output output output output if if if if the the the the input input input input is is is is 3.
What What What What is is is is the the the the output output output output if if if if the the the the input input input input is is is is 5.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
After correcting the code, answer the following questions.
What is the output if the input is 10 8.
What is the output if the input is 4 9.
The following program contains errors.
Correct them so that the program.
Write the missing statements in the following program so that it prompts the user to input two numbers.
If one of the numbers is 0 or negative, the program outputs that both numbers must be positive.
If both the numbers are equal, it outputs the sum of the numbers; if the first number is less than or equal to 2 and both the numbers are not equal, it outputs the second number to the power of.
Suppose that classStanding is a char variable, and gpa and dues are double variables.
Write a switch expression that assigns the dues as follows: If classStanding is 'f', the dues are $150_0_00; if classStanding is 's' (if gpa is at least 3_0_75, the dues are $75_0_00; otherwise, dues are 120_0_00); if classStanding is 'j' (if gpa is at least 3_0_75, the dues are $50_0_00; otherwise, dues are $100_0_00); if classStanding is 'n' (if gpa is at least 3_0_75, the dues are $25_0_00; otherwise, dues are $75_0_00).
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
If you pay the full amount, you get $10_0_00 or 1% of the billingAmount, whichever is smaller, as a credit on your next bill; if you pay at least 50% of the billingAmount, the penalty is 5% of the balance; if you pay at least 20% of the billingAmount and less than 50% of the billingAmount, the penalty is 10% of the balance; otherwise, the penalty is 20% of the balance.
Design an algorithm that prompts the user to enter the billing amount and the desired payment.
The algorithm then calculates and outputs the credit or the remaining balance.
If the amount is not paid in full, the algorithm PROGRAMMING EXERCISES 1.
Write a program that prompts the user to input a number.
The program should then output the number and a message saying whether the number is positive, negative, or zero.
Write a program that prompts the user to input three.
The program should then output the  in ascending order.
Write a program that prompts the user to input an integer between 0 and 35.
If the number is less than or equal to 9, the program should output the number; otherwise, it should output A for 10, B for 11, C for 12.
Rearrange the statements so that they prompt the user to input the shape type (rectangle, circle, or cylinder) and the appropriate dimension of the shape.
The program then outputs the following information about the shape: For a rectangle, it outputs the area and perimeter; for a circle, it outputs the area and circumference; and for a cylinder, it outputs the volume and surface area.
After rearranging the statements, your program should be properly indented.
In a right triangle, the square of the length of one side is equal to the sum of the squares of the lengths of the other two sides.
Write a program that prompts the user to enter the lengths of three sides of a triangle and then outputs a message indicating whether the triangle is a right triangle.
A box of cookies can hold 24 cookies, and a container can hold 75 boxes of cookies.
Write a program that prompts the user to enter the total number of cookies, the number of cookies in a box, and the number of cookie boxes in a container.
The program then outputs the number of boxes and the number of containers to ship the cookies.
Note that each box must contain the specified number of cookies, and each container must contain the specified number of boxes.
If the last box of cookies contains less than the number of specified cookies, you can discard it and output the number of leftover cookies.
Similarly, if the last container contains less than the number of specified boxes, you can discard it and output the number of leftover boxes.
The roots of the quadratic equation ax2 + bx +  = 0, a 6¼ 0 are given by the following formula: b  pﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ b2  4 2a In this formula, the term b2  4 is called the discriminant.
If b2  4 = 0, then the equation has a single (repeated) root.
If b2  4 > 0, the equation has two real roots.
If b2  4 < 0, the equation has two complex roots.
Write a program that prompts the user to input the value of a (the coefficient of x2), b (the coefficient of x), and  (the constant term) and outputs the type of roots of the equation.
Furthermore, if b2  4  0, the program should output the roots of the quadratic equation.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Write a program that mimics a calculator.
The program should take as input two integers and the operation to be performed.
It should then output the , the operator, and the result.
Redo Exercise 8 to  floating-point.
If you do not spend any money to buy savings bonds, then because you had a summer job, your parents buy savings bonds for you in an amount equal to 1% of the money you save after paying taxes and buying clothes, other accessories, and school supplies.
If you spend up to 25% of your net income to buy savings bonds, your parents spend $0_0_25 for each dollar you spend to buy savings bonds, plus money equal to 1% of the money you save after paying taxes and buying clothes, other accessories, and school supplies.
If you spend more than 25% of your net income to buy savings bonds, your parents spend $0_0_40 for each dollar you spend to buy savings bonds, plus money equal to 2% of the money you save after paying taxes and buying clothes, other accessories, and school supplies.
Write a program that implements the algorithm given in Example 1-3 (Chapter 1), which determines the monthly wages of a salesperson.
Write a program that implements the algorithm that you designed in Exercise 34 of this chapter.
The number of lines that can be printed on a paper depends on the paper size, the point size of each character in a line, whether lines are double-spaced or single-spaced, the top and bottom margin, and the left and right margins of the paper.
Assume that all characters are of the same point size, and all lines are either single-spaced or double-spaced.
Note that 1  = 72 points.
Moreover, assume that the lines are printed along the  of the paper.
For example, if the length of the paper is 11 inches and  is 8_0_5 inches, then the maximum length of a line is 8_0_5 inches.
Write a program that calculates the number of characters in a line and the number of lines that can be printed on a paper based on the following input from the user: a.
The length and , in inches, of the paper The top, bottom, left, and right margins The point size of a line If the lines are double-spaced, then double the point size of each character Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The company offers two types of service: regular and premium.
Its rates vary, depending on the type of service.
The rates are computed as follows: Regular service: Premium service: a.
Charges for over 50 minutes are $0_0_20 per minute.
Your program should prompt the user to enter an account number, a service code (type char), and the number of minutes the service was used.
A service code of r or R means regular service; a service code of p or P means premium service.
Treat any other character as an error.
Your program should output the account number, type of service, number of minutes the telephone service was used, and the amount due from the user.
For the premium service, the customer may be using the service during the day and the night.
Therefore, to calculate the bill, you must ask the user to input the number of minutes the service was used during the day and the number of minutes the service was used during the night.
Write a program to implement the algorithm that you designed in Exercise 22 of Chapter 1.
Also save the account balance after withdrawal in the file Ch4_Ex15_Output_0_txt.
A new  is in the process of negotiating a contract for a new romance novel.
The publisher is offering three options.
In the first option, the is paid $5,000 upon delivery of the final manuscript and $20,000 when the novel is published.
In the second option, the  is paid 12_0_5% of the net price of the novel for each copy of the novel sold.
In the third option, the is paid 10% of the net price for the first 4000 copies sold, and 14% of the net price for the copies sold over 4000.
The  has some idea about the number of copies that will be sold and would like to have an estimate of the royalties generated under each option.
Write a program that prompts the  to enter the net price of each copy of the novel and the estimated number of copies that will be sold.
The program then outputs the royalties under each option and the best option the  could choose.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Samantha and Vikas are looking to buy a house in a new.
After looking at various models, the three models they like are colonial, split-entry, and single-story.
The builder gave them the base price and the finished area in square feet of the three models.
They want to know the model(s) with the least price per square foot.
Write a program that accepts as input the base price and the finished area in square feet of the three models.
The program outputs the model(s) with the least price per square foot.
One way to determine how healthy a person is by measuring the body fat of the person.
The formulas to determine the body fat for female and male are as follows: Body fat formula for women: A1 ¼ (body weight  0_0_732) + 8_0_987 A2 ¼ wrist measurement (at fullest point) / 3_0_140 A3 ¼ waist measurement (at navel)  0_0_157 A4 ¼ hip measurement (at fullest point)  0_0_249 A5 ¼ forearm measurement (at fullest point)  0_0_434 B ¼ A1 + A2 – A3 – A4 + A5 Body fat ¼ body weight – B Body fat percentage ¼ body fat  100 / body weight Body fat formula for men: A1 ¼ (body weight  1_0_082) + 94_0_42 A2 ¼ wrist measurement  4_0_15 B ¼ A1 – A2 Body fat ¼ body weight – B Body fat percentage ¼ body fat  100 / body weight 19.
Write a program to calculate the body fat of a person.
Ron bought several acres of farm to grow and sell vegetables.
Suppose that Ron wants to grow a maximum of two types of vegetables.
Write a program that prompts Ron or the user to do the following: 1.
Enter the total farm area in acres.
The number of vegetables (one or two) that the user wants to grow.
If the user wants to grow two types of vegetables, then specify the portion, as a percentage, of the farm land used for each type of vegetable.
Enter the seed cost, plantation cost, fertilizing cost, labor cost, for each acre.
Enter vegetable selling price per acre.
Output the total revenue.
Output the profit/loss.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
For special occasions, such as a wedding or conference, the hotel offers a special discount as follows: If the number of rooms booked is at least 10, the discount is 10%; at least 20, the discount is 20%; and at least 30, the discount is 30%.
Also if rooms are booked for at least 3 days, then there is an additional 5% discount.
Write a program that prompts the user to enter the cost of renting one room, the number of rooms booked, the number of days the rooms are booked, and the sales tax (as a percent).
The program outputs the cost of renting one room, the discount on each room as a percent, the number of rooms booked, the number of days the rooms are booked, the total cost of the rooms, the sales tax, and the total billing amount.
Your program must use appropriate named constants to store special values such as various discounts.
Let l be a line in the - plane.
If l is a vertical line, its equation is  = a for some real number a.
Suppose l is not a vertical line and its slope is.
Then the equation of l is  = mx +b, where b is the -intercept.
If l passes through the point (0, 0,), the equation of l can be written as   0 = (  0).
If (1, 1) and (2, 2) are two points in the - plane and 1 6¼ 2, the slope of the line passing through these points is  = (2  1) / (2  1).
Write a program that prompts the user to enter two points in the - plane.
The program outputs the equation of the line and uses if statements to determine and output whether the line is vertical, horizontal, increasing, or decreasing.
If l is a nonvertical line, output its equation in the form = mx +b.
The first 11 prime integers are 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, and 31.
A positive integer between 1 and 1000 (inclusive), other than the first 11 prime integers, is prime if it is not divisible by 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, and 31.
Write a program that prompts the user to enter a positive integer between 1 and 1000 (inclusive) and that outputs whether the number is prime.
If the number is not prime, then output all the numbers, from the list of the first 11 prime integers, which divide the number.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Explore how to construct and use count-controlled, sentinel-controlled, flag-controlled, and EOF-controlled repetition structures 4.
Learn how to debug loops Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
This chapter discusses how repetitions are incorporated in programs.
Why Is Repetition Needed.
David needs to lower his cholesterol count to stay physically fit and reduce the risk of heart attack, and he wants to accomplish this by doing regular exercises.
He decided to join a gym and, among other measures, keep track of the number of calories burned each time he uses the gym.
At the end of each week he wants to determine the average number of calories burned each day.
We need to write a program that David can use to enter the number of calories burned each day and get as output the average number of calories burned each day.
Suppose that the numbers of calories burned each day in a particular week are: 375, 425, 270, 190, 350, 200, and 365.
To find the average number of calories burned each day, we must add these numbers and divide the total by 7.
From what we have learned so far, we can write the following program to find the average number of calories burned each day.
Why Is Repetition Needed.
Sample Run: In this sample run, the user input is shaded.
Enter calories burned day 1: 375 Enter calories burned day 2: 425 Enter calories burned day 3: 270 Enter calories burned day 4: 190 Enter calories burned day 5: 350 Enter calories burned day 6: 200 Enter calories burned day 7: 365 Average number of calories burned each day: 310 As you can see, this program requires us to declare seven variables to store seven numbers.
Now if David wants to determine the average number of calories burned each day of a month, then we need to add and average about 30 numbers, which will require us to declare at least 30 variables, list them again in cin statements, and, perhaps, again in the output statements.
This takes an exorbitant amount of lines and time.
Also, if you want to run this program again with a different number of values, you have to rewrite the program.
Next, let us see if there is a better alternative.
The numbers we want to add are: 375, 425, 270, 190, 350, 200, and 365.
Consider the following statements, in which  and calBurnedInOneDay.
Next, let us execute statements 2 and 3 three times.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
If we execute these two statements seven times, then  contains the sum of the calories burned in a week.
If you want to find the calories burned in 30 days, then you can repeat statements 2 and 3 thirty times, and if you want to find the calories burned in 100 days, you can repeat statements 2 and 3 one hundred times.
In either case, you do not have to declare any additional variables, as you did in the previous Cplus_plus program.
However, as it is written now, we would have to rewrite statements 2 and 3 for each value of we want to add to.
We need a structure that will tell the computer to repeat these same 2 statements 7 times, or 30 times, or 100 times, however many repetitions we want.
Then we can use this Cplus_plus code to add any number of values, whereas the earlier code adds a specific number of values and requires you to drastically change the code to change the number of values.
There are many other situations in which it is necessary to repeat a set of statements.
For example, for each student in a class, the formula for determining the course grade is the same.
Cplus_plus has three repetition, or looping, structures that let you repeat statements over and over until certain conditions are met.
This chapter introduces all three looping (repetition) structures.
The next section discusses the first repetition structure, called the while loop.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Cplus_plus has three repetition, or looping, structures that allow you to repeat a set of statements until certain conditions are met.
This section discusses the first looping structure, called a while loop.
The general form of the while statement is: statement In Cplus_plus, while is a reserved word.
Of course, the statement can be either a simple or compound statement.
The expression acts as a decision maker and is usually a logical expression.
The statement is called the body of the loop.
Note that the parentheses around the expression are part of the syntax.
Figure 5-1 shows the flow of execution of a while loop.
If it initially evaluates to true, the statement executes.
The loop condition—the expression—is then reevaluated.
If it again evaluates to true, the statement executes again.
The statement (body of the loop) continues to execute until the expression is no longer true.
A loop that continues to execute endlessly is called an infinite loop.
To avoid an infinite loop, make sure that the loop's body contains statement(s) that assure that the entry condition—the expression in the while statement—will eventually be false.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sample Run: In this sample run, the user input is shaded.
Enter calories burned  1: 375 Enter calories burned  2: 425 Enter calories burned  3: 270 Enter calories burned  4: 190 Enter calories burned  5: 350 Enter calories burned  6: 200 Enter calories burned  7: 365 Average number of calories burned each : 310 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
EXAMPLE 5-1 Consider the following Cplus_plus program segment:.
The statements from Line 2 to Line 6 forms the while loop.
The expression in the while statement,  <= 20, is in Line 2, and the body of the while loop is from Line 3 to Line 6.
The body of the while loop continues to execute as long as the expression  <= 20 evaluates to true.
The following table shows the iterations of the while loop.
The loop terminates The preceding while loop produces the following output: 0 5 10 15 20 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Also, let us note the following: a.
In the sixth iteration,  becomes 25 but is not printed because the entry condition is false.
If you omit the statement: =  + 5; from the body of the loop, you will have an infinite loop, continually printing rows of zeros.
You must initialize the loop control variable  before you execute the loop.
If the statement: = 0; (in Line 1) is omitted, the loop may not execute at all.
If the two statements in the body of the loop, Lines 4 and 5, are interchanged, it may drastically alter the result.
For example, consider the following statements: = 0;.
If you put a semicolon at the end of the while loop (after the logical expression), then the action statement of the while loop is empty or null.
For example, the action statement of the following while loop is empty.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Typically, the expression checks whether a variable, called the loop control variable (LCV), satisfies certain conditions.
For example, in Example 5-1, the expression in the while statement checks whether  <= 20.
The LCV must be properly initialized before the while loop is encountered, and it should eventually make the expression evaluate to false.
We do this by updating or assigning a new  to the LCV in the body of the while loop.
Therefore, generally while loops are written in the following form: while (expression) //expression tests the LCV {.
The expression,  <= 20, in Line 2, checks whether  is less than or equal to 20.
The statement in Line 5 updates the  of , which eventually makes  greater than 20 and the expression,  <= 20, evaluates to false.
It is possible that the expression in the while statement may contain more than one variable to control the loop.
In that case, the loop has more than one LCV and all LCVs must be properly initialized and updated.
EXAMPLE 5-2 Consider the following Cplus_plus program segment: = 20;.
In this example, at Line 1,  is initialized to 20, which makes the expression  < 20 in the while statement (Line 2) evaluate to false.
Because initially the loop entry condition,  < 20, is false, the body of the while loop never executes.
Hence, no values are output and the  of  remains 20.
This example demonstrates the importance of the  to which the LCV is initialized.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The next few sections describe the various forms of while loops.
Case 1: Counter-Controlled while Loops Suppose you know exactly how many times certain statements need to be executed.
For example, suppose you know exactly how many pieces of data (or entries) need to be read.
In such cases, the while loop assumes the form of a -controlled while loop.
That is, the LCV serves as a "_0_" Suppose that a set of statements needs to be executed N times.
You can set up a  (initialized to 0 before the while statement) to track how many items have been read.
Before executing the body of the while statement, the is compared with N.
If  < N, the body of the while statement executes.
The body of the loop continues to execute until the  of  >= N.
Thus, inside the body of the while statement, the  of  increments by 1 after it reads a new item.
In this case, the while loop might look like the following:.
The program can prompt you to enter the number of items in the file and an input statement can read the  you entered; or you can specify the first item in the file as the number of items in the file, so that you need not remember the number of input values (items).
This is useful if someone other than the programmer enters the data.
EXAMPLE 5-3 Students at a local middle school volunteered to sell fresh baked cookies to raise funds to increase the number of computers for the computer lab.
Each student reported the number of boxes he/she sold.
We will write a program that will output the total number of boxes of cookies sold, the total revenue generated by selling the cookies, and the average number of boxes sold by each student.
The data provided is in the following form: studentName numOf BoxesSold Consider the following program: //Program: Counter-Controlled Loop //This program computes and outputs the total number of boxes of //cookies sold, the total revenue, and the average number of //boxes sold by each volunteer.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sample Run: In this sample run, the user  is shaded.
Line 14: Enter the number of volunteers: 5 Line 21: Enter the volunteer's name and the number of boxes sold: Sara 120 Line 21: Enter the volunteer's name and the number of boxes sold: Lisa 128 Line 21: Enter the volunteer's name and the number of boxes sold: Cindy 359 Line 21: Enter the volunteer's name and the number of boxes sold: Nicole 267 Line 21: Enter the volunteer's name and the number of boxes sold: Blair 165 Line 27: The total number of boxes sold: 1039 Line 28: Enter the cost of one box: 3_0_50 Line 31: The total money made by selling cookies: $3636_0_50 Line 33: The average number of boxes sold by each volunteer: 207 This program works as follows.
The statements in Lines 7 to 12 declare the variables used in the program.
The statement in Line 14 prompts the user to enter the number of student volunteers.
The statement in Line 15 inputs this number into the variable numOfVolunteers.
The statements in Lines 17 and 18 initialize the variables  and The while statement in Line 19 checks the value of  to determine how many students' data have been read.
If  is less than numOfVolunteers, the while loop proceeds for the next iteration.
The statement in Line 21 prompts the user to  the student's name and the number of boxes sold by the student.
The statement in Line 22 inputs the student's name into the variable name and the number of boxes sold by the student into the variable numOfBoxesSold.
The statement in Line 24 updates the value of  by adding the value of numOfBoxesSold to its current value and the statement in Line 25 increments the value of  by 1.
The statement in Line 27 outputs the total number of boxes sold, the statement in Line 28 prompts the user to the cost of one box of cookies, and the statement in Line 29 inputs the cost in the variable.
The statement in Line 31 outputs the total money made by selling cookies, and the statements in Lines 32 through 35 output the average number of boxes sold by each volunteer.
Note that  is initialized to 0 in Line 17 in this program.
In Line 22, after reading the number of boxes sold by a student, the program adds it to the sum of all the boxes sold before the current number of boxes sold.
The first numOfBoxesSold Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
To find the average, divide by.
If  is 0, then dividing by zero will terminate the program and you will get an error message.
Therefore, before dividing  by , you must check whether or not  is 0.
Notice that in this program, the statement in Line 18 initializes the LCV  to 0.
The expression  < numOfVolunteers in Line 19 evaluates whether  is less than numOfVolunteers.
The statement in Line 25 updates the value of.
Case 2: Sentinel-Controlled while Loops You do not always know how many pieces of data (or entries) need to be read, but you may know that the last entry is a special value, called a sentinel, that will tell the loop to stop.
In this case, you must read the first item before the while statement so the test expression will have a valid value to test.
If this item does not equal the sentinel, the body of the while statement executes.
The while loop continues to execute as long as the program has not read the sentinel.
Such a while loop is called a sentinelcontrolled while loop.
In this case, a while loop might look like the following:.
However, the program assumes that the programmer knows the exact number of volunteers.
Now suppose that the programmer does not know the exact number of volunteers.
Once again, assume that the data is in the following form: student's name followed by a space and the number of boxes sold by the student.
Because we do not know the exact number of volunteers, we assume that reading a value of -1 for name will mark the end of the data, since it is a highly unlikely name to run into.
So consider the following program: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sample Run: In this sample run, the user  is shaded.
Line 14: Enter each volunteer's  and the number of boxes sold by each volunteer, ending  -1: Sara 120 Lisa 128 Cindy 359 Nicole 267 Blair 165 Abby 290 Amy 190 Megan 450 Elizabeth 280 Meredith 290 Leslie 430 Chelsea 378 -1 Line 26: The total number of boxes sold: 3347 Line 27: Enter the cost of one box: 3_0_50 Line 30: The total money made by selling cookies: $11714_0_50 Line 32: The average number of boxes sold by each volunteer: 278 This program works as follows.
The statements in Lines 8 to 12 declare the variables used in the program.
The statement in Line 14 prompts the user to enter the data ending  -1.
The statements in Lines 15 and 16 initialize the variables  and The statement in Line 17 reads the first  and stores it in.
The while statement in Line 18 checks whether  is not equal to.
The statement in Line 20 reads and stores the number of boxes sold by the student in the  numOfBoxesSold and the statement in Line 21 updates the value of  by adding numOfBoxesSold to it.
The statement in Line 22 increments the value of  by 1, and the statement in Line 23 reads and stores the next  into.
The statements in Lines 20 through 23 repeat until the program reads the.
The statement in Line 26 outputs the total number of boxes sold, the statement in Line 27 prompts the user to  the cost of one box of cookies, and the statement in Line 28 inputs the cost in the.
The statement in Line 30 outputs the total money made by selling cookies, and the statements in Lines 31 through 34 output the average number of boxes sold by each volunteer.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Notice that the statement in Line 17 initializes the LCV.
The expression  _0_¼ in Line 18 checks whether the value of  is not equal to.
The statement in Line 23 updates the LCV.
Next, consider another example of a sentinel-controlled while loop.
In this example, the user is prompted to enter the value to be processed.
If the user wants to stop the program, he or she can enter the sentinel.
EXAMPLE 5-5 Telephone Digits The following program reads the letter codes A to Z and prints the corresponding telephone digit.
This program uses a sentinel-controlled while loop.
To stop the program, the user is prompted for the sentinel, which is #.
This is also an example of a nested control structure, where if_0__0__0_else and the while loop are nested.
Program to convert uppercase letters to their corresponding telephone digits.
Enter a : A : A, Corresponding telephone : 2 Enter another uppercase  to find its corresponding telephone.
Enter a : M : M, Corresponding telephone : 6 Enter another uppercase  to find its corresponding telephone.
Enter a : Q : Q, Corresponding telephone : 7 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time  subsequent rights restrictions require it.
Enter another uppercase  to find its corresponding telephone.
Enter a : V : V, Corresponding telephone : 8 Enter another uppercase  to find its corresponding telephone.
Enter a : Y : Y, Corresponding telephone : 9 Enter another uppercase  to find its corresponding telephone.
Enter a : # This program works as follows.
The statements in Lines 8 and 9 tell the user what to do.
The statement in Line 10 prompts the user to  a ; the statement in Line 11 reads and stores that  into the variable.
The while loop at Line 13 checks is #.
If the  entered by the user is not #, the body of the while loop executes.
The statement at Line 15 outputs the  entered by the user.
The statement in Line 17 determines the position of the  in the English alphabet.
If the  entered by the user is uppercase, the statements between Lines 19 and 27 determine and output the corresponding telephone.
If the entered by the user is not valid, the else (Line 28) executes.
Let us see how the statements in Lines 19 to 27 determine the corresponding telephone digits.
Now, the letters A, B, and C correspond to the telephone  2, letters D, E, and F correspond to the telephone  3, and so on.
Note that the letters P, Q, R, and S correspond to telephone  7, and the letters W, X, Y, and Z correspond to the telephone 9.
The ASCII values of the letters A, B, and C, are 65, 66, and 67, respectively.
We subtract 65 from these values to get 0, 1, and 2.
If we divide each of these numbers by 3, then the quotient is 0, so we add 2 to the quotient to get the corresponding telephone Similarly, the ASCII values of the letters D, E, and F are 68, 69, and 70, respectively.
We subtract 65 from these values, to get 3, 4, and 5.
Again we divide 3, 4, and 5 by 3 to get the quotient 1, and then add 2 to get the corresponding telephone , which is 3.
The statements in Lines 18 to 23 handle the cases when four letters, such as P, Q, R, and S, correspond to a telephone.
We leave the details as an exercise.
Once the current  is processed, the statements at Lines 30 and 31 again inform the user what to do next.
The statement at Line 32 prompts the user to  a ; the statement at Line 33 reads and stores that  into the variable.
After the statement at Line 34 (at the end of the while loop) executes, the control goes back to the top of the while loop and the same process begins again.
When the user enters #, the program terminates.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time  subsequent rights restrictions require it.
First, it is initialized in Line 11, by the  statement, and then updated in Line 33.
The expression in Line 13 checks whether  is #.
The statements in Lines 17 to 29 can be written using a switch statement by checking each  and outputting the corresponding telephone  as follows: { case '': case 'B': case 'C': << 2 << endl; break; case 'D':.
However, this code will be very long and occupy a considerable amount of space.
Case 3: Flag-Controlled while Loops flag-controlled while loop uses a bool variable to control the loop.
It is generally named for the true state of that condition: for example, , isTallEnough, and isFull.
Suppose  is a bool variable.
The flag-controlled while loop takes the following form:.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Example 5-6 further illustrates the use of a flag-controlled while loop.
EXAMPLE 5-6 Number Guessing Game The following program randomly generates an integer greater than or equal to 0 and less than 100.
The program then prompts the user to guess the number.
If the user guesses the number correctly, the program outputs an appropriate message.
Otherwise, the program checks whether the guessed number is less than the random number.
If the guessed number is less than the random number generated by the program, the program outputs the message "Your guess is lower than the number.
Guess again_0_"; otherwise, the program outputs the message "Your guess is higher than the number.
The program then prompts the user to enter another number.
The user is prompted to guess the random number until the user enters the correct number.
To generate a random number, you can use the function  from the header file cstdlib.
For example, the expression () returns an int value between 0 and 32767.
Therefore, the statement: << () << ", " << () << endl; will output two numbers that appear to be random.
However, each time the program is run, this statement will output the same random numbers.
This is because the function  uses an algorithm that produces the same sequence of random numbers each time the program is executed on the same system.
To generate different random numbers each time the program is executed, you also use the function srand from the header file cstdlib.
The function srand takes as input an unsigned int, which acts as the seed for the algorithm.
By specifying different seed values, each time the program is executed, the function  will generate a different sequence of random numbers.
To specify a different seed, you can use the function time from the header file ctime, which returns the number of seconds elapsed since January 1, 1970.
For example, consider the following statements: srand(time(0)); = () % 100; The first statement sets the seed, and the second statement generates a random number greater than or equal to 0 and less than 100.
Note how the function time is used.
It is used with an argument, that is, parameter, which is 0.
The program uses the bool variable isGuessed to control the loop.
The bool variable isGuessed is initialized to false.
It is set to true when the user guesses the correct number.
Sample Run: In this sample run, the user input is shaded.
Enter an integer greater than or equal to 0 and less than 100: 45 Your  is higher than the.
Enter an integer greater than or equal to 0 and less than 100: 20 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Enter an integer greater than or equal to 0 and less than 100: 35 Your  is higher than the.
Enter an integer greater than or equal to 0 and less than 100: 28 Your  is lower than the.
Enter an integer greater than or equal to 0 and less than 100: 32 You guessed the correct.
The preceding program works as follows: The statement in Line 2 creates an integer greater than or equal to 0 and less than 100 and stores this  in the variable.
The statement in Line 3 sets the bool variable  to false.
The expression in the while loop at Line 4 evaluates the expression _0_.
We could also have used  == false as the test expression, but.
The statement in Line 6 prompts the user to enter an integer greater than or equal to 0 and less than 100.
The statement in Line 7 stores the  entered by the user in the variable.
The expression in the if statement in Line 9 determines whether the value of  is the same as , that is, if the user guessed the  correctly.
If the value of  is the same as , the statement in Line 11 outputs the message: You guessed the correct.
The statement in Line 12 sets the variable  to true.
The control then goes back to Line 3.
If the expression in Line 9 evaluates to false, then the else statement in Line 14 determines whether the value of  is less than or greater than  and outputs the appropriate message.
Case 4: EOF-Controlled while Loops If the data file is frequently altered (for example, if data is frequently added or deleted), it's best not to read the data with a sentinel value.
Someone might accidentally erase the sentinel value or add data past the sentinel, especially if the programmer and the data entry person are different people.
Also, it can be difficult at times to select a good sentinel value.
In such situations, you can use an end-of-file (EOF)-controlled while loop.
Until now, we have used an input stream variable, such as cin, and the extraction operator, >>, to read and store data into variables.
However, the input stream variable can also return a value after reading data, as follows: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
If the program has reached the end of the input data, the input stream variable returns the logical value false.
If the program reads any faulty data (such as a char value into an int variable), the input stream enters the fail state.
Once a stream enters the fail state, any further I/O operations using that stream are considered to be null operations; that is, they have no effect.
Unfortunately, the computer does not halt the program or give any error messages.
It just continues executing the program, silently ignoring each additional attempt to use that stream.
In this case, the input stream variable returns the value false.
In cases other than (1) and (2), the input stream variable returns the logical value true.
You can use the value returned by the input stream variable to determine whether the program has reached the end of the input data.
Because the input stream variable returns the logical value true or false, in a while loop, it can be considered a logical expression.
The following is an example of an EOF-controlled while loop:.
This function is called eof.
Like the I/O functions—such as get, ignore, and peek, discussed in Chapter 3— the function eof is a member of the data type istream.
The syntax to use the function eof is: in which istreamVar is an input stream variable, such as cin.
Suppose you have the declaration: ifstream infile; Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
This is a logical (Boolean) expression.
The value of this expression is true if the program has read past the end of the input file, infile; otherwise, the value of this expression is false.
Using the function eof to determine the end-of-file status works best if the input is text.
The earlier method of determining the end-of-file status works best if the input consists of numeric data.
Suppose you have the declaration:.
In the Windows console environment, the end-of-file marker is entered using Ctrl+z (hold the Ctrl key and press z).
In the UNIX environment, the end-of-file marker is entered using Ctr+d (hold the Ctrl key and press d).
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
EXAMPLE 5-8 Suppose we are given a file consisting of students' names and their test scores, a number between 0 and 100 (inclusive).
Each line in the file consists of a student name followed by the test score.
We want a program that outputs each student's name followed by the test score followed by the grade.
The program also needs to output the average test score for the class.
Consider the following program:.
This program reads data from a file consisting of students' names and their test scores.
The program outputs each student's name followed by the test score followed by the grade.
The program also outputs the average test score for all the students.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Line 26 27 28 29 //determine the { case 0: case 1: case 2: case 3: case 4: case 5:.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sample Run: Input File: Steve Gill 89 Rita Johnson 91_0_5 Randy Brown 85_0_5 Seema Arora 76_0_5 Samir Mann 73 Samantha McCoy 88_0_5 Output File: Steve Rita Randy Seema Samir Samantha Gill Johnson Brown Arora Mann McCoy 89_0_00 91_0_50 85_0_50 76_0_50 73_0_00 88_0_50 B A B C C B Class : 84_0_00 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the  to remove additional content at any time if subsequent rights restrictions require it.
The preceding program works as follows.
The statements in Lines 8 to 13 declare and initialize variables needed by the program.
The statements in Lines 14 and 15 declares inFile to be an ifstream variable and  to be an ofstream variable.
The statement in Line 16 opens the input file using the variable inFile.
If the input file does not exist, the statements in Lines 17 to 21 output an appropriate message and terminate the program.
The statement in Line 22 opens the output file using the variable.
The statement in Line 23 sets the output of floating-point numbers to two decimal places in a  form with trailing zeros.
The statements in Lines 24 and 25 and the while loop in Line 26 read each student's first name, last name, and test  and then output the name followed by the test followed by the.
Specifically, the statements in Lines 24 and 57 read the first and last name; the statements in Lines 25 and 58 read the test.
The statement in Line 28 updates the value of sum.
The statement in Line 56 outputs a student's first name, last name, test , and.
The if_0__0__0_else statement in Lines 61 to 64 outputs the class average and the statements in Lines 65 and 66 close the files.
The Programming Example: Checking Account Balance, available on the Web site accompanying this book, further illustrates how to use an EOF-controlled while loop in a program.
More on Expressions in while Statements In the examples of the previous sections, the expression in the while statement is quite simple.
In other words, the while loop is controlled by a single variable.
However, there are situations when the expression in the while statement may be more complex.
For example, the program in Example 5-6 uses a flag-controlled while loop to implement the Number Guessing Game.
However, the program gives as many tries as the user needs to guess the number.
Suppose you want to give the user no more than five tries to guess the number.
If the user does not guess the number correctly within five tries, then the program outputs the random number generated by the program as well as a message that you have lost the game.
In this case, you can write the while loop as follows (assume that noOfGuesses is an int variable initialized to 0): {.
Programming Example: Fibonacci Number.
The correct number  " <<  << endl; Programming Exercise 15 at the end of this chapter asks you to write a complete Cplus_plus program to implement the Number Guessing Game in which the user has, at most, five tries to  the number.
As you can see from the preceding while loop, the expression in a while statement can be complex.
The main objective of a while loop  to repeat certain statement(s) until certain conditions are met.
PROGRAMMING EXAMPLE: Fibonacci Number So far, you have seen several examples of loops.
Recall that in Cplus_plus, while loops are used when certain statements must be executed repeatedly until certain conditions are met.
Following  a Cplus_plus program that uses a while loop to find a Fibonacci number.
Watch the Video Consider the following sequence of numbers: 1, 1, 2, 3, 5, 8, 13, 21, 34, _0__0__0_.
This sequence  called the Fibonacci sequence.
Given the first two numbers of the sequence (say, a1 and a2), the nth number an,  >= 3, of this sequence  given by: an ¼ an1 þ an2 Thus: a3 ¼ a2 þ a1 ¼ 1 þ 1 ¼ 2, a4 ¼ a3 þ a2 ¼ 2 þ 1 ¼ 3, and so on.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
However, given any first two numbers, using this process, you can determine the nth number, an, >= 3, of the sequence.
We will call such  sequence  Fibonacci sequence.
Then: 3 ¼ 2 þ 1 ¼ 6 þ 3 ¼ 9; 4 ¼ 3 þ 2 ¼ 9 þ 6 ¼ 15 Next, we write  program that determines the nth Fibonacci number given the first two numbers.
PROBLEM ANALYSIS AND ALGORITHM DESIGN Input.
The nth Fibonacci number.
To find, say, the tenth Fibonacci number of  sequence, you must first find 9 and 8, which requires you to find 7 and 6, and so on.
Therefore, to find 10, you must first find 3, 4, 5,.
This discussion translates into the following algorithm: 1.
Get the first two Fibonacci numbers.
Get the desired Fibonacci position.
That , get the position, , of the Fibonacci number in the sequence.
Calculate the next Fibonacci number by adding the previous two elements of the Fibonacci sequence.
Repeat Step 3 until the nth Fibonacci number  found.
Output the nth Fibonacci number.
Note that the program assumes that the first number of the Fibonacci sequence  less than or equal to the second number of the Fibonacci sequence, and both numbers are nonnegative.
Moreover, the program also assumes that the user enters  valid value for the position of the desired number in the Fibonacci sequence; that , it   positive Variables Because the previous two numbers must be known in order to find the current Fibonacci number, you need the following variables: two variables—say, previous1 and previous2 to hold the previous two numbers of the Fibonacci sequence; and one variable—say, current—to hold the current Fibonacci number.
The number of times that Step 2 of the algorithm repeats depends on the position of the Fibonacci number you are calculating.
For example, if you want to calculate the tenth Fibonacci number, you must execute Step 3 eight times.
You also need  variable to track the number of times Step 3 has executed, the loop control variable.
You therefore need five variables for the data manipulation: int previous1; int previous2;.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: Fibonacci Number.
To calculate the third Fibonacci number, add the values of previous1 and previous2 and store the result in current.
To calculate the fourth Fibonacci number, add the value of the second Fibonacci number (that , previous2) and the value of the third Fibonacci number (that , current).
Thus, when the fourth Fibonacci number  calculated, you no longer need the first Fibonacci number.
Instead of declaring additional variables, which could be too many, after calculating  Fibonacci number to determine the next Fibonacci number, previous1  set to previous2 and previous2  set to current.
Therefore, you can  use the variable current to store the next Fibonacci number.
This process  repeated until the desired Fibonacci number  calculated.
Initially, previous1 and previous2 are the first two elements of the sequence, supplied by the user.
From the preceding discussion, it follows that you need five variables.
Prompt the user for the first two numbers—that , previous1 and previous2.
Read (input) the first two numbers into previous1 and previous2.
Prompt the user for the position of the desired Fibonacci number.
Read the position of the desired Fibonacci number into.
The desired Fibonacci number is the first Fibonacci number.
Copy the value of previous1 into current.
The desired Fibonacci number is the second Fibonacci number.
Copy the value of previous2 into current.
Initialize counter to 3 to keep track of the calculated Fibonacci numbers.
Calculate the next Fibonacci number, as follows: c_0_3.
Assign the value of previous2 to previous1.
Assign the value of  to previous2.
Repeat Steps c_0_2 through c_0_5 until the Fibonacci number you want is calculated.
The following while loop executes Steps c_0_2 through c_0_5 and determines the nth Fibonacci number.
Sample Runs: In these sample runs, the user input is shaded.
Sample Run 1: Enter the first two Fibonacci numbers: 12 16 The first two Fibonacci numbers are 12 and 16 Enter the position of the desired Fibonacci number: 10 The Fibonacci number at position 10 is 796 Sample Run 2: Enter the first two Fibonacci numbers: 1 1 The first two Fibonacci numbers are 1 and 1 Enter the position of the desired Fibonacci number: 15 The Fibonacci number at position 15 is 610 for Looping (Repetition) Structure The while loop discussed in the  section is general enough to implement most forms of repetitions.
The Cplus_plus for looping structure discussed here is a specialized form of the while loop.
Its primary purpose is to simplify the writing of -controlled loops.
For this reason, the for loop is typically called a counted or indexed for loop.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The general form of the for statement is: statement The initial statement, loop condition, and update statement (called for of the for statement.
Figure 5-2 shows the flow of execution of a for loop.
The initial statement executes.
The loop condition is evaluated.
If the loop condition evaluates to true: i.
Execute the for loop statement.
Execute the update statement (the third expression in the parentheses).
Repeat Step 2 until the loop condition evaluates to false.
The initial statement usually initializes a variable (called the for loop control, or for indexed, variable).
In Cplus_plus, for is a reserved word.
As the name implies, the initial statement in the for loop is the first statement to execute; it executes only once.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Next, the loop condition,  < 10, is evaluated.
Because 0 < 10 is true, the print statement executes and outputs 0.
The update statement, iplus_plus, then executes, which sets the value of  to 1.
Once again, the loop condition is evaluated, which is still true, and so on.
When becomes 10, the loop condition evaluates to false, the for loop terminates, and the first statement following the for loop executes.
A for loop can have either a simple or compound statement.
The following examples further illustrate how a for loop executes.
EXAMPLE 5-10 five times:.
Therefore, the first output statement executes five times because the for loop body executes five times.
After the for loop executes, the second output statement executes only once.
The indentation, which is ignored by the compiler, is nevertheless misleading.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Example 5-10(2), the indentation of Line 2 is misleading.
The preceding examples show that care is required in getting a for loop to perform the desired action.
The following are some comments on for loops:.
If the loop condition is initially false, the loop body does not execute.
The update expression, when executed, changes the value of the loop control variable (initialized by the initial expression), which should change in such a way that eventually sets the value of the loop condition to false.
The for loop body executes indefinitely if the loop condition is always true.
Cplus_plus allows you to use fractional values for loop control variables of the double type (or any real data type).
Because different computers can give these loop control variables different results, you should avoid using such variables.
A semicolon at the end of the for statement (just before the body of the loop) is a semantic error.
In this case, the action of the for loop is empty.
In the for statement, if the loop condition is omitted, it is assumed to be true.
In a for statement, you can omit all three statements—initial statement, loop condition, and update statement.
However, the for statement must contain two semicolons.
The following is a legal for loop: << "" << endl; This is an infinite for loop, continuously printing the word.
Following are more examples of for loops.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
For example, consider the following for loop: << " " << ; << endl;.
After each iteration of the loop,  is decremented by 1.
The loop continues to execute as long as  >= 1.
EXAMPLE 5-13 You can increment (or decrement) the loop control variable by any fixed number.
In the following for loop, the variable is initialized to 1; at the end of the for loop,  is incremented by 2.
This for loop outputs the first 10 positive odd integers.
Consider the following for loop: <<  << " "; << endl;.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Because initially the loop condition ( >= 10) is false, nothing happens.
Consider the following for loop:.
Next, the update statement increments the value of  by 1, so the value of  becomes 11.
Now the loop condition evaluates to false and the for loop terminates.
Note that the output statement in Line 2 executes only once.
Consider the following for loop:.
This for loop has no effect on the output statement in Line 2.
The semicolon at the end of the for statement terminates the for loop; the action of the for loop is thus empty.
The output statement is all by itself and executes only once.
Consider the following for loop: <<  << " "; << endl; In this for loop, because the loop condition is omitted from the for statement, the loop condition is always true.
This is an infinite loop.
The following for loop outputs the positive powers of 2 up to 100.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Consider the following program code, in which , newNum, , and average are int variables: = 0;.
In the preceding for loop, after reading a newNum, this value  added to the previously calculated (partial)  of all the numbers read before the current number.
Thus, after the program reads the first number and adds it to the value of , the variable  holds the correct  of the first number.
The syntax of the for loop, which : statement functionally equivalent to the following while statement: initial expression { statement update expression } For example, the following for and while loops are equivalent:.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
You can replace the while loop with an equivalent for loop as follows:.
The complete program listing of the program that uses a for loop to determine the desired Fibonacci number  given at the Web site accompanying this book.
The program named Ch5_FibonacciNumberUsingAForLoop_0_cpp.
In the following Cplus_plus program, we recommend that you walk through each step.
EXAMPLE 5-17 The following Cplus_plus program finds the  of the first n positive integers.
Programming Example: Classifying Numbers.
Line 1: Enter the number of positive integers to be added: 100 Line 7: The  of the first 100 positive integers  5050 The statement in Line 1 prompts the user to enter the number of positive integers to be added.
The statement in Line 2 stores the number entered by the user in n, and the statement in Line 3 initializes  to 0.
The for loop in Line 5 executes n times.
In the for loop, initialized to 1 and  incremented by 1 after each iteration of the loop.
Therefore, ranges from 1 to n.
Each time through the loop, the value of   added to.
The variable  was initialized to 0,  ranges from 1 to n, and the  value of added to the value of.
Therefore, after the for loop executes,  contains the  of the first n values, which in the sample run  100 positive integers.
Recall that putting one control structure statement inside another  called nesting.
The following programming example demonstrates a simple instance of nesting.
It also nicely demonstrates counting.
PROGRAMMING EXAMPLE: Classifying Numbers This program reads a given set of integers and then prints the number of odd and even integers.
It also outputs the number of zeros.
The program reads 20 integers, but you can easily modify it to read any set of numbers.
In fact, you can modify the program so that it first prompts the user to specify how many integers are to be read.
PROBLEM ANALYSIS AND ALGORITHM DESIGN Input.
The number of zeros, even numbers, and odd numbers.
After reading a number, you need to check whether it  even or odd.
Suppose the value  stored in number.
Divide number by 2 and check the remainder.
If the remainder  0, number  even.
Increment the even count and then check whether number  0.
If it , increment the zero count.
If the remainder  not 0, increment the odd count.
The program uses a switch statement to decide whether number  odd or even.
Suppose that number  odd.
Dividing by 2 gives the remainder 1 if number positive and the remainder -1 if it  negative.
If number  even, dividing by 2 gives the remainder 0 whether number  positive or negative.
You can use the mod operator, %, to find the remainder.
For example: 6 % 2 = 0; -4 % 2 = 0; -7 % 2 = -1; 15 % 2 = 1 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Repeat the preceding process of analyzing a number for each number in the list.
This discussion translates into the following algorithm: 1.
For each number in the list: a.
Analyze the number.
Increment the appropriate count.
Print the results.
Variables Because you want to count the number of zeros, even numbers, and odd numbers, you need three variables of type int—say, zeros, evens, and odds—to track the counts.
You also need a variable—say, number—to read and store the number to be analyzed and another variable—say, —to count the numbers analyzed.
Therefore, you need the following variables in the program: int int int int int.
You can initialize these variables when you declare them.
Declare and initialize the variables.
Prompt the user to enter 20 numbers.
For each number in the list: a.
Read the number.
Output the number (echo input).
Print the results.
Before writing the Cplus_plus program, let us describe Steps 1–4 in greater detail.
Then it will be much easier for you to write the instructions in Cplus_plus.
Initialize the variables.
You can initialize the variables zeros, evens, and odds when you declare them.
Use an output statement to prompt the user to enter 20 numbers.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: Classifying Numbers.
For Step 3, you can use a for loop to process and analyze the 20 numbers.
In pseudocode, this step is written as follows:.
Sample Run: In this sample run, the user input is shaded.
Please enter 20 integers, positive, negative, or.
The numbers you entered : 0 0 -2 -3 -5 6 7 8 0 3 0 -23 -8 0 2 9 0 12 67 54 0 0 -2 -3 -5 6 7 8 0 3 0 -23 -8 0 2 9 0 12 67 54 There  13 , which includes 6.
The  of odd numbers is: 7 We recommend that you do a walk-through of this program using the above sample input.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The general form of a do.
If it is a compound statement, enclose it between braces.
Figure 5-3 shows the flow of execution of a do.
The statement executes first, and then the expression is evaluated.
If the expression evaluates to true, the statement executes again.
As long as the expression in a do_0__0__0_while statement is true, the statement executes.
To avoid an infinite loop, you must, once again, make sure that the loop body contains a statement that ultimately makes the expression false and assures that it exits properly.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
After 20 is output, the statement: =  + 5; changes the value of  to 25 and so  <= 20 becomes false, which halts the loop.
In a while and for loop, the loop condition is evaluated before executing the body of the loop.
Therefore, while and for loops  called pretest loops.
On the other hand, the loop condition in a do.
Because the while and for loops both have entry conditions, these loops may never activate.
The do_0__0__0_while loop, on the other hand, has an exit condition and therefore always executes the statement at least once.
EXAMPLE 5-19 Consider the following two loops: a.
In (a), the while loop produces nothing, the statement never executes.
In (b), the do_0__0__0_while loop outputs the  11 and also changes the value of  to 16.
This is expected because in a do_0__0__0_while, the statement must always execute at least once.
A do_0__0__0_while loop can be used for input validation.
Suppose that a program prompts a user to enter a test score, which must be greater than or equal to 0 and less than or equal to 50.
If the user enters a score less than 0 or greater than 50, the user should be prompted to re-enter the score.
The following do_0__0__0_while loop can be used to accomplish this objective: int ;.
Divisibility Test by 3 and 9 Suppose that m and   integers and m is nonzero.
It is known   is divisible by 3 and 9 if  is divisible by 3 and 9.
In other words, an integer is divisible by 3 and 9 if and only if the sum of its digits is divisible by 3 and 9.
For example, suppose  = 27193257.
Because 36 is divisible by both 3 and 9, it follows  27193257 is divisible by both 3 and 9.
Next, we write a program  determines whether a positive integer is divisible by 3 and 9 by first finding the sum of its digits and then checking whether the sum is divisible by 3 and 9.
To find the sum of the digits of a positive integer, we need to extract each digit of the Consider the  951372.
Also note  951372 / 10 = 95137;  is, when the  is divided by 10, it removes the last digit.
Next, we repeat this process on the number 95137.
Of course, we need to add the extracted digits.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter().
Editorial review has deemed  any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
We thus have the following algorithm to find the  of the digits:.
Sample Runs: In these sample runs, the user input is shaded.
Sample Run 1 Enter a positive integer: 27193257 The  of the  = 36 27193257 is divisible by 3  9 Sample Run 2 Enter a positive integer: 609321 The  of the  = 21 609321 is divisible by 3, but  9 Sample Run 3 Enter a positive integer: 161905102 The  of the  = 25 161905102 is  divisible by 3  9 Choosing the Right Looping Structure All three loops have their place in Cplus_plus.
If you know,  the program can determine in advance, the number of repetitions needed, the for loop is the correct choice.
If you do know,  the program cannot determine in advance the number of repetitions needed,  it could be 0, the while loop is the right choice.
If you do  know, the program cannot determine in advance the number of repetitions needed,  it is at least 1, the do_0__0__0_while loop is the right choice.
The break statement is typically used for two purposes:.
To exit early from a loop.
To skip the remainder of the switch structure.
After the break statement executes, the program continues to execute with the first statement after the structure.
The use of a break statement in a loop can eliminate the use of certain (flag) variables.
The following Cplus_plus code segment helps illustrate this idea.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May  be copied, scanned,  duplicated, in whole  in part.
Due to electronic rights, some third party content may be suppressed from the eBook / eChapter().
Editorial review has deemed  any suppressed content does  materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
This while loop is supposed to find the  of a set of positive numbers.
If the  set contains a negative number, the loop terminates with an appropriate error message.
This while loop uses the flag variable  to signal the presence of a negative number.
The variable  is initialized to false before the while loop.
Before adding to , a check is made to see if  is negative.
If  is negative, an error message appears on the screen   is set to true.
In the next iteration, when the expression in the while statement is evaluated, it evaluates to false because is false.
In this form of the while loop, when a negative number is found, the expression in the if statement evaluates to true; after printing an appropriate message, the break statement terminates the loop.
All Rights Reserved.
May  be copied, scanned,  duplicated, in whole  in part.
Due to electronic rights, some third party content may be suppressed from the eBook / eChapter().
Editorial review has deemed  any suppressed content does  materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
However, break statements must be used very sparingly within a loop.
An excessive use of these statements in a loop will produce spaghetti-code (loops with many exit conditions)  can be very hard to understand  manage.
You should be extra careful in using break statements  ensure that the use of the break statements makes the code more readable   less readable.
The continue statement is used in while, for,  do.
When the continue statement is executed in a loop, it skips the remaining statements in the loop  proceeds with the next iteration of the loop.
In a for structure, the update statement is executed after the continue statement,  then the loop condition (that is, the loopcontinue test) executes.
If the previous program segment encounters a negative number, the while loop terminates.
If you want to discard the negative number  read the next number rather than terminate the loop, replace the break statement with the continue statement, as shown in the following example: = 0; cin >> ;.
It was stated earlier that all three loops have their place in Cplus_plus  that one loop can often replace another.
The execution of a continue statement, however, is where the while  do.
When the continue statement is executed in a while  a do.
In a for structure, the update statement always executes.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May  be copied, scanned,  duplicated, in whole  in part.
Due to electronic rights, some third party content may be suppressed from the eBook / eChapter(s).
Editorial review has deemed that any suppressed content does  materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Nested Control Structures In this section, we give examples that illustrate how to use nested loops to achieve useful results and process.
EXAMPLE 5-21 Suppose you want to create the following pattern: * ** *** **** ***** Clearly, you want to print five lines of stars.
In the first line, you want to print one star, in the second line, two stars, and so on.
Because five lines will be printed, start with the following for statement: The value of  in the first iteration is 1, in the second iteration it is 2, and so on.
You can use the value of  as the limiting condition in another for loop nested within this loop to control the number of stars in a line.
A little more thought produces the following code: {.
When is 1, the inner for loop in Line 3 outputs one star and the insertion point moves to the next line.
Then  becomes 2, the inner for loop outputs two stars, and the output statement in Line 5 moves the insertion point to the next line, and so on.
This process continues until  becomes 6 and the loop stops.
What pattern does this code produce if you replace the for statement in Line 1 with the following.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Nested Control Structures | 315 EXAMPLE 5-22 Suppose you want to create the following multiplication table: 1 2 3 4 2 4 6 8 3 6 9 12 4 8 12 16 5 10 15 20 5 10 15 20 25 6 12 18 24 30 7 14 21 28 35 8 16 24 32 40 9 18 27 36 45 10 20 30 40 50 The multiplication table has five lines.
Therefore, as in Example 5-21, we use a for statement to output these lines as follows: //output a line of numbers In the first line, we want to print the multiplication table of 1, in the second line we want to print the multiplication table of 2, and so on.
Notice that the first line starts with 1 and when this line is printed,  is 1.
Similarly, the second line starts with 2 and when this line is printed, the value of  is 2, and so on.
Therefore, to print a line of numbers, we can use the value of  as the starting number and 10 as the limiting value.
That is, consider the following for loop: << (3) <<  * ; Let us take a look at this for loop.
Then we are printing the first line of the multiplication table.
Also,  goes from 1 to 10 and so this for loop outputs the numbers 1 through 10, which is the first line of the multiplication table.
Similarly, if  is 2, we are printing the second line of the multiplication table.
Also,  goes from 1 to 10, and so this for loop outputs the second line of the multiplication table, and so on.
A little more thought produces the following nested loops to output the desired grid: {.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The number -999 at the end of each line acts as a sentinel and therefore is not part of the data.
Our objective is to find the sum of the numbers in each line and output the sum.
Moreover, assume that this data is to be read from a file, say, Exp_5_23_0_txt.
We assume that the input file has been opened using the input file stream variable infile.
This particular data set has five lines of input.
So we can use a for loop or a countercontrolled while loop to process each line of data.
Let us use a while loop to process these five lines.
It follows that the while loop takes the following form: = 0;.
Let us now concentrate on processing a line.
Each line has a varying number of data items.
For example, the first line has six numbers, the second line has eight numbers, and so on.
Because each line ends with -999, we can use a sentinel-controlled while loop to find the  of the numbers in each line with -999 as the sentinel value.
Consider the following while loop: = 0;.
The Boolean expression  _0_= -999 in Line 6 checks whether the number is -999.
If  is not -999, the statements in Lines 8 and 9 execute.
The statement in Line 8 updates the value of ; the statement in Line 9 reads and stores the next number into.
The loop continues to execute as long as  is not -999.
It now follows that the nested loop to process the data is as follows.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Nested Control Structures |.
EXAMPLE 5-24 Suppose that we want to process data similar to the data in Example 5-23, but the input file is of an unspecified length.
That is, each line contains the same data as the data in each line in Example 5-23, but we do not know the number of input lines.
Because we do not know the number of input lines, we must use an EOF-controlled while loop to process the data.
In this case, the required code is as follows.
EXAMPLE 5-25 Consider the following data: 101 John Smith 65 78 65 89 25 98 -999 102 Peter Gupta 87 34 89 99 26 78 64 34 -999 103 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Buddy Friend 23 99 98 97 26 78 100 63 87 23 -999 104 Doctor Miller 62 35 78 99 12 93 19 -999 _0__0_.
The number -999 at the end of a line acts as a sentinel and therefore is not part of the data.
Assume that this is the data of certain candidates seeking the student council's presidential seat.
For each candidate, the data is in the following form: ID Name Votes The objective is to find the total number of votes received by the candidate.
We assume that the data is input from the file Exp_5_25_0_txt of unknown size.
We also assume that the input file has been opened using the input file stream variable infile.
Because the input file is of an unspecified length, we use an EOF-controlled while loop.
For each candidate, the first data item is the ID of type int on a line by itself; the second data item is the name, which may consist of more than one word; and the third line contains the votes received from the various departments.
To read the ID, we use the extraction operator >>; to read the name, we use the stream function getline.
Notice that after reading the ID, the reading marker is after the ID and the character after the ID is the newline character.
Therefore, after reading the ID, the reading marker is after the ID and before the newline character (of the line containing the ID).
The function getline reads until the end of the line.
Therefore, if we read the name immediately after reading the ID, then what is stored in the variable name is the newline character (after the ID).
It follows that to read the name, we must read and discard the newline character after the ID, which we can accomplish using the stream function get.
Therefore, the statements to read the ID and name are as follows:.
Avoiding Bugs by Avoiding Patches |.
Avoiding Bugs by Avoiding Patches Debugging sections in the previous chapters illustrated how to debug syntax and logical errors, and how to avoid partially understood concepts.
In this section, we illustrate how to avoid a software patch to fix a code.
A software patch is a piece of code written on top of an existing piece of code intended to fix a bug in the original code.
Suppose that the following data is in the file Ch5_LoopWithBugsData_0_txt.
For each line, output the numbers together with their.
Let us consider the following program: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sample Run: 87 23 92 56 78 89 78 56 83 92 34 56 94 70 56 56 = = = = 342 274 260 224 The sample run shows that there is a bug in the program because the file contains three lines of input and the output contains four lines.
Also, the number 56 in the last line repeats four times.
Clearly, there is a bug in the program and we must fix the code.
Some programmers, especially some beginners, address the symptom of the problem by adding a software patch.
In this case, the output should contain only three lines of output.
A beginning programmer might fix the code by adding a software patch to manually cut off the unwanted fourth line, as shown in the following modified program: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Avoiding Bugs by Avoiding Patches |.
Sample Run: 87 78 83 94  = 342 23 89 92 70  = 274 92 78 34 56  = 260 Clearly, the program is working correctly now.
As we can see, the programmer merely observed the symptom and addressed the problem by adding a software patch.
However, if you look at the code, not only does the program execute extra statements, it is also an example of a partially understood concept.
It appears that the programmer does not have a good grasp of why the earlier program produced four lines rather than three.
Adding a patch eliminated the symptom, but it is a poor programming practice.
The programmer must resolve why the program produced four lines.
Looking at the program closely, we can see that the four lines are produced because the outer loop executes four times.
The values assigned to loop control variable  are 1, 2, 3, and 4.
This is an example Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
For example, we can rewrite the loops as follows: {.
The complete modified program is available at the Web site accompanying this book and is named Ch5_LoopWithBugsCorrectedProgram_0_cpp.
Debugging Loops As we have seen in the earlier debugging sections, no matter how careful a program is designed and coded, errors are likely to occur.
However, if there are logical errors, we must carefully look at the code or even maybe at the design and try to find the errors.
To increase the reliability of the program, errors must be discovered and fixed before the program is released to the users.
Once an algorithm is written, the next step is to verify that it works properly.
If the algorithm is a simple sequential flow or contains a branch, it can be hand traced or you can use the debugger, if any, provided by the IDE.
Typically, loops are harder to debug.
The correctness of a loop can be verified by using loop invariants.
A loop invariant is a set of statements that remains true each time the loop body is executed.
Let p be a loop invariant and q be the (logical) expression in a loop statement.
Then p && q remains true before each iteration of the loop and p && not(q) is true after the loop terminates.
The full discussion of loop invariants is beyond the scope of the book.
However, you can learn about loop invariants in the book: Discrete Mathematics: Theory and Applications (Revised Edition), D_0_S.
Sen, Cengage Learning Asia, Singapore, 2010.
Here, we give a few tips that you can use to debug a loop.
As discussed in the previous section, the most common error associated with loops is offby-one.
If a loop turns out to be an infinite loop, the error is most likely in the logical expression that controls the execution of the loop.
Check the logical expression carefully and see if you have reversed an inequality, an assignment statement symbol appears in place of the equality operator, or && appears in place of ||.
If the loop changes the values of variables, you can print the values of the variables before and/or after each iteration or you can use your IDE's debugger, if any, and watch the values of variables during each iteration.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Quick Review | 323 The debugging sections in this book are designed to help you understand the debugging process.
However, as you will realize, debugging can be a tiresome process.
If your program is very bad, do not debug.
Throw it away and start over.
QUICK REVIEW 1.
Cplus_plus has three looping (repetition) structures: while, for, and do.
The syntax of the while statement is: statement 3.
In Cplus_plus, while is a reserved word.
In the while statement, the parentheses around the expression (the decision maker) are important; they mark the beginning and end of the expression.
The statement is called the body of the loop.
The body of the while loop must contain a statement that eventually sets the expression to false.
A counter-controlled while loop uses a counter to control the loop.
In a counter-controlled while loop, you must initialize the counter before the loop, and the body of the loop must contain a statement that changes the value of the counter variable.
A sentinel is a special value that marks the end of the input data.
The sentinel must be similar to, yet differ from, all the data items.
A sentinel-controlled while loop uses a sentinel to control the loop.
The while loop continues to execute until the sentinel is read.
An EOF-controlled while loop uses an end-of-file marker to control the loop.
The while loop continues to execute until the program detects the end-of-file marker.
In the Windows console environment, the end-of-file marker is entered using Ctrl+z (hold the Ctrl key and press z).
In the UNIX environment, the end-of-file marker is entered using Ctrl+d (hold the Ctrl key and press d).
A for loop simplifies the writing of a counter-controlled while loop.
In Cplus_plus, for is a reserved word.
The syntax of the for loop is: statement statement is called the body of the for loop.
Putting a semicolon at the end of the for loop (before the body of the for loop) is a semantic error.
In this case, the action of the for loop is empty.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Both while and for loops are called pretest loops.
The while and for loop bodies may not execute at all, but the do.
Executing a break statement in the body of a loop immediately terminates the loop.
Executing a continue statement in the body of a loop skips the loop's remaining statements and proceeds with the next iteration.
When a continue statement executes in a while or do.
After a continue statement executes in a for loop, the update statement is the next statement executed.
EXERCISES The number in parentheses at the end of an exercise refers to the learning objective listed at the beginning of the chapter.
Mark the following statements as true or false.
A loop is a control structure that causes certain statements to execute In a counter-controlled while loop, it is not necessary to initialize the In an infinite while loop, the while expression (the decision maker) is The while loop: = 0;.
A sentinel-controlled while loop is an event-controlled while loop To read data from a file of an unspecified length, an EOF-controlled Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Suppose that the input is 3 4 6 7 2 -1.
What is the output of the following int int cin.
What is the output if the b.
What is the output if the c.
What is the output if the d.
What is the output if the Suppose that the input is: a.
The following program is designed to input two numbers and output their It asks the user if he/she would like to run the program.
If the answer is Y or y, it prompts the user to enter two numbers.
After adding the numbers and displaying the results, it again asks the user if he/she would like to add more.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
What type of loop, such as counter-control or sentinel-control, will you use a.
Update the employee' salary.
In this for loop, identify the loop control variable, the initialization statement, the loop condition, the update statement, and the statement that updates the value of.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter().
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
What is the final value of.
What is the output of the following Cplus_plus program segment.
Which of the following apply to the while loop only.
It is considered a conditional loop.
The body of the loop executes at least once.
The logical expression controlling the loop is evaluated before the loop is entered.
The body of the loop may not execute at all.
The following program contains errors that prevent it from compiling and/.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter().
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
What is the output of this loop.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
It is supposed to add all of the numbers except for the sentinel.
If the data looks like: 12 5.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
What What What What the the the the output output output output if if if if the the the the input input input input 13 16.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
To learn how nested for loops work, do a walk-through of the following a.
PROGRAMMING EXERCISES 1.
Write a program that prompts the user to input an integer and then outputs both the individual digits of the number and the sum of the digits.
For example, it should output the individual digits of 3456 as 3 4 5 6, output the individual digits of 8030 as 8 0 3 0, output the individual digits of 2345526 as 2 3 4 5 5 2 6, output the individual digits of 4000 as 4 0 0 0, and output the individual digits of -2345 as 2 3 4 5.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The value of p can be approximated by using the following series:   1 1 1 1 1  ¼ 4 1  þ  þ  þ þ : 3 5 7 2n  1 2n þ 1 The following program uses this series to find the approximate value of p.
However, the statements are in the incorrect order, and there is also a bug in this program.
Rearrange the statements and remove the bug so that this program can be used to approximate p.
The program Telephone Digits outputs only telephone digits that correspond to uppercase letters.
Rewrite the program so that it processes both uppercase and lowercase letters and outputs the corresponding telephone digit.
If the input is something other than an uppercase or lowercase letter, the program must output an appropriate error message.
To make telephone numbers easier to remember, some companies use letters to show their telephone number.
For example, using letters, the telephone number 438-5626 can be shown as GET LOAN.
In some cases, to make a telephone number meaningful, companies might use more than seven letters.
For example, 225-5466 can be displayed as CALL HOME, which uses eight Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Write a program that prompts the user to enter a telephone number expressed in letters and outputs the corresponding telephone number in digits.
If the user enters more than seven letters, then process only the first seven letters.
Also output the – (hyphen) after the third digit.
Allow the user to use both uppercase and lowercase letters as well as spaces between words.
Moreover, your program should process as many telephone numbers as the user wants.
Write a program that reads a set of integers and then finds and prints the sum of the even and odd integers.
Write a program that prompts the user to input a positive integer.
It should then output a message indicating whether the number is a prime number.
An odd integer is prime if it is not divisible by any odd integer less than or equal to the square root of the = akak-1ak-2.
It is known that  is divisible by 11 if and only if  is divisible by 11.
For example, suppose that  = 8784204.
Because 11 is divisible by 11, it follows that 8784204 is divisible by 11.
Because 2 is not divisible by 11, 54063297 is not divisible by 11.
Write a program that prompts the user to enter a positive integer and then uses this criterion to determine whether the number is divisible by 11.
Write a program that uses while loops to perform the following steps: a.
Output all odd numbers between firstNum and secondNum.
Output the sum of all even numbers between firstNum and secondNum.
Output the numbers and their squares between 1 and 10.
Output the sum of the square of the odd numbers between firstNum and secondNum.
Output all uppercase letters.
Redo Programming Exercise 8 using for loops.
Redo Programming Exercise 8 using do.
The program in the Programming Example: Fibonacci Number does not check whether the first number entered by the user is less than or equal to the second number and whether both the numbers are nonnegative.
Also, the program does not check whether the user entered a valid value for the position of the desired number in the Fibonacci sequence.
Rewrite that program so that it checks for these things.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The population of a town A is less than the population of town B.
However, the population of town A is growing faster than the population of town B.
Write a program that prompts the user to enter the population and growth rate of each town.
The program outputs after how many years the population of town A will be greater than or equal to the population of town B and the populations of both the towns at that time.
Define a0 ¼ x; an+1 ¼ an/2 if an is even; an+1 ¼ 3  an + 1 if an is odd.
Write a program that prompts the user to input the value of x.
The program output the integer k such that ak ¼ 1 and the numbers a0, a1, a2,.
Enhance your program from Programming Exercise 13 by outputting the position of the largest number and the largest number of the sequence a0, a1, a2,.
The program in Example 5-6 implements the Number Guessing Game.
However, in that program, the user is given as many tries as needed to guess the correct number.
Rewrite the program so that the user has no more than five tries to guess the correct number.
Your program should print an appropriate message, such as "You win_0_" or "You lose_0_".
Example 5-6 implements the Number Guessing Game program.
If the guessed number is not correct, the program outputs a message indicating whether the guess is low or high.
Modify the program as follows: Suppose that the variables num and guess are as declared in Example 5-6 and is an int variable.
If is 0, then guess is correct and the program outputs a message indicating that the user guessed the correct number.
If  is greater than or equal to 50, the program outputs the message indicating that the guess is very high (if guess is greater than num) or very low (if guess is less than num).
If  is greater than or equal to 30 and less than 50, the program outputs the message indicating that the guess is high (if guess is greater than num) or low (if guess is less than num).
If  is greater than or equal to 15 and less than 30, the program outputs the message indicating that the guess is moderately high (if guess is greater than num) or moderately low (if guess is less than num).
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
As in Programming Exercise 15, give the user no more than five tries to guess the number.
Write a program to implement the algorithm that you designed in Exercise 21 of Chapter 1.
Your program should allow the user to buy as many items as the user desires.
The program in Example 5-4 uses a sentinel control loop to process cookies sales data.
Assume that the data is provided in a file and the first line in the file specifies the cost of one box.
Modify the program so that it uses an EOF-controlled loop to process the data.
Enhance the program that you wrote in Exercise 18 by modifying it as follows: When the students started selling cookies, they were told that the students who sell the maximum number of boxes will have 10% of the money they generate donated to their favorite charitable organization.
So, in addition to the output your program generated in Exercise 18, your program should output the names of all the students selling the maximum number of boxes and the amount that will be donated to their charitable organization.
When you borrow money to buy a house, a car, or for some other purpose, you repay the loan by making periodic payments over a certain period of time.
Of course, the lending company will charge interest on the loan.
Every periodic payment consists of the interest on the loan and the payment toward the principal amount.
To be specific, suppose that you borrow $1000 at the interest rate of 7_0_2% per year and the payments are monthly.
Suppose that your monthly payment is $25.
Now, the interest is 7_0_2% per year and the payments are monthly, so the interest rate per month is 7_0_2/12 ¼ 0_0_6%.
The first month's interest on $1000 is 1000  0_0_006 ¼ 6.
Because the payment is $25 and interest for the first month is $6, the payment toward the principal amount is 25 – 6 ¼ 19.
This means after making the first payment, the loan amount is 1000 – 19 ¼ 981.
For the second payment, the interest is calculated on $981.
So the interest for the second month is 981  0_0_006 ¼ 5_0_886, that is, approximately $5_0_89.
This implies that the payment toward the principal is 25 – 5_0_89 ¼ 19_0_11 and the remaining balance after the second payment is 981 – 19_0_11 ¼ 961_0_89.
This process is repeated until the loan is paid.
Write a program that accepts as input the loan amount, the interest rate per year, and the monthly payment.
For example, if the interest rate is 7_0_2% per year, then enter 7_0_2_0_) The program then outputs the number of months it would take to repay the loan.
In this case, the program must warn the borrower that the monthly payment is too low, and with Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Enhance your program from Exercise 20 by first telling the user the minimum monthly payment and then prompting the user to enter the monthly payment.
Your last payment might be more than the remaining loan amount and interest on it.
In this case, output the loan amount before the last payment and the actual amount of the last payment.
Also, output the total interest paid.
Write a complete program to test the code in Example 5-21.
Write a complete program to test the code in Example 5-22.
Write a complete program to test the code in Example 5-23.
Write a complete program to test the code in Example 5-24.
Write a complete program to test the code in Example 5-25.
These cups are to be made from a circular waxed paper of 4 inches in radius by removing a sector of length x (see Figure 5-4).
By closing the remaining part of the circle, a conical cup is made.
Your objective is to remove the sector so that the cup is of maximum volume.
Conical paper cup Write a program that prompts the user to enter the radius of the circular waxed paper.
The program should then output the length of the removed sector so that the resulting cup is of maximum volume.
Calculate your answer to two decimal places.
When the rent is, say, $600 per month, all the units are occupied.
However, for each, say, $40 increase in rent, one unit becomes vacant.
Moreover, each occupied unit requires an average of $27 per month for maintenance.
How many units should be rented to maximize the profit.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The total number of units.
The rent to occupy all the units.
The increase in rent that results in a vacant unit.
Amount to maintain a rented unit.
The program then outputs the number of units to be rented to maximize the profit.
Let  be a nonnegative integer.
The factorial of , written _0_, is defined by 0_0_=1,.
Write a program that prompts the user to enter a nonnegative integer and outputs the factorial of the number.
Let  be an integer.
The value of the expression limn_0_1 ð1 þ 1Þ is written as.
This number  appears in many places in mathematics.
It also appears in problems relating to exponential growth and decay.
It is known that  is an irrational number.
The value of  to nine decimal places is  = 2_0_718281827.
Write a program that computes the value of the expression limn_0_1 ð1 þ 1Þ between certain values of  and then compare the values with.
Exercise 30 defines the number.
The value of  can be approximated using the following expression: 2 þ 2_0_1 þ 3_0_1 þ    þ _0_1 ' 32.
Write a program that uses this formula to approximate the value of.
Test your program for  = 4, 8, 10, and 12.
Exercise 30 defines the number  and Exercise 31 shows how to approximate the value of  using a different expression.
Interestingly, the value of can also be approximated using the following expression: 2+ 1 1+ 1 2+ 2 3+ 3 4+ 4 5 + 5.
Test your program for  = 3, 5, 10, 50, and 100.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Explore functions with default parameters Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The programs in Chapters 1 through 5 use only the function main; the programming instructions are packed into one function.
This technique, however, is good only for short programs.
You must learn to break the problem into manageable pieces.
This chapter first discusses the functions previously defined and then discusses user-defined functions.
Let us imagine an automobile factory.
When an automobile is manufactured, it is not made from basic raw materials; it is put together from previously manufactured parts.
Some parts are made by the company itself; others, by different companies.
Functions are like building blocks.
They let you divide complicated programs into manageable pieces.
While working on one function, you can focus on just that part of the program and construct it, debug it, and perfect it.
Different people can work on different functions simultaneously.
If a function is needed in more than one place in a program or in different programs, you can write it once and use it many times.
Using functions greatly enhances the program's readability because it reduces the complexity of the function main.
Functions are often called modules.
They are like miniature programs; you can put them together to form a larger program.
When user-defined functions are discussed, you will see that this is the case.
This ability is less apparent with predefined functions because their programming code is not available to us.
However, because predefined functions are already written for us, you will learn these first so that you can use them when needed.
Predefined Functions Before formally discussing predefined functions in Cplus_plus, let us review a concept from a college algebra course.
In algebra, a function can be considered a rule or correspondence between values, called the function's arguments, and the unique values of the function associated with the arguments.
Thus, if () = 2 + 5, then (1) = 7, (2) = 9, and (3) = 11, where 1, 2, and 3 are the arguments of , and 7, 9, and 11 are the corresponding values of the function.
In Cplus_plus, the concept of a function, either predefined or user-defined, is similar to that of a function in algebra.
For example, every function has a name and, depending on the values specified by the user, it does some computation.
This section discusses various predefined functions.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Predefined Functions |.
Because the value of (, ) is of type double, we say that the function  is of type double or that the function  returns a value of type double.
Moreover,  and are called the parameters (or arguments) of the function.
Function  has two parameters.
The square root function, sqrt(), calculates the nonnegative square root of  for >= 0_0_0.
The function sqrt is of type double and has only one parameter.
The floor function, floor(), calculates the largest whole number that is less than or equal to.
The function floor is of type double and has only one parameter.
In Cplus_plus, predefined functions are organized into separate libraries.
For example, the header file iostream contains I/O functions, and the header file cmath contains math functions.
Table 6-1 lists some of the more commonly used predefined functions, the name of the header file in which each function's specification can be found, the data type of the parameters, and the function type.
The function type is the data type of the value returned by the function.
For example, to use the function , the program must : # <cmath> Example 6-1 shows you how to use some of the predefined functions.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Predefined Functions |.
Chapter 6: User-Defined Functions Sample Run: In this sample run, the user input is shaded.
The statements in Lines 1 to 4  the header files that are necessary to use the functions used in the program.
The statements in Lines 8 to 10 declare the variables used in the program.
The statement in  11 sets the output decimal numbers in fixed decimal format with two decimal places.
The statement in 12 uses the function islower to determine and output whether  is  lowercase letter.
The statement in  13 uses the function toupper to output the uppercase letter that corresponds to '', which is A.
Note that the function toupper returns an int value.
Therefore, the value  the expression toupper('') is 65, which is the ASCII value 'A'.
To print the character A rather than the value 65, you need to apply the cast operator as shown in the statement in  13.
The statement in  14 uses the function to output 4_0_56_0_0.
In Cplus_plus terminology, it is said that the function  is called with the parameters 4_0_5 and 6_0_0.
The statements in Lines 15 to 17 prompt the user to enter two decimal numbers and store the numbers entered by the user in the variables and.
In the statement in  18, the function  is used to output firstNumsecondNum.
In this case, the function  is called with the parameters and  and the values   and  are passed to the function.
The other statements have similar meanings.
Once again, note that the program includes the header files cctype and cmath, because it uses the functions islower, toupper, , abs, and  from these header files.
User-Defined Functions As Example 6-1 illustrates, using functions in  program greatly enhances the program's readability because it reduces the complexity  the function main.
Also, once you write again and again without having to rewrite the same code repeatedly.
For instance, in Example 6-1, the function  is used more than once.
Because Cplus_plus does not provide every function that you will ever need and designers cannot possibly know  user's specific needs, you must learn to write your own functions.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Value-Returning Functions | 351 User-defined functions in Cplus_plus are classified into two categories:.
Value-returning functions—functions that have  return type.
These functions return  value   specific data type using the return statement, which we will explain shortly.
Note that the function main has used return statement to return the value 0 in every program we've seen so far.
Void functions—functions that do not have  return type.
These functions do not use  return statement to return  value.
We will first discuss value-returning functions.
Many  the concepts discussed in regard to value-returning functions also apply to void functions.
Value-Returning Functions The previous section introduced some predefined Cplus_plus functions such as , abs, islower, and toupper.
These are examples  value-returning functions.
To use these functions in your programs, you must know the name  the header file that contains the functions' specification.
You need to include this header file in your program using the include statement and know the following items: 1.
The name  the function The parameters, if any The data type  each parameter The data type  the value computed (that is, the value returned) by the function, called the type  the function Because a value-returning function returns only one value, the natural thing for you to do is to use the value in one  three ways:.
This suggests that a value-returning function is used:.
In an assignment statement.
In an output statement.
That is, a value-returning function is used (called) in an expression.
Before we look at the syntax  a user-defined, value-returning function, let us consider the things associated with such functions.
In addition to the four properties described previously, one more thing is associated with functions (both value-returning and void): 5.
The code required to accomplish the task The first four properties form, what is called, the heading  the function (also called the function header); the fifth property is called the body  the function.
Together, these Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 6: User-Defined Functions.
The variable declared in the heading  the function  is called a formal parameter the function.
Thus, the formal parameter   is.
The program in Example 6-1 contains several statements that use the function pow.
That is, in Cplus_plus terminology, the function pow is called several times.
Later in this chapter, we discuss what happens when a function is called.
Suppose that the heading  the function pow is:.
In Line 1, the function pow is called with the parameters  and.
In this case, the values and  are passed to the function pow.
In fact, the value   is copied into base, and the value   is copied into exponent.
The variables  and  that appear in the call to the function pow in Line 1 are called the actual parameters  that call.
In Line 2, the function pow is called with the parameters 2_0_0 and 3_0_2.
In this call, the value 2_0_0 is copied into base, and 3_0_2 is copied into exponent.
Moreover, in this call  the function pow, the actual parameters are 2_0_0 and 3_0_2, respectively.
Similarly, in Line 3, the actual parameters  the function pow are  and 7; the value   is copied into base, and 7_0_0 is copied into exponent.
We can now formally present two definitions: Formal Parameter: A variable declared in the function heading.
Actual Parameter: A variable or expression listed in a call to a function.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Value-Returning Functions | 353 For predefined functions, you only need to be concerned with the first four properties.
Software companies, typically, do not give out the actual source code, which is the body the function.
Syntax: Value-Returning Function The syntax  a value-returning function is:.
In this syntax, functionType is the type  the value that the function returns.
The functionType is also called the data type or the return type  the value-returning function.
Moreover, statements enclosed between curly braces form the body  the function.
Syntax: Formal Parameter List The syntax  the formal parameter list is: dataType identifier, dataType identifier, _0__0_.
Consider the definition  the function  given earlier in this chapter.
Figure 6-1 identifies various parts  this function.
Function return type Function name.
Formal parameter list.
Various parts  the function.
Chapter 6: User-Defined Functions Syntax: Actual Parameter List The syntax  the actual parameter list is: expression or variable, expression or variable, _0__0_.
A function's formal parameter list can be empty.
However, if the formal parameter list is empty, the parentheses are still needed.
The function heading  the value-returning function thus takes, if the formal parameter list is empty, the following form: If the formal parameter list  a value-returning function is empty, the actual parameter is also empty in a function call.
In this case (that is, an empty formal parameter list), in a function call, the empty parentheses are still needed.
Thus, a call to a value-returning function with an empty formal parameter list is: In a function call, the   actual parameters, together with their data types, must match with the formal parameters in the order given.
That is, actual and formal parameters have a one-to-one correspondence.
The expression can be part  either an assignment statement or an output statement, or a parameter in a function call.
A function call in a program causes the body  the called function to execute.
In other words, it passes this value outside the function via the return statement.
Syntax: return Statement The return statement has the following syntax: return expr; in which expr is a variable, constant value, or expression.
The expr is evaluated, and its value is returned.
The data type  the value that expr computes must match the function type.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Value-Returning Functions | 355 In Cplus_plus, return is a reserved word.
When a return statement executes in a function, the function immediately terminates and the control goes back to the calling function.
Moreover, the function call statement is replaced by the value returned by the return statement.
When a return statement executes in the function main, the program terminates.
To put the ideas in this discussion to work, let us write a function that determines the larger  two numbers.
Because the function compares two numbers, it follows that this function has two parameters and that both parameters are numbers.
Let us assume that the data type  these numbers is floating-point (decimal)—say, double.
Because the larger  is  type double, the function's data type is also double.
Let us name this function larger.
The only thing you need to complete this function is the body the function.
Thus, following the syntax  a function, you can write this function as follows:.
Figure 6-2 describes various parts of the function larger.
Function Function return type name Function heading Formal.
Various parts of the function larger Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Figure 6-3 shows various ways the function larger can be called.
Function call Actual parameters.
Function calls In Figure 6-3, in the first statement, the function larger determines the larger of 23_0_50 and 37_0_80, and the assignment statement stores the result in.
The meaning of the other two statements is similar.
You can also write the definition of the function larger as follows: {.
In the definition of the function larger,  and y are formal parameters.
Recall that once a return statement executes, all subsequent statements are skipped.
Thus, it's a good idea to return the value as soon as it is computed.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The expression larger(1, 2) in Line 2  a function call.
The expression larger(1, 29) in Line 3  also a function call.
When the expression larger(1, 29) executes, the value of 1  copied into , and 29  copied into y.
Therefore, the statement in Line 3 outputs the larger of 1 and 29.
Note that the first parameter, 1, a variable, while the second parameter, 29,  a constant value.
The expression larger(38_0_45, 56_0_78) in Line 4  a function call.
In this call, the actual parameters are 38_0_45 and 56_0_78.
In this statement, the value returned by the function larger  assigned to the variable.
In a function call, you specify only the actual parameter, not its data type.
For example, in Example 6-2, the statements in Lines 1, 2, 3, and 4 show how to call the function larger with the actual parameters.
However, the following statements contain incorrect calls to the function.
Chapter 6: User-Defined Functions Once a function  written, you can use it anywhere in the program.
The function larger compares two numbers and returns the larger of the two.
Let us now write another function that uses this function to determine the largest of three numbers.
We call this function compareThree.
This expression has two calls to the function larger.
The actual parameters to the outer call are  and larger(, z); the actual parameters to the inner call are  and z.
It follows that, first, the expression larger(, z)  evaluated; that , the inner call executes first, which gives the larger of Next, the outer call determines the larger of  and t.
Finally, the return statement returns the largest number.
It thus follows that to execute a function call, the parameters must be evaluated first.
For example, the actual parameter larger(, z) of the outer call  evaluated first to render a resulting value that  sent with  to the outer call to larger.
Note that the function larger  much more general purpose than the function compareThree.
Here, we are merely illustrating that once you have written a function, you can use it to write other functions.
Later in this chapter, we will show how to use the function larger to determine the largest number from a set of numbers.
Function Prototype Now that you have some idea of how to write and use functions in a program, the next question relates to the order in which user-defined functions should appear in a program.
For example, do you place the function larger before or after the function main.
Should larger be placed before compareThree or after it.
Following the rule that you must declare an identifier before you can use it and knowing that the function main uses the identifier larger, logically you must place larger before main.
In reality, Cplus_plus programmers customarily place the function main before all other userdefined functions.
However, this organization could produce a compilation error because functions are compiled in the order in which they appear in the program.
For example, if the function main  placed before the function larger, the identifier larger will be undefined when the function main  compiled.
To work around this problem of undeclared identifiers, we place function prototypes before any function definition (including the definition of main).
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Value-Returning Functions | 359 The function prototype  not a definition.
It gives the program the name of the function, the number and data types of the parameters, and the data type of the returned value: just enough information to let Cplus_plus use the function.
It  also a promise that the full definition will appear later in the program.
If you neglect to write the definition of the function, the program may compile, but it will not execute.
Function Prototype: The function heading, terminated by a semicolon, ;, without the body of the function.
The general syntax of the function prototype of a value-returning function :.
FINAL PROGRAM You now know enough to write the entire program, compile it, and run it.
The following program uses the functions larger, compareThree, and main to determine the larger/ largest of two or three numbers.
Sample Run: In this sample run, the user input  shaded.
Line 2: The  of 5 and 10  10 Line 3: Enter  numbers: 25_0_6 73_0_85 Line 6: The  of 25_0_6 and 73_0_85  73_0_85 Line 7: The largest of 43_0_48, 34_0_00, and 12_0_65 is 43_0_48 In the previous program, the function prototypes of the functions  and compareThree appear before their function definitions.
Therefore, the definition of the functions  and compareThree can appear in any order.
Value-Returning Functions: Some Peculiarities A value-returning function must return a value.
Consider the following function, secret, that takes as a parameter an int value.
If the value of the parameter, , is greater than 5, it returns twice the value of.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Because this is a value-returning function of type int, it must return a value of type int.
Suppose the value of  is 10.
Then the expression  > 5 in Line 1 evaluates to true.
So the return statement in Line 2 returns the value 20.
Now suppose that  is 3.
The expression  > 5 in Line 1 now evaluates to false.
The if statement therefore fails, and the return statement in Line 2 does not execute.
However, there are no more statements to be executed in the body of the function.
In this case, the function returns a strange value.
It thus follows that if the value of  is less than or equal to 5, the function does not contain any valid return statements to return a value of type int.
A correct definition of the function secret is:.
Here, if the value of  is less than or equal to 5, the return statement in Line 3 executes, which returns the value of.
On the other hand, if the value of  is, say 10, the return statement in Line 2 executes, which returns the value 20 and also terminates the function.
Recall that in a value-returning function, the return statement returns the value.
Consider the following return statement: return , y; //only the value of y will be returned This is a legal return statement.
You might think that this return statement is returning the values of  and y.
Remember, a return statement returns only one value, even if the return statement contains more than one expression.
If a return statement contains more than one expression, only the value of the last expression is returned.
Therefore, in the case of the above return statement, the value of y is returned.
The following program further illustrates this concept:.
This program illustrates that a value-returning function returns only one value, even if the return statement contains more than one expression.
This is a legal, but not a recommended code.
Line 1: The value returned by 1: 45 Line 2: The value returned by 2: 7 Even though  return statement can contain more than one expression,  return statement in your program should contain only one expression.
Having more than one expression in  return statement may result in redundancy, wasted code, and  confusing syntax.
More Examples of Value-Returning Functions EXAMPLE 6-3 In this example, we write the definition of the function courseGrade.
This function takes as  parameter an int value specifying the score for  course and returns the grade,  value of type char, for the course.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
In this example, we write  function that rolls  pair of dice until the sum of the numbers rolled is  specific number.
We also want to know the number of times the dice are rolled to get the desired sum.
The smallest number on each die is 1, and the largest number is 6.
So the smallest sum of the numbers rolled is 2, and the largest sum of the numbers rolled is 12.
Suppose that we have the following declarations: int int int int.
We use the random number generator, discussed in Chapter 5, to randomly generate number between 1 and 6.
Then, the following statement randomly generates  number between 1 and 6 and stores that number into 1, which becomes the number rolled by 1.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Chapter 6: User-Defined Functions.
Next, we determine whether  contains the desired  of the numbers rolled by the dice.
This can be accomplished by the following do_0__0__0_while loop.
The number of times the dice are rolled to get the  10 = 11 The number of times the dice are rolled to get the  6 = 7 We leave it as an exercise for you to modify this program so that it allows the user to enter the Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 6: User-Defined Functions In the first programming example in Chapter 5, we designed and implemented an algorithm to find the number of  Fibonacci sequence.
In this example, we modify the main program by writing  function that computes and returns the desired number of Fobinacci sequence.
Because we have already designed and discussed how to determine specific number of  Fibonacci sequence, next, we give the definition of the function to implement the algorithm.
Given the first number, the second number, and the position of the desired Fibonacci number, the following function returns the Fibonacci number:.
Chapter 6: User-Defined Functions Sample Runs: In these sample runs, the user input is shaded.
Sample Run 1: Enter the  two Fibonacci numbers: 12 16 The  two Fibonacci numbers are 12 and 16 Enter the position of the desired Fibonacci number: 10 The Fibonacci number at position 10 is 796 Sample Run 2: Enter the  two Fibonacci numbers: 1 1 The  two Fibonacci numbers are 1 and 1 Enter the position of the desired Fibonacci number: 15 The Fibonacci number at position 15 is 610 The following is an example of a function that returns a Boolean value.
In this example, a function, isPalindrome, is designed that returns true if a string is a palindrome and false otherwise.
A string is a palindrome if it reads forward and backward in the same way.
For example, the strings "madamimadam", "5", "434", and "789656987" are all palindromes.
Suppose str is a string.
To determine whether str is a palindrome,  compare the and the last characters of str.
If they are not the same, str is not a palindrome and so the function should return false.
If the  and the last characters of str are the same, then we compare the  character with the  character from the end, and so on.
Note that if  = str_0_(), the number of characters in str, then we need to compare str[0] with str[ - 1], str[1] with str[ - 2], and in general str[] with str[ - 1 - ], 0 <=  <=  / 2.
The following algorithm implements this discussion: 1.
Chapter 4 contains a program to calculate the bill for a cable company.
In that program, all of the programming instructions are packed in the function main.
Here, we rewrite the same program using user-defined functions, further illustrating structured programming.
Because there are two types of customers, residential and business, the program contains two separate functions: one to calculate the bill for residential customers and one to calculate the bill for business customers.
Both functions calculate the billing amount and then return the billing amount to the function main.
The function main prints the amount due.
Let us call the function that calculates the residential bill residential and the function that calculates the business bill business.
The formulas to calculate the bills are the same as before.
Function residential: To compute the residential bill, you need to know the number of premium channels to which the customer subscribes.
Based on the number of premium channels, you can calculate the billing amount.
After calculating the billing amount, the function returns the billing amount using the return statement.
The following four steps describe this function: a.
Prompt the user for the number of premium channels.
Read the number of premium channels.
Calculate the amount due.
Return the amount due.
This function contains a statement to prompt the user to enter the number of premium channels (Step a) and a statement to read the number of premium channels (Step b).
Other items needed to calculate the billing amount, such as the cost of basic service connection and bill processing fees, are defined as named constants (before the definition of the function main).
Therefore, to calculate the billing amount, this function does not need to get any value from the function main.
This function, therefore, has no parameters.
From the previous discussion, it follows that the function residential requires local variables to store both the number of premium channels and the billing amount.
This function needs only these two local variables to calculate the billing amount: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Function business: To compute the business bill, you need to know the number of both the basic service connections and the premium channels to which the customer subscribes.
Then, based on these numbers, you can calculate the billing amount.
The billing amount is then returned using the return statement.
The following six steps describe this function: a.
Prompt the user for the number of basic service connections.
Read the number of basic service connections.
Prompt the user for the number of premium channels.
Read the number of premium channels.
Calculate the amount due.
Return the amount due.
This function contains the statements to prompt the user to enter the number of basic service connections and premium channels (Steps a and c).
The function also contains statements to input the number of basic service connections and premium channels (Steps b and d).
Other items needed to calculate the billing amount, such as the cost of basic service connections and bill processing fees, are defined as named constants (before the definition of the function main).
It follows that to calculate the billing amount this function does not need to get any values from the function main.
From the preceding discussion, it follows that the function business requires variables to store the number of basic service connections and the number of premium channels, as well as the billing amount.
In fact, this function needs only these three local variables to calculate the billing amount:.
The algorithm for the main program is as follows: 1.
To output floating-point numbers in a fixed decimal format with the decimal point and trailing zeros, set the manipulators fixed and showpoint.
To output floating-point numbers to two decimal places, set the precision to two decimal places.
Prompt the user for the account number.
Get the account number.
Prompt the user to enter the customer type.
Get the customer type.
If the customer type is R or r, Call the function residential to calculate the bill.
Print the bill.
If the customer type is B or b, Call the function business to calculate the bill.
Print the bill.
If the customer type is other than R, r, B, or b, it is an invalid customer type.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Value-Returning Functions | { case 'r': case 'R': = residential();.
Sample Run: In this sample run, the user input is shaded.
This program computes a cable bill.
Enter account : 21341 Enter customer type: R, r (Residential), B, b (Business): B Enter the  of basic service connections: 25 Enter the  of premium channels used: 9 = 21341 = $615_0_00 Flow of Compilation and Execution As stated earlier, a Cplus_plus program is a collection of functions.
Recall that functions can appear in any order.
The only thing that you have to remember is that you must declare an identifier before you can use it.
The program is compiled by the compiler sequentially from beginning to end.
Thus, if the function main appears before any other user-defined functions, it is compiled first.
However, if main appears at the end (or middle) of the program, all functions whose definitions (not prototypes) appear before the function main are compiled before the function main, in the order they are placed.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The compiler can then correctly translate a function call.
However, when the program executes, the first statement in the function main always executes first, regardless of where in the program the function main is placed.
Other functions execute only when they are called.
A function call transfers control to the first statement in the body of the function.
In general, after the last statement of the called function executes, control is passed back to the point immediately following the function call.
A value-returning function returns a value.
Therefore, after executing the value-returning function, when the control goes back to the caller, the value that the function returns replaces the function call statement.
The execution continues at the point immediately following the function call.
Suppose that a program contains functions funcA and funcB, and funcA contains a statement that calls funcB.
Suppose that the program calls funcA.
When the statement that contains a call to funcB executes, funcB executes, and while funcB is executing, the execution of the current call of funcA is on hold until funcB is done.
PROGRAMMING EXAMPLE: Largest Number In this programming example, the function larger is used to determine the largest from a set of numbers.
For the purpose of illustration, this program determines the largest  from a set of 10 numbers.
You can easily enhance this program to accommodate any set of numbers.
PROBLEM ANALYSIS AND ALGORITHM DESIGN Input.
The largest of 10 numbers.
Suppose that the input data is: 10 56 73 42 22 67 88 26 62 11 Read the first  of the data set.
Because this is the only  read to this point, you may assume that it is the largest  so far and call it max.
Read the second  and call it num.
Now compare max and num and store the larger  into max.
Now max contains the larger of the first two numbers.
Read the third.
Compare it with max and store the larger into max.
At this point, max contains the largest of the first three numbers.
Read the next , compare it with max, and store the larger into max.
Repeat this process for each remaining  in the data set.
Eventually, max will contain the largest  in the data set.
This discussion translates into the following algorithm: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: Largest Number.
Read the first.
Because this is the only  that you have read so far, it is the largest  so far.
Save it in a variable called.
For each remaining  in the list: a.
Read the next.
Store it in a variable called num.
Compare num and.
Because  now contains the largest , print it.
To find the larger of two numbers, the program uses the function larger.
COMPLETE PROGRAM LISTING //********************************************************.
Sample Run: In this sample run, the user input is shaded.
In this section, you will explore user-defined functions in general and, in particular, those Cplus_plus functions that do not have a data type, called void functions.
Void functions and value-returning functions have similar structures.
Both have a heading and a body.
Like value-returning functions, you can place user-defined void functions either before or after the function main.
However, the program execution always begins with the first statement in the function main.
A void function does not have a data type.
Therefore, functionType—that is, the return type—in the heading part and the return statement in the body of the void functions are meaningless.
However, in a void function, you can use the return statement without any value; it is typically used to exit the function early.
Like value-returning functions, void functions may or may not have formal parameters.
Because void functions do not have a data type, they are not used (called) in an expression.
A call to a void function is a stand-alone statement.
Thus, to call a void function, you use the function name together with the actual parameters (if any) in a stand-alone statement.
Before giving examples of void functions, next we give the syntax of a void function.
FUNCTION DEFINITION The function definition of void functions with parameters has the following syntax:.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Void Functions | 377 in which statements are usually declaration and/or executable statements.
The formal parameter list may be empty, in which case, in the function heading, the empty parentheses are still needed.
FORMAL PARAMETER LIST The formal parameter list has the following syntax: dataType& variable, dataType& variable, _0__0_.
You must specify both the data type and the variable name in the formal parameter list.
The symbol & after dataType has a special meaning; some parameters will have & and some will not, and we will explain why later in this chapter.
FUNCTION CALL The function call has the following syntax: functionName(actual parameter list); ACTUAL PARAMETER LIST The actual parameter list has the following syntax: expression or variable, expression or variable, _0__0_.
As with value-returning functions, in a function call, the number of actual parameters together with their data types must match the formal parameters in the order given.
Actual and formal parameters have a one-to-one correspondence.
Example 6-8 shows a void function with parameters.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 6: User-Defined Functions PARAMETER TYPES and the called function.
They enable functions to manipulate different data each time they are called.
In general, there are two types of formal parameters: value parameters and reference parameters.
Value parameter: A formal parameter that receives a copy of the content of the corresponding actual parameter.
Reference parameter: A formal parameter that receives the location (memory address) of the corresponding actual parameter.
When you attach & after the dataType in the formal parameter list of a function, the variable following that dataType becomes a reference parameter.
Example 6-9 shows a void function with value and reference parameters.
EXAMPLE 6-9 Consider the following function definition: void areaAndPerimeter(double length, double width,.
The function areaAndPerimeter has four parameters: length and width are value parameters of type double; and  and  are reference parameters of type double.
Figure 6-4 describes various parts of the function areaAndPerimeter.
Function name Value parameters Function heading void areaAndPerimeter(double length, double width, { = length * width;.
Various parts of the function areaAndPerimeter Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Void Functions | 379 EXAMPLE 6-10 Consider the following definition: void averageAndGrade(int testScore, int progScore, { = (testScore + progScore) / 2_0_0;.
The function averageAndGrade has four parameters: testScore and progScore are value parameters of type int,  is a reference parameter of type double, and is a reference parameter of type char.
Using visual diagrams, Examples 6-13, 6-14, and 6-15 explicitly show how value and reference parameters work.
EXAMPLE 6-11 We write a program to print a pattern (a triangle of stars) similar to the following: * * * * * * * * * * The first line has one star with some blanks before the star, the second line has two stars, some blanks before the stars, and a blank between the stars, and so on.
Let's write the function printStars that has two parameters, a parameter to specify the number of blanks before the stars in a line and a second parameter to specify the number of stars in a line.
To be specific, the definition of the function printStars is: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
If the value of the parameter blanks is 30, for instance, then the first for loop in the function printStars executes 30 times and prints 30 blanks.
Also, because you want to print a space between the stars, every iteration of the second for loop in the function printStars prints the string " *"—a blank followed by a star.
Next, consider the following statements: int  = 15;.
The for loop calls the function printStars.
Every iteration of this for loop specifies the number of blanks followed by the number of stars to print in a line, using the variables  and.
Every invocation of the function printStars receives one fewer blank and one more star than the previous call.
For example, the first iteration of the for loop in the function main specifies 30 blanks and 1 star (which are passed as the parameters  and  to the function printStars).
The for loop then decrements the number of blanks by 1 by executing the statement, numberOfBlanksminus_minus;.
At the end of the for loop, the number of stars is incremented by 1 for the next iteration.
This is done by executing the update statement counterplus_plus in the for statement, which increments the value of the variable  by 1.
In other words, the second call of the function printStars receives 29 blanks and 2 stars as parameters.
Thus, the previous statements will print a triangle of stars consisting of 15 lines.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Void Functions |.
Chapter 6: User-Defined Functions Sample Run: In this sample run, the user input is shaded.
Enter the number of star lines (1 to 20) to be printed: 15 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * In the function main, the user is first asked to specify how many lines of stars to print (Line 1).
Value Parameters The previous section defined two types of parameters—value parameters  reference parameters.
Example 6-10 showed a program that uses a function with parameters.
Before considering more examples of void functions with parameters, let us make the following observation about value  reference parameters.
When a function is called, the value of the actual parameter is copied into the corresponding formal parameter.
If the formal parameter is a value parameter, then after copying the value of the actual parameter, there is no connection between the formal parameter  actual parameter; that is, the formal parameter is a separate variable with its own copy of the data.
Therefore, during program execution, the formal parameter manipulates the data stored in its own memory space.
The program in Example 6-12 further illustrates how a value parameter works.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook /or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sample Run: Line Line Line Line 2: 5: 7: 4: Before calling the function funcValueParam,  = 6 In the function funcValueParam, before changing,  = 6 In the function funcValueParam, after changing,  = 15 After calling the function funcValueParam,  = 6 This program works as follows.
The execution begins at the function main.
The statement in Line 1 declares  initializes the int variable.
The statement in Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook /or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The value of the variable is then passed to the formal parameter.
Control now transfers to the function funcValueParam.
The statement in Line 5 outputs the value of  before changing its value.
The statement in Line 6 changes the value of  to 15; the statement in Line 7 outputs the value of.
After this statement executes, the function funcValueParam exits control goes back to the function main.
The statement in Line 4 outputs the value of  after calling the function remains the same even though the value of its corresponding formal parameter  was changed within the function funcValueParam.
The output shows the sequence in which the statements execute.
After copying data, a value parameter has no connection with the actual parameter, so a value parameter cannot pass any result back to the calling function.
When the function executes, any changes made to the formal parameters do not in any way affect the actual parameters.
The actual parameters have no knowledge of what is happening to the formal parameters.
Thus, value parameters cannot pass information outside of the function.
Value parameters provide only a one-way link from the actual parameters to the formal parameters.
Hence, functions with only value parameters have limitations.
Reference Variables as Parameters The program in Example 6-12 illustrates how a value parameter works.
On the other hand, suppose that a formal parameter is a reference parameter.
Because a reference parameter receives the address (memory location) of the actual parameter, reference parameters can pass one or more values from a function and can change the value of the actual parameter.
Reference parameters are useful in three situations:.
When the value of the actual parameter needs to be changed When you want to return more than one value from a function (recall.
When passing the address would save memory space and time relative to copying a large amount of data The first two situations are illustrated throughout this book.
Chapters 8 and 10 discuss the third situation, when arrays and classes are introduced.
Recall that when you attach & after the dataType in the formal parameter list of a function, the variable following that dataType becomes a reference parameter.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Reference Variables as Parameters.
This will prevent the formal parameter from being able to change the value of the corresponding actual parameter.
Chapters 9 and 10 discuss constant reference parameters.
Until then, the reference parameters that you use will be nonconstant as defined in this chapter.
From the definition of a reference parameter, it follows that a constant value or an expression cannot be passed to a nonconstant reference parameter.
If a formal parameter is a nonconstant reference parameter, during a function call, its corresponding actual parameter must be a variable.
EXAMPLE 6-13 Calculate Grade The following program takes a course score (a value between 0 and 100) and determines a student's course grade.
This program has three functions: main, getScore, and printGrade, as follows: 1.
Get the course score.
Print the course grade.
Prompt the user for the input.
Print the course score.
Calculate the course grade.
Print the course grade.
The complete program is as follows: //This program reads a course score and prints the.
Chapter 6: User-Defined Functions.
Sample Run: In this sample run, the user input is shaded.
Line 1: Based on the course , this program computes the course.
Line 4: Enter course : 85 Line 6: Course  is 85 Line 7: Your  for the course is.
This program works as follows.
The program starts to execute at Line 1, which prints the first line of the output (see the sample run).
The statement in Line 2 calls the function getScore with the actual parameter courseScore (a variable declared in main).
Because the formal parameter  of the function getScore is a reference parameter, the address (that is, the memory location of the variable courseScore) passes to.
Thus, both  and courseScore now refer to the same memory location, which is courseScore (see Figure 6-5).
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Reference Variables as Parameters.
Variable courseScore and the parameter Any changes made to  immediately change the value of courseScore.
Control is then transferred to the function getScore, and the statement in Line 4 executes, printing the second line of output.
This statement prompts the user to enter the course.
The statement in Line 5 reads and stores the value entered by the user (85 in the sample run) in , which is actually courseScore (because is a reference parameter).
Thus, at this point, the value of both variables and courseScore is 85 (see Figure 6-6).
After Line 6 executes, control goes back to the function main (see Figure 6-7).
It is a function call to the function printGrade with the actual parameter courseScore.
Because the formal parameter  of the function printGrade is a value parameter, the parameter  receives the value of the corresponding actual parameter courseScore.
After copying the value of courseScore into , no communication exists between  and courseScore (see Figure 6-8).
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 6: User-Defined Functions main courseScore FIGURE 6-8 printGrade 85 85.
Variable courseScore and the parameter The program then executes the statement in Line 7, which outputs the fourth line.
Because the output statement in Line 7 does not contain the newline character or the manipulator endl, the output of the if.
Because the next statement to execute in the function main is the last statement of the function main, the program terminates.
In this program, the function main first calls the function getScore to obtain the course  from the user.
The function main then calls the function printGrade to calculate and print the  based on this course.
The course  is retrieved by the function getScore; later, this course  is used by the function printGrade.
Because the value retrieved by the getScore function is used later in the program, the function getScore must pass this value outside.
Because getScore is written as a void function, the formal parameter that holds this value must be a reference parameter.
Value and Reference Parameters and Memory Allocation When a function is called, memory for its formal parameters and variables declared in the body of the function (called local variables) is allocated in the function data area.
Recall that in the case of a value parameter, the value of the actual parameter is copied into the memory cell of its corresponding formal parameter.
In the case of a reference parameter, the address of the actual parameter passes to the formal parameter.
That is, the content of the formal parameter is an address.
During data manipulation, the address stored in the formal parameter directs the computer to manipulate the data of the memory cell at that address.
Thus, in the case of a reference parameter, both the actual and formal parameters refer to the same memory location.
Consequently, during program execution, changes made by the formal parameter permanently change the value of the actual parameter.
Stream variables (for example, ifstream and ofstream) should be passed by reference to a function.
After opening the input/output file or after reading and/or outputting data, the state of the input and/or output stream can then be passed outside the function.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Value and Reference Parameters and Memory Allocation.
Each covers a different scenario.
EXAMPLE 6-14 The following program shows how reference and value parameters work.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sample Run: Line Line Line Line Line 4: Inside main: 1 = 10, 2 = 15, and  = A 13: Inside funOne:  = 11,  = 30,  = B, and  = 10 6: After funOne: 1 = 10, 2 = 30, and  = A 17: Inside funTwo:  = 31,  = 50, and  = G 8: After funTwo: 1 = 10, 2 = 31, and  = G Let us walk through this program.
The values of the variables are shown before and/or after each statement executes.
Just before the statement in Line 1 executes, memory is allocated only for the variables of the function main; this memory is not initialized.
After the statement in Line 3 executes, the variables are as shown in Figure 6-9.
Values of the variables after the statement in Line 3 executes The statement in Line 4 produces the following output: Line 4: Inside main: 1 = 10, 2 = 15, and  = A The statement in Line 5 is  function call to the function funOne.
Now function funOne has three parameters (, , and ) and  local variable ().
Memory for the parameters and the local variable of function funOne is allocated.
Because the formal parameter  is  reference parameter, it receives the address (memory location) of the corresponding actual parameter, which is 2.
The other two formal parameters are value parameters, so they copy the values of their corresponding actual parameters.
Just before the statement in Line 9 executes, the variables are as shown in Figure 6-10.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Value and Reference Parameters and Memory Allocation.
A FIGURE 6-10 Values of the variables just before the statement in Line 9 executes The following shows how the variables are manipulated after each statement from Line 9 to 12 executes.
Because  is the reference parameter and contains the address of , the value of  is updated.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 6: User-Defined Functions The statement in Line 13 produces the following output: Line 13: Inside funOne:  = 11,  = 30,  = B, and  = 10 After the statement in Line 13 executes, control goes back to Line 6 in main and the memory allocated for the variables of function funOne is deallocated.
Figure 6-11 shows the values of the variables of the function main.
Values of the variables after the statement in Line 6 Line 6 produces the following output: Line 6: After funOne: 1 = 10, 2 = 30, and  = A The statement in Line 7 is  function call to the function funTwo.
Now funTwo has three parameters: x, y, and w.
Also, x and w are reference parameters, and y is  value parameter.
Thus, x receives the address of its corresponding actual parameter, which is 2, and w receives the address of its corresponding actual parameter, which is.
The variable y copies the value 25 into its memory cell.
Figure 6-12 shows the values before the statement in Line 14 executes.
Values of the variables before the statement in Line 14 executes The following shows how the variables are manipulated after each statement from Line 14 to 16 executes.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Value and Reference Parameters and Memory Allocation St.
Because x is the reference parameter and contains the address of 2, the value of 2 is incremented by 1.
Because is the reference parameter and contains the address of , the value of  is updated.
Line 17 produces the following output: Line 17: Inside funTwo:  = 31,  = 50, and  = G After the statement in Line 17 executes, control goes to Line 8.
The memory allocated for the variables of function funTwo is deallocated.
The values of the variables of the function main are as shown in Figure 6-13.
Values of the variables after the statement in Line 8 The statement in Line 8 produces the following output: Line 8: After funTwo: 1 = 10, 2 = 31, and  = G After the statement in Line 8 executes, the program terminates.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 6: User-Defined Functions.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Sample Run: Line Line Line Line Line Line Line Line Line Line Line Line Line 1: Inside main:  = 5 8: Inside addFirst:  = 5,  = 5 10: Inside addFirst:  = 7,  = 7 12: Inside addFirst:  = 14,  = 14 3: Inside main after addFirst:  = 14 13: Inside doubleFirst:  = 14,  = 14 15: Inside doubleFirst:  = 28,  = 14 17: Inside doubleFirst:  = 28,  = 16 5: Inside main after doubleFirst:  = 14 18: Inside squareFirst:  = 14,  = 14 20: Inside squareFirst:  = 196,  = 14 22: Inside squareFirst:  = 196,  = 16 7: Inside main after squareFirst:  = 196 Both parameters of the function addFirst are reference parameters, and both parameters of the function doubleFirst are value parameters.
The statement: addFirst(, ); Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Chapter 6: User-Defined Functions in the function main (Line 2) passes the reference of  to both formal parameters and  of the function addFirst, because the corresponding actual parameters for both formal parameters are the same.
That is, the variables  and  refer to the same memory location, which is.
Figure 6-14 illustrates this situation.
Parameters of the function addFirst Any changes that  makes to its value immediately change the value of  and Similarly, any changes that  makes to its value immediately change and , because all three variables refer to the same memory location.
So the statement: doubleFirst(, ); in the function main (Line 4) copies the value of  into  and  because the corresponding actual parameters for both formal parameters are the same.
Figure 6-15 illustrates this scenario.
Parameters of the function doubleFirst Because both  and  are value parameters, any changes that  makes to its value do not affect the values of  and.
Similarly, any changes that  makes to its value do not affect  and.
The variable  receives the address of its corresponding actual parameter, which is , and the variable  copies the value of its Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Scope of an Identifier | 397 corresponding actual parameter, which is also.
Thus, both  and  refer to the same memory location, which is.
Figure 6-16 illustrates this situation.
Parameters of the function squareFirst Any changes that  makes immediately change.
Any changes made by  do not We recommend that you walk through the program in Example 6-15.
The output shows the order in which the statements execute.
Reference Parameters and Value-Returning Functions Earlier in this chapter, in the discussion of value-returning functions, you learned how to use value parameters only.
You can also use reference parameters in a value-returning function, although this approach is not recommended.
By definition, a value-returning function returns a single value; this value is returned via the return statement.
If a function needs to return more than  value, as a rule of good programming style, you should change it to a void function and use the appropriate reference parameters to return the values.
Scope of an Identifier The previous sections presented several examples of programs with user-defined functions.
Identifiers are declared in a function heading, within a block, or outside a block.
A question naturally arises: Are you allowed to access any identifier anywhere in the program.
You must follow certain rules to access an identifier.
The scope of an identifier refers to where in the program an identifier is accessible (visible).
Recall that an identifier is the name of something in Cplus_plus, such as a variable or function name.
This section examines the scope of an identifier.
First, we define the following  terms: Local identifier: Identifiers declared within a function (or block).
Local identifiers are not accessible outside of the function (block).
Global identifier: Identifiers declared outside of every function definition.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 6: User-Defined Functions Also, Cplus_plus does not allow the nesting of functions.
That is, you cannot include the definition of one function in the body of another function.
In general, the following rules apply when an identifier is accessed: 1.
Global identifiers (such as variables) are accessible by a function or a block if: a.
The identifier is declared before the function definition (block), b.
The function name is different than the identifier, c.
All parameters of the function have names different than the name of the identifier, and d.
All local identifiers (such as local variables) have names different than the name of the identifier.
Only within the block from the point at which it is declared until the end of the block, and b.
By those blocks that are nested within that block if the nested block does not have an identifier with the same name as that of the outside block (the block that encloses the nested block).
The scope of a function name is similar to the scope of an identifier declared outside any block.
That is, the scope of a function name is the same as the scope of a global variable.
Before considering an example to explain these scope rules, first note the scope of the identifier declared in the for statement.
Cplus_plus allows the programmer to declare a variable in the initialization statement of the for statement.
For example, the following for statement: <<  << endl; declares the variable  and initializes it to 1.
The scope of the variable  is limited to only the body of the for loop.
This scope rule for the variable declared in a for statement may not apply to Standard Cplus_plus, that is, non ANSI/ISO Standard Cplus_plus.
In Standard Cplus_plus, the scope of the variable declared in the initialize statement may extend from the point at which it is declared until the end of the block that immediately surrounds the for statement.
Scope of an Identifier |.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Chapter 6: User-Defined Functions Table 6-2 summarizes the scope (visibility) of the identifiers.
TABLE 6-2 Scope (Visibility) of the Identifiers Identifier Visibility in one Visibility in two Visibility Visibility in in Block three four Visibility in main.
N x (block four's local N.
N a (block four's local N.
N one (three's formal y (three's formal z (three's formal Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Global Variables, Named Constants, and Side Effects | 401 Note that function three cannot call function one, because function three has a formal parameter named one.
Similarly, the block marked four in function three cannot use the int variable a, which is declared in function three, because block four has an identifier named a.
Before closing this section, let us note the following about global variables: 1.
Chapter 2 stated that Cplus_plus does not automatically initialize variables.
However, some compilers initialize global variables to their default values.
For example, if a global variable is of type int, char, or double, it is initialized to zero.
In Cplus_plus, :: is called the scope resolution operator.
By using the scope resolution operator, a global variable declared before the definition of a function (block) can be accessed by the function (or block) even if the function (or block) has an identifier with the same name as the variable.
In the preceding program, by using the scope resolution operator, the function main can refer to the global variable z as ::z.
Similarly, suppose that a global variable t is declared before the definition of the function—say, funExample.
Then, funExample can access the variable t using the scope resolution operator even if funExample has an identifier t.
Using the scope resolution operator, funExample refers to the variable t as ::t.
Also, in the preceding program, using the scope resolution operator, function three can call function one.
Cplus_plus provides a way to access a global variable declared after the definition of a function.
In this case, the function must not contain any identifier with the same name as the global variable.
In the preceding program, the global variable w is declared after the definition of function one.
The function one does not contain any identifier named w; therefore, w can be accessed by function one only if you declare w as an external variable inside one.
To declare w as an external variable inside function one, the function one must contain the following statement: extern int w; In Cplus_plus, extern is a reserved word.
The word extern in the above statement announces that w is a global variable declared elsewhere.
Thus, when function one is called, no memory for w, as declared inside one, is allocated.
In Cplus_plus, external declaration also has another use, but it is not discussed in this book.
Global Variables, Named Constants, and Side Effects A Cplus_plus program can contain global variables and you might be tempted to make all of the variables in a program global variables so that you do not have to worry about what a function knows about which variable.
Using global variables, however, has side effects.
If Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 6: User-Defined Functions more than one function uses the same global variable and something goes wrong, it is difficult to discover what went wrong and where.
Problems caused by global variables in one area of a program might be misunderstood as problems caused in another area.
For example, consider the following program:.
Sample Run: Line Line Line Line Line 2: In main:  = 15 6: In funOne:  = 15 and  = 15 8: In funOne:  = 27 and  = 27 10: In funOne:  = 40 and  = 40 4: In main after funOne:  = 40 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Global Variables, Named Constants, and Side Effects | 403 This program has  variable  that is declared before the definition of any function.
Because none of the functions has an identifier , the variable  is accessible anywhere in the program.
Also, the program consists of  void function with  reference parameter.
In Line 3, the function main calls the function funOne, and the actual parameter passed to funOne is.
So, , the formal parameter of funOne, receives the address of.
Any changes that  makes to its value immediately change.
Because  can be directly accessed anywhere in the program, in Line 9, the function funOne changes the value of by using  itself.
Thus, you can manipulate the value of  by using either  reference parameter or  itself.
In the previous program, if the last value of  is incorrect, it would be difficult to determine what went wrong and in which part of the program.
We strongly recommend that you do not use global variables; instead, use the appropriate parameters.
In the programs given in this book, we typically placed named constants before the function main, outside of every function definition.
That is, the named constants we used are global named constants.
Unlike global variables, global named constants have no side effects because their values cannot be changed during program execution.
Moreover, placing  named constant in the beginning of the program can increase readability, even if it is used only in one function.
If you need to later modify the program and change the value of  named constant, it will be easier to find if it is placed in the beginning of the program.
In an algebra course, one learns how to factor  polynomial by using various techniques.
In this example, we write  program to factor  second degree polynomial of the form x2 þ bx þ c, i_0_e_0_, write x2 þ bx þ c ¼ ðx  uÞðx  vÞ.
For simplicity, we restrict this program to factor polynomials, where b, c, u, and v are integers.
For example, x2 þ 5x þ 6 ¼ ðx þ 2Þðx þ 3Þ, x2 þ 10x  24 ¼ ðx þ 12Þðx  2Þ, and x2  25 ¼ ðx þ 5Þðx  5Þ.
It can be shown that the values of u and v are given by pﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ b þ b2  4c u¼ 2 pﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ b  b2  4c v¼ 2 If b2  4c < 0, then u and v are complex numbers; if b2  4c > 0 and b2  4c is not the square of an integer, then ﬃu and v are p not integers.
Also, if b2  4c is the square of an pﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ ﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ ﬃ 2 2 integer and b þ b  4c and b  b  4c are not divisible by 2, then u andﬃ v are pﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ 2  4c and not integers.
It follows that for u and v to be integers, b þ b pﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ b  b2  4c must be divisible by 2.
The following function takes as  parameter, the values of b and c, and returns the values of u and v as well as indicating whether the polynomial is factorable.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Global Variables, Named Constants, and Side Effects |.
Sample Runs: In these sample runs, the user input is shaded.
Sample Run 1: Enter the coefficient of : 5 Enter the constant term: 6 Sample Run 2:.
Enter the constant term: -25 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Chapter 6: User-Defined Functions Sample Run 3: Enter the coefficient of : 8 Enter the constant term: 16 Sample Run 4: Enter the coefficient of : -13 Enter the constant term: 20 The polynomial is not.
The following is an example of a menu-driven program.
When the program executes, it gives the user a list of choices to choose from.
This program further illustrates how value and reference parameters work.
It converts length from feet and inches to meters and centimeters and vice versa.
The program contains three functions: showChoices, feetAndInchesToMetersAndCent, and metersAndCentToFeetAndInches.
The function showChoices informs the user how to use the program.
The user has the choice to run the program as long as the user wishes.
Global Variables, Named Constants, and Side Effects |.
Chapter 6: User-Defined Functions.
Sample Run: In this sample run, the user  is shaded.
The preceding output is self-explanatory.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated,  whole or  part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter().
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Static and Automatic Variables | 409 Static and Automatic Variables The variables discussed so far have followed two simple rules: 1.
Memory for global variables remains allocated as long as the  executes.
Memory for a variable declared within a block is allocated at block entry and deallocated at block exit.
For example, memory for the formal parameters and local variables of a function is allocated when the function is called and deallocated when the function exits.
A variable for which memory is allocated at block entry and deallocated at block exit is called an automatic variable.
A variable for which memory remains allocated as long as the  executes is called a static variable.
Global variables are static variables, and by default, variables declared within a block are automatic variables.
You can declare a static variable within a block by using the reserved word static.
The syntax for declaring a static variable is: static dataType identifier;.
Static variables declared within a block are local to the block, and their scope is the same as that of any other local identifier of that block.
Most compilers initialize static variables to their default values.
For example, static int variables are initialized to 0.
However, it is a good practice to initialize static variables yourself, especially if the initial value is not the default value.
In this case, static variables are initialized when they are declared.
The statement: static int  = 0; declares  to be a static variable of type int and initializes  to 0, the first time the function is called.
EXAMPLE 6-18 The following  shows how static and automatic variables behave.
Sample Run: Inside Inside Inside Inside Inside test test test test test = = = = = 2 and  = 11 4 and  = 11 6 and  = 11 8 and  = 11 10 and  = 11 In the function test,  is a static variable initialized to 0, and  is an automatic variable initialized to 10.
The function main calls the function test five times.
Memory for the variable  is allocated every time the function test is called and deallocated when the function exits.
Thus, every time the function test is called, it prints the same value for.
However, because  is a static variable, memory for  remains allocated as long as the  executes.
The variable  is initialized once to 0, the first time the function is called.
The subsequent calls of the function test use the value  had when the last left (executed) the function test.
Because memory for static variables remains allocated between function calls, static variables allow you to use the value of a variable from one function call to another function call.
Even though you can use global variables if you want to use certain values from one function call to another, the local scope of a static variable prevents other functions from manipulating its value.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated,  whole or  part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter().
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Debugging: Using Drivers and Stubs | 411 Debugging: Using Drivers and Stubs In this and the previous chapters, you learned how to write functions to divide a problem into subproblems, solve each subproblem, and then combine the functions to form the complete program to get a solution of the problem.
A program may contain a number of functions.
In a complex program, usually, when a function is written, it is tested and debugged alone.
You can write a separate program to test the function.
The program that tests a function is called a driver program.
For example, the program in Example 6-15 contains functions to convert the length from feet and inches to meters and centimeters and vice versa.
Before writing the complete program, you could write separate driver programs to make sure that each function is working properly.
Sometimes, the results calculated by one function are needed in another function.
In that case, the function that depends on another function cannot be tested alone.
For example, consider the following program that determines the time needed to fill a swimming pool.
Sample Run: In this sample run, the user input is shaded.
Enter the length, width,  the depth of the pool (in feet): 30 15 10 Enter the rate of the water, (in gallons per minute): 100 The time to fill the pool is approximately: 5 hour()  37 minute().
As you can see, the program contains the function poolCapacity to find the amount of water needed to fill the pool, the function poolFillTime to find the time to fill the pool, some other functions.
Now, to calculate the time to fill the pool, you must know the amount of the water needed  the rate at which the water is released in the pool.
Because the results of the function poolCapacity are needed in the function poolFillTime, the function poolFillTime cannot be tested alone.
Does this mean that we must write the functions in a specific order.
Not necessarily, especially when different people are working on different parts of the program.
In situations such as these, we use function stubs.
A function stub is a function that is not fully coded.
For a void function, a function stub might consist of only a function header  a set of empty braces, {},  for a valuereturning function it might contain only a return statement with a plausible  easy to use return value.
For example, the function stub for the function poolCapacity can be:.
Function Overloading: An Introduction.
Ultimately, the stub for function poolCapacity is replaced with a function that properly calculates the amount of water needed to fill the pool based on the values of the parameters.
In the meantime, the function stub allows work to continue on other parts of the program that call the function poolCapacity.
Because a stub looks a lot like a viable function, it must be properly documented in a way that would remind you to replace it with the actual definition.
If you forget to replace a stub with the actual definition, the program will generate erroneous results, which sometimes might be embarrassing.
Before we look at some programming examples, another concept about functions is worth mentioning: function overloading.
Function Overloading: An Introduction In a Cplus_plus program, several functions can have the same name.
This is called function overloading, or overloading a function name.
Before we state the rules to overloading a function, let us define the following: Two functions are said to have different formal parameter lists if both functions have:.
A different number of formal parameters or The same number of formal parameters  the data types of the formal parameters, in the order listed, differ in at least one position.
The functions functionSix  functionSeven both have three formal parameters, the data type of the corresponding parameters is the same.
Therefore, these functions have the same formal parameter list.
Note that it is the data types  not the parameter names or the return type that are examined.
To overload a function name, any two definitions of the function must have different formal parameter lists.
Function overloading: Creating several functions with the same name.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook /or eChapter().
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 6: User-Defined Functions The signature of a function consists of the function name  its formal parameter list.
Two If a function' name is overloaded, then all of the functions in the set have the same name.
Therefore, all the functions in the overloaded set must have different formal parameter lists.
Thus, the following function headings correctly overload the function functionXYZ: void void void void.
Both of these function headings have the same name  same formal parameter list.
Therefore, these function headings to overload the function functionABC are incorrect.
In this case, the compiler will generate a syntax error.
Some authors define the signature of a function as the formal parameter list,  some consider the entire heading of the function as its signature.
However, in this book, the signature of a function consists of the function' heading  its formal parameter list.
If the function' names are different, then, of course, the compiler would have no problem in identifying which function is called,  it will correctly translate the code.
However, if a function' name is overloaded, then, as noted, the function' formal parameter list determines which function' body executes.
Suppose you need to write a function that determines the larger of two items.
Both items can be integers, floating-point numbers, characters, or strings.
The function largerInt determines the larger of two integers; the function largerChar determines the larger of two characters,  so on.
All of these functions perform similar operations.
Instead of giving different names to these functions, you can use the same name—say, larger—for each function; that is, you can overload the function larger.
Thus, you can write the previous function prototypes simply as: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook /or eChapter().
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Functions with Default Parameters.
If the call is larger(5, 3), for example, the version having int parameters is executed.
If the call is larger('A', '9'), the version having char parameters is executed,  so on.
Function overloading is used when you have the same action for different sets of data.
Of course, for function overloading to work, you must give a separate definition for each function.
Functions with Default Parameters This section is not needed until Chapter 10.
Recall that when a function is called, the number of actual and formal parameters must be the same.
Cplus_plus relaxes this condition for functions with default parameters.
You specify the value of a default parameter when the function name appears for the first time, usually in the prototype.
In general, the following rules apply for functions with default parameters:.
If you do not specify the value of a default parameter, the default value is used for that parameter.
All of the default parameters must be the far-right parameters of the function.
Suppose a function has more than one default parameter.
In a function call, if a value to a default parameter is not specified, then you must omit all of the arguments to its right.
Default values can be constants, global variables, or function calls.
The caller has the option of specifying a value other than the default for any default parameter.
You cannot assign a constant value as a default value to a reference parameter.
Consider the following function prototype: void funcExp(int t, int u, double v, char  = 'A', int  = 67, char  = 'G', double  = 78_0_34); The function funcExp has seven parameters.
The parameters , , , and  are default parameters.
If no values are specified for , , , and  in a call to the function funcExp, their default values are used.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
In statement 2, the default value of  is replaced by 'B', the default value of  is replaced by 87, the default value of  is replaced by the value of ch, and the default value of  is used.
In statement 3, the default value of  is replaced by 'D', and the default values of , , and  are used.
The following function calls are illegal: 1.
In statement 2, because the first parameter is a default parameter, all parameters must be default parameters.
In statement 3, a constant value cannot be assigned to  because  is a reference parameter.
Example 6-19 further illustrates functions with default parameters.
Functions with Default Parameters.
Sample Run: 1:  = 23,  = 48_0_78,  = M 2:  = 1 3:  = 20 4:  = 34 5:  = 120 12:  = 46,  = 12_0_34,  = B 12:  = 92,  = 42_0_68,  = B 12:  = 184,  = 34_0_65,  = Q 9:  = 184,  = 48_0_78,  = M Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 6: User-Defined Functions In programs in this book, and as is recommended, the definition of the function main is placed before the definition of any user-defined functions.
You must, therefore, specify the default value for  parameter in the function prototype and in the function prototype only, not in the function definition because this must occur at the first appearance of the function name.
PROGRAMMING EXAMPLE: Classify Numbers In this example, we use functions to rewrite the program that determines the number of odds and evens from  given list of integers.
This program was first written in Chapter 5.
The main algorithm remains the same: 1.
Initialize the variables, zeros, odds, and evens to 0.
Read  number.
If the number is even, increment the even count, and if the number is also zero, increment the zero count; otherwise, increment the odd count.
Repeat Steps 2 and 3 for each number in the list.
The main parts of the program are: initialize the variables, read and classify the numbers, and then output the results.
To simplify the function main and further illustrate parameter passing, the program includes:.
A function initialize to initialize the variables, such as zeros, odds, and evens.
A function getNumber to get the number.
A function classifyNumber to determine whether the number is odd or even (and whether it is also zero).
This function also increments the appropriate count.
A function printResults to print the results.
Let us now describe each of these functions.
The variables that we need to initialize are zeros, odds, and evens.
As before, their initial values are all zero.
Clearly, this function has three parameters.
Because the values of the formal parameters initializing these variables must be passed outside of the function, these formal parameters must be reference parameters.
Essentially, this function is:.
Programming Example: Classify Numbers.
Because you need to pass only one number, this function has only one parameter.
The formal parameter of this (void) function must be  reference parameter because the number read is passed outside of the function.
Essentially, this function is:.
It also updates the values of some of the variables, zeros, odds, and evens.
This function needs to know the number to be analyzed; therefore, the number must be passed as parameter.
Because this function also increments the appropriate count, the variables (that is, zeros, odds, and evens declared in main) holding the counts must be passed as parameters to this function.
Thus, this function has four parameters.
Because the number will only be analyzed and not altered, you need to pass only its value.
Thus, the formal parameter corresponding to this variable is  value parameter.
After analyzing the number, this function increments the values of some of the variables, zeros, odds, and evens.
Therefore, the formal parameters corresponding to these variables must be reference parameters.
The algorithm to analyze the number and increment the appropriate count is the same as before.
The definition of this function is: void classifyNumber(int , int& , int& , { {.
The function printResults prints the final results.
To print the results (that is, the number of zeros, odds, and evens), this function must have access to the values of the variables, zeros, odds, and evens declared in the function main.
Therefore, this function has three parameters.
Because this function doesn't change the values of Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 6: User-Defined Functions.
We now give the main algorithm and show how the function main calls these functions.
Call the function initialize to initialize the variables.
Prompt the user to enter 20 numbers.
For each number in the list: a.
Call the function getNumber to read a number.
Output the number.
Call the function classifyNumber to classify the number and increment the appropriate count.
Call the function printResults to print the final results.
COMPLETE PROGRAM LISTING.
Chapter 6: User-Defined Functions.
Sample Run: In this sample run, the user input is shaded.
Please enter 20 integers.
The numbers you entered are: 0 0 12 23 45 7 -2 -8 -3 -9 4 0 1 0 -7 23 -24 0 0 12 0 0 12 23 45 7 -2 -8 -3 -9 4 0 1 0 -7 23 -24 0 0 12 There are 12 evens, which includes 6 zeros The  of odd numbers is: 8 In the previous program, because the data is assumed to be input from the standard input device (the keyboard) and the function getNumber returns only one value, you can also write the function getNumber as a value-returning function.
If written as a value-returning function, the definition of the function getNumber is:.
Of course, you also need to change the function prototype.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: Data Comparison.
This programming example illustrates: Watch the Video.
How to read data from more than one file in the same program.
How to send output to a file.
How to generate bar graphs.
With the help of functions and parameter passing, how to use the same program segment on different (but similar) sets of data.
How to use structured design to solve a problem and how to perform parameter passing.
This program is broken into two parts.
First, you learn how to read data from more than one file.
Second, you learn how to generate bar graphs.
Two groups of students at a local university are enrolled in certain special courses during the summer semester.
The courses are offered for the first time and are taught by different teachers.
At the end of the semester, both groups are given the same tests for the same courses, and their scores are recorded in separate files.
The data in each file is in the following form: courseNo courseNo.
The output is of the following form: Course No CSC ENG Group No 1 2 Course Average 83_0_71 80_0_82 1 2 82_0_00 78_0_20.
Avg for group 1: 82_0_04 Avg for group 2: 82_0_01 Input Because the data for the two groups are recorded in separate files, the input data appears in two separate files.
Output As shown above.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Suppose the data is stored in the file group1_0_txt for group 1 and file group2_0_txt for group 2.
After processing the data for one group, we can process the data for the second group for the same course and continue until we run out of data.
Processing data for each course is similar and is a two-step process: 1.
Sum the scores for the course.
Count the  of students in the course.
Divide the total score by the  of students to find the course average.
Output the results.
We are comparing only the averages of the corresponding courses in each group, and the data in each file is ordered according to course ID.
To ensure that only the averages of the corresponding courses are compared, we compare the course IDs for each group.
If the corresponding course IDs are not the same, we output an error message and terminate the program.
This discussion suggests that we should write a function, calculateAverage, to find the course average.
We should also write another function, printResult, to output the data in the form given.
By passing the appropriate parameters, we can use the same functions, calculateAverage and printResult, to process each course's data for both groups.
The preceding discussion translates into the following algorithm: 1.
Variables (Function Initialize the variables.
Get the course IDs for group 1 and group 2.
If the course IDs are different, print an error message and exit the program.
Calculate the course averages for group 1 and group 2.
Print the results in the form given above.
Repeat Steps 2 through 5 for each course.
Print the final results.
The preceding discussion suggests that the program needs the following variables for.
Programming Example: Data Comparison.
Then, we will put the function main together.
Because the input is stored in a file and the input file is opened in the function main, we must pass the ifstream variable associated with the input file to this function.
Furthermore, after calculating the course average, this function must pass the course average to the function main.
Therefore, this function has two parameters, and both parameters must be reference parameters.
To find the course average, we must first find the sum of all scores for the course and the number of students who took the course and then divide the sum by the number of students.
Thus, we need a variable to find the sum of the scores, a variable to count the number of students, and a variable to read and store a score.
Of course, we must initialize the variable to find the sum and the variable to count the number of students to zero.
Local Variables (Function calculate In the previous discussion of data manipulation, we identified three variables for the.
Declare and initialize variables.
Get the (next) course score, score.
Update  by adding the course score.
Get the (next) course ,.
The function printResult prints the group's course ID, group , and course average.
The output is stored in a file.
So we must pass four parameters to this function: the ofstream variable associated with the output file, the group , the course ID, and the course average for the group.
The ofstream variable must be passed by reference.
Because the function uses only the values of the other variables, the remaining three parameters should be value parameters.
Also, from the output, it is clear that we print the course ID only before the group.
In pseudocode, the algorithm is: print course ID else print a blank print group  and course average The definition of the function printResult follows: void printResult(ofstream& , string courseID, int , { "; else.
Now that we have designed and defined the functions calculateAverage and printResult, we can describe the algorithm for the function main.
Before outlining the algorithm, however, we note the following: It is quite possible that in both input files, the data is ordered according to the course IDs, but one file might have one or more additional courses that are not in the other file.
We do not discover this error until after we have processed both files and discovered that one file has unprocessed data.
Make sure to check for this error before printing the final answer—that is, the averages for group 1 and group 2.
MAIN ALGORITHM: Function main 1.
Declare the variables (local declaration).
Open the input files.
Print a message if you are unable to open a file and terminate the program.
Open the output file.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: Data Comparison.
To output floating-point numbers in a fixed decimal format with the decimal point and trailing zeros, set the manipulators fixed and showpoint.
Also, to output floating-point numbers to two decimal places, set the precision to two decimal places.
Initialize the course average for group 1 to 0_0_0.
Initialize the course average for group 2 to 0_0_0.
Initialize the  of courses to 0.
Print the heading.
Get the course ID, 1, for group 1.
Get the course ID, 2, for group 2.
For each course in group 1 and group 2,.
Calculate the course average for group 1 (call the function calculateAverage and pass the appropriate parameters).
Calculate the course average for group 2 (call the function calculateAverage and pass the appropriate parameters).
Print the results for group 1 (call the function printResult and pass the appropriate parameters).
Print the results for group 2 (call the function printResult and pass the appropriate parameters).
Update the average for group 1.
Update the average for group 2.
Increment the  of courses.
Get the course ID, 1, for group 1.
Get the course ID, 2, for group 2.
Close the input and output files.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: Data Comparison.
Course No CSC Group No 1 2 Course 83_0_71 80_0_82 ENG 1 2 82_0_00 78_0_20 HIS 1 2 77_0_69 84_0_15 MTH 1 2 83_0_57 84_0_29 PHY 1 2 83_0_22 82_0_60 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: Data Comparison.
Many currently available software packages can analyze data in several forms and then display the results in a visual form, such as bar graphs or pie charts.
The second part of this program aims to display the results found earlier in the form of bar graphs, as shown below: Course ID CSC ENG Course Average 0 10 20 30 40 50 60 70 80 90 100 |_0__0__0__0_|_0__0__0__0_|_0__0__0__0_|_0__0__0__0_|_0__0__0__0_|_0__0__0__0_|_0__0__0__0_|_0__0__0__0_|_0__0__0__0_|_0__0__0__0_| ***************************************** ######################################## ***************************************** #######################################.
Group 1 minus_minus **** Group 2 minus_minus #### Avg for group 1: 82_0_04 Avg for group 2: 82_0_01 Each symbol (* or #) in the bar graph represents two points.
If a course average is less than 2, no symbol is printed.
Because the output is in the form of a bar graph, we need to modify the function printResult.
Print Bars The function printResult prints the course ID and the bar graph representing the average for a course.
The output is stored in a file.
So we must pass four parameters to this function: the ofstream variable associated with the output file, the group Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 6: User-Defined Functions number (to print * or #), the course ID, and the course average for the department.
To print the bar graph, we can use a loop to print one symbol for every two points.
If the average is 78_0_45, we must print 39 symbols to represent this average.
Following this discussion, the definition of the function printResult is: void printResult(ofstream& , string , {.
Replace the function printResult in the preceding program, include the function printHeading, include the statements to output — Group 1 minus_minus **** and Group 2 minus_minus #### — , and rerun the program.
Your program should generate a bar graph similar to the bar graph shown earlier.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Quick Review | 433 QUICK REVIEW 1.
Functions, also called modules, are like miniature programs.
Functions enable you to divide a program into manageable tasks.
The Cplus_plus system provides the standard (predefined) functions.
To use a standard function, you must: i.
Know the name of the header file that contains the function's specification, Include that header file in the program, and Know the name and type of the function and number and types of the parameters (arguments).
There are two types of user-defined functions: value-returning functions and void functions.
Variables defined in a function heading are called formal parameters.
Expressions, variables, or constant values used in a function call are called actual parameters.
In a function call, the number of actual parameters and their types must match with the formal parameters in the order given.
To call a function, use its name together with the actual parameter list.
A value-returning function returns a value.
Therefore, a value-returning function is used (called) in either an expression or an output statement or as a parameter in a function call.
The general syntax of a user-defined function is:.
The line functionType functionName(formal parameter list) is called the function heading (or function header).
Statements enclosed between braces ({ and }) are called the body of the function.
The function heading and the body of the function are called the definition of the function.
If a function has no parameters, you still need the empty parentheses in both the function heading and the function call.
A value-returning function returns its value via the return statement.
However, whenever a return statement executes in a function, the remaining statements are skipped and the function exits.
A return statement returns only one value.
A function prototype is the function heading without the body of the function; the function prototype ends with the semicolon.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 6: User-Defined Functions A function prototype announces the function type, as well as the type and number of parameters, used in the function.
In a function prototype, the names of the variables in the formal parameter list are optional.
Function prototypes help the compiler correctly translate each function call.
In a program, function prototypes are placed before every function definition, including the definition of the function main.
When you use function prototypes, user-defined functions can appear in any order in the program.
When the program executes, the execution always begins with the first statement in the function main.
Functions execute only when they are called.
A call to a function transfers control from the caller to the called function.
In a function call statement, you specify only the actual parameters, not their data type or the function type.
When a function exits, control goes back to the caller.
A function that does not have a data type is called a void function.
A return statement without any value can be used in a void function.
If a return statement is used in a void function, it is typically used to exit the function early.
The heading of a void function starts with the word void.
In Cplus_plus, void is a reserved word.
A void function may or may not have parameters.
A call to a void function is a stand-alone statement.
To call a void function, you use the function name together with the actual parameters in a stand-alone statement.
There are two types of formal parameters: value parameters and reference parameters.
A value parameter receives a copy of its corresponding actual parameter.
A reference parameter receives the address (memory location) of its corresponding actual parameter.
The corresponding actual parameter of a value parameter is an expression, a variable, or a constant value.
A constant value cannot be passed to a reference parameter.
The corresponding actual parameter of a reference parameter must be a variable.
When you include & after the data type of a formal parameter, the formal parameter becomes a reference parameter.
The stream variables should be passed by reference to a function.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Quick Review | 44.
The scope of an identifier refers to those parts of the program where it is accessible.
Variables declared within a function (or block) are called local variables.
Variables declared outside of every function definition (and block) are called global variables.
The scope of a function name is the same as the scope of an identifier declared outside of any block.
See the scope rules in this chapter (section, Scope of an Identifier).
Cplus_plus does not allow the nesting of function definitions.
An automatic variable is a variable for which memory is allocated on function (or block) entry and deallocated on function (or block) exit.
A static variable is a variable for which memory remains allocated throughout the execution of the program.
By default, global variables are static variables.
In Cplus_plus, a function can be overloaded.
Two functions are said to have different formal parameter lists if both functions have:.
A different number of formal parameters, or The same number of formal parameters and the data types of the formal parameters, in the order listed, differ in at least one position.
The signature of a function consists of the function name and its formal parameter list.
Two functions have different signatures if they have either different names or different formal parameter lists.
If a function is overloaded, then in a call to that function the formal parameter list of the function determines which function to execute.
Cplus_plus allows functions to have default parameters.
If you do not specify the value of a default parameter, the default value is used for that parameter.
All of the default parameters must be the far-right parameters of the function.
Suppose a function has more than one default parameter.
In a function call, if a value to a default parameter is not specified, then you must omit all arguments to its right.
Default values can be constants, global variables, or function calls.
The calling function has the option of specifying a value other than the default for any default parameter.
You cannot assign a constant value as a default value to a reference parameter.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 6: User-Defined Functions EXERCISES The number in parentheses at the end of an exercise refers to the learning objective listed at the beginning of the chapter.
Mark the following statements as true or false: a.
To use a predefined function in a program, you need to know only the Parameters allow you to use different values each time the function is When a return statement executes in a user-defined function, the If a Cplus_plus function does not use parameters, parentheses around the In Cplus_plus, the names of the corresponding formal and actual parameters A function that changes the value of a reference parameter also changes Whenever the value of a reference parameter changes, the value of the In Cplus_plus, function definitions can be nested; that is, the definition of Using global variables in a program is a better programming style than The memory for a static variable remains allocated between function.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Using the functions described in Table 6-1, write each of the following as a Cplus_plus expression.
What What What What What is is is is is the the the the the output output output output output if if if if if the the the the the input input input input input is is is is is -23 8.
Which of the following statements are valid.
How many parameters does the function func1 have.
What is the type of the function func1.
How many parameters does function func2 have.
What is the type of function func2.
How many parameters does function func3 have.
What is the type of function func3.
How many parameters does function join have.
What is the type of function join.
How many actual parameters are needed to call the function func1.
What is the type of each actual parameter, and in what order should you use these parameters in a call to the function func1.
Write a Cplus_plus statement that prints the value returned by the function func1 with the actual parameters 3 and 8_0_5.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 6: User-Defined Functions Write a Cplus_plus statement that prints the value returned by function join with the actual parameters "John" and "Project Manager", respectively.
Write a Cplus_plus statement that prints the next character returned by Why do you need to include function prototypes in a program that contains Write the definition of a function that takes as input a char value and Consider the following function: {.
What is the output of the following Cplus_plus statements.
Write the definition of a function that takes as input the three numbers.
The function returns true if the  number to the power of the number equals the third number; otherwise, it returns false.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
What is the output of this program.
Chapter 6: User-Defined Functions Write the definition of a function that takes as input three decimal numbers and returns the first number multiplied by the second number to the power.
Function prototype, function heading, function body, and function definitions.
Function call statements, formal parameters, and actual parameters.
Value parameters and reference parameters.
Local variables and global variables.
Explain the difference between a value and a reference parameter.
Explain the difference between a local and a global variable.
What What What What is is is is the the the the output output output output if if if if the the the the input input input input is is is is 1.
Write the definition of a void function that takes as input a decimal number and outputs 3 times the value of the decimal number.
Format your output Write the definition of a void function that takes as input two decimal numbers.
If the first number is nonzero, it outputs the  number divided by the first number; otherwise, it outputs a message indicating that the  number cannot be divided by the first number because the first Write the definition of a void function with three reference parameters of type int, double, and string.
The function sets the  of the int and double Write the definition of a void function that takes as input three parameters of type int, say sum, prod, and.
The function updates the value of sum by adding the value of , and the value of prod by multiplying the value of.
The new  of sum and prod are reflected in the calling.
In the following program, number the marked statements to show the order in which they will execute (the logical order of execution).
All Rights Reserved.
May not be copied, scanned,  duplicated, in whole  in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/ eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
What is the output if the input is 3 625.
What is the output if the input is 24 1024.
What is the output if the input is 0 196.
The function traceMe in Exercise 30 outputs the  of , , and.
Modify the definition of this function so that rather than print these , int  = 5;.
Consider the following function prototype:.
Write  program that uses the function isPalindrome given in Example 6-6 (Palindrome).
Test your program on the following strings: "madam", "abba", "22", "67876", "444244", and.
Modify the function isPalindrome of Example 6-6 so that when determining whether  string is  palindrome, cases are ignored, that is, uppercase and lowercase letters are considered the same.
Write  value-returning function, isVowel, that returns the value true if given character is  vowel and otherwise returns false.
Write  program that prompts the user to input  sequence of characters and outputs the number of vowels.
The program should use and the functions listed in Table 6-1 to accomplish the following: pﬃﬃﬃ Output the value of p.
Prompt the user to input the value of  double variable r, which stores the radius of  sphere.
The program then outputs the following: i.
The value of 4pr2, which is the surface area of the sphere.
The value of (4/3)pr3, which is the volume of the sphere.
The following program is designed to find the area of  rectangle, the area of circle, or the volume of  cylinder.
However, () the statements are in the incorrect order; (b) the function calls are incorrect; (c) the logical expression in the while loop is incorrect; and (d) the function definitions are incorrect.
Rewrite the program so that it works correctly.
Your program must be properly indented.
Modify the roll dice , Example 6-4, so that it allows the user to the desired sum of the numbers to be rolled.
Also allow the user to call the rollDice function as many times as the user desires.
The following formula gives the distance between two points, (1, 1) and (2, 2) in the Cartesian plane: qﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ ðx2  1 Þ2 þ ðy2  1 Þ2 Given the center and a point on the , you can use this formula to find the radius of the.
Write a  that prompts the user to  the center and a point on the.
The  should then output the 's radius, diameter, circumference, and area.
Your  must have at least the following functions: a.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Rewrite the  in Programming Exercise 14 of Chapter 4 (cell phone company) so that it uses the following functions to calculate the billing amount.
Chapter 6: User-Defined Functions regularBill: This function calculates and returns the billing amount for regular service.
Write a  that takes as input five numbers and outputs the mean (average) and standard deviation of the numbers.
If the numbers are x1, x2, x3, x4, and x5, then the mean is x ¼ (x1 + x2 + x3 + x4 + x5)/5 and the standard deviation is: sﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ ðx1  xÞ2 þ ðx2  xÞ2 þ ðx3  xÞ2 þ ðx4  xÞ2 þ ðx5  xÞ2 s¼ 5 Your  must contain at least the following functions: a function that calculates and returns the mean and a function that calculates the standard deviation.
When you borrow money to buy a house, a car, or for some other purposes, then you typically repay it by making periodic payments.
Suppose that the loan amount is L, r is the interest rate per year, m is the number of payments in a year, and the loan is for t years.
Suppose that i ¼ (r / m) and r is in decimal.
Then the periodic payment is: R¼ Li ; 1  ð1 þ iÞmt You can also calculate the unpaid loan balance after making certain payments.
For example, the unpaid balance after making k payments is: Programming Exercises.
The then outputs the apropriate values.
Your  must contain at least two functions, with appropriate parameters, to calculate the periodic payments and the unpaid balance after certain payments.
Make the  menu driven and use a loop so that the user can repeat the  for different values.
During the tax season, every Friday, the J&J accounting firm provides assistance to people who prepare their own tax returns.
Their charges are as follows: a.
If a person has low income (<¼ 25,000) and the consulting time is less than or equal to 30 minutes, there are no charges; otherwise, the service charges are 40% of the regular hourly rate for the time over 30 minutes.
For others, if the consulting time is less than or equal to 20 minutes, there are no service charges; otherwise, service charges are 70% of the regular hourly rate for the time over 20 minutes.
Write a program that prompts the user to enter the hourly rate, the total consulting time, and whether the person has low income.
The program should output the billing amount.
Your program must contain a function that takes as input the hourly rate, the total consulting time, and a value indicating whether the person has low income.
The function should return the billing amount.
Your program may prompt the user to enter the consulting time in minutes.
During winter when it is very cold, typically, everyone would like to know the windchill factor, especially, before going out.
Meteorologists use the following formula to compute the windchill factor, : = 35_0_74 + 0_0_6215 * T 35_0_75 * V 14.
Write a program that prompts the user to input the wind speed, in miles per hour, and the temperature in degrees Fahrenheit.
The program then outputs the windchill factor.
Your program must contain at least two functions: one to get the user input and the other to determine the windchill factor.
Consider the definition of the function main:.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Chapter 6: User-Defined Functions The variables x, y, z, rate, and hours referred to in items a through f below are the variables of the function main.
Each of the functions described must have the appropriate parameters to access these variables.
Write the following definitions: Write the definition of the function initialize that initializes x and y to 0 and z to the blank character.
Write the definition of the function getHoursRate that prompts the user to input the hours worked and rate per hour to initialize the variables hours and rate of the function main.
Write the definition of the value-returning function payCheck that calculates and returns the amount to be paid to an employee based on the hours worked and rate per hour.
The hours worked and rate per hour are stored in the variables hours and rate, respectively, of the function main.
The formula for calculating the amount to be paid is as follows: For the first 40 hours, the rate is the given rate; for hours over 40, the rate is 1_0_5 times the given rate.
Write the definition of the function printCheck that prints the hours worked, rate per hour, and the salary.
Write the definition of the function funcOne that prompts the user to input a number.
The function then changes the value of x by assigning the value of the expression 2 times the (old) value of x plus the value of y minus the value entered by the user.
Write the definition of the function nextChar that sets the value of z to the next character stored in z.
Write the definition of a function main that tests each of these functions.
Consider the following Cplus_plus code: a.
Write the definition of func2 so that its action is as follows: a.
Prompt the user to input two integers and store the numbers in  and b, respectively.
Otherwise, the value assigned to c is 0.
The values of , b, and c are passed back to the calling environment.
After completing the definition of the func2 and writing its function prototype, test run your program.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 6: User-Defined Functions The statements in the following program are not in the correct order.
Rearrange the statements so that the program outputs the total time an employee spent on the job each day.
The program asks the user to  the employee's name, the arrival time (arrival hour, arrival minute, AM or PM), and departure time (departure hour, departure minute, AM or PM).
The program also allows the user to run the program as long as the user wishes.
After rearranging the statements, your program must be properly indented.
The function printGrade in Example 6-13 is written as  void function to compute and output the course grade.
The course score is passed as parameter to the function printGrade.
Rewrite the function printGrade as  value-returning function so that it computes and returns Also, change the name of the function to calculateGrade.
In this exercise, you are to modify the Classify Numbers programming example in this chapter.
As written, the program inputs the data from the standard  device (keyboard) and outputs the results on the standard output device (screen).
The program can process only 20 numbers.
Rewrite the program to incorporate the following requirements: Data to the program is  from  file of an unspecified length; that is, the program does not know in advance how many numbers are in the file.
Save the output of the program in  file.
Modify the function getNumber so that it reads  number from the file (opened in the function main), outputs the number to the output file (opened in the function main), and sends the number read to the function main.
Print only 10 numbers per line.
Have the program find the sum and average of the numbers.
Modify the function printResult so that it outputs the final results to the output file (opened in the function main).
Other than outputting the appropriate counts, this new  of the function printResult should also output the sum and average of the numbers.
Write  program that prints the day number of the year, given the date in the form month-day-year.
For example, if the  is 1-1-2006, the day number is 1; if the  is 12-25-2006, the day number is 359.
The program should check for  leap year.
A year is  leap year if it is divisible by 4, but not divisible by 100.
For example, 1992 and 2008 are divisible by.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
A year that is divisible by 100 is a leap year if it is also divisible by 400.
For example, 1600 and 2000 are divisible by 400.
However, 1800 is not a leap year because 1800 is not divisible by 400.
Write a progam that reads a string and outputs the number of times each lowercase vowel appears in it.
Your program must contain a function with one of its parameters as a string variable and return the number of times each lowercase vowel appears in it.
Also write a program to test your function.
Write a progam that reads a string and outputs the number of times each lowercase vowel appears in it.
Your program must contain a function with one of its parameters as a char variable, and if the character is a vowel, it increments that vowel's count.
Also write a program to test your function.
The cost to become a member of a fitness center is as follows: (a) the senior citizens discount is 30%; (b) if the  is bought and paid for 12 or more months, the discount is 15%; and (c) if more than five personal training sessions are bought and paid for, the discount on each session is 20%.
Write a menu-driven program that determines the cost of a new.
Your program must contain a function that displays the general information about the fitness center and its charges, a function to get all of the necessary information to determine the  cost, and a function to determine the  cost.
Use appropriate parameters to pass information in and Write a program that outputs inflation rates for two successive years and whether the inflation is increasing or decreasing.
Ask the user to  the current price of an item and its price one year and two years ago.
To calculate the inflation rate for a year, subtract the price of the item for that year from the price of the item one year ago and then divide the result by the price a year ago.
Your program must contain at least the following functions: a function to get the , a function to calculate the results, and a function to output the results.
Use appropriate parameters to pass the information in and out of the function.
Write a program to convert the time from 24-hour notation to 12-hour notation and vice versa.
Your program must be menu driven, giving the user the choice of converting the time between the two notations.
Furthermore, your program must contain at least the following functions: a function to convert the time from 24-hour notation to 12-hour notation, a function to convert the time from 12-hour notation to 24-hour notation, a function to display the choices, function(s) to get the , and function(s) to display the results.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 6: User-Defined Functions Jason opened a coffee shop at the beach and sells coffee in three sizes: small (9oz), medium (12oz), and large (15oz).
The cost of one small cup is $1_0_75, one medium cup is $1_0_90, and one large cup is $2_0_00.
Write a menu-driven program that will make the coffee shop operational.
Your program should allow the user to do the following: Buy coffee in any size and in any number of cups.
At any time show the total number of cups of each size sold.
At any time show the total amount of coffee sold.
At any time show the total money made.
Your program should consist of at least the following functions: a function to show the user how to use the program, a function to sell coffee, a function to show the number of cups of each size sold, a function to show the total amount of coffee sold, and a function to show the total money made.
Your program should not use any global variables and special values such as coffee cup sizes and cost of a coffee cup must be declared as named constants.
Your objective is to determine the dimensions, that is, the length and width, and the side of the square to be cut from the corners so that the resulting box is of maximum length.
The program then outputs the length and width of the cardboard and the length of the side of the square to be cut from the corner so that the resulting box is of maximum volume.
Calculate your answer to three decimal places.
Your program must contain a function that takes as input the length and width of the cardboard and returns the side of the square that should be cut to maximize the volume.
The function also returns the maximum volume.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
It costs $7 per foot to run power lines over land and $9 per foot to run them under water.
Your objective is to determine the most economical path to lay the power line.
That is, determine how long the power line should run under water and how long it should run over land to achieve the minimum total cost of laying the power line.
The The The The width of the river distance of the factory downstream on the other side of the river cost of laying the power line under water cost of laying the power line over land The program then outputs the length of the power line that should run under water and the length that should run over land so the cost of constructing the power line is at the minimum.
The program should also output the total cost of constructing the power line.
Suppose that the widths of the two intersecting corridors are 5 feet and 8 feet (see Figure 6-19).
Your objective is to find the length of the longest pipe, rounded to the nearest foot, that can be carried level around the rightangled corner.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Pipe problem Write a program that prompts the user to input the widths of both of the hallways.
The program then outputs the length of the longest pipe, rounded to the nearest foot, that can be carried level around the right-angled corner.
The greatest common divisor, written gcd(a, b), of a and b is the largest positive integer that divides both a and b.
Your program must contain a function that takes as input two integers and returns the gcd of the integers.
Example 6-16 shows how to write a program to factor a polynomial of the form 2 + bx + c, where b and c are integers.
Modify the program so that it can also factor polynomials of the form ax2 + bx + c, where a, b, and c are integers.
Note that the polynomial –22 – 3 + 2 can be factored as: –22 – 3 + 2 = (–2 + 1) ( + 2) = – (2 – 1) ( + 2).
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Explore how the assignment statement, and arithmetic and relational operators work with enum types 3.
Explore the string data type, and learn how to use string functions to manipulate strings Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
In subsequent chapters, you worked mainly with integral and floating-point data types.
In this chapter, you will learn about the enum type.
Moreover, the statement using namespace std; (discussed in Chapter 2) is used in every Cplus_plus program that uses ANSI/ISO Standard Cplus_plus style header files.
The second half of this chapter examines the purpose of this statement.
In fact, you will learn what the namespace mechanism is.
You will also learn about the string type and many useful functions that you can use to effectively manipulate strings.
Enumeration Type This section may be skipped without any loss of continuity.
Chapter 2 defined a data type as a set of values together with a set of operations on them.
For example, the int data type consists of integers from -2,147,483,648 to 2,147,483,647 and the set of operations on these numbers—namely, the arithmetic operations (+, -, *, /, and %).
Because the main objective of a program is to manipulate data, the concept of a data type becomes fundamental to any programming language.
By providing data types, you specify what values are legal and tell the user what kinds of operations are allowed on those values.
The system thus provides you with built-in checks against errors.
The data types that you have worked with until now were mostly int, bool, char, and double.
Even though these data types are sufficient to solve just about any problem, situations occur when these data types are not adequate to solve a particular problem.
Cplus_plus provides a mechanism for users to create their own data types, which greatly enhances the flexibility of the programming language.
In this section, you will learn how to create your own simple data types, known as the enumeration types.
In ensuing chapters, you will learn more advanced techniques to create complex data types.
To define an enumeration type, you need the following items:.
A name for the data type A set of values for the data type A set of operations on the values Cplus_plus lets you define a new  data type wherein you specify its name and values, but not the operations.
Preventing users from creating their own operations helps to avoid potential system failures.
The values that you specify for the data type must be identifiers.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Enumeration Type |.
In Cplus_plus, enum is a reserved word.
By listing all of the values between the braces, you also specify an ordering between the values.
Thus, the enumeration type is an ordered set of values.
Moreover, the default value assigned to these enumerators starts at 0.
That is, the default value assigned to value1 is 0, the default value assigned to value2 is 1, and so on.
EXAMPLE 7-1 The statement: enum colors {BROWN, BLUE, RED, GREEN, YELLOW}; defines a new  type called colors, and the values belonging to this  type are BROWN, BLUE, RED, GREEN, and YELLOW.
EXAMPLE 7-2 The statement: enum standing {FRESHMAN, SOPHOMORE, JUNIOR, SENIOR}; defines standing to be an enumeration type.
The values belonging to standing are FRESHMAN, SOPHOMORE, JUNIOR, and SENIOR.
Chapter 7: User-Defined Simple Data Types, Namespaces, and the string Type.
The same rules apply to enumeration types declared outside of any blocks.
Example 7-4 illustrates this concept.
EXAMPLE 7-4 Consider the following statements: enum mathStudent {JOHN, BILL, CINDY, LISA, RON}; enum compStudent {SUSAN, CATHY, JOHN, WILLIAM}; //illegal.
Declaring Variables Once a  type is defined, you can declare variables of that type.
The syntax for declaring variables of an enum type is the same as before: dataType identifier, identifier,_0__0__0_;.
Assignment Once a variable is declared, you can store values in it.
Assuming the previous declaration, the statement: = FOOTBALL; Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Enumeration Type |.
Thus, the preceding statement is compiled, and during execution, it advances the value of  to the next value in the list.
Consider the following statements: = FOOTBALL; = <sports>( + 1);.
Relational Operators Because an enumeration is an ordered set of values, the relational operators can be used with the enumeration type.
Once again, suppose you have the enumeration type sports and the variables  and  as defined earlier.
Then: <= SOCCER is true HOCKEY > BASKETBALL is true BASEBALL <  is false Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Therefore, you can use these enumeration types in loops.
Suppose  is a variable as declared earlier.
Consider the following for loop: for ( = ;  <= SOCCER;.
This for loop has five iterations.
Using enumeration types in loops increases the readability of the program.
Input /Output of Enumeration Types Because input and output are defined only for built-in  types such as int, char, double, and so on, the enumeration type can be neither input nor output (directly).
However, you can input and output enumeration indirectly.
Example 7-5 illustrates this concept.
EXAMPLE 7-5 Suppose you have the following statements:.
The first statement defines an enumeration type, courses; the second declares a variable registered of type courses.
You can read (that is, input) the enumeration type with the help of the char  type.
Note that you can distinguish between some of the values in the enumeration type courses just by reading the first character and others by reading the first two characters.
For example, you can distinguish between ALGEBRA and BASIC just by reading the first character; you can distinguish between ALGEBRA and ANALYSIS by reading the first two characters.
To read these values from, say, the keyboard, you read two characters and then use a selection structure to assign the value to the variable registered.
Thus, you need to declare two variables of type char.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Enumeration Type |.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Similarly, you can output the enumeration type indirectly:.
For example, suppose that  = ALGEBRA;.
The following statement will output the value 0 because the (default) value assigned to ALGEBRA is 0:.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Enumeration Type | 473 Functions and Enumeration Types You can pass the enumeration type as a parameter to functions just like any other simple data type—that is, by either value or reference.
Also, just like any other simple data type, a function can return a value of the enumeration type.
Using this facility, you can use functions to  and output enumeration types.
The following function inputs data from the keyboard and returns a value of the enumeration type.
Assume that the enumeration type courses is defined as before:.
The following function outputs an enumeration type value: {.
Declaring Variables When Defining the Enumeration Type In previous sections, you first defined an enumeration type and then declared variables of that type.
Cplus_plus allows you to combine these two steps into one.
That is, you can declare variables of an enumeration type when you define an enumeration type.
For example, the statement: enum grades {A, B, C, D, F} courseGrade; defines an enumeration type, grades, and declares a variable courseGrade of type grades.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Enumeration Type |.
Anonymous Data Types A data type wherein you directly specify values in the variable declaration with no type name is called an anonymous type.
The following statement creates an anonymous type: enum {BASKETBALL, FOOTBALL, BASEBALL, HOCKEY} mySport; This statement specifies the values and declares a variable mySport, but no name is given to the data type.
Creating an anonymous type, however, has drawbacks.
First, because there is no name for the type, you cannot pass an anonymous type as a parameter to a function, and a function cannot return an anonymous type value.
Second, values used in one anonymous type can be used in another anonymous type, but variables of those types are treated differently.
Consider the following statements: enum {ENGLISH, FRENCH, SPANISH, GERMAN, RUSSIAN} ; enum {ENGLISH, FRENCH, SPANISH, GERMAN, RUSSIAN} foreignLanguages;.
To avoid confusion, first define an enumeration type and then declare the variables.
We now describe the typedef statement in Cplus_plus.
The general syntax of the typedef statement is: typedef existingTypeName newTypeName; In Cplus_plus, typedef is a reserved word.
Note that the typedef statement does not create any new  type; it only creates an alias to an existing  type.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 7: User-Defined Simple Data Types, Namespaces, and the string Type.
Using the typedef statement, you can create your own   type, as shown in Example 7-7.
EXAMPLE 7-7 From Chapter 4, recall that logical () expressions in Cplus_plus evaluate to 1 or 0, which are, in fact, int values.
As a logical value, 1 represents true and 0 represents false.
Consider the following statements:.
The statements in Lines 2 and 3 declare the named constants  and  and initialize them to 1 and 0, respectively.
The statement in Line 4 declares  to be a variable of type.
Because  is a variable of type , the following statement is legal: = ; Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Programming Example: The Game of Rock, Paper, and Scissors | 477 PROGRAMMING EXAMPLE: Watch the Video The Game of Rock, Paper, and Scissors Children often play the game of rock, paper, and scissors.
This game has two players, each of whom chooses one of the three objects: rock, paper, or scissors.
If player 1 chooses rock and player 2 chooses paper, player 2 wins the game because paper covers the rock.
The game is played according to the following rules:.
If both players choose the same object, this play is a tie.
If one player chooses rock and the other chooses scissors, the player choosing the rock wins this play because the rock breaks the scissors.
If one player chooses rock and the other chooses paper, the player choosing the paper wins this play because the paper covers the rock.
If one player chooses scissors and the other chooses paper, the player choosing the scissors wins this play because the scissors cut the paper.
Write an interactive program that allows two people to play this game.
Input This program has two types of input:.
The users' responses when asked to play the game.
The players' choices.
The players' choices and the winner of each play.
After the game is over, the total number of plays and the number of times that each player won should be output as well.
Two players play this game.
Players enter their choices via the keyboard.
Each player enters R or r for Rock, P or p for Paper, or S or s for Scissors.
While the first player enters a choice, the second player looks elsewhere.
Once both entries are in, if the entries are valid, the program outputs the players' choices and declares the winner of the play.
The game continues until one of the players decides to quit the game.
After the game ends, the program outputs the total number of plays and the number of times that each player won.
This discussion translates into the following algorithm: Output PROBLEM ANALYSIS AND ALGORITHM DESIGN 1.
Provide a brief explanation of the game and how it is played.
Ask the users if they want to play the game.
Get plays for both players.
If the plays are valid, output the plays and the winner.
Update the total game count and winner count.
Repeat Steps 2 through 5 while the users agree to play the game.
Output the number of plays and times that each player won.
We will use the enumeration type to describe the objects.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Chapter 7: User-Defined Simple Data Types, Namespaces, and the string Type Variables It is clear that you need the following variables in the function main: int gameCount; //variable to store the number of //games played int winCount1; //variable to store the number of games.
The only valid selections are R, r, P, p, S, and s.
Function This function has no parameters.
It consists only of output statements to explain the displayRules game and rules of play.
Essentially, this function's definition is:.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Programming Example: The Game of Rock, Paper, and  | 479 cout << << cout << cout << << cout << << cout << << cout << << cout << <<.
Function Because the enumeration type cannot be read directly, this function converts the entered retrievePlay choice (R, r, P, p, S, or s) and returns the appropriate object type.
This function thus has one parameter, of type char.
It is a value-returning function, and it returns a value of type objectType.
In pseudocode, the algorithm of this function is: if selection is 'R' or 'r' return ROCK; if selection is 'P' or 'p' return PAPER; if selection is 'S' or 's' return SCISSORS; Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Clearly, this function has three parameters: player 1's choice, player 2's choice, and a parameter to return the winner.
In pseudocode, this function is: a.
Output  player's choice.
Determine the winning player.
Return the winning player via a reference parameter to the function main so that the function main can update the winning player's win count.
Function Because enumeration types cannot be output directly, let's write the function convertEnum convertEnum to output objects of the enum type objectType.
This function has one parameter, of type objectType.
It outputs the string that corresponds to the objectType.
In pseudocode, this function is: if  is ROCK The definition of the function convertEnum is:.
Function To decide the  of the game, you look at the players' selections and then at the winningObject rules of the game.
For example, if one player chooses  and another chooses PAPER, the player who chose PAPER.
In other words, the winning  is PAPER.
The function winningObject, given two objects, decides and returns the winning.
Clearly, this function has two parameters of type objectType, and the value returned by this function is also of type objectType.
The definition of this function is:.
Function After the game is over, this function outputs the final results—that is, the total displayResults number of plays and the number of plays won by each player.
The total number of plays is stored in the variable gameCount, the number of plays won by player 1 is stored in the variable winCount1, and the number of plays won by player 2 is stored in the variable winCount2.
This function has three parameters corresponding to these three variables.
Essentially, the definition of this function is:.
Declare the variables.
Initialize the variables.
Display the rules.
Prompt the users to  the game.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: The Game of Rock, Paper, and Scissors.
Prompt player 1 to make a selection.
Prompt player 2 to make a selection.
If both plays are legal: { i.
Increment the total game count.
Increment the 's game win count by 1.
Namespaces In July 1998, ANSI/ISO Standard Cplus_plus was officially approved.
Most recent compilers are also compatible with ANSI/ISO Standard Cplus_plus.
The ANSI/ISO Standard Cplus_plus language has some features that are not available in Standard Cplus_plus, which the remainder of this chapter addresses.
In subsequent chapters, unless specified otherwise, the Cplus_plus syntax applies to both standards.
First, we discuss the namespace mechanism of the ANSI/ISO Standard Cplus_plus, which was introduced in Chapter 2.
When a header file, such as iostream, is included in a program, the global identifiers in the header file also become the global identifiers in the program.
Therefore, if a global identifier in a program has the same name as one of the global identifiers in the header file, the compiler generates a syntax error (such as "identifier redefined").
The same problem can occur if a program uses third-party libraries.
To overcome this problem, third-party vendors begin their global identifiers with a special symbol.
In Chapter 2, you learned that because compiler vendors begin their global identifier names with an underscore (_), to avoid linking errors, you should not begin identifier names in your program with an underscore (_).
ANSI/ISO Standard Cplus_plus tries to solve this problem of overlapping global identifier names with the namespace mechanism.
The general syntax of the statement namespace is: namespace namespace_name { members } where members is usually named constants, variable declarations, functions, or another namespace.
Note that namespace_name is a Cplus_plus identifier.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 7: User-Defined Simple Data Types, Namespaces, and the string Type In Cplus_plus, namespace is a reserved word.
EXAMPLE 7-8 The statement: namespace globalType.
The scope of a namespace member is local to the namespace.
You can usually access a namespace member outside the namespace in one of two ways, as described below.
The general syntax for accessing a namespace member is: namespace_name::identifier Recall that in Cplus_plus, :: is called the scope resolution operator.
To access the member  of the namespace globalType, the following statement is required: globalType:: To access the member printResult (which is a function), the following statement is required: globalType::printResult(); Thus, to access a member of a namespace, you use the namespace_name, followed by the scope resolution operator, followed by the member name.
To simplify the accessing of a namespace member, ANSI/ISO Standard Cplus_plus provides the use of the statement using.
The syntax to use the statement using is as follows: a.
To simplify the accessing of all namespace members:.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
In Cplus_plus, using is a reserved word.
You typically put the using statement after the namespace declaration.
For the namespace globalType, for example, you usually write the code as follows: namespace globalType.
After the using statement, to access a namespace member, you do not have to put the namespace_name and the scope resolution operator before the namespace member.
However, if a namespace member and a global identifier in a program have the same name, to access this namespace member in the program, the namespace_name and the scope resolution operator must precede the namespace member.
Similarly, if a namespace member and an identifier in a block have the same name, to access this namespace member in the block, the namespace_name and the scope resolution operator must precede the namespace member.
Examples 7-9 through 7-12 help clarify the use of the namespace mechanism.
EXAMPLE 7-9 Consider the following Cplus_plus code: # <iostream> using namespace std;.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 7: User-Defined Simple Data Types, Namespaces, and the string Type In this example, you can refer to the global identifiers of the header file iostream, such as cin, cout, and endl, without using the prefix std:: before the identifier name.
The obvious restriction is that the block (or function) that refers to the global identifier (of the header file iostream) must not contain any identifier with the same name as this global identifier.
EXAMPLE 7-11 Consider the following Cplus_plus code: # <iostream>.
In this example, the function main can refer to the global identifiers of the header file iostream without using the prefix std:: before the identifier name.
The using Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Therefore, other functions (if any) should use the prefix std:: before the name of the global identifier of the header file iostream unless the function has a similar using statement.
To refer to the variable  in Line 2 in main, use the scope resolution operator, which is :: (that is, refer to  as ::), because the function main has a variable named  (declared in Line 9).
For example, to copy the value of  into , you can use the statement :: = ;.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 7: User-Defined Simple Data Types, Namespaces, and the string Type 2.
To refer to the member  (declared in Line 5) of the namespace expN because there is a global variable named  (declared in Line 2) and a variable named  in main.
To refer to the member u (declared in Line 6) of the namespace expN because there is a global variable named u (declared in Line 3).
You can reference the member  (declared in Line 4) of the namespace expN in main as either  or expN:: because there is no global identifier named  and the function main does not contain any identifier named.
The definition of a function that is a member of a namespace, such as printResult, is usually written outside the namespace as in the preceding program.
To write the definition of the function printResult, the name of the function in the function heading can be either printResult or expN::printResult (because no other global identifier is named printResult).
The identifiers in the system-provided header files, such as iostream, cmath, and iomanip, are defined in the namespace std.
For this reason, to simplify the accessing of identifiers from these header files, we have been using the following statement in the programs that we write: using namespace std; string Type In Chapter 2, you were introduced to the data type string.
Recall that prior to the ANSI/ISO Cplus_plus language standard, the Standard Cplus_plus library did not provide a string data type.
Compiler vendors often supplied their own programmer-defined string type, and the syntax and semantics of string operations often varied from vendor to vendor.
The data type string is a programmer-defined type and is not part of the Cplus_plus language; the Cplus_plus standard library supplies it.
Before using the data type string, the program must  the header file string, as follows: # <string> Recall that in Cplus_plus, a string is a sequence of zero or more characters, and strings are enclosed in double quotation marks.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The position of the first character, W, in  is 0; the position of the second character, i, is 1; and so on.
That is, the position of the first character in a string variable starts with 0, not 1.
The variable  can store (just about) any size string.
Chapter 3 discussed I/O operations on the string type; Chapter 4 explained relational operations on the string type.
We recommend that you revisit Chapters 3 and 4 and review the I/O and relational operations on the string type.
Other operators, such as the binary operator + (to allow the string concatenation operation) and the array index (subscript) operator [], have also been defined for the data type string.
Let's see how these operators work on the string data type.
Suppose you have the following declarations: string 1, 2, 3;.
Therefore, the new  of 1 is "Hello Mickey".
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 7: User-Defined Simple Data Types, Namespaces, and the string Type.
Recall that the position of the first character in a string variable is 0.
Therefore, because  is the seventh character in 1, its position is 6.
In Cplus_plus, [] is called the array subscript operator.
As illustrated previously, using the array subscript operator together with the position of the character, you can access an individual character within a string.
EXAMPLE 7-13 The following program shows the effect of the preceding statements.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sample Run: In the following sample run, the user input is shaded.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The following table describes some of these functions.
In this table, we assume that strVar is a string variable and  is a string variable, a string constant, or a character array.
TABLE 7-1 Some string functions.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The search starts at pos.
Returns a string that is a substring of starting at pos.
The length of the substring is at most len characters.
If len is too large, it means "to the end" of the string in.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 7: User-Defined Simple Data Types, Namespaces, and the string Type Next, we show how some of these functions work.
Consider the following statements: string string string string string string string.
Returns false Returns true 4 ¼ "Cplus_plus program_0_"; Outputs 9 Outputs 15 Outputs 12 Outputs 36 The value of  is 15.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sample Run: 9: 3: computer science 11: After clear, 3:.
The details are left as an exercise for you.
Notice that this program uses the static cast operator to output the value returned by the Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 7: User-Defined Simple Data Types, Namespaces, and the string Type function.
This is because the function  returns a value of the type string::size_type.
Without the cast operator, some compilers might give the following warning message: conversion from 'size_t' to 'unsigned int', possible loss of data Suppose 1 and 2 are of type string.
The following are valid calls to the.
Effect Outputs 11 Outputs 3 Outputs 14 Outputs  value of string::npos Outputs 8 Assigns 25 to Note that  search  case sensitive.
Therefore,   of o (lowercase o) in string   16.
Sample Run: 4: 5: 6: 7: 8: 9: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from  eBook and/or eChapter().
Editorial review has deemed that any suppressed content does not materially affect  overall learning experience.
Cengage Learning reserves  right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 7: User-Defined Simple Data Types, Namespaces, and  string Type The output of this program  self-explanatory.
The details are left as an exercise for you.
Notice that this program uses  static cast operator to output  value returned by function find.
This  because  function find returns a value of  type string::size_type.
Without  cast operator, some compilers might give following warning message: conversion from 'size_t' to 'unsigned int', possible loss of data Suppose that you have  following statements: string string string string string.
Sample Run: 6:  = Cloudy and warm.
The output of this program is self-explanatory.
The details are left as an exercise for you.
Chapter 7: User-Defined Simple Data Types, Namespaces, and the string Type.
Effect Outputs: It is Outputs: cloudy Outputs: cloudy and warm.
Outputs: is clo.
The output of this program is self-explanatory.
The details are left as an exercise for you.
The swap function is used to swap—that is, interchange—the contents of two string variables.
Suppose you have the following statements: string 1 = "Warm"; string 2 = "Cold";.
Additional string functions are described in Appendix F (Header File string).
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Pig Latin Strings In this programming example, we write a program that prompts the user to input a string and then outputs the string in the pig Latin form.
The rules for converting a string into pig Latin form are as follows: 1.
If the string begins with a vowel, add the string "-way" at the end of the string.
For example, the pig Latin form of the string "eye" is "eye-way".
If the string does not begin with a vowel, first add "-" at the end of the string.
Then rotate the string one character at a time; that is, move the first character of the string to the end of the string until the first character of the string becomes a vowel.
Then add the string "ay" at the end.
For example, the pig Latin form of the string "There" is "ere-Thay".
Strings such as "by" contain no vowels.
In cases like this, the letter y can be considered a vowel.
So, for this program, the vowels are a, e, i, o, u, y, A, E, I, O, U, and Y.
Therefore, the pig Latin form of "by" is "y-bay".
Strings such as "1234" contain no vowels.
The pig Latin form of the string "1234" is "1234-way".
That is, the pig Latin form of a string that has no vowels in it is the string followed by the string "-way".
PROBLEM ANALYSIS AND ALGORITHM DESIGN Input.
Output of the program is the string in the pig Latin form.
Suppose that  denotes a string.
To convert  into pig Latin, check the first character, [0], of.
If [0] is a vowel, add "-way" at the end of — that is,  =  + "-way".
Suppose that the first character of , [0], is not a vowel.
First, add "-" at the end of the string.
Then, remove the first character of  from  and put it at the end of.
Now, the second character of  becomes the first character of.
This process of checking the first character of  and moving it to the end of  if the first character of  is not a vowel is repeated until either the first character of is a vowel or all the characters of  are processed, in which case  does not contain any vowels.
In this program, we write a function isVowel to determine whether a character is a vowel, a function rotate to move the first character of  to the end of , and Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: Pig Latin Strings | 505 a function pigLatinString to find the pig Latin form of.
The previous discussion translates into the following algorithm: 1.
Find the pig Latin form of  by using the function pigLatinString.
Output the pig Latin form of.
Before writing the main algorithm, each of these functions is described in detail.
Function This function takes a character as a parameter and returns true if the character is isVowel a vowel and false otherwise.
The definition of the function isVowel is: { { case 'A': case 'E': case 'I': case 'O': case 'U': case 'Y': case 'a': case 'e': case 'i': case 'o': case 'u': case 'y': return true;.
This is done by extracting the substring, starting at position 1 (which is the second character) until the end of the , and then adding the first character of the.
The new  is returned as the value of this.
Chapter 7: User-Defined Simple Data Types, Namespaces, and the  Type Function This function takes a , pStr, as a parameter and returns the pig Latin form pigLatinString of pStr.
Suppose pStr denotes the  to be converted to its pig Latin form.
There are three possible cases: pStr[0] is a vowel, pStr contains a vowel and the first character of pStr is not a vowel, or pStr contains no vowels.
Suppose that pStr[0] is not a vowel.
Move the first character of pStr to the end of pStr.
This process is repeated until either the first character of pStr has become a vowel or all the characters of pStr are checked, in which case pStr does not contain any vowels.
This discussion translates into the following algorithm: 1.
If pStr[0] is a vowel, add "-way" at the end of pStr.
Suppose pStr[0] is not a vowel.
Move the first character of pStr to the end of pStr.
The second character of pStr becomes the first character of pStr.
Now pStr may or may not contain a vowel.
We use a bool variable, foundVowel, which is set to true if pStr contains a vowel and false otherwise.
Suppose that  denotes the length of pStr.
Initialize foundVowel to false.
If pStr[0] is not a vowel, move pStr[0] to the end of pStr by calling the function rotate.
Repeat Step b until either the first character of pStr becomes a vowel or all the characters of  have been checked.
Convert  into the pig Latin form.
The definition of the function pigLatinString is:.
Programming Example: Pig Latin Strings |.
Call the function pigLatinString to find the pig Latin form of the.
Output the pig Latin form of the.
Sample Runs: In these sample runs, the user input is shaded.
Sample Run 1: Enter a : eye The pig Latin form of eye is: eye-way Sample Run 2: Enter a : There The pig Latin form of There is: ere-Thay Sample Run 3: Enter a : why The pig Latin form of why is: y-whay Sample Run 4: Enter a : 123456 The pig Latin form of 123456 is: 123456-way QUICK REVIEW 1.
An enumeration type is a set of ordered values.
Cplus_plus's reserved word enum is used to create an enumeration type.
The syntax of enum is: enum typeName {value1, value2,_0__0__0_}; 4.
No arithmetic operations are allowed on the enumeration type.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Quick Review | 5.
Enumeration type values cannot be input or output directly.
Enumeration types can be passed as parameters to functions either by value or by reference.
A function can return a value of the enumeration type.
An anonymous type is one in which a variable's values are specified without any type name.
Cplus_plus's reserved word typedef is used to create synonyms or aliases to previously defined data types.
Anonymous types cannot be passed as parameters to functions.
The namespace mechanism is a feature of ANSI/ISO Standard Cplus_plus.
A namespace member is usually a named constant, variable, function, or another namespace.
The scope of a namespace member is local to the namespace.
One way to access a namespace member outside the namespace is to precede the namespace member name with the namespace name and scope resolution operator.
In Cplus_plus, namespace is a reserved word.
To use the namespace mechanism, the program must  the ANSI/ ISO Standard Cplus_plus header files—that is, the header files without the extension h.
The using statement simplifies the accessing of namespace members.
In Cplus_plus, using is a reserved word.
The keyword namespace must appear in the using statement.
When accessing a namespace member without the using statement, the namespace name and the scope resolution operator must precede the name of the namespace member.
To use an identifier declared in the standard header files without the namespace name, after including all the necessary header files, the following statement must appear in the program: using namespace std; 23.
A string is a sequence of zero or more characters.
Strings in Cplus_plus are enclosed in double quotation marks.
To use the type string, the program must  the header file string.
The other header files used in the program should be ANSI/ ISO Standard Cplus_plus style header files.
The assignment operator can be used with the string type.
The operator + can be used to concatenate two values of the type string.
For the operator + to work with the string data type, one of the operands of + must be a string variable.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 7: User-Defined Simple Data Types, Namespaces, and the string Type Relational operators, discussed in Chapter 4, can be applied to the string type.
In a string, the position of the first character is 0, the position of the second character is 1, and so on.
The length of a string is the number of characters in the string.
In Cplus_plus, [] is called the array subscript operator.
To access an individual character within a string, use the array subscript operator together with the position of the character.
The string type contains functions such as at, append, clear, compare, erase, find, find_first_of, find_first_not_of, insert, length, replace, size, substr, and swap to manipulate strings.
These functions are described in Table 7-1.
EXERCISES The number in parentheses at the end of an exercise refers to the learning objective listed at the beginning of the chapter.
The only arithmetic operations allowed on the enumeration type are You can input the value of an enumeration type directly from a standard The following are legal Cplus_plus statements in the same block of a Cplus_plus enum mathStudent {BILL, JOHN, LISA, RON, CINDY, SHELLY};.
You can use the namespace mechanism with header files with the Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
After the statement [1] = 'a';, the value = "abcd".
After the statement: =  + "ABCD"; 2.
Define an enum type, birdType, with the values PEACOCK, SPARROW, CANARY, PARROT, PENGUIN, OSTRICH, EAGLE, CARDINAL, and HUMMINGBIRD.
Declare a variable bird of the type birdType.
Assign CANARY to the variable bird.
Advance bird to the next value in the list.
Decrement bird to the previous value in the list.
Output the value of the variable bird.
Input value in the variable bird.
What is the value, if any, of the following expression.
What is the value, if any, of the expression:  <= KIWI What is the output, if any, of the following code.
Chapter 7: User-Defined Simple Data Types, Namespaces, and the string Type that the enum birdType is as defined in Exercise 2.
Write a Cplus_plus function that can be used to input value in a variable of type that the enum birdType is as defined in Exercise 2.
Write a Cplus_plus function that can be used to ouput the value of a variable of type Define an enumeration type triangleType with values EQUILATERAL, RIGHT, ISOSCELES, and SCALENE.
Also declare the variable triangle of.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
What is the output if the input is Hello There 2.
What is the output if the input is Diamond Gold 0.
What is the output if the input is Cplus_plus Java 1.
Suppose that you have the following statements:.
What is the output if the input is Programming Project.
What is the output if the input is Summer Trip.
What is the output if the input is Winter Cold.
Chapter 7: User-Defined Simple Data Types, Namespaces, and the string Type PROGRAMMING EXERCISES 1.
Define an enumeration type, triangleType, that has the values scalene, isosceles, equilateral, and noTriangle.
Write  function, triangleShape, that takes as parameters three numbers, each of which represents the  of  side of the triangle.
The function should return the shape of the triangle.
Write  program that prompts the user to input the  of the sides of triangle and outputs the shape of the triangle.
Redo Programming Exercise 14 of Chapter 4 (cell phone company) so that all of the named constants are defined in  namespace.
The Programming Example: Pig Latin Strings converts  string into the pig Latin form, but it processes only one word.
Rewrite the program so that it can be used to process  text of an unspecified.
If  word ends with punctuation mark, in the pig Latin form, put the punctuation at the end of the string.
For example, the pig Latin form of Hello.
Assume that the text contains the following punctuation marks: , (comma), (period),.
The program then uses the function  to remove all the vowels from the string.
For example, if = "There", then after removing all the vowels,  = "Thr".
After removing all the vowels, output the string.
Your program must contain function to remove all the vowels and  function to determine whether character is  vowel.
Write  program that can be used to calculate the federal tax.
The tax is calculated as follows: For single people, the standard exemption is $4,000; for married people, the standard exemption is $7,000.
A person can also put up to 6% of his or her gross income in  pension plan.
The tax rates are as follows: If the taxable income is:.
Between $0 and $15,000, the tax rate is 15%.
Between $15,001 and $40,000, the tax is $2,250 plus 25% of the taxable income over $15,000.
Over $40,000, the tax is $8,460 plus 35% of the taxable income over $40,000.
Prompt the user to enter the following information:.
Marital status If the marital status is "married," ask for the number of children under the age of 14 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter().
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Gross salary (If the marital status is "married" and both spouses have.
Percentage of gross income contributed to a pension fund Your program must consist of at least the following functions: a.
Function getData: This function asks the user to enter the relevant data.
Function taxAmount: This function computes and returns the tax owed.
To calculate the taxable income, subtract the sum of the standard exemption, the amount contributed to a pension plan, and the personal exemption, which  $1,500 per person.
Double the number.
Reverse the digits of the number.
Raise the number to the power of 2, 3, or 4.
Sum the digits of the number.
If the number  a two digit number, then raise the first digit to the power of the second digit.
If the number  a three digit number and the last digit  less than or equal to 4, then raise the first two digits to the power of the last digit.
After performing an operation if the number  less than 10, add 10 to the number.
Also, after each operation determine if the number  prime.
Each successive operation should be performed on the number generated by the last operation.
Your program should not contain any global variables and each of these operations must be implemented by a separate function.
Also, your program should be menu driven.
Fractions are of the form a/b, in which a and b are integers and b 6¼ 0.
Your program must be menu driven, allowing the user to select the operation (+, -, *, or /) and input the numerator and denominator of each fraction.
Furthermore, your program must consist of at least the following functions: a.
Function menu: This function informs the user about the program's purpose, explains how to enter data, and allows the user to select the operation.
Function addFractions: This function takes as input four integers representing the numerators and denominators of two fractions, adds the fractions, and returns the numerator and denominator of the result.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 7: User-Defined Simple Data Types, Namespaces, and the string Type Function subtractFractions: This function takes as input four integers representing the numerators and denominators of two fractions, subtracts the fractions, and returns the numerator and denominator of the Function multiplyFractions: This function takes as input four integers representing the numerators and denominators of two fractions, multiplies the fractions, and returns the numerators and denominators of Function divideFractions: This function takes as input four integers representing the numerators and denominators of two fractions, divides the fractions, and returns the numerator and denominator of the result.
Some sample outputs are: 3 / 4 + 2 / 5 = 23 / 20 2 / 3 * 3 / 5 = 6 / 15 8.
Your answer need not be in the lowest terms.
Write a program that reads in a line consisting of a student's name, Social Security number, user ID, and password.
The program outputs the string in which all the digits of the Social Security number and all the characters in the password are replaced by x.
Use the appropriate functions described in Table 7-1.
You are given a file consisting of students' names in the following form: lastName, firstName middleName.
Your program must read each student's entire name in a variable and must consist of a function that takes as input a string, consists of a student's name, and returns the string consisting of the altered name.
Use the string function find to find the index of ,; the function length to find the length of the string; and the function substr to extract the firstName, middleName, and lastName.
An oil slick occurs when an underwater refinery pipe ruptures, pumping oil into the water.
The spilled oil sits on top of the water and causes a natural disaster.
For simplicity, suppose that the oil sits on top of the water in the form of a circle.
Write a program that prompts the user to enter the rate at which the ruptured pipe pumps oil (in gallons) per minute, the thickness of the oil on top of the water, and the number of days for which the area and the volume of oil (in gallons) on top of the water after each day.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Learn about multidimensional arrays Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
In Chapter 2, you learned that Cplus_plus data types fall into three categories: simple, structured, and pointers.
One of these categories is the structured data type.
This chapter and the next few chapters focus on structured data types.
Recall that a data type is called simple if variables of that type can store only one value at a time.
In contrast, in a structured data type, each data item is a collection of other data items.
Simple data types are building blocks of structured data types.
The first structured data type that we will discuss is an array.
In Chapters 9 and 10, we will discuss other structured data types.
Before formally defining an array, let us consider the following problem.
We want to write a Cplus_plus program that reads five numbers, finds their sum, and prints the numbers in reverse order.
In Chapter 5, you learned how to read numbers, print them, and find the sum and average.
Suppose that you are given five test scores and you are asked to write a program that finds the average test score and output all the test scores that are less than the average test score.
After introducing //Program to find the average test score and output the average //test score and all the test scores that are less than.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sample Run: In this sample run, the user input is shaded.
Enter five  scores: 85 62 94 56 71 The    = 73_0_60 62 is less than the.
This program works fine.
However, if you need to read and process 100  scores, you would have to declare 100 variables and write many cin, , and if statements.
Thus, for large amounts of data, this type of program is not efficient.
Note the following in the previous program: 1.
Five variables must be declared because  scores less than the scores need to be printed.
All  scores are of the same data type, int.
The way in which these variables are declared indicates that the variables to store these numbers all have the same name—except the last character, which is a number.
All the if statements are similar, except the name of the variables to store the  scores.
Now, (1) tells you that you have to declare five variables.
Next, (3) and (4) tell you that it would be convenient if you could somehow put the last character, which is a number, into a counter variable and use one for loop to count from 0 to 4 for reading and another for loop to process the if statements.
Finally, because all variables are of the same type, you should be able to specify how many variables must be declared—and their data type—with a simpler statement than a brute force set of variable declarations.
The data structure that lets you do all of these things in Cplus_plus is called an array.
Arrays An array is a collection of a  number of components (also called elements) all of the same data type and in contiguous (that is, adjacent) memory space.
A one-dimensional array is an array in which the components are arranged in a list form.
This section discusses only onedimensional arrays.
Arrays of two dimensions or more are discussed later in this chapter.
The general form for declaring a one-dimensional array is: dataType arrayName[intExp]; Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Chapter 8: Arrays and Strings in which intExp specifies the number of components in the array and can be any constant expression that evaluates to a positive integer.
EXAMPLE 8-1 The statement: int num[5]; declares an array num of five components.
The component names are num[0], num[1], num[2], num[3], and num[4].
Figure 8-1 illustrates the array num.
Array num Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The index value specifies the position of the component in the array.
In Cplus_plus, [] is an operator called the array subscripting operator.
Moreover, in Cplus_plus, the array index starts at 0.
Consider the following statement: int list[10]; This statement declares an array list of 10 components.
In other words, we have declared 10 variables (see Figure 8-3).
Now, If  is 4, then the assignment statement: [2 *  - 3] = 58; stores 58 in [5] because 2 *  - 3 evaluates to 5.
The index expression is evaluated first, giving the position of the component in the array.
EXAMPLE 8-2 You can also declare arrays as follows: const int  = 10; int [];.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The statement in Line 2 asks the user to enter the size of the array when the program executes.
The statement in Line 3 inputs the size of the array into arraySize.
When the compiler compiles Line 1, the value of the variable arraySize is unknown.
Thus, when the compiler compiles Line 5, the size of the array is unknown and the compiler will not know how much memory space to allocate for the array.
In Chapter 12, you will learn how to specify the size of an array during program execution and then declare an array of that size using pointers.
Arrays that are created by using pointers during program execution are called dynamic arrays.
For now, whenever you declare an array, its size must be known.
Processing One-Dimensional Arrays Some of the basic operations performed on a one-dimensional array are initializing, inputting data, outputting data stored in an array, and finding the largest and/or smallest element.
Moreover, if the data is numeric, some other basic operations are finding the sum and average of the elements of the array.
Each of these operations requires the ability to step through the elements of the array.
This is easily accomplished using a loop.
For example, suppose that we have the following statements: int [100];.
The following for loop steps through each element of the array , starting at the first element of :.
If processing the  requires inputting data into , the statement in Line 2 takes the form of an input statement, such as the cin statement.
For example, the following statements read 100 numbers from the keyboard and store the numbers in :.
For example, the following statements output the numbers stored in.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Example 8-3 further illustrates how to process one-dimensional arrays.
EXAMPLE 8-3 This example shows how loops are used to process arrays.
The following declaration is used throughout this example:.
The meaning of the other statements is clear.
Initializing an array: The following loop initializes every component of the array sales to 0_0_0.
Reading data into an array: The following loop inputs the data into the array sales.
For simplicity, we assume that the data is entered from the keyboard.
Printing an array: The following loop outputs the array sales.
Finding the  and  of an array: Because the array sales, as its name implies, represents certain sales data, it is natural to find the total sale and  sale amounts.
The following Cplus_plus code finds the of the elements of the array sales and the  sale amount: = 0;.
Largest element in the array: We now discuss the algorithm to find the first occurrence of the largest element in an array—that is, the first array component with the largest value.
However, in general, the user is more interested in determining the location of the largest Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Of course, if you know the location (that is, the of the largest element in the array), you can easily determine the value of the largest element in the array.
So let us describe the algorithm to determine the  of the first occurrence of the largest element in an array—in particular, the  of the largest sale amount in the array sales.
We will use the  of the first occurrence of the largest element in the array to find the largest sale.
We assume that  will contain the  of the first occurence of the largest element in the array sales.
The general algorithm is straightforward.
Initially, we assume that the first element in the  is the largest element, so  is initialized to 0.
We then compare the element pointed to by  with every subsequent element in the.
Whenever we find an element in the array  than the element pointed to by , we update  so that it points to the new  element.
The algorithm is as follows: = 0;.
Array sales Here, we determine the largest element in the array sales.
Before the for loop begins, is initialized to 0, and the for loop initializes  to 1.
In the following, we show the values of , , and certain array elements during each iteration of the for loop.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
You can write an algorithm to find the smallest element in the array that is similar to the algorithm for finding the largest element in an array.
Recall that this program reads five test scores, finds the average test score, and outputs all the test scores that are less than the average test score.
EXAMPLE 8-4 //Program to find the average test score and output the average //test score and all the test scores that are less than the.
Sample Run: In this sample run, the user input is shaded.
Enter five test scores: 85 62 94 56 71 The  test  = 73_0_60 62 is less than the  test.
Array Index Out of Bounds.
The —say, —of an array  in bounds if   between 0 and ARRAY_ SIZE  1, that , 0 <=  <= ARRAY_SIZE  1.
If   negative or greater than ARRAY_SIZE  1, then we say that the   out of bounds.
Unfortunately, Cplus_plus does not check whether the  value  within range—that , between 0 and ARRAY_SIZE  1.
If the  goes out of bounds and the program tries to access the component specified by the , then whatever memory location indicated by the  that location  accessed.
This situation can result in altering or accessing the data of a memory location that you never intended to modify or access, or in trying to access protected memory that causes the program to instantly halt.
Consequently, several strange things can happen if the  goes out of bounds during execution.
It  solely the programmer's responsibility to make sure that the within bounds.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Logically, list[10] does not exist.
On some new , if an array  goes out of bounds in a progam, it  possible that the program terminates with an error message.
For example, see the programs Example_ArrayIndexOutOfBoundsA_0_cpp and Example_ArrayIndexOutOfBoundsB_0_cpp at the Web site accompanying this book.
Array Initialization during Declaration Like any other simple variable, an array can be initialized while it  being declared.
For example, the following Cplus_plus statement declares an array, , of five components and initializes these components.
When initializing arrays as they are declared, it  not necessary to specify the size of the array.
The size  determined by the number of initial values in the braces.
However, you must the brackets following the array name.
The previous statement , therefore, equivalent to: double [] = {12_0_25, 32_0_50, 16_0_90, 23, 45_0_68}; Although it  not necessary to specify the size of the array if it  initialized during declaration, it  a good practice to do so.
Partial Initialization of Arrays during Declaration When you declare and initialize an array simultaneously, you do not need to initialize all components of the array.
This procedure  called partial initialization of an array during declaration.
However, if you partially initialize an array during declaration, you must exercise some caution.
The following examples help to explain what happens when you declare and partially initialize an array.
The statement: int [10] = {0}; Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
The statement: int [10] = {8, 5, 12}; declares  to be an array of 10 components and initializes [0] to 8, [1] to 5, [2] to 12, and all other components to 0.
Note that, here, the size of the array in the declaration statement does matter.
For example, the statement: int [] = {5, 6, 3};.
The first two components are initialized to 4 and 7, respectively, and all other components are initialized to 0.
Suppose that you have the following statement: int [5] = {};.
Then some may initialize each element of the array  to 0.
When you partially initialize an array, then all of the elements that follow the last uninitialized element must be uninitialized.
Therefore, the following statement will result in a syntax error: int [10] = {2, 5, 6, , 8}; //illegal In this initialization, because the fourth element  uninitialized, all elements that follow the fourth element must be left unintialized.
Some Restrictions on Array Processing.
The statement in Line 1 declares and initializes the array , and the statement in Line 2 declares the array.
Note that these arrays are of the same type and have the same number of components.
Suppose that you want to copy the elements of  into the corresponding elements of.
The following statement  illegal:.
An aggregate operation on an array  any operation that manipulates the entire array as a single unit.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 8: Arrays and Strings To copy one array into another array, you must copy it component-wise—that , one component at a time.
For example, the following statements copy  into.
Note that the following statements are legal in the sense that they do not generate a syntax error; however, they do not give the desired results.
We will comment on these statements in the section Base Address of an Array and Array in Computer Memory later in this chapter.
Arrays as Parameters to Functions Now that you have seen how to work with arrays, a question naturally arises: How are arrays passed as parameters to functions.
By reference only: In Cplus_plus, arrays are passed by reference only.
Because arrays are passed by reference only, you do not use the symbol & when declaring an array as a formal parameter.
When declaring a one-dimensional array as a formal parameter, the size of the array is usually omitted.
If you specify the size of a one-dimensional array when it is declared as a formal parameter, the size is ignored by the compiler.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Consider the following function: {.
In this declaration, the size of both arrays is unspecified.
Sometimes, the number of elements in the array might be less than the size of the array.
For example, the number of elements in an array storing student data might increase or decrease as students drop or add courses.
In such situations, we want to process only the components of the array that hold actual data.
To write a function to process such arrays, in addition to declaring an array as a formal parameter, we declare another formal parameter specifying the number of elements in the array, as in the following function:.
Constant Arrays as Formal Parameters Recall that when a formal parameter is a reference parameter, then whenever the formal parameter changes, the actual parameter changes as well.
However, even though an array is always passed by reference, you can still prevent the function from changing the actual parameter.
You do so by using the reserved word const in the declaration of the formal parameter.
Consider the following function: {.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Chapter 8: Arrays and Strings Here, the function example can modify the array x, but not the array y.
Any attempt to change y results in a compile-time error.
It is a good programming practice to declare an array to be constant as a formal parameter if you do not want the function to modify the array.
EXAMPLE 8-6 This example shows how to write functions for array processing and how to declare an array as a formal parameter.
The parameter listSize specifies the.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Starting at the position specified //by src, the elements of list1 are copied into list2 //starting at the position specified by tar.
The parameter //numOfElements specifies the number of elements of list1 to //be copied into list2.
Starting at the position specified //by tar, the list2 must have enough components to copy the //elements of list1.
The following call copies all of the //elements of list1 into the corresponding positions in //list2: copyArray(list1, 0, list2, 0, numOfElements); void copyArray(int list1[], int src, int list2[],.
Base Address of an Array and Array in Computer Memory The base address of an array is the address (that is, the memory location) of the first array component.
For example, if list is a one-dimensional array, then the base address of list is the address of the component list[0].
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
This statement declares myList to be an array of five components of type int.
The computer allocates five memory spaces, each large enough to store an int value, for these components.
Moreover, the five memory spaces are contiguous.
The base address of the array myList is the address of the component myList[0].
Suppose that the base address of the array myList is 1000.
Then, the address of the component myList[0] is 1000.
Typically, the memory allocated for an int variable is four bytes.
Recall from Chapter 1 that main memory is an ordered sequence of cells, and each cell has a unique address.
Typically, each cell is one byte.
Therefore, to store a value into myList[0], starting at the address 1000, the next four bytes are allocated for myList[0].
It follows that the starting address of myList[1] is 1004, the starting address of myList[2] is 1008, and so on (see Figure 8-7).
Memory addresses myList [0].
FIGURE 8-7 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 Address of myList [0] Address of myList [1] Address of myList [2] Address of myList [3] Address of myList [4] Array myList and the addresses of its components Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
There is also a memory space associated with the identifier , and the base address of the array is stored in that memory space.
Earlier, we said that this statement will not give the desired result.
That is, this statement will not output the values of the components of.
In fact, the statement outputs the value stored in , which is the base address of the array.
This is why the statement will not generate a syntax error.
Suppose that you also have the following statement: int yourList[5]; Then, in the statement:.
It does not determine whether the elements of  are less than or equal to the corresponding elements of yourList.
The Web site accompanying this book contains the program BaseAddressOfAnArray_0_cpp, which clarifies statements such as those in Lines 2 and 3.
You might be wondering why the base  of an array is so important.
The reason is that when you declare an array, the only things about the array that the computer remembers are the name of the array, its base , the data type of each component, and (possibly) the number of components.
Using the base  of the array, the index of an array component, and the size of each component in bytes, the computer calculates the  of a particular component.
For example, suppose you want to access the value of [3].
Now, the base  of  is 1000.
Each component of  is of type int, so it uses four bytes to store a value, and the index of the desired component is 3.
To access the value of [3], the computer calculates the  1000 + 4 * 3 = 1000 + 12 = 1012.
So, starting at 1012, the computer accesses the next four bytes: 1012, 1013, 1014, and 1015.
When you pass an array as a parameter, the base  of the actual array is passed to the formal parameter.
For example, suppose that you have the following function: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
In this statement, the base  of  is passed to the formal parameter.
The definition of the function contains the statement [2] = 28;.
This statement stores 28 into [2].
To access [2], the computer calculates the  as : 1000 + 4 * 2 = 1008.
So, starting at the  1008, the computer accesses the next four bytes and stores 28.
Note that, in fact, 1008 is the  of [2] (see Figure 8-7).
It  that during the execution of the statement in Line 5, the statement in Line 4 stores the value 28 into [2].
It also  that during the execution of the function call statement in Line 5, [index] and [index] refer to the same memory space,  0 <= index and index < 5.
If Cplus_plus allowed arrays to be passed by value, the computer would have to allocate memory for the components of the formal parameter and copy the contents of the actual array into the corresponding formal parameter when the function is called.
If the array size was large, this process would waste memory as well as the computer time needed for copying the data.
That is why in Cplus_plus arrays are always passed by reference.
Functions Cannot Return a Value of the Type Array Cplus_plus does not allow functions to return a value of the type array.
Note that the functions sumArray and indexLargestElement described earlier return values of type int.
EXAMPLE 8-7 Suppose that the distance traveled by an object at time  = a1 is d1 and at time  = a2 is d2, a1 < a2.
Then the average speed of the object from time a1 to a2, that is, over the interval [a1, a2] is (d2d1)/(a2a1).
Suppose that the distance traveled by an object at certain times is given by the following table: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Then the average speed over the interval [0, 10]  (180)/(100) = 1_0_8, over the interval [10, 20]  (27 18)/(20  10) = 0_0_9, and so on.
The following program takes as input the distance traveled by an object at time 0, 10, 20, 30, 40, and 50.
The program then outputs the average speed over the intervals [10 * , 10 * ( + 1)], = 0, 1, 2, 3, and 4.
The program also outputs the maximum and minimum average speed over these intervals.
Programming Exercise 17, at the end of this chapter, asks you to modify this program so that the distance traveled by an object recorded, but not necessarily after every 10 time units.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any  if subsequent rights restrictions require it.
Enter the total distance traveled after every 10 units of.
Enter total distance traveled at  0 units: 0 Enter total distance traveled at  10 units: 25 Enter total distance traveled at  20 units: 38 Enter total distance traveled at  30 units: 52 Enter total distance traveled at  40 units: 60 Enter total distance traveled at  50 units: 72 Distance Traveled Average Speed / 0 0_0_00 0 [0, 0] 10 25_0_00 2_0_50 [0, 10] 20 38_0_00 1_0_30 [10, 20] 30 52_0_00 1_0_40 [20, 30] 40 60_0_00 0_0_80 [30, 40] 50 72_0_00 1_0_20 [40, 50] Maximum average speed: 2_0_50 Minimum average speed: 0_0_80 The output of this program  straightforward.
We leave the details as an exercise.
Integral Data Type and Array Indices The sections "Enumeration Type" and "typedef Statement" from Chapter 7 are required to understand this section.
Other than integers, Cplus_plus allows any integral type to be used as an array.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Chapter 8: Arrays and Strings As you can see, the above code  much easier to follow than the code that used integers for the For this reason, you should use the enumeration type for the array  or other integral data types wherever possible.
Note that when using the enumeration type for array indices, use the default values of the identifiers in the enumeration type.
That , the value of the first identifier must be 0, and so on.
Because the number of students can change from semester to semester, instead of specifying the size of the array while declaring it, you can declare the array as follows: const int  = 20;.
As the name implies, you search the array sequentially, starting from the first array element.
You compare searchItem with the elements in the array (the ) and continue the search until either you find the item or no more data is left in the  to compare with searchItem.
Consider the  of seven elements shown in Figure 8-8.
List of seven elements Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Searching an Array for a Specific Item | 543 Suppose that you want to determine whether 27 is in the.
A sequential search works as follows: First, you compare 27 with [0], that is, compare 27 with 35 [0] 6¼ 27, you then compare 27 with [1], that is, with 12, the second item in the.
This search is successful.
Let us now search for 10.
As before, the search starts at the first element in the , that is, at [0].
Proceeding as before, we see that, this time, the search item, which is 10, is compared with every item in the.
Eventually, no more data is left in the  to compare with the search item.
This is an unsuccessful search.
It now follows that, as soon as you find an element in the  that is equal to the search item, you must stop the search and report success.
Suppose that the name of the array containing the  elements is.
The previous discussion translates into the following algorithm for the sequential search: found is set to false = 0; found is set to true else increment return ; else return -1;.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
If the function seqSearch returns a value greater than or equal to 0, it is a successful search; otherwise, it is an unsuccessful search.
As you can see from this code, you start the search by comparing searchItem with the first element in the.
If searchItem is equal to the first element in the , you exit the loop; otherwise,  is incremented by 1 to point to the next element in the You then compare searchItem with the next element in the , and so on.
EXAMPLE 8-8 // This program illustrates how to use a sequential search in a.
Searching an Array for a Specific Item |.
Sample Run 1: In this sample run, the user input is shaded.
Line 9: Enter 10.
In this section, we discuss how to sort an array using the algorithm, called selection sort.
Additional searching and sorting algorithms are discussed in Chapter 16.
As the name implies, in the selection sort algorithm, we rearrange the  by selecting an element in the  and moving it to its proper position.
This algorithm finds the location of the smallest element in the unsorted portion of the  and moves it to the top of the unsorted portion of the.
The first time, we locate the smallest item in the entire.
The second time, we locate the smallest item in the  starting from the second element in the , and so on.
List of eight elements Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Suppose you have the  shown in Figure 8-9.
FIGURE 8-10 24 swap 7 unsorted Elements of  during the first iteration Figure 8-10 shows the elements of  in the first iteration.
Initially, the entire  is unsorted.
So, we find the smallest item in the.
The smallest item is at position 6, as shown in Figure 8-10(a).
Because this is the smallest item, it must be moved to position 0.
So, we swap 16 (that is, [0]) with 5 (that is, [6]), as shown in Figure 8-10(b).
After swapping these elements, the resulting  is as shown in Figure 8-10(c).
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Searching an Array for a Specific Item | 547 Figure 8-11 shows the elements of list during the second iteration.
Now the unsorted list is list[1]_0__0__0_list[7].
So, we find the smallest element in the unsorted list.
The smallest element is at position 3, as shown in Figure 8-11(a).
Because the smallest element in the unsorted list is at position 3, it must be moved to position 1.
So, we swap 7 (that is, list[3]) with 30 (that is, list[1]), as shown in Figure 8-11(b).
After swapping list[1] with list[3], the resulting list is as shown in Figure 8-11(c).
Now, the unsorted list is list[2]_0__0__0_list[7].
So, we repeat the preceding process of finding the (position of the) smallest element in the unsorted portion of the list and moving it to the beginning of the unsorted portion of the list.
Selection sort thus involves the following steps.
In the unsorted portion of the list: a.
Find the location of the smallest element.
Move the smallest element to the beginning of the unsorted list.
Initially, the entire list (that is, list[0]_0__0__0_list[length - 1]) is the unsorted list.
After executing Steps a and b once, the unsorted list is list[1]_0__0_.
After executing Steps a and b a second time, the unsorted list is list[2]_0__0__0_list[length - 1], and so on.
In this way, we can keep track of the unsorted portion of the list and repeat Steps a and b with the help of a for loop, as shown in the following pseudocode: { a.
Find the location, smallestIndex, of the smallest element in list[]_0__0__0_list[length - 1].
Swap the smallest element with list[].
That is, swap list[] with list[].
The second time through the loop, we locate the smallest element in list[1]_0__0__0_list[length - 1] and swap the smallest element with list[1], and so on.
Step a is similar to the algorithm for finding the  of the largest item in the list, as Here, we find the  of the smallest item in the list.
The general form of Step a is: = ; //assume first element is the smallest.
Step b swaps the contents of list[] with list[].
The following statements accomplish this task: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Auto Declaration and Range-Based For Loops |.
Sample Run: After sorting, the  elements are: 2 5 10 16 25 34 46 56 73 89 The statement in Line 1 declares and initializes  to be an array of 10 components of type int.
The statement in Line 3 uses the function selectionSort to sort.
Notice that both  and its length (the number of elements in it, which is 10) are passed as parameters to the function selectionSort.
The for loop in Lines 5 and 6 outputs the elements of.
To illustrate the selection sort algorithm in this program, we declared and initialized the array However, you can also prompt the user to input the data during program execution.
Therefore, if  = 1000, then to sort the , selection sort makes about 500,000 key comparisons and about 3000 item assignments.
The next section presents the insertion sort algorithm that reduces the number of comparisons.
Auto Declaration and Range-Based For Loops Cplus_plus11 introduces auto declaration of elements, which allows a programmer to declare and initialize a variable without specifying its type.
For example, the following statement declares the variable  and stores 15 in it: auto  = 15; Because the initializer, which is 15, is an int value, the type of  will be int.
One way to process the elements of an array one-by-one, starting at the first element, is to use an  variable, initialized to 0, and a loop.
For example, to process the elements of an array, , you can use a for loop such as the following: //process [] This chapter uses these types of loops to process the elements of an array.
Cplus_plus11 provides a special type of for loop to process the elements of an array.
The syntax to use this for loop to process the elements of an array is: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
This form of the for loop is called a range-based for loop.
The for statement in Line 2 is read as "for each  in _0_" The variable  is initialized to [0].
In the next iteration, the value of  is [1], and so on.
It follows that the variable  is assigned the contents of each array element, not its value, and that the loop by default starts at 0 and traverses the entire array.
You can also use auto declaration in a range-based loop to process the elements of an array.
For example, using the range-based for loop, the for loop to find the largest element in the array  can be written as: {.
Then in the definition of the function doSomething, a range-based for loop cannot be applied to.
Recall that in Cplus_plus, arrays as parameters are passed by reference.
Therefore, when the function doSomething is called,  gets the base address of the actual parameters, that is, the base address of the actual parameter is copied into the memory space So a formal parameter  is, in fact, not an array, it is a variable to store the address of a memory , so it has no first (that is, [0]) and last elements.
Until now, we have avoided discussing character arrays for a simple reason: Character arrays are of special interest, and you process them differently than you process other arrays.
Cplus_plus provides many (predefined) functions that you can use with character arrays.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Character array: An array whose components are of type char.
Recall that the most widely used character sets are ASCII and EBCDIC.
The first character in the ASCII character set is the null character, which is nonprintable.
Also, recall that in Cplus_plus, the null character is represented as '\0', a backslash followed by a zero.
The statement: = '\0'; stores the null character in , wherein  is a char variable.
As you will see, the null character plays an important role in processing character arrays.
Because the collating sequence of the null character is 0, the null character is less than any other character in the char data set.
The most commonly used term for character arrays is C-strings.
However, there is a subtle difference between character arrays and C-strings.
Recall that a string is a sequence of zero or more characters, and strings are enclosed in double quotation marks.
In Cplus_plus, C-strings are null terminated; that is, the last character in a C-string is always the null character.
A character array might not contain the null character, but the last character in a C-string is always the null character.
As you will see, the null character should not appear anywhere in the C-string except the last position.
Also, C-strings are stored in (one-dimensional) character arrays.
The following are examples of C-strings: From the definition of C-strings, it is clear that there is a difference between 'A' and "A".
The first one is character A; the second is C-string A.
Because C-strings are null terminated, "A" represents two characters: 'A' and '\0'.
Similarly, the C-string "Hello" represents six characters: 'H', 'e', 'l', 'l', 'o', and '\0'.
To store 'A', we need only one memory cell of type char; to store "A", we need two memory cells of type char—one for 'A' and one for '\0'.
Similarly, to store the C-string "Hello" in computer memory, we need six memory cells of type char.
Consider the following statement: char [16]; This statement declares an array  of 16 components of type char.
Because C-strings are null terminated and  has 16 components, the largest string that can be stored in is of length 15, to leave room for the terminating '\0'.
If you store a C-string of length 10 in , the first 11 components of  are used and the last 5 are left unused.
The statement: char [16] = {'J', 'o', 'h', '', '\0'}; Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Chapter 8: Arrays and Strings declares an array  containing 16 components of type char and stores the C-string "John" in it.
During char array variable declaration, Cplus_plus also allows the C-string notation.
There is a difference between the last two statements: Both statements store "John" in , but the size of  in the statement in Line A is 16, and the size of in the statement in Line B is 5.
Most rules that apply to other arrays also apply to character arrays.
Consider the following statement: char [26]; Suppose you want to store "Lisa L.
Johnson"; //illegal Cplus_plus provides a set of functions that can be used for C-string manipulation.
The header file cstring defines these functions.
We often use three of these functions: strcpy (string copy, to copy a C-string into a C-string variable—that is, assignment); strcmp (string comparison, to compare C-strings); and strlen (string length, to find the length of a C-string).
Table 8-1 summarizes these functions.
TABLE 8-1 strcpy, strcmp, and strlen Functions Function.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
That is, the following statement must be included in the program: # <cstring> String Comparison In Cplus_plus, C-strings are compared character by character using the system's collating sequence.
Let us assume that you use the ASCII character set.
The C-string "Air" is less than the C-string "Boat" because the first character of "Air" is less than the first character of "Boat".
The C-string "Air" is less than the C-string "An" because the first characters of both strings are the same, but the second character 'i' of "Air" is less than the second character 'n' of "An".
The C-string "Bill" is less than the C-string "Billy" because the first four characters of "Bill" and "Billy" are the same, but the fifth character of "Bill", which is '\0' (the null character), is less than the fifth character of "Billy", which is 'y'.
The C-string "Hello" is less than "hello" because the first character 'H' of the C-string "Hello" is less than the first character 'h' of the C-string "hello".
As you can see, the function strcmp compares its first C-string argument with its second C-string argument character by character.
EXAMPLE 8-10 Suppose you have the following statements:.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Returns a value > 0 In this chapter, we defined a C-string to be a sequence of zero or more characters.
C-strings are enclosed in double quotation marks.
We also said that C-strings are null terminated, so the C-string "Hello" has six characters even though only five are enclosed in double quotation marks.
Therefore, to store the C-string "Hello" in computer memory, you must use a character array of size 6.
The length of a C-string is the number of actual characters enclosed in double quotation marks; for example, the length of the C-string "Hello" is 5.
Thus, in a logical sense, a C-string is a sequence of zero or more characters, but in the physical sense (that is, to store the C-string in computer memory), a C-string has at least one character.
Because the length of the C-string is the actual number of characters enclosed in double quotation marks, we defined a C-string to be a sequence of zero or more characters.
However, you must remember that the null character stored in computer memory at the end of the C-string plays a key role when we compare C-strings, especially C-strings such as "Bill" and "Billy".
Reading and Writing Strings As mentioned earlier, most rules that apply to arrays apply to C-strings as well.
Aggregate operations, such as assignment and comparison, are not allowed on arrays.
Even the input/ output of arrays is done component-wise.
However, the one place where Cplus_plus allows aggregate operations on arrays is the input and output of C-strings (that is, character arrays).
We will use the following declaration for our discussion: char [31];.
The length of the input C-string must be less than or equal to 30.
If the length of the input string is 4, the computer stores the four characters that are input and the null character '\0'.
If the length of the input C-string is more than 30, then because there is no check on the array index bounds, the computer continues storing the string in whatever memory cells follow name.
This process can cause serious problems, because data in the adjacent memory cells will be corrupted.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
For example, the C-string "Hello" is entered as Hello.
Recall that the extraction operator, >>, skips all leading whitespace characters and stops reading data into the current variable as soon as it finds the first whitespace character or invalid data.
As a result, C-strings that contain blanks cannot be read using the extraction operator, >>.
For example, if a first name and last name are separated by blanks, they cannot be read into name.
How do you input C-strings with blanks into a character array.
Once again, the function get comes to our rescue.
Recall that the function get is used to read character data.
Until now, the form of the function get that you have used (Chapter 3) read only a single character.
However, the function get can also be used to read strings.
To read C-strings, you use the form of the function get that has two parameters.
The first parameter is a C-string variable; the second parameter specifies how many characters to read into the string variable.
To read C-strings, the general form (syntax) of the get function, together with an input stream variable such as cin, is: cin_0_get(str, m + 1); This statement stores the next m characters, or all characters until the newline character '\n' is found, into str.
The newline character is not stored in str.
If the input C-string has fewer than m characters, then the reading stops at the newline character.
Consider the following statements: char str[31]; cin_0_get(str, 31);.
Johnson then "William T.
Johnson" is stored in str.
Suppose that the input is: Hello there.
My name is Mickey Blair.
Because str can store, at most, 30 characters, the C-string "Hello there.
My name is Mickey" is stored in str.
Summer is warm.
Winter will be cold.
Further, suppose that we want to store the first C-string in str1 and the second C-string in str2.
Both str1 and str2 can store C-strings that are up to 25 characters in length.
Because Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 8: Arrays and Strings the number of characters in the first line is 15, the reading stops at '\n'.
Now the newline character remains in the input buffer and must be manually discarded.
Therefore, you must read and discard the newline character at the end of the first line to store the second line into str2.
The following sequence of statements stores the first line into str1 and the second line into str2:.
You can output C-strings by using an output stream variable, such as , together with the insertion operator, <<.
For example, the statement: << name; outputs the contents of  on the screen.
The insertion operator, <<, continues to write the contents of  until it finds the null character.
Thus, if the length of  is 4, the above statement outputs only four characters.
If  does not contain the null character, then you will see strange output because the insertion operator continues to output data from memory adjacent to  until a '\0' is found.
For example, see the output of the.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
In subsequent chapters, the  of the input file was included in the open statement.
By doing so, the program always received data from the same input file.
In real-world applications, the data may actually be collected at several locations and stored in separate files.
Also, for comparison purposes, someone might want to process each file separately and then store the output in separate files.
To accomplish this task efficiently, the user would prefer to specify the  of the input and/or output file at execution time rather than in the programming code.
Cplus_plus allows the user to do so.
Consider the following statements:.
We now want to point out that values (that is, strings) of type string are not null terminated.
Variables of type string can also be used to read and store the names of input/output files.
However, the argument to the function open must be a null-terminated string—that is, a C-string.
Therefore, if we use a variable of type string to read the  of an input/output file and then use this variable to open a file, the value of the variable must (first) be converted to a C-string (that is, a null-terminated string).
The header file string contains the function c_str, which converts a value of type string to a null-terminated character array (that is, C-string).
The syntax to use the function c_str is: in which strVar is a variable of type string.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 8: Arrays and Strings.
Parallel Arrays Two (or more) arrays are called parallel if their corresponding components hold related information.
Suppose you need to keep track of students' course grades, together with their ID numbers, so that their grades can be posted at the end of the semester.
Further, suppose that there is a maximum of 50 students in a class and their IDs are 5 digits long.
Because there may be 50 students, you need 50 variables to store the students' IDs and 50 variables to store their grades.
You can declare two arrays: studentId of type int and courseGrade of type char.
Each array has 50 components.
Furthermore, studentId[0] and courseGrade[0] will store the ID and course grade of the first student, studentId[1] and courseGrade[1] will store the ID and course grade of the second student, and so on.
The statements: int studentId[50]; char courseGrade[50]; declare these two arrays.
Suppose you need to input data into these arrays, and the data is provided in a file in the following form: studentId courseGrade For example, a sample data set is: 23456 86723 22356 92733 11892.
A B C B D Suppose that the input file is opened using the ifstream variable infile.
Because the size of each array is 50, a maximum of 50 elements can be stored into each array.
Moreover, it is possible that there may be fewer than 50 students in the class.
Therefore, Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Two- and Multidimensional Arrays.
The following loop reads the data into the parallel arrays studentId and courseGrade: int  = 0;.
Two- and Multidimensional Arrays The remainder of this chapter discusses two-dimensional arrays and ways to work with multidimensional arrays.
In the previous section, you learned how to use one-dimensional arrays to manipulate data.
If the data is provided in a list form, you can use one-dimensional arrays.
However, sometimes data is provided in a table form.
For example, suppose that you want to track the number of cars in a particular color that are in stock at a local dealership.
The dealership sells six types of cars in five different colors.
Figure 8-12 shows sample data.
Table inStock Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 8: Arrays and Strings You can see that the data is in a table format.
The table has 30 entries, and every entry is an integer.
Because the table entries are all of the same type, you can declare a onedimensional array of 30 components of type int.
The first five components of the onedimensional array can store the data of the first row of the table, the next five components of the one-dimensional array can store the data of the second row of the table, and so on.
In other words, you can simulate the data given in a table format in a one-dimensional array.
If you do so, the algorithms to manipulate the data in the one-dimensional array will be somewhat complicated, because you must know where one row ends and another begins.
You must also correctly compute the index of a particular element.
Cplus_plus simplifies the processing of manipulating data in a table form with the use of two-dimensional arrays.
This section first discusses how to declare twodimensional arrays and then looks at ways to manipulate data in a two-dimensional array.
Two-dimensional array: A collection of a fixed number of components arranged in rows and columns (that is, in two dimensions), wherein all components are of the same type.
The syntax for declaring a two-dimensional array is:.
The two expressions, intExp1 and intExp2, specify the number of rows and the number of columns, respectively, in the array.
The statement: double sales[10][5]; declares a two-dimensional array sales of 10 rows and 5 columns, in which every component is of type double.
As in the case of a one-dimensional array, the rows are numbered 0.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Two- and Multidimensional Arrays.
The syntax to access a component of a two-dimensional array is: arrayName[indexExp1][indexExp2] wherein indexExp1 and indexExp2 are expressions yielding nonnegative integer values.
The statement: [5][3] = 25_0_75; stores 25_0_75 into row number 5 and column number 3 (that is, the sixth row and the fourth column) of the array  (see Figure 8-14).
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
So the indices can also be variables.
Two-Dimensional Array Initialization during Declaration Like one-dimensional arrays, two-dimensional arrays can be initialized when they are declared.
This statement declares  to be a two-dimensional array of four rows and three columns.
The elements of the first row are 2, 3, and 1; the elements of the second row are 15, 25, and 13; the elements of the third row are 20, 4, and 7; and the elements of the fourth row are 11, 18, and 14, respectively.
Figure 8-15 shows the array.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Two- and Multidimensional Arrays [0] [1] [2] [3] FIGURE 8-15.
Two-dimensional array To initialize a two-dimensional array when it is declared: 1.
The elements of each row are all enclosed within one set of curly braces and separated by commas.
The set of all rows is enclosed within curly braces.
For number arrays, if all components of a row are not specified, the unspecified components are initialized to 0.
In this case, at least one of the values must be given to initialize all the components of a row.
Two-Dimensional Arrays and Enumeration Types The section "Enumeration Type" in Chapter 7 is required to understand this section.
These statements define the carType and colorType enumeration types and define inStock as a two-dimensional array of six rows and five columns.
Suppose that each row in inStock corresponds to a car type, and each column in inStock corresponds to a color type.
That is, the first row corresponds to the car type GM, the second row corresponds to the car type FORD, and so on.
Similarly, the first column corresponds to the color type RED, the second column corresponds to the color type BROWN, and so on.
Suppose further that each entry in inStock represents the number of cars of a particular type and color (see Figure 8-16).
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
This example illustrates that enumeration types can be used effectively to make the program readable and easy to manage.
PROCESSING TWO-DIMENSIONAL ARRAYS A two-dimensional array can be processed in three ways: 1.
Process a single element.
Process the entire array.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Two- and Multidimensional Arrays.
Process a particular row of the array, called row processing.
Process a particular column of the array, called column processing.
Processing a single element is like processing a single variable.
Initializing and printing the array are examples of processing the entire two-dimensional array.
Finding the largest element in a row (column) or finding the sum of a row (column) are examples of row (column) processing.
We will use the following declaration for our discussion: const int  = 7; //This can be set to any number.
If a row is looked at by itself, it can be seen to be just a one-dimensional array.
A column seen by itself is also a one-dimensional array.
Therefore, when processing a particular row or column of a two-dimensional array, we use algorithms similar to those that process one-dimensional arrays.
We further explain this concept with the help of the two-dimensional array matrix, as declared previously.
Suppose that we want to process row number 5 of matrix (that is, the sixth row of matrix).
The elements of row number 5 of matrix are: matrix[5][0], matrix[5][1], matrix[5][2], matrix[5][3], matrix[5][4], matrix[5][5] We see that in these components, the first index (the row position) is fixed at 5.
The second index (the column position) ranges from 0 to 5.
Therefore, we can use the following for loop to process row number 5: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 8: Arrays and Strings process matrix[5][] Clearly, this for loop is equivalent to the following for loop: = 5; process matrix[][] Similarly, suppose that we want to process column number 2 of matrix, that is, the third column of matrix.
The elements of this column are: matrix[0][2], matrix[1][2], matrix[2][2], matrix[3][2], matrix[4][2], matrix[5][2], matrix[6][2] Here, the second index (that is, the column position) is fixed at 2.
The first index (that is, the  position) ranges from 0 to 6.
In this case, we can use the following for loop to process column 2 of matrix: process matrix[][2] Clearly, this for loop is equivalent to the following for loop: = 2; process matrix[][] Next, we discuss specific processing algorithms.
Initialization Suppose that you want to initialize  number 4, that is, the fifth , to 0.
As explained earlier, the following for loop does this: = 4; matrix[][] = 0; If you want to initialize the entire matrix to 0, you can also put the first index, that is, the  position, in a loop.
By using the following nested for loops, we can initialize each component of matrix to 0: matrix[][] = 0; Print By using a nested for loop, you can output the elements of matrix.
The following nested for loops print the elements of matrix, one  per line: { Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Two- and Multidimensional Arrays.
The following for loop inputs data into each component of matrix: cin >> matrix[][]; Sum by Row.
Once again, by putting the  number in a loop, we can find the  of each.
As in the case of  by , the following nested for loop finds the  of each individual column: //Sum of each individual column.
Largest Element in Each Row and Each Column As stated earlier, two other operations on a two-dimensional array are finding the element in each  and each column and finding the  of both diagonals.
Next, we give the Cplus_plus code to perform these operations.
The following for loop determines the  element in  number 4: = 4; = matrix[][0]; //Assume that the first element of //the  is the.
Passing Two-Dimensional Arrays as Parameters to Functions Two-dimensional arrays can be passed as parameters to a function, and they are passed by reference.
The base address (that is, the address of the first component of the actual parameter) is passed to the formal parameter.
If matrix is the name of a two-dimensional array, then matrix[0][0] is the first component of matrix.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Two- and Multidimensional Arrays.
That is, the first  is stored first, followed by the second , followed by the third , and so on.
In the case of a one-dimensional array, when declaring it as a formal parameter, we usually omit the size of the array.
Because Cplus_plus stores two-dimensional arrays in order form, to compute the address of a component correctly, the compiler must know where one  ends and the next  begins.
Thus, when declaring a two-dimensional array as a formal parameter, you can omit the size of the first dimension, but not the second; that is, you must specify the number of columns.
Suppose we have the following declaration: const int  = 6; const int  = 5;.
This function takes as a parameter a two-dimensional array of an unspecified number of rows and five columns, and outputs the content of the two-dimensional array.
During the function call, the number of columns of the actual parameter must match the number of columns of the formal parameter.
Similarly, the following function outputs the  of the elements of each  of a twodimensional array whose elements are of type int:.
Chapter 8: Arrays and Strings The following function determines the  element in each : void largestInRows(int matrix[][],.
Likewise, you can write a function to find the  of the elements of each column, read the data into a two-dimensional array, find the  and/or smallest element in each or column, and so on.
Example 8-11 shows how the functions printMatrix, sumRows, and largestInRows are used in a program.
EXAMPLE 8-11 The following program illustrates how two-dimensional arrays are passed as parameters to functions.
Two- and Multidimensional Arrays.
Sample Run: 23 4 12 1 81 12 5 16 54 12 54 34 Sum Sum Sum Sum Sum Sum of of of of of of The The The The The The 6 24 23 34 32 76 1 2 3 4 5 6 = = = = = = 15 67 76 22 67 78 18 10 11 8 33 9 8 67 121 176 77 267 209 element element element element element element in in in in in in row row row row row row 1 2 3 4 5 6 = = = = = = 23 67 76 34 81 78 In this program, the statement in Line 1 declares and initializes board to be a twodimensional array of six rows and five columns.
The statement in Line 2 uses the function printMatrix to output the elements of board (see the first six lines of the Sample Run).
The statement in Line 4 uses the function sumRows to calculate and print the sum of each row.
The statement in Line 6 uses the function largestInRows to find and print the largest element in each row.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Because every name is a string, a convenient way to store the list of names is to use an array.
Strings in Cplus_plus can be manipulated using either the data type string or character arrays (C-strings).
Also, on some compilers, the data type string may not be available in Standard Cplus_plus (that is, nonANSI/ISO Standard Cplus_plus).
This section illustrates both ways to manipulate a list of strings.
Arrays of Strings and the string Type Processing a list of strings using the data type string is straightforward.
Suppose that the list consists of a maximum of 100 names.
You can declare an array of 100 components of type string as follows: string list[100]; Basic operations, such as assignment, comparison, and input/output, can be performed on values of the string type.
Therefore, the data in list can be processed just like any one-dimensional array discussed in the first part of this chapter.
Suppose that the largest string (for example, name) in your list is 15 characters long and your list has 100 strings.
You can declare a two-dimensional array of characters of 100 rows and 16 columns as follows (see Figure 8-19): char list[100][16]; list list[0] list[1] list[2] list[3] _0__0_.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Two- and Multidimensional Arrays.
The following statement stores "Snow White" in list[1] (see Figure 8-20): strcpy(list[1], "Snow White"); list list[0] list[1] S n o w list[2] list[3] W h i t e \0 _0__0_.
The following for loop accomplishes this task: cin_0_get(list[], 16);.
The data type string has operations such as assignment, concatenation, and relational operations defined for it.
If you use Standard Cplus_plus header files and the data type string is available on your compiler, we recommend that you use the data type string to manipulate lists of strings.
Another Way to Declare a Two-Dimensional Array This section may be skipped without any loss of continuity.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 8: Arrays and Strings If you know the size of the tables with which the program will be working, then you can use typedef to first define a two-dimensional array data type and then declare variables of that type.
For example, consider the following:.
By first defining a data type, you do not need to keep checking the exact number of columns when you declare a two-dimensional array as a variable or formal parameter, or when you pass an array as a parameter during a function call.
Multidimensional Arrays In this chapter, we defined an array as a collection of a fixed number of elements (called components) of the same type.
A one-dimensional array is an array in which the elements are arranged in a list form; in a two-dimensional array, the elements are arranged in a table form.
We can also define three-dimensional or larger arrays.
In Cplus_plus, there is no limit, except the limit of the memory space, on the dimension of arrays.
Following is the general definition of an array.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Two- and Multidimensional Arrays.
The syntax to access a component of an n-dimensional array is: arrayName[indexExp1][indexExp2] _0__0_.
For example, the statement: double [10][5][7]; declares  to be a three-dimensional array.
The size of the first dimension  10, the size of the second dimension  5, and the size of the third dimension  7.
The first dimension ranges from 0 to 9, the second dimension ranges from 0 to 4, and the third dimension ranges from 0 to 6.
The base address of the array   the address of the first array component—that , the address of [0][0][0].
The total number of components in the array 10 * 5 * 7 = 350.
The statement: [5][3][2] = 15564_0_75; sets the value of [5][3][2] to 15564_0_75.
You can use loops to process multidimensional arrays.
For example, the nested for loops: [][][] = 0_0_0; initialize the entire array to 0_0_0.
When declaring a multidimensional array as a formal parameter in a function, you can omit the size of the first dimension but not the other dimensions.
As parameters, multidimensional arrays are passed by reference only, and a function cannot return a value of the array type.
There  no check to determine whether the array indices are within bounds, so it  often advisable to include some form of "index-in-range" checking.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Code Detection When a message  transmitted in secret code over a transmission channel, it usually sent as a sequence of bits, that , 0s and 1s.
Due to noise in the transmission channel, the transmitted message may become corrupted.
That , the message received at the destination  not the same as the message transmitted; some of the bits may have been changed.
There are several techniques to check the validity of the transmitted message at the destination.
One technique  to transmit the same message twice.
At the destination, both copies of the message are compared bit by bit.
If the corresponding bits are the same, the message received error-free.
Let's write a program to check whether the message received at the destination error-free.
For simplicity, assume that the secret code representing the message  a sequence of digits (0 to 9) and the maximum length of the message  250 digits.
Also, the first number in the message  the length of the message.
For example, if the secret code : 7 9 2 7 8 3 5 6 then the actual message  7 digits long.
The above message  transmitted as: 7 9 2 7 8 3 5 6 7 9 2 7 8 3 5 6 Input A file containing the secret code and its copy Output The secret code, its copy, and a message—if the received code  error-free—in the following form: Code Digit Code Digit Copy 9 9 2 2 7 7 8 8 3 3 5 5 6 6 Message transmitted OK.
PROBLEM ANALYSIS AND ALGORITHM DESIGN Because we have to compare the corresponding digits of the secret code and its copy, we first read the secret code and store it in an array.
Then we read the first digit of the copy and compare it with the first digit of the secret code, and so on.
If any of the corresponding digits are not the same, we indicate this fact by printing a message next to the digits.
Because the maximum length of the message  250, we use an array of size 250.
The first number in both the secret code and the copy of the secret code indicates the length of the code.
This discussion translates into the following algorithm: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: Code Detection.
Open the input and output files.
If the input file does not exist, exit the program.
Read the length of the secret code.
If the length of the secret code  greater than 250, terminate the program because the maximum length of the code in this program  250.
Read and store the secret code into an array.
Read the length of the copy.
If the length of the secret code and its copy are the same, compare the codes and output an appropriate message.
To simplify the function main, let us write a function, readCode, to read the secret code and another function, compareCode, to compare the codes.
If the length of the secret code is greater than 250, a bool variable lenCodeOk, which is a reference parameter, is set to false and the function terminates.
The value of lenCodeOk is passed to the calling function to indicate whether the secret code was read successfully.
If the length of the code is less than 250, the readCode function reads and stores the secret code into an array.
Because the input is stored into a file and the file was opened in the function main, the input stream variable corresponding to the input file must be passed as a parameter to this function.
Furthermore, after reading the length of the secret code and the code itself, the readCode function must pass these values to the function main.
Therefore, this function has four parameters: an input file stream variable, an array to store the secret code, the length of the code, and the bool parameter.
The definition of the function readCode is as follows: void readCode(ifstream& infile, int list[], int& length,.
Therefore, it must have access to the array containing the secret code and the length of the secret code.
The copy of the secret code and its length are stored in the input file.
Thus, the input stream variable corresponding to the input file must be passed as a parameter to this function.
Also, the compareCode function compares the secret code with the copy and prints an appropriate message.
Because the output will be stored in a file, the output stream variable corresponding to the output file must also be passed as a parameter to this function.
Therefore, the function has four parameters: an input file stream variable, an output file stream variable, the array containing the secret code, and the length of the secret code.
This discussion translates into the following algorithm for the function compareCode: a.
Declare the variables.
Set a bool variable codeOk to true.
Read the length of the copy of the secret code.
If the length of the secret code and its copy are not the same, output an appropriate error message and terminate the function.
For each digit in the input file: e_0_1.
Read the next digit of the copy of the secret code.
Output the corresponding digits from the secret code and its copy.
If the corresponding digits are not the same, output an error message and set the bool variable codeOk to false.
If the bool variable codeOk is true Output a message indicating that the secret code was transmitted correctly.
Following this algorithm, the definition of the function compareCode is: void compareCode(ifstream& infile, ofstream& outfile,.
Programming Example: Code Detection {.
Declare the variables.
Open the files.
Call the function readCode to read the secret.
Call the function compareCode to compare the codes.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: Code Detection.
Sample Run: In this sample run, the user input is shaded.
Enter the input  name: Ch8_SecretCodeData_0_txt Enter the output  name: Ch8_SecretCodeOut_0_txt 7927835679278356 Code Digit Code Digit Copy 9 9 2 2 7 7 8 8 3 3 5 5 6 6 Message transmitted OK.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not  copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may  suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Text Processing (Line and letter ) Let us now write a program that reads a given text, outputs the text as is, and also prints the number of lines and the number of times each letter appears in the text.
An uppercase letter and a lowercase letter are treated as being the same; that is, they are tallied together.
Watch the Video Because there are 26 letters, we use an array of 26 components to perform the letter We also need a variable to store the line.
The text is stored in a , which we will call textin_0_txt.
The output will stored in a , which we will call textout_0_out.
PROBLEM ANALYSIS AND ALGORITHM DESIGN Input.
Output A  containing the text, number of lines, and the number of times a letter appears in the text.
Based on the desired output, it is clear that we must output the text as is.
That is, if the text contains any whitespace characters, they must  output as well.
Furthermore, we must count the number of lines in the text.
Therefore, we must know where the line ends, which means that we must trap the newline character.
This requirement suggests that we cannot use the extraction operator to process the input.
Because we also need to perform the letter count, we use the get function to read the text.
Let us first describe the variables that are necessary to develop the program.
This will simplify the discussion that follows.
Variables We need to store the line count and the letter count.
Therefore, we need a variable to store the line count and 26 variables to perform the letter count.
We will use an array of 26 components to perform the letter count.
We also need a variable to read and store each character in turn, because the input  is to  read character by character.
Because data is to  read from an input  and output is to  saved in a , we need an input stream variable to open the input  and an output stream variable to open the output.
These statements indicate that the function main needs (at least) the following variables:.
Clearly, the variable lineCount and the array letterCount must  initialized to 0.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not  copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may  suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: Text Processing | 583 The algorithm for the program is: 1.
Declare the variables.
Open the input and output files.
Initialize the variables.
While there is more data in the input : 4_0_1.
For each character in a line: 4_0_1_0_1.
Read and write the character.
Increment the appropriate letter count.
Increment the line count.
Output the line count and letter counts.
Close the files.
To simplify the function main, we divide it into four functions:.
Function Function Function Function initialize copyText characterCount writeTotal The following sections describe each of these functions in detail.
Then, with the help of these functions, we describe the algorithm for the function main.
It, therefore, has two parameters: one corresponding to the variable lineCount and one corresponding to the array letterCount.
Clearly, the parameter corresponding to lineCount must be a reference parameter.
The definition of this function is:.
Clearly, this function has four parameters: an input file stream variable, an output file stream variable, a char variable, and the array to update the letter count.
Note that the copyText function does not perform the letter count, but we still pass the array letterCount to it.
We take this step because this function calls the function characterCount, which needs the array letterCount to update the appropriate Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 8: Arrays and Strings letter count.
Therefore, we must pass the array letterCount to the copyText function so that it can pass the array to the function characterCount.
Therefore, the characterCount function has two parameters: a char variable and the array to update the letter count.
In pseudocode, this function is: a.
Convert the letter to uppercase.
Find the index of the array corresponding to this letter.
If the index is valid, increment the appropriate count.
At this step, we must ensure that the character is a letter.
We are counting only letters, so other characters—such as commas, hyphens, and periods—are ignored.
Following this algorithm, the definition of this function is:.
The definition of this function is: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time  subsequent rights restrictions require it.
Programming Example: Text Porcessing |.
Declare the variables.
Open the input file.
If the input file does not exist, exit the program.
Open the output file.
Initialize the variables, such as lineCount and the array letterCount.
Read the first character.
While (not end of input file): 7_0_1.
Process the next line; call the function copyText.
Read the next character.
Output the line  and letter counts.
Call the function writeTotal.
Close the files.
COMPLETE PROGRAM LISTING.
Programming Example: Text Porcessing |.
Through computers, the technological revolution is drastically changing the way we live and communicate with one another.
Terms such as "the Internet," which were unfamiliar just a few years ago, are very common today.
With the help of computers you can send letters to, and receive letters from, loved ones within seconds.
You no longer need to send a résumé by mail to apply for a job; in many cases you can simply submit your job application via the Internet.
You can watch how stocks perform in real time, and instantly buy and sell them.
Students regularly "surf" the Internet and use computers to design their classroom projects.
They also use powerful word-processing software to complete their term papers.
Many people maintain and balance their checkbooks on computers.
The number of  = 15 = 53 = 7 = 30 = 19 = 81 = 11 = 10 = 29 = 41 = 4 = 3 = 31 = 26 = 50 = 59 = 21 = 0 = 45 = 48 = 62 = 24 = 7 = 15 = 0 = 20 = 0 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time  subsequent rights restrictions require it.
Quick Review | 589 QUICK REVIEW 1.
In a structured data type, each data item is a collection of other data items.
An array is a structured data type with a fixed number of components.
Every component is of the same type, and components are accessed using their relative positions in the array.
Elements of a one-dimensional array are arranged in the form of a list.
There is no check on whether an array  is out of bounds.
In Cplus_plus, an array  starts with 0.
An array  can be any expression that evaluates to a nonnegative integer.
The value of the  must always be less than the size of the array.
There are no aggregate operations on arrays, except for the input/output of character arrays (-strings).
Arrays can be initialized during their declaration.
If there are fewer initial values than the array size, the remaining elements are initialized to 0.
The base address of an array is the address of the first array component.
For example,  list is a one-dimensional array, the base address of list is the address of list[0].
When declaring a one-dimensional array as a formal parameter, you usually omit the array size.
If you specify the size of a one-dimensional array in the formal parameter declaration, the compiler will ignore the size.
In a function call statement, when passing an array as an actual parameter, you use only its name.
As parameters to functions, arrays are passed by reference only.
Because as parameters, arrays are passed by reference only, when declaring an array as a formal parameter, you do not use the symbol & after the data type.
Although as parameters, arrays are passed by reference, when declaring an array as a formal parameter, using the reserved word const before the data type prevents the function from modifying the array.
Individual array components can be passed as parameters to functions.
The sequential search algorithm searches a list for a given item, starting with the first element in the list.
It continues to compare the search item with the other elements in the list until either the item is found or the list has no more elements left to be compared with the search item.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Chapter 8: Arrays and Strings In Cplus_plus, a string is any sequence of characters enclosed between double quotation marks.
In Cplus_plus, C-strings are null terminated.
In Cplus_plus, the null character is represented as '\0'.
In the ASCII character set, the collating sequence of the null character is 0.
C-strings are stored in character arrays.
Character arrays can be initialized during declaration using string notation.
Input and output of C-strings is the only place where Cplus_plus allows aggregate operations.
The header file cstring contains the specifications of the functions that can be used for C-string manipulation.
Commonly used C-string manipulation functions include strcpy (string copy), strcmp (string comparison), and strlen (string length).
C-strings are compared character by character.
Because C-strings are stored in arrays, individual characters in the C-string can be accessed using the array component access notation.
Parallel arrays are used to hold related information.
In a two-dimensional array, the elements are arranged in a table form.
To access an element of a two-dimensional array, you need a pair of indices: one for the row position and one for the column position.
In a two-dimensional array, the rows are numbered 0 to ROW_SIZE  1 and the columns are numbered 0 to COLUMN_SIZE  1.
If matrix is a two-dimensional array, then the base address of matrix is the address of the array component matrix[0][0].
In row processing, a two-dimensional array is processed one row at a time.
In column processing, a two-dimensional array is processed one column at a time.
When declaring a two-dimensional array as a formal parameter, you can omit the size of the first dimension but not the second.
When a two-dimensional array is passed as an actual parameter, the number of columns of the actual and formal arrays must match.
Cplus_plus stores, in computer memory, two-dimensional arrays in a row order form.
EXERCISES The number in parentheses at the end of an exercise refers to the learning objective listed at the beginning of the chapter.
Mark the following statements as true or false.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
If an array index goes out of bounds, the program always terminates in The only aggregate operations allowable on int arrays are the increment Arrays can be passed as parameters to a function either by value or by The declaration: char [16] = "John K.
Miller"; declares  to be an array of 15 characters because the string "John K.
As parameters, two-dimensional arrays are passed either by value or by int accountNum[75]; In this declaration, identify the following: a.
The array size.
The data type of each array component.
The range of values for the index of the array.
The index of the first element.
The index of the last element.
Identify error(s), if any, in the following array declarations.
What would be a valid range for the index of an array of size 99.
Declare an array alpha of 50 components of type int.
Initialize each component of alpha to -1.
Output the value of the first component of the array alpha.
Set the value of the twenty-fifth component of the  alpha to 62.
Set the value of the tenth component of alpha to three times the value of the fiftieth component of alpha plus 10.
Use a for loop to output the value of a component of alpha if its index is a multiple of 2 or 3.
Output the value of the last component of alpha.
Output the value of the alpha so that 15 components per line are printed.
Use a for loop to increment every other element (the even indexed elements).
Use a for loop to create a new , diffAlpha, whose elements are the differences between consecutive elements in alpha.
Correct the following code so that it correctly sets the value of each.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Chapter 8: Arrays and Strings Correct the following code so that it correctly initializes and outputs the int [10];.
What is  index out of bounds.
Does Cplus_plus check for  indices 14.
However, there are errors in the code.
Find and correct for (int  = 1; if ([] << 15.
Initialize this to the following values: 5_0_2, 6_0_3, 5_0_8, 4_0_9, 5_0_2, 5_0_7, 6_0_7, 7_0_1, 5_0_10, 6_0_0.
Array weights of 7 components of type int.
Initialize this  to the following values: 120, 125, 137, 140, 150, 180, 210.
Array specialSymbols of type char.
Initialize this  to the following values: '$', '#', '%', '@', '&', '.
Array seasons of 4 components of type string.
Initialize this  to the following values: "fall", "winter", "spring", "summer".
Determine whether the following  declarations are valid.
Write a Cplus_plus code that will output the value stored in each component of.
Write a Cplus_plus code that will set the values of the first five components of as follows: The value of the ith component is the value of the ith component minus three times the value of the (+1)th component.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
A car dealer has 10 salespersons.
Each salesperson keeps track of the number of cars sold each month and reports it to the management at the end of the month.
The management keeps the data in a file and assigns a number, 1 to 10, to each salesperson.
The following statement declares an array, cars, of 10 components of type int to store the number of cars sold by each salesperson: int cars[10]; Write the code to store the number of cars sold by each salesperson in the array cars, output the total numbers of cars sold at the end of each month, and output the salesperson number selling the maximum number of cars.
When an array is passed as an actual parameter to a function, what is actually 29.
Sort the following  using the selection sort algorithm as discussed in this 6, 45, 10, 25, 58, 2, 50, 30, 86 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
In the definition of the function modifyList, can you use a range-based for loop to process the elements of.
Justify your answer.
Given the declaration:.
Chapter 8: Arrays and Strings Mark the following statements as valid or invalid.
If a statement is invalid, explain 36.
Mark the following statements as "Yes" if they output Shelly.
Write a Cplus_plus statement that stores "Sunny Day" in 1.
Write a Cplus_plus statement that stores the  of 1 into the int variable.
Write a Cplus_plus statement that copies the value of  into 2.
Write Cplus_plus code that outputs 1 if 1 is less than or equal to 2, and otherwise outputs 2.
Define a two-dimensional array named temp of three rows and four columns of type int such that the first row is initialized to 6, 8, 12, 9; the second row is 40.
Suppose that array temp is as defined in Exercise 39.
Write Cplus_plus statements a.
Output the contents of the first row and last column element of temp.
Output the contents of the last row and first column element of temp.
Output the contents of the last row and last column element of temp.
How many components does the array sales have.
What is the number of rows in the array sales.
What is the number of columns in the array sales.
To sum the sales by , what kind of processing is required.
To sum the sales by , what kind of processing is required.
Declare an array alpha of 10 rows and 20 columns of type int.
Initialize the array alpha to 0.
Store 1 in the first row and 2 in the remaining rows.
Store 5 in the first column, and make sure that the value in each subsequent column is twice the value in the previous column.
Print the array alpha one row per line.
Print the array alpha one column per line.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Write the definition of the function print that can be used to output the contents of these arrays.
Write the Cplus_plus statements that calls the function print to output the contents of the arrays times, speed, trees, and students.
PROGRAMMING EXERCISES 1.
Write a Cplus_plus program that declares an array alpha of 50 components of type double.
Initialize the array so that the first 25 components are equal to the square of the index variable, and the last 25 components are equal to three times the index variable.
Output the array so that 10 elements per line are printed.
Write a Cplus_plus function, smallestIndex, that takes as parameters an int array and its size and returns the index of the first occurrence of the smallest element in the array.
Also, write a program to test your function.
Write a Cplus_plus function, lastLargestIndex, that takes as parameters an int array and its size and returns the index of the last occurrence of the largest element in the array.
Also, write a program to test your function.
Write a program that reads a file consisting of students' test scores in the range 0–200.
It should then determine the number of students having scores in each of the following ranges: 0–24, 25–49, 50–74, 75–99, 100–124, 125–149, 150–174, and 175–200.
Output the score ranges and the number of students.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The students' IDs and test answers are stored in a file.
The first entry in the file contains answers to the test in the form: TFFTFFTTTTFFTFTFTFTT Every other entry in the file is the student ID, followed by a blank, followed by the student's responses.
For example, the entry: ABC54301 TFTFTFTT TFTFTFFTTFT 7.
This student did not answer question 9.
The exam has 20 questions, and the class has more than 150 students.
Each correct answer is awarded two points, each wrong answer gets one point deducted, and no answer gets zero points.
Write a program that processes the test data.
The output should be the student's ID, followed by the answers, followed by the test score, followed by the test grade.
Assume the following grade scale: 90%–100%, A; 80%– 89_0_99%, B; 70%–79_0_99%, C; 60%–69_0_99%, D; and 0%–59_0_99%, F.
Write a program that allows the user to enter the last names of five candidates in a local election and the number of votes received by each candidate.
The program should then output each candidate's name, the number of votes received, and the percentage of the total votes received by the candidate.
Your program should also output the winner of the election.
A sample output is: Candidate Johnson Miller Duffy Robinson Ashtony Total Votes Received 5000 4000 6000 2500 1800 19300 % of Total Votes 25_0_91 20_0_73 31_0_09 12_0_95 9_0_33 The Winner of the Election is Duffy.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Chapter 8: Arrays and Strings Write the definition of the function setZero that initializes any onedimensional array of type int to 0.
Write the definition of the function inputArray that prompts the user to input 20 numbers and stores the numbers into alpha.
Write the definition of the function doubleArray that initializes the elements of beta to two times the corresponding elements in alpha.
Make sure that you prevent the function from modifying the elements of alpha.
Write the definition of the function copyGamma that sets the elements of the first row of inStock to  and the remaining rows of inStock to three times the previous row of inStock.
Make sure that you prevent the function from modifying the elements of.
Write the definition of the function copyAlphaBeta that stores alpha into the first five rows of inStock and beta into the last five rows of inStock.
Make sure that you prevent the function from modifying the elements of alpha and beta.
Write the definition of the function printArray that prints any onedimensional array of type int.
Print 15 elements per line.
Write the definition of the function setInStock that prompts the user to input the elements for the first column of inStock.
The function should then set the elements in the remaining columns to two times the corresponding element in the previous column, minus the corresponding element in.
Write Cplus_plus statements that call each of the functions in parts a through g.
Write a Cplus_plus program that tests the function main and the functions discussed in parts a through g.
The program should output the average high, average low, and the highest and lowest temperatures for the year.
Your program must consist of the following functions: a.
Function getData: This function reads and stores data in the twodimensional array.
Function averageHigh: This function calculates and returns the average high temperature for the year.
Function averageLow: This function calculates and returns the average low temperature for the year.
Function indexHighTemp: This function returns the index of the highest high temperature in the array.
Function indexLowTemp: This function returns the index of the lowest low temperature in the array.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Exercises 10.
Programming Exercise 10 in Chapter 6 asks you find the mean and standard deviation of five numbers.
Extend this programming exercise to find the mean and standard deviation of up to 100 numbers.
Suppose that the mean (average) of n numbers x1, x2,.
Then, the standard deviation of these numbers is: sﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ ðx1  xÞ2 þ ðx2  xÞ2 þ    þ ðxi  xÞ2 þ    þ ðxn  xÞ2 s¼ n 11.
So, an integer larger than this cannot be stored and processed as an integer.
Similarly, if the sum or product of two positive integers is greater than 2147483647, the result will be incorrect.
One way to store and manipulate large integers is to store each individual digit of the number in an array.
Write a program that inputs two positive integers of, at most, 20 digits and outputs the sum of the numbers.
If the sum of the numbers has more than 20 digits, output the sum with an appropriate message.
Your program must, at least, contain a function to read and store a number into an array and another function to output the sum of the numbers.
Each day of the week, they run a certain number of miles and write them into a notebook.
At the end of the week, they would like to know the number of miles run each day, the total miles for the week, and average miles run each day.
Write a program to help them analyze their data.
Your program must contain parallel arrays: an array to store the names of the runners and a two-dimensional array of five rows and seven columns to store the number of miles run by each runner each day.
Furthermore, your program must contain at least the following functions: a function to read and store the runners' names and the numbers of miles run each day; a function to find the total miles run by each runner and the average number of miles run each day; and a function to output the results.
You may assume the following input data: 12.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 8: Arrays and Strings Blair 23 45 96 38 59 Clark 60 85 45 39 67 Kennedy 77 31 52 74 83 Bronson 93 94 89 77 97 Sunny 79 85 28 93 82 Smith 85 72 49 75 63 14.
Use three arrays: a one-dimensional array to store the students' names, a (parallel) two-dimensional array to store the test scores, and a parallel onedimensional array to store grades.
Your program must contain at least the following functions: a function to read and store data into two arrays, a function to calculate the average test score and grade, and a function to output the results.
Have your program also output the class average.
A company hired 10 temporary workers who are paid hourly and you are given a data file that contains the last name of the employees, the number of hours each employee worked in a week, and the hourly pay rate of each employee.
You are asked to write a program that computes each employee's weekly pay and the average salary of all the workers.
The program then outputs the weekly pay of each employee, the average weekly pay, and the names of all the employees whose pay is greater than or equal to the average pay.
If the number of hours worked in a week is more than 40 hours, then the pay rate for the hours over 40 is 1_0_5 times the regular hourly rate.
Use two parallel arrays: a one-dimensional array to store the names of all the employees, and a two-dimensional array of 10 rows and 3 columns to store the number of hours an employee worked in a week, the hourly pay rate, and the weekly pay.
Your program must contain at least the following functions—a function to read the data from the file into the arrays, a function to determine the weekly pay, a function to output the names of all the employees whose pay is greater than or equal to the average weekly pay, and a function to output each employee's data.
Children often play a memory game in which a deck of cards containing matching pairs is used.
The cards are shuffled and placed face down on a table.
The players then take turns and select two cards at a time.
If both cards match, they are left face up; otherwise, the cards are placed face down at the same positions.
Once the players see the selected pair of cards and if the cards do not match, then they can memorize the cards and use their memory to select the next pair of cards.
The game continues until all the cards are face up.
Write a program to play the memory game.
Use a twodimensional array of 4 rows and 4 columns for a deck of 16 cards with 8 matching pairs.
You can use numbers 1 to 8 to mark the cards.
Use appropriate functions in your program, and the main program should be merely a call to functions.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The airplane has 13 rows, with six seats in each row.
Rows 1 and 2 are first class, rows 3 through 7 are business class, and rows 8 through 13 are economy class.
Your program must prompt the user to enter the following information: a.
Desired seat Output the seating plan in the following form: Row Row Row Row Row Row Row Row Row Row Row Row Row 17.
F * * * X * * X * X * * * * * X * * X X * X * X * * * X * X X * * * * X * X X * * X X * X * * X X X * X * X * * X * * X X * X X * X X X X X * X X * X X * X * Here, * indicates that the seat is available; X indicates that the seat is occupied.
Make this a menu-driven program; show the user's choices and allow the user to make the appropriate choices.
The program in Example 8-7 outputs the average speed over the intervals of length 10.
Modify the program so that the user can store the distance traveled at the desired times, such as times 0, 10, 16, 20, 30, 38, 45.
The program then computes and outputs the average speed of the object over the successive time intervals specified by the time when the distance was recorded.
For example, for the previous list of times, the average speed is computed over the time intervals 0 to 16, 16 to 20, 20 to 30, 30 to 38, and 38 to 45.
A positive integer n is called prime if n > 1 and the only factors of n are 1 and n.
It is known that a positive integer n > 1 is prime if n is not divisible pﬃﬃﬃ by any prime integer m  n.
The 1230th prime number is 10007.
Let t be an integer such that 2  t  100,000,000.
Then t is prime if either t is equal to one of the first 1230 prime numbers or t is not divisible by any of the first 1230 prime numbers.
Write a program that declares an array of size 1230 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 8: Arrays and Strings and stores the first 1230 prime numbers in this array.
The program then uses the first 1230 prime numbers to determine if a number between 2 and 100,000,000 is prime.
If a number is not prime, then output at least one of its prime factors.
A positive integer  is called composite if  = ab, where a and b are positive integers such that a 6¼ 1 and b 6¼ 1.
If  is composite, then  can be written as a product of prime numbers.
Let  be an integer such that 2    100,000,000.
Modify the program in Exercise 18 so that if  is not prime, the program outputs  as a product of prime numbers.
Write a program that uses a 3  3 array and randomly place each integer from 1 to 9 into the nine squares.
The program calculates the magic number by adding all the numbers in the array and then dividing the sum by 3.
The 3  3 array is a magic square if the sum of each row, each column, and each diagonal is equal to the magic number.
Your program must contain at least the following functions: a function, to randomly fill the array with the numbers and a function to determine if the array is a magic square.
Run these functions for some large number of times, say 1,000, 10,000, or 1,000,000 times and see the number of times the array is a magic square.
Write a program that randomly generate a 20  20 two-dimensional array, board, of type int.
An element board[i][j] is a peak (either a maximum or a minimum) if all its neighbors (there should be either 3, 5, or 8 neighbors for any cell) are less than board[i][j], or greater than board[i][j].
The program should output all elements in board, with their indices, which are peak.
It should also output if a peak is a maximum or a minimum.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Learn how to create structs within a struct Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
You also learned how to process data stored in an array and how to perform list operations, such as searching and sorting.
This chapter may be skipped without experiencing any discontinuation.
In this chapter, you will learn how to group related values that are of different types.
Cplus_plus provides another structured data type, called a struct (some languages use the term "record"), to group related items of different types.
An array is a homogeneous data structure; a struct is typically a heterogeneous data structure.
The treatment of a struct in this chapter is similar to the treatment of a struct in C.
A struct in this chapter, therefore, is a C-like struct.
Chapter 10 introduces and discusses another structured data type, called a class.
Suppose that you want to write a program to process student data.
A student record consists of, among other things, the student's name, student ID, GPA, courses taken, and course grades.
Thus, various components are associated with a student.
However, these components are all of different types.
For example, the student's name is a string, and the GPA is a floating-point number.
Because these components are of different types, you cannot use an array to group all of the items associated with a student.
Cplus_plus provides a structured data type called struct to group items of different types.
Grouping components that are related but of different types offers several advantages.
For example, a single variable can pass all the components as parameters to a function.
The components may be of different types.
The components of a struct are called the members of the struct.
The general syntax of a struct in Cplus_plus is: struct structName { dataType1 identifier1; dataType2 identifier2;.
Thus, a semicolon (after the right brace) is essential to end the Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Records (structs) |.
A semicolon at the end of the struct definition is, therefore, a part of the syntax.
The member style is of type string, the members numOfBedrooms, numOfBathrooms, numOfCarsGarage, yearBuilt, and finishedSquareFootage are of type int, and the members price and tax are of type double.
Like any type definition, a struct is a definition, not a declaration.
That is, it defines only a data type; no memory is allocated.
Once a data type is defined, you can declare variables of that type.
For example, the following statement defines newHouse to be a struct variable of type houseType: //variable declaration houseType newHouse;.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
You can also declare struct variables when you define the struct.
For example, consider the following statements:.
These statements define the struct houseType and also declare tempHouse to be a variable of type houseType.
Typically, in a program, a struct is defined before the definitions of all the functions in the program, so that the struct can be used throughout the program.
Therefore, if you define a struct and also simultaneously declare a struct variable (as in the preceding statements), then that struct variable becomes a global variable and thus can be accessed anywhere in the program.
Keeping in mind the side effects of global variables, you should first only define a struct and then declare the struct variables.
Accessing struct Members In arrays, you access a component by using the array name together with the relative position (index) of the component.
The array name and index are separated using square brackets.
To access a structure member (component), you use the struct variable name together with the member name; these names are separated by a dot (period).
The syntax for accessing a struct member is: structVariableName_0_memberName The structVariableName_0_memberName is just like any other variable.
For example, newStudent_0_courseGrade is a variable of type char, newStudent_0_firstName is a string variable, and so on.
As a result, you can do just about anything with struct members that you normally do with variables.
You can, for example, use them in assignment statements or input/output (where permitted) statements.
In Cplus_plus, the dot (_0_) is an operator called the member access operator.
Consider the following statements: struct studentType.
Records (structs) |.
After the preceding three assignment statements execute, newStudent is as shown in Figure 9-2.
Brown courseGrade testScore programmingScore FIGURE 9-2.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
The statement: cin >> newStudent_0_testScore >> newStudent_0_programmingScore; reads two integer values from the keyboard and stores them in newStudent_0_testScore.
Suppose that  is a variable of type int.
The statement: = (newStudent_0_testScore + newStudent_0_programmingScore) / 2; assigns the average of newStudent_0_testScore and newStudent_0_programmingScore to.
Records (structs) | 615 The first two statements declare ryanHouse and anitaHouse to be variables of houseType.
The next eight statements store the string "Colonial" into ryanHouse_0_, 3 into ryanHouse_0_, 2 into ryanHouse_0_, and so on.
Next, consider the following statements: cin >> anitaHouse.
Assignment We can assign the value of one struct variable to another struct variable of the same type by using an assignment statement.
Suppose that newStudent is as shown in Figure 9-3.
After this assignment statement executes, the values of  are as shown in Figure 9-4.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
To compare struct variables, you compare them member-wise.
As with an array, no aggregate relational operations are performed on a struct.
For example, suppose that newStudent and  are declared as shown earlier.
Furthermore, suppose that you want to see whether  and newStudent refer to the same.
Now newStudent and  refer to the same  if they have the same first name and the same last name.
To compare the values of  and newStudent, you must compare them member-wise, as follows: if (.
Although you can use an assignment statement to copy the contents of one struct into another struct of the same type, you cannot use relational operators on struct variables.
Therefore, the following would be illegal: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Records (structs) |.
Input /Output No aggregate input/output operations are allowed on a struct variable.
Data in a struct variable must be read one member at a time.
Similarly, the contents of a struct variable must be written one member at a time.
We have seen how to read data into a struct variable.
Let us now see how to output a struct variable.
The statement: cout << << << << << newStudent.
A struct variable can be passed as a parameter either by value or by reference, and A function can return a value of type struct.
The following function reads and stores a 's first name, last name, test , programming , and.
It also determines the 's course grade and stores it.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
The function readIn stores the appropriate information in the variable newStudent.
Similarly, we can write a function that will print the contents of a struct variable.
For example, the following function outputs the contents of a struct variable of type studentType on the screen: { cout <<.
TABLE 9-1 Arrays vs.
Yes Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Records (structs) | 619 Arrays in structs A list is a set of elements of the same type.
Thus, a list has two things associated with it: the values (that is, elements) and the length.
Because the values and the length are both related to a list, we can define a struct containing both items.
Consider the following statements:.
The statement in Line 2 stores 12 in the first component of the array.
The statement in Line 3 increments the value of  by 1.
The meaning of the other statements is similar.
After these statements execute, intList is as shown in Figure 9-6.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
If searchItem is  in the list, then the function returns its location in the.
In this function, because  is a member of list, we access this by list_0_.
Similarly, we can access an element of list via list_0_[].
Notice that the formal parameter list of the function seqSearch is declared as a constant reference parameter.
This means that list receives the address of the corresponding actual parameter, but list cannot modify the actual parameter.
Recall that when a variable is passed by value, the formal parameter copies the value of the actual parameter.
Therefore, if the formal parameter modifies the data, the modification has no effect on the data of the actual parameter.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Records (structs) | 621 Suppose that a struct has several data members requiring a large amount of memory to store the data, and you need to pass a variable of that struct type by value.
The corresponding formal parameter then receives a copy of the data of the variable.
The compiler must then allocate memory for the formal parameter in order to copy the value of the actual parameter.
This operation might require, in addition to a large amount of storage space, a considerable amount of computer time to copy the value of the actual parameter into the formal parameter.
On the other hand, if a variable is passed by reference, the formal parameter receives only the address of the actual parameter.
Therefore, an efficient way to pass a variable as a parameter is by reference.
If a variable is passed by reference, then when the formal parameter changes, the actual parameter also changes.
Sometimes, however, you do not want the function to be able to change the values of the actual parameter.
In Cplus_plus, you can pass a variable by reference and still prevent the function from changing its value.
This is done by using the keyword const in the formal parameter declaration, as shown in the definition of the function seqSearch.
Likewise, we can also rewrite the sorting, binary search, and other list-processing functions.
We need to print their monthly paychecks and keep track of how much money has been paid to each employee in the year-to-date.
First, let's define an employee's record: struct employeeType {.
Each employee has the following members (components): first name, last name, personal ID, department ID, yearly salary, monthly salary, year-to-date paid, and monthly bonus.
Because we have 50 employees and the data type of each employee is the same, we can use an array of 50 components to process the employees' data.
Every element of employees is a struct.
For example, Figure 9-7 also shows employees[2].
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
For our discussion, we assume that each employee's data is stored in a file, say, employee_0_dat.
The following Cplus_plus code loads the data into the employees' array.
We assume that, initially, yearToDatePaid is 0 and that the monthly bonus is determined each month based on performance.
The following loop computes and prints the employee's paycheck for the month: double payCheck; //variable to calculate the paycheck Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Records (structs) |.
You also saw examples wherein a member of a struct is an array, and the array type is a struct.
In this section, you will learn about situations for which it is beneficial to organize data in a struct by using another struct.
Let us consider the following employee record: struct employeeType.
Some members of this struct will be accessed more frequently than others, and some members are more closely related than others.
Moreover, some members will Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
For example, the hire date and the quit date are of the data type int.
Let us reorganize this struct as follows:.
We have separated the employee's name, address, and contact type into subcategories.
Furthermore, we have defined a struct dateType.
Let us rebuild the employee's record as follows: struct employeeType.
The information in this employee's struct is easier to manage than the previous one.
Some of this struct can be reused to build another struct.
For example, suppose that you want to define a customer's record.
Every customer has a first name, last name, and Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Records (structs) | 625 middle name, as well as an address and a way to be contacted.
You can, therefore, quickly put together a customer's record by using the structs nameType, addressType, contactType, and the members specific to the customer.
Next, let us declare a variable of type employeeType and discuss how to access its members.
Consider the following statement: employeeType newEmployee; This statement declares newEmployee to be a struct variable of type employeeType (see Figure 9-8).
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Note that newEmployee has a member called name.
We access this member via newEmployee_0_name.
Note also that newEmployee_0_name is a struct and has three members.
We apply the member access criteria to access the member  of the struct newEmployee_0_name.
The statement: cin >> newEmployee_0_name_0_;.
Because employees is an array, to access a component, we use the index.
For example, employees[50] is the 51st component of the array employees (recall that an array index starts with 0).
Because employees[50] is a struct, we apply the member access criteria to select a particular member.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: Sales Data Analysis.
Sales Data Analysis A company has six salespeople.
Every month, they go on road trips to sell the company's product.
At the end of each month, the total sales for each salesperson, together with that salesperson's ID and the month, is recorded in a file.
At the end of each year, the manager of the company wants to see this report in this following tabular format: minus_minusminus_minusminus_minusminus_minusminus_minus Annual Sales Report minus_minusminus_minusminus_minusminus_minusminus_minus.
Total 494_0_00 9023_0_00 0_0_00 8834_0_00 0_0_00 392_0_00 322_0_00 0_0_00 0_0_00 0_0_00 1223_0_00 3420_0_00 2708_0_00 10258_0_00 3296_0_00 10619_0_00 5326_0_00 4705_0_00 18743_0_00 4965_0_00 Max Sale by :  = 57373,  = $10619_0_00 Max Sale by :  = 3,  = $18743_0_00 In this report, QT1 stands for quarter 1 (months 1 to 3), QT2 for quarter 2 (months 4 to 6), QT3 for quarter 3 (months 7 to 9), and QT4 for quarter 4 (months 10 to 12).
The salespeople's IDs are stored in one file; the sales data is stored in another file.
The sales data is in the following form: salesPersonID.
A sample sales data is: 12345 32214 23422 57373.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Let us write a program that produces the output in the specified format.
PROBLEM ANALYSIS AND ALGORITHM DESIGN Input One file containing each salesperson's  and a second file containing the sales data.
Output A file containing the annual sales report in the above format.
Based on the problem's requirements, it is clear that the main components for each salesperson are the salesperson's , quarterly sales amount, and total annual sales amount.
Because the components are of different types, we can group them with the help of a struct, defined as follows: struct salesPersonRec.
Because the program requires us to find the company's total sales for each quarter, we need an array of four components to store the data.
Note that this data will be used to determine the quarter in which the maximum sales were made.
Therefore, the program also needs the following array: double totalSaleByQuarter[4]; Recall that in Cplus_plus, the array index starts with 0.
Therefore, totalSaleByQuarter[0] stores data for quarter 1, totalSaleByQuarter[1] stores data for quarter 2, and so on.
We will refer to these variables throughout the discussion.
The array salesPersonList is as shown in Figure 9-9.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: Sales Data Analysis.
After this step, the array salesPersonList is as shown in Figure 9-10.
Array salesPersonList after initialization Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The next step is to process the sales data.
Processing the sales data is quite straightforward.
For each entry in the file containing the sales data: 1.
Read the salesperson's ID, month, and sale amount for the month.
Search the array salesPersonList to locate the component corresponding to this salesperson.
Determine the quarter corresponding to the month.
Update the sales for the quarter by adding the sale amount for the month.
Once the sales data file is processed: 1.
Calculate the total sales by salesperson.
Calculate the total sales by quarter.
Print the report.
This discussion translates into the following algorithm: 1.
Initialize the array salesPersonList.
Process the sales data.
Calculate the total sales by quarter.
Calculate the total sales by salesperson.
Print the report.
Calculate and print the maximum sales by salesperson.
Calculate and print the maximum sales by quarter.
To reduce the complexity of the main program, let us write a separate function for each of these seven steps.
Function This function reads the salesperson's ID from the input file and stores the salesperson's ID initialize in the array salesPersonList.
It also initializes the quarterly sales amount and the total sales amount for each salesperson to 0.
The definition of this function is: void initialize(ifstream& indata, salesPersonRec list[], {.
Programming Example: Sales Data Analysis.
The algorithm for this function is: 1.
Read the salesperson's ID, month, and sales amount for the month.
Search the array salesPersonList to locate the component corresponding to the salesperson.
Determine the  corresponding to the month.
Update the sales for the  by adding the sales amount for the month.
Suppose that the entry read is: 57373 2 350 Here, the salesperson's ID is 57373, the month is 2, and the sale amount is 350.
Suppose that the array salesPersonList is as shown in Figure 9-11.
Array salesPersonList Now, ID 57373 corresponds to the array component salesPersonList[3], and month 2 corresponds to  1.
After processing this entry, the array salesPersonList is as shown in Figure 9-12.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Array salesPersonList after processing entry 57373 2 350 The definition of the function getData is: void getData(ifstream& infile, salesPersonRec list[],.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Programming Example: Sales Data Analysis.
Function This function finds the company's total sales for each.
To find the total sales for saleByQuarter each , we add the sales  of each salesperson for that.
Clearly, this function must have access to the array salesPersonList and the array totalSaleByQuarter.
This function also needs to know the number of rows in each array.
Thus, this function has three parameters.
The definition of this function is: void saleByQuarter(salesPersonRec list[], int listSize,.
Clearly, this Person function must have access to the array salesPersonList.
This function also needs to know the size of the array.
Thus, this function has two parameters.
Print the heading—that is, the first three lines of output.
Print the data for each salesperson.
Print the last line of the table.
Note that the next two functions will produce the final two lines of output.
Clearly, the printReport function must have access to the array salesPersonList and the array totalSaleByQuarter.
Also, because the output will be stored in a file, this function must have access to the ofstream variable associated with the output file.
Thus, this function has four parameters: a parameter corresponding to the array salesPersonList, a parameter corresponding to the array totalSaleByQuarter, a parameter specifying the size of the array, and a parameter corresponding to the ofstream variable.
The definition of this function is: void printReport(ofstream& outfile, salesPersonRec list[], { int ; int ; outfile << << outfile << outfile << << outfile << << "QT4 " << endl;.
Programming Example: Sales Data Analysis.
Function This function prints the name of the salesperson who produces the maximum sales maxSaleBy amount.
To identify this salesperson, we look at the sales total for each salesperson Person and find the largest sales amount.
Because each employee's sales total is maintained in the array salesPersonList, this function must have access to the array salesPersonList.
Also, because the output will be stored in a file, this function must have access to the ofstream variable associated with the output file.
Therefore, this function has three parameters: a parameter corresponding to the array salesPersonList, a parameter specifying the size of this array, and a parameter corresponding to the output file.
The algorithm to find the largest sales amount is similar to the algorithm to find the largest element in an array (discussed in Chapter 8).
The definition of this function is: void maxSaleByPerson(ofstream& outData, salesPersonRec list[], { int  = 0;.
Function This function prints the  in which the maximum sales were made.
To identify maxSaleBy this , we look at the total sales for each  and find the largest sales amount.
Quarter Because the sales total for each  is in the array totalSaleByQuarter, this function must have access to the array totalSaleByQuarter.
Also, because the output will be stored in a file, this function must have access to the ofstream variable associated with the output file.
Therefore, this function has two parameters: a parameter corresponding to the array totalSaleByQuarter and a parameter corresponding to the output file.
The algorithm to find the largest sales amount is the same as the algorithm to find the largest element in an array (discussed in Chapter 8).
The definition of this function is: void maxSaleByQuarter(ofstream& outData, Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
We are now ready to write the algorithm for the function main.
Declare the variables.
Prompt the user to enter the name of the file containing the salesperson's  data.
Read the name of the input file.
Open the input file.
If the input file does not exist, exit the program.
Initialize the array salesPersonList.
Call the function initialize.
Close the input file containing the salesperson's  data and clear the input stream.
Prompt the user to enter the name of the file containing the sales data.
Read the name of the input file.
Open the input file.
If the input file does not exist, exit the program.
Prompt the user to enter the name of the output file.
Read the name of the output file.
Open the output file.
To output floating-point numbers in a fixed decimal format with the decimal point and trailing zeroes, set the manipulators fixed and showpoint.
Also, to output floating-point numbers to two decimal places, set the precision to two decimal places.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: Sales Data Analysis 16.
Call the function getData.
Calculate the total sales by.
Call the function saleByQuarter.
Calculate the total sales for each salesperson.
Call the function totalSaleByPerson.
Print the report in a tabular format.
Call the function printReport.
Find and print the salesperson who produces the maximum sales for the year.
Call the function maxSaleByPerson.
Find and print the  that produces the maximum sales for the year.
Call the function maxSaleByQuarter.
Close the files.
For each // salesperson, it outputs the , the total sales by each // , and the total sales for the year.
It also outputs // the salesperson's  generating the maximum sale for the // year and the sales amount.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Programming Example: Sales Data Analysis.
Sample Run: In this sample run, the user input is shaded.
Enter the salesPerson ID file name: Ch9_SalesManID_0_txt Enter the sales data file name: Ch9_SalesData_0_txt Enter the output file name: Ch9_SalesDataAnalysis_0_txt Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Input File: Salespeople's IDs 12345 32214 23422 57373 35864 54654 Input File: Salespeople's Data 12345 32214 23422 57373 35864 54654 12345 32214 23422 23422 57373 35864 54654 12345 35864 54654 12345 32214 23422 23422 57373 35864 1 893 1 343 3 903 2 893 5 329 9 392 2 999 4 892 4 895 2 492 6 892 10 1223 11 3420 12 322 5 892 3 893 8 494 8 9023 6 223 4 783 8 8834 3 2882 Sample Run: –––––––––––– Annual Sales Report –––––––––––– ID QT1 12345 32214 23422 57373 35864 54654 Total 1892_0_00 343_0_00 1395_0_00 893_0_00 2882_0_00 893_0_00 8298_0_00 QT2 0_0_00 892_0_00 1901_0_00 892_0_00 1221_0_00 0_0_00 4906_0_00 QT3.
Total 494_0_00 9023_0_00 0_0_00 8834_0_00 0_0_00 392_0_00 18743_0_00 322_0_00 0_0_00 0_0_00 0_0_00 1223_0_00 3420_0_00 4965_0_00 2708_0_00 10258_0_00 3296_0_00 10619_0_00 5326_0_00 4705_0_00 Max Sale by :  = 57373,  = $10619_0_00 Max Sale by :  = 3,  = $18743_0_00 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
A struct is a collection of a fixed number of components.
Components of a struct can be of different types.
The syntax to define a struct is: struct structName { dataType1 identifier1; dataType2 identifier2;.
In Cplus_plus, struct is a reserved word.
In Cplus_plus, struct is a definition; no memory is allocated.
Memory is allocated for the struct variables only when you declare them.
Components of a struct are called members of the struct.
Components of a struct are accessed by name.
In Cplus_plus, the dot (_0_) operator is called the member access operator.
Members of a struct are accessed by using the dot (_0_) operator.
For example, if employeeType is a struct, employee is a variable of type employeeType, and name is a member of employee, then the expression employee_0_name accesses the member name.
That is, employee_0_name is a variable and can be manipulated like other variables.
The only built-in operations on a struct are the assignment and member access operations.
Neither arithmetic nor relational operations are allowed on struct(s).
As a parameter to a function, a struct can be passed either by value or by reference.
A function can return a value of type struct.
A struct can be a member of another struct.
EXERCISES The number in parentheses at the end of an exercise refers to the learning objective listed at the beginning of the chapter.
Mark the following statements as true or false.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The only allowable operations on a struct are assignment and member f.
Some aggregate input/output operations are allowed on a struct h.
A struct variable can be passed as a parameter either by value or by i.
Define a struct, carType, to store the following data about a car: Manufacturer (string), model (string), model type (string), color (string), number of doors (int), miles per gallon in city (int), miles per gallon on Assume the definition of Exercise 2.
Declare a carType variable and write Cplus_plus statements to store the following information: Manufacturer—GMT, model—Cyclone, type—sedan, color—blue, number of doors—4, miles per gallon in city—28, miles per gallon on highway—32, year when the car Define a struct, fruitType, to store the following data about a fruit: Fruit name Assume the definition of Exercise 4.
Declare a variable of type fruitType to store the following data: Fruit name—banana, color—yellow, fat—1, Consider the declaration of the struct houseType given in this chapter.
Declare variables oldHouse and newHouse of type houseType.
Store the following information into oldHouse: Style—Two-story, number of bedrooms—5, number of bathrooms—3, number of cars garage—4, year built—1975, finished square footage—3500, price— 675000, and tax—12500.
Copy the values of the components of oldHouse into the corresponding components of newHouse.
Consider the declaration of the struct houseType given in this chapter.
Suppose firstHouse and secondHouse are variables of houseType.
Write Cplus_plus statement(s) to compare the style and price of firstHouse and secondHouse.
Output true if the corresponding values are the same; a.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Write a Cplus_plus function, printHouseInfo to output data stored into a variable of houseType.
Use appropriate labels to identify each Which aggregrate operations allowed on struct variables are not allowed Consider the following statements: a.
Assume the declarations of Exercise 10.
Write Cplus_plus statements to store the : Linda Brown : 3_0_78 : Calculus call number: 23827 : 4 grade: A Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Assume the declarations of Exercise 10.
Write Cplus_plus statements that do the a.
Store the following information in : : Programming I : 13452 : 3 In the array , initialize each  to 0_0_0.
Copy the information of the thirty-first component of the array into student.
Update the  of the tenth student in the array  by adding 0_0_75 to its previous value.
Consider the following statements (nameType is as defined in Exercise 10): b.
Store the following information in newEmployee: : Mickey Doe : 111111111 : 2 dept: ACCT : 34567_0_78 b.
In the array , initialize each  to 0.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Update the  of the 50th employee in the array  by adding 5735_0_87 to its previous value.
Assume that you have the following definition of a struct: c.
Write a Cplus_plus code to initialize each component of inventory as follows: partName to null string, partNum to -1, price to 0_0_0, and quantitiesInStock to 0.
Write a Cplus_plus code that uses a loop to output the data stored in inventory.
Assume that the variable length indicates the number of elements in inventory.
Assume the definition and declaration of Exercise 15.
Write the definition of a void function that can be used to input data in a variable of type partsType.
Also write a Cplus_plus code that uses your function to input data in a.
Declare the variable destination of type tourType.
Write Cplus_plus statements to store the following data in destination: cityName—Chicago, distance—550 miles, travelTime—9 hours and 30 minutes.
Write the definition of a function to output the data stored in a variable of type tourType.
Write the definition of a value-returning function that inputs data into a variable of type tourType.
Write the definition of a void function with a reference parameter of type tourType to input data in a variable of type tourType.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
PROGRAMMING EXERCISES 1.
Assume the definition of Exercise 4, which defines the struct fruitType.
Write a program that declares a variable of type fruitType, prompts the user to input data about a fruit, and outputs the fruit data.
Write a program that reads students' names followed by their test scores.
The program should output each student's  followed by the test scores and the relevant grade.
It should also find and print the highest test score and the of the students having the highest test score.
Student data should be stored in a struct variable of type studentType, which has four components: studentFName and studentLName of type string, testScore of type int (testScore is between 0 and 100), and grade of type char.
Suppose that the class has 20 students.
Use an array of 20 components of type studentType.
Your program must contain at least the following functions: A function to read the students' data into the array.
A function to assign the relevant grade to each student.
A function to find the highest test score.
A function to print the names of the students having the highest test score.
Your program must output each student's  in this form: last followed by a comma, followed by a space, followed by the first ; the must be left justified.
Moreover, other than declaring the variables and opening the input and output files, the function main should only be a collection of function calls.
Define a struct, menuItemType, with two components: menuItem of type string and menuPrice of type double.
Write a program to help a local restaurant automate its breakfast billing system.
The program should do the following: a.
Show the customer the different breakfast items offered by the restaurant.
Allow the customer to select more than one item from the menu.
Calculate and print the bill.
Assume that the restaurant offers the following breakfast items (the price of each item is shown to the right of the item): Plain Egg Bacon and Egg Muffin French Toast Fruit Basket Cereal Coffee Tea $1_0_45 $2_0_45 $0_0_99 $1_0_99 $2_0_49 $0_0_69 $0_0_50 $0_0_75 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Your program must contain at least the following functions:.
Function getData: This function loads the data into the array menuList.
Function showMenu: This function shows the different items offered by the restaurant and tells the user how to select the items.
Function printCheck: This function calculates and prints the check.
A sample output is: Welcome to Johnny's Restaurant Bacon and Egg $2_0_45 Muffin $0_0_99 Coffee $0_0_50 Tax $0_0_20 Amount Due $4_0_14 5.
Format your output with two decimal places.
The name of each item in the output must be left justified.
You may assume that the user selects only one item of a particular type.
Redo Exercise 4 so that the customer can select multiple items of a particular type.
A sample output in this case is: Welcome to Johnny's Restaurant 1 Bacon and Egg $2_0_45 2 Muffin $1_0_98 1 Coffee $0_0_50 Tax $0_0_25 Amount Due $5_0_18 6.
Write a program whose main function is merely a collection of variable declarations and function calls.
This program reads a text and outputs the letters, together with their counts, as explained below in the function printResult.
All information must be Your program must consist of at least the following functions:.
Function openFile: Opens the input and output files.
You must pass the file streams as parameters (by reference, of course).
If the file does not exist, the program should print an appropriate message and exit.
The program must ask the user for the names of the input and output files.
Function count: Counts every occurrence of capital letters A-Z and small letters a-z in the text file opened in the function openFile.
This information must go into an array of structures.
The array must be passed as a parameter, and the file identifier must also be passed as a parameter.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Function printResult: Prints the number of capital letters and small letters, as well as the percentage of capital letters for every letter A-Z and the percentage of small letters for every letter a-z.
The percentages should look like this: "25%".
This information must come from an array of structures, and this array must be passed as a parameter.
Write a program that declares a struct to store the data of a football player (player's name, player's position, number of touchdowns, number of catches, number of passing yards, number of receiving yards, and the number of rushing yards).
Declare an array of 10 components to store the data of 10 football players.
Your program must contain a function to input data and a function to output data.
Add functions to search the array to find the index of a specific player, and update the data of a player.
Your program should be menu driven, giving the user various choices.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Learn about the static members of a class Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The definition of a struct given in Chapter 9 is similar to the definition of a C-struct.
However, the members of a Cplus_plus struct can be data items as well as functions.
Cplus_plus provides another structured data type, called a class, which is specifically designed to group data and functions.
This chapter first introduces classes and explains how to use them and then discusses the similarities and differences between a struct and a class.
In fact, a struct and a class have similar capabilities, as discussed in the section "A struct versus a class" in this chapter.
Classes Chapter 1 introduced the problem-solving methodology called object-oriented design (OOD).
In OOD, the first step is to identify the components, called objects.
An object combines data and the operations on that data in a single unit.
In Cplus_plus, the mechanism that allows you to combine data and the operations on that data in a single unit is called a class.
Now that you know how to store and manipulate data in computer memory and how to construct your own functions, you are ready to learn how objects are constructed.
This and subsequent chapters develop and implement programs using OOD.
This chapter first explains how to define a class and use it in a program.
A class is a collection of a fixed number of components.
The components of a class are called the members of the class.
The general syntax for defining a class is: class classIdentifier { classMembersList }; in which classMembersList consists of variable declarations and/or functions.
That is, a member of a class can be either a variable (to store data) or a function (to manipulate data).
For example, the following statements define the class courseType, with variables and functions, to implement the basic properties of a course.
If a member of a class is a variable, you declare it just like any other variable.
Also, in the definition of the class, you cannot initialize a variable when you declare it.
If a member of a class is a function, you typically use the function prototype to declare that member.
If a member of a class is a function, it can (directly) access any member of the class—member variables and member functions.
That is, when you write the definition of a member function, you can directly access any member variable of the class without passing it as a parameter.
The only condition is that you must declare an identifier before you can use it.
In Cplus_plus, class is a reserved word, and it defines only a data type; no memory is allocated.
It announces the declaration of a class.
Moreover, note the semicolon (;) after the right brace.
The semicolon is part of the syntax.
A missing semicolon, therefore, will result in a syntax error.
The members of a class are classified into three categories: private, public, and protected.
This chapter mainly discusses the first two types, private and public.
In Cplus_plus, private, protected, and public are reserved words and are called member access specifiers.
Following are some facts about public and private members of a class:.
By default, all members of a class are private.
If a member of a class is private, you cannot access it directly from.
A public member is accessible outside of the class.
To make a member of a class public, you use the member access specifier public with a colon, :.
Suppose that we want to define a class to implement the time of day in a program.
Because a clock gives the time of day, let us call this class clockType.
Furthermore, to represent time in computer memory, we use three int variables: one to represent the hours, one to represent the minutes, and one to represent the seconds.
Suppose these three variables are:.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Set the time.
Retrieve the time.
Print the time.
Increment the time by one second.
Increment the time by one minute.
Increment the time by one hour.
Compare the two times for equality.
To implement these seven operations, we will write seven functions—setTime, getTime, printTime, incrementSeconds, incrementMinutes, incrementHours, and equalTime.
From this discussion, it is clear that the class clockType has 10 members: three member variables and seven member functions.
Some members of the class clockType will be private; others will be public.
Deciding which member to make public and which to make private depends on the nature of the member.
The general rule is that any member that needs to be directly accessed outside of the class is declared public; any member that should not be accessed directly by the user should be declared private.
For example, the user should be able to set the time and print the time.
Therefore, the members that set the time and print the time should be declared public.
Similarly, the members to increment the time and compare the time for equality should be declared public.
On the other hand, to prevent the direct manipulation of the member variables hr, min, and sec, we will declare them private.
Furthermore, note that if the user has direct access to the member variables, member functions such as setTime are not explains why some members need to be public and others should be private.
The following statements define the class clockType: class clockType {.
The class clockType has seven member functions: setTime, getTime, printTime, incrementSeconds, incrementMinutes, incrementHours, and equalTime.
It has three member variables: hr, min, and sec.
The three member variables—hr, min, and sec—are private to the class and cannot be accessed outside of the class.
They can also directly access the member variables (hr, min, and sec).
In other words, when we write the definitions of these functions, we do not pass these member variables as parameters to the member functions.
In the function equalTime, the formal parameter is a constant reference parameter.
That is, in a call to the function equalTime, the formal parameter receives the address of the actual parameter, but the formal parameter cannot modify the value of the actual parameter.
You could have declared the formal parameter as a value parameter, but that would require the formal parameter to copy the value of the actual parameter, which could result  poor performance.
The private and public members can appear  any order.
If you want, you can declare the private members first and then declare the public ones.
The section "Order of public and private Members of a "  this chapter discusses this issue.
In the definition of the class clockType, all member variables are private and all member functions are public.
For example, if a member function is used only to implement other member functions of the class and the user does not need to access this function, you make it private.
Similarly, a member variable of a class can also be public.
Note that we have not yet written the definitions of the member functions of the class.
You will learn how to write them shortly.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated,  whole or  part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The given values are passed as parameters to the function setTime.
The function printTime prints the time, that is, the values of hr, min, and sec.
The function incrementSeconds increments the time by one second, the function incrementMinutes increments the time by one minute, the function incrementHours increments the time by one hour, and the function equalTime compares two times for equality.
Note that the function equalTime has only one parameter, although you need two things to make a comparison.
We will explain this point with the help of an example the section "Implementation of Member Functions," later  this chapter.
Unified Modeling Language  Diagrams A class and its members can be described graphically using a notation known as the Unified Modeling Language (UML) notation.
For example, Figure 10-1 shows the UML class diagram of the class clockType.
UML class diagram of the class clockType The top box contains the name of the class.
The middle box contains the member variables and their data types.
The last box contains the member function name, parameter list, and the return type of the function.
A + (plus) sign  front of a member name indicates that this member is a public member; a - (minus) sign indicates that this is a private member.
The symbol # before the member name indicates that the member is a protected member.
Variable (Object) Declaration Once a class is defined, you can declare variables of that type.
In Cplus_plus terminology, a class variable is called a class object or class instance.
To help you become familiar with this terminology, from now on we will use the term class object, or simply object, for a class variable.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated,  whole or  part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Each object has separate memory allocated for hr, min, and sec.
In actuality, memory is allocated only for the member variables of each class object.
The Cplus_plus compiler generates only one physical copy of a member function of a class, and each class object executes the same copy of the member function.
Therefore, whenever we draw the figure of a class object, we will show only the member variables.
As an example, Figure 10-2 shows the objects myClock and yourClock with values  their member variables.
The general syntax for an object to access a member of a class is: classObjectName_0_memberName The class members that a class object can access depend on where the object is declared.
If the object is declared  the definition of a member function of the class, then the object can access both the public and private members.
If the object is declared elsewhere (for example,  a user's program), then the object can access only the public members of the class.
Recall that  Cplus_plus, the dot,.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated,  whole or  part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
These statements are legal; that is, they are syntactically correct.
In the first statement, myClock_0_setTime(5, 2, 30);, the member function setTime is executed.
The values 5, 2, and 30 are passed as parameters to the function setTime, and the function uses these values to set the values of the three member variables hr, min, and sec of myClock to 5, 2, and 30, respectively.
Similarly, the second statement executes the member function printTime and outputs the contents of the three member variables of myClock.
In the third statement, the values of the variables x, y, and z are used to set the values of the three member variables of yourClock.
In the fourth statement, the member function equalTime executes and compares the three member variables of myClock to the corresponding member variables of yourClock.
Because in this statement equalTime is a member of the object myClock, it has direct access to the three member variables of myClock.
So it needs one more object, which in this case is yourClock, to compare.
In essence, equalTime needs two objects to compare.
The object to which it is dotted, myClock, is one and the argument, yourClock, is the other.
This explains why the function equalTime has only one parameter.
The objects myClock and yourClock can access only public members of the class clockType.
Thus, the following statements are illegal because  and  are declared as private members of the class clockType and, therefore, cannot be accessed by the objects myClock and yourClock:.
You cannot use arithmetic operators to perform arithmetic operations on class objects (unless they are overloaded; see Chapter 13).
For example, you cannot use the operator + to add two class objects of, say, type clockType.
Also, you cannot use relational operators to compare two class objects for equality (unless they are overloaded; see Chapter 13).
The two built-in operations that are valid for class objects are member access (_0_) and (=).
You have seen how to access an individual member of a class by using the name of the class object, then a dot, and then the member name.
Assignment Operator and Classes Suppose that myClock and yourClock are clockType objects, as defined previously.
Furthermore, suppose that the values of myClock and yourClock are as shown in Figure 10-3(a).
In other words, the values of the three member variables of yourClock are copied into the corresponding member variables of.
Therefore, an  statement Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
After the statement in Line 1 executes, the values of and yourClock are as shown in Figure 10-3(b).
Class Scope A class object can be either automatic (that is, created each time the control reaches its declaration and destroyed when the control exits the surrounding block) or static (that is, created once, when the control reaches its declaration, and destroyed when the program terminates).
Also, you can declare an array of class.
A class object has the same scope as other variables.
A member of a class has the same scope as a member of a struct.
That is, a member of a class is local to the class.
You access a class member outside of the class by using the class object name and the member access operator (_0_).
Functions and Classes The following rules describe the relationship between functions and classes:.
Class  can be passed as parameters to functions and returned as function values.
As parameters to functions, class  can be passed either by value or by reference.
If a class object is passed by value, the contents of the member variables of the actual parameter are copied into the corresponding member variables of the formal parameter.
Recall that when a variable is passed by value, the formal parameter copies the value of the actual parameter.
That is, memory space to copy the value of the actual parameter is allocated for the formal parameter.
As a parameter, a class object can be passed by value.
Suppose that a class has several member variables requiring a large amount of memory to store data, and you need to pass a variable by value.
The corresponding formal parameter then receives a copy of the data of the variable.
That is, the compiler must allocate memory for the formal parameter, so as to copy the value of the member variables of the actual parameter.
This operation might require, in addition to a large amount of storage space, a considerable amount of computer time to copy the value of the actual parameter into the formal parameter.
On the other hand, if a variable is passed by reference, the formal parameter receives only the address of the actual parameter.
Therefore, an efficient way to pass a variable as a parameter is by reference.
If a variable is passed by reference, then when the formal parameter changes, the actual parameter also changes.
Sometimes, however, you do not want the function to be able to change the values of the member variables.
In Cplus_plus, you can pass a variable by reference and still prevent the function from changing its value by using the keyword const in the formal parameter declaration.
As an example, consider the following function definition: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The parameter otherClock is declared using the keyword const.
Thus, in a call to the function testTime, the formal parameter otherClock receives the address of the actual parameter, but otherClock cannot modify the contents of the actual parameter.
For example, after the following statement executes, the value of  will not be altered: testTime(); In fact, if the function testTime attempts to modify otherClock, the compiler will generate syntax errors.
Generally, if you want to declare a class object as a value parameter, you declare it as a reference parameter using the keyword const, as described previously.
Recall that if a formal parameter is a value parameter, within the function definition, you can change the value of the formal parameter.
That is, you can use an assignment statement to change the value of the formal parameter (which, of course, would have no effect on the actual parameter).
However, if a formal parameter is a constant reference parameter, you cannot use an assignment statement to change its value within the function, nor can you use any other function to change its value.
Therefore, within the definition of the function testTime, you cannot alter the value of For example, the following would be illegal in the definition of the function testTime:.
Implementation of Member Functions When we defined the class clockType, we included only the function prototype for the member functions.
For these functions to work properly, we must write the related algorithms.
One way to implement these functions is to provide the function definition rather than the function prototype in the class itself.
Unfortunately, the class definition would then be very long and difficult to comprehend.
Another reason for providing function prototypes instead of function definitions relates to information hiding; that is, we want to hide the details of the operations on the data.
We Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
That is, we will write the definitions of the functions setTime, getTime, printTime, incrementSeconds, equalTime, and so on.
Because the identifiers setTime, outside of the class.
In order to reference these identifiers, we use the scope resolution operator, :: (double colon).
In the function definition's heading, the name of the function is the name of the class, followed by the scope resolution operator, followed by the function name.
For example, the definition of the function setTime is as follows: {.
Note that the definition of the function setTime checks for the valid values of hours, minutes, and seconds.
If these values are out of range, the member variables , , and  are initialized to 0.
Let us now explain how the member function setTime works when accessed by an object of type clockType.
The member function setTime is a void function and has three parameters.
A call to this function is a stand-alone statement.
We must use three parameters in a call to this function.
Furthermore, recall that because setTime is a member of the class clockType, it can directly access the member variables , , and , as shown in the definition of setTime.
Suppose that myClock is an object of type clockType (as declared previously).
The object myClock has three member variables, as shown in Figure 10-4(a).
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time  subsequent rights restrictions require it.
Now the function setTime is called with parameters 3, 48, and 52.
So the values of the formal parameters hours, minutes, and seconds of the function setTime are 3, 48, and 52, respectively.
Next, in the statement myClock_0_setTime(3, 48, 52);, setTime is accessed by the object myClock.
Therefore, the three variables—, , and —referred to in the body of the function setTime are the three member variables of myClock.
When the body of the function setTime executes, the value of hours is copied into myClock_0_, the value of minutes is copied into myClock_0_, and the value of seconds is copied into myClock_0_.
In essence, the values, 3, 48, and 52, which are passed as parameters in the preceding statement, are assigned to the three member variables of myClock by the function setTime (see the body of the function setTime).
After the previous statement executes, the object myClock is as shown in Figure 10-4(b).
Next, let us give the definitions of the other member functions of the class clockType.
The definitions of these functions are simple and easy to follow: void clockType::getTime(int& , int& , int& ) const.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time  subsequent rights restrictions require it.
From the definitions of the functions incrementMinutes and incrementSeconds, it is clear that a member function of a class can call other member functions of the class.
The function equalTime has the following definition: bool clockType::equalTime(const clockType& otherClock) const {.
Suppose that myClock and yourClock are objects of type clockType, as declared previously.
Further suppose that we have myClock and yourClock, as shown in Figure 10-5.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time  subsequent rights restrictions require it.
Objects myClock and yourClock Consider the following statement:.
In the expression: the object myClock accesses the member function equalTime.
Because otherClock is a reference parameter, the address of the actual parameter yourClock is passed to the formal parameter otherClock, as shown in Figure 10-6.
Object myClock and parameter otherClock The member variables , , and  of otherClock have the values 14, 25, and 54, respectively.
In other words, when the body of the function equalTime executes, the value of otherClock.
The function equalTime is a member of myClock.
When the function equalTime executes, the variables , , and  in the body of the function equalTime are the member variables of the object myClock.
Therefore, the member  of myClock is compared with otherClock_0_, the member  of myClock is compared with otherClock_0_, and the member  of myClock is compared with otherClock_0_.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Let us again take a look at the definition of the function equalTime.
Notice that within the definition of this function, the object otherClock accesses the member variables , , and.
However, these member variables are private.
The function equalTime is a member of the class clockType, and , , and  are the member variables.
Moreover, otherClock is an object of type clockType.
Therefore, the object otherClock can access its private member variables within the definition of the function equalTime.
The same is true for any member function of a class.
In general, when you write the definition of a member function, say, dummyFunction, of a class, say, dummyClass, and the function uses an object, dummyObject of the class dummyClass, then within the definition of dummyFunction, the object dummyObject can access its private member variables (in fact, any private member of the class).
Once a class is properly defined and implemented, it can be used in a program.
A program or software that uses and manipulates the objects of a class is called a client of that class.
When you declare objects of the class clockType, every object has its own copy of the member variables , , and.
In object-oriented terminology, variables such as , , and  are called instance variables of the class because every object instance has its own copy of the data.
Accessor and Mutator Functions Let us look at the member functions of the class clockType.
The function setTime sets the values of the member variables to the values specified by the user.
In other words, it alters or modifies the values of the member variables.
Similarly, the functions incrementSeconds, incrementMinutes, and incrementHours also modify the member variables.
On the other hand, functions such as getTime, printTime, and equalTime only access the values of the member variables.
They do not modify the member variables.
We can, therefore, categorize the member functions of the class clockType into two categories: member functions that modify the member variables and member functions that only access, but do not modify, the member variables.
This is typically true for any class.
That is, every class has member functions that only access but do not modify the member variables, called accessor functions, and member functions that modify the member variables, called mutator functions.
Accessor function: A member function of a class that only accesses (that is, does not modify) the value(s) of the member variable(s).
Mutator function: A member function of a class that modifies the value(s) of the member variable(s).
Moreover, a constant member function of a class cannot modify the member variables of that class.
For example, see the headings of the member functions getTime, printTime, and equalTime of the class clockType.
A member function of a class is called a constant function if its heading contains the reserved word const at the end.
For example, the member functions getTime, printTime, and equalTime of the class clockType are constant functions.
A constant member function of a class cannot modify the member variables of that class, so these are accessor functions.
One thing that should be remembered about constant member functions is that a constant member function of a class can only call other constant member functions of that class.
Therefore, you should be careful when you make a member function constant.
Example 10-2 shows how to use the class clockType in a program.
Note that we have combined the definition of the class, the definition of the member functions, and the main function to create a complete program.
Later in this chapter, you will learn how to separate the definition of the class clockType, the definitions of the member functions, and the main program, using three files.
EXAMPLE 10-2 //The program listing of the program that defines //and uses the class clockType.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sample Run: In this sample run, the user input is shaded.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time  subsequent rights restrictions require it.
The only thing you need to remember is that, by default, all members of a class are private.
You must use the member access specifier public to make a member available for public access.
Member access remains as set for all declared members until explicitly reset, so public sets all members public until explicitly changed to private.
Therefore,  you decide to declare the private members after the public members (as is done in the case of clockType), you must use the member access specifier private to begin the declaration of the private members.
We can declare the class clockType in one of three ways, as shown in Examples 10-3 through 10-5.
EXAMPLE 10-3 This declaration is the same as before.
For the sake of completeness, we  the class definition: class clockType {.
Classes public: void void void void void void bool };.
In Example 10-5, because the identifiers , , and  do not follow any member access specifier, they are by default private.
It is a common practice to list all of the public members first and then the private members.
This way, you can focus your attention on the public members.
Constructors In the program in Example 10-2, when we printed the value of yourClock without calling the function setTime, the output was some strange numbers (see the output of 5 in the sample run).
This is due to the fact that Cplus_plus does not automatically initialize the variables.
Because the private members of a class cannot be accessed outside of the class (in our case, the member variables),  the user forgets to initialize these variables by calling the function setTime, the program will produce erroneous results.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time  subsequent rights restrictions require it.
There are two types of constructors: with parameters and without parameters.
The constructor without parameters is called the default constructor.
Constructors have the following properties:.
The name of a constructor is the same as the name of the class.
A constructor is a function and it has no type.
That is, it is neither a value-returning function nor a void function.
A class can have more than one constructor.
However, all constructors of a class have the same name.
If a class has more than one constructor, the constructors must have different formal parameter lists.
That is, either they have a different number of formal parameters or, if the number of formal parameters is the same, then the data type of the formal parameters, in the order you list, must differ in at least one position.
In other words, like function overloading, a constructor's name is overloaded.
Constructors execute automatically when a class object is declared and enters its scope.
Because they have no types, they cannot be called like other functions.
Which constructor executes depends on the types of values passed to the class object when the class object is declared.
Let us extend the definition of the class clockType by including two constructors: class clockType.
Let us now write the definitions of these constructors: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time  subsequent rights restrictions require it.
From the definitions of these constructors, it follows that the default constructor sets the three member variables—, , and —to 0.
Also, the constructor with parameters sets the member variables to whatever values are assigned to the formal parameters.
Moreover, we can write the definition of the constructor with parameters by calling the function setTime, as follows:.
Invoking a Constructor Recall that when a class object is declared, a constructor is automatically executed.
Because a class might have more than one constructor, including the default constructor, next we discuss how to invoke a specific constructor.
Invoking the Default Constructor Suppose that a class contains the default constructor.
The syntax to invoke the default constructor is: className classObjectName; For example, the statement:.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time  subsequent rights restrictions require it.
In this case, the default constructor executes because no arguments are included in the declaration and the member variables of yourClock are initialized to 0.
If you declare an object and want the default constructor to be executed, the empty parentheses after the object name are not required in the object declaration statement.
In fact,  you accidentally include the empty parentheses, the compiler generates a syntax error message.
For example, the following statement to declare the object yourClock is illegal:.
Note the following:.
The number of arguments and their type should match the formal parameters (in the order given) of one of the constructors.
If the type of the arguments does not match the formal parameters of any constructor (in the order given), Cplus_plus uses type conversion and looks for the best match.
For example, an integer value might be converted to a floating-point value with a zero decimal part.
Any ambiguity will result in a compile-time error.
Consider the statement: clockType myClock(5, 12, 40); This statement declares an object myClock of type clockType.
Here, we are passing three values of type int, which matches the type of the formal parameters of the constructor with a parameter.
Therefore, the constructor with parameters of the class clockType executes, and the three member variables of the object myClock are set to 5, 12, and 40.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time  subsequent rights restrictions require it.
EXAMPLE 10-6 Consider the following class definition: class inventory {.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time  subsequent rights restrictions require it.
Consider the following declarations: inventory inventory inventory inventory.
For item1, the default constructor in Line 1 executes because no value is passed to this variable.
For item2, the constructor in Line 2 executes because only one parameter, which is of type string, is passed, and it matches with the constructor in Line 2.
For item3, the constructor in Line 3 executes because three parameters are passed to item3, and they match with the constructor in Line 3.
Similarly, for item4, the constructor in Line 4 executes (see Figure 10-7).
Effect of constructors on objects If the values passed to a class object do not match the parameters of any constructor and if no type conversion is possible, a compile-time error will be generated.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
In such cases, the rules for declaring formal parameters are the same as those for declaring default formal parameters in a function.
Moreover, actual parameters to a constructor with default parameters are passed according to the rules for functions with default parameters.
In the implementation file, the definition of this constructor is the same as the definition of the constructor with parameters.
If you replace the constructors of the class clockType with the constructor in Line 1 (the constructor with the default parameters), then you can declare clockType objects with zero, one, two, or three arguments, as follows: clockType clockType clockType clockType.
The member variable hr of clock2 is initialized to 5, and the member variables min and sec of clock2 are initialized to 0.
The member variable hr of clock3 is initialized to 12, the member variable min of clock3 is initialized to 30, and the member variable sec of clock3 is initialized to 0.
The member variable hr of clock4 is initialized to 7, the member variable min of clock4 is initialized to 34, and the member variable sec of clock4 is initialized to 18.
Using these conventions, we can say that a constructor that has no parameters, or has all default parameters, is called the default constructor.
Classes and Constructors: A Precaution As discussed in the preceding section, constructors provide guaranteed initialization of the object's member variables.
Typically, the default constructor is used to initialize the member variables to some default values, and this constructor has no parameters.
A constructor with parameters is used to initialize the member variables to some specific values.
We have seen that if a class has no constructor(s), then the object created is uninitialized because Cplus_plus does not automatically initialize variables when they are declared.
In reality, if a class has no constructor(s), then Cplus_plus automatically provides the default constructor.
However, this default constructor does not initialize the object being declared.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
If a class has no constructor(s), Cplus_plus automatically provides the default constructor.
However, the object declared is still uninitialized.
On the other hand, suppose a class, say, dummyClass, includes constructor(s) with parameter(s) and does not include the default constructor.
In this case, Cplus_plus does not provide the default constructor for the class dummyClass.
Therefore, when an object of the class dummyClass is declared, we must include the appropriate arguments in its declaration.
The following code further explains this.
Consider the definition of the following class: class dummyClass { public:.
The class dummyClass has a constructor with parameters.
It does not have a default constructor written for it and Cplus_plus will not provide one automatically because at least one constructor has been written for it.
Given this definition of the class dummyClass, the following object declaration is legal:.
In-line initialization of Data Members and the Default Constructor Cplus_plus11 standard allows the initialization of data members when they are declared in a class.
For example, the definition of the class clockType can also be written as follows: class clockType {.
In this class definition, the data members , , and  are declared as well as initialized.
This is called in-line initialization of the data members and in many situations eliminates the declaration of the default constructor.
When an object of the class clockType is declared without parameters, then the object is initialized using the in-line initialized values.
If an object is declared with parameters, then the default values are overridden by the constructor with the parameters.
For example, consider the following statements: clockType myTime; clockType yourTime(3, 40, 18); The , , and  of myTime are each set to 0, while the , , and  of yourTime are set to 3, 40, and 18, respectively.
At the time of the writing of this book, the compiler that we used to create and test code had not implemented this feature of Cplus_plus11.
Therefore, we will continue to include the default constructor in the definition of a class.
Arrays of Class  (Variables) and Constructors If a class has constructors and you declare an array of that class's objects, the class should have the default constructor.
The default constructor is typically used to initialize each (array) class object.
For example, if you declare an array of 100 class objects, then it is impractical (if not impossible) to specify different constructors for each component.
You can declare two arrays—arrivalTimeEmp and departureTimeEmp—of 100 components each, wherein each component is an object of type clockType.
Consider the following statement:.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Array arrivalTimeEmp You can now use the functions of the class clockType to manipulate the time for each employee.
For example, the following statement sets the arrival time, that is, ,.
Array arrivalTimeEmp after setting the time of employee 49 To output the arrival time of each employee, you can use a loop, such as the following:.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Similarly, you can use arrays to manage a list of names or other objects.
Before leaving our discussion of arrays of class objects, we would like to point out the following: The beginning of this section stated that if you declare an array of class objects and the class has constructor(s), then the class should have the default constructor.
The compiler uses the default constructor to initialize the array of objects.
If the array size is large, then it is impractical to specify a different constructor with parameters for each object.
For a small-sized array, we can manage to specify a different constructor with parameters.
For example, the following statement declares  to be an array of two components.
The member variables of the first component are initialized to 8, 35, and 42, respectively.
The member variables of the second component are initialized to 6, 52, and 39, respectively.
Consider the following statement, which creates the object  and initializes its member variables to 10, 45, and 38, respectively.
This is how we have been creating and initializing objects.
It does not first require that an anonymous object be created and then member-wise copied in order to initialize.
The main point that we are stressing here, and that we discussed in the preceding section, is the following: To avoid any pitfalls, if a class has constructor(s), it should also have the default constructor.
Destructors Like constructors, destructors are also functions.
Moreover, like constructors, a destructor does not have a type.
That is, it is neither a value-returning function nor a void function.
However, a class can have only one destructor, and the destructor has no parameters.
The name of a destructor is the tilde character (~), followed by the name of the class.
For example, the name of the destructor for the class clockType is: ~clockType(); Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The use of destructors is discussed in subsequent chapters.
Data Abstraction, Classes, and Abstract Data Types For the car that we drive, most of us want to know how to start the car and drive it.
Most people are not concerned with the complexity of how the engine works.
By separating the design details of a car's engine from its use, the manufacturer helps the driver focus on how to drive the car.
Our daily life has other similar examples.
For the most part, we are concerned only with how to use certain items, rather than with how they work.
Separating the design details (that is, how the car's engine works) from its use is called abstraction.
In other words, abstraction focuses on what the engine does and not on how it works.
Thus, abstraction is the process of separating the logical properties from the implementation details.
Driving the car is a logical property; the construction of the engine constitutes the implementation details.
We have an abstract view of what the engine does but are not interested in the engine's actual implementation.
Abstraction can also be applied to data.
Earlier sections of this chapter defined a data type clockType.
The data type clockType has three member variables and the following basic operations: 1.
Set the time.
Return the time.
Print the time.
Increment the time by one second.
Increment the time by one minute.
Increment the time by one hour.
Compare two times to see whether they are equal.
The actual implementation of the operations, that is, the definitions of the member functions of the class clockType, was postponed.
Data abstraction is defined as a process of separating the logical properties of the data from its implementation.
The definition of clockType and its basic operations are the logical properties; the storing of clockType objects in the computer and the algorithms to perform these operations are the implementation details of clockType.
Abstract data type (ADT): A data type that separates the logical properties from the implementation details.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Data Abstraction, Classes, and Abstract Data Types | 681 Like any other data type such as int, an ADT has three things associated with it: the name of the ADT, called the type name; the set of values belonging to the ADT, called the domain; and the set of operations on the data.
Return the time.
Print the time.
Increment the time by one second.
Increment the time by one minute.
Increment the time by one hour.
Compare the two times to see whether they are equal.
EXAMPLE 10-7 A list is defined as a set of values of the same type.
Because all values in a list are of the same type, a convenient way to represent and process a list is to use an array.
You can define a list as an ADT as follows: dataTypeName listType domain Every listType value is an array of, say, 1000 numbers operations Check to see whether the list is empty.
Check to see whether the list is full.
Search the list for a given item.
Delete an item from the list.
Insert an item in the list.
Sort the list.
Destroy the list.
Print the list.
The next obvious question is how to implement an ADT in a program.
To implement an ADT, you must represent the data and write algorithms to perform the operations.
The previous section used classes to group data and functions together.
Furthermore, our definition of a class consisted only of the specifications of the operations; functions to implement the operations were written separately.
Thus, we see that classes are a convenient way to implement an ADT.
In fact, in Cplus_plus, classes were specifically designed to handle ADTs.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Typically in a list, not only do we store the elements, but we also keep track of the number of elements in the list.
Therefore, our class listType has two member variables: one to store the elements and another to keep track of the number of elements in the list.
The following class, listType, defines the list as an ADT.
UML class diagram of the class listType A struct Versus a class Chapter 9 defined a struct as a fixed collection of components, wherein the components can be of different types.
This definition of components in a struct included only member variables.
However, a Cplus_plus struct is very similar to a Cplus_plus class.
As with a Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Information Hiding | 683 class, members of a struct can also be functions, including constructors and a destructor.
The only difference between a struct and a class is that, by default, all members of a struct are public, and all members of a class are private.
You can use the member access specifier private in a struct to make a member private.
In C, the definition of a struct is similar to the definition of a struct in Cplus_plus, as given in Chapter 9.
Because Cplus_plus evolved from C, the standard C-structs are perfectly acceptable in Cplus_plus.
However, the definition of a struct in Cplus_plus was expanded to include member functions and constructors and destructors.
In the future, because a class is a syntactically separate entity, specially designed to handle an ADT, the definition of a class may evolve in a completely different way than the definition of a C-like struct.
Both Cplus_plus classes and structs have the same capabilities.
However, most programmers restrict their use of structures to adhere to their C-like structure form and thus do not use them to include member functions.
In other words, if all of the member variables of a class are public and the class has no member functions, you typically use a struct to group these member variables.
Information Hiding The previous section defined the class clockType to implement the time in a program.
We then wrote a program that used the class clockType.
In fact, we combined the class clockType with the function definitions to implement the operations and the function main so as to complete the program.
That is, the specification and implementation details of the class clockType were directly incorporated into the program.
Is it a good practice to include the specification and implementation details of a class in the program.
Suppose the definition of the class and the definitions of the member functions are directly included in the user's program.
The user then has direct access to the definition of the class and the definitions of the member functions.
Therefore, the user can modify the operations in any way the user pleases.
The user can also modify the member variables of an object in any way the user pleases.
Thus, in this sense, the private member variables of an object are no longer private to the object.
If several programmers use the same object in a project and if they have direct access to the internal parts of the object, there is no guarantee that every programmer will use the same object in exactly the same way.
Thus, we must hide the implementation details.
The user should know only what the object does, not how it does it.
Hiding the implementation details frees the user from having to fit this extra piece of code in the program.
Also, by hiding the details, we can ensure that an object will be used in exactly the same way throughout the project.
Furthermore, once an object has been written, debugged, and tested properly, it becomes (and remains) error-free.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
For illustration purposes, we will use the class clockType.
To implement clockType in a program, the user must declare objects of type clockType and know which operations are allowed and what the operations do.
So, the user must have access to the specification details.
Because the user is not concerned with the implementation details, we must put those details in a separate file called an implementation file.
Also, because the specification details can be too long, we must free the user from having to include them directly in the program.
However, the user must be able to look at the specification details so that he or she can correctly call the functions, and so forth.
We must, therefore, put the specification details in a separate file.
The file that contains the specification details is called the header file (or interface file).
The implementation file contains the definitions of the functions to implement the operations of an object.
This file contains, among other things (such as the preprocessor directives), the Cplus_plus statements.
Because a Cplus_plus program can have only one function, main, the implementation file does not contain the function main.
Only the user program contains the function main.
Because the implementation file does not contain the function main, we cannot produce the executable code from this file.
In fact, we produce what is called the object code from the implementation file.
The user then links the object code produced by the implementation file with the object code of the program that uses the class to create the final executable code.
Finally, the header file has an extension h, whereas the implementation file has an extension cpp.
Suppose that the specification details of the class clockType are in a file called clockType.
The complete name of this file should then be clockType_0_h.
If the implementation details of the class clockType are in a file—say, clockTypeImp—the name of this file must be clockTypeImp_0_cpp.
The file clockTypeImp_0_cpp contains only the definitions of the functions, not the definition of the class.
Thus, to resolve the problem of an undeclared identifier (such as the function names and variable names), we include the header file clockType_0_h in the file clockTypeImp_0_cpp with the help of the include statement.
The following include statement is required by any program that uses the class clockType, as well as by the implementation file that defines the operations for the class clockType: Note that the header file clockType_0_h is enclosed in double quotation marks, not angular brackets.
The header file clockType_0_h is called the user-defined header file.
Typically, all user-defined header files are enclosed in double quotation marks, whereas the system-provided header files (such as iostream) are enclosed between angular brackets.
Also, note that the preceding include statement assumes that the header file clockType_0_h is in the same directory as the _0_cpp file (user program).
The implementation contains the definitions of the functions, and these definitions are hidden from the user because the user is typically provided only the object code.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Information Hiding | 685 However, the user of the class should be aware of what a particular function does and how to use it.
Therefore, in the specification file with the function prototypes, we include comments that briefly describe the function and specify any preconditions and/ or postconditions.
Precondition: A statement specifying the condition(s) that must be true before the function is called.
Following are the specification and implementation files for the class clockType: //clockType_0_h, the specification file for the class clockType class clockType { public:.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Next, we describe the user file containing the program that uses the class clockType.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
To save space, we have not provided the complete details of the implementation file and the file that contains the user program.
However, you can find these files and the specification (header) file at the Web site accompanying this book.
Executable Code The previous section discussed how to hide the implementation details of a class.
To use an object in a program, during execution, the program must be able to access the implementation details of the object (that is, the algorithms to implement the operations on the object).
This section discusses how a client's program obtains access to the implementation details of an object.
For illustration purposes, we will use the class clockType.
As explained previously, to use the class clockType, the program must include the header file clockType_0_h via the include statement.
For example, the following program segment includes the header file clockType_0_h: //Program testClockClass_0_cpp.
To create the executable code to run the program testClockClass_0_cpp, the following steps are required: 1.
We separately compile the file clockTypeImp_0_cpp and create the object code file clockTypeImp_0_obj.
The object code file contains the machine language code, but the code is not in an executable form.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The command: cc -c clockTypeImp.
To create the executable code for the source code file testClock Class_0_, we compile the source code file testClockClass_0_, create the object code file testClockClass_0_obj, and then link the files testClockClass_0_obj and clockTypeImp_0_obj to create the executable file testClockClass_0_exe.
The following command on the system command line creates the executable file testClockClass_0_exe: cc testClockClass.
To create the object code file for any source code file, we use the command line option -c on the system command line.
For example, to create the object code file for the source code file, called exercise_0_, we use the following command on the system command line: cc -c exercise.
To link more than one object code file with a source code file, we list all of the object code files on the system command line.
For example, to link A_0_obj and B_0_obj with the source code file test_0_, we use the command: cc test.
If a source code file is modified, it must be recompiled.
If modifications in one source file affect other files, the other files must be recompiled and relinked.
The user must have access to the header file and the object code file.
Access to the header file is needed to see what the objects do and how to use them.
Access to the object code file is needed so that the user can link the program with the object code to produce an executable code.
The user does not need access to the source code file containing the implementation details.
As stated in Chapter 1, IDEs Visual Cplus_plus 2012 Express, Visual Studio 2012, and Cplus_plus Builder put the editor, compiler, and linker all into one package.
With one command, the program is compiled and linked with the other necessary files.
These systems also manage multiple-file programs in the form of a project.
Thus, a project consists of several files, called the project files.
These systems usually have a command, called build, rebuild, or make.
When one or more files in the project change, you can use these commands to recompile and relink the files.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
More Examples of Classes.
EXAMPLE 10-8 The following statements define the class circleType to implement the basic properties of a circle: class circleType {.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sample Run: In this sample run, the user input is shaded.
Line 7: circle1 - : 8_0_00, : 201_0_06, : 50_0_27 Line 8: circle2 - : 0_0_00, : 0_0_00, : 0_0_00 Line 9: Enter the  of a circle: 5_0_5 Line 13: After setting the.
Line 14: circle2 - : 5_0_50, : 95_0_03, : 34_0_56 The preceding program works as follows.
The statements in Lines 3 and 4 create the objects circle1 and circle2.
The  of circle1 is set to 8; and the  of circle2 is set to 0 by using the default value by the constructor.
The statements in Lines 7 and 8 output the  of circle1 and circle2.
The statements in Lines 9 and 10 prompt the user to enter the  of a circle and store the  in the variable.
The statement in Line 12 uses the member function setRadius and the value of to set the  of circle2.
The statement in Line 14 ouputs the ()  of circle2.
EXAMPLE 10-9 In Example 6-4, in Chapter 6, the function rollDice rolls a pair of dice until the sum of the numbers rolled is a given number and returns the number of times the dice are rolled to get the desired sum.
In fact, we can design a class that implements the basic properties of a die.
Consider the definition of the following class die.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sample Run: Line Line Line Line Line Line 5: 1: 1 6: 2: 1 8: After rolling 1: 2 10: After rolling 2: 6 11: The sum of the numbers rolled by the dice is: 8 14: After again rolling, the sum of the numbers rolled is: 5 The preceding program works as follows.
The statements in Lines 3 and 4 create the objects 1 and 2, and using the default constructor set both dice to 1.
The statements in Lines 5 and 6 output the number of both dice.
The statement in Line 7 rolls 1 and the statement in Line 8 outputs the number rolled.
Similarly, the statement in Line 9 rolls 2 and the statement in Line 10 outputs the number rolled.
The statement in Line 11 outputs the sum of the numbers rolled by 1 and 2.
The statements in Lines 12 and 13 again rolls both dice and the statement in Line 14 outputs the sum of the numbers rolled.
The class personType that is designed in Example 10-10 is very useful; we will use this class in subsequent chapters.
EXAMPLE 10-10 The most common attributes of a person are the person's first and last name.
The typical operations on a person's name are to set the name and print the name.
The following statements define a class with these properties.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
More Examples of Classes.
EXAMPLE 10-11 In this example, we design and implement a class to manipulate an integer.
Some of the operations that can be performed on this integer are: count the number of even digits, odd digits, and zeros; find the sum of the digits; reverse the digits; split the number in the block of three-digit numbers; and find the sum of these numbers.
The following class defines some of these operations.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
More Examples of Classes.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sample Run: In this sample run, the user input is shaded.
Enter an integer: 90237104628012645 90237104628012645- - - - - The number of even digits: 11 The number of zeros: 3 The number of odd digits: 6 Programming Exercise 21, at the end of this chapter, asks you to write the definition of the functions of the class integerManipulation that are not given.
Static Members of a Class This section may be skipped without any loss of continuation.
In  6, we described two types of variables: automatic and static.
Recall that if a local variable of a function is static, it exists between function calls.
Similar to static variables, a class can have static members, functions, or variables.
Let us note the following about the static members of a class:.
If a function of a class is static, in the class definition it is declared using the keyword static in its heading.
If a member variable of a class is static, it is declared using the keyword static, as discussed in  6 and also illustrated in Example 10-12.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Static Members of a  |.
Example 10-12 clarifies the effect of the keyword static.
EXAMPLE 10-12 Consider the following definition of the class illustrate: class illustrate {.
Suppose that the static member variables and the definitions of the member functions of the class illustrate are as follows.
Also, notice that all static member variables are initialized, as.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Suppose that you have class, say, myClass, with member variables (static as well as non-static ).
When you create objects of type myClass, only non-static member variables of the class myClass become the member variables of each object.
For each static member variable of  class, Cplus_plus allocates only one memory space.
All myClass objects refer to the same memory space.
In fact, static member variables of  class exist even when no object of that class type exists.
You can access the public static member variables outside of the class, as explained earlier in this section.
Next, we explain how memory space is allocated for static and non-static member variables of  class.
Suppose that you have the class illustrate, as given in Example 10-12.
Memory space then exists for the static member variables  and.
Consider the following statements:.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Static Members of   | 701 0 0 illusObject1 illusObject2 FIGURE 10-12.
Similarly, the output of the statement: illusObject2_0_print();.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Now consider the statement: illustrate::countplus_plus; After this statement executes, the objects and static members are as shown in Figure 10-14.
The program in Example 10-13 further illustrates how static members of  class work.
Sample Run: = 3,  = 1,  = 1 = 5,  = 1,  = 1 Line 7: ***Increment  using 1*** = 8,  = 2,  = 1 = 5,  = 2,  = 1 Line 12: ***Increment  using 2*** = 8,  = 3,  = 1 = 23,  = 3,  = 1 The preceding program works as follows.
The static member variables  and are initialized to 0.
The statement in Line 1 declares 1 to be an object of the class illustrate and initializes its member variable  to 3.
The statement in Line 2 declares 2 to be an object of the class illustrate and initializes its member variable  to 5.
The statement in Line 3 uses the name of the class illustrate and the function incrementY to increment.
Now,  is a public static member of the class illustrate.
So the statement in Line 4 uses the name of the class illustrate to directly access  and increments it by 1.
The statements in Lines 5 and 6 output the data stored in the objects 1 and 2.
Notice that the value of  for both objects is the same.
Similarly, the value of  for both objects is the same.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The statement in Line 8 uses the object 1 and the function incrementY to increment.
The statement in Line 9 sets the value of the member variable  of 1 to 8.
Lines 10 and 11 output the data stored in the objects 1 and 2.
Notice that the value of  for both objects is the same.
Similarly, the value of  for both objects is the same.
Moreover, notice that the statement in Line 9 changes only the value of the member variable  of 1 because  is not a static member of the class illustrate.
The statement in Line 13 uses the object 2 and the function incrementY to increment.
The statement in Line 14 sets the value of the member variable  of 2 to 23.
Lines 15 and 16 output the data stored in the objects 1 and 2.
Notice that the value of  for both objects is the same.
Similarly, the value of  for both objects is the same.
Moreover, notice that the statement in Line 14 changes only the value of the member variable  of 2, because  is not a static member of the class illustrate.
Here are some additional comments on static members of a class.
As you have seen in this section, a static member function of a class does not need any object to be invoked.
It can be called using the name of the class and the scope resolution operator, as illustrated.
Therefore, a static member function cannot use anything that depends on a calling object.
In other words, in the definition of a static member function, you cannot use a non-static member variable or a non-static function unless there is an object declared locally that accesses the non-static member variable or the nonstatic member function.
Let us again consider the class illustrate, as defined in Example 10-12.
This class contains both static and non-static member variables.
When we declare objects of this class, each object has its own copy of the member variable , which is non-static, and all objects share the member variables  and , which are static.
Earlier in this chapter, we defined the terminology instance variables of a class using the class clockType.
However, at that point, we did not discuss static member variables of a class.
A class can have static as well as non-static member variables.
We can, therefore, make the general statement that non-static member variables of a class are called the instance variables of the class.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: Juice Machine | PROGRAMMING EXAMPLE: Watch the Video 705 Juice Machine A common place to buy  is from a machine.
A new  machine has been purchased for the gym, but it is not working properly.
The machine sells the following types of juices: orange, apple, mango, and strawberry–banana.
You have been asked to write a program for this  machine so that it can be put into operation.
The program should do the following: 1.
PROBLEM ANALYSIS AND ALGORITHM DESIGN Input Show the customer the different products sold by the  machine.
Let the customer make the selection.
Show the customer the cost of the item selected.
Accept money from the customer.
Release the item.
The item selection and the cost of the item.
Output The selected item.
A  machine has two main components: a built-in cash register and several dispensers to hold and release the products.
Cash Register Let us first discuss the properties of a cash register.
The register has some cash on hand, it accepts the amount from the customer, and if the amount deposited is more than the cost of the item, then—if possible—it returns the change.
For simplicity, we assume that the user deposits the money greater than or equal to the cost of the product.
The cash register should also be able to show to the  machine's owner the amount of money in the register at any given time.
The following class defines the properties of a cash register: class cashRegister { public: int getCurrentBalance() const;.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
UML class diagram of the class cashRegister Next, we give the definitions of the functions to implement the operations of the class cashRegister.
The definitions of these functions are very simple and easy to follow.
The function getCurrentBalance shows the current amount in the cash register.
In the definition of the class cashRegister, the constructor is declared with a default value.
Therefore, if the user does not specify any value when the object is declared, the default value is used to initialize the member variable.
Recall that because we have specified the default value for the constructor's parameter in the Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: Juice Machine | 707.
The definition of the constructor is as follows:.
Note that the definition of the constructor checks for valid values of the parameter If the value of  is less than 0, the value assigned to the member variable  is 500.
Dispenser The dispenser releases the selected item if it is not empty.
It should show the number of items in the dispenser and the cost of the item.
The following class defines the properties of a dispenser.
Let us call this class dispenserType: class dispenserType { public: getNoOfItems() const; //Function to show the number of items in the machine.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Figure 10-16 shows the UML class diagram of the class dispenserType.
UML class diagram of the class dispenserType.
For example, the statement: dispenserType apple(100, 65); declares apple to be an object of type dispenserType, sets the number of apple juice bottles in the dispenser to 100, and sets the  of each apple juice bottle to 65 cents (see Figure 10-17).
Object apple Next, we discuss the definitions of the functions to implement the operations of the class dispenserType.
The function getNoOfItems returns the number of items of a particular product.
Because the number of items currently in the dispenser is stored in the private member variable , the function returns the value of The definition of this function is:.
Programming Example: Juice Machine | 709 The function getCost returns the  of a product.
Because the  of a product is stored in the private member variable , the function returns the value of.
MAIN PROGRAM When the program executes, it must do the following: 1.
Show the different products sold by the juice machine.
Show how to select a particular product.
Show how to terminate the program.
Furthermore, these instructions must be displayed after processing each selection (except exiting the program) so that the user need not remember what to do if he or she wants to buy two or more items.
Once the user has made the appropriate selection, the juice machine must act accordingly.
If the user has opted to buy a product and that product is available, the juice machine should show the  of the product and ask the user to deposit the money.
If the amount deposited is at least the  of the item, the juice machine should sell the item and display an appropriate message.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Show the selection menu to the customer.
If the selection is valid and the dispenser corresponding to the selection is not empty, sell the product.
We divide this program into three functions: showSelection, sellProduct, and main.
This definition of the function showSelection is:.
The first thing that this function does is check whether the dispenser holding the product is empty.
If the dispenser is empty, the function informs the customer that this product is sold out.
If the dispenser is not empty, it tells the user to deposit the necessary amount to buy the product.
If the user does not deposit enough money to buy the product, sellProduct tells the user how much additional money must be deposited.
If the user fails to deposit enough money in two tries to buy the product, the function simply returns the money.
Selling the product means to decrement the number of items in the dispenser by 1 and to update the money in the cash register by adding the  of the product.
Therefore, this function has two parameters: one corresponding to the dispenser and the other corresponding to the cash register.
Furthermore, both parameters must be referenced.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: Juice Machine | 711 In pseudocode, the algorithm for this function is: 1.
If the dispenser is not empty, a.
Show and prompt the customer to  the  of the item.
Get the amount entered by the customer.
If the amount entered by the customer is less than the  of the product, i.
Show and prompt the customer to  the additional amount.
Calculate the total amount entered by the customer.
If the amount entered by the customer is at least the  of the product, i.
Update the amount in the cash register by adding the amount entered by the user.
Sell the product—that is, decrement the number of items in the dispenser by 1.
Display an appropriate message.
If the amount entered by the user is less than the  of the item, return the amount.
If the dispenser is empty, tell the user that this product is sold out.
This definition of the function sellProduct is: void sellProduct(dispenserType& product, { int ; //variable to hold the  entered.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Create the cash register—that is, declare an object of type cashRegister.
Create four dispensers—that is, declare four objects of type dispenserType and initialize these objects.
For example, the statement: dispenserType orange(100, 50); 3.
The number of items in the dispenser is 100, and the cost of an item is 50.
Declare additional variables as necessary.
Show the selection; call the function showSelection.
While not done (a selection of 9 exits the program), a.
Sell the product; call the function sellProduct.
Show the selection; call the function showSelection.
Programming Example: Juice Machine |.
In the previous sections, we designed the classes to implement cash registers and dispensers to implement a juice machine.
In this section, for the sake of completeness, we give complete definitions of the classes, the implementation file, and the user program to implement a juice machine.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: Juice Machine |.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: Juice Machine |.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sample Run: In this sample run, the user input is shaded.
However, you can also place the definitions of these classes in separate header files and those header files in the files that use these classes, such as the implementation file of these classes and the file that contains the main program.
Similarly, you can also create separate implementation files for these classes.
The Web site accompanying this book contains these header and implementation files.
QUICK REVIEW 1.
A class is a collection of a fixed number of components.
Components of a class are called the members of the class.
Members of a class are accessed by name.
In Cplus_plus, class is a reserved word.
Members of a class are classified into one of three categories: private, protected, and public.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Quick Review | 6.
The public members of a class are directly accessible outside of the class.
By default, all members of a class are private.
The public members are declared using the member access specifier public and the colon, :.
The private members are declared using the member access specifier private and the colon, :.
A member of a class can be a function or a variable.
If any member of a class is a function, you usually use the function prototype to declare it.
If any member of a class is a variable, it is declared like any other variable.
In the definition of a class, you cannot initialize a variable when you declare it.
A member function of a class is called a constant function if its heading contains the reserved word const at the end.
Moreover, a constant member function of a class cannot modify the member variables of the class.
In the Unified Modeling Language (UML) diagram of a class, the top box contains the name of the class.
The middle box contains the member variables and their data types.
The last box contains the member function name, parameter list, and the return type of the function.
A + (plus) sign in front of a member indicates that this member is a public member.
A - (minus) sign preceding a member indicates that this is a private member.
The symbol # before the member name indicates that the member is a protected member.
In Cplus_plus, a class is a definition.
No memory is allocated for the class itself; memory is allocated for the class variables when you declare them.
In Cplus_plus, class variables are called class objects or class instances or, simply, objects.
A class member is accessed using the class variable name, followed by the dot operator (_0_), followed by the member name.
The only built-in operations on classes are the assignment and member selection.
As parameters to functions, classes can be passed either by value or by reference.
A function can return a value of type class.
For example, a function can return a value of clockType.
Any program (or software) that uses a class is called a client of the class.
A member function of a class that modifies the value(s) of the member variable(s) is called a mutator function.
A constant member function of a class can only call the other constant member functions of the class.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 10: Classes and Data Abstraction Constructors guarantee that the member variables are initialized when an object is declared.
The name of a constructor is the same as the name of the class.
A class can have more than one constructor.
A constructor without parameters is called the default constructor.
Constructors automatically execute when a class object enters its scope.
Destructors automatically execute when a class object goes out of scope.
A class can have only one destructor, and the destructor has no parameters.
The name of a destructor is the tilde (~), followed by the class name (no spaces in between).
Constructors and destructors are functions without any type; that is, they are neither value-returning nor void.
As a result, they cannot be called like other functions.
A data type that separates the logical properties from the implementation details is called an abstract data type (ADT).
Classes were specifically designed in Cplus_plus to handle ADTs.
To implement an ADT, you must represent the data and write related algorithms to implement the operations.
A precondition is a statement specifying the condition(s) that must be true before the function is called.
A postcondition is a statement specifying what is true after the function call is completed.
A public static member, function or variable, of a class can be accessed using the class name and the scope resolution operator, ::.
For each static variable of a class, Cplus_plus allocates only one memory space.
All objects of the class refer to the same memory space.
Non-static member variables of a class are called the instance variables of the class.
EXERCISES The number in parentheses at the end of an exercise refers to the learning objective listed at the beginning of the chapter.
Mark the following statements as true or false.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
How many members does class bagType have.
How many private members does class bagType have.
How many constructors does class bagType have.
How many constant functions does class bagType have.
Which constructor is used to initialize the object newBag.
Assume the definition of class bagType as given in Exercise 6.
Answer the a.
Write the definition of the member function set so that private members are set according to the parameters.
Write the definition of the member function print that prints the values of the data members.
Write the definition of the default constructor of the class bagType so that the private member variables are initialized to "", 0_0_0, 0_0_0, 0_0_0, 0_0_0, respectively.
Write a Cplus_plus statement that prints the value of the object newBag.
Write a Cplus_plus statement that declares the object tempBag of type bagType, and initializes the member variables of tempBag to "backPack", 15, 8, 20, and 49_0_99, respectively.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Write the definition of the constructor in Line 4 so that the instance variables are initialized to "", 0, and 0_0_0, respectively.
Write the definition of the constructor in Line 5 so that the instance variables are initialized according to the parameters.
Write the definition of the constructor in Line 6 so that the instance variable name is initialized to the empty string and the remaining instance variables are initialized according to the parameters.
Consider the definition of the class employee as given in Exercise 8.
Which Consider the definition of the class employee as given in Exercise 8.
Answer the a.
Write the definition of the function setData so that the instance variables are set according to the parameters.
Write the definition of the function print to output the values of the instance variables.
Write the definition of the function updateSalary to update the value of the instance variable salary by adding the value of the parameter.
Write the definition of the function getNumOfServiceYears to return the value of the instance variable numOfServiceYears.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 10: Classes and Data Abstraction Write the definition of the function getSalary to return the value of the instance variable salary.
Write a program to test the class employee.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Write the definition of the member function print that prints the values of the data members.
Write the definition of the constructor of the class houseType so that the private member variables are initialized according to the parameters.
Write a Cplus_plus statement that prints the value of the object newHouse.
Write a Cplus_plus statement that declares an object house of type newHouse, and initializes the member variables of house to "Ranch", 3, 2, 2, 2005, 1300, 185000, and 3600_0_0, respectively.
Which function members are accessors and which are mutators.
How many members does class temporary have.
How many private members does class temporary have.
How many constructors does class temporary have.
Can this constructor be used to initialize an object without specifying any parameters.
If yes, then illustrate with an example; otherwise, explain why it cannot be used to initialize an object witout specifying any parameters.
Assume the definition of class temporary as given in Exercise 13.
Write the definition of the member function set so that the instance variables are set according to the parameters.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 10: Classes and Data Abstraction Write the definition of the member function manipulate that returns a decimal number as follows: If the value of description is "rectangle", it returns first * second; if the value of description is "circle", it returns the  of the circle with radius first; if the value of description is "sphere", it returns the volume of the sphere with radius first; if the value of description is "cylinder", it returns the volume of the cylinder with radius first and height second; otherwise, it returns the value -1.
Write the definition of the function print to print the values of the instance variables and the values returned by the function manipulate.
For example, if description ¼ "rectangle", first ¼ 8_0_5, and second ¼ 5, it should print: rectangle:  = 8_0_50,  = 5_0_00,  = 42_0_50 d.
Write the definition of the constructor so that it initializes the instance variables using the function set.
Write the definition of the remaining functions to set or retrieve the values of the instance variables.
Note that the function get returns the values of all instance variables.
Assume the definition of class temporary as given in Exercise 13.
What is the temporary temporary temporary temporary.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Write the definitions of the member functions as described in the definition of the class testClass.
Write a test program to test the various operations of the class testClass.
Given the definition of the class clockType with constructors (as described in.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 10: Classes and Data Abstraction Assume the definition of the class personType as given in this chapter.
Write a Cplus_plus statement that declares student to be a personType object, and initialize its first name to "Buddy" and last name to "Arora".
Write a Cplus_plus statement that outputs the data stored in the object student.
Write a Cplus_plus statement that changes the first name of student to "Susan" and the last name to "Gilbert".
Explain why you would need both public and private members in a class.
The name of the class is secretType.
The class secretType has four member variables: name of type string, age and weight of type int, and height of type double.
The class secretType has the following member functions.
Write the definition of the member functions of the class secretType, as described in Part c.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Write  Cplus_plus statement that initializes the member variable count to 0.
Write  Cplus_plus statement that increments the value of count by 1.
Write  Cplus_plus statement that outputs the value of count.
Write the definitions of the functions of the class myClass as described in its definition.
Write  Cplus_plus statement that declares myObject1 to be  myClass object and initializes its member variable  to 5.
Write  Cplus_plus statement that declares myObject2 to be  myClass object and initializes its member variable  to 7.
Which of the following statements are valid.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
In Example 10-9, we designed the class die.
Using this class, declare an array named rolls of 100 components of type die.
Write Cplus_plus statements to roll each die of the array rolls, find and output the highest number rolled and the number of times this number was rolled, and find and output the number that is rolled the maximum number of times together with its count.
Also write  program to test your PROGRAMMING EXERCISES 1.
Chapter 9 defined the struct studentType to implement the basic properties of  student.
Define the class studentType with the same components as the struct studentType, and add member functions to manipulate the data members.
Write  program to illustrate how to use the class temporary, designed in Exercises 13 and 14 of this chapter.
Your program should not use the statements given in Exercises 15 and 16.
Also, your program must contain statements that would ask the user to enter data of an object and use the member function set to initialize the object.
Write  program that converts  number entered in Roman numerals to positive integer.
Your program should consist of  class, say, romanType.
An object of type romanType should do the following:.
Store the number as  Roman numeral.
Convert and store the number as  positive integer.
Print the number as  Roman numeral or positive integer as requested by the user.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Design and implement  class dayType that implements the day of the week in  program.
The class dayType should store the day, such as Sun for Sunday.
The program should be able to perform the following operations on an object of type dayType:.
Set the day.
Print the day.
Return the day.
Return the next day.
Return the previous day.
Calculate and return the day by adding certain days to the current day.
For example, if the current day is Monday and we add 4 days, the day to be returned is Friday.
Similarly, if today is Tuesday and we add 13 days, the day to be returned is Monday.
Add the appropriate constructors.
Write the definitions of the functions to implement the operations for the class dayType as defined in Programming Exercise 5.
Also, write a program to test various operations on this class.
This chapter defines the class clockType to implement time in a program.
Add functions to this class so that a program that uses this class can set only the hours, minutes, or seconds and retrieve only the hours, minutes, or seconds.
Also write a program to test your class.
Enhance Programming Exercise 7 by adding functions to the class clockType so that a program that uses this class can perform the following operations: a.
Returns the elapsed time of the day of a clock in seconds.
Returns the remaining time of the day of a clock in seconds.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 10: Classes and Data Abstraction Determine and output how far apart in time two clocks are.
Output the time in the form hr:min:sec.
Also write a program to test your class.
Example 10-10 defined a class personType to store the name of a person.
The member functions that we included merely print the name and set the name of a person.
Redefine the class personType so that, in addition to what the existing class does, you can: a.
Set the first name only.
Set the last name only.
Store and set the middle name.
Check whether a given first name is the same as the first name of this person.
Check whether a given last name is the same as the last name of this person.
Write the definitions of the member functions to implement the operations for this class.
Also, write a program to test various operations on this class.
Some of the characteristics of a book are the title, author(s), publisher, ISBN, price, and year of publication.
Design a class bookType that defines the book as an ADT.
Each object of the class bookType can hold the following information about a book: title, up to four authors, publisher, ISBN, price, and number of copies in stock.
To keep track of the number of authors, add another member variable.
Include the member functions to perform the various operations on objects of type bookType.
For example, the usual operations that can be performed on the title are to show the title, set the title, and check whether a title is the same as the actual title of the book.
Similarly, the typical operations that can be performed on the number of copies in stock are to show the number of copies in stock, set the number of copies in stock, update the number of copies in stock, and return the number of copies in stock.
Add similar operations for the publisher, ISBN, book price, and authors.
Add the appropriate constructors and a destructor (if one is needed).
Write the definitions of the member functions of the class bookType.
Write a program that uses the class bookType and tests various operations on the objects of the class bookType.
Declare an array of 100 components of type bookType.
Some of the operations that you should perform are to search for a book by its title, search by ISBN, and update the number of copies of a book.
In this exercise, you will design a class memberType.
Each object of memberType can hold the name of a person, member ID, number of books bought, and amount spent.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Exercises b.
Similarly, update, modify, and show the number of books bought and the amount spent.
Add the appropriate constructors.
Write the definitions of the member functions of memberType.
Write a program to test various operations of your class memberType.
Using the classes designed in Programming Exercises 10 and 11, write a program to simulate a bookstore.
The bookstore has two types of customers: those who are members of the bookstore and those who buy books from the bookstore only occasionally.
Each member has to pay a $10 yearly membership fee and receives a 5% discount on each book purchased.
For each member, the bookstore keeps track of the number of books purchased and the total amount spent.
For every eleventh book that a member buys, the bookstore takes the average of the total amount of the last 10 books purchased, applies this amount as a discount, and then resets the total amount spent to 0.
Write a program that can process up to 1000 book titles and 500 members.
Your program should contain a menu that gives the user different choices to effectively run the program; in other words, your program should be user driven.
The method sellProduct of the Juice Machine programming example gives the user only two chances to enter enough money to buy the product.
Rewrite the definition of the method sellProduct so that it keeps prompting the user to enter more money as long as the user has not entered enough money to buy the product.
Also, write a program to test your method.
Write the definition of a class, swimmingPool, to implement the properties of a swimming pool.
Your class should have the instance variables to store the length (in feet), width (in feet), depth (in feet), the rate (in gallons per minute) at which the water is filling the pool, and the rate (in gallons per minute) at which the water is draining from the pool.
Add appropriate constructors to initialize the instance variables.
Also add member functions to do the following: determine the amount of water needed to fill an empty or partially filled pool, determine the time needed to completely or partially fill or empty the pool, and add or drain water for a specific amount of time.
Your program must contain the class ticTacToe to implement a ticTacToe object.
Include a 3-by-3 two-dimensional array, as a private member variable, to create the board.
If needed, include additional member variables.
Some of the operations on a ticTacToe object are printing the current board, getting a move, checking if a move is valid, and determining the winner after each move.
Add additional operations as needed.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 10: Classes and Data Abstraction The equation of a line in standard form is ax + by ¼ c, wherein both a and b cannot be zero, and a, b, and c are real numbers.
If b 6¼ 0, then –a/b is the slope of the line.
If a ¼ 0, then it is a horizontal line, and if b ¼ 0, then it is a vertical line.
The slope of a vertical line is undefined.
Two lines are parallel if they have the same slope or both are vertical lines.
Two lines are perpendicular if either one of the lines is horizontal and the other is vertical or the product of their slopes is –1.
Design the class lineType to store a line.
To store a line, you need to store the values of a (coefficient of x), b (coefficient of y), and c.
Your class must contain the following operations: a.
If a line is nonvertical, then determine its slope.
Determine if two lines are equal.
Determine if two lines are perpendicular.
If two lines are not parallel, then find the point of intersection.
Add appropriate constructors to initialize variables of lineType.
Also write a program to test your class.
Typically, everyone saves money periodically for retirement, buying a house, or for some other purposes.
If you are saving money for retirement, then the money you put in a retirement fund is tax sheltered and your employer also makes some contribution into your retirement fund.
In this exercise, for simplicity, we assume that the money is put into an account that pays a fixed interest rate, and money is deposited into the account at the end of the specified period.
Suppose that a person deposits R dollars m times a year into an account that pays  % interest compounded m times a year for t years.
Then ithe total accumulated at the end of t years is given by h R ð1=mÞmt 1 =m For example, suppose that you deposit $500 at the end of each month into an account that pays 4_0_8% interest per year compounded monthly for 25 years.
Then the total money accumulated into the account is 500[(1 + 0_0_048/12)300 – 1]/(0_0_048/12) ¼ $289,022_0_42.
On the other hand, suppose that you want to accumulate S dollars in t years and would like to know how much money, m times a year, you should deposit into an account that pays % interest compounded m times a year.
The periodic payment is given by the formula ð1=mÞ mt 1 Design a class that uses the above formulas to determine the total accumulated into an account and the periodic deposits to accumulate a specifc amount.
Your class should have instance variables to store the periodic deposit, the value of m, the interest rate, and the number of years Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Add appropriate constructors to initialize instance variables, functions to set the values of the instance variables, functions to retrieve the values of the instance variables, and functions to do the necessary calculations and output results.
Define the class bankAccount to implement the basic properties of a bank account.
An object of this class should store the following data: Account holder's name (string), account number (int), account type (string, checking/saving), balance (double), and interest rate (double).
Use a static member in the class to automatically assign account numbers.
Also declare an array of 10 components of type bankAccount to process up to 10 customers and write a program to illustrate how to use your class.
Suppose you roll a set of  dice.
Then the smallest sum is  and the largest sum is 6.
For example, if  = 10, then the smallest sum is 6 and the largest sum is 60.
Let m be the desired sum of the numbers rolled.
Write a program that uses the class die, of The program prompts the user to enter the desired sum and the number of times the dice are to be rolled.
The program outputs the number of times the desired sum was rolled and the probability of rolling the desired sum.
Test run your program to roll the 10 dice 10,000, 100,000, 1,000,000, 10,000,000, and 100,000,000 times with the desired sums 6, 25, 40, and 60.
How many times was the sum 6 rolled.
How many times was the sum 60 rolled.
Programming Exercise 19 prompted the user to input the number of times the dice were to be rolled and the desired sum, and the program output the number of times the desired sum occurred.
Modify Programming Exercise 19 as follows: Suppose you roll 4 dice 1000 times.
Store the sum of the numbers rolled in each roll into an array, and then use this array to print a bar graph (similar to the bar graph in the Programming Example Data Comparison (Chapter 6)).
Test run your program using 4, 5, and 6 dice and the number of rolls 2500, 3000, and 5000.
What type of curve does the shape of your bar graph resemble.
Write the definitions of the member functions of the class integerManipulation not given in Example 10-11.
Also add the following operations to this class: (1) Split the number into blocks of -digit numbers starting from right to left and find the sum of these -digit numbers.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Become familiar with the three basic principles of object-oriented design Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
By using , you can combine data and operations in a single unit.
An object, therefore, becomes a self-contained entity.
Operations can directly access the data, but the internal state of an object cannot be manipulated directly.
In addition to implementing ADT,  have other features.
For instance,  can create new  from existing.
This important feature encourages code reuse.
Two common ways to relate  in a meaningful way are:.
Inheritance Suppose that you want to design a class, partTimeEmployee, to implement and process the characteristics of a part-time employee.
The main features associated with a part-time employee are the name, pay rate, and number of hours worked.
In Example 10-10 (in Chapter 10), we designed a class to implement a person's name.
Every part-time employee is a person.
Therefore, rather than design the class partTimeEmployee from scratch, we want to be able to extend the definition of the class personType (from Example 10-10) by adding additional members (data and/or functions).
Of course, we do not want to make the necessary changes directly to the class personType—that is, edit the class personType and add and/or delete members.
In fact, we want to create the class partTimeEmployee without making any physical changes to the class personType by adding only the members that are necessary.
For example, because the class personType already has members to store the first name and last name, we will not include any such members in the class partTimeEmployee.
In fact, these member variables will be inherited from the In Chapter 10, we extensively studied and designed the class clockType to implement the time of day in a program.
The class clockType has three member variables to store the hours, minutes, and seconds.
Certain applications, in addition to the hours, minutes, and seconds, might also require us to store the time zone.
In this case, we would like to extend the definition of the class clockType and create a class, extClockType, to accommodate this new.
That is, we want to derive the class extClockType by adding a member variable—say, timeZone—and the necessary member functions to manipulate the time (see Programming Exercise 1 at the end of this chapter).
In Cplus_plus, the mechanism that allows us to accomplish this task is the principle of inheritance.
Inheritance is Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The derived  inherit the properties of the base.
So rather than create completely new  from scratch, we can take advantage of inheritance and reduce software development complexity.
Each derived class, in turn, can become a base class for a future derived class.
Inheritance can be either single inheritance or multiple inheritance.
In single inheritance, the derived class is derived from a single base class; in multiple inheritance, the derived class is derived from more than one base class.
This chapter concentrates on single inheritance.
Inheritance can be viewed as a treelike, or hierarchical, structure wherein a base class is shown with its derived.
Consider the tree diagram shown in Figure 11-1.
Inheritance hierarchy In this diagram, shape is the base class.
The  circle and rectangle are derived from shape, and the class square is derived from rectangle.
Every circle and every rectangle is a shape.
Every square is a rectangle.
The general syntax of a derived class is: class className: memberAccessSpecifier baseClassName { member list }; in which memberAccessSpecifier is public, protected, or private.
When no memberAccessSpecifier is specified, it is assumed to be a private inheritance.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The following statements specify that the class circle is derived from shape, and it is a public inheritance.
In this definition, the public members of shape become private members of the class circle.
So any object of type circle cannot directly access these members.
The previous definition of circle is equivalent to: class circle: shape {.
The following facts about the base and the derived  should be kept in mind.
The private members of a base class remain private to the base class; hence, the members of the derived class cannot directly access them.
In other words, when you write the definitions of the member functions of the derived class, even though the private members of the base class are members of the derived class, the derived class cannot directly access them.
The public members of a base class can be inherited either as public members or as private members by the derived class.
That is, the public members of the base class can become either public or private members of the derived class.
This means that what were public members in the base class can either remain public members or become private members in the derived class.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The derived class can include additional members—data and/or functions.
The derived class can redefine the public member functions of the base class.
That is, in the derived class, you can have a member function with the same name, number, and types of parameters as a function in the base class, but with different code in the function body.
However, this redefinition applies only to the objects of the derived class, not to the objects of the base class.
All member variables of the base class are also member variables of the derived class.
Similarly, the member functions of the base class (unless redefined) are also member functions of the derived class.
The first issue is the redefinition of the member functions of the base class in the derived class.
While discussing this issue, we will also address how to access the private (data) members of the base class in the derived class.
The second key inheritance issue is related to the constructor.
The constructor of a derived class cannot directly access the private member variables of the base class.
Thus, we need to ensure that the private member variables that are inherited from the base class are also initialized when a constructor of the derived class executes.
Redefining (Overriding) Member Functions of the Base Class Suppose that a class derivedClass is derived from the class baseClass.
Further assume that both derivedClass and baseClass have some member variables.
It then follows that the member variables of the class derivedClass are its own member variables, together with the member variables of baseClass.
Suppose that baseClass contains a function, print, that prints the values of the member variables of baseClass.
Now derivedClass contains member variables in addition to the member variables inherited from baseClass.
Suppose that you want to include a function that prints the values of the member variables of derivedClass.
You can give any name to this function.
However, in the class derivedClass, you can also name this function print (the same name used by baseClass).
This is called redefining (or overriding) the member function of the base class.
Next, we illustrate how to redefine the member functions of a base class with the help of an example.
To redefine a public member function of a base class in the derived class, the corresponding function in the derived class must have the same name, number, and types of parameters.
In other words, the name of the function being redefined in the derived class must have the same name and the same set of parameters.
If the corresponding functions in the base class and the derived class have the same name but different sets of parameters, then this is function overloading in the derived class, which is also allowed.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
UML class diagram of the class rectangleType The class rectangleType has 10 members.
Suppose that the definitions of the member functions of the class rectangleType are as follows: {.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
UML class diagram of the class boxType and the inheritance hierarchy From the definition of the class boxType, it is clear that the class boxType is derived from the class rectangleType, and it is a public inheritance.
Therefore, all public members of the class rectangleType are public members of the class boxType.
The class boxType also overrides (redefines) the functions print and area.
In general, while writing the definitions of the member functions of a derived class to specify a call to a public member function of the base class, we do the following:.
If the derived class overrides a public member function of the base class, then to specify a call to that public member function of the base class, you use the name of the base class, followed by the scope resolution operator, ::, followed by the function name with the appropriate parameter list.
For example, to call the function area of the class rectangleType the statement is: rectangleType::area().
If the derived class does not override a public member function of the base class, you may specify a call to that public member function by using the name of the function and the appropriate parameter list.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
See the definition of the function setDimension (of the class boxType), given later in this section, for an example.
Next, let us write the definition of the member function print of the class boxType.
The class boxType has three member variables: , , and.
The member function print of the class boxType prints the values of these member variables.
To write the definition of the function print of the class boxType, keep in mind the following:.
The member variables  and  are private members of the class rectangleType, so they cannot be directly accessed in the class boxType.
Therefore, when writing the definition of the function print of the class boxType, we cannot access  and directly.
The member variables  and  of the class rectangleType are accessible by the class boxType only through the public member functions of the class rectangleType.
Therefore, when writing the definition of the member function print of the class boxType, we must call the member function print of the class rectangleType to print the values of  and.
After printing the values of  and , we can directly output the value of  because it is a member of class boxType.
To call the member function print of rectangleType in the definition of the member function print of boxType, we must use the following statement: rectangleType::print(); This statement ensures that we call the member function print of the base class.
The definition of the member function print of the class boxType is: void boxType::print() const.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Notice that in the preceding definition of the function setDimension, a call to the member function setDimension of the class rectangleType is preceded by the name of the class and the scope resolution operator, even though the class boxType overloads—not overrides—the function setDimension.
The definition of the function getHeight is:.
The member function area of the class boxType determines the surface area of a box.
To determine the surface area of a box, we need to access the  and  of the box, which are declared as private members of the class rectangleType.
Therefore, we use the member functions getLength and getWidth of the class rectangleType to retrieve the  and , respectively.
Because the class boxType does not contain any member functions that have the names getLength or getWidth, we can call these member functions of the class rectangleType without coupling them to the name of the base class.
The member function volume of the class boxType determines the volume of a box.
To determine the volume of a box, you multiply the , , and  of the box or multiply the area of the base of the box by its.
Let us write the definition of the member function volume by using the second alternative.
To do this, you can use the member function area of the class rectangleType to determine the area of the base.
Because the class boxType overrides the member function area, to specify a call to the member function area of the class rectangleType, we use the name of the base class and the scope resolution operator, as shown in the following definition:.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Constructors of Derived and Base Classes A derived class can have its own private member variables, so a derived class can explicitly include its own constructors to initialize them.
When we declare a derived class object, this object inherits the members of the base class, but the derived class object cannot directly access the private (data) members of the base class.
That is, the member functions of a derived class cannot directly access the private members of the base class.
As a consequence, the constructors of a derived class can (directly) initialize only the (public data) members inherited from the base class of the derived class.
Thus, when a derived class object is declared, it must also trigger the execution of one of the base class's constructors.
Furthermore, this triggering of the base class's constructor is specified in the heading of the definition of a derived class constructor.
First, let us write the definition of the default constructor of the class boxType.
Recall that, if a class contains a default constructor and no values are specified when the object is declared, the default constructor executes and initializes the object.
Because the class rectangleType contains the default constructor, we do not specify any constructor of the base class when writing the definition of the default constructor of the class boxType.
To write the definition of class boxType constructor with parameters, we first write the class boxType constructor heading including all of the parameters needed for both the base class and derived class constructors; that is, all the parameters needed for both boxType and rectangleType.
Then, to trigger the execution of the base class constructor with parameters, we add a colon (:) to the heading followed by the name of the constructor of the base class with its parameters in the heading of the definition of the constructor of the derived class.
In effect, we "tack on" the base class constructor to the derived class constructor via a colon.
The derived class constructor gets all of the parameters needed for itself and the base class constructor, then passes on the base class parameters to its constructor.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
In this definition, we specify the constructor of rectangleType with two parameters.
When this constructor of boxType executes, it triggers the execution of the constructor of the class rectangleType with two parameters of type double.
Consider the following statements:.
The statement in Line 1 creates the rectangleType object myRectangle.
Thus, the object myRectangle has two member variables: length and width.
The statement in Line 2 creates the boxType object myBox.
Thus, the object myBox has three member variables: length, width, and  (see Figure 11-4).
In the statement in Line 5, the function print associated with the class boxType is executed.
Recall that, if a derived class overrides a member function of the base class, the redefinition applies only to the objects of the derived class.
Thus, the output of the statement in Line 3 is (as defined in the class rectangleType): = 5_0_0;  = 3_0_0 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Note that the constructors of a base class are not inherited by a derived class.
So if a base class contains private data members, only base class constructors can construct the base class, including the base class part of a derived class.
In this case, derived class constructors can only construct the additional members specified in its definition.
This means that a call to a base class constructor must be included in the definition of a constructor of the derived class.
When a derived class constructor executes, first a constructor of the base class executes to initialize the data members inherited from the base class, and then the constructor of the derived class executes to initialize the data members declared by the derived class.
So first, the constructor of the class rectangleType executes to initialize the instance variables length and width, and then the constructor of the class boxType executes to initialize the instance variable.
The program in Example 11-2 shows how the objects of a base class and a derived class behave.
EXAMPLE 11-2 In this example, we write a program to solve the following problems: 1.
Jim's lawn care store specializes in putting up fences around small farms and home lawns and fertilizing the farms and lawns.
For simplicity, we assume that the yards and farms are rectangular.
In order to put up the fence, the program needs to know the perimeter and to fertilize, the program needs to know the area.
We will write a program that uses the class rectangle to store the dimensions of a yard or a farm.
The program will also prompt the user to input the dimensions (in feet) of a yard or farm, the cost (per foot) to put up the fence, and the cost (per square foot) to fertilize the area.
The program will then output the cost of putting up the fence and fertilizing the area.
Linda's gift store specializes in wrapping small packages.
For simplicity, we assume that a package is in the shape of a box with a specific length, width, and We will write a program that uses the class boxType to store the dimensions of a package.
The program will ask the user to input the dimensions of the package and the cost (per square foot) to wrap the package.
The program will then output the cost of wrapping the package.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sample Run: In this sample run, the user input is shaded.
Line 14: Enter the length and width of the yard (in feet): 70 50 Line 18: Enter the cost of fence (per foot): $10_0_00 Line 21: Enter the cost of fertilizer (per square foot): $0_0_25 Line 25: Amount due: $3275_0_00 Line 29: Enter the length, width, and height of the package (in feet): 3 2 0_0_25 Line 33: Enter the cost (25 to 50 cents) of wrapping per square foot: 25 Line 39: Amount due: $3_0_63 The preceding program works as follows: The statements in Lines 8 to 12 and 26 to 28 declare the variables and objects used in the program.
The statement in Line 17 uses the function setDimension to initialize the instance variables of the object yard.
The statements in Lines 18 to 23 prompt the user to input the cost of putting up the fence and fertilizing the yard, and they store the values in the variables fenceCostPerFoot and fertilizerCostPerSquareFoot.
The statement in Line 24 calculates the billing amount.
Note that this statement uses the functions perimeter and area of the class rectangleType to compute the length of the fence and the area of the yard.
Then the statement in Line 25 outputs the billing amount.
The statement in Line 29 prompts the user to input the length, width, and height of the package and the statement in Line 30 inputs these values in the variables length, width, and height, respectively.
The statement in Line 32 uses the function setDimension to initialize the instance variables of the object package.
The statement in Line 33 prompts the user to input the cost (per square foot) of wrapping the package and the statement in Line 34 stores the cost in the variable wrappingCostPerSquareFeet.
The statement in Line 36 calculates the billing amount.
Note that this statement uses the function area of the class boxType to compute the surface area of the package.
The statement in Line 37 checks if the value of the billing amount  less than $1_0_00, and the statement in Line 38 sets the value of the billing amount to 1_0_00.
Then the statement in Line 39 outputs the billing amount.
Note that in this program the length of the   70 feet and the width  50 feet.
So the perimeter of the   2 * (70 + 50) = 240 feet, and the area of the 70 * 50 = 3500 square feet.
The total cost of putting up the fence and fertilizing the ¼ $(240 * 10 + 3500 * 0_0_25) = $(2400 + 875) = $3275_0_00.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
So the surface area of the  ¼ 2 * ( 3 * 2 + 3 * 0_0_25 + 2 * 0_0_25) = 14_0_50 square feet.
Therefore, the cost of wrapping the   $14_0_50 * 25 / 100 = $3_0_625 = $3_0_63 (rounded to two decimal places).
Now both the classes rectangleType and boxType have the functions setDimension and area.
It follows that the program correctly calls the function setDimension of each class to initialize the objects  and.
Similarly, in the case of , the function area of the class rectangleType  called to calculate the area of the , and in the case of , the function area of the class boxType  called to calculate the surface area of the.
From the output of this program, it follows that the redefinition of the functions setDimension and area in the class boxType applies only to an object of the type boxType.
The Web site accompanying this book contains a program in the folder Ch11_InheritanceAndConstructors that further illustrates how to use the classes rectangleType and boxType in a program.
Therefore, a derived class can also have a constructor with default parameters.
For example, suppose that the definition of the class rectangleType  as shown below.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Notice that this definition also takes care of the default constructor of the class boxType.
Suppose that a base class, baseClass, has private member variables and constructors.
Further suppose that the class derivedClass  derived from baseClass, and derivedClass has no member variables.
Therefore, the member variables of derivedClass are the ones inherited from baseClass.
A constructor cannot be called like other functions, and the member variables of baseClass cannot be directly accessed by the member functions of derivedClass.
To guarantee the initialization of the inherited member variables of an object of type derivedClass, even though derivedClass has no member variables, it must have the appropriate constructors.
A constructor (with of derivedClass, the heading of the definition of the constructor contains a call to an appropriate constructor (with parameters) of baseClass, and the body of the constructor empty—that , it contains only the opening and closing braces.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
There are both full-time and part-time employees.
Part-time employees are paid based on the number of hours worked and an hourly rate.
Suppose that you want to define a class to keep track of a part-time employee's information, such as name, pay rate, and hours worked.
You can then print the employee's name together with his or her wages.
Because every employee  a person and Example 10-10 (Chapter 10) defined the class personType to store the first name and the last name together with the necessary operations on name, we can define a class partTimeEmployee based on the class personType.
You can also redefine the print function to print the appropriate information.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
As we will see in the next chapter, destructors  typically used to deallocate dynamic memory allocated to the objects of a class.
The next chapter explains how to create and work with dynamic memory_0_) Suppose that a base class and its derived class have destructors.
When a derived class object goes out of scope, it automatically invokes its destructor.
When the destructor of the derived class executes, it automatically invokes the destructor of the base class.
So when writing the definition of the destructor of the derived class, an explict call to the destructor of the base class is not needed.
Furthermore, when the destructor of the derived class executes, it executes its own code  and then calls the destructor of the base class.
For example, suppose that class three is derived from class two, class two is derived from class one, and these  have destructors.
When an object of class three goes out of scope,  the destructor of class three executes, then the destructor of class two executes, and finally, the destructor of class one executes.
That is, the destructors execute in the reverse order.
HEADER FILE OF A DERIVED CLASS The previous section explained how to derive new  from previously defined.
To define new , you create new  files.
The base   already defined, and  files contain their definitions.
Thus, to create new  based on the previously defined , the  files of the new  contain commands that tell the computer where to look for the definitions of the base.
Recall that to include a system-provided  file, such as iostream, in a user program, you enclose the file between angular brackets; to include a user-defined  file in a program, you enclose the  file between  quotation marks.
Suppose that the definition of the class personType is placed in the  file personType_0_h.
To create the definition of the class partTimeEmployee, the file—say, partTimeEmployee_0_h—must contain the preprocessor directive:.
Multiple Inclusions of a Header File The previous section discussed how to create the  file of a derived class.
To include a  file in a program, you use the preprocessor command.
Recall that before a program is compiled, the preprocessor  processes the program.
Consider the following  file:.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
When this program code is compiled, it is  processed by the preprocessor.
The preprocessor  includes the  file test_0_h and then the  file testA_0_h.
When the  file testA_0_h is included, because it contains the preprocessor directive #include "test_0_h", the  file test_0_h is included twice in the program.
The second inclusion of the  file test_0_h results in compile-time errors, such as the identifier already being declared.
This problem occurs because the  inclusion of the  file test_0_h has already defined the variables  and.
To avoid multiple inclusion of a file in a program, we use certain preprocessor commands in the  file.
Let us  rewrite the  file test_0_h using these preprocessor commands and then explain their meaning.
The effect of these commands is as follows: If the identifier H_test is not defined, we must define the identifier H_test and let the remaining statements between #define and #endif pass through the compiler.
If the  file test_0_h is included the second time in the program, the statement #ifndef fails and all of the statements until #endif are skipped.
In fact, all  files are written using similar preprocessor commands.
EXAMPLE 11-4 In Chapter 10, we defined the class integerManipulation to perform various operations, such as reverse the number and count the even digits, odd digits, and zeros on an integer.
In this example, we extend this class so that a prime factorization of an integer between 2 and 27 * 1013 can be determined and printed.
In order to find the prime factorization of an integer, we create an array of the  125,000 prime numbers and then use these prime numbers to find the factorization (see the related Programming Exercise 19, in Chapter 8).
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
In the definition of the class primeFactorization, add additional member functions as private members as needed.
Next we only give the definition of the constructor and leave the definitions of the other functions as an exercise (see Programming Exercise.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Note that this program does not check whether the user entered a valid number.
The program that you will write in Programing Exercise 14, must ensure that.
Sample Runs: In these sample runs, the user input is shaded.
Sample Run1: Enter an integer between 2 and 270,000,000,000,000: 898329840343 898329840343 is not a prime number.
Its factorization is: 898329840343 = 13 * 237701 * 290711 Sample Run2: Enter an integer between 2 and 270,000,000,000,000: 24578290120000 24578290120000 is not a prime number.
Its factorization is: 24578290120000 = 2 * 2 * 2 * 2 * 2 * 2 * 5 * 5 * 5 * 5 * 614457253 Sample Run3: Enter an integer between 2 and 270,000,000,000,000: 54149933 54149933 is a prime number.
Its factorization is: 54149933 = 54149933 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
In particular, you used the object cin, the extraction operator >>, and functions such as get and ignore to read data from the standard input device.
You also used the object  and the insertion operator << to send output to the standard output device.
To use cin and , the programs included the header file iostream, which includes the definitions of the classes istream and ostream.
Moreover, for file I/O, the programs included the header file fstream, and they used objects of type ifstream for file input and objects of type ofstream for file output.
This section briefly describes how stream classes are related and implemented in Cplus_plus.
In Cplus_plus, stream classes are implemented using the inheritance mechanism, as shown in Figure 11-6.
Cplus_plus stream classes hierarchy Figure 11-6 shows the stream classes that we have encountered in previous chapters.
From this figure, it follows that the class ios is the base class for all stream classes.
Classes istream and ostream are directly derived from the class ios.
The class ifstream is derived from the class istream, and the class ofstream is derived from the class ostream.
Moreover, using the mechanism of multiple inheritance, the class iostream (not to be confused with the header file iostream—these are separate things) and the class fstream are derived from the class iostream.
To identify the I/O status, the class ios contains an integer status word.
This integer status word provides a continuous update that reports the status of the stream.
The classes istream and ostream are responsible for providing the operations for the data transfer between memory and devices.
The class istream defines the extraction operator, >>, and functions such as get and ignore.
The class ostream defines the insertion operator, <<, which is used by the object.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Similarly, the class ofstream is derived from the class ostream to provide the file output operations.
Objects of type ifstream are used for file input; objects of type ofstream are used for file output.
The header file fstream contains the definitions of the classes ifstream and ofstream.
Protected Members of a Class The private members of a class are private to the class and cannot be directly accessed outside of the class.
Only member functions of that class can access the private members.
As discussed previously, the derived class cannot directly access the private members of a base class.
However, it is sometimes necessary (say, for efficiency and/or to simplify the code) for a derived class to directly access a private member of a base class.
If you make a private member become public, then anyone can access that member.
Recall that the members of a class are classified into three categories: public, private, and protected.
A derived class can directly access the protected members of a base class.
So, for a base class to give access to a member to its derived class and still prevent its direct access outside of the class, you must declare that member under memberAccessSpecifier protected.
Thus, the accessibility of a protected member of a class is between public and private.
To summarize, if a member of a base class needs to be accessed by a derived class, that member is declared under memberAccessSpecifier protected.
Inheritance as public, protected, or private Suppose class B is derived from class A.
Then, B cannot directly access the private members of A.
That is, the private members of A are hidden in B.
What about the public and protected members of A.
This section gives the rules that generally apply when accessing the members of a base class.
Consider the following statement: class B: memberAccessSpecifier A {.
If memberAccessSpecifier is public—that is, the inheritance is public—then: The public members of A are public members of B.
They can be directly accessed in class B.
The protected members of A are protected members of B.
They can be directly accessed by the member functions (and friend functions) of B.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The private members of A are hidden in B.
They cannot be directly accessed in B.
They can be accessed by the member functions (and friend functions) of B through the public or protected members of A.
If memberAccessSpecifier is protected—that is, the inheritance is protected—then: The public members of A are protected members of B.
They can be accessed by the member functions (and friend functions) of B.
The protected members of A are protected members of B.
They can be accessed by the member functions (and friend functions) of B.
The private members of A are hidden in B.
They cannot be directly accessed in B.
They can be accessed by the member functions (and friend functions) of B through the public or protected members of A.
If memberAccessSpecifier is private—that is, the inheritance is private—then: a.
The public members of A are private members of B.
They can be accessed by the member functions (and friend functions) of B.
The protected members of A are private members of B.
They can be accessed by the member functions (and friend functions) of B.
The private members of A are hidden in B.
They cannot be directly accessed in B.
They can be accessed by the member functions (and friend functions) of B through the public or protected members of A.
Example 11-5 illustrates how the member functions of a derived class can directly access a protected member of the base class.
EXAMPLE 11-5 Consider the following definition of the class bClass: class bClass {.
The definition of the class bClass contains a protected member variable bCh of type char and a private member variable  of type double.
It also contains an overloaded member function setData.
One version is used to set both member variables; the other version is used to set only the private member variable.
The class also has a constructor with default parameters.
Suppose that the definitions of the member functions and the constructor are as follows:.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
It also contains a constructor, a member function setData with three parameters, and the function print.
Let us now write the definition of the function setData.
Because  is a protected member variable of the class bClass, it can be directly accessed in the definition of the function setData.
However, because  is a private member variable of the class bClass, the function setData cannot directly access it.
Thus, the function setData must set  by using the function setData of the class bClass.
The definition of the function setData of the class dClass can be written as follows:.
Note that the definition of the function setData calls the function bClass::setData, with one parameter to set the member variable , and then directly sets the value of.
We now write the definition of the function print of the class dClass.
Notice that in the definition of the class bClass, the member function print is not overloaded as the member function setData.
It prints the values of both member variables,  and The member variable  is a private member variable, so it cannot be directly accessed in the class dClass.
Even though  is a protected member variable and it can be directly accessed in the class dClass, we must print its value using the function print of the class bClass, because we want this function to output the values of both (which is protected) and  (which is private and inaccessible to dClass).
For this reason, we first call the function bClass::print to output  and  and then output the value of.
The definition of the function print is:.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Composition (Aggregation) | 767 The following program illustrates how the objects of bClass and dClass work.
We assume that the definition of the class bClass is in the header file protectMembClass_0_h, and the definition of the class dClass is in the header file protectMembInDerivedCl_0_h.
Sample Run: Base class:  = *,  = 0 *** Derived class  *** Base class:  = &,  = 2_0_5 Derived class  = 7 When you write the definitions of the member functions of the class dClass, the protected member variable  can be accessed directly.
However, dClass objects cannot.
Composition (aggregation) is another way to relate two classes.
In composition (aggregation), one or more members of a class are objects of another class type.
Composition is Example 10-10 in Chapter 10 defined a class called personType.
The class personType stores a person's first and last name.
Suppose we want to keep track of additional Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Because every person has a personal ID and a date of birth, we can define a new , called personalInfo, in which one of the members is an  of type personType.
We can declare additional members to store the personal ID and date of birth for the  personalInfo.
First, we define another , dateType, to store only a person's date of birth.
Then, we construct the  personalInfo from the classes personType and dateType.
This way, we can demonstrate how to define a new  using two classes.
To define the  dateType, we need three member variables—to store the month, day number, and year.
Some of the operations that need to be performed on a date are setting the date and printing the date.
The following statements define the dateType: dateType {.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Composition (Aggregation) |.
The definition of the function setDate, before storing the date into the member variables, does not check whether the date is valid.
That is, it does not confirm whether is between 1 and 12,  is greater than 0, and  is valid (for example, for January,  should be between 1 and 31).
In Programming Exercise 2 at the end of this chapter, you are asked to rewrite the definition of the function setDate so that the date is validated before storing it in the member variables.
The definitions of the remaining member functions are as follows:.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Again, as in the case of setDate, in Programming Exercise 2, you are asked to rewrite the definition of the constructor so that it checks for valid values of , , and before storing the date into the member variables.
Next, we give the definition of the  personalInfo: personalInfo { public: void setpersonalInfo(string first, string last,  ,.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Composition (Aggregation) |.
Before we give the definition of the member functions of the  personalInfo, let us discuss how the constructors of the objects bDay and name are invoked.
Recall that a  constructor is automatically executed when a  object enters its scope.
Suppose that we have the following statement: personalInfo student; When the object student enters its scope, the objects bDay and name, which are members of student, also enter their scopes.
As a result, one of their constructors is executed.
We, therefore, need to know how to pass arguments to the constructors of the member objects (that is, bDay and name), which occurs when we give the definitions of the constructors of the.
Recall that constructors do not have a type and so cannot be called like other functions.
The arguments to the constructor of a member object (such as bDay) are specified in the heading part of the definition of the constructor of the.
Furthermore, member objects of a  are constructed (that is, initialized) in the order they are declared (not in the order they are listed in the constructor's member initialization list) and before the containing objects are constructed.
Another way to think of this is that all of the components that make up the instance of personalInfo must be built before the instance itself can be built.
Thus, in our case, the object name is initialized  because it is the  member listed (in the private section of the class personalInfo definition), then bDay (the second member listed), and finally student (the instance of personalInfo we are declaring).
The following statements illustrate how to pass arguments to the constructors of the member objects name and bDay: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Object-Oriented Design (OOD) and The  11 chapters of this book used the top-down approach to programming, also called structured programming, to write programs.
Problems were broken down into modules, and each module solved a particular part of the problem.
Data requirements were identified, and functions were written to manipulate the data.
The functions and the data were kept separate, and the functions acted on the data in a passive way.
Structured programming, therefore, has certain limitations.
In structured programming, functions are Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
It  quite difficult, if not impossible, to reuse a function written for one program in another program.
For some of these reasons, structured programming  not very efficient for large software development.
Chapter 10 began with the introduction of.
We learned how  are defined and used.
Later in that chapter, we concentrated on the data requirements of a problem and the logical operations on that data.
With the help of , we combined, or encapsulated, the data—and the operations on that data—in a single unit.
Also, with the help of , we were able to separate the data and the algorithms to manipulate that data.
However, the functions to implement the operations on the data had direct access to the data.
This chapter explains how to create new  from existing  through inheritance and composition.
Furthermore, an object has the capability to hide the information details.
These are some of the features of object-oriented design (OOD).
The three basic principles of OOD are as follows:.
Encapsulation—The ability to combine data and operations on that data in a single unit.
Inheritance—The ability to create new  () from existing ().
Polymorphism—The ability to use the same expression to denote different operations.
In OOD, a class  a fundamental entity; in structured programming, a function  a fundamental entity.
In OOD, we debug ; in structured programming, we debug functions.
In OOD, a program  a collection of interacting ; in structured programming, a program  a collection of interacting functions.
Also, OOD encourages code reuse.
Once a class becomes error-free, it can be reused in many programs because it  a selfcontained entity.
But  contain functions (methods) that are not designed to solve specific programming problems.
They are built as general service functions that will be used in any program.
They come with their own set of variables and don't require the programmer to spend time rethinking what data to put into the program solution.
They also hide the implementation details, providing greater control of variable values than structured programs.
Object-oriented programming (OOP) implements OOD.
To create , we must know how to represent the data and write functions to manipulate that data.
Thus, we must know everything that we have learned in Chapters 2 through 8.
The first eight chapters are essential for any type of programming, whether structured or object-oriented.
Cplus_plus supports OOP through the use of.
We have already examined the first two features of OOP, encapsulation and inheritance, in this chapter and Chapter 10.
Chapter 13 discusses the third feature of OOD: polymorphism.
A polymorphic function or operator has many forms.
In Cplus_plus, a function name and operators such as +, -, *, and / can be overloaded.
An example of function overloading occurs when the function or operator  called, and the specific version used decided according to the arguments used.
For instance, if both operands are Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Suppose a class has constructors.
If no arguments are passed to an object when it declared, the default constructor  executed; otherwise, one of the constructors with parameters  executed.
However, all constructors have the same name.
Also, Cplus_plus provides virtual functions as a means to There are several OOP languages in existence today, including Ada, Modula-2, Object Pascal, Turbo Pascal, Eiffel, Cplus_plus, Java, and Smalltalk.
The earliest OOP language was Simula, developed in 1967.
The OOP terminology  influenced by the vocabulary of Smalltalk, the OOP language largely developed at a Xerox research center during the 1970s.
An OOP language uses many "fancy" words, such as methods, message passing, and so forth.
OOP  a natural and intuitive way to view the programming process.
When we view an object, we immediately think of what it can do.
For example, when we think about a car, we also think about the operations on the car, such as starting the car and driving the car.
When programmers think about a list, they also think about the operations on the list, such as searching, sorting, and inserting.
OOP allows ADT to be created and used.
In Cplus_plus, we implement ADT through the use of.
Objects are created when class variables are declared.
Objects interact with each other via function calls.
Every object has an internal state and an external state.
The private members form the internal state; the public members form the external state.
Only the object can manipulate its internal state.
Identifying Classes, Objects, and Operations In this book's first 9 chapters, in the problem analysis phase, we analyzed the problem, identified the data, and outlined the algorithm.
To reduce the complexity of the function main, we wrote functions to manipulate the data.
In Chapter 10, we used the OOD technique and first identified the  that made up the overall problem.
The  were designed and implemented independently of the main program.
The hardest part in OOD  to identify the  and.
In this section, we describe a common and simple technique to identify  and.
We begin with a description of the problem and then identify all of the nouns and verbs.
We choose our  from the list of nouns, and we choose our operations from the list of verbs.
For example, suppose that we want to write a program that calculates and prints the volume and surface area of a cylinder.
We can state this problem as follows: Write a program to input the dimensions of a cylinder and calculate and print the surface area and volume.
In this statement, the nouns are bold, and the verbs are italic.
From the list of nouns— program, dimensions, cylinder, surface area, and volume—we can easily visualize Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: Grade Report.
The nouns dimensions, surface area, and volume are characteristics of a cylinder and thus can hardly be considered.
After we identify a class, the next step is to determine three pieces of information:.
Operations that an object of that class type can perform Operations that can be performed on an object of that class type Information that an object of that class type must maintain From the list of verbs identified in the problem description, we choose a list of possible operations that an object of that class can perform, or has performed, on itself.
For example, from the list of verbs for the cylinder problem description—write, input, calculate, and print—the possible operations for a cylinder object are input, calculate, and print.
For the class cylinderType, the dimensions represent the data.
The center of the base, radius of the base, and height of the cylinder are the characteristics of the dimensions.
You can input data to the object either by a constructor or by a mutator function.
The verb calculate applies to determining the volume and the surface area.
From this, you can deduce the operations: cylinderVolume and cylinderSurfaceArea.
Similarly, the verb print applies to the display of the volume and the surface area on an output device.
In Programming Exercise 3 at the end of this chapter, you are asked to design a class to implement the characteristics of a cylinder.
Identifying classes via the nouns and verbs from the descriptions of the problem is not the only technique possible.
There are several other OOD techniques in the literature.
However, this technique is sufficient for the programming exercises in this book.
This programming example further illustrates the concepts of inheritance and composition.
Watch the Video The mid-semester point at your local university is approaching.
The registrar's office wants to prepare the grade reports as soon as the students' grades are recorded.
However, some of the students enrolled have not yet paid their tuition.
If a student has paid the tuition, the grades are shown on the grade report together with the grade point average (GPA).
If a student has not paid the tuition, the grades are not printed.
For these students, the grade report contains a message indicating that the grades have been held for nonpayment of the tuition.
The grade report also shows the billing amount.
The registrar's office and the business office want your help in writing a program that can analyze the students' data and print the appropriate grade reports.
The data is stored in a file in the following form: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The students' data is given thereafter.
A sample input file is as follows: 3 345 Lisa Miller 890238 Y 4 Mathematics MTH345 4 A Physics PHY357 3 B ComputerSci CSC478 3 B History HIS356 3 A.
The first line indicates that the input file contains three students' data, and the tuition rate is $345 per credit hour.
Next, the course data for student Lisa Miller is given: Lisa Miller's ID is 890238, she has paid the tuition, and she is taking four courses.
The course number for the mathematics class she is taking is MTH345, the course has four credit hours, her mid-semester grade is A, and so on.
The desired output for each student is in the following form: Student Name: Lisa Miller Student ID: 890238 Number of courses enrolled: 4 Course No Course Name CSC478 HIS356 MTH345 PHY357 ComputerSci History Mathematics Physics Credits 3 3 4 3 Grade B A A B Total number of credits: 13 Mid-Semester GPA: 3_0_54 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: Grade Report.
To calculate the GPA, we assume that the grade A is equivalent to four points, B is equivalent to three points, C is equivalent to two points, D is equivalent to one point, and F is equivalent to zero points.
PROBLEM ANALYSIS AND ALGORITHM DESIGN Input A file containing the data in the form given previously.
For easy reference, let us assume that the name of the input file is stData_0_txt.
Output A file containing the output in the form given previously.
We must first identify the main components of the program.
The university has students, and every student takes courses.
Thus, the two main components are the student and the course.
Let us first describe the course component.
Course The main characteristics of a course are the course name, course number, and number of credit hours.
Some of the basic operations that need to be performed on an object of the course type are: 1.
Set the course information.
Print the course information.
Show the credit hours.
Show the course number.
The following class defines the course as an ADT: class courseType.
If the //actual parameter to this function is the object cout, //then the output is shown on the standard output device.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
UML class diagram of the class courseType The definitions of the functions to implement the operations of the class courseType are quite straightforward and easy to follow.
The function setCourseInfo sets the values of the private member variables according to the values of the parameters.
Its definition is: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: Grade Report.
The function print prints the course information.
The parameter outF specifies the output device.
Also, we print the course name and course number left-justified rather than right-justified (the default).
Thus, we need to set the left manipulator.
Before printing the credit hours, the manipulator is set to be right-justified.
The following steps describe this function: 1.
Set the left manipulator.
Print the course number.
Print the course name.
Set the right manipulator.
Print the credit hours.
If no values are specified when a courseType object is declared, the constructor uses the default values to initialize the object as follows:  to blank,  to blank, and to 0.
Otherwise, the values specified in the object declaration are used to initialize the object.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Next, we discuss the student component.
Notice that in the definition of the class courseType, the member functions, such as print and getCredits, are accessor functions.
This class also has other accessor functions.
As noted in Chapter 10, we typically define the accessor functions with the keyword const at the end of their headings.
We leave it as an exercise for you to redefine this class so that the accessor functions are declared as constant functions.
Because every student has to pay tuition, we also include a member to indicate whether the student has paid the tuition.
Every student is a person, and every student takes courses.
We have already designed a class personType to process a person's first and last name.
We have also designed a class to process the information for a course.
Thus, we see that we can derive the class studentType to keep track of a student's information from the class personType, and one member of this class is of type courseType.
We can add more members as needed.
The basic operations to be performed on an object of type studentType are as follows: 1.
Set the student information.
Print the student information.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: Grade Report 3.
Calculate the GPA.
Calculate the billing amount.
Because the grade report will print the courses in ascending order, sort the courses according to the course number.
The following class defines studentType as an ADT.
We assume that a student takes no more than six courses per semester, so we store course information in an array of six course objects.
If the //actual parameter corresponding to  is the object //cout, then the output is shown on the standard output //device.
If the actual parameter corresponding to //is an ofstream object, say outFile, then the output.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Figure 11-10 shows the UML class diagram of the class studentType together with the inheritance and composition (aggregation) relation.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: Grade Report.
This class also has other accessor functions.
As noted in Chapter 10, we typically define the accessor functions with the keyword const at the end of their headings.
We leave it as an exercise for you to redefine this class so that the accessor functions are declared as Note that the member function sortCourses to sort the array coursesEnrolled is a private member of the class studentType.
This is due to the fact that this function is needed for internal data manipulation, and the user of the class does not need to access this member.
Next, we discuss the definitions of the functions to implement the operations of the class studentType.
The function setInfo first initializes the private member variables to the incoming parameter values.
This function then calls the function sortCourses to sort the array coursesEnrolled by course number.
The class studentType is derived from the class personType, and the variables to store the first and last name are private member variables of that class.
Therefore, we call the member function setName of the class personType to pass the appropriate variables to set the first and last names.
The definition of the function setInfo is as follows: void studentType::setInfo(string fName, string lName, int ID, int nOfCourses, bool isTPaid,.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Note that because the private member variable coursesEnrolled is an array of type courseType, the default constructor of the class courseType executes automatically, and the entire array is initialized.
The function print prints the grade report.
The parameter outF specifies the output device.
If the student has paid his or her tuition, the grades and the GPA are shown.
Otherwise, three stars are printed in place of each grade, the GPA is not shown, a message indicates that the grades are being held for nonpayment of the tuition, and the amount due is shown.
This function has the following steps: 1.
Output Output Output Output the the the the student's name.
Print each course's information.
For each course, print: a.
Course No, Course Name, Credits b.
Print the total credit hours.
To output the GPA and billing amount in a fixed decimal format with the decimal point and trailing zeros, set the necessary flag.
Also, set the precision to two decimal places.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: Grade Report.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The formal parameter  is an object of the class ostream.
We can use this function to send the output to the standard output device, the screen, or to a file.
As indicated in the definition of the class, if the actual parameter is, say, cout, then the output is displayed on the screen.
If the actual parameter is, say, outfile, an object of the class ofstream, then the output is sent to the device indicated by outfile.
As mentioned in the section, "Cplus_plus Stream Classes," the class ofstream is derived from the class ostream.
Therefore, the class ostream is the base class.
In Cplus_plus, if a formal reference parameter is of the type ostream, it can refer to an object of the class ofstream.
In general, Cplus_plus allows a formal reference parameter of the base class type to refer to an object of the derived class.
Of course, for user-defined classes, some other things need to be taken into account for this mechanism to work properly, which we will discuss in Chapter 12 (in the section "Inheritance, Pointers, and Virtual Functions").
The function  calculates and returns the total credit hours that a student is taking.
These credit hours are needed to calculate both the  and the billing amount.
The total credit hours are calculated by adding the credit hours of each course in which the student is enrolled.
Because the credit hours for a course are in the private member variable of an object of type courseType, we use the member function getCredits of the class courseType to retrieve the credit hours.
The definition of this function is:.
Programming Example:  Report.
This function calculates a student's.
To find the , we find the equivalent points for each grade, add the points, and then divide.
The function sortCourses sorts the array coursesEnrolled by course number.
To sort the array, we use a selection sort algorithm.
Because we will compare the course numbers, which are strings and private member variables of the class courseType, we first retrieve and store the course numbers in local variables.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
PROGRAM Now that we have designed the classes courseType and studentType, we will use these classes to complete the program.
We will restrict our program to process a maximum of 10 students.
Note that this program can easily be enhanced to process any number of students.
Because the print function of the class does the necessary computations to print the final grade report, the main program has very little work to do.
Because the input is in a file and the output will be sent to a file, we declare stream variables to access the input and output files.
Essentially, the main algorithm for the program is: 1.
Declare the variables.
Open the input file.
If the input file does not exist, exit the program.
Open the output file.
Get the number of students registered and the  rate.
Load the students' data.
Print the grade reports.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example:  Report.
Therefore, we must declare an array of 10 components of type studentType to hold the students' data.
We also need to store the number of students registered and the tuition rate.
Because the data will be read from a file and because the output is sent to a file, we need two stream variables to access the input and output files.
Thus, we need the following variables:.
In pseudocode, the definition of this function is as follows: For each student in the university, 1.
Get the first name, last name, student ID, and isPaid.
Get the number of courses the student is taking.
For each : Get the  name,  number, credit hours, and grade.
Load the  information into a courseType object.
Load the data into a studentType object.
We need to declare several local variables to read and store the data.
The definition of the function getStudentData is: void getStudentData(ifstream& infile, studentType studentList[], {.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
For each student, it calls the function print printGrade of the class studentType to print the grade report.
The definition of the function Reports printGradeReports is: void printGradeReports(ofstream& outfile, studentType studentList[], int numberOfStudents, {.
Programming Example: Grade Report.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: Grade Report.
Malik // // This program reads students' data from a file and outputs // the grades.
If student has not paid the tuition, the // grades are not shown, and an appropriate message is // output.
The output is stored in a file.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Programming Example: Grade Report.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Inheritance and composition (aggregation) are meaningful ways to relate two or more classes.
Inheritance is an "is-a" relation.
Composition (aggregation) is a "has-a" relation.
In a single inheritance, the derived class is derived from only one existing class called the base class.
In a multiple inheritance, a derived class is derived from more than one base class.
The private members of a base class are private to the base class.
The derived class cannot directly access them.
The public members of a base class can be inherited either as public or private by the derived class.
A derived class can redefine the member functions of a base class, but this redefinition applies only to the objects of the derived class.
A call to a base class's constructor (with parameters) is specified in the heading of the definition of the derived class's constructor.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
When initializing the object of a derived class, the constructor of the base class is executed first.
Review the inheritance rules given in this chapter.
In composition (aggregation), a member of a class is an object of another class.
In composition (aggregation), a call to the constructor of the member objects is specified in the heading of the definition of the class's constructor.
The three basic principles of OOD are encapsulation, inheritance, and polymorphism.
An easy way to identify classes, objects, and operations is to describe the problem in English and then identify all of the nouns and verbs.
Choose your classes (objects) from the list of nouns and your operations from the list of verbs.
EXERCISES The number in parentheses at the end of an exercise refers to the learning objective listed at the beginning of the chapter.
Mark the following statements as true or false.
The public members of a base class can only be inherited as public To redefine (or override) a member function of the base class in the derived class, the corresponding member function must have the same If the derived class does not override a public member function of the base class, you may specify a call to that public member function by The constructor of a derived class can specify a call to the constructor The constructor of a derived class can specify a call to the constructor of Suppose that x and y are classes, one of the member variables of x is an object of type y, and both classes have constructors.
The constructor of x specifies a call to the constructor of y by using the object name When the destructor of the derived class executes, it automatically Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
In composition, one or more members of a class are objects of another Suppose vehicle is a class that defines the basic properties of a vehicle.
Draw a class hierarchy in which several classes are derived from the class vehicle, and then other classes are derived from the classes derived from Suppose that a class employeeType is derived from the class personType (see Example 10-10, in Chapter 10).
Give examples of members—data and functions—that can be added to the class employeeType.
Also write the definition of the class employeeType Consider the class circleType as defined in Example 10-8 (Chapter 10).
Suppose that the class sphereType is derived from the class i.
Name some of the functions and/or data members that can be added to the class sphereType.
Write the definition of the class sphereType.
Write the definitions of the member functions of the class sphereType.
Consider the following statements: a.
In this declaration, which class is the base class and which class is the Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Suppose that you have the declarations of Exercise 7.
Write the definitions of the member functions of the classes circle and cylinder.
Identify the member functions of the class cylinder that overrides the member Consider the following class definition: class temp {.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Identify and correct errors, if any, in the definition of the class derivedFromTemp.
Also give a correct definition of this class.
After correcting errors, if any, in the definition of the class derivedFromTemp, write the definition of the member functions of the class derivedFromTemp.
What is the heading of the function print in the class derived.
Suppose that the class overloads the functions set and get of the class base.
What are the headings of these functions in the class derived.
Explain the difference between overriding and overloading a member Suppose that class three is derived from class two and class two is derived from class one and that each class has instance variables.
Suppose that an object of class three enters its scope, so the constructors of these classes will execute.
Determine the order in which the constructors of a.
Which private members, if any, of smart are public members of superSmart.
Which members, functions, and/or data of the class smart are directly accessible in class superSmart.
Assume the definitions of the classes smart and superSmart as given in Exercise 14.
Suppose that the following statements are in a user program (client code): a.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Write the definition of the default constructor of smart so that the instance variables of smart are initialized to 0.
Write the definition of the default constructor of superSmart so that the instance variables of superSmart are initialized to 0.
Write the definition of the member function set of smart so that the instance variables are initialized according to the parameters.
Write the definition of the member function  of the class smart so that it returns the  of the instance variables.
Write the definition of the member function manipulate of the class superSmart so that it returns the (x + y), that is, return x plus y to the power of.
Suppose class two is derived from class one.
To avoid multiple inclusion of these classes, which preprocessor directives are used in the header files containing the definitions of these classes.
Justify your answer by giving Explain how in a private inheritance, the members of the base class are Explain how in a protected inheritance, the members of the base class are Explain how in a public inheritance, the members of the base class are Explain the difference between the private and protected members of Explain the difference between the protected and public members of a.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Determine which members of class first are private, protected, and Assume the declaration of Exercise 24.
Suppose that class third is derived from class first using the statement: class third: protected first 26.
Determine which members of class first are private, protected, and Assume the declaration of Exercise 24.
Suppose that class fourth is derived from class first using the statement: class fourth: public first 27.
Determine which members of class first are private, protected, and Assume the declaration of Exercise 24.
Suppose that class fifth is derived from class first using the statement: class fifth: first 28.
Determine which members of class first are private, protected, and class classA { protected:.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Write the definition of the function setData of class two.
Write the definition of the function print of class two.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
In Chapter 10, the  clockType was designed to implement the time of day in  program.
Certain applications, in addition to hours, minutes, and seconds, might require you to store the time zone.
Derive the extClockType from the  clockType by adding  member variable to store the time zone.
Add the necessary member functions and constructors to make the  functional.
Also, write the definitions of the member functions and the constructors.
Finally, write  test program to test your.
In this chapter, the  dateType was designed to implement the date in program, but the member function setDate and the constructor do not check whether the date is valid before storing the date in the member variables.
Rewrite the definitions of the function setDate and the constructor so that the values for the month, day, and year are checked before storing the date into the member variables.
Add  member function, isLeapYear, to check whether  year is  leap year.
Moreover, write test program to test your.
Chapter 10 defined the  circleType to implement the basic properties of  circle.
Design   cylinderType that can capture the properties of  cylinder and perform the usual operations on the cylinder.
Derive this  from the  circleType designed in Chapter 10.
Some of the operations that can be performed on  cylinder are as follows: calculate and print the volume, calculate and print the surface area, set the height, set the radius of the base, and set the center of the base.
Also, write  program to test various operations on  cylinder.
Amanda and Tyler opened  business that specializes in shipping liquids, such as milk, juice, and water, in cylinderical containers.
The shipping charges depend on the amount of the liquid in the container.
Write program that does the following:.
Prompts the user to input the dimensions (in feet) of the container (radius of the base and the height).
Prompts the user to input the shipping cost per liter.
Prompts the user to input the paint cost per square foot.
Your program must use the  cylinderType (designed in Programming Exercise 3) to store the radius of the base and the height of the container.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter().
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Your program should be able to handle  maximum of 500 entries.
Define   addressType that can store  street address, city, state, and ZIP code.
Use the appropriate functions to print and store the address.
Also, use constructors to automatically initialize the member variables.
Define   extPersonType using the  personType (as defined in Example 10-10, Chapter 10), the  dateType (as designed in this chapter' Programming Exercise 2), and the  addressType.
Add  member variable to this  to classify the person as  family member, friend, or business associate.
Also, add  member variable to store the phone number.
Add (or override) the functions to print and store the appropriate information.
Use constructors to automatically initialize the member variables.
Define the  addressBookType using the previously defined classes.
An object of the type addressBookType should be able to process  maximum of 500 entries.
The program should perform the following operations: Load the data into the address book from  disk.
Sort the address book by last name.
Search for  person by last name.
Print the address, phone number, and date of birth (if it exists) of given person.
Print the names of the people whose birthdays are in  given month.
Print the names of all the people between two last names.
Depending on the user' request, print the names of all family members, friends, or business associates.
In Programming Exercise 2, the  dateType was designed and implemented to keep track of  date, but it has very limited operations.
Redefine the  dateType so that it can perform the following operations on a date, in addition to the operations already defined: i.
Set the month.
Set the day.
Set the year.
Return the month.
Return the day.
Return the year.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Return the number of days in the month.
For example, if the  is 3-12-2017, the number of days to be returned is 31 because there are 31 days in March.
Return the number of days passed in the year.
For example, if the  is 3-18-2017, the number of days passed in the year is 77.
Note that the number of days returned also includes the current day.
Return the number of days remaining in the year.
For example, if the is 3-18-2017, the number of days remaining in the year is 288.
Calculate the new  by adding a fixed number of days to the.
For example, if the  is 3-18-2017 and the days to be added are 25, the new  is 4-12-2017.
Write the definitions of the functions to implement the operations defined for the class dateType in Programming Exercise 6.
The class dateType defined in Programming Exercise 6 prints the  in numerical form.
Some applications might require the  to be printed in another form, such as March 24, 2017.
Derive the class extDateType so that the  can be printed in either form.
Add a member variable to the class extDateType so that the month can also be stored in string form.
Add a member function to output the month in the string format, followed by the year—for example, in the form March 2017.
Write the definitions of the functions to implement the operations for the class extDateType.
Using the classes extDateType (Programming Exercise 8) and dayType (Chapter 10, Programming Exercise 5), design the class calendarType so that, given the month and the year, we can print the calendar for that month.
To print a monthly calendar, you must know the first day of the month and the number of days in that month.
Thus, you must store the first day of the month, which is of the form dayType, and the month and the year of the calendar.
Clearly, the month and the year can be stored in an object of the form extDateType by setting the day component of the  to 1 and the month and year as specified by the user.
Thus, the class calendarType has two member variables: an object of the type dayType and an object of the type extDateType.
Design the class calendarType so that the program can print a calendar for any month starting January 1, 1500.
Note that the day for January 1 of the year 1500 is a Monday.
To calculate the first day of a month, you can add the appropriate days to Monday of January 1, 1500.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Determine the first day of the month for which the calendar will be printed.
Call this operation firstDayOfMonth.
Set the month.
Set the year.
Return the month.
Return the year.
Print the calendar for the particular month.
Add the appropriate constructors to initialize the member variables.
Write the definitions of the member functions of the class calendarType (designed in Programming Exercise 9) to implement the operations of the class calendarType.
Write a test program to print the calendar for either a particular month or a particular year.
For example, the calendar for September 2017 is: Sun Mon 3 10 17 24 4 11 18 25 September 2017 Tue Wed Thu 5 12 19 26 6 13 20 27 7 14 21 28 Fri 1 8 15 22 29 Sat 2 9 16 23 30 In this exercise, you will design various classes and write a program to computerize the billing system of a hospital.
Design the class doctorType, inherited from the class personType, defined in Chapter 10, with an additional data member to store a doctor's speciality.
Add appropriate constructors and member functions to initialize, access, and manipulate the data members.
Design the class billType with data members to store a patient's ID and a patient's hospital charges, such as pharmacy charges for medicine, doctor's fee, and room charges.
Add appropriate constructors and member functions to initialize, access, and manipulate the data members.
Design the class patientType, inherited from the class personType, defined in Chapter 10, with additional data members to store a patient's ID, age, date of birth, attending physician's name, the date when the patient was admitted in the hospital, and the date when the patient was discharged from the hospital.
Write a program to test your classes.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 11: Inheritance and Composition In the Programming Example Grade Report, in the definitions of the classes courseType and studentType, the accessor functions are not made constants; that is, they are not defined with the reserved word const at the end of their headings.
Redefine these classes so that all of the accessor functions are constant functions.
Accordingly, modify the definitions of the accessor functions and rerun the program.
Define the class bankAccount to store a bank customer's account number and balance.
Suppose that account number is of type int, and balance is of type double.
Your class should, at least, provide the following operations: set the account number, retrieve the account number, retrieve the balance, deposit and withdraw money, and print account information.
Add appropriate constructors.
Every bank offers a checking account.
Derive the class checkingAccount from the class bankAccount (designed in part (a)).
This class inherits members to store the account number and the balance from the base class.
A customer with a checking account typically receives interest, maintains a minimum balance, and pays service charges if the balance falls below the minimum balance.
Add member variables to store this additional information.
In addition to the operations inherited from the base class, this class should provide the following operations: set interest rate, retrieve interest rate, set minimum balance, retrieve minimum balance, set service charges, retrieve service charges, post interest, verify if the balance is less than the minimum balance, write a check, withdraw (override the method of the base class), and print account information.
Add appropriate constructors.
Every bank offers a savings account.
Derive the class savingsAccount from the class bankAccount (designed in part (a)).
This class inherits members to store the account number and the balance from the base class.
A customer with a savings account typically receives interest, makes deposits, and withdraws money.
In addition to the operations inherited from the base class, this class should provide the following operations: set interest rate, retrieve interest rate, post interest, withdraw (override the method of the base class), and print account information.
Add appropriate constructors.
Write a program to test your classes designed in parts (b) and (c).
Write the definitions of the functions of the class primeFactorization (Example 11-4) and write a program that uses this class to output the prime factorization of an integer.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Learn about the pointer data type and pointer variables.
Examine the relationship between the address of operator  classes Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook /or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Until now, you have studied only the first two data types.
This chapter discusses the third data type called the pointer data type.
You will first learn how to declare pointer variables (or pointers, for short)  manipulate the data to which they point.
Later, you will use these concepts when you study dynamic arrays linked lists.
Linked lists are discussed in Chapter 16.
Pointer Data Type  Pointer Variables Chapter 2 defined a data type as a set of values together with a set of operations.
Recall that the set of values is called the domain of the data type.
In addition to these two properties, until now, all of the data types you have encountered have one more thing associated with them: the name of the data type.
For example, there is a data type called int.
The set of values belonging to this data type includes integers that range between –2147483648 2147483647,  the operations allowed on these values are the arithmetic operators described in Chapter 2.
To manipulate numeric integer data in the range –2147483648 to 2147483647, you can declare variables using the word int.
The name of the data type allows you to declare a variable of that type.
Next, we describe the pointer data type.
The values belonging to pointer data types are the memory addresses of your computer.
As in many other languages, there is no name associated with the pointer data type in Cplus_plus.
Because the domain—that is, the set of values of a pointer data type—is the addresses (locations) in memory, a pointer variable is a variable whose content is an address, that is, a memory location  the pointer variable is said to point to that memory location.
Pointer variable: A variable whose content is an address (that is, a memory address)  is therefore said to point to a memory address.
Declaring Pointer Variables As remarked previously, there is no name associated with pointer data types.
Moreover, pointer variables store memory addresses.
So the obvious question is: If no name is associated with a pointer data type, how do you declare pointer variables.
The value of a pointer variable is an address or memory space that typically contains some data.
Therefore, when you declare a pointer variable, you also specify the data type of the value to be stored in the memory location pointed to by the pointer variable.
For example, if a pointer variable contains the address of a memory location containing an int value, it is said to be an int pointer or a pointer (variable) of type int.
As with regular variables, pointers are bound to a data type  they can only contain the addresses of (or point to) variables of the specific data type they were created to hold.
In Cplus_plus, you declare a pointer variable by using the asterisk symbol (*) between the data type  the variable name.
The general syntax to declare a pointer variable is: dataType *identifier; Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook /or eChapter(s).
Pointer Data Type  Pointer Variables |.
In these statements, both p  ch are pointer variables.
The content of p (when properly assigned) points to a memory location of type int,  the content of ch points to a memory location of type char.
So, p is a pointer variable of type int,  ch is a pointer variable of type char.
Before discussing how pointers work, let us make the following observations.
The statement: int *p;.
Thus, the character * can appear anywhere between the data type name  the variable.
Now, consider the following statement: int* p, q; In this statement, only p is the pointer variable, not q.
Here, q is an int variable.
Each variable must have its own * character placed to the left of it to make it a pointer variable.
To avoid confusion, we prefer to attach the character * to the variable name.
So the preceding statement is written as: int *p, q;.
Now that you know how to declare pointers, next we will discuss how to make a pointer point to a memory space  how to manipulate the data stored in these memory locations.
Because the value of a pointer is a memory address, a pointer can store the address of a memory space of the designated type.
For example, if p is a pointer of type int, p can store the address of any memory space of type int.
Cplus_plus provides two operators—the address of operator (&)  the dereferencing operator (*)—to work with pointers.
The next two sections describe these operators.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook /or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
That is, x and the value of  refer to the same memory location.
Let's compare names and pointers.
In the following two declarations, 1 and 2 are int variables and numptr is the name of an int pointer: int 1, 2; int *numptr;.
For instance, if we want to copy the integer 100 at the memory location 1 to the memory location 2, we can use this statement: 2 = 1;.
On the other hand, when we use the statement: = &1; we are asking the program to copy the address of the memory location of 1 to , not the integer value it is holding.
The pointer  will not contain 100, but the actual address 1 has been assigned by the operating system.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Dereferencing Operator (*) | 815 In the next section, after discussing the dereference operator, we will explain how to output the value of the memory location whose address is stored in.
Every chapter until now has used the asterisk character, *, as the binary multiplication operator.
Cplus_plus also uses * as a unary operator.
When used as a unary operator, *, commonly referred to as the dereferencing operator or indirection operator, refers to the object to which its operand (that is, the pointer) points.
For example, given the statements: int  = 25;.
Let us assume that memory location 1200 is allocated for , and memory location 1800 is.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The following shows the values of the variables after the execution of each statement.
After Statement 1 2 3 Values of the Variables.
The statement  = &; stores the address of , which is 1800, into.
The statement * = 24; stores 24 into the memory location to which points.
Because the value of  is 1800, statement 3 stores 24 into memory location 1800.
Note that the value of  is also changed.
Let us summarize the preceding discussion.
A declaration such as int *; allocates memory for  only, not for *.
Later, you will learn how to allocate memory for *.
The content of  points only to a memory location of type int.
Note that after the statement  = &; executes, the value of * is 78; after the statement * = 24; executes, the value of * is 24.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Dereferencing Operator (*) | 817.
After the statement  = 50; executes, the values of &, , *, &, and  are as follows: & 1400.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The content of  points only to a memory location of type int.
Memory location  exists and is of type int.
Therefore, the assignment statement: = &; is legal.
After this assignment statement executes, * is valid and meaningful.
The program in Example 12-3 further illustrates how a pointer variable works.
EXAMPLE 12-3 The following program illustrates how pointer variables work:.
Dereferencing Operator (*) | 819 << << << << << <<.
Sample Run: In this sample run, the user input is shaded.
The statement in  7 declares  to be a variable of type double and the statement in  8 declares  to be a pointer variable of type double.
The statement in  10 stores 2_0_5 in  and the statement in  11 stores the address of  in.
The statement in 12 outputs the  and  of the circle using the value stored in the memory location.
The statement in  13 outputs the  and  of the circle using the value stored in the memory location to which  is pointing.
Note that the output of the statements in Lines 12 and 13 is the same because points to.
Next, the statement in  14 prompts the user to input the and the statement in  15 stores the  in the memory location to which is pointing.
Next, similar to the statements in Lines 12 and 13, the statements in Lines 17 and 18 output the  and  using the variables and.
The statements in Lines 19 to 22, output the address of , the value stored in , the address of , and the value stored in.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
When you run this program on your machine, you are likely to get different values.
Furthermore, the pointer values, that is, the Classes, Structs, and Pointer Variables In the previous section, you learned how to declare and manipulate pointers of simple data types, such as int and char.
You can also declare pointers to other data types, such as classes.
You will now learn how to declare and manipulate pointers to classes and structs.
The only difference between classes and structs is that, by default, all members of a class are private, and, by default, all members of a struct are public.
Therefore, the following discussion applies Consider the following declaration of a struct: struct studentType.
In Cplus_plus, the dot operator, _0_, has a higher precedence than the dereferencing operator.
Let us elaborate on this a bit.
In the expression (*)_0_, the operator * evaluates first, so the expression * evaluates first.
Because  is a pointer variable of type studentType, * refers to a memory space of type Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Classes, Structs, and Pointer Variables | 821 studentType, which is a struct.
Let us see how this expression gets evaluated.
As you can see, in the expression (*)_0_, the parentheses are important.
However, typos can be problematic.
Therefore, to simplify the accessing of class or struct components via a pointer, Cplus_plus provides another operator called the member access operator arrow, arrow_operator.
The operator arrow_operator consists of two consecutive symbols: a hyphen and the "greater than" sign.
The syntax for accessing a class (struct) member using the operator arrow_operator is: pointerVariableNamearrow_operatorclassMemberName Thus, the statement:.
Accessing class (struct) components via pointers using the operator arrow_operator thus eliminates the use of both parentheses and the dereferencing operator.
Because typos are unavoidable and missing parentheses can result in either an abnormal program termination or erroneous results, when accessing class (struct) components via pointers, this book uses the arrow notation.
Example 12-4 illustrates how pointers work with class member functions.
EXAMPLE 12-4 Consider the following class: class classExample { public:.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The statement in Line 3 stores the address of cExpObject into (see Figure 12-3).
It means that  contains the address cExpObject FIGURE 12-3.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Initializing Pointer Variables | 823 In the statement in Line 4, the pointer  accesses the member function setX to set the value of the member variable  (see Figure 12-4).
Initializing Pointer Variables Because Cplus_plus does not automatically initialize variables, pointer variables must be initialized if you do not want them to point to anything.
Pointer variables are initialized using the constant value 0, called the null pointer.
Thus, the statement = 0; stores the null pointer in , that is,  points to nothing.
Some programmers use the named constant NULL to initialize pointer variables.
The named constant NULL is defined in the header file cstddef.
The following two statements are equivalent: = NULL;.
Initializing Pointer Variables Using nullptr Cplus_plus11 Standard provides the null pointer nullptr to initialize pointer variables.
A pointer with the value nullptr points to nothing, and is called the null pointer.
The following statement declares  to be a pointer of type int and it also initializes it to the null pointer: int * = nullptr; Because the compiler that we have used to test the code has implemented this feature of Cplus_plus11 Standard, we can initialize the pointer variable using the int value 0, using another pointer variable of the same type, or using nullptr.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
However, you learned how to use pointers to manipulate data only into memory spaces that were created using other variables.
In other words, the pointers manipulated data into already existing memory spaces.
But you could have accessed these memory spaces through the variables that were used to create them.
So what  the benefit of using pointers.
In this section, you will learn about the power behind pointers.
In particular, you will learn how to allocate  deallocate memory during program execution using pointers.
Variables that are created during program execution are called dynamic variables.
With the help of pointers, Cplus_plus creates dynamic variables.
Cplus_plus provides two operators, new delete, to create  destroy dynamic variables, respectively.
When a program requires a new , the operator new  used.
When a program no longer needs a dynamic , the operator delete  used.
In Cplus_plus, new  delete are reserved words.
Operator new The operator new  two forms: one to allocate a single   another to allocate.
The operator new   (as a ) of the designated type  returns a pointer to it—that , the address of this allocated.
Moreover, the allocated uninitialized.
Consider the following declaration: *;.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook /or eChapter(s).
Dynamic Variables | 825 This statement creates a  during program execution somewhere in stores the address of the allocated  in.
Similarly, the statement: =  [16]; creates an array of 16 components of type   stores the base address of the array in.
Recall that the operator    space of a specific type  returns the address of the allocated  space.
However, if the operator   unable to allocate the required  space (for example, there  not enough  space), then it throws a bad_alloc exception,  if this exception  not handled, it terminates the program with an error message.
Exceptions are covered in detail in Chapter 14.
This chapter also discusses bad_alloc exception.
Operator delete Suppose you have the following declaration: *;.
Editorial review  deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Suppose that the address of allocated  space  1500.
Then, the value of  after the execution of this statement  1500 (see Figure 12-5(a)).
Next, the statement in Line 3 executes, which  a  space of type stores the address of the allocated  space into.
Suppose the address of this allocated  space  1800.
It follows that the value of   now 1800 (see Figure 12-5(c)).
In other words, after the execution of the statement in Line 4, the value stored into  space at location 1800  73 (see Figure 12-5(d)).
Now the obvious question  what happened to the  space 1500 that  was pointing to after execution of the statement in Line 1.
After execution of the statement in Line 3,  points to the   space at location 1800.
In addition, the  space 1500 remains as marked allocated.
In other words, it cannot be freed or reallocated.
This  called leak.
That , there  an unused  space that cannot be allocated.
Imagine what would happen if you executed statements, such as Line 3, a few thousand or a few million times.
There would be a good amount of  leak.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review  deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Dynamic Variables | 827 question at hand  how to avoid  leak.
When a dynamic variable  no longer needed, it can be destroyed; that , its  can be deallocated.
Cplus_plus operator delete.
Depending on the particular operating system, after these statements execute, these pointer variables may still contain the addresses of the deallocated  spaces.
In this case, we say that these pointers are dangling.
Therefore, if later you access the spaces via these pointers without properly initializing them, depending on the particular system, either the program will access a wrong  space, which may result in corrupting data now stored in those spaces, or the program may terminate with an error message.
One way to avoid this pitfall  to set these pointers to NULL after the delete operation.
Also note that for the operator delete to work properly, the pointer must point to a valid  space.
In Example 12-3, we used the pointer variable radiusPtr to access the  location of the variable radius.
However, in that example, the radiusPtr pointed to an existing , which was not created during program execution.
In the following example, we illustrate how to use the   delete operators to allocate  deallocate dynamic.
EXAMPLE 12-5 The following program illustrates how to use the operators new  delete.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Operations on Pointer Variables | 829 Sample Run: In this sample run, the user input is shaded.
However, let us note the following: the statement in  9 allocates memory of type stores the address of the allocated memory in.
The output of the statement in  15 shows that the address of the allocated memory is 003450A8.
Next the statement in  17 deallocates the memory space to which  is.
The statement in  18 outputs the value stored in the memory location to which is.
As shown by the output of this statement, the value stored is a strange number.
This is because after the delete operation in  17,  does not point to a valid memory location.
Next, the statement in  19 declares the pointer variable , allocates memory space of type ,  stores the address of the memory space of type   stores the address of the allocated memory space in ,  the statement in  21 stores 5_0_38 in the allocated memory space.
The statements in Lines 22 to 25 output the addresses as shown by the output.
Operations on Pointer Variables The operations that are allowed on pointer variables are the assignment  relational operations  some limited arithmetic operations.
The value of one pointer variable can be assigned to another pointer variable of the same type.
For example, suppose that we have the following statements: int *p, *q; Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook /or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
After this statement executes, both  and q point to the same memory location.
Any changes made to * automatically change the value of *q, and vice versa.
Two pointer variables of the same type can be compared for equality, and so on.
The expression: == q evaluates to true if  and q have the same value—that is, if they point to the same memory location.
Similarly, the expression: _0_= q evaluates to true if  and q point to different memory locations.
Integer values can be added and subtracted from a pointer variable.
The value of one pointer variable can be subtracted from another pointer variable.
The arithmetic operations that are allowed differ from the arithmetic operations on numbers.
First, let us use the following statements to explain the increment and decrement operations on pointer variables:.
Recall that the size of the memory allocated for an int variable is 4 bytes, a variable is 8 bytes, and a char variable is 1 byte.
The memory allocated for a variable of type studentType is then 40 bytes.
The increment operator increments the value of a pointer variable by the size of the data type or structure to which it is pointing.
Similarly, the decrement operator decrements the value of a pointer variable by the size of the data type or structure to which it is pointing.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Thus, when an integer is added to a pointer variable, the value of the pointer variable is incremented by the integer times the size of the data type or structure to which the pointer is pointing.
Similarly, when an integer is subtracted from a pointer variable, the value of the pointer variable is decremented by the integer times the size of the data type or structure to which the pointer is pointing.
Pointer arithmetic can be very dangerous.
Using pointer arithmetic, the program can accidentally access the memory locations of other variables and change their content without warning, leaving the programmer trying to find out what went wrong.
If a pointer variable tries to access either the memory spaces of other variables or an illegal memory space, some systems might terminate the program with an appropriate error message.
Always exercise extra care when doing pointer arithmetic.
Dynamic Arrays In Chapter 8, you learned how to declare and process arrays.
The arrays discussed in Chapter 8 are called static arrays because their size was fixed at compile time.
One of the limitations of a static array is that every time you execute the program, the size of the array is fixed, so it might not be possible to use the same array to process different data sets of the same type.
One way to handle this limitation is to declare an array that is large enough to process a variety of data sets.
However, if the array is very big and the data set is small, such a declaration would result in memory waste.
On the other hand, it would be helpful if, during program execution, you could prompt the user to enter the size of the array and then create an array of the appropriate size.
This approach is especially helpful if you cannot even guess the array size.
In this section, you will learn how to create arrays during program execution and process such arrays.
An array created during the execution of a program is called a dynamic array.
To create a dynamic array, we use the second form of the new.
In other words, the  new  an array of 10 components of type , it returns the base address of the array, and the assignment stores the base address of the array into.
Thus, the statement: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Thus, by using the increment and decrement operations, you can access the components of the array.
Of course, after performing a few increment operations, it is possible to lose track of the first array component.
Cplus_plus allows us to use array notation to access these memory locations.
For example, the statements: [0] = 25; [1] = 35; store 25 and 35 into the first and second array components, respectively.
That is, [0] refers to the first array component, [1] refers to the second array component, and so on.
In general, [i] refers to the (i + 1)th array component.
Unlike using pointer arithmetic, after the preceding statements execute,  still points to the first array component.
The following for loop initializes each array component to 0: [] = 0; in which  is an  variable.
When the array notation is used to process the array pointed to by ,  stays fixed at the first memory location.
Moreover,  is a dynamic array created during program execution.
The statement: list[5]; declares list to be an array of five components of type.
Recall from Chapter 8 that list itself is a variable, and the value stored in list is the base address of the array— that is, the address of the first array component.
Suppose the address of the first array component is 1000.
Figure 12-6 shows list and the array list.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
However, the value stored in , which is 1000, cannot be altered during program execution.
That is, the value of  is constant.
Therefore, the increment and decrement operations cannot be applied to.
In fact, any attempt to use the increment or decrement operations on  results in a compile-time error.
Notice that here we are only saying that the value of  cannot be changed.
However, the data into the array  can be manipulated as before.
For example, the statement [0] = 25; stores 25 into the first array component.
Similarly, the statement [3] = 78; stores 78 into the fourth component of  (see Figure 12-7).
Unlike the case with the name , we are allowed to perform increment and decrement operations on the pointer.
An array name is a constant pointer.
The statement in Line 3 prompts the user to enter the size of the array, and the statement in Line 4 inputs the array size into the variable arraySize.
The statement in Line 6  an array of the size specified by arraySize, and the base address of the array is stored in.
From this point on, you can treat  just like any other array.
For example, you can use the array notation to process the elements of  and pass  as a parameter to the function.
Chapter 8 introduced range-based for loops, which is a feature of Cplus_plus11 Standard, and discussed how it can be effectively used to process the elements of an array.
We also pointed out that if a formal parameter of a function is an array, a range-based for loop cannot be used on that formal parameter.
In this section, we explain why this is the case.
Consider the following statements:.
The statement in Line 1 declares  to be a pointer variable of type.
During execution, the statement in Line 2  an array of five components of type  and stores the base address of the array into the pointer.
The statements in Lines 3 and 4 initialize the array to which  points.
Now, the array to which  points is a dynamic array.
So at the compile time, the pointer , even though it will contain the base address of an array, has no first and no last elements.
Therefore, in the for loop in Line 5,  cannot be initialized to the first element of the array.
Thus, the rangebased for loop in Line 5 is illegal and will result in a syntax (compiler) error.
In essence, a range-based for loop cannot be used on dynamic arrays.
The following code shows the type of syntax errors generated by the compiler when a range-based for loop is used on a dynamic array.
Dynamic Arrays 7.
These numbers are merely to show the line number.
The syntax errors generated by the complier shows that the syntax errors are in Line 15.
This is due to the fact that the pointer  has no first and no last elements and so the functions begin and end cannot be called on.
Next, consider the following function: { } The function testFunc has two formal parameters:  is a pointer variable of type , and  is an array of type.
Now  is a pointer of type , so it can contain the address of an  variable and the base address of an  array.
Suppose that in a call to function testFunc,  contains the base address of an array.
However, during compilation  does not have the first and the last elements, so in the definition of the function testFunc, a range-based for loop cannot be used on Next, consider the formal parameter.
Even though  is declared as an array, it is still a pointer of type  and can only contain the base address of any array of type.
However, during compilation  does not have the first and the last elements, so in the definition of the function testFunc, a range-based for loop cannot be used on.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
To declare a pointer as a value parameter in a function heading, you use the same mechanism as you use to declare a variable.
To make a formal parameter be a reference parameter, you use & when you declare the formal parameter in the function heading.
Therefore, to declare a formal parameter as a reference pointer parameter, between the data type name and the identifier name, you must  * to make the identifier a pointer and & to make it a reference parameter.
The obvious question is: In what order should & and * appear between the data type name and the identifier to declare a pointer as a reference parameter.
In Cplus_plus, to make a pointer a reference parameter in a function heading, * appears before the & between the data type name and the identifier.
The following example illustrates this concept: {.
The parameter p is a reference parameter; the parameter q is a value parameter.
Furthermore, the function pointerParameters can change the value of *q, but not the value of q.
However, the function pointerParameters can change the value of both p and *p.
Pointers and Function Return Values In Cplus_plus, the return type of a function can be a pointer.
For example, the return type of the function: {.
Dynamic Two-Dimensional Arrays The beginning of this section discussed how to create dynamic one-dimensional arrays.
You can also create dynamic multidimensional arrays.
In this section, we discuss how to create dynamic two-dimensional arrays.
Dynamic multidimensional arrays are created similarly.
There are various ways you can create dynamic dimensional arrays.
One way is as follows.
Consider the statement: *board[4]; Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Because board[0], board[1], board[2], and board[3] are pointers, you can now use these pointers to create the rows of board.
Suppose that each  of board has six columns.
Then, the following for loop creates the rows of board.
The assignment statement then stores the returned address into board[].
It follows that after the execution of the previous for loop, board is a two-dimensional array of four rows and six columns.
In the previous for loop, if you replace the number 6 with the number 10, then the loop will create a two-dimensional array of four rows and 10 columns.
In other words, the number of columns of board can be specified during execution.
However, the way board is declared, the number of rows is fixed.
So in reality, board is not a true dynamic two-dimensional array.
Next, consider the following statement: **; This statement declares  to be a pointer to a pointer.
In other words,  and * are pointers.
Now  can store the address of a pointer or an array of pointers of type , and * can store the address of an  memory space or an array of values.
Suppose that you want  to be an array of 10 rows and 15 columns.
To accomplish this, first we create an array of 10 pointers of type  and assign the address of that array to.
The following statement accomplishes this: = new * [10]; //create an array of 10  pointers Because the elements of  are  pointers, each of them can point to an array of values.
Next, we create the columns of.
The following for loop accomplishes this: [] = new [15]; To access the components of , you can use the array subscripting notation discussed in Chapter 8.
Note that the number of rows and the number of columns of  can be specified during program execution.
The following program further explains how to create twodimensional arrays.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Shallow versus Deep Copy and Pointers |.
The function fill prompts the user to enter the elements of a two-dimensional array of type.
The function print outputs the elements of a two-dimensional array of type.
For the most part, the preceding output should be clear.
Let us look at the statements in the function main.
The statement in Line 1 declares  to be a pointer to a pointer of type.
The statements in Lines 2 and 3 declare  variables rows and columns.
The statement in Line 4 prompts the user to input the  of rows and  of columns.
The statement in Line 5 stores the  of rows in the variable rows and the  of columns in the variable columns.
The statement in Line 7 creates the rows of , and the for loop in Lines 8 and 9 creates the columns of.
The statement in Line 10 uses the function fill to fill the array , and the statement in Line 12 uses the function print to output the elements of.
Shallow versus Deep Copy and Pointers In an earlier section, we discussed pointer arithmetic and explained that if we are not careful, one pointer might access the data of another (completely unrelated) pointer.
This event might result in unsuspected or erroneous results.
Here, we discuss another peculiarity of pointers.
To facilitate the discussion, we will use diagrams to show pointers and their related memory.
Consider the following statements: *; *second;.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The third statement creates an array of 10 components, and the base address of the array is stored into  (see Figure 12-8).
Pointer  and the array to which it points Suppose that some meaningful data is stored in the array pointed to by.
To be specific, suppose that this array is as shown in Figure 12-9.
This action results in Figure 12-11.
FIGURE 12-11 and  after the statement delete [] ; executes Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Classes and Pointers: Some Peculiarities.
Therefore, if the program later tries to access the memory pointed to by , either the program will access the wrong memory or it will terminate in an error.
This case is an example of a shallow copy.
More formally, in a shallow copy, two or more pointers of the same type point to the same memory; that is, they point to the same data.
On the other hand, suppose that instead of the earlier statement,  = ; (in Line A), we have the following statements: = new [10]; [] = []; The  statement creates an array of 10 components of type , and the base address of the array is stored in.
The  statement copies the array pointed to by into the array pointed to by  (see Figure 12-12).
If  deletes its memory, there is no effect on.
This case is an example of a deep copy.
More formally, in a deep copy, two or more pointers of the same type each point to their own copy of the data.
From the preceding discussion, it follows that you must know when to use a shallow copy and when to use a deep copy.
Classes and Pointers: Some Peculiarities In the previous section, we discussed how to use the arrow notation to access class members via the pointer if a pointer variable is of a class type.
Because a class can have pointer member variables, this section discusses some peculiarities of such classes.
To facilitate the discussion, we will use the following class: class ptrMemberVarType { Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
FIGURE 12-13 objectTwo x x.
Objects objectOne and objectTwo Destructor The object objectOne has a pointer member variable p.
Suppose that during program execution, the pointer p creates a dynamic array.
When objectOne goes out of scope, all of the member variables of objectOne are destroyed.
However, p created a dynamic array, and dynamic memory must be deallocated using the operator delete.
Thus, if the pointer p does not use the delete operator to deallocate the dynamic array, the memory space of the dynamic array will stay marked as allocated, even though it cannot be accessed.
How do we ensure that when p is destroyed, the dynamic memory created by p is also destroyed.
Suppose that objectOne is as shown in Figure 12-14.
FIGURE 12-14 Object objectOne and its data Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Classes and Pointers: Some Peculiarities.
Therefore, we can put the necessary code in the destructor to ensure that when objectOne goes out of scope, the memory created by the pointer p is deallocated.
For example, the definition of the destructor for the class ptrMemberVarType is:.
Of course, you must include the destructor as a member of the class in its definition.
Let us extend the definition of the class ptrMemberVarType by including the destructor.
Moreover, the remainder of this section assumes that the definition of the destructor is as given previously—that is, the destructor deallocates the memory space pointed to by p.
For the destructor to work properly, the pointer p must have a valid value.
If p is not properly initialized (that is, if the value of p is garbage) and the destructor executes, either the program terminates with an error message or the destructor deallocates an unrelated memory space.
For this reason, you should exercise extra caution when working with pointers.
Assignment Operator This section describes the limitations of the built-in assignment operators for classes with pointer member variables.
Suppose that objectOne and objectTwo are as shown in Figure 12-15.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
FIGURE 12-15 Objects objectOne and.
That is, the value of objectOne_0_x is copied into _0_x, and the value of objectOne_0_p is copied into _0_p.
Because p is a pointer, this member-wise copying of the data would lead to a shallow copying of the data.
That is, both _0_p and objectOne_0_p would point to the same memory space, as shown in Figure 12-16.
This situation could very well happen if the class ptrMemberVarType has a destructor that deallocates the memory space pointed to by p when an object of type ptrMemberVarType goes out of scope.
It suggests that there must be a way to avoid this pitfall.
To avoid this shallow copying of data for classes with a pointer member variable, Cplus_plus allows the programmer to extend the definition of the assignment operator.
This process is called overloading the assignment operator.
Chapter 13 explains how to accomplish this task by using operator overloading.
Once the assignment operator is properly overloaded, both objectOne and  have their own data, as shown in Figure 12-17.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Classes and Pointers: Some Peculiarities.
Objects objectOne and Copy Constructor When declaring a class object, you can initialize it by using the value of an existing object of the same type.
For example, consider the following statement: ptrMemberVarType objectThree(objectOne); The object objectThree is being declared and is also being initialized by using the value of objectOne.
That is, the values of the member variables of objectOne are copied into the corresponding member variables of objectThree.
This initialization is called the default member-wise initialization.
The default member-wise initialization is due to the copy constructor provided by the compiler.
Just as in the case of the assignment operator, because the class ptrMemberVarType has member variables that are pointers, this default initialization would lead to a shallow copying of the data, as shown in Figure objectOne.
FIGURE 12-18 Objects objectOne and objectThree Before describing how to overcome this deficiency, let us describe one more situation that could also lead to a shallow copying of the data.
The solution to both these problems is the same.
Recall that as parameters to a function, class objects can be passed either by reference or by value.
Remember that the class ptrMemberVarType has the destructor, which deallocates the memory space pointed to by p.
Suppose that objectOne is as shown in Figure 12-19.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Because objectOne is passed by value to paramObject, the copy constructor copies the member variables of objectOne into the corresponding member variables of paramObject.
Just as in the previous case, paramObject_0_p and objectOne_0_p would point to the same memory space, as shown in Figure 12-20.
FIGURE 12-20 Pointer member variables of objects objectOne and paramObject pointing to the same array Because objectOne is passed by value, the member variables of paramObject should have their own copy of the data.
In particular, paramObject_0_p should have its own memory space.
How do we ensure that this is, in fact, the case.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Classes and Pointers: Some Peculiarities.
During object declaration, the initialization of one object using the value of another object will lead to a shallow copying of the data if the default member-wise copying of data is allowed.
If, as a parameter, an object is passed by value and the default member-wise copying of data is allowed, it will lead to a shallow copying of the data.
In both cases, to force each object to have its own copy of the data, we must override the definition of the copy constructor provided by the compiler; that is, we must provide our own definition of the copy constructor.
This is usually done by putting a statement that includes the copy constructor in the definition of the class and then writing the definition of the copy constructor.
Then, whenever the copy constructor needs to be executed, the system would execute the definition provided by us, not the one provided by the compiler.
Therefore, for the class ptrMemberVarType, we can overcome this shallow copying problem by including the copy constructor in the class ptrMemberVarType.
Example 12-8 illustrates this.
The copy constructor automatically executes in three situations (the first two are described previously).
When an object is declared and initialized by using the value of another object When, as a parameter, an object is passed by value When the return value of a function is an object Therefore, once the copy constructor is properly defined for the class ptrMemberVarType, both objectOne_0_p and objectThree_0_p will have their own copies of the data.
Similarly, objectOne_0_p and paramObject_0_p will have their own copies of the data, as shown in Figure 12-21.
Pointer member variables of objects objectOne and paramObject with their own data Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
However, this deallocation has no effect on objectOne.
The general syntax to include the copy constructor in the definition of a class is: className(const className& otherObject); Notice that the formal parameter of the copy constructor is a constant reference parameter.
Example 12-8 illustrates how to include the copy constructor in a class and how it works.
EXAMPLE 12-8 Consider the following class: class ptrMemberVarType { public: void print() const;.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Classes and Pointers: Some Peculiarities.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Classes and Pointers: Some Peculiarities.
Line 14 8 Line Line Line Line Line Line Line Line Line Line 4: Enter 5.
The member variable  of listOne is an array of  10, which is Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The for loop in Line 5 reads and stores five  in listOne_0_.
The statement in Line 9 outputs the numbers stored in listOne, that is, the five numbers The statement in Line 11 declares listTwo to be an object of type ptrMemberVarType and also initializes listTwo using the values of listOne.
The statement in Line 13 outputs the The statements in Lines 15 and 16 modify listTwo, and the statement in Line 18 outputs the modified data of listTwo.
Notice that the data stored in listOne is unchanged, even though listTwo modified its data.
It follows that the copy constructor used to initialize listTwo using listOne (at Line 11) provides listTwo its own copy of the data.
The statements in Lines 23 through 28 show that when listOne is passed as a parameter by value to the function  (see Line 24), the corresponding formal parameter temp has its own copy of data.
Notice that the function  modifies the object temp; however, the object listOne remains unchanged.
See the outputs of the lines marked Line 23 (before the function  is called) and Line 25 (after the function  terminates) in the sample run.
Also notice that when the function terminates, the destructor of the class ptrMemberVarType deallocates the memory space occupied by temp_0_, which has no effect on listOne_0_.
For classes with pointer member variables, three things are normally done: 1.
Include the destructor in the class.
Overload the assignment operator for the class.
Chapter 13 discusses overloading the assignment operator.
Until then, whenever we discuss classes with pointer member variables, out of the three items in the previous list, we will implement only the destructor and the copy constructor.
Inheritance, Pointers, and Virtual Functions Recall that as a parameter, a class object can be passed either by value or by reference.
Earlier chapters also said that the types of the actual and formal parameters must match.
However, in the case of classes, Cplus_plus allows the user to pass an object of a derived class to a formal parameter of the base class type.
The formal parameter recognizes the base class portion of the derived class and allows it to pass.
First, let us discuss the case in which the formal parameter is either a reference parameter or a pointer.
To be specific, let us consider the following classes: class petType { public: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Inheritance, Pointers, and Virtual Functions |.
The class petType has three members.
The class dogType is derived from the class petType and has three members of its own.
Both classes have a member function print.
Suppose that the definitions of the member functions of both classes are as follows:.
The function callPrint has a formal reference parameter p of type petType.
You can call the function callPrint by using an object of either type petType or type dogType as a parameter.
Moreover, the body of the function callPrint calls the member function print.
Consider the following function main:.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sample Run: : Lucky : Tommy, : German Shepherd *** Calling the function callPrint *** : Lucky : Tommy The statements in Lines 1 through 6 are quite straightforward.
Let us look at the statements in Lines 7 and 9.
The statement in Line 7 calls the function callPrint and passes the object pet as the parameter; it generates the fourth line of the output.
The statement in Line 9 also calls the function callPrint but passes the object dog as the parameter; it generates the fifth line of the output.
The output generated by the statements in Lines 7 and 9 shows only the value of , even though each time a different class object was passed as a parameter.
Because in Line 9, object dog is passed as a parameter to the function callPrint, one would expect that the output generated by the statement in Line 9 should be the same as the second line of the output.
What actually occurred is that for both statements (Lines 7 and 9), the member function print of the base class petType was executed.
This is due to the fact that the binding of the member function print in the body of the function callPrint occurred at compile time.
Because the formal parameter p of the function callPrint is of type petType, the compiler associates the function print of the class petType for the statement p_0_print();.
More specifically, in compile-time binding, the necessary code to call a specific function is generated by the compiler.
Thus, when the body of the function callPrint executes, logically the print function of object dog should execute, which is not the case.
So, during program execution, how does Cplus_plus correct this problem of making the call to the appropriate function.
Cplus_plus corrects this problem by providing the mechanism of virtual functions.
The binding of virtual functions occurs at program execution time, not at compile time.
This kind of binding is called run-time binding, late binding, or dynamic binding.
More formally, in run-time binding, the compiler does not generate the code to call a specific function.
Instead, it generates enough information to enable the run-time system to generate the specific code for the appropriate function call.
Run-time binding is also known as dynamic binding.
In Cplus_plus, virtual functions are declared using the reserved word virtual.
Let us redefine the previous classes using this feature.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Inheritance, Pointers, and Virtual Functions |.
Note that we need to declare a virtual function only in the base class.
The definition of the dogType member function print is the same as before.
Because we have placed a virtual function declaration in the base class, a base class object can use the derived class's definition.
For example, if we execute the previous program with these modifications, the output is as follows: Sample Run: : Lucky : Tommy, : German Shepherd *** Calling the function callPrint *** : Lucky : Tommy, : German Shepherd This output shows that for the statement in Line 9, the print function of dogType is executed (see the last two lines of the output).
The previous discussion also applies when a formal parameter is a pointer to a class, and a pointer of the derived class is passed as an actual parameter.
To illustrate this feature, suppose we have the preceding classes.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sample Run: : Lucky : Tommy, : German Shepherd *** Calling the function callPrint *** : Lucky : Tommy, : German Shepherd The preceding examples show that if a formal parameter, say p of a class type, is either a reference parameter or a pointer and p uses a virtual function of the base class, we can effectively pass a derived class object as an actual parameter to p.
However, if p is a value parameter, then this mechanism of passing a derived class object as an actual parameter to p does not work, even if p uses a virtual function.
Recall that, if a formal parameter is a value parameter, the value of the actual parameter is copied into the formal parameter.
Therefore, if a formal parameter is of a class type, the member variables of the actual object are copied into the corresponding member variables of the formal parameter.
Suppose that we have the above classes—that is,  and.
Consider the following function definition:.
The object dog has two member variables, name and breed.
The member variable name is inherited from the base class.
Consider the following function call: callPrint(dog); Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Inheritance, Pointers, and Virtual Functions | 857 In this statement, because the formal parameter p is a value parameter, the member variables of dog are copied into the member variables of p.
However, because p is an object of type , it has only one member variable.
Consequently, only the member variable name of dog will be copied into the member variable name of p.
Also, because the statement: p_0_print(); in the body of the function is linking print to the  object p, it will result in executing the member function print of the class.
The output of the following program further illustrates this concept.
Sample Run: Name: Lucky Name: Tommy, Breed: German Shepherd *** Calling the function callPrint *** Name: Lucky Name: Tommy Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
In Line 9, because the formal parameter p is a value parameter, the member variables of dog are copied into the corresponding member variables of p.
However, because p is an object of base type , it has only the one member variable name.
Consequently, only the member variable name of dog is copied into the member variable name of p.
Moreover, the statement p_0_print(); in the function callPrint executes the function print of the base class , not of the derived class.
Therefore, the last line of the output shows only the value of name (the member variable of dog).
An object of the base class type cannot be passed to a formal parameter of the derived Before closing this section, we discuss another issue related to virtual functions.
Suppose that the definition of the class  is as before, and the definition of the class  is modified slightly as follows: class : public {.
This is called the slicing problem.
The following statement will result in a compile-time error.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Abstract Classes and Pure Virtual Functions |.
The destructor executes automatically when the class object goes out of scope.
Thus, if the object creates dynamic memory space, the destructor can be designed to deallocate that memory space.
If a derived class object is passed to a formal parameter of the base class type, the destructor of the base class executes regardless of whether the derived class object is passed by reference or by value.
Logically, however, the destructor of the derived class should be executed when the derived class object goes out of scope.
To correct this problem, the destructor of the base class must be virtual.
The virtual destructor of a base class automatically makes the destructor of a derived class virtual.
When a derived class object is passed to a formal parameter of the base class type, then when the object goes out of scope, the destructor of the derived class executes.
After executing the destructor of the derived class, the destructor of the base class executes.
Therefore, when the derived class object is destroyed, the base class part (that is, the members inherited from the base class) of the derived class object is also destroyed.
If a base class contains virtual functions, make the destructor of the base class virtual.
Abstract Classes and Pure Virtual Functions The preceding sections discussed virtual functions.
Other than enforcing run-time binding of functions, virtual functions also have another use, which is discussed in this section.
Chapter 11 discussed the second principle of OOD—inheritance.
Through inheritance we can derive new  without designing them from scratch.
The derived , in addition to inheriting the existing members of the base class, can add their own members and also redefine or override public and protected member functions of the base class.
The base class can contain functions that you would want each derived class to implement.
There are many scenarios when it is desirable for a class to serve as a base class for a number of derived ; however, the derived  may contain certain functions that may not have meaningful definitions in the base class.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
As noted in that chapter, from the class shape, you can derive other , such as rectangle, circle, ellipse, and so on.
Some of the things common to every shape are its center, using the center to move a shape to a different location, and drawing the shape.
We can  these in the class shape.
For example, you could have the definition of the class shape similar to the following: class shape {.
Note that we have made the functions draw and move virtual to enforce run-time binding of these functions.
This definition of the class shape requires you to write the definitions of the functions draw and move.
However, at this point, there is no shape to draw or move.
One way to handle this is to make the body of these functions empty.
This solution would work, but it has a drawback.
Once we write the definitions of the functions of the class shape, then we could create an object of this class and invoke the empty  and move functions.
Because there is no shape to work with, we would like to prevent the user from creating objects of the class shape.
It follows that we would like to do the following two things—to not include the definitions of the functions  and move and to prevent the user from creating objects of the class shape.
Because we do not want to include the definitions of the functions  and move of the class shape, we must convert these functions to pure virtual functions.
In this case, the prototypes of these functions are: virtual void () = 0; virtual void move(double x, double ) = 0; Note the  = 0 before the semicolon.
Once you make these functions pure virtual functions in the class shape, you no longer need to provide the definitions of these functions for the class shape.
Once a class contains one or more pure virtual functions, then that class is called an abstract class.
Thus, the abstract definition of the class shape is similar to the following: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Abstract Classes and Pure Virtual Functions |.
Note that this is a pure virtual //function.
Now suppose that we derive the class rectangle from the class shape.
To make rectangle a nonabstract class so that we can create objects of this class, the class (or its implementation file) must provide the definitions of the pure virtual functions of its base class, which is the class shape.
Note that in addition to the pure virtual functions, an abstract class can contain instance variables, constructors, and functions that are not pure virtual.
However, the abstract class must provide the definitions of the constructor and functions that are not pure virtual.
The following example further illustrates how abstract  work.
EXAMPLE 12-9 In Chapter 11, we defined the class partTimeEmployee, which was derived from the class personType, to illustrate inheritance.
We also noted that there are two types of employees: full-time and part-time.
The base salary of a full-time employee is usually fixed for a year.
In addition, a full-time employee may receive a bonus.
On the other hand, the salary of a part-time employee is usually calculated according to the pay rate per hour and the number of hours worked.
In this example, we first define the class employeeType, derived from the class personType, to store an employee's name and ID.
We include functions to set the ID and retrieve the ID.
We also include pure virtual functions print and calculatePay to print an employee's data, which includes the employee's ID, name, and wages.
From the class employeeType, we derive the  fullTimeEmployee and partTimeEmployee and provide the definitions of the pure virtual functions of the class employeeType.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Abstract Classes and Pure Virtual Functions |.
The definitions of the constructor and functions of the class fullTimeEmployee are: void fullTimeEmployee::set(string , string , long ,.
Abstract Classes and Pure Virtual Functions | 865 fullTimeEmployee::fullTimeEmployee(string , string , long , double ,.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Abstract Classes and Pure Virtual Functions |.
Sample Run: : 75 Name: John Smith : $61700 : 275 Name: Bill Nielson : $883_0_5 The preceding output is self-explanatory.
We leave the details as an exercise.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 8 briefly explained how loops can be used to process elements stored in an array.
Moreover, the previous sections of this chapter discussed abstract classes.
Using these features, this section discusses how to use arrays to manipulate lists.
Let us  make the following definition.
List: A collection of elements of the same type.
The length of a list is the number of elements in the list.
Some of the operations performed on a list are as follows: 1.
Create the list.
The list is initialized to an empty state.
Determine whether the list is empty.
Determine whether the list is full.
Find the size of the list.
Destroy, or clear, the list.
Determine whether an item is the same as a given list element.
Insert an item in the list at the specified location.
Remove an item from the list at the specified location.
Replace an item at the specified location with another item.
Retrieve an item from the list at the specified location.
Search the list for a given item.
The list we create can be sorted or unsorted.
However, the algorithms to implement certain operations are the same whether the list is sorted or unsorted.
For example, a list, sorted or unsorted, is empty if the length of the list is empty.
However, the search algorithms for sorted and unsorted lists are typically different.
Therefore, next we create the abstract class that implements some of these operations.
We will separately describe the classes to create sorted and unsorted lists.
However, we must  decide how to store the list in the computer's memory.
Because all the elements of a list are of the same type, an effective, convenient, and a common way to process a list is to store it in an array.
Initially, the size of the array holding the list elements is usually larger than the number of elements in the list so that, at a later stage, the list can grow to a specific size.
Thus, we must know how full the array is, that is, we must keep track of the number of list elements stored in the array.
Now, Cplus_plus allows the programmer to create dynamic arrays.
Therefore, we will leave it for the user to specify the size of the array.
The size of the array can be specified when a list object is declared.
It follows that, in order to maintain and process the list in an array, we need the following three variables: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The array, list, holding the list elements.
A variable, length, to store the length of the list (that is, the number of list elements currently in the array).
A variable, maxSize, to store the size of the array (that is, the maximum number of elements that can be stored in the array).
Now that you know the operations to be performed on a list and ways to store the list into computer memory, we can define the class implementing the list as an ADT (abstract data type).
For illustration purposes, we assume that the elements of the list are of type int.
We will remove this restriction when we discuss class templates in Chapter 13; there, we will develop a generic class that can be used to process a variety of lists.
The following class defines array-based int lists as an ADT: Now that you know the operations to be performed on a list and how to store the list into the computer's memory, next we define the abstract class arrayListType implementing the list as an ADT (abstract data type).
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Note that this is an abstract function.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
UML class diagram, the name of an abstract class and abstract function is shown in italics.
UML diagram of the class arrayListType Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Moreover notice that the functions insertAt, insertEnd, replaceAt, seqSearch, insert, and remove are declared as abstract.
This is because, as noted earlier, typically we deal with two types of lists—lists whose elements are arranged according to some criteria, such as sorted list, and lists whose elements are in no particular order, unsorted lists.
The algorithms to implement the operations, search, insert, and remove slightly differs for sorted and unsorted lists.
Therefore, by using the principle of inheritance, from the class arrayListType, we in fact, will derive two classes: orderedArrayListType and unorderedArrayListType.
Objects of the class unorderedArrayListType would arrange list elements in no particular order, that is, these lists are unsorted.
On the other hand, objects of the class orderedArrayListType would arrange elements according to some comparison criteria, usually, greater than or equal to.
That is, these lists will be in ascending order.
Moreover, after inserting an element into or removing an element from an ordered list, the resulting list will be ordered.
We will, therefore, separately describe the algorithm to implement the operations search, insert, and remove for unsorted and sorted lists.
Because each of the classes orderedArrayListType and unorderedArrayListType will provide separate definitions of the functions insertAt, insertEnd, replaceAt, seqSearch, insert, and remove, and because these functions would access the instance variable, to provide direct access to the instance variables, the instance variables are declared as protected.
Next, we write the definitions of the nonabstract functions.
The list is empty if  is 0; it is full if  is equal to.
Therefore, the definitions of the functions isEmpty and isFull are.
The member variable  of the class arrayListType stores the number of elements currently in the list.
Similarly, because the  of the array holding the list elements is stored in the member variable ,  specifies the maximum of the list.
Therefore, the definitions of the functions listSize and maxListSize are.
The definition of this function is: {.
The function removeAt removes an item from a specific  in the list.
The of the item to be removed is passed as a parameter to this function.
After removing the item from the list, the  of the list is reduced by 1.
If the item to be removed is somewhere in the middle of the list, after removing the item we must move certain elements up one array slot because we cannot leave holes in the portion of the array containing the list.
Figure 12-23 illustrates this concept.
Thus, after removing an element, the  of the list is 5.
Suppose that the item to be removed is at, say  3.
Clearly, we must move list[4] into list[3] and list[5] into list[4], in this order.
The definition of the function removeAt is {.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The definition of this function is: void arrayListType::retrieveAt( , & ) {.
We now discuss the definition of the constructors and destructor.
The constructor creates an array of the  specified by the user, and initializes the  of the list to 0 and the to the  of the array specified by the user.
The  of the array is passed as a parameter to the constructor.
The default array  is 100.
The destructor deallocates the memory occupied by the array holding the list elements.
The definitions of the constructor and the destructor are as follows: {.
Recall that the copy constructor is called when an object is passed as a (value) parameter to a function, and when an object is declared and initialized using the value of another object of the same type.
It copies the values of the member variables of the actual object into the corresponding member variables of the formal parameter and the object being created.
Unordered Lists As described in the preceding section, we derive the class unorderedArrayListType from the abstract class arrayListType and implement the operations insertAt, insertEnd, replaceAt, seqSearch, insert, and remove.
The definition of the class unorderedArrayListType is: (To save space, we  the member functions without documentation.
The descriptions of these functions are the class unorderedArrayListType: public arrayListType {.
We leave the UML class diagram and its inheritance hierarchy of the class unorderedArrayListType as an exercise for you.
The function insertAt inserts an  at a specific  in the.
The  to be inserted and the insert  in the array are passed as parameters to this function.
In order to insert the  somewhere in the middle of the , we must first make room for the new.
That is, we need to move certain elements down one array slot.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
If the  is to be inserted at, say  6, we can easily accomplish this by copying the  in [6].
On the other hand, if the is to be inserted at, say  3, we first need to move elements [3], [4], and [5] one array slot left to make room for the new.
Thus, we must first copy [5] into [6], [4] into [5], and [3] into [4], in this order.
Of course, special cases such as trying to insert in a full  must be handled separately.
Some of these cases can be accomplished by other member functions.
The definition of the function insertAt is as follows: void unorderedArrayListType::insertAt( , {.
The function remove deletes an  from the.
The  to be deleted is passed as a parameter to this function.
In order to delete the , the function calls the member function seqSearch to determine whether or not the  to be deleted is in the.
If the  to be deleted is  in the , the  is removed from the  and the of the  is decremented by 1.
If the  to be removed is  in the , the function seqSearch returns the index of the  in the  to be deleted.
We can now use the index returned by the function seqSearch, and use the function removeAt to remove the  from the.
Therefore, the definition of the function remove is:.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sample Run: In this sample run, the user input is shaded.
List Line Line Line Line Line 3: Enter 8 integers: 23 89 54 32 56 11 88 39 8: : 23 89 54 32 56 11 88 39 11: Enter the  to be deleted: 23 15: After removing 23 : 89 54 32 56 11 88 39 18: Enter the search : 11 22: 11  in.
The preceding program is self-explanatory.
We leave the details as an exercise.
The Web site accompanying this book contains the program testProgUnorderedList_II_0_cpp, which illustrates how the copy constructor on an unorderedArrayListType object works.
That is, the elements of the  need not be distinct.
On the other hand, a set is also a collection of elements of the same type.
However, the elements of a set are distinct.
It follows that a set is a  with distinct elements.
In this section we designed the class unorderedArrayListType to process unordered lists.
Note that the functions insertAt and insertEnd do not check whether the to be inserted is already in the.
Similarly, the function replaceAt, does not check if the item to be replaced is already in the.
Just as you can design a class to manipulate lists, you can also design a class to manipulate sets.
Programming Exercise 12, at the end of this chapter asks you to design the class unorderedSetType, derived from the class unorderedArrayListType, to manipulate sets.
Ordered Lists As described earlier we derive two classes from the abstract class arrayListType, which are: unorderedArrayListType and orderedArrayListType.
Elements of an unorderedArrayListType object are in no particular order.
However, elements of an object orderedArrayListType are in ascending order.
The preceding section described the operation of the class unorderedArrayListType.
This section describes the class orderedArrayListType.
The class orderedArrayListType also contains the function insert to insert an item at the proper place in the.
The following class defines ordered array-based int lists as Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
We leave the UML class diagram and its inheritance hierarchy of the class orderedArrayListType as an exercise for you.
We give only the definition of the function insert and leave others as an exercise for you.
The function insert inserts a new  at the proper place in the  and the  of the  is increased by 1.
The definition of this function is:.
Address of Operator and Classes.
Programming Exercise 13, at the end of this chapter asks you to design the class orderedSetType, derived from the class orderedArrayListType, to manipulate ordered sets.
Address of Operator and Classes This chapter has used the address of operator, &, to store the address of a variable into a pointer variable.
The address of operator is also used to create aliases to an object.
Consider the following statements: int ; int & = ;.
The address of operator can also be used to return the address of a private member variable of a class.
However, if you are not careful, this operation can result in serious errors in the program.
The following example helps illustrate this idea.
Consider the following class definition: //header file testadd_0_h #ifndef H_testAdd #define H_testAdd class testAddress {.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Address of Operator and Classes.
Chapter 10 said that private member variables are not accessible outside of the class by default.
However, by returning their addresses, the programmer can make them accessible.
One way to resolve this problem is to never provide the user of the class with the addresses of the private member variables.
Sometimes, however, it is necessary to return the address of a private member variable, as we will see in the next chapter.
How can we prevent the program from directly manipulating the private member variables.
To fix this problem, we use the word const before the return type of the function.
This way, we can still return the addresses of the private member variables, but at the same time prevent the programmer from directly manipulating the private member variables.
Let us rewrite the class  using this feature.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Pointer variables contain the addresses of other variables as their values.
In Cplus_plus, no name is associated with the pointer data type.
A pointer variable is declared using an asterisk, *, between the data type and the variable.
For example, the statements: int *p; char *ch;.
The value of  points to a memory space of type int, and the value of ch points to a memory space of type char.
Usually,  is called a pointer variable of type int, and ch is called a pointer variable of type char.
In Cplus_plus, & is called the address of operator.
The address of operator returns the address of its operand.
For example, if is a pointer variable of type int and num is an int variable, the statement: = &num; 6.
When used as a unary operator, * is called the dereferencing operator.
The memory location indicated by the value of a pointer variable is accessed by using the dereferencing operator, *.
For example, if  is a pointer variable of type int, the statement: * = 25; 8.
You can use the member access operator arrow, arrow_operator, to access the component of an object pointed to by a pointer.
Pointer variables are initialized using either 0 (the integer zero), NULL, nullptr, or the address of a variable of the same type.
The only number that can be directly assigned to a pointer variable is 0.
The only arithmetic operations allowed on pointer variables are increment (plus_plus), decrement (minus_minus), addition of an integer to a pointer variable, subtraction of an integer from a pointer variable, and subtraction of a pointer from another pointer.
Pointer arithmetic is different than ordinary arithmetic.
When an integer is added to a pointer, the value added to the value of the pointer variable is the integer times the size of the object to which the pointer is pointing.
Similarly, when an integer is subtracted from a pointer, the value subtracted from the value of the pointer variable is the integer times the size of the object to which the pointer is pointing.
Pointer variables can be compared using relational operators.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Quick Review | 14.
A variable created during program execution  called a dynamic variable.
The operator new  used to create a dynamic variable.
The operator delete  used to deallocate the memory occupied by a dynamic variable.
In Cplus_plus, both new  delete are reserved words.
The operator new  two forms: one to create a single dynamic variable another to create an array of dynamic variables.
If   a pointer of type , the statement: = new ;.
The operator delete  two forms: one to deallocate the memory occupied by a single dynamic variable  another to deallocate the memory occupied by an array of dynamic variables.
If   a pointer of type , the statement: delete ; 23.
The array name  a constant pointer.
It always points to the same memory location, which  the location of the first array component.
To create a dynamic array, the form of the new  that creates an array of dynamic variables  used.
For example, if   a pointer of type , the statement: = new [10]; 25.
The base address of the array  stored in.
We call  a dynamic array.
Array notation can be used to access the components of a dynamic array.
For example, suppose   a dynamic array of 10 components.
Then, [0] refers to the first array component, [1] refers to the second array component,  so on.
In particular, [i] refers to the (i + 1)th component of the array.
An array created during program execution  called a dynamic array.
If   a dynamic array, then the statement: delete [] ; 28.
Cplus_plus allows a program to create dynamic multidimensional arrays.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook /or eChapter(s).
Editorial review  deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes,  Lists In the statement  **board;, the variable board  a pointer to a pointer.
In a shallow copy, two or more pointers of the same type point to the same memory space; that , they point to the same data.
In a deep copy, two or more pointers of the same type have their own copies of the data.
If a class  a destructor, the destructor  automatically executed whenever a class object goes out of scope.
If a class  pointer member variables, the built-in assignment operators provide a shallow copy of the data.
A copy constructor executes when an object  declared  initialized by using the value of another object  when an object  passed by value as a parameter.
Cplus_plus allows a user to pass an object of a derived class to a formal parameter of the base class type.
The binding of virtual functions occurs at execution time, not at compile time,   called dynamic, or run-time, binding.
In Cplus_plus, virtual functions are declared using the reserved word virtual.
A class  called an abstract class if it contains one or more pure virtual functions.
Because an abstract class  not a complete class—as it (or its implementation file) does not contain the definitions of certain functions—you cannot create objects of that class.
In addition to the pure virtual functions, an abstract class can contain instance variables, constructors,  functions that are not pure virtual.
However, the abstract class must provide the definitions of constructors functions that are not pure virtual.
A list  a collection of elements of the same type.
The commonly performed operations on a list are as follows: create the list, determine whether the list  empty, determine whether the list  full, find the size of the list, destroy or clear the list, determine whether an item  the same as a given list element, insert an item in the list at the specified location, remove an item from the list at the specified location, replace an item at the specified location with another item, retrieve an item from the list from the specified location,  search the list for a given item.
The address of  can be used to return the address of a private member variable of a class.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Mark the following statements as true or false.
If  is a pointer variable, then * refers to the memory location to In Cplus_plus, the dereferencing operator has a higher precedence than the Variables that are created during program execution are called dynamic The statement delete ; deallocates the dynamic variable that is Given the declaration: int list[10];.
Given the declaration:.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
How is * used to create pointers.
Give an example to justify your b.
How is * used to dereference pointers.
Give an example to justify your Consider the following statement: a.
Write Cplus_plus statements that use the variable numPtr to increment the value.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Suppose that  is a pointer of type  and  is a pointer of type.
Also suppose that the size of the memory allocated for an  value is 4 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes, and Lists bytes and the size of the memory allocated for a  value is 8 bytes.
What are the values of  and  after the statements  =.
Write a Cplus_plus code that inputs data into the array  from the standard input device.
Write a Cplus_plus statement that deallocates the memory space of the array to which  points.
Consider the following Cplus_plus code: a.
Write the Cplus_plus statement that deallocates the memory space occupied by.
Write a statement that declares sales to be a pointer to a pointer of type Write a Cplus_plus code that dynamically creates a two-dimensional array of five rows and seven columns and sales contains the base address of Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Write a Cplus_plus code that deallocates the memory space occupied by the Name three things that you should  for classes with pointer member Suppose that you have the following classes, classA and classB: c.
What is the output of the function main of Exercise 34, if the definition of class classA {.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes, and Lists Consider the following definition of the class studentType: public studentType: public personType {.
Rewrite the definition of the class studentType so that the functions print and Suppose that the definitions of the classes employeeType, fullTimeEmployee, and partTimeEmployee are as given in Example.
Redo Programming Exercise 5 of Chapter 8 using dynamic arrays.
Redo Programming Exercise 6 of Chapter 8 using dynamic arrays.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
You must ask the user for the number of candidates and then create the appropriate arrays to hold the data.
Programming Exercise 11 in Chapter 8 explains how to add large integers using arrays.
However, in that exercise, the program could add only integers of, at most, 20 digits.
This chapter explains how to work with dynamic integers.
Design  class named largeIntegers such that an object of this class can store an integer of any number of digits.
Add operations to add, subtract, multiply, and compare integers stored in two objects.
Also add constructors to properly initialize objects and functions to set, retrieve, and print the values of objects.
Banks offer various types of accounts, such as savings, checking, certificate of deposits, and money market, to attract customers as well as meet their specific needs.
Two of the most commonly used accounts are savings and checking.
Each of these accounts has various options.
For example, you may have  savings account that requires no minimum balance but has  lower interest rate.
Similarly, you may have  checking account that limits the number of checks you may write.
Another type of account that is used to save money for the long term is certificate of deposit (CD).
In this programming exercise, you use abstract classes and pure virtual functions to design classes to manipulate various types of accounts.
For simplicity, assume that the bank offers three types of accounts: savings, checking, and certificate of deposit, as described next.
Savings accounts: Suppose that the bank offers two types of savings accounts: one that has no minimum balance and  lower interest rate and another that requires  minimum balance and has  higher interest rate.
Checking accounts: Suppose that the bank offers three types of checking accounts: one with  monthly service charge, limited check writing, no minimum balance, and no interest; another with no monthly service charge, minimum balance requirement, unlimited check writing and lower interest; and  third with no monthly service charge,  higher minimum requirement, higher interest rate, and unlimited check writing.
Certificate of deposit (CD): In an account of this type, money is left for some time, and these accounts draw higher interest rates than savings or checking accounts.
Suppose that you purchase  CD for six months.
Then we say that the CD will mature in six months.
The penalty for early withdrawal is stiff.
Figure 12-25 shows the inheritance hierarchy of these bank accounts.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Inheritance hierarchy of banking accounts Note that the classes bankAccount and checkingAccount are abstract.
That is, we cannot instantiate objects of these classes.
The other classes in Figure 12-25 are not abstract.
Therefore, instance variables such as name, accountNumber, and balance should be declared in the abstract class bankAccount.
Some operations common to all types of accounts are retrieve account owner's name, account number, and account balance; make deposits; withdraw money; and create monthly statements.
So include functions to implement these operations.
Some of these functions will be pure virtual.
Therefore, it inherits all the properties of a bank account.
Because one of the objectives of a checking account is to be able to write checks, include the pure virtual function writeCheck to write a check.
Therefore, it inherits all the properties of a checking account.
For simplicity, assume that this type of account does not pay any interest, allows the account holder to write a limited number of checks each month, and does not require any minimum balance.
Include appropriate named constants, instance variables, and functions in this class.
Therefore, it inherits all the properties of a checking account.
Furthermore, this type of account pays interest, allows the account holder to write checks, and requires a minimum balance.
Therefore, it inherits all the properties Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Furthermore, this type of account pays higher interest and requires a higher minimum balance than the no service charge checking account.
Therefore, it inherits all the properties of a bank account.
Furthermore, a savings account also pays interest.
Therefore, it inherits all the properties of a savings account.
It also requires a minimum balance.
Therefore, it inherits all the properties of a bank account.
In addition, it has instance variables to store the number of CD maturity months, interest rate, and the current CD month.
Write the definitions of the classes described in this programming exercise and a program to test your classes.
The function retrieveAt of the class arrayListType is written as a void function.
Rewrite this function so that it is written as a value returning function, returning the required item.
If location of the item to be returned is out of range, use the assert function to terminate the program.
Also, write a program to test your function.
Use the class unorderedArrayListType to test your function.
The function removeAt of the class arrayListType removes an element from the list by shifting the elements of the list.
However, if the element to be removed is at the beginning of the list and the list is fairly large it could take a lot of computer time.
Because the list elements are in no particular order, you could simply remove the element by swapping the last element of the list with the item to be removed and reducing the length of the list.
Rewrite the definition of the function removeAt using this technique.
Use the class unorderedArrayListType to test your function.
The function remove of the class arrayListType removes only the first occurrence of an element.
Add the function removeAll as an abstract function to the class arrayListType, which would remove all occurrences of a given element.
Also, write the definition of the function removeAll in the class unorderedArrayListType and write a program to test this function.
Add the function min as an abstract function to the class arrayListType to return the smallest element of the list.
Also, write the definition of the function min in the class unorderedArrayListType and write a program to test this function.
Add the function max as an abstract function to the class arrayListType to return the largest element of the list.
Also, write the definition of the function max in the class unorderedArrayListType and write a program to test this function.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 12: Pointers, Classes, Virtual Functions, Abstract Classes, and Lists Write the definitions of the functions of the class orderedArrayListType that are not given in this chapter.
Also, write a program to test various operations of this class.
Design the class unorderedSetType, derived from the class unorderedArrayListType, to manipulate sets.
Note that you need to redefine only the functions insertAt, insertEnd, and replaceAt.
If the item to be inserted is already in the list, the functions insertAt and insertEnd output an appropriate message.
Similarly, if the item to be replaced is already in the list, the function replaceAt outputs an appropriate message.
Also, write a program to test your class.
The elements of an unorderedSetType object are distinct, but in no particular order.
Design the class orderedSetType, derived from the class orderedArrayListType, to manipulate ordered sets.
The elements of an orderedSetType object are distinct and in ascending order.
Note that you need to redefine only the functions insert and replaceAt.
If the item to be inserted is already in the list, the function insert outputs an appropriate message.
Similarly, if the item to be replaced is already in the list, the function replaceAt outputs an appropriate message.
Also, write a program to test your class.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Explore how to construct function templates and class templates Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The ability to combine data and operations on the data is called encapsulation.
It is the first principle of object-oriented design (OOD).
Chapter 10 defined the abstract data type (ADT) and described how  in Cplus_plus implement ADT.
Chapter 11 discussed how new  can be derived from existing  through the mechanism of inheritance.
Inheritance, the second principle of OOD, encourages code reuse.
This chapter covers operator overloading and templates.
Templates enable the programmer to write generic code for related functions and.
We will also simplify function overloading (introduced in Chapter 6) through the use of templates, called function templates.
Why Operator Overloading Is Needed Chapter 10 defined and implemented the class clockType.
It also showed how you can use the class clockType to represent the time of day in a program.
Let us review some of the characteristics of the class clockType.
Consider the following statements: clockType myClock(8, 23, 34); clockType yourClock(4, 5, 30); The first statement declares myClock to be an object of type clockType and initializes the member variables hr, min, and sec of myClock to 8, 23, and 34, respectively.
The second statement declares yourClock to be an object of type clockType and initializes the member variables hr, min, and sec of yourClock to 4, 5, and 30, respectively.
Now consider the following statements: myClock_0_printTime(); myClock_0_incrementSeconds();.
The first statement prints the value of myClock in the form hr:min:sec.
The second statement increments the value of myClock by one second.
The third statement checks whether the value of myClock is the same as the value of yourClock.
These statements do their job.
However, if we can use the insertion operator << to output the value of myClock, the increment operator plus_plus to increment the value of myClock by one second, and relational operators for comparison, we can enhance the Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Recall that the only built-in operations on  are the assignment operator and the member selection operator.
Therefore, other operators cannot be directly applied to class objects by default.
However, Cplus_plus allows the programmer to extend the definitions of operators such as relational operators, arithmetic operators, the insertion operator for data output, and the extraction operator for data input—so they can be applied to.
In Cplus_plus terminology, this is called operator overloading.
Operator Overloading Recall how the arithmetic operator / works.
If both operands of / are integers, the result is an integer; otherwise, the result is a floating-point number.
This means that the / operator has one definition when both operands are integers and another when an operand is a floating-point number.
Which definition is used depends on the data types of the operand it is used with.
Similarly, the stream insertion operator, <<, and the stream extraction operator, >>, are overloaded.
The operator >> is used as both a stream extraction operator and a right shift operator.
The operator << is used as both a stream insertion operator and a left shift operator.
These are examples of operator overloading.
The results of + and - are different for integer arithmetic, floating-point arithmetic, and pointer arithmetic.
Cplus_plus allows the user to overload most of the  so that the  can work effectively in a specific application.
It does not allow the user to create new.
Most of the existing  can be overloaded to manipulate class objects.
In order to overload an , you must write function(s) (that is, the header and body) to define what operation the overloaded  indicates should be performed.
The name of the function that overloads an  is the reserved word followed by the  to be overloaded.
For example, the name of the function to overload the  >= is: >= Operator function: The function that overloads an.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Therefore, the  function is a value-returning function.
The syntax of the heading for an  function is: In Cplus_plus,  is a reserved word.
Recall that the only built-in operations on  are  (=) and member selection.
To use other  on class objects, they must be explicitly overloaded.
Operator overloading provides the same concise expressions for user-defined data types as it does for built-in data types.
To overload an  for a class: 1.
Include the statement to declare the function prototype to overload the (that is, the  function) in the definition of the class.
Write the definition of the  function.
Certain rules must be followed when you include an  function in a class definition.
These rules are described in the section, "Operator Functions as Member Functions and Nonmember Functions" later in this chapter.
Overloading an Operator: Some Restrictions When overloading an , keep the following in mind: 1.
You cannot change the precedence of an.
The associativity cannot be changed.
Default parameters cannot be used with an overloaded.
You cannot change the number of parameters an  takes.
Only existing  can be overloaded.
The meaning of how an  works with built-in types, such as int, remains the same.
That is, you cannot redefine how  work with built-in data types.
Operators can be overloaded either for objects of the user-defined types, or for a combination of objects of the user-defined type and objects of the built-in type.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Now that we know the syntax to overload an  for a class and certain restrictions on  overloading, in this example, we only illustrate how to overload the relational  == for the class clockType.
After discussing, in general, various concepts related to  overloading, later in this chapter in the Programming Example clockType, we will show how to overload other , such as >>, <<, and plus_plus (pre-increment), for the class clockType.
The prototype of the function to overload the equality  for the class clockType is: bool ==(const clockType& otherClock) const; Therefore, this statement must be included in the definition of the class clockType.
Because in this example we are illustrating how to only overload the  ==, we do not include the functions to increment the time.
So consider the following definition of the class clockType: class clockType {.
Also, the definitions of other functions of the class clockType are the same as given in Chapter 10.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sample Run: Line Line Line Line Line 6: : 08:23:50 9: yourClock: 08:23:50 12: tempClock: 09:16:25 16: The time of  and yourClock are.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
However, note that the statement in Line 15 uses the == to compare the time of  and yourClock.
Similarly, the statement in Line 19 uses the  == to compare the time of  and tempClock.
The output of statements in Lines 16 and 22 show that the  == is successfully overloaded for the class clockType.
Before discussing  overloading in general, in the next two sections we discuss two important concepts related to  overloading.
Pointer this A member function of a class can (directly) access the member variables of a given object of that class.
Sometimes, it is necessary for a member function to refer to the object as a whole, rather than the object's individual member variables.
How do you refer to the object as a whole (that is, as a single unit) in the definition of the member function, especially when the object is not passed as a parameter.
Every object of a class maintains a (hidden) pointer to itself, and the name of this pointer is this.
In Cplus_plus, this is a reserved word.
When an object invokes a member function, the member function references the pointer this of the object.
For example, suppose that test is a class and has a member function called one.
Further suppose that the definition of one looks like the following: {.
That is, the member variables of  are copied into the corresponding member variables of.
When object  invokes function one, the pointer this in the definition of member function one refers to object , so this means the address of  and *this means the contents of.
On the other hand, in the statement = _0_one(); the pointer this in the definition of member function one refers to object , and so this means the address of  and *this means the contents of.
So the statement copies the contents of object  into object.
The following example illustrates how the pointer this works.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
We will add a function to this class to illustrate how the pointer this works.
We do not give the complete definition of this class.
We only show the function that uses the pointer this to return the whole object.
The complete definition can be found at the Web site accompanying this book.
Line 10: Area of  = 200_0_00 Line 12: Area of  = 800_0_00 For the most part, the output is self-explanatory.
The statement in Line 7 creates the object  and sets the  and  to 20_0_00 and 10_0_00, respectively.
The statement in Line 8 creates the object  and using the default constructor sets the and  to 0_0_00, and 0_0_00, respectively.
The statement in Line 10 outputs the of.
The statement in Line 11 doubles the dimensions of  and then the object , with new  and , is returned by the pointer this.
The assignment  then copies the value of  into.
The statement in Line 12 outputs the  of.
The following example shows another way of how the pointer this works.
EXAMPLE 13-3 Consider the following class: class rectangleType {.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Note that the definition of the class rectangleType is the same as given in Chapter 11, except that here, in the definition of the class rectangleType, we have added the functions setLength and setWidth to individually set a rectangle's  and , and then return the entire object.
We have also replaced the constructors with the constructor with default parameters.
The definitions of the functions print, setDimension, getLength, getWidth, , and perimeter are the same as before.
The definition of the constructor with default parameters is the same as the definition of the constructor with parameters.
The definitions of the functions setLength and setWidth are as follows:.
Consider the statement in Line 10, which is:.
This expression sets the  of myRectangle to 15_0_25 and returns a reference of the calling object, which is myRectangle.
Thus, the returned *this pointer makes the next expression executed equivalent to which sets the  of myRectangle to 12_0_00.
By returning the dereferenced this pointer, member functions can be "chained" like this.
The statement in Line 12 outputs the value of myRectangle.
The statement in Line 14 sets the  of the object yourRectangle to 18_0_50, and ignores the *this value returned.
The statement in Line 16 outputs the value of yourRectangle.
Notice the output in Line 15.
The value printed for  is 0_0_00, which was stored when the object was declared in Line 8.
Next, the statement in Line 18 sets the  of yourRectangle, and the statement in Line 20 outputs the value of yourRectangle.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
To make a function be a friend to a class, the reserved word friend precedes the function prototype (in the class definition).
The word friend appears only in the function prototype in the class definition, not in the definition of the friend function.
In other words, friendship is always given by the class, never taken by the function.
Consider the following statements: class classIllusFriend { friend void two(/*parameters*/);.
That is, it is a nonmember function of the class classIllusFriend.
When you write the definition of the function two, any object of type classIllusFriend, which is included in the definition as either a local variable of two or a formal parameter of two, can access its private members within the definition of the function two.
However, they are typically placed before any member function declaration.
DEFINITION OF A friend FUNCTION When writing the definition of a friend function, the name of the class and the scope resolution operator do not precede the name of the friend function in the function heading because it is not a member function of the class.
Also, recall that the word friend does not appear in the heading of the friend function's definition.
Thus, the definition of the function two in the previous class classIllusFriend is: {.
The next section illustrates the difference between a member function and a nonmember function (friend function) when we overload some of the operators for a specific class.
The following example shows how a friend function accesses the private members of a class.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
In the following definition we do not document the functions.
The complete definition of this class is available at the Web site accompanying this book.
The next two statements increase the  and of recFriendObject by 5 units.
The next statement outputs the  of the object recFriendObject using the new  and.
Note that the recFriendObject accesses its private member variables  and  and increase their values Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
If rectangleFriend is not declared as a friend function of the class rectangleType, then this statement would result in a syntax error because an object cannot directly access its private members.
The definition of the remaining functions and constructors of the class rectangleType is as given in Chapter 11.
Now consider the definition of the following function main:.
Sample Run myYard : 450_0_00 Passing object myYard to the friend function.
The statement in Line 9 outputs the of myYard.
The statement in Line 11 calls the function  (a friend function of the class rectangleType) and passes the object myYard as an actual parameter.
Notice that the function  generates the last three lines of the output.
Later in this chapter, you will learn that for a class, stream insertion and extraction operators can be overloaded only as friend functions.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
This section describes these rules.
Most operator functions can be either member functions  nonmember functions—that is, friend functions of a class.
To make an operator function be a member  nonmember function of a class, keep the following in mind: 1.
The function that overloads any of the operators (), [], arrow_operator,  = for a class must be declared as a member of the class.
Suppose that an operator op is overloaded for a class—say, opOverClass.
If the far left operand of op is an object of a different type (that is, not of type opOverClass), the function that overloads the operator op for opOverClass must be a nonmember—that is, a friend of the class opOverClass.
If the operator function that overloads the operator op for the class opOverClass is a member of the class opOverClass, then when applying op on objects of type opOverClass, the far left operand of op must be of type opOverClass.
You must follow these rules when including an operator function in a class definition.
You will see later in this chapter that functions that overload the insertion operator, <<, and the extraction operator, >>, for a class must be nonmembers—that is, friend functions of the class.
Except for certain operators noted previously, operators can be overloaded either as member functions  as nonmember functions.
The following discussion shows the difference between these two types of functions.
To facilitate our discussion of operator overloading, we will use the class rectangleType, given next.
For easy reference, we reproduce the definition of this class and the definitions of the class rectangleType { public:.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned,  duplicated, in whole  in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/ eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The class rectangleType has two private member variables:  and , both of type double.
We will add operator functions to the class rectangleType as we overload the operators.
Also, suppose that you have the following statements:.
That is, myRectangle, yourRectangle, and tempRect are objects of type rectangleType.
Cplus_plus consists of both binary and unary operators.
It also has a ternary operator, _0_:, which cannot be overloaded.
The next few sections discuss how to overload various binary and unary operators.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned,  duplicated, in whole  in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/ eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
This operator can be overloaded as either a member function of the class  as a friend function.
We will describe both ways to overload this operator.
OVERLOADING THE BINARY OPERATORS AS MEMBER FUNCTIONS Suppose that # is overloaded as a member function of the class rectangleType.
The name of the function to overload # for the class rectangleType is: operator# Because myRectangle and yourRectangle are both objects of type rectangleType, you can perform the operation: myRectangle # yourRectangle The compiler translates this expression into the following expression: This expression clearly shows that the function operator# has only one parameter, which is yourRectangle.
The object on the left of the operator# is the object that is invoking the function operator#, and the object on the right of operator# is passed as a parameter to this function.
Because operator# is a member of the class rectangleType and myRectangle is an object of type rectangleType, in the previous statement, operator# has direct access to the private members of the object myRectangle.
OPERATORS AS MEMBER FUNCTIONS This section describes the general form of the functions used to overload binary operators as member functions of a class.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
EXAMPLE 13-5 Let us  +, *, ==,  _0_= for the class rectangleType.
These operators are overloaded as member functions.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Notice that + adds the corresponding lengths  widths of the two rectangles.
The definition of the function * is as follows: rectangleType rectangleType::* (const rectangleType& rectangle) const.
Notice that * multiplies the corresponding lengths  widths of the two rectangles.
Two rectangles are equal if their lengths  widths are equal.
Therefore, the definition of the function to  the  == is: bool rectangleType::== (const rectangleType& rectangle) const {.
Two rectangles are not equal if either their lengths are not equal or their widths are not equal.
Therefore, the definition of the function to  the  _0_= is: bool rectangleType::_0_= (const rectangleType& rectangle) const {.
We leave Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook /or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
For the most part, the preceding output is self-explanatory.
However, let us look at the statements in Lines 11, 15, 19,  23.
The statement in Line 11 uses the  + to add the lengths  widths of 1  2  stores the result in 3.
The statement in Line 13 outputs the    of 3_0_) Similarly, the statement in Line 15 uses the  * to multiply the lengths  widths of 1 2  stores the result in 4.
Similarly, the statement in Line 23 uses the relational  _0_= to determine whether the dimensions of 1  3 are the same.
OVERLOADING THE BINARY OPERATORS (ARITHMETIC OR RELATIONAL) AS NONMEMBER FUNCTIONS Suppose that # represents the binary  (arithmetic or relational) that is to be overloaded as a nonmember function of the class rectangleType.
Further suppose that the following operation is to be performed: myRectangle # yourRectangle.
In this case, the expression is compiled as: Here, we see that both myRectangle and yourRectangle are passed as parameters to the function #.
The function # is not a member of the object myRectangle or the object yourRectangle and so cannot be called by either.
To  the  function # as a nonmember function of the class in the definition of the class, the reserved word friend must appear before the function heading.
Also, the function # must have a parameter for each of its two operands.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Function Prototype (to be included in the definition of the class): friend returnType #(const className&, const className&); in which # stands for the binary  to be overloaded; returnType is the type of value returned by the function; and className is the name of the class for which the is being overloaded.
Function Definition: returnType #(const className& firstObject,.
EXAMPLE 13-6 This example illustrates how to overload the operators +  == as nonmember functions of the class rectangleType.
To  the  function + as a nonmember function of the class rectangleType, its prototype in the definition of rectangleType is: friend rectangleType +(const rectangleType&, const rectangleType&); The definition of the function + is as follows:.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Recall that the private members of a class are local to the class , therefore, cannot be accessed outside of the class.
If we follow this rule, then because + is not a member of the class rectangleType, expressions such as firstRect.
However, because + is declared as a friend function of the class rectangleType, an object of type rectangleType can access its private members in the definition of +.
Also, note that in the function heading, the name of the class—that is, rectangleType— the scope resolution  are not included before the name of the function +, because the function + is not a member of the class.
To include the  function == as a nonmember function of the class rectangleType, its prototype in the definition of rectangleType is: friend bool ==(const rectangleType& , const rectangleType&); The definition of the function == is as follows: bool ==(const rectangleType& firstRect, {.
Operators If an  function is a member function of a class, then the leftmost operand of that must be an object of that class.
Therefore, the  function that overloads the insertion , <<, or the extraction , >>, for a class must be a nonmember function of that class.
Consider the expression: << myRectangle; In this expression, the far left operand of << (that is, ) is an ostream object, not an object of type rectangleType.
Because the far left operand of << is not an object of type rectangleType, the  function that overloads the insertion  for rectangleType must be a nonmember function of the class rectangleType.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook /or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The general syntax to overload the stream insertion , <<, for a class is described next.
Function Prototype (to be included in the definition of the class):.
Both parameters are reference parameters.
The first parameter—that is, — is a reference to an ostream object.
The second parameter is usually a const reference to a particular class, because (recall from Chapter 10) the most effective way to pass an object as a parameter to a class is by reference.
In this case, the formal parameter does not need to copy the member variables of the actual parameter.
The word const appears before the class name because we want to print only the member variables of the object.
That is, the function should not modify the member variables of the object.
The function return type is a reference to an ostream object.
The return type of the function to overload the  << must be a reference to an ostream object for the following reasons.
Suppose that the  << is overloaded for the class rectangleType.
This is a perfectly legal statement because both of the actual parameters are objects, not the value of the objects.
The first parameter, , is of type ostream; the second parameter, myRectangle, is of type rectangleType.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook /or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
To execute the previous statement, you must first execute the expression: << that is, the expression: After executing this expression, which outputs the value of , whatever is returned by the function  << will become the left-side parameter of the << (that is, the first parameter of the function <<) in order to output the value of object yourRectangle (see the statement in Line A).
The left-side parameter of the  << must be an object of the ostream type, so the expression: << must return the object  (not its value) to the left side of the second  << in order to output the value of yourRectangle.
Therefore, the return type of the function << must be a reference to an object of the ostream type.
The general syntax to overload the stream extraction , >>, for a class is described next.
Function Prototype (to be included in the definition of the class):.
Both parameters are reference parameters.
The first parameter—that is, isObject—is a reference to an istream object.
The second parameter is usually a reference to a particular class.
The data read will be stored in the object.
The function return type is a reference to an istream object.
For the same reasons as explained previously (when we overloaded the insertion <<), the return type of the function >> must be a reference to an istream object.
We can then successfully execute statements of the following type: cin >>  >> yourRectangle; Example 13-7 shows how the stream insertion  extraction operators are overloaded for the class rectangleType.
EXAMPLE 13-7 The definition of the class rectangleType  the definitions of the functions are: # <iostream> using namespace std;.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sample Run: In this sample run, the user input is shaded.
Line 3: :  = 23;  = 45 Line 4: Enter the length and width of a rectangle: 32 15 Line 7: :  = 32;  = 15 Line 8:  + :  = 55;  = 60 Line 9:  * :  = 736;  = 675 The statements in Lines 1 and 2 declare and initialize  and to be objects of type rectangleType.
The statement in Line 3 outputs the value of using  and the insertion.
The statement in Line 5 inputs the data into  using cin and the extraction.
The statement in Line 7 outputs the value of  using  and the insertion.
The statement in Line 8 adds the lengths and widths of  and and outputs the result.
Similarly, the  statement in Line 9 multiplies the lengths and widths of  and  and outputs the result.
The output shows that both the stream insertion and stream extraction operators were overloaded successfully.
One of the built-in operations on classes is the assignment operation.
The assignment causes a member-wise copy of the member variables of the class.
For example, the statement: = ;.
From Chapter 12, recall that the built-in assignment  works well for classes that do not have pointer member variables, but not for classes with pointer member variables.
Therefore, to avoid the shallow copy of data for classes with pointer member variables, we must explicitly overload the assignment.
Recall that to overload the assignment  = for a class, the  function = must be a member of that class.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Function Prototype (to be included in the definition of the class): const className& =(const className&); Function Definition:.
In the definition of the function =:.
There is only one formal parameter.
The formal parameter is usually a const reference to a particular class.
The function return type is a const reference to a particular class.
We now explain why the return type of the function = should be a reference of the class type.
Suppose that the assignment  = is overloaded for the class rectangleType.
That is, the object  becomes the actual parameter to the function:.
Now consider the statement: =  = tempRect;.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
The value returned by the expression: will become the parameter to the function = in order to assign a value to the.
That is, it must return a reference to the object , not the value of.
For reason, the return type of the function to overload the assignment  = for a class must be a reference to the class type.
Now consider the statement:.
Here, we are trying to copy the value of  into ; that is, statement is a self-assignment.
One reason why we must prevent such assignments is because they waste computer time.
First, however, we explain how the body of the assignment  prevents such assignments.
As noted above, the body of the function = does prevent assignments, such as the one given in Line B.
Let us see how.
Consider the if statement in the body of the  function =: if ( _0_= &rightObject) //avoid self-assignment.
Because the function = is invoked by the object , the pointer in the body of the function = refers to the object.
Furthermore, because  is also a parameter of the function =, Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Therefore, in the expression: _0_= &rightObject and &rightObject both mean the address of.
Thus, the expression will evaluate to false and the body of the if statement will be skipped.
This note illustrates another reason why the body of the  function must prevent self-assignments.
Let us consider the following class: class arrayClass { public: const arrayClass& = (const& arrayClass);.
The class arrayClass has a pointer member variable, list, which is used to create an array to store integers.
Suppose that the definition of the function to overload the assignment  for the class arrayClass is written without the if statement, as follows: const arrayClass & arrayClass::=.
When  statement executes in the body of the function =: 1.
The statement in Line 1 destroys , that is, _0_, so the array holding the numbers no longer exists.
The problem is in Line 6.
Here, the expression [] = otherList_0_[] is equivalent to the statement _0_[] = _0_[].
Because _0_[] has no valid data (it was destroyed in Line 1), the statement in Line 6 produces garbage.
It follows that the definition of the function = must prevent self-assignments.
The correct definition of = for the class arrayClass is: const arrayClass& arrayClass::=.
The following example illustrates how to overload the assignment.
EXAMPLE 13-8 Consider the following class: class cAssignmentOprOverload { public:.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The function to overload the assignment  works as follows.
The statement in Line 1 checks whether an object is copying itself.
The statement in Line 2 destroys The statements in Lines 3 and 4 copy the values of the member variables and  of otherList into the member variables  and of , respectively.
The statement in Line 5 creates the array to store the numbers.
The for loop in Line 6 copies otherList into.
The statement in Line 8 returns the address of  object, because the return type of the function = is a reference type.
The following program tests the class cAssignmentOprOverload: 1.
Sample Run: In  sample run, the user input is shaded.
Line 14: Enter 5 integers: 8 5 3 7 2 Line 19: 1: 8 5 3 7 2 Line 22: 2: 8 5 3 7 2 Line 26: 2: The  is.
Line 28: After destroying 2, 1: 8 5 3 7 2 Line 30: After destroying 2, 3: 8 5 3 7 2 The statement in Line 9 creates 1 of  10; the statements in Lines 10 and 11 create 2 and 3 of (default)  50.
The statements in Lines 15 through 17 input the data into 1, and the statement in Line 20 outputs 1.
The Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The statement in Line 23 outputs 2 (see Line 22 in the sample run, which contains the output of Lines 22 and 23).
The statement in Line 24 destroys 2.
The statement in Line 27 outputs 2, which is.
The sample run clearly shows that the destruction of 2 affects neither 1 nor 3, because 1 and 3 each have their own data.
Overloading Unary Operators The process of overloading unary operators is similar to the process of overloading binary operators.
The only difference is that in the case of binary operators, the  has two operands.
In the case of unary operators, the  has only one parameter.
Therefore, to overload a unary  for a class: 1.
If the  function is a member of the class, it has no parameters.
If the  function is a nonmember—that is, a friend function of the class—it has one parameter.
Next, we describe how to overload the increment and decrement operators.
OVERLOADING THE INCREMENT (plus_plus) AND DECREMENT (minus_minus) OPERATORS The increment  has two forms: pre-increment (plus_plusu) and post-increment (uplus_plus), in which u is a variable, say, of type.
In the case of pre-increment, plus_plusu, the value of the variable, u, is incremented by 1 before the value of u is used in an expression.
In the case of post-increment, the value of u is used in the expression before it is incremented by 1.
Overloading the Pre-Increment Operator.
Overloading the pre-increment  is quite straightforward.
In the function definition, first we increment the value of the object, and then we use the pointer  to return the object's value.
For example, suppose that we overload the pre-increment  for the class rectangleType to increment the  and width of a rectangle by 1.
Also, suppose that the  function operatorplus_plus is a member of the class rectangleType.
The  function operatorplus_plus then has no parameters and we use the pointer to return the incremented value of the object:.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Moreover, the pointer associated with myRectangle returns the incremented value of myRectangle, which in  case is ignored.
Now,  is also an object of type rectangleType, so the statement: = plus_plusmyRectangle; increments the  and width of myRectangle by 1, and the pointer  associated with myRectangle returns the incremented value of myRectangle, which is copied into.
GENERAL SYNTAX TO OVERLOAD THE PRE-INCREMENT OPERATOR plus_plus AS A MEMBER FUNCTION The general syntax to overload the pre-increment  plus_plus as a member function is described next.
Function Prototype (to be included in the definition of the class):.
The  function to overload the pre-increment  can also be a nonmember of the class rectangleType, which we describe next.
If the  function operatorplus_plus is a nonmember function of the class rectangleType, it has one parameter, which is an object of type rectangleType.
Function Prototype (to be included in the definition of the class):.
We now discuss how to overload the post-increment operator.
As in the case of the preincrement operator, we first describe the overloading of this operator as a member of a class.
Let us overload the post-increment operator for the class rectangleType.
In both cases, pre- and post-increment, the name of the operator function is the same—operatorplus_plus.
To distinguish between pre- and post-increment operator overloading, we use a dummy parameter (of type int) in the function heading of the operator function.
The dummy parameter is not used in the definition of the function.
Its only purpose is to distinguish between the pre- and post-increment versions of operatorplus_plus.
Thus, the function prototype for the post-increment operator of the class rectangleType is: rectangleType operatorplus_plus(int);.
Notice that the parameter 0 is only used to distinguish between the pre- and post-increment operator functions.
The post-increment operator first uses the value of the object in the expression and then increments the value of the object.
So the steps required to implement this function are: 1.
Save the value of the object—in, say, temp.
Increment the value of the object.
Return the value that was saved in temp.
The function definition of the post-increment operator for the class rectangleType is: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The general syntax to overload the post-increment operator plus_plus as a member function is described next.
Function Prototype (to be included in the definition of the class):.
The post-increment operator can also be overloaded as a nonmember function of the class.
In this situation, the operator function operatorplus_plus has two parameters.
The definition of the function to overload the post-increment operator for the class rectangleType as a nonmember is:.
The general syntax to overload the post-increment operator plus_plus as a nonmember function is described next.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The decrement operators can be overloaded in a similar way, the details of which are left as an exercise for you.
Let us now write the definition of the class rectangleType and show how the operator functions appear in the class definition.
Because certain operators can be overloaded as either member or nonmember functions, we give two equivalent definitions of the class rectangleType.
In the first definition, the increment, decrement, arithmetic, and relational operators are overloaded as member functions.
In the second definition, the increment, decrement, arithmetic, and relational operators are overloaded as nonmember functions.
The definition of the class rectangleType is as follows: //Definition of the class rectangleType.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Operator Overloading: Member versus Nonmember The preceding sections discussed and illustrated how to overload operators.
Certain operators must be overloaded as member functions of the class, and some must be overloaded as nonmember (friend) functions.
What about the operators that can be overloaded as either member functions or nonmember functions.
For example, the binary arithmetic  + can be overloaded as a member function or a nonmember function.
If you overload + as a member function, then the  + has direct access to the member variables of one of the objects, and you need to pass only one object as a Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
On the other hand, if you overload + as a nonmember function, then you must pass both objects as parameters.
When both objects are passed as parameters, the code may become somewhat clearer.
So, other than following the restrictions on  overloading, it is a matter of preference whether you overload + as a member or as a nonmember function.
In the remainder of this chapter, if we overload an  as a member function, we will leave it as an exercise for you to overload it as a nonmember function.
Chapter 12 described the peculiarities of classes with pointer member variables.
Now that we have discussed how to overload various operators, let us review the peculiarities of classes with pointer member variables, for the sake of completeness, and how to avoid them.
Recall that the only built-in operations on classes are assignment and member selection.
The assignment  provides a member-wise copy of the data.
That is, the member variables of an object are copied into the corresponding member variables of another object of the same type.
We have seen that this member-wise copy does not work well for classes with pointer member variables.
Other problems that may arise with classes with pointer member variables relate to deallocating dynamic memory when an object goes out of scope and passing a class object as a parameter by value.
To resolve these problems, classes with pointer member variables must: 1.
Explicitly overload the assignment 2.
Include the destructor Operator Overloading: One Final Word Next, we look at three examples that illustrate  overloading.
Before delving into these examples, you must remember the following: Suppose that an  op is overloaded for a class—say, rectangleType.
Whenever we use the  op on objects of type rectangleType, the body of the function that overloads the  op for the class rectangleType executes.
Therefore, whatever code you put in the body of the function executes.
PROGRAMMING EXAMPLE: Watch the Video clockType Chapter 10 defined a class clockType to implement the time of day in a program.
We implemented the operations to print the time, increment the time, and compare the two times for equality using functions.
This example redefines the class clockType.
It also overloads the stream insertion and extraction operators for easy input and output, relational operators for comparisons, and the increment  to increment the time by one second.
The program that uses the class clockType requires the user to input the time in the form hr:min:sec.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: clockType.
The definition of the class clockType is as follows: //Header file newClock_0_h.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Figure 13-1 shows a UML class diagram of the class clockType.
UML class diagram of the class clockType Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: clockType.
Notice that the class clockType overloads only the preincrement.
For consistency, however, the class should also overload the post-increment.
This step is left as an exercise for you.
The algorithm to increment the time by one second is as follows: a.
Return the incremented value of the object.
The definition of the function operatorplus_plus is:.
The definition of the function == is quite simple.
Therefore, the definition of the function == is: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The definition of the function <= is given next.
The first time is less than or equal to the second time if: 1.
The  of the first time are less than the  of the second time, or 2.
The  of the first time and the second time are the same, but the of the first time are less than the  of the second time, or 3.
The  and  of the first time and the second time are the same, but the  of the first time are less than or equal to the of the second time.
The definition of the function <= is: //Overload the less than or equal to.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Programming Example: clockType.
Similarly, you can use the  == and < to write the definition of the function The definitions of the functions setTime and getTime are the same as given in Chapter 10.
They are included here for the sake of completeness.
Moreover, we have modified the definition of the constructor so that it uses the function setTime to set the time.
The definitions are as follows: {.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time  subsequent rights restrictions require it.
Here, after printing the time in the previous format, we must return the ostream object.
Therefore, the definition of the function << is: //Overload the stream insertion.
The algorithm to input the time is: a.
Get the input, which is a number, and store it in the member variable.
Also check  the input is valid.
Get the next input, which is a colon, and discard it.
Get the next input, which is a number, and store it in the member variable.
Also check  the input is valid.
Get the next input, which is a colon, and discard it.
Get the next input, which is a number, and store it in the member variable.
Also check  the input is valid.
Return the istream object.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time  subsequent rights restrictions require it.
Programming Example: clockType.
The definition of the function >> is:.
Sample Run: In this sample run, the user input is shaded.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any  if subsequent rights restrictions require it.
Programming Example: Complex Numbers.
Complex Numbers A number of the form a + ib, in which 2 = -1 and a and b are real numbers, is called a complex number.
We call a the real part and b the imaginary part of a + ib.
Complex numbers can also be represented as ordered pairs (a, b).
The addition and multiplication of complex numbers are defined by the following rules: Using the ordered pair notation, these rules are written as: Cplus_plus has no built-in data type that allows us to manipulate complex numbers.
In this example, we will construct a data type, complexType, that can be used to process complex numbers.
We will overload the stream insertion and stream extraction operators for easy input and output.
We will also overload the operators + and * to perform addition and multiplication of complex numbers.
If x and y are complex numbers, we can evaluate expressions such as x + y and x * y.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any  if subsequent rights restrictions require it.
Figure 13-2 shows a UML class diagram of the class complexType.
UML class diagram of the class complexType Next, we write the definitions of the functions to implement various operations of the class complexType.
The definitions of most of these functions are straightforward.
We will discuss only the definitions of the functions to overload the stream insertion , <<, and the stream extraction , >>.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any  if subsequent rights restrictions require it.
Programming Example: Complex Numbers.
Output Output Output Output Output the the the the the left parenthesis, (.
Therefore, the definition of the function << is: ostream& <<(ostream& osObject, { osObject osObject osObject osObject osObject << << << << <<.
Next, we discuss the definition of the function to overload the stream extraction , >>.
The input is of the form: In this input, the  part of the complex number is 3, and the imaginary part is 5.
The algorithm to read this complex number is: a.
Read Read Read Read Read and and and and and discard the left parenthesis.
Programming Example: Complex Numbers.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
You can extend this data type to perform subtraction and division on complex numbers.
Next, we will define a class, called newString, and overload the assignment and relational operators.
That is, when we declare a variable of type newString, we will be able to use the assignment  to copy one string into another and relational operators to compare the two strings.
Before discussing the class newString, however, we will examine the overloading of the  [].
Recall that we have used the  [] to access the components of an array.
To access individual characters in a string of type newString, we have to overload the  [] for the class newString.
Recall that the function to overload the  [] for a class must be a member of the class.
Furthermore, because an array can be declared as constant or nonconstant, we need to overload the  [] to handle both cases.
The syntax to declare the  function [] as a member of a class for nonconstant arrays is: Type& [](int index);.
Suppose that classTest is a class that has an array member variable.
The definition of classTest to overload the  [] is: class classTest { public: Type& [](int index); Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Next, the body of the  function [] for nonconstant arrays is executed to complete the execution of the assignment statement for 1.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
A C-string is a sequence of one or more characters.
C-strings are enclosed in double quotation marks.
C-strings are null terminated.
C-strings are stored in character arrays.
The only aggregate operations allowed on C-strings are input and output.
To use other operations, the programmer needs to  the header file cstring, which contains the specifications of many functions for string manipulation.
Initially, Cplus_plus did not provide any built-in data types to handle C-strings.
More recent versions of Cplus_plus, however, provide a string class to handle C-strings and operations on C-strings.
Our objective in this example is to define our own class for C-string manipulation and, at the same time, to further illustrate operator overloading.
More specifically, we overload the assignment operator, the relational operators, and the stream insertion and extraction operators for easy input and output.
Let us call this class newString.
First, we give the definition of the class newString: //Header file myString_0_h #ifndef H_myString #define H_myString.
Programming Example: newString.
The class newString has two private member variables: one to store the C-string and one to store the length of the C-string.
Next, we give the definitions of the functions to implement the newString operations.
The implementation file includes the header file cassert because we are using the function.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: newString.
Because temp is declared to be an array of size 81, the largest string that can be stored into temp is of length 80.
The manipulator setw in  statement (that is, in the input statement) ensures that no more than 80 characters are read into temp.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Let us explain the functions that overload the conversion constructor, the assignment , and the copy constructor.
The conversion constructor is a single-parameter function that converts its argument to an object of the constructor's class.
In our case, the conversion constructor converts a string to an object of the newString type.
Note that the assignment  is explicitly overloaded only for objects of the newString type.
However, the overloaded assignment  also works if we want to store a C-string into a newString object.
Consider the declaration: newString ;.
First, the compiler automatically invokes the conversion constructor to create an object of the newString type to temporarily store the string "Hello there".
Second, the compiler invokes the overloaded assignment  to assign the temporary newString object to the object.
Hence, it is not necessary to explicitly overload the assignment  to store a C-string into an object of type newString.
Next, we write a Cplus_plus program that tests some of the operations of the class newString.
Programming Example: newString.
Sample Run: In  sample run, the user input is shaded.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due  electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right  remove additional content at any time if subsequent rights restrictions require it.
The statement in  1 outputs the values of 1, 2, and 3.
Notice that the  of 3 is  be printed between *** and ###.
Because 3 is empty, nothing is printed between *** and ###; see 1 in the sample run.
The statements in Lines 2 through 5 compare 1 and 2 and output the result.
The statement in  7 inputs a string with a length of at least 7 into 1, and the statement in  9 outputs the new  of 1.
Note that in the statement (see  10): 4 = 3 = "Birth "; Because the associativity of the assignment  is from right  left, first the statement 3 = "Birth "; executes, and then the statement 4 = 3; executes.
The statement in  11 outputs the values of 3 and 4.
The statements in Lines 15, 17, and 19 use the array subscripting  []  individually manipulate the characters of 3.
The meanings of the remaining statements are straightforward.
Function Overloading The previous section discussed  overloading.
Operator overloading provides the programmer with the same concise notation for user-defined data types as the has for built-in types.
The types of parameters used with an  determine the action take.
Similar   overloading, Cplus_plus allows the programmer  overload a function name.
Chapter 6 introduced function overloading.
For easy reference in the following discussion, let us review this concept.
Recall that a class can have more than one constructor, but all constructors of a class have the same name, which is the name of the class.
This is an example of overloading a function.
Further recall that overloading a function refers  having several functions with the same name but different parameter lists.
The parameter list determines which function will execute.
For function overloading  work, we must give the definition of each function.
The next section teaches you how  overload functions with a single code segment and leave the job of generating code for separate functions for the compiler.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due  electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right  remove additional content at any time if subsequent rights restrictions require it.
Templates | 967 Templates Templates are a very powerful feature of Cplus_plus.
They allow you  write a single code segment for a set of related functions, called a function template, and for a set of related classes, called a class template.
The syntax we use for templates is: template <class Type> declaration; in which Type is the name of a data type, built-in or user-defined, and declaration is either a function declaration or a class declaration.
In Cplus_plus, template is a reserved word.
The word class in the heading refers  any user-defined type or built-in type.
Type is referred  as a formal parameter  the template.
Function Templates In Chapter 6, when we introduced function overloading, the function larger was overloaded  find the larger of two integers, characters, floating-point numbers, or strings.
To implement the function larger, we need  write four function definitions for the data type: one for int, one for char, one for double, and one for string.
However, the body of each function is similar.
Cplus_plus simplifies the process of overloading functions in cases such as this by providing function templates.
The syntax of the function template is: template <class Type> function definition; in which Type is referred  as a formal parameter of the template.
It is used  specify the type of parameters  the function and the return type of the function and  declare variables within the function.
The statements: template <class Type> {.
In the function heading, the type of the formal parameters  and y is Type, which will be specified by the type of the actual parameters when the function is called.
The statement: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Because 5 and 6 are of type int, the data type int is substituted for Type, and the compiler generates the appropriate code.
Note that the function template  will work only for those data types for which the  >= has been defined.
If we omit the body of the function in the function template definition, the function template, as usual, is the prototype.
The following example illustrates the use of function templates.
EXAMPLE 13-9 The following program uses the function template  to determine the  of the two items.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook /or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sample Run: Line Line Line Line 1: 2: 3: 6: Larger Larger Larger Larger of of of of 5  6 = 6 A   = 5_0_6  3_0_2 = 5_0_6 Hello   = Hello Class Templates Like function templates, class templates are used to write a single code segment for a set of related classes.
For example, in Chapter 10, we defined a list as an ADT; our list element type was int.
If the list element type changes from int to, say, char, double, or string, we need to write separate classes for each element type.
For the most part, the operations on the list  the algorithms to implement those operations remain the same.
Using class , we can create a generic class listType,  the compiler can generate the appropriate source code for a specific implementation.
The syntax we use for a class template is: template <class Type> class declaration Class  are called parameterized types because, based on the parameter type, a specific class is generated.
The following statements define listType to be a class template: template <class elemType> class listType { public: bool isEmpty() const; //Function to determine whether the list is empty.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook /or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
This definition of the class template  is a generic definition  includes only the basic operations on a list.
To derive a specific list from this list  to add or rewrite the operations, we declare the array containing the list elements  the  of the list as protected.
Next, we describe a specific list.
Suppose that you want to create a list to process integer data.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook /or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Templates | 971 In the statements in Lines 1  2, <int>  <newString> are referred to as template instantiations or instantiations of the class template <elemType>, in which elemType is the class parameter in the template header.
A template instantiation can be created with either a built-in or user-defined type.
Thus, when giving the definitions of the function members of a class template, we must follow the definition of the function template.
For example, the definition of the member insert of the class  is: template <class elemType> {.
The statement in Line 1 declares intList to be a list of 100 components.
When the compiler generates the code for intList, it replaces the word elemType with int in the definition of the class.
The template parameter in the definitions of the member functions (for example, elemType in the definition of insert) of the class is also replaced by int.
HEADER FILE AND IMPLEMENTATION FILE OF A CLASS TEMPLATE Until now, we have placed the definition of the class (in the header file)  the definitions of the member functions (in the implementation file) in separate files.
The object code was generated from the implementation file  linked with the user code.
However, this mechanism of separating the class definition  the definitions of the member functions does not work with class.
Passing parameters to a function has an effect at run time, whereas passing a parameter to a class template has an effect at compile time.
Because the actual parameter to a class is specified in the user code  because the compiler cannot instantiate a function template without the actual parameter to the template, we can no longer compile the implementation file independently of the user code.
This problem has several possible solutions.
We could put the class definition and the definitions of the function  directly in the client code, or we could put the class definition and the definitions of the function  together in the same header file.
Another alternative is to put the class definition and the definitions of the functions in separate files (as usual) but include a directive to the implementation file at the end of the header file.
In either case, the function definitions and the client code are compiled together.
For illustrative purposes, we will put the class definition and the function definitions in the same header file.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
However, these classes, as designed in Chapter 12, process only those lists whose elements are of type int.
Now that we have discussed how to use class templates to create a generic code, in this section, we redesign these classes so that they can be used to process any type of list.
Moreover, in this chapter, we discussed how to overload the assignment operator.
Therefore, in addition to the operations discussed in Chapter 12, we also overload the assignment operator for the class because it has a pointer member variable.
The following class template defines the abstract class  as an ADT.
The documentation of these functions is similar to ones given in Chapter 12.
The source code file at the Web site accompanying this template <class elemType> class { public:.
Templates | 973 The definitions of the functions to implement the operations of the class  are similar to the ones given in Chapter 12.
Here the functions to implement these operations are function templates.
For example, the definitions of the functions print, isItemAtEqual, removeAt, retrieveAt, the constructor, and the destructor are: template <class elemType> void <elemType>::print().
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Next, because we are overloading the assignment for the class , we give the definition of the function template to overload the assignment.
Templates | 975 We leave it as an exercise for you to provide the definitions of the remaining function templates for the class.
So its objects cannot be instantiated.
Next we describe the nonabstract class unorderedArrayListType derived from the class.
As in the case of the class , the definitions of the member functions of the class unorderedArrayListType is similar to ones given in Chapter 12.
For example, the definitions of the functions insertEnd, seqSearch, replaceAt, and remove, and constructor are as follows: template <class > void unorderedArrayListType<>::insertEnd {.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
We leave it as an exercise for you to provide the definitions of the remaining function templates for the class unorderedArrayListType.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
List 3: Enter 5 strings: hello sunny warm winter summer Line 8: : hello sunny warm winter summer Line 11: Enter the string to be deleted: hello Line 15: After removing hello : sunny warm winter summer Line 18: Enter the search item: winter Line 22: winter  in.
The preceding program works as follows.
The statement in Line 1 declares to be an object of the type.
The member variable  of is an array of 25 components and the component type is string.
The statement in Line 2 declares the string variable.
The statement in Line 3 prompts the user to enter 5 strings.
The statement in Line 5 gets the next string from the input stream.
The statement in Line 6 uses the member function insertEnd of to store the string into.
The statement in Line 9 uses the member function print of  to output the elements of.
The statement in Line 11 prompts the user to enter the string to be deleted from , and the statement in Line 12 gets the string to be deleted from the input stream.
The statement in Line 14 uses the member function remove of  to remove the string from.
The statement in Line 16 outputs the modified.
The statements in Lines 18 through 24 tests the function seqSearch.
The Web site accompanying this book contains additional programs illustrating how to use the class template  to create lists of double elements and clockType objects.
Just as we can derive the class template , from the abstact class template , to manipulate unordered lists, we can also derive the class template orderedArrayListType to manipulate ordered lists.
QUICK REVIEW 1.
An operator that has different meanings with different data types is said to be overloaded.
In Cplus_plus, >> is used as a stream extraction operator and as a right shift operator.
Similarly, << is used as a stream insertion operator and as a left shift operator.
Both are examples of operator overloading.
Any function that overloads an operator is called an operator function.
The syntax of the heading of the operator function is: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Quick Review | 5.
Operator functions are value-returning functions.
Except for the assignment operator and the member selection operator, to use an operator on class objects, that operator must be overloaded.
The assignment operator performs a default member-wise copy.
For classes with pointer member variables, the assignment operator must be explicitly overloaded.
Operator overloading provides the same concise notation for user-defined data types as is available for built-in data types.
When an operator is overloaded, its precedence cannot be changed, its associativity cannot be changed, default parameters cannot be used, the number of parameters that the operator takes cannot be changed, and the way in which an operator works with built-in data types remains the same.
It is not possible to create new.
Only existing  can be overloaded.
The  that cannot be overloaded are _0_, _0_*, ::, _0_:, and sizeof.
The pointer this refers to the object as a whole.
The operator functions that overload the  (), [], arrow_operator,  = for a class must be members of that class.
A friend function is a nonmember of a class.
The heading of the prototype of a friend function is preceded by the word friend.
In Cplus_plus, friend is a reserved word.
If an operator function is a member of a class, the far left operand of the operator must be a class object ( a reference to a class object) of that operator's class.
The binary operator function as a member of a class has only one parameter; as a nonmember of a class, it has two parameters.
The operator functions that overload the stream insertion operator, <<, and the stream extraction operator, >>, for a class must be friend functions of that class.
To overload the pre-increment (plus_plus) operator for a class if the operator function is a member of that class, it must have no parameters.
Similarly, to overload the pre-decrement (minus_minus) operator for a class if the operator function is a member of that class, it must have no parameters.
To overload the post-increment (plus_plus) operator for a class if the operator function is a member of that class, it must have one parameter, of type int.
The user does not specify any value for the parameter.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned,  duplicated, in whole  in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/ eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 13: Overloading and Templates The dummy parameter in the function heading helps the compiler generate the correct code.
The post-decrement operator has similar conventions.
A conversion constructor is a single-parameter function.
A conversion constructor converts its argument to an object of the constructor's class.
The compiler implicitly calls such constructors.
Classes with pointer member variables must overload the assignment operator and include both the copy constructor and the destructor.
In Cplus_plus, template is a reserved word.
Using templates, you can write a single code segment for a set of related functions—called the function template.
Using templates, you can write a single code segment for a set of related classes—called the class template.
The syntax of a template is: template <class Type> declaration; 32.
The word class in the heading refers to any user-defined data type built-in data type.
Class  are called parameterized types.
In a class template, the parameter Type specifies how a generic class template is to be customized to form a specific template class.
The parameter Type is mentioned in every class header and member function definition.
Suppose  is a class template, and func is a member function of The heading of the function definition of func is: template <class Type> 36.
Suppose  is a class template, which can take int as a parameter.
The statement: <int> x; declares x to be an object of type , and the type passed to the class is int.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned,  duplicated, in whole  in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/ eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Mark the following statements as true  false.
The precedence of an operator cannot be changed, but its associativity f.
A friend function of a class is a nonmember function of the class, so it g.
When writing the definition of a friend function, the keyword i.
Every instance of an overloaded function has the same number of j.
It is not necessary to overload relational operators for classes that have k.
The function heading of the operator function to overload the preincrement operator (plus_plus) and the post-increment operator (plus_plus) is the l.
What are the two things that you need to overload an operator for a Within the definition of an operator function, how do you refer to the What is the difference between the two statements return this; and What is the difference between a friend function of a class and a member a.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 13: Overloading and Templates Write the statement that includes a friend function named before in the class dateType that takes as parameters two objects of type dateType and returns true if the date represented by the first object comes before the date represented by the second object; otherwise, the function returns false.
Write the definition of the function you defined in part a.
Suppose that the operator << is to be overloaded for a user-defined class Suppose that the binary operator + is overloaded as a member function for a class strange.
How many parameters does the function operator+ a.
Write a statement that shows the declaration in the class strange to overload the  =.
Write a statement that shows the declaration in the class strange to overload the binary  + as a member function.
Write a statement that shows the declaration in the class strange to overload the  == as a member function.
Write a statement that shows the declaration in the class strange to overload the post-increment  plus_plus as a member function.
Write a statement that shows the declaration in the class strange to overload the binary  + as a friend function.
Write a statement that shows the declaration in the class strange to overload the  == as a friend function.
Write a statement that shows the declaration in the class strange to overload the post-increment  plus_plus as a friend function.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
In a class, why do you include the function that overloads the stream What is the purpose of a dummy parameter in a function that overloads the What type of value should be returned by a function that overloads a a.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The conjugate of a + ib is a – ib, and the pﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃﬃ absolute value of a + ib is a2 þ b2.
Extend the definition of the class complexType of the Programming Example: Complex Numbers by overloading the operators ~ and.
Also, When should a class overload the assignment operator and define the copy What are the three things that you must do for classes with pointer member template <class type> class {.
Write a statement that declares sObj to be an object of type such that the private member variables a and b are of type int.
Write a statement that shows the declaration in the class  to overload the  == as a member function.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Write the definition of the function == for the class , which is overloaded as a member function.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
For example, if 1 is "Hello " and 2 is "there", the statement: 3 = 1 + 2; b.
Suppose that 1 is "Hello " and 2 is "there".
Then, the statement: 1 += 2; should assign "Hello there" to 1, in which 1 and 2 are PROGRAMMING EXERCISES 1.
This chapter uses the class rectangleType to illustate how to overload the +, *, ==, _0_=, >>, and <<.
In this exercise, first redefine the class rectangleType by declaring the instance variables as protected and then overload additional  as defined in parts a to c.
Overload the pre-  post-increment  decrement  to increment  decrement, respectively, the length  width of a rectangle by one unit.
If the resulting dimensions are not positive, output an appropriate message do not perform the operation.
Redefine the functions to overload the relational by considering the areas of rectangles as follows: Two rectangles are the same, if they have the same area; otherwise, the rectangles are not the same.
Similary, rectangle yard1 is greater than rectangle yard2 if the area of yard1 is greater than the area of yard2.
Overload the remaining relational  using similar definitions.
Write the definitions of the functions to overload the  defined in parts a to c.
Write a test program that tests various operations on the class rectangleType.
Redo Programming Exercise 1 by overloading the  as nonmembers of the class rectangleType.
Write a test program that tests various operations on the class rectangleType.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook /or eChapter().
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 11 defined the class boxType by extending the definition of the class rectangleType.
In this exercise, derive the class boxType from the class rectangleType, defined in Exercise 1, add the functions to overload the  +, -, *, ==, _0_=, <=, <, >=, >,  pre-  post-increment  decrement  as members of the class boxType.
Overload the relational  by considering the volume of the boxes.
For example, two boxes are the same if they have the same volume.
Write the definitions of the functions of the class boxType as defined in part a.
Write a test program that tests various operations on the class rectangleType.
Redo Programming Exercise 3 by overloading the  as nonmembers of the class boxType.
Write a test program that tests various operations on the class boxType.
Extend the definition of the class clockType by overloading the post-increment  function as a member of the class clockType.
Write the definition of the function to overload the post-increment for the class clockType as defined in part a.
Rewrite the definition of the class clockType so that these  are overloaded as nonmember functions.
Also, overload the post-increment  for the class clockType as a nonmember.
Write the definitions of the member functions of the class clockType as designed in part a.
Write a test program that tests various operations on the class as designed in parts a  b.
Extend the definition of the class complexType so that it performs the subtraction  division operations.
Overload the  subtraction  division for this class as member functions.
If (a, b)  (c,  ) are complex numbers: (a, b) - (c,  ) = (a - c, b -  ).
If (c,  ) is nonzero: (a, b) / (c, ) = ((ac + bd ) / (c2 +  2), (-ad + bc) / (c2 +  2)).
Write the definitions of the functions to overload the  -  / as defined in part a.
Write a test program that tests various operations on the class complexType.
Format your answer with two decimal places.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook /or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Write the definitions of the member functions of the class complexType as designed in part a.
Write a test program that tests various operations on the class complexType as designed in parts a  b.
Format your answer with two decimal places.
Extend the definition of the class newString as follows: Overload the  +  += to perform the string concatenation operations.
Add the function length to return the length of the string.
Write the definition of the function to implement the operations defined in part.
Write  test program to test various operations on the newString objects.
Rational fractions are of the form  / b, in which   b are integers b 6¼ 0.
In this exercise, by "fractions" we mean rational fractions.
Suppose / b   /  are fractions.
Arithmetic operations on fractions are defined by the following rules: i.
For example,  / b <  /  if  < bc.
Design  class—say, fractionType—that performs the arithmetic relational operations on fractions.
Overload the arithmetic  relational so that the appropriate symbols can be used to perform the operation.
Also, overload the stream insertion  stream extraction for easy input  output.
Write  Cplus_plus program that, using the class fractionType, performs operations on fractions.
Among other things, test the following: Suppose x, y,  z are objects of type fractionType.
If the input is 2/3, the statement: cin >> x; Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook /or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Your answer need not be in the lowest terms.
Recall that in Cplus_plus, there is no check on an array index out of bounds.
However, during program execution, an array index out of bounds can cause serious problems.
Also, in Cplus_plus, the array index starts at 0.
Design  implement the class  that solves the array index out of bounds problem  also allows the user to begin the array index starting at any integer, positive or negative.
Every object of type  is an array of type int.
During execution, when accessing an array component, if the index is out of bounds, the program must terminate with an appropriate error message.
Consider the following statements:.
The statement in Line 1 declares list to be an array of 5 components, the component type is int,  the components are: list[0], list[1], _0__0__0_, list[4]; the statement in Line 2 declares myList to be an array of 11 components, the component type is int,  the components are: myList[2], myList[3], _0__0__0_, myList[12]; the statement in Line 3 declares yourList to be an array of 14 components, the component type is int,  the components are: yourList[-5], yourList[-4], _0__0__0_, yourList[0], _0__0__0_, yourList[8].
Write  program to test the class.
Programming Exercise 11 processes only int arrays.
Redesign the class using class templates so that the class can be used in any application that requires arrays to process data.
Design  class to perform various matrix operations.
Therefore, every element of matrix has  row position   column position.
If  is  matrix of five rows  six columns, we say that the matrix  is of the size 5  6 sometimes denote it as 56.
Clearly,  convenient place to store  matrix is in  two-dimensional array.
Two matrices can be added  subtracted if they have the same size.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook /or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The sum  difference of    are given by: þ  ¼ ½aij þ bij    ¼ ½aij  bij  The multiplication of    ( * ) is defined only if the number of columns of  is the same as the number of rows of.
If  is of the size m  n   is of the size n  t, then  * = [cik] is of the size m  t the element cik is given by the formula: cik ¼ ai1 b1k þ ai2 b2k þ    þ ain bnk 14.
Design  implement  class matrixType that can store  matrix of any size.
Overload the operators +, -,  * to perform the addition, subtraction, multiplication operations, respectively,  overload the operator << to output matrix.
Also, write  test program to test various operations on the matrices.
In Programming Exercise 4 in Chapter 10, we defined  class romanType to implement Roman numbers in  program.
In that exercise, we also implemented  function, romanToPositiveInteger, to convert  Roman number into its equivalent positive integer.
Modify the definition of the class romanType so that the member variables are declared as protected.
Use the class newString, as designed in Programming Exercise 9, to manipulate strings.
Furthermore, overload the stream insertion and stream extraction operators for easy input and output.
The stream insertion operator outputs the Roman number in the Roman format.
Also, include  member function, positiveIntegerToRoman, that converts  positive integer to an equivalent Roman number format.
Write the definition of the member function positiveIntegerToRoman.
For simplicity, we assume that only the letter I can appear in front of another letter and that it appears only in front of the letters V and X.
For example, 4 is represented as IV, 9 is represented as IX, 39 is represented as XXXIX, and 49 is represented as XXXXIX.
Also, 40 will be represented as XXXX, 190 will be represented as CLXXXX, and so on.
Derive  class extRomanType from the class romanType to do the following: In the class extRomanType, overload the arithmetic operators +, -, *, and / so that arithmetic operations can be performed on Roman numbers.
Also, overload the pre- and post-increment and decrement operators as member functions of the class extRomanType.
To add (subtract, multiply, or divide) Roman numbers, add (subtract, multiply, or divide, respectively) their positive integer representations and Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
For subtraction, if the first number is smaller than the second number, output a message saying that, "Because the first number is smaller than the second, the numbers cannot be subtracted".
Similarly, for division, the numerator must be larger than the denominator.
Use similar conventions for the increment and decrement operators.
Write the definitions of the functions to overload the operators described in part b.
Write a program to test your class.
Consider the class dateType given in Chapter 11.
In this class, add the functions to overload the increment and decrement operators to increase the date by a day and decrease the date by a day, respectively; relational operators to compare two dates; and stream operators for easy input and Also write a program to test your class.
Programming Exercise 16, Chapter 10, describes how to design the class lineType to implement a line.
Redo this programming exercise so that the class lineType: a.
Chapter 13: Overloading and Templates Overloads the stream insertion , <<, for easy output.
Overloads the stream extraction , >>, for easy intput.
Overloads the unary  +, as a member function, so that it returns true if a line is vertical; false otherwise.
Overloads the unary  -, as a member function, so that it returns true if a line is horizontal; false otherwise.
Overloads the  ==, as a member function, so that it returns true if two lines are equal; false otherwise.
Overloads the  ||, as a member function, so that it returns true if two lines are parallel; false otherwise.
Overloads the  &&, as a member function, so that it returns true if two lines are perpendicular; false otherwise.
Write a program to test your class.
Consider the classes class cashRegister and dispenserType given in the Programming Example "Juice Machine" in Chapter 10.
In the class class cashRegister, add the functions to overload the binary operators + and – to add and subtract an amount in a cash register; the relational operators to compare the amount in two cash registers; and the stream insertion  for easy output.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
In this class, add the functions to overload the increment and decrement operators to increment and decrement the number of items by one, respectively, and the stream insertion for easy output.
Write a program to test the classes designed in parts a and b.
The company invests only in the stock market.
At the end of each trading day, the company would like to generate and post the listing of its stocks so that investors can see how their holdings performed that day.
We assume that the company invests in, say, 10 different stocks.
The desired output is to produce two listings, one sorted by stock symbol and another sorted by percent gain from highest to lowest.
The input data is provided in a file in the following format: symbol openingPrice closingPrice todayHigh todayLow prevClose volume For example, the sample data is: MSMT 112_0_50 115_0_75 116_0_50 111_0_75 113_0_50 6723823 CBA 67_0_50 75_0_50 78_0_75 67_0_50 65_0_75 378233.
The first line indicates that the stock symbol is MSMT, today's opening price was 112_0_50, the closing price was 115_0_75, today's high price was 116_0_50, today's low price was 111_0_75, yesterday's closing price was 113_0_50, and the number of shares currently being held is 6723823.
The listing sorted by stock symbols must be of the following form: ********* First Investor's Heaven ********** ********* Financial Report ********** Stock Today Previous Percent Symbol Open Close High Low Close Gain minus_minusminus_minusminus_minus minus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minus minus_minusminus_minusminus_minusABC 123_0_45 130_0_95 132_0_00 125_0_00 120_0_50 8_0_67% AOLK 80_0_00 75_0_00 82_0_00 74_0_00 83_0_00 -9_0_64% CSCO 100_0_00 102_0_00 105_0_00 98_0_00 101_0_00 0_0_99% IBD 68_0_00 71_0_00 72_0_00 67_0_00 75_0_00 -5_0_33% MSET 120_0_00 140_0_00 145_0_00 140_0_00 115_0_00 21_0_74% Closing Assets: $9628300_0_00 -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-* Volume minus_minusminus_minus-10000 5000 25000 15000 30920 Develop this programming exercise in two steps.
In the first step (part a), design and implement a stock object.
In the second step (part b), design and implement an object to maintain a list of stocks.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 13: Overloading and Templates (Stock Object) Design and implement the stock object.
Call the class that captures the various characteristics of a stock object stockType.
The main components of a stock are the stock symbol, stock price, and number of shares.
Moreover, we need to output the opening price, closing price, high price, low price, previous price, and the percent gain/loss for the day.
These are also all the characteristics of a stock.
Therefore, the stock object should store all this information.
Perform the following operations on each stock object: i.
Set the stock information.
Print the stock information.
Show the different prices.
Calculate and print the percent gain/loss.
Show the number of shares.
The natural ordering of the stock list is by stock symbol.
Overload the relational operators to compare two stock objects by their symbols.
Overload the insertion operator, <<, for easy output.
Because the data is stored in a file, overload the stream extraction operator, >>, for easy input.
For example, suppose infile is an ifstream object and the input file was opened using the object infile.
Further suppose that myStock is a stock object.
Then, the statement: infile >> myStock; b.
Let us call the class to implement a list of stock objects stockListType.
The class stockListType must be derived from the class listType, which you designed and implemented in the previous exercise.
However, the class stockListType is a very specific class, designed to create a list of stock objects.
Therefore, the class stockListType is no longer a template.
Add and/or overwrite the operations of the class listType to implement the necessary operations on a stock list.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Therefore, these members can be directly accessed in the class stockListType.
Because the company also requires you to produce the list ordered by the percent gain/loss, you need to sort the stock list by this component.
However, you are not to physically sort the list by the component percent gain/loss.
Instead, you will provide a logical ordering with respect to this component.
To do so, add a member variable, an array, to hold the indices of the stock list ordered by the component percent gain/loss.
Call this array sortIndicesGainLoss.
When printing the list ordered by the component percent gain/loss, use the array sortIndicesGainLoss to print the list.
The elements of the array sortIndicesGainLoss will tell which component of the stock list to print next.
Write a program that uses these two classes to automate the company's analysis of stock data.
Write the definitions of the member functions of the classes arrayListType and unorderedArrayListType that are not given in this chapter.
Also, write a program to test your function.
Write the definition of the class template orderedArrayListType, derived from the class arrayListType, to implement an ordered list.
As in Chapter 12, add the function insert to this class.
Provide the definitions of the nonabstract functions.
Also, write a program to test your class.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Explore stack unwinding Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
For example, division by zero is an exception.
Similarly, trying to open an input file that does not exist is an exception, as is an array index that goes out of bounds.
Until now, we have dealt with certain exceptions by using either an if statement or the assert function.
For instance, in Examples 5-3 and 5-4, before dividing sum by counter or count, we checked whether counter or count was nonzero.
Similarly, in the Programming Example newString (Chapter 13), we used the assert function to determine whether the array index is within bounds.
On the other hand, there were places where we simply ignored the exception.
For instance, while determining a substring in a string (Chapter 7), we never checked whether the starting position of the substring was within range.
Also, we did not handle the array index out-of-bounds exception.
However, in all of these cases, if exceptions occurred during program execution, either we included code to terminate the program or the program terminated with an appropriate error message.
For instance, if we opened an input file in the function main and the input file did not exist, we terminated the function main, so the program was terminated.
There are situations when an exception occurs, but you don't want the program to simply ignore the exception and terminate.
For example, a program that monitors stock performance should not automatically sell if the account balance goes below a certain level.
It should inform the stockholder and request an appropriate action.
Similarly, a program that monitors a patient's heartbeat cannot be terminated if the blood pressure goes very high.
A program that monitors a satellite in space cannot be terminated if there is a temporary power failure in some section of the satellite.
The code to handle exceptions depends on the type of application you develop.
One common way to provide exception-handling code is to add exception-handling code at the point where an error can occur.
This technique allows the programmer reading the code to see the exception-handling code together with the actual code and to determine whether the error-checking code is properly implemented.
The disadvantage of this approach is that the program can become cluttered with exception-handling code, which can make understanding and maintaining the program difficult.
This can distract the programmer from ensuring that the program functions correctly.
Handling Exceptions within a Program In Chapter 3, we noted that if you try to input invalid data into a variable, the input stream enters the fail state, so an exception occurs.
This occurs, for example, if you try to input a letter into an int variable.
Chapter 3 also showed how to clear and restore the input stream.
Chapter 4 introduced the assert function and explained how to use it to avoid certain unforeseeable errors, such as division by zero.
Even though the function assert can check whether an expression meets the required condition(s), if the conditions are not met, it terminates the program.
As indicated in the previous section, situations occur in which, if something goes wrong, the program should not be simply terminated.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Handling Exceptions within a Program | 999 This section discusses how to handle exceptions.
However, first we offer some examples that show what can happen if an exception is not handled.
We also review some of the ways to handle exceptions.
The program in Example 14-1 shows what happens when division by zero occurs and the problem is not addressed.
Sample Run 1: 2: Enter the dividend: 12 5: Enter the divisor: 5 9:  = 2 Sample Run 2: 2: Enter the dividend: 24 5: Enter the divisor: 0 CPP_Proj1_0_exe has encountered a problem and needs to close.
We are sorry for the inconvenience.
In Sample Run 1, the value of divisor is nonzero, so no exception occurs.
The program calculates and outputs the  and terminates normally.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The statement in  8 divides dividend by the divisor.
However, the program does not check whether divisor is 0 before dividing dividend by divisor.
So the program crashes with the message shown.
Notice that the error message is platform independent, that is, IDE dependent.
Some IDEs might not give this error message and might simply hang.
Next, consider Example 14-2.
This is the same program as in Example 14-1, except that in  8, the program checks whether divisor is zero.
Sample Run 1: 2: Enter the dividend: 12 5: Enter the : 5 10:  = 2 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Handling Exceptions within a Program.
In Sample Run 1, the value of  is nonzero, so no exception occurs.
The program calculates and outputs the  and terminates normally.
In Sample Run 2, the value entered for  is 0.
In  8, the program checks whether  is 0.
Because  is 0, the expression in the if statement fails, so the else part executes, which outputs the third line of the sample run.
The program in Example 14-3 uses the function assert to determine whether the  is zero.
If the  is zero, the function assert terminates the program with an error message.
EXAMPLE 14-3 // Division by zero and the assert function.
Sample Run 1: 2: Enter the dividend: 26 5: Enter the : 7 10:  = 3 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The program calculates and outputs the  and terminates normally.
In Sample Run 2, the value entered for  is 0.
In  8, the function assert checks whether  is nonzero.
Because  is 0, the expression in the assert statement evaluates to false, and the function assert terminates the program with the error message shown in the third line of the output.
Cplus_plus Mechanisms of Exception Handling Examples 14-1 through 14-3 show what happens when an exception occurs in a program and is not processed.
This section describes how to  the necessary code to handle exceptions within a program.
The try block also contains statements that should not be executed if an exception occurs.
The try block is followed by one or more catch blocks.
A catch block specifies the type of exception it can catch and contains an exception handler.
The general syntax of the try/catch block is: try {.
Handling Exceptions within a Program.
Usually, before executing such a statement, we check whether certain conditions are met.
For example, before performing the division, we check whether the  is nonzero.
If the conditions are not met, we typically generate an exception, which in Cplus_plus terminology is called throwing an exception.
This is typically done using the throw statement, which we will explain shortly.
We will show what is typically thrown to generate an exception.
Let us now note the following about try/catch blocks.
If no exception is thrown in a try block, all catch blocks associated with that try block are ignored and program execution resumes after the last catch block.
If an exception is thrown in a try block, the remaining statements in that try block are ignored.
The program searches the catch blocks in the order they appear after the try block and looks for an appropriate exception handler.
If the type of thrown exception matches the parameter type in one of the catch blocks, the code of that catch block executes, and the remaining catch blocks after this catch block are ignored.
The last catch block that has an ellipses (three dots) is designed to catch any type of exception.
Consider the following catch block:.
In this catch block:.
The identifier x acts as a parameter.
In fact, it is called a catch block parameter.
The data type int specifies that this catch block can catch an exception of type int.
A catch block can have at most one catch block parameter.
Essentially, the catch block parameter becomes a placeholder for the value thrown.
In this case, x becomes a placeholder for any thrown value that is of type int.
In other words, if the thrown value is caught by this catch block, then the thrown value is stored in the catch block parameter.
This way, if the exception-handling code wants to do something with that value, it can be accessed via the catch block parameter.
Suppose in a catch block heading only the data type is specified, that is, there is no catch block parameter.
The thrown value then may not be accessible in the catch block exception-handling code.
THROWING AN EXCEPTION In order for an exception to occur in a try block and be caught by a catch block, the exception must be thrown in the try block.
The general syntax to throw an exception is: throw expression; Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The object being thrown can be either a specific object or an anonymous object.
It follows that in Cplus_plus, an exception is a value.
In Cplus_plus, throw is a reserved word.
Example 14-4 illustrates how to use a throw statement.
EXAMPLE 14-4 Suppose we have the following declaration: int  = 5; string  = "Something is wrong_0__0__0_";.
Effect throw throw throw throw The constant value 4 is thrown.
The value of the variable x is thrown.
The object  is thrown.
An anonymous string object with.
ORDER OF catch BLOCKS A catch block can catch either all exceptions of a specific type or all types of exceptions.
The heading of a catch block specifies the type of exception it handles.
As noted previously, the catch block that has an ellipses (three dots) is designed to catch any type of exception.
Therefore, if we put this catch block first, then this catch block can catch all types of exceptions.
Suppose that an exception occurs in a try block and is caught by a catch block.
The remaining catch blocks associated with that try block are then ignored.
Therefore, you should be careful about the order in which you list catch blocks following a try block.
For example, consider the following sequence of try/catch blocks: try {.
Handling Exceptions within a Program.
Because the catch block in Line 2 can catch exceptions of all types, the catch block in Line 3 cannot be reached.
For this sequence of try/catch blocks, some compilers might, in fact, give a syntax error (check your compiler's documentation).
In a sequence of try/catch blocks, if the catch block with an ellipses (in the heading) is needed, then it should be the last catch block of that sequence.
USING try/catch BLOCKS IN A PROGRAM Next, we provide examples that illustrate how a try/catch block might appear in a program.
A common error that might occur when performing numeric calculations is division by zero with integer values.
If, during program execution, division by zero occurs with integer values and is not addressed by the program, the program might terminate with an error message or might simply hang.
Example 14-5 shows how to handle division by zero exceptions.
EXAMPLE 14-5 This example illustrates how to catch and handle division by zero exceptions.
It also shows how a try/catch block might appear in a program.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sample Run 1: In this sample run, the user input is shaded.
This program works as follows.
The statement in  1 declares the int variables dividend, , and.
The try block starts at  2.
The statement in  3 prompts the user to enter the value for the dividend; the statement in  4 stores this number in the variable dividend.
The statement in  6 prompts the user to enter the value for the , and the statement in  7 stores this number in the variable.
The statement in 9 checks whether the value of  is 0.
If the value of  is 0, the statement in  10 throws the constant value 0.
The statement in  11 calculates the and stores it in.
The statement in  12 outputs the value of.
The catch block starts in  13 and catches an exception of type int.
In Sample Run 1, the program does not throw any exception.
In Sample Run 2, the entered value of  is 0.
Therefore, the statement in  10 throws 0, which is caught  the catch block starting in  13.
The statement in 14 outputs the appropriate message.
The program in Example 14-6 is the same as the program in Example 14-5, except that the throw statement throws the value of the variable.
Sample Run 1: In this sample run, the user input is shaded.
The program in Example 14-7 illustrates how to handle division  zero, division  a negative integer, and input failure exceptions.
It also shows how to throw and catch an object.
This program is similar to the programs in Examples 14-5 and 14-6.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Handling Exceptions within a Program.
Sample Run 3: In this sample run, the user input is shaded.
In this program, the statements in Lines 1 and 2 declare the variables used in the program.
Notice that the string object inpStr is also initialized.
The statements in Lines 4 through 9 input the data into the variables dividend and The statement in  10 checks whether  is 0, the statement in 12 checks whether  is negative, and the statement in  14 checks whether the standard input stream is in the fail state.
The statement in  11 throws the variable , the statement in  13 throws an anonymous string object with the string "Negative _0_", and the statement in 15 throws the object inpStr.
The catch block in  18 catches an exception of type int, and the catch block in 20 catches an exception of type string.
If the exception is thrown by the statement in 11, it is caught and processed by the catch block in  18.
If the exception is thrown by the statements in Lines 13 or 15, it is caught and processed by the catch block in  20.
In Sample Run 1, the program does not encounter any problems.
In Sample Run 2, division by a negative number occurs.
In Sample Run 3, the standard input stream enters the fail state.
Using Cplus_plus Exception Classes Cplus_plus provides support to handle exceptions via a hierarchy of classes.
The class exception is the base of the classes designed to handle exceptions.
The function what returns a string containing an Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter().
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
All derived classes of the class exception override the function what to issue their own error messages.
Two classes are immediately derived from the class exception: logic_error and runtime_error.
Both of these classes are defined in the header file stdexcept.
To deal with logical errors in a program, such as a string subscript out of range or an invalid argument to a function call, several classes are derived from the class logic_error.
For example, the class invalid_argument is designed to deal with illegal arguments used in a function call.
The class out_of_range deals with the string subscript out of range error.
If a length greater than the maximum allowed for a string object is used, the class length_error deals with this error.
For example, recall that every string object has a maximum length (see Chapter 7).
If a length larger then the maximum length allowed for a string is used, then the length_error exception is generated.
If the operator new cannot allocate memory space, this operator throws a bad_alloc exception.
The class runtime_error is designed to deal with errors that can be detected only during program execution.
For example, to deal with arithmetic overflow and underflow exceptions, the classes overflow_error and underflow_error are derived from the class runtime_error.
Examples 14-8 and 14-9 illustrate how Cplus_plus' exception classes are used to handle exceptions in a program.
The program in Example 14-8 shows how to handle the exceptions out_of_range and length_error.
Notice that in this program, these exceptions are thrown by the string functions substr and the string concatenation operator +.
Because the exceptions are thrown by these functions, we do not  any throw statement in the try block.
Handling Exceptions within a Program.
Sample Run: 5:  = Testing string exceptions.
Because the starting position of the substring is 8, which is less than 26, no exception is thrown.
However, in the statement in  9, the starting position of the substring is 28, which is greater than 26 (the  of ).
Therefore, the function substr throws an out_of_range exception, which is caught and processed by the catch  in  13.
Notice that in the statement in  14, the object re uses the function what to return the error message, invalid string position.
The program in Example 14-9 illustrates how to handle the exception bad_alloc thrown by the operator new.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sample Run: 4: 4: 4: 4: 4: 4: 4: 4: 7: Created list[0] of 50000000 components.
Created list[1] of 50000000 components.
Created list[2] of 50000000 components.
Created list[3] of 50000000 components.
Created list[4] of 50000000 components.
Created list[5] of 50000000 components.
Created list[6] of 50000000 components.
Created list[7] of 50000000 components.
In the bad_alloc catch : bad allocation.
The preceding program works as follows.
The statement in  1 declares list to be an array of 100 pointers.
The body of the for loop in  3  designed to execute 100 times.
For each iteration of the for loop, the statement in  4 uses the operator new to allocate an array of 50000000 components of type int.
As shown in the sample run, the operator new  able to create eight arrays of 50000000 components each.
In the ninth iteration, the operator new  unable to create the array and throws a bad_alloc Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Creating Your Own Exception Classes.
This exception  caught and processed by the catch  in  6.
Notice that the expression be_0_() returns the string bad allocation.
Some IDEs might return the string bad_alloc_0_) After the statement in  7 executes, control exits the try/catch , and the statement in  8 terminates the program.
Creating Your Own Exception Classes Watch the Video Whenever you create your own classes or write programs, exceptions are likely to occur.
As you have seen, Cplus_plus provides numerous exception classes to deal with these situations.
However, it does not provide all of the exception classes you will ever need.
Therefore, Cplus_plus enables programmers to create their own exception classes to handle both the exceptions not covered by Cplus_plus's exception classes and their own exceptions.
This section describes how to create your own exception classes.
Cplus_plus uses the same mechanism to process the exceptions that you define as it uses for built-in exceptions.
However, you must throw your own exceptions using the throw statement.
In Cplus_plus, any class can be considered an exception class.
Therefore, an exception class simply a class.
It need not be inherited from the class exception.
What makes a class an exception  how you use it.
The exception class that you define can be very simple in the sense that it does not contain any members.
For example, the following code can be considered an exception class: class dummyExceptionClass { };.
Sample Run 1: In this sample run, the user input  shaded.
The preceding program works as follows.
If the user enters 0 for the , the statement in  10 throws an anonymous object of the class divByZero.
The class divByZero has no members, so we cannot really do anything with the thrown object.
Therefore, in the catch  in  13, we specify only the data type name without the parameter name.
The statement in  14 outputs the appropriate error message.
Let us again consider the statement throw divByZero(); in  10.
Notice that in this statement, divByZero  the name of the class, the expression divByZero() creates an anonymous object of this class, and the throw statement throws the object.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Creating Your Own Exception Classes.
Next, we illustrate how to create exception classes with members.
If you want to  members in your exception class, you typically  constructors and the function what.
Consider the following definition of the class divisionByZero.
The definition of the class divisionByZero contains two constructors: the default constructor and the constructor with parameters.
The default constructor stores the string "Division by zero" in an object.
The constructor with parameters allows users to create their own error messages.
The function what  used to return the string stored in the object.
In the definition of the class divisionByZero, the constructors can also be written as:.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sample Run 1: In this sample run, the user input is shaded.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Creating Your Own Exception Classes.
This thrown exception is caught and processed by the catch block in  13.
The parameter divByZeroObj in the catch block catches the value of the thrown object and then uses the function  to return the string stored in the object.
The statement in  14 outputs the appropriate error.
The program in Example 14-12 is similar to the program in Example 14-11.
Here, the thrown object is still an anonymous object, but the error  is specified by the user (see the statement in  10).
EXAMPLE 14-12 // Using user-defined exception class divisionByZero with a.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sample Run 1: In this sample run, the user input is shaded.
The details are left as an exercise for you.
In the programs in Examples 14-11 and 14-12, the data manipulation is done in the function main.
Therefore, the exception is thrown, caught, and processed in the function main.
The program in Example 14-13 uses the user-defined function doDivision to manipulate the data.
Therefore, the exception is thrown, caught, and processed in the function doDivision.
EXAMPLE 14-13 // Handling an exception thrown by a function.
Sample Run 1: In this sample run, the user input is shaded.
If a circleType object tries to set the radius to a negative number, then the function setRadius of this class sets the radius to 0.
In this example, first we define the class negativeNumber to handle negative number exceptions and then use this class to throw an exception if a circleType object tries to set the radius to a negative number.
So consider the following class: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Note that the definition of the class negativeNumber is similar to the definition of the class divisionByZero.
The definition of the class circleType is the same as in Example 10-8, except for the definition of function setRadius.
The modified definition of this function is:.
If the value of the parameter r is a negative number, the function setRadius throws a negativeNumber object.
In this case, the value of the instance variable  of the object thrown is "Radius cannot be negative".
The user program will handle the exception, if any, thrown by this function.
Consider the following program: //The user program that uses the class circleType.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Creating Your Own Exception Classes.
The statement in  3 creates the circleType object circle and using the default constructor sets the  to 0_0_0.
The statement in  4 declares the double variable.
The try/catch block, between Lines 7 and 17 contains the code to prompt the user to enter the  of the circle and depending on the value entered by the user generates the output.
For example, if the user enters a nonnegative , the statement in  11 sets the  of the circle and the statement in  12 outputs the , , and the perimeter of the circle.
If the user enters a negative number, the statement in  11 throws an exception, which is a negativeNumber object, and the catch block processes the exception.
In Sample Run 1, the user enters 4_0_75, a nonnegative number, and the program outputs the , , and the perimeter of the circle.
In Sample Run 2, the user enters -2_0_65, which is a negative number, and the statement in  16 outputs that the  cannot be negative.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Typically, a catch block either handles the exception or partially processes the exception and then rethrows the same exception, or it rethrows another exception in order for the calling environment to handle the exception.
The catch block in Examples 14-4 through 14-14 handles the exception.
The mechanism of rethrowing or throwing an exception is quite useful in cases in which a catch block catches the exception but cannot handle the exception, or if the catch block decides that the exception should be handled by the calling block or environment.
This allows the programmer to provide the exception-handling code all in one place.
To rethrow or throw an exception, we use the throw statement.
The general syntax to rethrow an exception caught by a catch block is: throw;.
The object being thrown can be either a specific object or an anonymous object.
A function specifies the exceptions it throws (to be handled somewhere) in its heading using the throw clause.
For example, the following function specifies that it throws exceptions of type int, string, and divisionByZero, in which divisionByZero is the class, as defined previously.
Creating Your Own Exception Classes.
Sample Run 1: In this sample run, the user input is shaded.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
In this program, if the value of  is 0, the statement in  15 throws an exception of type divisionByZero, which is an anonymous object of this class, with the message string: The statement in  19, in the catch block, throws the same exception value, which in this case is an object.
In Sample Run 1, no exception is thrown.
Let us see  happens in Sample Run 2.
The function main calls the function doDivision in the try block.
In the function doDivision, the value of  is 0, so the statement in 15 throws an exception.
The exception is caught by the catch block in  18.
The statement in  19 rethrows the same exception.
In other words, the catch block catches and rethrows the same exception.
Therefore, the function call statement in  2 results in throwing an exception.
This exception is caught and processed by the catch block in  3.
Sample Run 1: In this sample run, the user input is shaded.
This program works the same way as the program in Example 14-15.
The only difference is that here, the catch block in  18 rethrows a different exception value, that is, object.
The programs in Examples 14-15 and 14-16 illustrate how a function can rethrow the same exception or throw another exception for the calling function to handle.
This mechanism is quite useful because it allows a program to handle all of the exceptions in one location, rather than spread the exception-handling code throughout the program.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The following sections discuss each of these situations.
Terminate the Program In some cases, it is best to let the program terminate when an exception occurs.
Suppose you have written a program that inputs data from a file.
If the input file does not exist when the program executes, then there is no point in continuing with the program.
In this case, the program can output an appropriate error message and terminate.
Fix the Error and Continue In other cases, you will want to handle the exception and let the program continue.
Suppose that you have a program that takes as input an integer.
If a user inputs a letter in place of a number, the input stream will enter the fail state.
This is a situation in which you can  the necessary code to keep prompting the user to input a number until the entry is valid.
The program in Example 14-17 illustrates this situation.
EXAMPLE 14-17 // Handle exceptions by fixing the errors.
The program continues to // prompt the user until a valid input is entered.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sample Run: In this sample run, the user input is shaded.
If the input is invalid, the standard input  enters the fail state.
In the try block, the statement in  12 throws an exception, which is a string object.
Control passes to the catch block, and the exception is caught and processed.
The statement in  20 restores the input  to its good state, and the statement in  21 clears the rest of the input from the line.
Log the Error and Continue The program that terminates when an exception occurs usually assumes that this termination is reasonably safe.
However, if your program is designed to run a nuclear reactor or continuously monitor a satellite, it cannot be terminated if an exception occurs.
These programs should report the exception, but the program must continue to run.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Because numerous ticketing transactions occur each day, a program is run at the end of each day to validate that day's transactions.
This type of program would take an enormous amount of time to process the transactions and use exceptions to identify any erroneous entries.
Instead, when an exception occurs, the program should write the exception into a file and continue to analyze the transactions.
Stack Unwinding The examples given in this chapter show how to catch and process an.
In particular, you learned how to catch and process an  in the same block, as well as process the caught  in the calling environment.
When an  is thrown in, say, a function, the function can do the following:.
Partially process the  and throw the same  or a new.
In each of these cases, the function call stack is unwound so that the  can be caught in the next try/catch block.
When the function call stack is unwound, the function in which the  was not caught and/or rethrown terminates, and the memory for its local variables is destroyed.
The stack unwinding continues until either a try/catch handles the  or the program does not handle the.
If the program does not handle the , then the function terminate is called to terminate the program.
Examples 14-18 and 14-19 illustrate how the exceptions are propagated.
For this, let us define the following  class: // User-defined myException class.
Stack Unwinding |.
The program in Example 14-18 illustrates how exceptions thrown in a function get processed in the calling environment.
EXAMPLE 14-18 // Processing exceptions thrown by a function in the calling.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Exception generated in function C.
In this program, the function  calls functionA, functionA calls functionB, and functionB calls functionC.
The function functionC creates and throws an of type myException.
The functions functionA and functionB do not process the thrown by functionC.
The function  calls functionA in the try block and catches the  thrown by functionC.
The parameter me in the catch block heading catches the value of the and then uses the function  to return the string stored in that object.
The output statement in the catch block outputs the appropriate.
The program in Example 14-19 is similar to the program in Example 14-18.
Here, the is caught and processed by the immediate calling environment.
Quick Review |.
Exception generated in functionC.
In this program, the  is caught and processed by.
Even though the function  contains the try/catch block, the try block does not throw any exceptions because the  thrown by functionC is caught and processed by.
QUICK REVIEW 1.
An  is an occurrence of an undesirable situation that can be detected during program execution.
Some typical ways of dealing with exceptions are to use an if statement or the assert function.
The function assert can check whether an expression meets the required condition(s).
If the conditions are not met, it terminates the program.
The try/catch block is used to handle exceptions within a program.
Statements that may generate an  are placed in a try block.
The try block also contains statements that should not be executed if an occurs.
The try block is followed by one or more catch blocks.
A catch block specifies the type of  it can catch and contains an handler.
If the heading of a catch block contains_0__0__0_(ellipses) in place of parameters, then this catch block can catch exceptions of all types.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
If an exception is thrown in a try block, the remaining statements in the try block are ignored.
The program searches the catch blocks, in the order they appear after the try block, and looks for an appropriate exception handler.
If the type of the thrown exception matches the parameter type in one of the catch blocks, then the code in that catch block executes and the remaining catch blocks after this catch block are ignored.
The data type of the catch block parameter specifies the type of exception that the catch block can catch.
A catch block can have, at most, one catch block parameter.
If only the data type is specified in a catch block heading, that is, if there is no catch block parameter, then the thrown value may not be accessible in the catch block exception-handling code.
In order for an exception to occur in a try block and be caught by a catch block, the exception must be thrown in the try block.
The general syntax to throw an exception is: throw expression; 16.
The object being thrown can be either a specific object or an anonymous object.
Cplus_plus provides support to handle exceptions via a hierarchy of classes.
The class exception is the base class of the exception classes provided by Cplus_plus.
The function  returns the string containing the exception object thrown by Cplus_plus's built-in exception classes.
The class exception is contained in the header file exception.
The two classes that are immediately derived from the class exception are logic_error and runtime_error.
Both of these classes are defined in the header file stdexcept.
The class invalid_argument is designed to deal with illegal arguments used in a function call.
The class out_of_range deals with the string subscript out_of_range error.
If a length greater than the maximum allowed for a string object is used, the class length_error deals with this error.
If the operator new  allocate memory space, this operator throws a bad_alloc exception.
The class runtime_error is designed to deal with errors that can be detected only during program execution.
For example, to deal with arithmetic Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
A catch block typically handles the exception or partially processes the exception and then either rethrows the same exception or rethrows another exception in order for the calling environment to handle the exception.
Cplus_plus enables programmers to create their own exception classes to handle both the exceptions not covered by Cplus_plus's exception classes and their own exceptions.
Cplus_plus uses the same mechanism to process the exceptions you define as it uses for built-in exceptions.
However, you must throw your own exceptions using the throw statement.
In Cplus_plus, any class can be considered an exception class.
It need not be inherited from the class exception.
What makes a class an exception is how it is used.
The general syntax to rethrow an exception caught by a catch block is: throw;.
The object being thrown can be either a specific object or an anonymous object.
A function specifies the exceptions it throws in its heading using the throw clause.
When an  is thrown in a function, the function can do the following: do nothing, partially process the  and throw the same or a new , or throw a new.
In each of these cases, the function call stack is unwound so that the  can be caught in the next try/catch block.
The stack unwinding continues until a try/ catch handles the  or the program does not handle the.
If the program does not handle the , then the function terminate is called to terminate the program.
EXERCISES The number in parentheses at the end of an exercise refers to the learning objective listed at the beginning of the chapter.
Mark the following statements as true or false.
Division by zero is an  while opening an input file that does Suppose you use the assert function to check if certain conditions are met.
If the conditions are not met, then the assert function One way to handle an  is to print an error message and exit Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
If an  is thrown in a try block, the remaining statements in i.
The class invalid_range deals with the string subscript out_of_range l.
An  can be caught either in the function where it occurred, or m.
When the function call stack is unwound, the function in which the was not caught terminates, but the memory for its local What happens if in a catch block heading only the data type is specified, that is, d.
In this code, identify the try.
In this code, identify the catch.
In this code, identify the catch  parameter and its type.
In this code, identify the throw statement.
What is the output if the input is 1200.
What is the output if the input is 975.
What is the output if the input is -2000.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
What is the output if: The value of lowerLimit is 50.
The value of lowerLimit is 150.
The value of lowerLimit is 50, and the value of  is 0.
The value of lowerLimit is 150, and the value of  is 10.
The value of lowerLimit is 150, and the value of  is 0.
If you define your own exception class,  is typically included in that Define an exception class called tornadoException.
The class should have two constructors, including the default constructor.
If the exception is thrown with the default constructor, the method  should return "Tornado: Take cover immediately_0_".
The other constructor has a single parameter, say, m, of the int type.
If the exception is thrown with this constructor, the method Write a Cplus_plus program to test the class tornadoException specified in a.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
What output will be produced if the exception is thrown with the default constructor.
Also,  output will be produced if the exception is thrown with the constructor with parameters with the following actual parameter.
Suppose an exception is thrown in a function.
What are the three things the PROGRAMMING EXERCISES 1.
Write a program that prompts the user to enter a length in feet and inches and outputs the equivalent length in centimeters.
If the user enters a negative number or a nondigit number, throw and handle an appropriate exception and prompt the user to enter another set of numbers.
Redo Programming Exercise 8 of Chapter 4 so that your program handles exceptions such as division by zero and invalid input.
Redo Programming Exercise 7 of Chapter 7 so that your program handles exceptions such as division by zero and invalid input.
Write a program that prompts the user to enter time in 12-hour notation.
The program then outputs the time in 24-hour notation.
Your program must contain three exception classes: invalidHr, invalidMin, and invalidSec.
If the user enters an invalid value for hours, then the program should throw and catch an invalidHr object.
Similar conventions for the invalid values of minutes and seconds.
Write a program that prompts the user to enter a person's date of birth in numeric form such as 8-27-1980.
The program then outputs the date of birth in the form: August 27, 1980.
Your program must contain at least two exception classes: invalidDay and invalidMonth.
If the user enters an invalid value for day, then the program should throw and catch an invalidDay object.
Similar conventions for the invalid values of month Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Become aware of recursion vs.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
For certain problems, however, using the iterative technique to obtain the solution is quite complicated.
This chapter introduces another problem-solving technique called recursion and provides several examples demonstrating how recursion works.
Recursive Definitions The process of solving a problem by reducing it to smaller versions of itself is called recursion.
Recursion is a very powerful way to solve certain problems for which the solution would otherwise be very complicated.
Let us consider a problem that is familiar to most everyone.
In mathematics, the factorial of a nonnegative integer is defined as follows: 0.
To find (  1)_0_, we apply the definition again.
If (  1) > 0, then we use Equation 15-2; otherwise, we use Equation 15-1.
Thus, for an integer  greater than 0,.
Let us apply this definition to find 3_0_.
Because  > 0, we use Equation 15-2 to obtain: 3.
Next, we find 2.
Because  > 0, we use Equation 15-2 to obtain: 2.
Now, to find 1_0_, we again use Equation 15-2 because  = 1 > 0.
Finally, we use Equation 15-1 to find 0_0_, which is 1.
The solution in Equation 15-1 is direct—that is, the right side of the equation contains no factorial notation.
The solution in Equation 15-2 is given in terms of a smaller version of itself.
The definition of the factorial given in Equations 15-1 and 15-2 is called a recursive definition.
Equation 15-1 is called the base case (that is, the case for which the solution is obtained directly); Equation 15-2 is called the general case.
Recursive definition: A definition in which something is defined in terms of a smaller version of itself.
From the previous example (factorial), it is clear that: 1.
Every recursive definition must have one (or more) base cases.
The general case must eventually be reduced to a base case.
The base case stops the recursion.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
An algorithm that finds the solution to a given problem by reducing the problem to smaller versions of itself is called a recursive algorithm.
The recursive algorithm must have one or more base cases, and the general solution must eventually be reduced to a base case.
A function that calls itself is called a recursive function.
That is, the body of the recursive function contains a statement that causes the same function to execute again before completing the current call.
Recursive algorithms are implemented using recursive functions.
Next, let us write the recursive function that implements the factorial function.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Let us note the following from the preceding example, involving the factorial function.
Logically, you can think of a recursive function as having an unlimited number of copies of itself.
Every call to a recursive function—that is, every recursive call—has its own code and its own set of parameters and local variables.
After completing a particular recursive call, control goes back to the call must execute completely before control goes back to the previous call.
The execution in the previous call begins from the point immediately following the recursive call.
Direct and Indirect Recursion A function is called directly recursive if it calls itself.
A function that calls another function and eventually results in the original function call is said to be indirectly recursive.
For example, if function A calls function B and function B calls function A, then function A is indirectly recursive.
Indirect recursion can be several layers deep.
For example, suppose that function A calls function B, function B calls function C, function C calls function D, and function D calls function A.
Function A is then indirectly recursive.
Indirect recursion requires the same careful analysis as direct recursion.
The base cases must be identified, and appropriate solutions to them must be provided.
However, tracing through indirect recursion can be tedious.
You must, therefore, exercise extra care when designing indirect recursive functions.
For simplicity, the problems in this book involve only direct recursion.
A recursive function in which the last statement executed is the recursive call is called a tail recursive function.
The function  is an example of a tail recursive function.
Infinite Recursion Figure 15-1 shows that the sequence of recursive calls eventually reached a call that made no further recursive calls.
That is, the sequence of recursive calls eventually reached a base case.
On the other hand, if every recursive call results in another recursive call, then the recursive function (algorithm) is said to have infinite recursion.
In theory, infinite recursion executes forever.
Every call to a recursive function requires the system to allocate memory for the local variables and formal parameters.
The system also saves this information so that after completing a call, control can be transferred back to the right caller.
Therefore, because computer memory is finite, if you execute an infinite recursive Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Problem Solving Using Recursion | 1043 function on a computer, the function executes until the system runs out of memory and results in an abnormal termination of the program.
Recursive functions (algorithms) must be carefully designed and analyzed.
You must make sure that every recursive call eventually reduces to a base case.
This chapter provides several examples that illustrate how to design and implement recursive algorithms.
To design a recursive function, you must do the following: a.
Understand the problem requirements.
Determine the limiting conditions.
For example, for a list, the limiting condition is the number of elements in the list.
Identify the base cases and provide a direct solution to each base case.
Identify the general cases and provide a solution to each general case in terms of smaller versions of itself.
Problem Solving Using Recursion Examples 15-1 through 15-3 illustrate how recursive algorithms are developed and implemented in Cplus_plus using recursive functions.
E X A M P L E 1 5 - 1: L A R G E S T E L E M E N T I N A N A R R A Y In Chapter 8, we used a loop to find the largest element in an array.
In this example, we use a recursive algorithm to find the largest element in an array.
Consider the list given in Figure 15-2.
Suppose list is the name of the array containing the list elements.
Also, suppose that list[a]_0__0__0_list[b] stands for the array elements list[a], list[a + 1], _0__0__0_, and list[b].
For example, list[0]_0__0__0_list[5] represents the array elements list[0], list[1], list[2], list[3], list[4], and list[5].
Similarly, list[1]_0__0__0_list[5] represents the array elements list[1], list[2], list[3], list[4], and list[5].
To write a recursive algorithm to find the largest element in list, let us think in terms of recursion.
If list is of length 1, then list has only one element, which is the largest element.
Suppose the length of list is greater than 1.
To find the largest element in Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
That is, the largest element in list[a]_0__0__0_list[b] is given by:.
That is, the largest element in list is the maximum of list[0] and the largest element in list[1]_0__0__0_list[5].
To find the largest element in list[1]_0__0__0_list[5], we use the same formula again because the length of this list is greater than 1.
The largest element in list[1]_0__0__0_list[5] is then: and so on.
We see that every time we use the preceding formula to find the largest element in a sublist, the length of the sublist in the next call is reduced by one.
Eventually, the sublist is of length 1, in which case the sublist contains only one element, which is the largest element in the sublist.
From this point onward, we backtrack through the recursive calls.
This discussion translates into the following recursive algorithm, which is presented in pseudocode: Base Case: The size of the list is 1 The only element in the list is the largest element General Case: The size of the list is greater than 1 To find the largest element in list[]_0__0__0_list[b] Find the largest element in list[ + 1]_0__0__0_list[b] and call it max b.
Compare the elements list[] and max the largest element in list[]_0__0__0_list[b] is list[] otherwise the largest element in list[]_0__0__0_list[b] is max This algorithm translates into the following Cplus_plus function to find the largest element in.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Problem Solving Using Recursion |.
The following Cplus_plus program uses the function largest to determine the largest element in.
The largest element in : 76 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Problem Solving Using Recursion | 1047 E X A M P L E 1 5 - 2: F I B O N A C C I N U M B E R In Chapter 5, we designed  program to determine the desired Fibonacci number.
In this example, we write  recursive function, rFibNum, to determine the desired Fibonacci number.
The function rFibNum takes as parameters three numbers representing the first two numbers of the Fibonacci sequence and  number n, the desired nth Fibonacci number.
The function rFibNum returns the nth Fibonacci number in the sequence.
Recall that the third Fibonacci number is the sum of the first two Fibonacci numbers.
The fourth Fibonacci number in a sequence is the sum of the second and third Fibonacci numbers.
Therefore, to calculate the fourth Fibonacci number, we add the second Fibonacci number and the third Fibonacci number (which is itself the sum of the first two Fibonacci numbers).
The following recursive algorithm calculates the nth Fibonacci number, in which a denotes the first Fibonacci number, b the second Fibonacci number, and n the nth Fibonacci number.
That is, we want to determine the fourth Fibonacci.
Next, we determine (2, 5, 3) and (2, 5, 2).
To find (2, 5, 1), note that  = 2,  = 5, and  = 1.
Therefore, by the definition given in Equation 15-3:.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
In this statement, the first number is 2, the second number is 3, and we want to determine the fifth Fibonacci number of the sequence.
Figure 15-5 traces the execution of the expression (2,3,5).
The value returned is 13, which is the fifth Fibonacci number of the sequence whose first number is 2 and second number is 3.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Problem Solving Using Recursion | 3 1 5.
Sample Runs: In these sample runs, the user input  shaded.
Sample Run 1 Enter the first Fibonacci number: 2 Enter the second Fibonacci number: 5 Enter the position of the desired Fibonacci number: 6 The Fibonacci number at position 6 : 31 Sample Run 2 Enter the first Fibonacci number: 12 Enter the second Fibonacci number: 18 Enter the position of the desired Fibonacci number: 15 The Fibonacci number at position 15 : 9582 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Problem Solving Using Recursion | 1051 E X A M P L E 1 5 - 3: T O W E R O F H A N O I In the nineteenth century, a game called the Tower of Hanoi became popular in Europe.
This game represents work that  under way in the temple of Brahma.
At the creation of the universe, priests in the temple of Brahma were supposedly given three diamond needles, with one needle containing 64 golden disks.
Each golden disk  slightly smaller than the disk below it.
The priests' task  to move all 64 disks from the first needle to the third needle.
The rules for moving the disks are as follows: 1.
Only one disk can be moved at a time.
The removed disk must be placed on one of the needles.
A larger disk cannot be placed on top of a smaller disk.
The priests were told that once they had moved all of the disks from the first needle to the third needle, the universe would come to an end.
Our objective  to write a program that prints the sequence of moves needed to transfer the disks from the first needle to the third needle.
Figure 15-6 shows the Tower of Hanoi problem with three disks.
Let us first consider the case in which the first needle contains only one disk.
In this case, the disk can be moved directly from needle 1 to needle 3.
So let us consider the case in which the first needle contains only two disks.
In this case, first we move the first disk from needle 1 to needle 2, and then we move the second disk from needle 1 to needle 3.
Finally, we move the first disk from needle 2 to needle 3.
Next, we consider the case in which the first needle contains three disks and then generalize this to the case of 64 disks (in fact, to an arbitrary number of disks).
Suppose that needle 1 contains three disks.
To move disk number 3 to needle 3, the top two disks must first be moved to needle 2.
Disk number 3 can then be moved from needle 1 to needle 3.
To move the top two disks from needle 2 to needle 3, we use the same strategy as before.
This time, we use needle 1 as the intermediate needle.
Figure 15-7 shows a solution to the Tower of Hanoi problem with three disks.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Solution to Tower of Hanoi problem with three disks Let us now generalize this problem to the case of 64 disks.
To begin, the first needle contains all 64 disks.
Disk number 64 cannot be moved from needle 1 to needle 3 unless the top 63 disks are on the second needle.
So first, we move the top 63 disks from needle 1 to needle 2, and then we move disk number 64 from needle 1 to needle 3.
Now the top 63 disks are all on needle 2.
To move disk number 63 from needle 2 to needle 3, we first move the top 62 disks from needle 2 to needle 1, and then we move disk number 63 from needle 2 to needle 3.
To move the remaining 62 disks, we use a similar procedure.
This discussion translates into the following recursive algorithm given in pseudocode.
Suppose that needle 1 contains n disks, in which n  1.
Move the top n  1 disks from needle 1 to needle 2, using needle 3 as the intermediate needle.
Move disk number n from needle 1 to needle 3.
Move the top n  1 disks from needle 2 to needle 3, using needle 1 as the intermediate needle.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Recursion or Iteration.
Tower of Hanoi: Analysis Let us determine how long it would take  move all 64 disks from  1   3.
If  1 contains three disks, then the number of moves required  move all three disks from  1   3  23  1 = 7.
Similarly, if  1 contains 64 disks, then the number of moves required  move all 64 disks from  1   3  264  1.
Because 210 ¼ 1024  1000 ¼ 103 , we have: 264 ¼ 24  260  24  1018 ¼ 1:6  1019 The number of seconds in one year  approximately 3_0_2  107.
Suppose the priests move one disk per second and they do not rest.
Now: 1:6  1019 ¼ 5  3:2  1018 ¼ 5  ð3:2  107 Þ  1011 ¼ ð3:2  107 Þ  ð5  1011 Þ The time required  move all 64 disks from  1   3  roughly 5  1011 years.
It  estimated that our universe  about 15 billion years old (1_0_5  1010).
This calculation shows that our universe would last about 33 times as long as it already has.
Assume that a computer can generate 1 billion (109) moves per second.
Then the number of moves that the computer can generate in one year : ð3:2  107 Þ  109 ¼ 3:2  1016 So the computer time required  generate 264 moves : 264  1:6  1019 ¼ 1:6  1016  103 ¼ ð3:2  1016 Þ  500 Thus, it would take about 500 years for the computer  generate 264 moves at the rate of 1 billion moves per second.
Recursion or Iteration.
In Chapter 5, we designed a program  determine a desired Fibonacci number.
That program used a loop  perform the calculation.
In other words, the programs in Chapter 5 used an iterative control structure  repeat a set of statements.
More formally, iterative Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due  electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right  remove additional content at any time if subsequent rights restrictions require it.
In Example 15-2, we designed a recursive function  calculate a Fibonacci number.
From the examples here, it follows that in recursion, a set of statements  repeated by having the function call itself.
Moreover, a selection control structure  used  control the repeated calls in recursion.
Similarly, in Chapter 8, we used an iterative control structure (a for loop)  determine the largest element in a list.
In this chapter, we use recursion  determine the largest element in a list.
In addition, this chapter began by designing a recursive function  find the factorial of a nonnegative integer.
Using an iterative control structure, we can also write an algorithm  find the factorial of a nonnegative integer.
The only reason  give a recursive solution  a factorial problem   illustrate how recursion works.
We thus see that there are usually two ways  solve a particular problem—iteration and recursion.
The obvious question  which method  better—iteration or recursion.
There no simple answer.
In addition  the nature of the problem, the other key factor in determining the best solution method  efficiency.
Example 6-13 (Chapter 6), while tracing the execution of the problem, showed us that local variables  allocated.
When the function terminates, that memory space  then deallocated.
This chapter, while tracing the execution of recursive functions, also shows us that every (recursive) call has its own set of parameters and (automatic) local variables.
That , every (recursive) call requires the system  allocate memory space for its formal parameters and (automatic) local variables and then deallocate the memory space when function both in terms of memory space and computer time.
Therefore, a recursive function executes more slowly than its iterative counterpart.
On slower computers, especially those with limited memory space, the (slow) execution of a recursive function would be visible.
Today's computers, however, are fast and have inexpensive memory.
Therefore, the execution of a recursion function  not noticeable.
Keeping the power of today's computers in mind, the choice between the two alternatives—iteration or recursion— depends on the nature of the problem.
Of course, for problems such as mission control systems, efficiency  absolutely critical and, therefore, the efficiency factor would dictate the solution method.
As a general rule, if you think that an iterative solution  more obvious and easier understand than a recursive solution, use the iterative solution, which would be more efficient.
On the other hand, problems exist for which the recursive solution  more obvious or easier  construct, such as the Tower of Hanoi problem.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due  electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right  remove additional content at any time if subsequent rights restrictions require it.
Programming Example: Converting a Number from Binary  Decimal | PROGRAMMING EXAMPLE: Watch the Video 1055 Converting a Number from Binary Decimal In Chapter 1, we explained that the language of a computer, called machine language,  a sequence of 0s and 1s.
When you press the key A on the keyboard, 01000001  stored in the computer.
Also, you know that the collating sequence of A in the ASCII character set  65.
In fact, the binary representation of A  01000001, and the decimal representation of A  65.
The numbering system we use  called the decimal system, or base 10 system.
The numbering system that the computer uses  called the binary system, or base 2 system.
In this and the next programming example, we discuss how  convert a number from base 2  base 10 and from base 10  base 2.
Binary  To convert a number from base 2  base 10, we first find the weight of each bit in Decimal the binary number.
The weight of each bit in the binary number  assigned from right  left.
The weight of the rightmost bit  0.
The weight of the bit immediately the left of the rightmost bit  1, the weight of the bit immediately  the left of it 2, and so on.
Consider the binary number 1001101.
The weight of each bit  as follows: Weight 6 5 4 3 2 1 0 1 0 0 1 1 0 1 We use the weight of each bit to find the equivalent decimal number.
For each bit, we multiply the bit by 2 to the power of its weight and then we add all of the numbers.
For the above binary number, the equivalent decimal number is: 1  26 þ 0  25 þ 0  24 þ 1  23 þ 1  22 þ 0  21 þ 1  20 ¼ 64 þ 0 þ 0 þ 8 þ 4 þ 0 þ 1 ¼ 77 To write a program that converts a binary number into the equivalent decimal number, we note two things: (1) the weight of each bit in the binary number must be known, and (2) the weight is assigned from right to left.
Because we do not know in advance how many bits are in the binary number, we must process the bits from right to left.
After processing a bit, we can add 1 to its weight, giving the weight of the bit immediately to the left of it.
Also, each bit must be extracted from the binary number and multiplied by 2 to the power of its weight.
To extract a bit, we can use the mod operator.
Consider the following recursive algorithm, which is given in pseudocode: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
This algorithm assumes that the memory locations  and weight have been.
In this function, both  and weight are reference parameters.
The actual parameters corresponding to these parameters are initialized to 0.
After extracting the rightmost , this function updates the  number and the weight of the next Suppose  and  are int variables.
Consider the following statements:.
It shows the content of the variables and  next to each function call.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: Converting a Number from Binary to Decimal |.
FIGURE 15-8 13 4 0 because  is 0 the if statement fails and this.
Execution of binToDec(1101, , ); In Figure 15-8, each down arrow represents the successive function call.
Because the last statement of the function binToDec is a function call, after this statement executes, nothing happens.
After the statement: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: Converting a Number from Decimal to.
Enter a number in binary: 11010110 11010110 = 214 PROGRAMMING EXAMPLE: Converting a Number from Decimal to The previous programming example discussed and designed a program to convert a number from a binary representation to a  format—that is, from base 2 to base 10.
This programming example discusses and designs a program that uses recursion to convert a nonnegative integer in  format—that is, base 10—into the equivalent binary number—that is, base 2.
First, we define some terms.
Let x be an integer.
We call the remainder of x after division by 2 the rightmost  of x.
Thus, the rightmost  of 33 is 1 because 33 % 2 is 1, and the rightmost  of 28 is 0 because 28 % 2 is 0.
We first illustrate the algorithm to convert an integer in base 10 to the equivalent number in binary format, with the help of an example.
Suppose we want to find the binary representation of 35.
First, we divide 35 by 2.
The quotient is 17, and the remainder—that is, the rightmost  of 35—is 1.
Next, we divide 17 by 2.
The quotient is 8, and the remainder—that is, the rightmost  of 17— is 1.
Next, we divide 8 by 2.
The quotient is 4, and the remainder—that is, the rightmost  of 8—is 0.
We continue this process until the quotient becomes 0.
The rightmost  of 35 cannot be printed until we have printed the rightmost  of 17.
The rightmost  of 17 cannot be printed until we have printed the rightmost of 8, and so on.
Thus, the binary representation of 35 is the binary representation of 17 (that is, the quotient of 35 after division by 2), followed by the rightmost  of 35.
Thus, to convert an integer num in base 10 into the equivalent binary number, we first convert the quotient num / 2 into an equivalent binary number and then append the rightmost  of num to the binary representation of num / 2.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: Converting a Number from Decimal to.
The first output is produced by call 4, which prints 1; the second output is produced by call 3, which prints 1; the third output is produced by call 2, which prints 0; and the fourth output is produced by call 1, which prints 1.
Thus, the output of the statement: decToBin(13, 2); is:.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Enter a number in : 57 57 = 111001 QUICK REVIEW 1.
The process of solving a problem by reducing it to smaller versions of itself is called recursion.
A recursive definition defines a problem in terms of smaller versions of itself.
Every recursive definition has one or more  cases.
A recursive algorithm solves a problem by reducing it to smaller versions of itself.
Every recursive algorithm has one or more  cases.
The solution to the problem in a  case is obtained directly.
A function is called recursive if it calls itself.
Recursive algorithms are implemented using recursive functions.
Every recursive function must have one or more  cases.
The general solution breaks the problem into smaller versions of itself.
The general case must eventually be reduced to a  case.
The  case stops the recursion.
While tracing a recursive function:.
Logically, you can think of a recursive function as having an unlimited number of copies of itself.
Every call to a recursive function—that is, every recursive call—has its own code and its own set of parameters and local variables.
After completing a particular recursive call, control goes back to the call must execute completely before control goes back to the previous call.
The execution in the previous call begins from the point immediately following the recursive call.
A function is called directly recursive if it calls itself.
A function that calls another function and eventually results in the original function call is said to be indirectly recursive.
A recursive function in which the last statement executed is the recursive call is called a tail recursive function.
To design a recursive function, you must do the following: a.
Understand the problem requirements.
Determine the limiting conditions.
For example, for a list, the limiting condition is the number of elements in the list.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Identify the general cases and provide a solution to each general case in terms of smaller versions of itself.
EXERCISES The number in parentheses at the end of an exercise refers to the learning objective listed at the beginning of the chapter.
Mark the following statements as true or false.
A recursive solution of a problem reduces the problem into smaller e.
It is not necessary for a recursive function to have a  case because f.
Every call to a recursive function has its own code and its own set of {.
Identify the general case.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Identify the base case.
Identify the general case.
What is the output of the following statement.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Suppose  intArray is an array of integers, and  specifies the number of elements in intArray.
Also, suppose  low and high are two integers such  0 <= low < , 0 <= high < , and low < high.
That is, low and high are two indices in intArray.
Write a recursive definition  reverses the elements in intArray between low Write a recursive algorithm to multiply two positive integers m and n using Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed  any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
There are many other similar problems in which you are asked to find the number of ways to select a set of items from a given set of items.
The general problem can be stated as follows: Find the number of ways  different things can be chosen from a set of  items, in which  and  are nonnegative integers and  .
Suppose (, ) denotes the number of ways  different things can be chosen from a set of  items.
Then, (, ) is given by the following formula:.
Write a recursive function  takes as a parameter a nonnegative integer and generates the following pattern of stars.
If the nonnegative integer is 4, then the pattern generated is: **** *** ** * * ** *** **** 2.
Also, write a program  prompts the user to enter the number of lines in the pattern and uses the recursive function to generate the pattern.
For example, specifying 4 as the number of lines generates the above pattern.
Write a recursive function to generate the following pattern of stars: * * * * * * * * * * * * * * * * Also, write a program  prompts the user to enter the number of lines in the pattern and uses the recursive function to generate the pattern.
For example, specifying 4 as the number of lines generates the above pattern.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed  any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Also, write a program to  your function.
Write a recursive function named sumSquares  returns the sum of the squares of the numbers from 0 to num, in which num is a nonnegative int variable.
Also write a program to  your function.
Write a recursive function  finds and returns the sum of the elements of an int array.
Also, write a program to  your function.
A palindrome is a string  reads the same both forward and backward.
For example, the string "madam" is a palindrome.
Write a program  uses a recursive function to check whether a string is a palindrome.
Your program must contain a value-returning recursive function  returns true if the string is a palindrome and false otherwise.
Write a recursive function  returns both the smallest and the largest element in an int array.
Also, write a program to  your function.
Write a recursive function  returns true if the digits of a positive integer are in increasing order; otherwise, the function returns false.
Also, write a program to  your function.
Write a recursive function, reverseDigits,  takes an integer as a parameter and returns the number with the digits reversed.
Also, write a program to  your function.
Write a recursive function, sumDigits,  takes an integer as a parameter and returns the sum of the digits of the integer.
Also, write a program to test your function.
Write a recursive function, power, that takes as parameters two integers x and y such that x is nonzero and returns xy.
You can use the following recursive definition to calculate xy.
If y  0: 8 if y ¼ 0 <1 powerðx; yÞ ¼ x if y ¼ 1 : x  powerðx; y  1Þ if y > 1: If y < 0: 1 : powerðx; yÞ ¼ powerðx; yÞ Also, write a program to test your function.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Also, write a program to test your function.
Write a recursive function to implement Ackermann's function.
Also write a program to test your function.
What happens when you call the function with m ¼ 4 and n ¼ 3.
Write a recursive function to implement the recursive algorithm of Exercise 16 (reversing the elements of an array between two indices).
Also, write a program to test your function.
Write a recursive function to implement the recursive algorithm of Exercise 17 (multiplying two positive integers using repeated addition).
Also, write a program to test your function.
Write a recursive function to implement the recursive algorithm of Exercise 18 (determining the number of ways to select a set of things from a given set of things).
Also, write a program to test your function.
Write and implement a recursive version of the sequential search algorithm.
In the Programming Example, Converting a Number from Decimal to Binary, given in this chapter, you learned how to convert a decimal number into the equivalent binary number.
Two more number systems, octal (base 8) and hexadecimal (base 16), are of interest to computer scientists.
In fact, in Cplus_plus, you can instruct the computer to store a number in octal or hexadecimal.
The digits in the octal number system are 0, 1, 2, 3, 4, 5, 6,  7.
The digits in the hexadecimal number system are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E,  F.
So A in hexadecimal is 10 in decimal, B in hexadecimal is 11 in decimal,  so on.
The algorithm to convert a positive decimal number into an equivalent number in octal (or hexadecimal) is the same as discussed for binary numbers.
Here, we divide the decimal number by 8 (for octal)  by 16 (for hexadecimal).
Suppose ab represents the number a to the base b.
For example, 7510 means 75 to the base 10 (that is decimal),  8316 means 83 to the base 16 (that is, hexadecimal).
Write a program that uses a recursive function to convert a number in decimal to base 8 or base 16.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook /or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Using Newton's method, you can also write an algorithm to find the square root of  nonnegative real number within given tolerance as follows: Suppose x is  nonnegative real number,  is the approximate square root of x,  epsilon is the tolerance.
Start with  = x.
If |2  x|  epsilon, then  is the square root of x within the tolerance; otherwise: Replace  with (2 + x) / (2)  repeat Step in which |2  x| denotes the absolute value of 2  x.
Write  recursive function to implement this algorithm to find the square root of nonnegative real number.
Also, write  program to test your function.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook /or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Become familiar with circular linked lists Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook /or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
You have performed several operations on sequential lists, such as sorting, inserting, deleting,  searching.
You also found that if data is not sorted, then searching for an item in the list can be very time consuming especially with large lists.
Once the data is sorted, you can use  binary search  improve the search algorithm.
However, in this case, insertion  deletion become time consuming especially with large lists, because these operations require data movement.
Also, because the array size must be fixed during execution, new  can be added only if there is room.
Thus, there are limitations when you organize data in an array.
This chapter helps you to overcome some of these problems.
Chapter 12 showed how memory (variables) can be dynamically allocated  deallocated using pointers.
This chapter uses pointers to organize  process data in lists called linked lists.
Recall that when data is stored in an array, memory for the components of the array is contiguous— that is, the blocks are allocated one after the other.
However, as we will see, the components (called nodes) of  linked list need not be contiguous.
Linked Lists contains the address of the next node.
Thus, every node in  linked list has two components: one to store the relevant information (that is, data)  one to store the address, called the link, of the next node in the list.
The address of the first node in the list is stored in  separate location called the head or first.
Figure 16-1 is  pictorial representation of  node.
Structure of  node Linked list: A list of , called nodes, in which the order of the nodes is determined by the address, called the link, stored in each node.
The list in Figure 16-2 is an example of  linked list.
Linked list The arrow in each node indicates that the address of the node to which it is pointing is stored in that node.
The down arrow in the last node indicates that this link field is nullptr.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Linked list and values of the links The value of the head is 1200, the data part of the first node is 45, and the link component of the first node contains 1575, the address of the second node.
If no confusion arises, then we will use the arrow notation whenever we draw the figure of a linked list.
For simplicity and for the ease of understanding and clarity, Figures 16-3 through 16-6 use decimal integers as the values of memory addresses.
However, in computer memory, the memory addresses are in binary.
Because each node of a linked list has two components, we need to declare each node as a class or struct.
The data type of each node depends on the specific application—that is, what kind of data is being processed.
However, the link component of each node is a pointer.
The data type of this pointer variable is the node type itself.
For the previous struct nodeType.
Linked Lists: Some Properties To help you better understand the concept of a linked list and a node, some important properties of linked lists are described next.
Consider the linked list in Figure 16-4.
Linked list with four nodes Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The address of the first node is stored in the pointer head.
Each node has two components: info, to store the info, and link, to store the address of the next node.
For simplicity, we assume that info is of type int.
Suppose that the first node is at location 2000, the second node is at location 2800, the third node is at location 1500, and the fourth node is at location 3600.
Therefore, the value of head is 2000, the value of the component link of the first node is 2800, the value of the component link of the second node is 1500, and so on.
Also, the down arrow in the component link of the last node indicates that this value is nullptr.
The number at the top of each node is the address of that node.
The following table shows the values of head and some other nodes in the list shown in Figure 16-4.
Value head 2000.
Linked list after the statement  = head; executes Clearly, in Figure 16-5: currentarrow_operatorinfo currentarrow_operatorlink currentarrow_operatorlinkarrow_operatorinfo Value 2000 17 2800 92 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Therefore, after this statement executes,  points to the second node in the list.
In Figure 16-6: currentarrow_operatorinfo currentarrow_operatorlink currentarrow_operatorlinkarrow_operatorinfo Value 2800 92 1500 63 Finally, note that in Figure 16-6: headarrow_operatorlinkarrow_operatorlink headarrow_operatorlinkarrow_operatorlinkarrow_operatorinfo headarrow_operatorlinkarrow_operatorlinkarrow_operatorlink headarrow_operatorlinkarrow_operatorlinkarrow_operatorlinkarrow_operatorinfo currentarrow_operatorlinkarrow_operatorlink currentarrow_operatorlinkarrow_operatorlinkarrow_operatorinfo currentarrow_operatorlinkarrow_operatorlinkarrow_operatorlink currentarrow_operatorlinkarrow_operatorlinkarrow_operatorlinkarrow_operatorinfo Value 1500 63 3600 45 3600 45 nullptr Does not exist From now on, when working with linked lists, we will use only the arrow notation.
TRAVERSING A LINKED LIST The basic operations of a linked list are as follows: search the list to determine whether a particular item is in the list, insert an item in the list, and delete an item from the list.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
That is, given a pointer to the first node of the list, we must step through the nodes of the list.
Suppose that the pointer head points to the first node in the list, and the link of the last node is nullptr.
We cannot use the pointer head to traverse the list because if we use head to traverse the list, we would lose the nodes of the list.
This problem occurs because the links are in only one direction.
The pointer head contains the address of the first node, the first node contains the address of the second node, the second node contains the address of the third node, and so on.
If we move head to the second node, the first node is lost (unless we save a pointer to this node).
If we keep advancing head to the next node, we will lose all of the nodes of the list (unless we save a pointer to each node before advancing head, which is impractical because it would require additional computer time and memory space to maintain the list).
Therefore, we always want head to point to the first node.
It now follows that we must traverse the list using another pointer of the same type.
Suppose that  is a pointer of the same type as head.
The following code traverses the list: = head;.
ITEM INSERTION AND DELETION This section discusses how to insert an item into, and delete an item from, a linked list.
Consider the following definition of a node.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Linked list before item insertion.
Inserting a Node in a Linked List Statement Effect head.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Suppose that we reverse the sequence of the statements and execute the statements in the following order: = ;.
Using two pointers, we can simplify the insertion code somewhat.
Suppose q points to the  with info 34 (see Figure 16-9).
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Statement Effect head 45 34.
Node to be deleted is with info 34.
List after the statement  = q; executes From Figure 16-11, it is clear that the node with info 34 is removed from the list.
However, the memory is still occupied by this node, and this memory is inaccessible; that is, this node is dangling.
To deallocate the memory, we need a pointer to this node.
The Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Deleting a Node from a Linked List Statement Effect head.
First, we consider a linked list in general.
If the data we read is unsorted, the linked list will be unsorted.
Such a list can be built in two ways: forward and backward.
In the forward manner, a new  is always inserted at the end of the linked list.
In the backward manner, a new  is always inserted at the beginning of the list.
We will consider both cases.
BUILDING A LINKED LIST FORWARD Suppose that the nodes are in the usual info-link form, and info is of type int.
Let us assume that we process the following data: 2 15 8 24 34 We need three pointers to build the list: one to point to the first  in the list, which cannot be moved; one to point to the last  in the list; and one to create the new.
Next, consider the following statements: 1 2.
Initially, both  and  are nullptr.
Therefore, we have the list as shown in Figure 16-12.
FIGURE 16-12 Empty list After statement 1 executes, num is 2.
Statement 2 creates a  and stores the address of that  in.
Statement 3 stores 2 in the info field of , and statement 4 stores nullptr in the link field of  (see Figure 16-13).
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Figure 16-14 shows the resulting list.
List after inserting  in it We now repeat statements 1 through 6b.
After statement 1 executes, num is 15.
Statement 2 creates a  and stores the address of this  in.
Statement 3 stores 15 in the info field of , and statement 4 assigns nullptr to the link field of (see Figure 16-15).
List and  with info 15 Because  is not nullptr, we execute statements 6a and 6b.
Figure 16-16 shows the resulting list.
List after inserting  at the end We now repeat statements 1 through 6b three more times.
Figure 16-17 shows the resulting list.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
List after inserting 8, 24, and 34 To build the linked list, we can put the previous statements in a loop and execute the loop until certain conditions are met.
We can, in fact, write a Cplus_plus function to build a linked list.
Suppose that we read a list of integers ending with -999.
The following function, buildListForward, builds a linked list (in a forward manner) and returns the pointer of the built list:.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
For the previously given data—2, 15, 8, 24, and 34—the linked list is as shown in Figure 16-18.
List after building it backward Because the new  is always inserted at the beginning of the list, we do not need to know the end of the list, so the pointer  is not needed.
Also, after inserting the new at the beginning, the new  becomes the   in the list.
Thus, we need to update the value of the pointer  to correctly point to the   in the list.
We see, then, that we need only two pointers to build the linked list: one to point to the list and one to create the new.
Because initially the list is empty, the pointer must be initialized to nullptr.
In pseudocode, the algorithm is: 1.
Initialize  to nullptr.
For each item in the list, a.
Store the item in.
Update the value of the pointer.
The following Cplus_plus function builds the linked list backward and returns the pointer of.
Linked List as an ADT The previous sections taught you the basic properties of linked lists and how to construct and manipulate them.
Because a linked list is a very important data structure, rather than discuss specific lists such as a list of integers or a list of strings, this section discusses linked lists as an abstract data type (ADT).
Using templates, this section gives a generic definition of linked lists, which is then used in the next section and later in this book.
The programming example at the end of this chapter also uses this generic definition of linked lists.
The basic operations on linked lists are: 1.
Initialize the list.
Determine whether the list is empty.
Print the list.
Find the length of the list.
Destroy the list.
Retrieve the info contained in the.
Retrieve the info contained in the.
Search the list for a given item.
Insert an item in the list.
Delete an item from the list.
Make a copy of the linked list.
In general, there are two types of linked lists—sorted lists, whose elements are arranged according to some criteria, and unsorted lists, whose elements are in no particular order.
The algorithms to implement the operations search, insert, and remove slightly differ for sorted and unsorted lists.
Therefore, we will define the class linkedListType to implement the basic operations on a linked list as an abstract class.
Using the principle of inheritance, we, in fact, will derive two classes—unorderedLinkedList and orderedLinkedList—from the class linkedListType.
Objects of the class unorderedLinkedList would arrange list elements in no particular order, that is, these lists may not be sorted.
On the other hand, objects of the class orderedLinkedList would arrange elements according to some comparison criteria, usually less than or equal to.
That is, these lists will be in ascending order.
Moreover, after Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
If a linked list is unordered, we can insert a new  at either the end or the beginning.
Furthermore, you can build such a list in either a forward manner or a backward manner.
The function buildListForward inserts the new  at the end, whereas the function buildListBackward inserts the new  at the beginning.
To accommodate both operations, we will write two functions: insertFirst to insert the new  at the beginning of the list and insertLast to insert the new  at the end of the list.
Also, to make the algorithms more efficient, we will use two pointers in the list: , which points to the   in the list, and last, which points to the last  in the list.
Structure of Linked List Nodes Recall that each  of a linked list must store the data as well as the address for the next in the list (except the last  of the list).
Therefore, the  has two member variables.
To simplify operations such as insert and delete, we define the class to implement the  of a linked list as a struct.
The definition of the struct  is: //Definition of the template <class Type>.
Exercise 9, at the end of this chapter, asks you to redefine the class to implement the nodes of a linked list so that the member variables of the class  are private.
Member Variables of the class linkedListType To maintain a linked list, we use two pointers:  and last.
The pointer  points to the   in the list, and last points to the last  in the list.
We also keep a count of the number of nodes in the list.
Therefore, the class linkedListType has three member variables, as follows: protected: int count;.
Linked List as an ADT.
This requires the list to be traversed, starting at the  node.
Moreover, a specific application requires each node to be processed in a very specific way.
A common technique to accomplish this is to provide an iterator.
An iterator is an object that produces each element of a container, such as a linked list, one element at a time.
The two most common operations on iterators are plus_plus (the increment operator) and * (the dereferenceing operator).
The increment operator advances the iterator to the next node in the list, and the dereferencing operator returns the info of the  node.
Note that an iterator is an object.
So we need to define a class, which we will call linkedListIterator, to create iterators to objects of the class linkedListType.
The iterator class would have one member variable pointing to (the ) node.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Figure 16-19 shows the UML class diagram of the class.
UML class diagram of the class.
Linked List as an ADT.
Now that we have defined the classes to implement the node of a linked list and an iterator to a linked list, next we describe the class  to implement the basic properties of a linked list.
The following abstract class defines the basic properties of a linked list as an ADT: template <class > class { public:.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Linked List as an ADT.
Figure 16-20 shows the UML class diagram of the class.
UML class diagram of the class Note that typically, in the UML diagram, the name of an abstract class and abstract function is shown in italics.
The instance variables  and , as defined earlier, of the class are protected, not private, because as noted previously, we will derive the classes unorderedLinkedList and orderedLinkedList from the class.
Because each of the classes unorderedLinkedList Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The definition of the class  includes a member function to overload the assignment.
For classes that include pointer data members, the assignment must be explicitly overloaded (see Chapters 12 and 13).
For the same reason, the definition of the class also includes a copy constructor.
Notice that the definition of the class  contains the member function copyList, which is declared as a private member.
This is due to the fact that this function is used only to implement the copy constructor and overload the assignment.
Next, we write the definitions of the nonabstract functions of the class LinkedListClass.
The  is empty if  is nullptr.
Therefore, the definition of the function isEmptyList to implement this operation is as follows: template <class >.
DEFAULT CONSTRUCTOR The default constructor, , is quite straightforward.
It simply initializes the  to an empty state.
Recall that when an object of the  type is declared and no value is passed, the default constructor is executed automatically.
DESTROY THE LIST The function destroyList deallocates the memory occupied by each node.
We traverse the  starting from the  node and deallocate the memory by calling the delete.
We need a temporary pointer to deallocate the memory.
Once the entire  is destroyed, we must set the pointers  and  to nullptr and  to 0.
Linked List as an ADT.
INITIALIZE THE LIST The function initializeList initializes the  to an empty state.
Note that the default constructor or the copy constructor has already initialized the  when the object was declared.
This operation, in fact, reinitializes the  to an empty state, so it must delete the nodes (if any) from the.
This task can be accomplished by using the destroyList operation, which also resets the pointers  and  to nullptr and sets  to 0.
Print the List The member function print prints the data contained in each node.
To do so, we must traverse the list, starting at the  node.
Because the pointer  always points to the node in the list, we need another pointer to traverse the list.
The length of a linked list (that is, how many nodes are in the list) is stored in the variable Therefore, this function returns the value of this variable: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Retrieve the Data of the First Node The function front returns the info contained in the  node, and its definition is straightforward: template <class > <>::front().
Notice that if the list is empty, the assert statement terminates the program.
Therefore, before calling this function, check to see whether the list is nonempty.
Retrieve the Data of the Last Node The function back returns the info contained in the  node, and its definition is straightforward: template <class > <>::back().
Notice that if the list is empty, the assert statement terminates the program.
Therefore, before calling this function, check to see whether the list is nonempty.
Begin and End The function begin returns an iterator to the  node in the linked list, and the function end returns an iterator to one past the  node in the linked list.
Their definitions are: template <class >.
Linked List as an ADT.
Copy the List The function copyList makes an identical copy of a linked list.
Therefore, we traverse the list to be copied, starting at the  node.
Corresponding to each node in the original list, we: a.
Create a node, and call it newNode.
Copy the info of the node (in the original list) into newNode.
Insert newNode at the end of the list being created.
The definition of the function copyList is: template <class Type> void <Type>::copyList.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Destructor The destructor deallocates the memory occupied by the nodes of a list when the class object goes out of scope.
Because memory is allocated dynamically, resetting the pointers  and does not deallocate the memory occupied by the nodes in the list.
We must traverse the list, starting at the  node, and delete each node in the list.
The list can be destroyed by calling the function destroyList.
Therefore, the definition of the destructor is: template <class Type>.
Copy Constructor Because the class  contains pointer data members, the definition of this class contains the copy constructor.
Recall that if a formal parameter is a value parameter, the copy constructor provides the formal parameter with its own copy of the data.
The copy constructor also executes when an object is declared and initialized using The copy constructor makes an identical copy of the linked list.
This can be done by calling the function copyList.
Because the function copyList checks whether the original is empty by checking the value of , we must  initialize the pointer to nullptr before calling the function copyList.
The definition of the copy constructor is: template <class Type> <Type>::.
Unordered Linked Lists.
We give its definition for the sake of completeness.
Unordered Linked Lists As described in the preceding section, we derive the class unorderedLinkedList from the abstract class  and implement the operations search, insertFirst, insertLast, and deleteNode.
The following class defines an unordered linked list as an ADT: template <class > class unorderedLinkedList: public <> { public: bool search(const & searchItem) const; //Function to determine whether searchItem is in the.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Search the List The member function search searches the  for a given item.
If the item is found, it returns true; otherwise, it returns false.
Because a linked  is not a random-access data structure, we must sequentially search the , starting from the  node.
This function has the following steps: 1.
Compare the search item with the  node in the.
If the info of the  node is the same as the search item, stop the search; otherwise, make the next node the  node.
Repeat Step 1 until either the item is  or no more data is left in the to compare with the search item.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Unordered Linked Lists.
Insert the First Node The function insertFirst inserts the new  at the beginning of the —that is, before the  pointed to by first.
The steps needed to implement  function are as follows: 1.
Insert the  before first.
Increment count by 1.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Insert the Last Node The definition of the member function insertLast is similar to the definition of the member function insertFirst.
Here, we insert the new  after.
Essentially, the function insertLast is: template <class Type>.
DELETE A NODE Next, we discuss the implementation of the member function deleteNode, which deletes a  from the list with a given info.
We need to consider several cases: Case 1: The list is empty.
Case 2: The   is the  with the given info.
In this case, we need to adjust the pointer.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Unordered Linked Lists.
If the  to be deleted is the  , then we must adjust the pointer.
Case 4: The list does not contain the  with the given info.
If list is empty, we can simply print a message indicating that the list is empty.
If list is not empty, we search the list for the  with the given info and, if such a  is , we delete this.
After deleting the , count is decremented by 1.
In pseudocode, the algorithm is: if list is empty Output(cannot delete from an empty list); else { if the   is the  with the given info adjust the head pointer, that is, , and deallocate the memory; else { search the list for the  with the given info if such a  is , delete it and adjust the.
If the list is empty, output an error message as shown in the pseudocode.
Case 2: The list is not empty.
This case has two scenarios: list has only one , and list has more than one.
Consider the list with one , as shown in Figure 16-22.
After deletion, the list becomes empty.
Therefore, after deletion, both  and  are set to nullptr, and count is set to 0.
Now consider the list of more than one , as shown in Figure 16-23.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
After deleting this , the second becomes the.
Therefore, after deleting this , the value of the pointer changes; that is, after deletion,  contains the address of the  with info 17, and count is decremented by 1.
Figure 16-24 shows the list after deleting 28.
This case has two subcases: (a) the  to be deleted is not the  , and (b) the to be deleted is the.
Let us illustrate both cases.
Case 3a: The  to be deleted is not the.
Consider the list shown in Figure 16-25.
After deleting this node, the resulting list is as shown in Figure 16-26.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Unordered Linked Lists.
The link field of the previous node—that is, 17—changes.
Consider the list shown in Figure 16-27.
Suppose that the node to be deleted is 54.
Therefore, the deletion of 54 requires us to change the value of the pointer last.
After deleting 54, last contains the address of the node with info 24.
Also, count is decremented by 1.
Figure 16-28 shows the resulting list.
In this case, the list requires no adjustment.
We simply output an error message, indicating that the item to be deleted is not in the list.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Because a linked list is not a random-access data structure, we must sequentially search the list.
We handle Case 1 separately, because it does not require us to traverse the list.
We sequentially search the list, starting at the second node.
If the node to be deleted is in the middle of the list, we need to adjust the link field of the node just before the node to be deleted.
Thus, we need a pointer to the previous node.
When we search the list for the given info, we use two pointers: one to check the info of the current node and one to keep track of the node just before the current node.
If the node to be deleted is the last node, we must adjust the pointer last.
The definition of the function deleteNode is: template <class Type>.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Unordered Linked Lists.
Header File of the Unordered Linked List For the sake of completeness, we will show how to create the header file that defines the class unorderedListType and the operations on such lists.
Ordered Linked Lists The preceding section described the operations on an unordered linked.
This section deals with ordered linked lists.
As noted earlier, we derive the class orderedLinkedList from the class linkedListType and provide the definitions of the abstract functions insertFirst, insertLast, search, and deleteNode to take advantage of the fact that the elements of an ordered linked  are arranged using some ordering criteria.
For simplicity, we assume that elements of an ordered linked  are arranged in ascending order.
Because the elements of an ordered linked  are in order, we include the function insert to insert an element in an ordered  at the proper place.
The following class defines an ordered linked  as an ADT: template <class Type> class orderedLinkedList: public linkedListType<Type> { public: bool search(const Type& searchItem) const; //Function to determine whether searchItem is in the.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Figure 16-29 shows a UML class diagram of the class orderedLinkedList and the inheritance hierarchy.
Next, we give the definitions of the member functions of the class orderedLinkedList.
Search the List First, we discuss the search operation.
The algorithm to implement the search operation is similar to the search algorithm for general lists discussed earlier.
Here, because the  is sorted, we can improve the search algorithm somewhat.
As before, we start the search at the first node in the.
We stop the search as soon as we find a node in the  with info greater than or equal to the search item or when we have searched the entire.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Compare the search item with the current node in the.
If the info of the current node is greater than or equal to the search item, stop the search; otherwise, make the next node the current node.
Repeat Step 1 until either an item in the  that is greater than or equal to the search item is  or no more data is left in the  to compare with the search item.
Note that the loop does not explicitly check whether the search item is equal to an item in the.
Thus, after the loop executes, we must check whether the search item is equal to the item in the.
Insert a Node To insert an  in an ordered linked , we first find the place where the new  is supposed to go, and then we insert the  in the.
To find the place for the new , as before, we search the.
Here, we use two pointers,  and trailCurrent, to search the.
The pointer  points to the node whose info is being compared with the  to be inserted, and trailCurrent points to the node just before.
Because the  is in order, the search algorithm is the same as before.
The following cases arise: Case 1: The  is initially empty.
The node containing the new  is the only node and thus the first node in the.
Case 2: The new  is smaller than the smallest  in the.
In this case, we need to adjust the 's head pointer— that is, first.
Also, count is incremented by 1.
Case 3: The  is to be inserted somewhere in the.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Ordered Linked Lists.
In this case, the new is inserted at the end of the.
Thus, the value of  is nullptr, and the new  is inserted after trailCurrent.
Also, count is incremented by 1.
In this case, the new  is inserted between trailCurrent and.
Also, count is incremented by 1.
The following statements can accomplish both Cases 3a and 3b.
Assume newNode points to the new.
Case 1: The  is empty.
Consider the  shown in Figure 16-30(a).
Suppose that we want to insert 27 in the.
To accomplish this task, we create a , copy 27 into the , set the link of the  to nullptr, and make first point to the.
Figure 16-30(b) shows the resulting.
Notice that, after inserting 27, the values of both first and count change.
Case 2: The  is not empty, and the  to be inserted is smaller than the smallest in the.
Consider the  shown in Figure 16-31.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
After inserting 10 in the list, the  with info 10 becomes the first  of list.
This requires us to change the value of first.
Also, count is incremented by 1.
Figure 16-32 shows the resulting list.
As indicated previously, this case has two scenarios.
Case 3a: The  to be inserted is larger than the largest  in the list; that is, it goes at the end of the list.
Consider the list shown in Figure 16-33.
After inserting 65, the resulting list is as shown in Figure 16-34.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Ordered Linked Lists.
Consider the list shown in Figure 16-35.
Clearly, 27 goes between 17 and 38, which would require the link of the node with info 17 to be changed.
After inserting 27, the resulting list is as shown in Figure 16-36.
It also follows that we should traverse the list with two pointers— say, current and trailCurrent.
The pointer current is used to traverse the list and compare the info of the node in the list with the item to be inserted.
The pointer trailCurrent points to the node just before current.
For example, in Case 3b, when the search stops, trailCurrent points to node 17 and current points to node 38.
The item is inserted after trailCurrent.
In Case 3a, after searching the list to find the place for 65, trailCurrent points to node 54 and current is nullptr.
Essentially, the function insert is as follows: template <class Type>.
Insert First and Insert Last The function insertFirst inserts the new  at the beginning of the list.
However, because the resulting list must be sorted, the new  must be inserted at the proper place.
Similarly, the function insertLast must insert the new  at the proper place.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Ordered Linked Lists.
The definitions of these functions are:.
Note that in reality, the functions insertFirst and insertLast do not apply to ordered linked lists because the new  must be inserted at the proper place in the list.
However, you must provide its definition as these functions are declared as abstract in the parent class.
Delete a Node To delete a given  from an ordered linked list,  we search the list to see whether the  to be deleted is in the list.
The function to implement this operation is the same as the delete operation on general linked lists.
Here, because the list is sorted, we can somewhat improve the algorithm for ordered linked lists.
As in the case of insertNode, we search the list with two pointers,  and Similar to the operation insertNode, several cases arise: Case 1: The list is initially empty.
We cannot delete from an empty list.
Case 2: The  to be deleted is contained in the  node of the list.
We must adjust the head pointer of the list—that is,.
Case 3: The  to be deleted is somewhere in the list.
In this case,  points to the node containing the  to be deleted, and  points to the node just before the node pointed to by.
Case 4: The list is not empty, but the  to be deleted is not in the list.
After deleting a node, count is decremented by 1.
The definition of the function deleteNode is: template <class Type>.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Header File of the Ordered Linked List For the sake of completeness, we will show how to create the header file that defines the class orderedListType, as well as the operations on such lists.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Ordered Linked Lists.
Line 3: Enter numbers ending  -999.
The details are left as an exercise for you.
Notice that the function insert does not check whether the item to be inserted is already in the , that is, it does not check for duplicates.
Programming Exercise 8 at the end of this chapter asks you to revise the definition of the function insert so that before inserting the item, it checks whether it is already in the.
If the item to be inserted is already in the , the function outputs an appropriate error message.
In other words, duplicates are not allowed.
Print a Linked List in Reverse Order The nodes of an ordered  (as constructed previously) are in ascending order.
Certain applications, however, might require the data to be printed in descending order, which means that we must print the  backward.
We now discuss the function reversePrint.
Given a pointer to a , this function prints the elements of the  in reverse order.
Consider the linked  shown in Figure 16-37.
Linked For the  in Figure 16-37, the output should be in the following form: 20 15 10 5 Because the links are in only one direction, we cannot traverse the  backward starting from the last node.
Let us see how we can effectively use recursion to print the  in reverse order.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
We cannot print the info of the first node until we have printed the remainder of the  (that is, the tail of the first node).
Similarly, we cannot print the info of the second node until we have printed the tail of the second node, and so on.
Every time we consider the tail of a node, we reduce the size of the by 1.
Eventually, the size of the  will be reduced to zero, in which case the recursion will stop.
Let us first write the algorithm in pseudocode.
Here, we do not see the base case; it is hidden.
The  is printed only if the pointer to the  is not nullptr.
Also, in the body of the if statement, the recursive call is on the tail of the.
Because eventually the tail of the  will be empty, the if statement in the next call will fail, and the recursion will stop.
Also, note that statements (for example, printing the info of the node) appear after the recursive call; thus, when the transfer comes back to the calling function, we must execute the remaining statements.
Recall that the function exits only after the last statement executes.
Let us trace the execution of this statement, which is a function call, for the  shown in Figure 16-37.
Because the formal parameter is a value parameter, the value of the actual parameter is passed to the formal parameter.
See Figure 16-38.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Its definition is: template <class Type>.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
In other words, every node contains the address of the next node (except the last (see Figure 16-39).
That is, we can traverse the list starting at the first node or, if a pointer to the last node is given, we can traverse the list starting at the last node.
As before, the typical operations on a doubly linked list are: 1.
Initialize the list.
Destroy the list.
Determine whether the list is empty.
Search the list for a given item.
Retrieve the first element of the list.
Retrieve the last element of the list.
Insert an item in the list.
Delete an item from the list.
Find the length of the list.
Print the list.
Make a copy of the doubly linked list.
Next, we describe these operations for an ordered doubly linked list.
The following class defines a doubly linked list as an ADT: //Definition of the node template <class Type>.
Doubly Linked Lists.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The functions to implement the operations of a doubly linked  are similar to the ones discussed earlier.
Here, because every node has two pointers, back and next, some of the operations require the adjustment of two pointers in each node.
For the insert and delete operations, because we can traverse the  in either direction, we use only one pointer to traverse the.
Let us call this pointer current.
We can set the value of trailCurrent by using both the current pointer and the back pointer of the node pointed to by current.
We give the definition of each function here, with four exceptions.
Definitions Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Doubly Linked Lists.
Default Constructor The default constructor initializes the doubly linked  to an empty state.
It sets and  to nullptr and  to 0.
The  is empty if the pointer  is nullptr.
Destroy the List This operation deletes all of the nodes in the , leaving the  in an empty state.
We traverse the  starting at the  node and then delete each node.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
This task can be done by using the operation destroy.
The definition of the function initializeList is: template <class >.
Length of the List The length of a linked  (that is, how many nodes are in the ) is stored in the variable Therefore, this function returns the value of this variable.
Print the List The function print outputs the info contained in each node.
We traverse the , starting from the  node.
Reverse Print the List This function outputs the info contained in each node in reverse order.
We traverse the in reverse order, starting from the  node.
Its definition is: template <class Type>.
Search the List The function search returns true if searchItem is  in the ; otherwise, it returns false.
The search algorithm is exactly the same as the search algorithm for an ordered linked.
First and Last Elements The function front returns the  element of the , and the function back returns the  element of the.
If the  is empty, both functions terminate the program.
Their definitions are: template <class Type>.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
INSERT A NODE Because we are inserting an  in a doubly linked list, the insertion of a  in the list requires the adjustment of two pointers in certain nodes.
As before, we find the place where the new  is supposed to be inserted, create the , store the new , and adjust the link fields of the new  and other particular nodes in the list.
There are four cases: Case 1: Insertion in an empty list Case 2: Insertion at the beginning of a nonempty list Case 3: Insertion at the end of a nonempty list Case 4: Insertion somewhere in a nonempty list Both Cases 1 and 2 require us to change the value of the pointer.
Cases 3 and 4 are similar.
After inserting an ,  is incremented by 1.
Next, we show Case 4.
Consider the doubly linked list shown in Figure 16-40.
After inserting 20, the resulting list is as shown in Figure 16-41.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Doubly Linked Lists.
The definition of the function insert is: template <class Type>.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
DELETE A NODE This operation deletes a given  (if ) from the doubly linked list.
As before, we search the list to see whether the  to be deleted is in the list.
The search algorithm is the same as before.
Similar to the insertNode operation, this operation (if the  to be deleted is in the list) requires the adjustment of two pointers in certain nodes.
The delete operation has several cases: Case 1: The list is empty.
Case 2: The  to be deleted is in the   of the list, which would require us to change the value of the pointer.
Case 3: The  to be deleted is somewhere in the list.
Case 4: The  to be deleted is not in the list.
After deleting a , count is decremented by 1.
Let us demonstrate Case 3.
Consider the list shown in Figure 16-42.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Doubly Linked Lists.
Doubly linked list before deleting 17 Suppose that the  to be deleted is 17.
First, we search the list with two pointers and find the  with info 17 and then adjust the link field of the affected nodes (see Figure 16-43).
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Circular Linked Lists.
A linked  in which the  node points to the  node is called a circular linked.
Figure 16-45 show various circular linked lists.
Then, by using , you can access both the  and the  nodes of the.
For example,  points to the node, and firstarrow_operatorlink points to the  node.
As before, the usual operations on a circular  are: 1.
Initialize the  (to an empty state).
Determine if the  is empty.
Find the length of the.
Search the  for a given item.
Insert an item in the.
Delete an item from the.
We leave it as an exercise for you to design a class to implement a sorted circular linked Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
PROGRAMMING EXAMPLE: Watch the Video Store For a family or an individual, a favorite place to go on weekends or holidays is to a store to rent movies.
A new  store in your neighborhood is about to open.
However, it does not have a program to keep track of its DVDs and customers.
The store managers want someone to write a program for their system so that the store can function.
The program should be able to perform the following operations: 1.
Rent a ; that is, check out a.
Return, or check in, a.
Create a  of DVDs owned by the store.
Show the details of a particular.
Print a  of all of the DVDs in the store.
Check whether a particular  is in the store.
Maintain a customer database.
Print a  of all of the DVDs rented by each customer.
Let us write a program for the  store.
This example further illustrates the objectoriented design methodology and, in particular, inheritance and overloading.
The programming requirement tells us that the  store has two major components: DVDs and customers.
We will describe these two components in detail.
We also need to maintain the following lists:.
A  of all of the DVDs in the store A  of all of the store's customers Lists of the DVDs currently rented by the customers We will develop the program in two parts.
In Part 1, we design, implement, and test the  component.
In Part 2, we design and implement the customer component, which is then added to the  component developed in Part 1.
That is, after completing Parts 1 and 2, we can perform all of the operations listed previously.
PART 1: COMPONENT Object This is the first stage, wherein we discuss the  component.
The common things associated with a  are:.
Name of the movie Names of the stars Name of the producer Name of the director Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example:  Store.
Set the  information—that is, the title, stars, production company, and so on.
Show the details of a particular.
Check the number of copies in the store.
Check out (that is, rent) the.
In other words, if the number of copies is greater than zero, decrement the number of copies by one.
Check in (that is, return) the.
To check in a , first we must check whether the store owns such a  and, if it does, increment the number of copies by one.
Check whether a particular  is available—that is, check whether the number of copies currently in the store is greater than zero.
The deletion of a  from the  list requires that the list be searched for the to be deleted.
Thus, we need to check the title of a  to find out which is to be deleted from the list.
For simplicity, we assume that two DVDs are the same if they have the same title.
The following class defines the  object as an ADT.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: DVD Store.
We leave the UML diagram of the class dvdType as an exercise for you.
For easy output, we will overload the output stream insertion , <<, for the class dvdType.
Next, we will write the definitions of each function in the class dvdType.
The definitions of these functions, as given below, are quite straightforward and easy to follow.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: DVD Store.
In general, we would not know how many DVDs are in the store, and adding or deleting a  from the store would change the number of DVDs in the store.
Therefore, we will use a linked list to create a list of DVDs (see Figure 16-46).
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
We also defined the basic operations such as insertion and deletion of a  in the list.
However, some operations are very specific to the  list, such as check out a , check in a , set the number of copies of a , and so on.
These operations are not available in the class unorderedLinkedList.
We will, therefore, derive a class dvdListType from the class unorderedLinkedList and add these operations.
The definition of the class dvdListType is:.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example:  Store.
The //parameter title specifies the name of the  for //which the number of copies is to be updated.
Furthermore, unorderedLinkedList is a class template, and we have passed the class dvdType as a parameter to this class.
That is, the class dvdListType is not a Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Because we are now dealing with a very specific data type, the class dvdListType is no longer required to be a template.
Thus, the info type of each node in the linked list is now dvdType.
Through the member functions of the class dvdType, certain members—such as  and of an object of type dvdType—can now be accessed.
The definitions of the functions to implement the operations of the class dvdListType are given next.
The primary operations on the  list are to check in a  and to check out a Both operations require the list to be searched and the location of the being checked in or checked out to be found in the  list.
Other operations, such as determining whether a particular  is in the store, updating the number of copies of a , and so on, also require the list to be searched.
To simplify the search process, we will write a function that searches the  list for a particular If the  is found, it sets a parameter found to true and returns a pointer to the  so that check-in, check-out, and other operations on the  object can be performed.
Note that the function searchDVDList is a private data member of the class dvdListType because it is used only for internal manipulation.
First, we describe the search procedure.
Consider the node of the  list shown in Figure 16-47.
In fact, the component info of the node has seven members: dvdTitle, movieStar1, movieStar2, movieProducer, movieDirector, movieProductionCo, and.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: DVD Store.
DVD list node showing components of info These member variables are all private and cannot be accessed directly.
The member functions of the class dvdType will help us in checking and/or setting the value of a particular component.
Suppose a pointer—say, current—points to a node in the DVD list (see Figure 16-49).
Pointer current and DVD list node Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Suppose that we want to know whether the title of the DVD stored in this node is the same as the title specified by the variable title.
The expression: is true if the title of the DVD stored in this node is the same as the title specified by the parameter title, and false otherwise.
Because  is a private member, it cannot be accessed directly.
Programming Example: DVD Store.
If it is unsuccessful,  is set to false and  will be nullptr.
The definitions of the other functions of the class dvdListType follow:.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: DVD Store.
COMPONENT Customer The customer object stores information about a customer, such as the first name, last Object name, account number, and a list of DVDs rented by the customer.
Every customer is a person.
We have already designed the class personType in Example 10-10 (Chapter 10) and described the necessary operations on the name of a person.
Therefore, we can derive the class customerType from the class personType and add the additional members that we need.
First, however, we must redefine the class personType to take advantage of the new  of objectoriented design that you have learned, such as operator overloading, and then derive the class customerType.
Recall that the basic operations on an object of type personType are: 1.
Print the name.
Set the name.
Show the first name.
Show the last name.
Similarly, the basic operations on an object of type customerType are: 1.
Print the name, account number, and the list of rented DVDs.
Set the name and the account number.
Rent a DVD; that is, add the rented DVD to the list.
Return a DVD; that is, delete the rented DVD from the list.
Show the account number.
The details of implementing the customer component are left as an exercise for you.
Main Program We will now write the main program to test the DVD object.
We assume that the necessary data for the DVDs are stored in a file.
We will open the file and create the Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The data in the input file is in the following form: movie star1 movie star2 movie producer movie director movie production co.
We will write a function, createDVDList, to read the data from the input file and create the list of DVDs.
We will also write a function, displayMenu, to show the different choices—such as check in a movie or check out a movie—that the user can make.
The algorithm of the function main is: 1.
Open the input file.
If the input file does not exist, exit the program.
Create the list of DVDs (createDVDList).
Show the menu (displayMenu).
While not done Perform various operations.
Opening the input file is straightforward.
Let us describe Steps 2 and 3, which are accomplished by writing two separate functions: createDVDList and displayMenu.
Because the data will be read from a file and the input file was opened in the function main, we pass the input file pointer to this function.
We also pass the DVD list pointer, declared in the function main, to this function.
Both parameters are reference parameters.
Next, we read the data for each DVD and then insert the DVD in the list.
The general algorithm is: a.
Read the data and store it in a DVD object.
Insert the DVD in the list.
Repeat steps a and b for each DVD's data in the file.
It contains the following output statements: Select one of the following: 1.
To check whether the store carries a particular DVD 2.
To check out a DVD Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: DVD Store 3.
To To To To To | 1147 check in a DVD check whether a particular DVD is in stock print only the titles of all the DVDs print a list of all the DVDs exit In pseudocode, Step 4 (of the main program) is: a.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Malik // // This program uses the classes dvdType and dvdListType to.
Programming Example: DVD Store.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: DVD Store.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
A linked list is a list of items, called nodes, in which the order of the nodes is determined by the address, called a link, stored in each node.
The pointer to a linked list—that is, the pointer to the first node in the list—is stored in a separate location called the head or first.
A linked list is a dynamic data structure.
The length of a linked list is the number of nodes in the list.
Item insertion and deletion from a linked list do not require data movement; only the pointers are adjusted.
A (single) linked list is traversed in only one direction.
The search on a linked list is sequential.
The first (or head) pointer of a linked list is always fixed, pointing to the first node in the list.
To traverse a linked list, the program must use a pointer different than the head pointer of the list, initialized to the first node in the list.
In a doubly linked list, every node has two links: one points to the next node and one points to the previous node.
A doubly linked list can be traversed in either direction.
In a doubly linked list, item insertion and deletion require the adjustment of two pointers in a node.
A linked list in which the last node points to the first node is called a circular linked list.
EXERCISES The number in parentheses at the end of an exercise refers to the learning objective listed at the beginning of the chapter.
Mark the  statements as true or false.
Every node in a linked list has two components: one to store the relevant In a linked list, the order of the elements is determined by the order in Suppose the nodes of a linked list are in the usual info-link form and points to a  of the linked list.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The two most common operations on iterators are plus_plus and * (the l.
The function search of the class unorderedLinkedList searches the linked list sequentially, while the function search of the class orderedLinkedList searches the list using a binary search algorithm 2.
Suppose that the fourth  of a linked list is to be deleted, and p points to the fourth Consider the linked list shown in Figure 16-50.
Assume that the nodes are in the usual info-link form.
Use this list to answer Exercises 6 through 14.
If necessary, declare additional variables.
Linked list for Exercises 6 through 14.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Set the info of the second  to 52.
Make trail point to the  before temp.
Make temp point to an empty list.
Set the value of the  before trail to 36.
Write a while loop to make current point to the  with info 10.
Mark each of the following statements as valid or invalid.
If a statement is a.
Write a Cplus_plus code so that current traverses the entire list.
Create the node with info 68 and insert it between trail and last.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
After deleting the node, make last point to the last node of the list and the link of the last node must be nullptr.
Delete the node with info 10.
Also, deallocate the memory occupied by this node.
Show what is produced by the following Cplus_plus code.
Assume the node is in the usual info-link form with the info of the type int.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Show what is produced by the following Cplus_plus code.
Assume the node is in the usual info-link form with the info of the type int.
Assume that the node of a linked  is in the usual info-link form with the info of type int.
The following data, as described in parts (a) to (d), is to be inserted into an initially linked : 72, 43, 8, 12.
Suppose that head is a pointer of type.
After the linked  is created, head should point to the first node of the.
Declare additional variables as you need them.
Write the Cplus_plus code to create the linked.
After the linked  is created, Insert 72 into an empty linked.
Insert 8 at the end of the.
Assume that the node of a linked  is in the usual info-link form with the info of type int.
Use the linked  created by this code to answer the following questions.
Determine the order of the nodes of the linked.
Write a Cplus_plus code that creates and inserts a node with info 45 after the node with info 16.
Write a Cplus_plus code that creates and inserts a node with info 58 before the node with info 25.
Does this require you to the change the value of the pointer that was pointing to the first node of the linked.
Write a Cplus_plus code that deletes the node with info 25.
Does this require you to the change the value of the pointer that was pointing to the first node of the linked.
How does the function insertFirst of the class unorderedLinkedList differ Consider the following Cplus_plus statements.
What is the output of this program segment.
Suppose the input is: 45 35 12 83 40 23 11 98 64 120 16 -999 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require.
Draw the UML diagram of the class doublyLinkedList as discussed in Draw the UML diagram of the class dvdType of the DVD Store programming example.
Draw the UML diagram of the class dvdListType of the DVD Store programming example.
PROGRAMMING EXERCISES 1.
Using linked lists, redo the program to handle as many entries as required.
Add the following operations to your program: Add or delete a new  to the address book.
Allow the user to save the data in the address book.
Extend the class linkedListType by adding the following operations: a.
Find and delete the node with the smallest info in the.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require.
Also, write a program to test these functions.
Extend the class linkedListType by adding the following operations: Write a function that returns the info of the kth element of the linked If no such element exists, terminate the program.
Write a function that deletes the k element of the linked.
If no such element exists, terminate the program.
Provide the definitions of these functions in the class linkedListType.
Also, write a program to test these functions.
Also, write a program function to print a (single) linked  backward.
Add the operation divideMid to the class  as follows: void divideMid(<Type> &sublist); //This operation divides the given  into two sublists //of (almost) equal sizes.
Write the definition of the function template to implement the operation divideMid.
Also, write a program to test your function.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require.
Add the following operation to the class : void divideAt(<Type> &secondList, const Type& item); //Divide the  at the node with the info item into two //sublists.
Write the definition of the function template to implement the operation divideAt.
Also, write a program to test your function.
Add the following operation to the class : void mergeLists(<Type> &1, <Type> &2); //This function creates a new  by merging the //elements of 1 and 2.
Also, after the preceding statement executes, 1 and 2 are empty.
Write the definition of the function template mergeLists to implement the operation mergeLists.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Rewrite the definition of the function insert so that before inserting the item, it checks whether the item to be inserted is already in the If the item to be inserted is already in the , the function outputs an appropriate error message.
Also, write a program to test your function.
In this chapter, the class to implement the nodes of a   is defined as a struct.
The following rewrites the definition of the struct  so that it is declared as a class and the member variables are private.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Also, write a program to test your class.
Programming Exercise 9 asks you to redefine the class to implement the nodes of a   so that the instance variables are private.
Therefore, the class linkedListType and its derived classes  and can no longer directly access the instance variables of the class.
Rewrite the definitions of these classes so that they use the member functions of the class  to access the  and fields of a node.
Also, write programs to test various operations of the classes and.
Write the definitions of the function copyList, the copy constructor, and the function to overload the assignment  for the class doublyLinkedList.
Write a program to test various operations of the class doublyLinkedList.
Write the definitions of the class circularLinkedList and its member functions.
Write a program to test various operations of the class defined in (a).
Complete the design and implementation of the class customerType defined in the DVD Store programming example.
Design and implement the class customerListType to create and maintain a  of customers for the DVD store.
In other words, write a program that uses the classes designed in the DVD Store programming example and in Programming Exercise 14 to make a DVD store operational.
Extend the class linkedListType by adding the following function: a.
Also write a program to test your function.
Use the class unorderedLinkedList to create a.
Write a program that prompts the user to input a string and then outputs the string in the pig Latin form.
The rules for converting a string into pig Latin form are described in Programming Example: Pig Latin Strings of Chapter 7.
Your program must store the characters of a string into a list and use the function rotate, as described in Programming Exercise 16, to rotate the string.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Also write the definition of the function splitEvensOddsList.
Note that this function does not create any new , it only rearranges the nodes of the original list so that nodes with even integers are in evensList and nodes with odd integers are in oddsList.
Write a program that uses class intLinkedList to create a linked list of integers and then uses the function splitEvensOddsList to split the list into two sublists.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Discover how to use queues to solve simulation problems Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Both stacks and queues have numerous applications in computer science.
Stacks Suppose that you have a program with several functions.
To be specific, suppose that you have functions A, B, C, and D in your program.
Now suppose that function A calls function B, function B calls function C, and function C calls function D.
When function D terminates, control goes back to function C; when function C terminates, control goes back to function B; and when function B terminates, control goes back to function A.
During program execution, how do you think the computer keeps track of the function calls.
What about recursive functions.
How does the computer keep track of the recursive calls.
In Chapter 16, we designed a recursive function to print a linked list backward.
What if you want to write a nonrecursive algorithm to print a linked list backward.
This section discusses the data structure called the stack, which the computer uses to implement function calls.
You can also use stacks to convert recursive algorithms into nonrecursive algorithms, especially recursive algorithms that are not tail recursive.
Stacks have numerous applications in computer science.
After developing the tools necessary to implement a stack, we will examine some applications of stacks.
A stack is a list of homogeneous elements in which the addition and deletion of elements occur only at one end, called the top of the stack.
For example, in a cafeteria, the second tray in a stack of trays can be removed only if the first tray has been removed.
For another example, to get to your favorite computer science book, which is underneath your math and history books, you must first remove the math and history books.
After removing these books, the computer science book becomes the top book—that is, the top element of the stack.
Figure 17-1 shows some examples of stacks.
Stack of boxes Stack of coins Stack of books Stack of trays 5 Applied Math World History Cplus_plus Programming English Chemistry FIGURE 17-1 Various types of stacks Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The top element of the stack is the last element added to the stack.
Because the elements are added and removed from one end (that is, the top), it follows that the item that is added last will be removed first.
For this reason, a stack is also called a Last In First Out (LIFO) data structure.
Stack: A data structure in which the elements are added and removed from one end only; a Last In First Out (LIFO) data structure.
Now that you know what a stack is, let us see what kinds of operations can be performed on a stack.
Because new  can be added to the stack, we can perform the add operation, called push, to add an element onto the stack.
Similarly, because the top item can be retrieved and/or removed from the stack, we can perform the operation top to retrieve the top element of the stack and the operation pop to remove the top element from the stack.
The push, top, and pop operations work as follows: Suppose there are boxes lying on the floor that need to be stacked on a table.
Initially, all of the boxes are on the floor, and the stack is empty (see Figure 17-2).
A D B C Empty stack E.
D Peek at the top element Push Box D.
Stack operations Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
After this push operation, the stack is as shown in Figure 17-3(b).
Next, we push box C onto the stack.
After this push operation, the stack is as shown in Figure 17-3(c).
Next, we look, that is, peek, at the top element of the stack.
After this operation, the stack is unchanged and shown in Figure 17-3(d).
We then push box D onto the stack.
After this push operation, the stack is as shown in Figure 17-3(e).
Next, we pop the stack.
After the pop operation, the stack is as shown in Figure 17-3(f ).
An element can be removed from the stack only if there is something in the stack, and an element can be added to the stack only if there is room.
The two operations that immediately follow from push, top, and pop are isFullStack (checks whether the stack is full) and isEmptyStack (checks whether the stack is empty).
Because a stack keeps changing as we add and remove elements, the stack must be empty before we first start using it.
Thus, we need another operation, called initializeStack, which initializes the stack to an empty state.
Therefore, to successfully implement a stack, we need at least these six operations, which are described in the next section.
We might also need other operations on a stack, depending on the specific implementation.
If the stack is full, it returns the value true; otherwise, it returns the value false.
If the stack is empty, it returns the value true; otherwise, it returns the value false.
The input to this operation consists of the stack and the new.
Prior to this operation, the stack must exist and must not be full.
Prior to this operation, the stack must exist and must not be full.
Prior to this operation, the stack must exist and must not be empty.
The following abstract class stackADT defines these operations as an ADT: template <class Type> class stackADT { public:.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
UML class diagram of the class stackADT We now consider the implementation of our abstract stack data structure.
Because all of the elements of a stack are of the same type, a stack can be implemented as either an array or a linked structure.
Both implementations are useful and are discussed in this chapter.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The first  of the stack can be put in the first array slot, the second  of the stack in the second array slot, and so on.
The top of the stack is the index of the last  added to the stack.
In this implementation of a stack, stack elements are stored in an array, and an array is a random access data structure; that is, you can directly access any  of the array.
However, by definition, a stack is a data structure in which the elements are accessed (popped or pushed) at only one end—that is, a Last In First Out data structure.
Thus, a stack  is accessed only through the top, not through the bottom or middle.
This feature of a stack is extremely important and must be recognized in the beginning.
To keep track of the top position of the array, we can simply declare another variable called stackTop.
The following class, stackType, implements the functions of the abstract class stackADT.
By using a pointer, we can dynamically allocate arrays, so we will leave it for the user to specify the size of the array (that is, the stack size).
We assume that the default stack size is 100.
Because the class  has a pointer member variable (the pointer to the array to store the stack elements), we must overload the assignment and include the copy constructor and destructor.
Moreover, we give a generic definition of the stack.
Depending on the specific application, we can pass the stack type when we declare a stack object.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Implementation of Stacks as Arrays.
The default stack size is 100.
Figure 17-5 shows the UML class diagram of the class.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
UML class diagram of the class Because Cplus_plus arrays begin with the index 0, we need to distinguish between the value of and the array position indicated by.
If  is 0, the stack is empty; if  is nonzero, then the stack is nonempty and the top element of the stack is given by  - 1.
Notice that the function copyStack is included as a private member.
This is because we want to use this function only to implement the copy constructor and overload the assignment.
To copy a stack into another stack, the program can use the assignment.
Figure 17-6 shows this data structure, wherein stack is an object of type.
Note that  can range from 0 to.
If  is nonzero, then - 1 is the index of the  element of the stack.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Implementation of Stacks as Arrays.
A 1 7 stack elements Example of a stack Note that the pointer list contains the base address of the array (holding the stack elements)—that is, the address of the first array component.
Next, we discuss how to implement the member functions of the class.
Initialize Stack Let us consider the initializeStack operation.
Because the value of indicates whether the stack is empty, we can simply set  to 0 to initialize the stack (see Figure 17-7).
A unused stack Empty stack Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Empty Stack We have seen that the value of  indicates whether the stack is empty.
If is 0, the stack is empty; otherwise, the stack is not empty.
The definition of the function isEmptyStack is: template <class Type>.
Push Adding, or pushing, an element onto the stack is a two-step process.
Recall that the value of  indicates the number of elements in the stack, and  - 1 gives the position of the top element of the stack.
Therefore, the push operation is as follows: 1.
Store the newItem in the array component indicated by.
Figures 17-8 and 17-9 illustrate the push operation.
Suppose that before the push operation, the stack is as shown in Figure 17-8.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Implementation of Stacks as Arrays.
After the push operation, the stack is as shown in Figure 17-9.
Stack after pushing y Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
If we try to add a new  to a full , the resulting condition is called an overflow.
Error checking for an overflow can be handled in different ways.
One way is as shown previously.
Or, we can check for an overflow before calling the function push, as shown next (assuming  is an object of type ).
Pop To remove, or pop, an element from the , we simply decrement  by 1.
Figures 17-10 and 17-11 illustrate the pop operation.
Suppose that before the pop operation, the  is as shown in Figure 17-10.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Implementation of Stacks as Arrays.
O [1] elements B.
Stack after popping D Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
If we try to remove an  from an empty , the resulting condition is called an underflow.
Error checking for an underflow can be handled in different ways.
One way is as shown in the definition of the function pop.
Or, we can check for an underflow before calling the function pop, as shown next (assuming  is an object of type ).
The  to be copied is passed as a parameter to the function copyStack.
We will, in fact, use this function to implement the copy constructor and overload the assignment operator.
The definition of this function is: template <class >.
Constructor and Destructor The functions to implement the constructor and the destructor are straightforward.
The constructor with parameters sets the  size to the size specified by the user, sets to 0, and creates an appropriate array in which to store the  elements.
If the user does not specify the size of the array in which to store the  elements, the constructor uses the default value, which is 100, to create an array of size 100.
The destructor simply deallocates the memory occupied by the array (that is, the ) and sets  to 0.
The definitions of the constructor and destructor are: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Implementation of Stacks as Arrays.
Copy Constructor The copy constructor is called when a  object is passed as a (value) parameter to a function.
It copies the values of the member variables of the actual parameter into the corresponding member variables of the formal parameter.
Its definition is: template <class >.
Recall that for classes with pointer member variables, the assignment  must be explicitly overloaded.
The definition of the function to overload the assignment for the class  is: template <class > const <>& <>::= Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Stack Header File Now that you know how to implement the  operations, you can put the definitions of the class and the functions to implement the  operations together to create the header file.
For the sake of completeness, we next describe the header file.
We will refer to  header file in any program that uses a.
Implementation of Stacks as Arrays.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Implementation of Stacks as Arrays.
EXAMPLE 17-1 Before we give a programming example, let us first write a simple program that uses the class  and tests some of the  operations.
Among others, we will test the assignment  and the copy constructor.
The program and its output are as follows: //Program to test the various operations of a.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The  element of otherStack: 38 The original  is not empty.
The  element of the original : 38 The elements of : 38 45 23 It is recommended that you do a walk-through of  program.
PROGRAMMING EXAMPLE: Watch the Video Highest GPA In  example, we write a Cplus_plus program that reads a data file consisting of each student's GPA followed by the student's name.
The program then prints the highest GPA and the names of all of the students who received that GPA.
The program scans the input file only once.
Moreover, we assume that there is a maximum of 100 students in the class.
Input 3_0_4 3_0_2 2_0_5 3_0_4 3_0_8 3_0_8 3_0_6 The program reads an input file consisting of each student's GPA, followed by the student's name.
Sample data is: Randy Kathy Colt Tom Ron Mickey Peter Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: Highest GPA Output PROBLEM ANALYSIS AND ALGORITHM DESIGN | 1185 The highest  and all of the names associated with the highest.
For example, for the above data, the highest  is 3_0_8, and the students with that  are Ron and Mickey.
We read the first  and the name of the student.
Because  data is the first item read, it is the highest  so far.
Next, we read the second  and the name of the We then compare  (second)  with the highest  so far.
Three cases arise: 1.
The new  is greater than the highest  so far.
In  case, we: a.
Update the value of the highest  so far.
Initialize the —that is, remove the names of the students from the.
Save the name of the  having the highest  so far in the.
The new  is equal to the highest  so far.
In  case, we add the name of the new  to the stack.
The new  is smaller than the highest  so far.
In  case, we discard the name of the  having  grade.
We then read the next  and the name of the  and repeat Steps 1 through 3.
We continue  process until we reach the end of the input file.
From  discussion, it is clear that we need the following variables:.
Declare the variables and initialize stack.
Open the input file.
If the input file does not exist, exit the program.
Set the output of the floating-point numbers to a fixed decimal format with a decimal point and trailing zeroes.
Also, set the precision to two decimal places.
Read the  and the  name.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sample Run: 3_0_4 3_0_2 2_0_5 3_0_4 3_0_8 3_0_8 3_0_6 3_0_5 3_0_8 3_0_7 3_0_9 3_0_8 3_0_9 2_0_7 3_0_9 3_0_4 Randy Kathy Colt Tom Ron Mickey Peter Donald Cindy Dome Andy Fox Minnie Gilda Vinay Danny Output = 3_0_90 The students holding the highest  : Vinay Minnie Andy Note that the names of the students with the highest   output in the reverse order, relative to the order they appear in the input, due to the fact that the element of the stack is the last element added to the stack.
Linked Implementation of Stacks Because an array size is , in the array (linear) representation of a stack, only a number of elements can be pushed onto the stack.
If in a program the number of elements to be pushed exceeds the size of the array, the program may terminate in an error.
We must overcome these problems.
We have seen that by using pointer variables, we can dynamically allocate and deallocate memory, and by using linked lists, we can dynamically organize data (such as an ordered list).
Next, we will use these concepts to implement a stack dynamically.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Linked Implementation of Stacks.
With the help of stackTop, we can do several things: find the  element, check whether the stack is empty, and so on.
Similar to the linear representation, in a linked representation, stackTop is used to locate the  element in the stack.
However, there is a slight difference.
In the former case, stackTop gives the index of the array.
In the latter case, stackTop gives the address (memory location) of the  element of the stack.
The following class implements the functions of the abstract class stackADT: //Definition of the node template <class >.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Logically, the stack is never full.
The stack is full only if we run out of memory space.
Therefore, in reality, the function isFullStack does not apply to linked implementation of stacks.
However, the class  must provide the definition of the function isFullStack, because it is defined in the parent abstract class stackADT.
We leave the UML class diagram of the class  as an exercise for you.
EXAMPLE 17-2 Suppose that stack is an object of type.
Figure 17-12(a) shows an empty stack, and Figure 17-12(b) shows a nonempty stack.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Linked Implementation of Stacks.
Empty and nonempty linked stack In Figure 17-12(b), the top element of the stack is C; that is, the last element pushed onto the stack is C.
Next, we discuss the definitions of the functions to implement the operations of a linked stack.
Default Constructor The first operation that we consider is the default constructor.
The default constructor initializes the stack to an empty state when a stack object is declared.
Thus, this function sets  to nullptr.
The definition of this function is: template <class >.
Empty Stack and Full Stack The operations isEmptyStack and isFullStack are quite straightforward.
The stack is empty if  is nullptr.
Also, because the memory for a stack element is allocated and deallocated dynamically, the stack is never full.
The definitions of the functions to implement these operations are: template <class > bool <>::isEmptyStack() const Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
However, you must provide its definition because it is included as an abstract function in the parent class stackADT.
Initialize Stack The operation initializeStack reinitializes the stack to an empty state.
Because the stack may contain some elements and we are using a linked implementation of a stack, we must deallocate the memory occupied by the stack elements and set  to nullptr.
The definition of this function is: template <class >.
In the case of pop, the node pointed to by  will be removed.
In both cases, the value of the pointer  is updated.
The operation top returns the info of the node that  is pointing to.
Push Consider the stack shown in Figure 17-13.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Linked Implementation of Stacks.
A (a) Create newNode and store D FIGURE 17-14.
B A (b) Put  on the top of stack (c) Make  point to the top Push operation.
See Figure 17-14(a).
Return the Top Element The operation to return the top  of the stack is quite straightforward.
Its definition is: template <class Type>.
Now we consider the pop operation, which removes the top  of the stack.
Consider the stack shown in Figure 17-15.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Linked Implementation of Stacks.
Figure 17-16 shows the pop operation.
C stack B.
A (a) Make temp point to the top B (b) Make  point to the next B.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
See Figure 17-16(c).
Copy Stack The function copyStack makes an identical copy of a.
Its definition is similar to the definition of copyList for linked lists, given in Chapter 16.
The definition of the function copyStack is: template <class Type> void <Type>::copyStack.
Constructors and Destructors We have already discussed the default constructor.
To complete the implementation of the  operations, next we give the definitions of the functions to implement the copy constructor and the destructor and to overload the assignment operator.
The definition of the function to overload the assignment  for the class is: template <class > const <>& <>::= Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The definition of a  and the functions to implement the  operations discussed previously are generic.
Also, as in the case of an array representation of a , in the linked representation of a , we must put the definition of the  and the functions to implement the  operations together in a (header) file.
A client's program can header file via the  statement.
Example 17-3 illustrates how a linkedStack object is used in a program.
EXAMPLE 17-3 We assume that the definition of the class  and the functions to implement the  operations are included in the header file "linkedStack_0_h".
Linked Implementation of Stacks.
Sample Run: After the assignment , : 27 43 34 Testing the copy.
Stack in the function : 27 43 34 After the copy , : 27 43 34 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
A comparison of other functions—such as initializeStack and initializeList, isEmptyList and isEmptyStack, and so on—suggests that the class  can be derived from the class linkedListType.
Moreover, the functions pop and isFullStack can be implemented as in the previous section.
Note that the class linkedListType is an abstract and does not implement all of the operations.
However, the class unorderedLinkedListType is derived from the class linkedListType and provides the definitions of the abstract functions of the class linkedListType.
Therefore, we can derive the class from the class unorderedLinkedListType.
Next, we define the class  that is derived from the class unorderedLinkedList.
The definitions of the functions to implement the  operations are also given.
Application of Stacks: Postfix Expressions Calculator |.
Application of Stacks: Postfix Expressions Calculator The usual notation for writing arithmetic expressions (the notation we learned in elementary school) is called infix notation, in which the  is written between the operands.
For example, in the expression a + b, the  + is between the operands a and b.
In infix notation, the operators have precedence.
That is, we must evaluate expressions from left to right, and multiplication and division have higher precedence than do addition and subtraction.
If we want to evaluate the expression in a different order, we must parentheses.
For example, in the expression a + b * c, we  evaluate * using the operands b and c, and then we evaluate + using the operand a and the result of b * c.
In the early 1920s, the Polish mathematician Jan Lukasiewicz discovered that if operators were written before the operands (prefix or Polish notation; for example, + a b), the parentheses could be omitted.
In the late 1950s, the Australian philosopher and early computer scientist Charles L.
Hamblin proposed a scheme in which the operators follow the operands (postfix operators), resulting in the Reverse Polish notation.
This has the advantage that the operators appear in the order required for computation.
For example, the expression: a+b*c in a postfix expression is: abc*+ The following example shows various infix expressions and their equivalent postfix expressions.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
In fact, many compilers now  translate arithmetic expressions into some form of postfix notation and then translate this postfix expression into machine code.
Postfix expressions can be evaluated using the following algorithm: Scan the expression from left to right.
When an operator is found, back up to get the required number of operands, perform the operation, and continue.
Consider the following postfix expression: 63+2*= Let us evaluate this expression using a stack and the previous algorithm.
Figure 17-17 shows how this expression gets evaluated.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Application of Stacks: Postfix Expressions Calculator | 1203 Read the first , 6, which is a number.
Push the number onto the stack (see Figure 17-17(a)).
Read the next , 3, which is a number.
Push the number onto the stack (see Figure 17-17(b)).
Read the next , +, which is an operator.
Because an operator requires two operands to be evaluated, pop the stack twice (see Figure 17-17(c)).
Perform the operation and put the result back onto the stack (see Figure 17-17(d)).
Read the next , 2, which is a number.
Push the number onto the stack (see Figure 17-17(e)).
Read the next , *, which is an operator.
Because an operator requires two operands to be evaluated, pop the stack twice (see Figure 17-17(f )).
Perform the operation, and put the result back onto the stack (see Figure 17-17(g)).
Scan the next , =, which  the equal sign, indicating the end of the.
Therefore, print the result.
The result of the   in the stack, so pop and print (see Figure 17-17(h)).
From this discussion, it  clear that when we read a  other than a number, the following cases arise: 1.
The  we read  one of the following: +, -, *, /,  =.
If the   +, -, *,  /, the   an operator, so we must evaluate it.
Because an operator requires two operands, the stack must have at least two elements; otherwise, the  has an error.
If the   = (an equal sign), the  ends and we must print the answer.
At this step, the stack must contain exactly one element; otherwise, the  has an error.
In this case, the  contains an illegal operator.
It  also clear that when an operand (number)  encountered in an , it pushed onto the stack because the operator comes after the operands.
Consider the following expressions: 7 6 + 3 ; 6 - = 14 + 2 3 * = 14 2 3 + = () has an illegal operator,  () does not have enough operands for +, and  () has too many operands.
In the case of  (), when we encounter the equal  (=), the stack will have two elements, and this error cannot be discovered until we are ready to print the value of the.
To make the input easier to read, we assume that the postfix expressions are in the following form: #6 #3 + #2 * = Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned,  duplicated, in whole  in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/ eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
If the  scanned  #, then the next input   number (that , an operand).
If the  scanned  not #, then it either an operator (may be illegal)  an equal  (indicating the end of the ).
Furthermore, we assume that each  contains only the +, -, *, and / operators.
This program outputs the entire postfix  together with the answer.
If the has an error, the   discarded.
In this case, the program outputs the  together with an appropriate error message.
Because an  may contain an error, we must clear the stack before processing the next.
Also, the stack must be initialized; that , the stack must be empty.
Main Algorithm Following the previous discussion, the main algorithm in pseudocode : Read the first character while not the end of input data { initialize the stack process the output result d.
The function evaluateExpression, if possible, evaluates the  and leaves the result in the stack.
If the postfix   error free, the function printResult outputs the result.
The function evaluateOpr evaluates an operator, and the function discardExp discards the current  if there  any error in the.
Function evaluateExpression The function evaluateExpression evaluates each postfix.
The general algorithm : while (ch   = '=') //process each //= marks the end of an { {.
Application of Stacks: Postfix Expressions Calculator |.
The definition of this function : void evaluateExpression(ifstream& inpF, ofstream& outF, stackType<double>& stack, { double ;.
Editorial review has deemed that any suppressed content does  materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Note that the function exit  the program.
Function evaluateOpr This function (if possible) evaluates an expression.
Two operands are needed to evaluate an operation, and operands are saved in the stack.
Therefore, the stack must contain at least two numbers.
If the stack contains fewer than two numbers, then the expression has an error.
In this case, the entire expression is discarded, and an appropriate message is printed.
This function also checks for any illegal operations.
In pseudocode, this function is: if stack is empty { error in the expression set expressionOk to false } else { retrieve the top element of stack into op2 pop stack if stack is empty { error in the expression set expressionOk to false } else { retrieve the top element of stack into op1 pop stack //If the operation is legal, perform the //operation and push the result onto the stack.
Application of Stacks: Postfix Expressions Calculator |.
All Rights Reserved.
May  be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does  materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Function discardExp This function  called whenever an error  discovered in the expression.
It reads and writes the input data only until the input  '=', the end of the expression.
The def inition of this function :.
Function printResult the postfix expression contains no errors, the function printResult prints the result; otherwise, it outputs an appropriate message.
The result of the expression  in the stack, and the output  sent to a file.
Therefore, this function must have access to the stack and the output file.
Suppose that no errors were encountered by the method evaluateExpression.
In this case, this method outputs an appropriate error message.
The definition of this method : void printResult(ofstream& , stackType<double>& stack,.
Application of Stacks: Postfix Expressions Calculator |.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sample Run: Input File #35 #27 + #3 * = #26 #28 + #32 #2 ; - #5 / = #23 #30 #15 * / = #2 #3 #4 + = #20 #29 #9 * ; = #25 #23 - + = #34 #24 #12 #7 / * + #23 - = Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Removing Recursion: Nonrecursive Algorithm to Print a Linked List Backward | 1211 Output #35_0_00 #27_0_00 + #3_0_00 * = 186_0_00 _________________________________ _________________________________ #23_0_00 #30_0_00 #15_0_00 * / = 0_0_05 _________________________________ 1 7 _________________________________ _________________________________ _________________________________ #34_0_00 #24_0_00 #12_0_00 #7_0_00 / * + #23_0_00 - = 52_0_14 _________________________________ Removing Recursion: Nonrecursive Algorithm to Print a Linked List Backward In Chapter 16, we used recursion to print a linked list backward.
In this section, you will learn how a stack can be used to design a nonrecursive algorithm to print a linked list backward.
Consider the linked list shown in Figure 17-18.
Linked list To print the list backward, first we need to get to the last node of the list, which we can do by traversing the linked list starting at the first node.
However, once we are at the last node, how do we get back to the previous node, especially given that links go in only one direction.
You can again traverse the linked list with the appropriate loop termination condition, but this approach might waste a considerable amount of computer time, especially if the list very large.
Moreover, if we do this for every node in the list, the program might execute very slowly.
Next, we show how to use a stack effectively to print the list backward.
After printing the info of a particular node, we need to move to the node immediately behind this node.
For example, after printing 15, we need to move to the node with Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Thus, while initially traversing the list to move to the last node, we must save a pointer to each node.
For example, for the list in Figure 17-18, we must save a pointer to each of the nodes with info 5 and 10.
After printing 15, we go back to the node with info 10; after printing 10, we go back to the node with info 5.
From this, it follows that we must save pointers to each node in a stack, so as to implement the Last In First Out principle.
Because the number of nodes in a linked list is usually not known, we will use the linked implementation of a stack.
Suppose that stack is an object of type linkedListType, and  is a pointer of the same type as the pointer first.
Consider the following statements:.
Because  is not nullptr, the statements in Lines 3 and 4 execute (see Figure 17-20).
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Removing Recursion: Nonrecursive Algorithm to Print a Linked List Backward | 1213 After the statement in Line 4 executes, the loop condition in Line 2 is reevaluated.
Because  is not nullptr, the loop condition evaluates to true, so the statements in Lines 3 and 4 execute (see Figure 17-21).
FIGURE 17-21 List and stack after the statements stack_0_push(); and  = currentarrow_operatorlink; execute After the statement in Line 4 executes, the loop condition, in Line 2, is evaluated again.
Because  is not nullptr, the loop condition evaluates to true, so the statements in Lines 3 and 4 execute (see Figure 17-22).
Because  is nullptr, the loop condition evaluates to false, and the while loop Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
From Figure 17-22, it follows that a pointer to each node in the linked list is saved in the stack.
The top element of the stack contains a pointer to the last.
The statement in Line 7 removes the top element of the stack (see Figure 17-23).
Next, the loop condition in Line 5 is evaluated.
Because the loop condition evaluates to true, the statements in Lines 6, 7, and 8 execute.
After the statements in Lines 6 and 7 execute, Figure 17-24 results.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Next, the loop condition in Line 5 is evaluated.
Because the loop condition evaluates to true, the statements in Lines 6, 7, and 8 execute.
After the statements in Lines 6 and 7 execute, Figure 17-25 results.
Next, the loop condition in Line 5 is evaluated.
Because the loop condition evaluates to false, the while loop terminates.
The while loop in Line 5 produces the following output: 15 10 5 Queues This section discusses another important data structure called a queue.
The notion of a queue in computer science is the same as the notion of the queues to which you are accustomed in everyday life.
There are queues of customers in a bank or in a grocery store and queues of cars waiting to pass through a tollbooth.
Similarly, because a computer can send a print request faster than a printer can print, a queue of documents is often waiting to be printed at a printer.
The general rule to process elements in a queue is that the at the front of the queue is served next, and when a new  arrives, he or she stands at the end of the queue.
That is, a queue is a First In First Out data structure.
Queues have numerous applications in computer science.
Whenever a system is modeled on the First In First Out principle, queues are used.
At the end of this section, we will discuss one of the most widely used applications of queues, computer simulation.
First, however, we need to develop the tools necessary to implement a queue.
The next few sections discuss how to design classes to implement queues as an ADT.
A queue is a set of elements of the same type in which the elements are added at one end, called the back or rear, and deleted from the other end, called the front.
For example, consider a line of customers in a bank, wherein the customers are waiting to withdraw/ deposit money or to conduct some other business.
Each new  gets in the line at the rear.
Whenever a teller is ready for a new , the  at the front of the line is served.
The rear of the queue is accessed whenever a new  is added to the queue, and the front of the queue is accessed whenever an  is deleted from the queue.
As in a Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Queue: A data structure in which the elements are added at one end, called the rear, and deleted from the other end, called the front; a First In First Out (FIFO) data structure.
Queue Operations From the definition of queues, we see that the two key operations are add and delete.
We call the add operation addQueue and the delete operation deleteQueue.
Because elements can be neither deleted from an empty queue nor added to a full queue, we need two more operations to successfully implement the addQueue and deleteQueue operations: isEmptyQueue (checks whether the queue is empty) and isFullQueue (checks whether a queue is full).
We also need an operation, initializeQueue, to initialize the queue to an empty state.
Moreover, to retrieve the first and last elements of the queue, we include the operations front and back, as described in the following list.
Some of the queue operations are:.
If the queue is full, it returns the value true; otherwise, it returns the value false.
Input to isEmptyQueue: Determines whether the queue is empty.
If the queue is empty, it returns the value true; otherwise, it returns the value false.
Prior to this operation, the queue must exist and must not be empty.
Input to this operation consists of the queue.
Prior to this operation, the queue must exist and must not be empty.
Input to this operation consists of the queue and the new.
Prior to this operation, the queue must exist and must not be full.
Input to this operation consists of the queue.
Prior to this operation, the queue must exist and must not be empty.
As in the case of a stack, a queue can be stored in an array or in a linked structure.
We will consider both implementations.
Because elements are added at one end and removed from the other end, we need two pointers to keep track of the front and rear of the queue, called queueFront and queueRear.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
We leave it as an exercise for you to draw the UML class diagram of the class queueADT.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Of course, we need an array to store the queue elements, the variables queueFront and queueRear to keep track of the first and last elements of the queue and the variable maxQueueSize to specify the maximum size of the queue.
Thus, we need at least four member variables.
Before writing the algorithms to implement the queue operations, we need to decide how to use queueFront and queueRear to access the queue elements.
How do queueFront and queueRear indicate that the queue is empty or full.
Suppose that queueFront gives the index of the first  of the queue, and queueRear gives the index of the last  of the queue.
To add an  to the queue, first we advance queueRear to the next array position, and then we add the  to the position that queueRear is pointing to.
To delete an  from the queue, first we retrieve the that queueFront is pointing to, and then we advance queueFront to the next of the queue.
Thus, queueFront changes after each  operation, and queueRear changes after each addQueue operation.
Let's see what happens when queueFront changes after a  operation and queueRear changes after an addQueue operation.
Assume that the array to hold the queue elements is of size 100.
Initially, the queue is empty.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Queues [0] [1] [2] [3] A FIGURE 17-27.
Queue after the  operation Will this queue design work.
Suppose A stands for adding (that is, addQueue) an element to the queue, and D stands for deleting (that is, ) an element from the queue.
Consider the following sequence of operations: AAADADADADADADADA_0__0_.
This sequence of operations would eventually set the index queueRear to point to the last array position, giving the impression that the queue is full.
However, the queue has only two or three elements, and the front of the array is empty (see Figure 17-29).
Queue after the sequence of operations AAADADADADADA.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
If the value of queueFront indicates that there is room in the front of the array, then when queueRear gets to the last array position, we can slide all of the queue elements toward the first array position.
This solution is good if the queue size is very small; otherwise, the program may execute more slowly.
Another solution to this problem is to assume that the array is circular—that is, the first array position immediately follows the last array position (see Figure 17-30).
FIGURE 17-30 Circular queue We will consider the array containing the queue to be circular, although we will draw the figures of the array holding the queue elements as before.
Suppose that we have the queue as shown in Figure 17-31(a).
X Y queueFront 98 queueRear 0 (b) After addQueue(Queue,'Z');.
After the operation addQueue(Queue,'Z');, the queue is as shown in Figure 17-31(b).
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
In this case,  will be set to 0, which is the first array position.
This queue design seems to work well.
Before we write the algorithms to implement the queue operations, consider the following two cases.
Case 1: Suppose that after certain operations, the array containing the queue is as shown in Figure 17-32(a).
Queue before and after the delete operation After the operation deleteQueue();, the resulting array is as shown in Figure 17-32(b).
Case 2: Let us now consider the queue shown in Figure 17-33(a).
Z queue elements queueFront 99  97.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
This latest queue design has brought up another problem of distinguishing between an empty and a full queue.
This problem has several solutions.
One solution is to keep a count.
In addition to the member variables  and , we need another variable, count, to implement the queue.
The value of count is incremented whenever a new  is added to the queue, and it is decremented whenever an  is removed from the queue.
In this case, the function initializeQueue initializes count to 0.
This solution is very useful if the user of the queue frequently needs to know the number of elements in the queue.
Another solution is to let  indicate the index of the array position preceding the first  of the queue, rather than the index of the (actual) first  itself.
In this case, assuming  still indicates the index of the last  in the queue, the queue is empty if  ==.
In this solution, the slot indicated by the index  (that is, the slot preceding the first true ) is reserved.
The queue will be full if the next available space is the special reserved slot indicated by Finally, because the array position indicated by  is to be kept empty, if the array size is, say, 100, then 99 elements can be stored in the queue (see Figure 17-34).
Array to store the queue elements with a reserved slot Let us implement the queue using the first solution.
That is, we use the variable count to indicate whether the queue is empty or full_0_The following class implements the functions of the abstract class queueADT.
Because arrays can be allocated dynamically, we will leave it for the user to specify the size of the array to implement the queue.
The default size of the array is 100.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Next, we consider the implementation of the queue operations.
EMPTY QUEUE AND FULL QUEUE As discussed earlier, the queue is empty if  == 0, and the queue is full if  == maxQueueSize.
So the functions to implement these operations are: template <class >.
INITIALIZE QUEUE This operation initializes a queue to an empty state.
The first  is added at the first array position.
Therefore, we initialize  to 0, queueRear to maxQueueSize - 1, and  to 0 (see Figure 17-35).
FRONT This operation returns the first element of the queue.
If the queue is nonempty, the element of the queue indicated by the index  is returned; otherwise, the program terminates.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
BACK This operation returns the last element of the queue.
If the queue is nonempty, the element of the queue indicated by the index  is returned; otherwise, the program terminates.
Because  points to the last of the queue, to add a new  to the queue, we first advance to the next array position and then add the new  to the array position indicated by.
So the function addQueue is: template <class >.
Because points to the array position containing the first  of the , in order to remove the first  , we decrement  by 1 and advance to the next.
So the function deleteQueue is: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
CONSTRUCTORS AND DESTRUCTORS To complete the implementation of the  operations, we next consider the implementation of the constructor and the destructor.
The constructor gets the maxQueueSize from the user, sets the variable maxQueueSize to the value specified by the user, and creates an array of size maxQueueSize.
If the user does not specify the  size, the constructor uses the default value, which is 100, to create an array of  100.
The constructor also initializes  and  to indicate that the  is empty.
The definition of the function to implement the constructor is: template <class Type> {.
The array to store the  elements is created dynamically.
Therefore, when the object goes out of scope, the destructor simply deallocates the memory occupied by the array that stores the  elements.
The definition of the function to implement the destructor is: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Also, the array implementation of the requires the array to be treated in a special way together with the values of the indices and.
The linked implementation of a  simplifies many of the special cases of the array implementation and, because the memory to store a is allocated dynamically, the  is never full.
This section discusses the linked implementation of a.
Because elements are added at one end and removed from the other end, we need to know the front of the  and the rear of the.
Thus, we need two pointers, and , to maintain the.
The following class implements the functions of the abstract class queueADT: //Definition of the node template <class >.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The UML class diagram of the class  is left as an exercise for you.
Next, we write the definitions of the functions of the class.
EMPTY AND FULL QUEUE The  is empty if  is nullptr.
Memory to store the  elements is allocated dynamically.
Therefore, the  is never full, so the function to implement Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Note that in reality, in the linked implementation of queues, the function isFullQueue does not apply because, logically, the  is never full.
However, you must provide its definition because it is included as an abstract function in the parent class queueADT.
INITIALIZE QUEUE The operation initializeQueue initializes the  to an empty state.
The  is empty if there are no elements in the.
Note that the constructor initializes the when the  object is declared.
So this operation must remove all of the elements, if any, from the.
Therefore, this operation traverses the  containing the  starting at the first node, and it deallocates the memory occupied by the elements.
The definition of this function is: template <class >.
The addQueue operation adds a new  at the end of the queue.
To implement this operation, we access the pointer.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
If the queue is empty, the function front terminates the program.
If the queue is nonempty, the operation back returns the last  of the queue, so the  of the queue indicated by the pointer  is returned.
If the queue is empty, the function back terminates the program.
Similarly, if the queue is nonempty, the operation deleteQueue removes the first  of the queue, so we access the pointer.
The definitions of the functions to implement these operations are: template <class >.
When the  object goes out of scope, the destructor destroys the ; that is, it deallocates the memory occupied by the elements of the.
The definition of the function to implement the destructor is similar to the definition of the function initializeQueue.
Also, the functions to implement the copy constructor and overload the assignment operators are similar to the corresponding functions for stacks.
Implementing these operations is left as an exercise for you.
EXAMPLE 17-5 The following program tests various operations on a.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Queue Elements: 5 9 16 4 2 Queue Derived from the class unorderedLinkedListType From the definitions of the functions to implement the  operations, it is clear that the linked implementation of a  is similar to the implementation of a linked list created in a forward manner (see Chapter 16).
The addQueue operation is similar to the operation insertFirst.
Likewise, the operations initializeQueue and initializeList and isEmptyQueue and isEmptyList are similar.
The deleteQueue operation can be implemented as before.
The pointer  is the same as the pointer first, and the pointer  is the same as the pointer last.
This correspondence suggests that we can derive the class to implement the  from the class linkedListType (see Chapter 16).
Note that the class linkedListType is an abstract class and does not implement all of the operations.
However, the class unorderedLinkedListType is derived from the class linkedListType and provides the definitions of the abstract functions of the class linkedListType.
Therefore, we can derive the class  from the class unorderedLinkedListType.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Application of Queues: Simulation.
See Programming Exercise 17 at the end of this chapter.
Application of Queues: Simulation A technique in which one system models the behavior of another system is called simulation.
For example, physical simulators  wind tunnels used to experiment with the design of car bodies and flight simulators used to train airline pilots.
Simulation techniques are used when it is too expensive or dangerous to experiment with real systems.
You can also design computer models to study the behavior of real systems.
Simulating the behavior of an expensive or dangerous experiment using a computer model is usually less expensive than using the real system and is a good way to gain insight without putting human life in danger.
Moreover, computer simulations are particularly useful for complex systems when it is difficult to construct a mathematical model.
For such systems, computer models can retain descriptive accuracy.
In computer simulations, the steps of a program are used to model the behavior of a real system.
Let us consider one such problem.
The manager of a local movie theater is hearing complaints from customers about the length of time they have to wait in line to buy tickets.
The theater currently has only one cashier.
Another theater is preparing to open in the neighborhood, and the manager is afraid of losing customers.
The manager wants to hire enough cashiers so that a customer does not have to wait too long to buy a ticket but does not want to hire extra cashiers on a trial basis and potentially waste time and money.
One thing that the manager would like to know is the average time a customer has to wait for service.
The manager wants someone to write a program to simulate the behavior of the theater.
In computer simulation, the objects being studied are usually represented as data.
For the theater problem, some of the objects are the customers and the cashier.
The cashier serves the customers, and we want to determine a customer's average waiting time.
Actions are implemented by writing algorithms, which in a programming language are implemented with the help of functions.
Thus, functions are used to implement the actions of the objects.
In Cplus_plus, we can combine the data and the operations on that data into a single unit with the help of classes.
Thus, objects can be represented as classes.
The member variables of the class describe the properties of the objects, and the function members describe the actions on that data.
This change in simulation results can also occur if we change the values of the data or modify the definitions of the functions (that is, modify the algorithms implementing the actions).
The main goal of a computer simulation is to either generate results showing the performance of an existing system or predict the performance of a proposed system.
In the theater problem, when the cashier is serving a customer, the other customers must wait.
Because customers are served on a first come, first served basis and queues are an Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
This section examines computer simulations in which queues are the basic data structure.
These simulations model the behavior of systems, called queuing systems, in which queues of objects are waiting to be served by various servers.
In other words, a queuing system consists of servers and queues of objects waiting to be served.
We deal with a variety of queuing systems on a daily basis.
For example, a grocery store and a banking system are both queuing systems.
Furthermore, when you send a print request to a networked printer that is shared by many people, your print request goes in a.
Print requests that arrived before your print request are usually completed before yours.
Thus, the printer acts as the server when a  of documents is waiting to be printed.
Designing a Queuing System In this section, we describe a queuing system that can be used in a variety of applications, such as a bank, grocery store, movie theater, printer, or a mainframe environment in which several people are trying to use the same processors to execute their programs.
To describe a queuing system, we use the term server for the object that provides the service.
For example, in a bank, a teller is a server; in a grocery store or movie theater, a cashier is a server.
We will call the object receiving the service the customer, and the service time—the time it takes to serve a customer—the transaction time.
Because a queuing system consists of servers and a queue of waiting objects, we will model a system that consists of a list of servers and a waiting queue holding the customers to be served.
The customer at the  of the queue waits for the next available server.
When a server becomes free, the customer at the  of the queue moves to the free server to be served.
When the first customer arrives, all servers are free and the customer moves to the first server.
When the next customer arrives, if a server is available, the customer immediately moves to the available server; otherwise, the customer waits in the queue.
To model a queuing system, we need to know the number of servers, the expected arrival time of a customer, the time between the arrivals of customers, and the number of events affecting the system.
Let us again consider the movie theater system.
The performance of the system depends on how many servers are available, how long it takes to serve a customer, and how often a customer arrives.
If it takes too long to serve a customer and customers arrive frequently, then more servers are needed.
This system can be modeled as a time-driven simulation.
In a time-driven simulation, the clock is implemented as a counter, and the passage of, say, one minute can be implemented by incrementing the counter by 1.
The simulation is run for a fixed amount of time.
If the simulation needs to be run for 100 minutes, the counter starts at 1 and goes up to 100, which can be implemented by using a loop.
For the simulation described in this section, we want to determine the average wait time for a customer.
To calculate the average wait time for a customer, we need to add the waiting Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Application of Queues: Simulation.
When a customer arrives, he or she goes to the end of the queue and the customer's waiting time begins.
If the queue is empty and a server is free, the customer is served immediately, so this customer's waiting time is zero.
On the other hand, if a customer arrives and either the queue is nonempty or all of the servers are busy, the customer must wait for the next available server and, therefore, this customer's waiting time begins.
We can keep track of the customer's waiting time by using a timer for each customer.
When a customer arrives, the timer is set to 0, which is incremented after each time unit.
Suppose that, on average, it takes five minutes for a server to serve a customer.
When a server becomes free and the waiting customer's queue is nonempty, the customer at the front of the queue proceeds to begin the transaction.
Thus, we must keep track of the time a customer is with a server.
When the customer arrives at a server, the transaction time is set to five and is decremented after each time unit.
When the transaction time becomes zero, the server is marked free.
Hence, the two objects needed to implement a time-driven computer simulation of a queuing system are the customer and the server.
Next, before designing the main algorithm to implement the simulation, we design classes to implement each of the two objects: customer and server.
Customer Every customer has a customer number, arrival time, waiting time, transaction time, and departure time.
If we know the arrival time, waiting time, and transaction time, we can determine the departure time by adding these three times.
Let us call the class to implement the customer object customerType.
It follows that the class customerType has four member variables: the customerNumber, arrivalTime, waitingTime, and transactionTime, each of the data type int.
The basic operations that must be performed on an object of type customerType are as follows: set the customer's number, arrival time, and waiting time; increment the waiting time by one time unit; return the waiting time; return the arrival time; return the transaction time; and return the customer number.
The following class, customerType, implements the customer as an ADT: class customerType { public: customerType(int  = 0, int  = 0, int  = 0, int  = 0); //Constructor to initialize the instance variables.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Application of Queues: Simulation.
FIGURE 17-36 UML class diagram of the class customerType The definitions of the member functions of the class customerType follow easily from their descriptions.
Next, we give the definitions of the member functions of the class customerType.
The function setCustomerInfo uses the values of the parameters to initialize , , , and.
The definition of setCustomerInfo is: void customerType::setCustomerInfo( ,  ,.
The definition of the constructor is similar to the definition of the function setCustomerInfo.
It uses the values of the parameters to initialize , , , and.
To make debugging easier, we use the function setCustomerInfo to write the definition of the constructor, which is given next, as follows: customerType::customerType( ,  , { setCustomerInfo(, , , );.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Server At any given time unit, the server is either busy serving a customer or is free.
We use a string variable to set the status of the server.
Every server has a timer and, because the program might need to know which customer is served by which server, the server also stores the information of the customer being served.
Thus, three member variables are associated with a server: the status, the , and the currentCustomer.
Some of the basic operations that must be performed on a server are as follows: check whether the server is free; set the server as free; set the server as busy; set the transaction time (that is, how long it takes to serve the customer); return the remaining transaction time (to determine whether the server should be set to free); if the server is busy after each time unit, decrement the transaction time by one time unit; and so on.
The following class, serverType, implements the server as an ADT: class serverType { public:.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Application of Queues: Simulation.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Application of Queues: Simulation.
Because we are designing a simulation program that can be used in a variety of applications, we need to design two more classes: one to create and process a list of servers and one to create and process a queue of waiting customers.
The next two sections describe each of these classes.
Server List A server list is a set of servers.
At any given , a server is either free or busy.
For the customer at the front of the queue, we need to find a server in the list that is free.
If all of the servers are busy, then the customer must wait until one of the servers becomes free.
Thus, the class that implements a list of servers has two member variables: one to store the number of servers and one to maintain a list of servers.
Using dynamic arrays, depending on the number of servers specified by the user, a list of servers is created during program execution.
Some of the operations that must be performed on a server list are as follows: return the server number of a free server; when a customer gets ready to do business and a server is available, set the server to busy; when the simulation ends, some of the servers might still be busy, so return the number of busy servers; after each  unit, reduce the  of each busy server by one  unit; and if the  of a server becomes zero, set the server to free.
The following class, serverListType, implements the list of servers as an ADT: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any  if subsequent rights restrictions require it.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any  if subsequent rights restrictions require it.
Application of Queues: Simulation.
UML class diagram of the class serverListType.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any  if subsequent rights restrictions require it.
The function setServerBusy sets a server to busy.
This function is overloaded.
The of the server that is set to busy is passed as a parameter to this function.
One function sets the server's transaction  according to the parameter tTime; the other function sets it by using the transaction  stored in the object cCustomer.
The transaction is later needed to determine the average wait.
The definitions of these functions are: void serverListType::setServerBusy( , customerType cCustomer,.
The definition of the function updateServers is quite straightforward.
Starting at the first server, it searches the list of  for busy.
When a busy server is found, its transactionTime is decremented by 1.
If the transactionTime reduces to zero, the Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any  if subsequent rights restrictions require it.
Application of Queues: Simulation.
If the transactionTime of a busy server reduces to zero, then the transaction of the customer being served by the server is complete.
If the actual parameter corresponding to outFile is cout, a message indicating which customer has been served is printed on the screen, together with the customer's departing.
Otherwise, the output is sent to a file specified by the user.
The definition of this function is as follows:.
Waiting Customers Queue When a customer arrives, he or she goes to the end of the queue.
When a server becomes available, the customer at the front of the queue leaves to conduct the transaction.
After each  unit, the waiting  of each customer in the queue is incremented by 1.
The ADT queueType designed in this chapter has all the operations needed to implement a queue, except the operation of incrementing the waiting  of each customer in the queue by one  unit.
We will derive a class, waitingCustomerQueueType, from the class queueType and add the additional operations to implement the customer queue.
The definition of the class waitingCustomerQueueType is as follows: class waitingCustomerQueueType: public queueType<customerType> { public:.
The value of // is passed to the constructor of queueType.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any  if subsequent rights restrictions require it.
You can also derive it from the class linkedQueueType, which implements the queue in a linked list.
We leave the details as an exercise for you.
The definitions of the member functions are given next.
The definition of the constructor.
The function updateWaitingQueue increments the waiting  of each customer in the queue by one  unit.
The class waitingCustomerQueueType is derived from the class.
Because the member variables of  are private, the function updateWaitingQueue cannot directly access the elements of the queue.
The only way to access the elements of the queue is to use the deleteQueue operation.
After incrementing the waiting , the element can be put back into the queue by using the addQueue operation.
The addQueue operation inserts the element at the end of the queue.
If we perform the deleteQueue operation followed by the addQueue operation for each element of the queue, then eventually the front element again becomes the front element.
Given that each deleteQueue operation is followed by an addQueue operation, how do we determine that all of the elements of the queue have been processed.
We cannot use the isEmptyQueue or isFullQueue operations on the queue, because the queue will never be empty or full.
One solution to this problem is to create a temporary queue.
Every element of the original queue is removed, processed, and inserted into the temporary queue.
When the original queue becomes empty, all of the elements in the queue are processed.
We can then copy the elements from the temporary queue back into the original queue.
However, this solution requires us to use extra memory space, which could be significant.
Also, if the queue is large, extra computer  is needed to copy the elements from the temporary queue back into the original queue.
Let us look into another solution.
In the second solution, before starting to update the elements of the queue, we can insert a dummy customer with a wait  of, say, -1.
During the update process, when we arrive at the customer with the wait  of -1, we can stop the update process without processing the customer with the wait  of -1.
If we do not process the customer with the wait  of -1, this customer is removed from the queue and, after processing all of Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any  if subsequent rights restrictions require it.
Application of Queues: Simulation.
This solution does not require us to create a temporary queue, so we do not need extra computer  to copy the elements back into the original queue.
We will use this solution to update the queue.
Therefore, the definition of the function updateWaitingQueue is:.
To run the simulation, we first need to get the following information:.
The number of  units the simulation should run.
Assume that each unit is one minute.
The number of servers.
The amount of  it takes to serve a customer—that is, the transaction.
The approximate  between customer arrivals.
These pieces of information are called simulation parameters.
By changing the values of these parameters, we can observe the changes in the performance of the system.
We can write a function, setSimulationParameters, to prompt the user to specify these values.
The definition of this function is: void setSimulationParameters(int& int& int& {.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
When a server becomes free and the  queue is nonempty, we can move the at the front of the queue to the free server to be served.
Moreover, when a starts the transaction, the waiting time ends.
The waiting time of the is added to the total waiting time.
The general algorithm to start the transaction (supposing that serverID denotes the ID of the free server) is: 1.
Remove the  from the front of the queue.
To run the simulation, we need to know the number of customers arriving at a given time unit and how long it takes to serve the.
We use the Poisson distribution from statistics, which says that the probability of y events occurring at a given time is given by the formula: PðyÞ ¼ y e ; y ¼ 0; 1; 2;.
Suppose that, on average, a  arrives every four minutes.
During this four-minute period, the can arrive at any one of the four minutes.
Assuming an equal likelihood of each of the four minutes, the expected value that a  arrives in each of the four minutes is, , 1 / 4 = _0_25.
Next, we need to determine whether or not the actually arrives at a given minute.
One of the basic assumptions of the Poisson distribution is that the probability of more than one outcome occurring in a short time interval is negligible.
For simplicity, we assume that only one Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Application of Queues: Simulation.
Thus, we use e- as the cutoff point to determine whether a  arrives at a given time unit.
Suppose that, on average, a  arrives every four minutes.
We can use an algorithm to generate a number between 0 and 1.
If the value of the number generated is > e-0_0_25, we can assume that the arrived at a particular time unit.
For example, suppose that rNum is a random number such that 0  rNum  1.
If rNum > e-0_0_25, the  arrived at the given time unit.
We now describe the function runSimulation to implement the simulation.
Suppose that we run the simulation for 100 time units and customers arrive at time units 93, 96, and 100.
The average transaction time is five minutes—that is, five time units.
For simplicity, assume that we have only one server and that the server becomes free at time unit 97, and that all customers arriving before time unit 93 have been served.
When the server becomes free at time unit 97, the  arriving at time unit 93 starts the transaction.
Because the transaction of the  arriving at time unit 93 starts at time unit 97 and it takes five minutes to complete a transaction, when the simulation loop ends, the  arriving at time unit 93 is still at the server.
Moreover, customers arriving at time units 96 and 100 are in the queue.
For simplicity, we assume that when the simulation loop ends, the customers at the servers are considered served.
The general algorithm for this function is: 1.
Declare and initialize the variables, such as the simulation parameters, number, , total and average waiting times, number of customers arrived, number of customers served, number of customers left in the waiting queue, number of customers left with the servers, waitingCustomersQueue, and a list of servers.
Update the server list to decrement the transaction time of each busy server by one time unit.
If the 's queue is nonempty, increment the waiting time of each by one time unit.
If a  arrives, increment the number of customers by 1 and add the new  to the queue.
If a server is free and the 's queue is nonempty, remove a from the front of the queue and send the  to.
Print the appropriate results.
Your results must include the number of customers left in the queue, the number of customers still with servers, the number of customers arrived, and the number of customers who actually completed a transaction.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Exercise 18 asks you to write the definition of the function runSimulation.
When we tested our version of the simulation program, we generated the following results.
Sample Run: Customer number 1 arrived at time unit 4 Customer number 2 arrived at time unit 8 From server number 1  number 1 departed at time unit 9 Customer number 3 arrived at time unit 9 Customer number 4 arrived at time unit 12 From server number 1  number 2 departed at time unit 14 From server number 1  number 3 departed at time unit 19 Customer number 5 arrived at time unit 21 From server number 1  number 4 departed at time unit 24 From server number 1  number 5 departed at time unit 29 Customer number 6 arrived at time unit 37 Customer number 7 arrived at time unit 38 Customer number 8 arrived at time unit 41 From server number 1  number 6 departed at time unit 42 Customer number 9 arrived at time unit 43 Customer number 10 arrived at time unit 44 From server number 1  number 7 departed at time unit 47 Customer number 11 arrived at time unit 49 Customer number 12 arrived at time unit 51 From server number 1  number 8 departed at time unit 52 Customer number 13 arrived at time unit 52 Customer number 14 arrived at time unit 53 Customer number 15 arrived at time unit 54 From server number 1  number 9 departed at time unit 57 Customer number 16 arrived at time unit 59 From server number 1  number 10 departed at time unit 62 Customer number 17 arrived at time unit 66 From server number 1  number 11 departed at time unit 67 Customer number 18 arrived at time unit 71 From server number 1  number 12 departed at time unit 72 From server number 1  number 13 departed at time unit 77 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Quick Review | Customer number 19 arrived at From server number 1 departed at time unit 82 From server number 1 departed at time unit 87 Customer number 20 arrived at From server number 1 departed at time unit 92 Customer number 21 arrived at From server number 1 departed at time unit 97 1251 time unit 78 number 14 number 15 time unit 90 number 16 time unit 92 number 17 The simulation ran for 100 time units Number of servers: 1 Average transaction time: 5 Average arrival time difference between customers: 4 Total waiting time: 269 Number of customers that completed a transaction: 17 Number of customers left in the servers: 1 The number of customers left in queue: 3 Average waiting time: 12_0_81 ************** END SIMULATION ************* QUICK REVIEW 1.
A stack is a data structure in which the items are added and deleted from one end only.
A stack is a Last In First Out (LIFO) data structure.
The basic operations on a stack are as follows: push an item onto the stack, pop an item from the stack, retrieve the top element of the stack, initialize the stack, check whether the stack is empty, and check whether the stack is full.
A stack can be implemented as an array or a linked list.
The middle elements of a stack should not be accessed directly.
Stacks are restricted versions of arrays and linked lists.
Postfix notation does not require the use of parentheses to enforce operator precedence.
In postfix notation, the operators are written after the operands.
Postfix expressions are evaluated according to the following rules: Scan the expression from left to right.
If an operator is found, back up to get the required number of operands, evaluate the operator, and continue.
A queue is a data structure in which the items are added at one end and removed from the other end.
A queue is a First In First Out (FIFO) data structure.
The basic operations on a queue are as follows: add an item to the queue, remove an item from the queue, retrieve the first or last element of the a.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
A queue can be implemented as an array or a linked list.
The middle elements of a queue should not be accessed directly.
Queues are restricted versions of arrays and linked lists.
EXERCISES The number in parentheses at the end of an exercise refers to the learning objective listed at the beginning of the chapter.
Mark the following statements as true or false.
A stack is a list of homogenous elements in which the addition and c.
In the array implementation of a stack, stackTop contains the index of d.
In the array implementation of a stack, to remove the top element of the stack, the operation pop decrements the value of stackTop by 1 if e.
In the array implementation of a stack, the operation top returns the f.
In the linked implementation of a stack, stackTop contains the address g.
In the linked implementation of a stack, the operation isFullStack h.
In the array implementation of a queue, the operation deleteQueue l.
In the linked implementation of a queue, the queue is empty if Suppose that stack is an object of type stackType<int>.
What is the Suppose that stack is an object of type stackType<double> and the value a.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Show what is output by the following segment of code:.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Explain why, in the linked implementation of a stack, it is not necessary to Suppose that stack is an object of type <int>.
What is Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Assume that this function is a Write the definition of the method second that takes as a parameter a stack object and returns the second element of the stack.
The original stack <int> queue;.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Also, suppose that the value of queueFront What are the values of queueFront and queueRear after adding an element to queue.
What are the values of queueFront and queueRear after removing an element from queue.
Suppose that queue is a  object and the size of the array implementing queue is 100.
Also, suppose that the value of queueFront a.
What are the values of queueFront and queueRear after adding an element to queue.
What are the values of queueFront and queueRear after removing an element from queue.
Suppose that queue is a  object and the size of the array implementing queue is 100.
Also, suppose that the value of queueFront a.
What are the values of queueFront and queueRear after adding an element to queue.
What are the values of queueFront and queueRear after removing an element from queue.
Suppose that queue is a  object and the size of the array implementing queue is 100.
Also, suppose that the value of queueFront a.
What are the values of queueFront and queueRear after adding an element to queue.
What are the values of queueFront and queueRear after removing an element from queue.
Suppose that queue is implemented as an array with the special reserved slot, as described in this chapter.
Also, suppose that the size of the array implementing queue is 100.
If the value of queueFront is 50, what is the Suppose that queue is implemented as an array with the special reserved slot, as described in this chapter.
Suppose that the size of the array implementing queue is 100.
Also, suppose that the value of queueFront is 74 a.
What are the values of queueFront and queueRear after adding an element to queue.
What are the values of queueFront and queueRear after removing an element from queue.
Also, what was the position of the removed queue element.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Write a function template, reverseStack, that takes as a parameter a stack object and uses a queue object to reverse the elements of the stack.
Write a function template, reverseQueue, that takes as a parameter a queue object and uses a stack object to reverse the elements of the queue.
Add the operation queueCount to the class  (the array implementation of queues), which returns the number of elements in the queue.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Exercises 33.
Two stacks of the same type are the same if they have the same number of elements and their elements at the corresponding positions are the same.
Overload the relational  == for the class  that returns true if two stacks of the same type are the same; it returns false otherwise.
Also, write the definition of the function template to overload this.
Repeat Programming Exercise 1 for the class.
Add the following operation to the class.
That is, the top element of stack1 is the bottom element of stack2, and so on.
The old contents of stack2 are destroyed, and stack1 is unchanged.
Write the definition of the function template to implement the operation reverseStack.
Repeat Programming Exercises 3a and 3b for the class.
Write a program that takes as input an arithmetic expression.
The program outputs whether the expression contains matching grouping symbols.
For example, the arithmetic expressions {25 + (3 – 6) * 8} and 7 + 8 * 2 contain matching grouping symbols.
However, the expression 5 + {(13 + 7) / 8 - 2 * 9 does not contain matching grouping symbols.
Write a program that uses a stack to print the prime factors of a positive integer in descending order.
The Programming Example, Converting a Number from Binary to Decimal, in Chapter 15, uses recursion to convert a binary number into an equivalent decimal number.
Write a program that uses a stack to convert a binary number into an equivalent decimal number.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Write a program that uses a stack to convert a decimal number into an equivalent binary number.
Write a program that reads a string consisting of a positive integer or a positive decimal number and converts the number to the numeric format.
If the string consists of a decimal number, the program must use a stack to convert the decimal number to the numeric format.
The rules to convert an infix expression into an equivalent postfix expression are as follows: Suppose infx represents the infix expression and pfx represents the postfix expression.
The rules to convert infx into pfx are as follows: a.
Initialize pfx to an empty expression and also initialize the stack.
Get the next symbol, sym, from infx.
If sym is an operand, append sym to pfx.
If sym is (, push sym into the stack.
If sym is ), pop and append all of the symbols from the stack until the most recent left parentheses.
Pop and discard the left parentheses.
Pop and append all of the operators from the stack to pfx that are above the most recent left parentheses and have precedence greater than or equal to sym.
Push sym onto the stack.
After processing infx, some operators might be left in the stack.
Pop and append to pfx everything from the stack.
In this program, you will consider the following (binary) arithmetic operators: +, -, *, and /.
You may assume that the expressions you will process are error free.
Design a class that stores the infix and postfix strings.
The class must include the following operations:.
Some other operations that you might need are:.
The resulting postfix expression is stored in pfx.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
If the first  is of higher or equal precedence than the second , it returns the value true; otherwise, it returns the value false.
Include the constructors and destructors for automatic initialization and dynamic memory deallocation.
Test your program on the following expressions: a.
Write the definitions of the functions to overload the assignment operator and copy constructor for the class queueType.
Also, write a program to test these operations.
Write the definitions of the functions to overload the assignment operator and copy constructor for the class linkedQueueType.
Also, write a program to test these operations.
This chapter describes the array implementation of queues that use a special array slot, called the reserved slot, to distinguish between an empty and a full.
Write the definition of the class and the definitions of the function members of this  design.
Also, write a test program to test various operations on a.
Write the definition of the function moveNthFront that takes as a parameter a positive integer,.
The function moves the nth element of the to the front.
The order of the remaining elements remains unchanged.
For example, suppose: = {5, 11, 34, 67, 43, 55} and  = 3.
Add this function to the class queueType.
Also, write a program to test your method.
Write a program that reads a line of text, changes each uppercase letter to lowercase, and places each letter both in a  and onto a stack.
The program should then verify whether the line of text is a palindrome (a set of letters or numbers that is the same whether read forward or backward).
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
You can also use the variable count to return the number of elements in the.
On the other hand, class linkedQueueType does not use such a variable to keep track of the number of elements in the.
Redefine the class linkedQueueType by adding the variable count to keep track of the number of elements in the.
Modify the definitions of the functions addQueue and deleteQueue as necessary.
Add the function queueCount to return the number of elements in the Also, write a program to test various operations of the class you defined.
Write the definition of the class linkedQueueType, which is derived from the class unorderedLinkedList, as explained in this chapter.
Also, write a program to test various operations of this class.
Write the definitions of the functions setWaitingTime, getArrivalTime, getTransactionTime, and getCustomerNumber of the class customerType defined in the section Application of Queues: Simulation.
Write the definitions of the functions getRemainingTransactionTime, setCurrentCustomer, getCurrentCustomerNumber, getCurrentCustomerArrivalTime, getCurrentCustomerWaitingTime, and getCurrentCustomerTransactionTime of the class serverType defined in the section Application of Queues: Simulation.
Write the definition of the function runSimulation to complete the design of the computer simulation program (see the section Application of Queues: Simulation).
Test run your program for a variety of data.
Moreover, use a random number generator to decide whether a customer arrived at a given time unit.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Explore how to implement the merge sort algorithm and how it performs Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 16 described how to organize data using linked lists.
The most important operation that can be performed on a list is the search algorithm.
Using the search algorithm, you can do the following:.
Determine whether a particular  is in the list.
If the data is specially organized (e_0_g_0_, sorted), find the location in the list where a new  can be inserted.
Find the location of an  to be deleted.
The search algorithm's performance, therefore, is crucial.
If the search is slow, it takes a large amount of computer time to accomplish your task; if the search is fast, you can accomplish your task quickly.
In the first part of this chapter, we describe the search algorithms: sequential search and binary search.
Certain search algorithms work only on sorted data.
Therefore, the second half of this chapter discusses various sorting algorithms.
Searching and Sorting Algorithms The searching and sorting algorithms that we describe are generic.
Because searching and sorting require comparisons of data, the algorithms should work on the type of data that provides appropriate functions to compare data items.
Now data can be organized with the help of an array or a linked list.
You can create an array of data items, or you can use the class unorderedLinkedList to organize data.
The algorithms that we describe should work on either organization.
Consequently, we will write the function templates to implement a particular algorithm.
All algorithms described in this chapter, with the exception of the merge sort algorithms, are for array-based lists.
Because of storage issues and some other overheads, merge sort works better for linked lists.
Therefore, after describing the merge sort algorithm, we will add it as a function to the class unorderedLinkedList.
We will also show how to use the searching and sorting algorithms on objects of the class unorderedArrayListType.
Moreover, we will place all of the array-based searching and sorting functions in the header file searchSortAlgorithms_0_h.
Therefore, if you need to use a particular searching and/ or sorting function designed in this chapter, your program can include this header file and use that function.
Search Algorithms Chapters 12, 13, and 16 described how to implement the sequential search algorithm.
This chapter discusses other search algorithms and analyzes them.
Analysis of the algorithms enables programmers to decide which algorithm to use for a specific application.
Before exploring these algorithms, let us make the following observations.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
For example, if you have a data set consisting of student records, then the student ID uniquely identifies each student in a particular school.
This unique member of the  is called the key of the.
The keys of the items in the data set are used in such operations as searching, sorting, inserting, and deleting.
For instance, when we search the data set for a particular , we compare the key of the  for which we are searching with the keys of the items in the data set.
When analyzing searching and sorting algorithms, the key comparisons refer to comparing the key of the search  with the key of an  in the list.
The number of key comparisons refers to the number of times the key of the search  (in algorithms such as searching and sorting) is compared with the keys of the items in the list.
Sequential Search The sequential search (also called a linear search) on array-based lists was described in Chapters 12 and 13, and the sequential search on linked lists was covered in Chapter 16.
The sequential search works the same for both array-based and linked lists.
The search always starts at the first element in the list and continues until either the  is found in the list or the entire list is searched.
Because we are interested in the performance of the sequential search (that is, the analysis of this type of search), for easy reference and the sake of completeness, we provide the sequential search algorithm for array-based lists (as described in Chapters 12 and 13).
If the search  is , its index (that is, its location in the array) is returned.
If the search is unsuccessful, -1 is returned.
Note that the following sequential search does not require the list elements to be in any particular order.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
You can also write a recursive algorithm to implement the sequential search algorithm.
The statements before and after the loop are executed only once and hence require very little computer time.
The statements in the while loop are the ones that are repeated several times.
For each iteration of the loop, the search  is compared with an element in the list, and a few other statements are executed, including some other comparisons.
Clearly, the loop terminates as soon as the search  is  in the list.
Therefore, execution of the other statements in the loop is directly related to the outcome of the key comparison.
Also, different programmers might implement the same algorithm differently, although the number of key comparisons would typically be the same.
The speed of a computer can also easily affect the time an algorithm takes to perform, but it, of course, does not affect the number of key comparisons required.
Therefore, when analyzing a search algorithm, we count the number of key comparisons because this number gives us the most useful information.
Furthermore, the criteria for counting the number of key comparisons can be applied equally well to other search algorithms.
Suppose that L is a list of length n.
We want to determine the number of key comparisons made by the sequential search when the list L is searched for a given item.
If the search item is not in the list, we then compare the search item with every element in the list, making n comparisons.
This is an unsuccessful case.
Suppose that the search item is in the list.
Then, the number of key comparisons depends on where in the list the search item is located.
If the search item is the first element of L, we make only one key comparison.
On the other hand, if the search item is the last element in the list, the algorithm makes n comparisons.
This is the worst case.
The best and worst cases are not likely to occur every time we apply the sequential search on L, so it would be more helpful if we could determine the average behavior of the algorithm.
That is, we need to determine the average number of key comparisons the sequential search algorithm makes in the successful case.
To determine the average number of comparisons in the successful case of the sequential search algorithm: 1.
Consider all possible cases.
Find the number of comparisons for each case.
Add the number of comparisons and divide by the number of cases.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
If the target is the second element in the list, two comparisons are required.
Similarly, if the target is the kth element in the list, k comparisons are required.
We assume that the target can be any element in the list; that is, all list elements are equally likely to be the target.
Suppose that there are n elements in the list.
The following expression gives the average number of comparisons: 1 þ 2 þ  þ n : n 1 8 It is known that: 1 þ 2 þ  þ n ¼ nðn þ 1Þ : 2 Therefore, the following expression gives the average number of comparisons made by the sequential search in the successful case: 1 þ 2 þ    þ n 1 nðn þ 1Þ n þ 1 : ¼ ¼ n n 2 2 This expression shows that, on average, a successful sequential search searches half of the list.
It thus follows that if the list size is 1,000,000, on average, the sequential search makes 500,000 comparisons.
As a result, the sequential search is not efficient for large lists.
Binary Search As you can see, the sequential search is not efficient for large lists because, on average, it searches half the list.
We, therefore, describe another search algorithm called the binary search, which is very fast.
However, a binary search can be performed only on sorted lists.
We, therefore, assume that the list is sorted.
Later in this chapter, we will describe several sorting algorithms.
The binary search algorithm uses the "divide and conquer" technique to search the list.
First, the search item is compared with the middle element of the list.
If the search item is less than the middle element of the list, we restrict the search to the first half of the list; otherwise, we search the second half of the list.
Consider the sorted list of  = 12 in Figure 18-1.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
List of  12 Suppose that we want to determine whether 75 is in the list.
Initially, the entire list is the search list (see Figure 18-2).
Search list, list[0]_0__0__0_list[11] First, we compare 75 with the middle element in this list, list[5] (which is 39).
Because 75 6¼ list[5] and 75 > list[5], we then restrict our search to the list list[6]_0__0__0_list[11], as shown in Figure 18-3.
Search list, list[6]_0__0__0_list[11] This process is now repeated on the list list[6]_0__0__0_list[11], which is a list of = 6.
Because we need to determine the middle element of the list frequently, the binary search algorithm is typically implemented for array-based lists.
To determine the middle element of the list, we add the starting index, first, and the ending index, last, of the search list and then divide by 2 to calculate its index.
That is: mid ¼ first þ last.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The following Cplus_plus function implements the binary search algorithm.
If the item is in the list, its location is returned; if the search item is not in the list, -1 is returned.
In the binary search algorithm, each time through the loop, we make two key comparisons.
The only exception is in the successful case; the  time through the loop, only one key comparison is made.
The binary search algorithm, as given in this chapter, uses an iterative control structure (the while loop) to compare the search item with the list elements.
You can also write a recursive algorithm to implement the binary search algorithm.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sorted list for a binary search The size of this list is 12; that is, the  is 12.
Suppose that we are searching for item 89.
Table 18-1 shows the values of , , and  each time through the loop.
It also shows the number of times the item is compared with an element in the list each time through the loop.
TABLE 18-1 Values of , , and  and the Number of Comparisons for Search Item 89 Iteration.
The item is  at location 10, and the total number of comparisons is 5.
Next, let us search the list for item 34.
Table 18-2 shows the values of , , and each time through the loop.
It also shows the number of times the item is compared with an element in the list each time through the loop.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The item is found at location 4, and the total number of comparisons is 7.
Let us now search for item 22, as shown in Table 18-3.
TABLE 18-3 Values of first, last, and mid and the Number of Comparisons for Search Item 22 Iteration.
This is an unsuccessful search.
The total number of comparisons is 6.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Line 5: 45 found at position 3 The preceding program works as follows.
The statement in Line 1 creates the array (Note that the array  is sorted_0_) The statement in Line 2 declares to be an int variable.
The statement in Line 3 uses the binary search algorithm to determine whether 45 is in.
Note that the array , its lengths, and the search item, which is 45, are passed as parameters to the function binarySearch.
The statements in Lines 4 to 7 output the result of the search, which is successful.
Performance of Binary Search Suppose that L is a sorted list of size 1024 and we want to determine if an item x is in L.
From the binary search algorithm, it follows that every iteration of the while loop cuts the size of the search list by half.
Because every iteration of the while loop makes two item (key) comparisons, that is, x is compared twice with the elements of L, the binary search will make, at most, 22 comparisons to determine whether x is in L.
On the other hand, recall that a sequential search on average will make 512 comparisons to determine whether x is in L.
To better understand how fast binary search is compared to sequential search, suppose that L is of size 1048576.
Because 1048576 ¼ 220, it follows that the while loop in a binary search will have, at most, 21 iterations to determine whether an element is in L.
Every iteration of the while loop makes two key (that is, item) comparisons.
Therefore, to determine whether an element is in L, a binary search makes, at most, 42 item comparisons.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Moreover, suppose that  is a power of 2, that is,  ¼ 2m, for some nonnegative integer m.
After each iteration of the while loop, about half of the elements are left to search, that is, the search sublist for the next iteration is half the size of the current sublist.
For example, after the first iteration, the search sublist size is about =2 ¼ 2m1.
It is easy to see that the maximum number of the iteration of the while loop is about m + 1.
Each iteration makes two key comparisons.
Thus, the maximum number of comparisons to determine whether an element x is in L is 2(m + 1) ¼ 2(log2 + 1) ¼ 2log2 + 2.
In the case of a successful search, it can be shown that for a list of length , on average, a binary search makes 2log2 – 3 key comparisons.
In the case of an unsuccessful search, it can be shown that for a list of length , a binary search makes approximately 2log2 key comparisons.
Binary Search Algorithm and the class orderedArrayListType The class orderedArrayListType, designed in Chapter 13, does not contain the binary search algorithm.
Now that you know how to implement the binary search algorithm, you can learn how to use it in the class orderedArrayListType.
To use the binary search algorithm within the class orderedArrayListType, we add the function binSearch to this class and call the functions binarySearch with the appropriate parameters.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Asymptotic Notation: Big-O Notation Just as a problem is analyzed before writing the algorithm and the computer program, after an algorithm is designed, it should also be analyzed.
Usually, there are various ways to design a particular algorithm.
Certain algorithms take very little computer time to execute, while others take a considerable amount of time.
Consider the following examples.
EXAMPLE 18-3 Consider the following algorithm (assume that all variables are properly declared):.
Line 7 has one operation, >¼.
Either Line 8 or Line 9 executes; each has one operation.
There are three operations, <<, in Line 11.
Therefore, the total number of operations executed in the preceding code  6 þ 1 þ 1 þ 3 ¼ 11.
In this algorithm, the number of operations executed  fixed.
EXAMPLE 18-4 Consider the following algorithm (assume that all variables are properly declared):.
Asymptotic Notation: Big-O Notation.
Similarly, there are nine or eight operations after the while loop, depending on whether Line 11 or Line 13 executes.
Line 5 has one operation, and there are four operations within the while loop (Lines 6 through 8).
Thus, Lines 5 through 8 have five operations.
If the while loop executes 10 times, these five operations execute 10 times, plus one extra operation  executed at Line 5 to terminate the loop.
Therefore, the number of operations executed from Lines 5 through 8  51.
If the while loop executes 10 times, the total number of operations executed : 5  10 þ 1 þ 5 þ 9 or 5  10 þ 1 þ 5 þ 8: That : 5  10 þ 15 or 5  10 þ 14: We can generalize it to the case when the while loop executes  times.
If the while loop executes  times, the number of operations executed : 5 þ 15 or 5 þ 14: In these expressions, for very large values of , the term 5 becomes the dominating term, and the terms 15 and 14 become negligible.
Usually, in an algorithm, certain operations are dominant.
For example, in the algorithm in Example 18-4, to add numbers, the dominant operation  in Line 6.
Similarly, in a search algorithm, because the search item  compared with the items in the list, the dominant operations would be comparison, that , the relational operation.
Therefore, in the case of a search algorithm, we  the number of comparisons.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Suppose that you want to determine whether an item  in a list and that the  of the list.
To determine whether the item  in the list, there are various algorithms.
However, the basic method  to compare the item with the items in the list.
Therefore, the performance of the algorithm depends on the number of comparisons.
Thus, in the case of a search, n  the  of the list and f(n) becomes the  function; that , f(n) gives the number of comparisons done by the search algorithm.
Suppose that on a particular computer, it takes c units of computer time to execute one operation.
Thus, the computer time it would take to execute f(n) operations  cf(n).
Clearly, the constant c depends on the speed of the computer and, therefore, varies from computer to computer.
However, f(n), the number of basic operations,  the same on each computer.
If we know how the function f(n) grows as the  of the problem grows, we can determine the efficiency of the algorithm.
TABLE 18-4 Growth Rate of Various Functions.
Suppose that the problem size  doubled.
From Table 18-4, it follows that if the number of basic operations  a function of f(n) ¼ n2, the number of basic operations quadrupled.
If the number of basic operations  a function of f(n) ¼ 2n, then the number of basic operations  squared.
However, if the number of operations  a function of f(n) ¼ log2n, the change in the number of basic operations  insignificant.
Suppose that a computer can execute 1 billion steps per second.
Table 18-5 shows the time that the computer takes to execute f(n) steps.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Asymptotic Notation: Big-O Notation.
Figure 18-5 shows the growth rate of functions in Table 18-5.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Growth rate of various functions The remainder of this section develops a notation that shows how a function f() grows as increases without bound.
That is, we develop a notation that is useful in describing the Let f be a function of.
By the term asymptotic, we mean the study of the function f as becomes larger and larger without bound.
Clearly, the function g does not contain any linear term; that is, the coefficient of  in g is zero.
TABLE 18-6 Growth Rate of 2 and 2 + 4 + 20.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Asymptotic Notation: Big-O Notation.
For large values of , we can predict the behavior of f() by looking at the behavior of g().
In the algorithm analysis, if the complexity of a function can be described by the complexity of a quadratic function without the linear term, we say that the function is of O(2), called Big-O of 2.
Let f and g be real-valued functions.
Assume that f and g are nonnegative; that is, for all real numbers , f()  0 and g()  0.
Definition: We say that f() is Big-O of g(), written f() ¼ O(g()), if there exist positive constants c and 0 such that: f()  cg() for all   0.
EXAMPLE 18-5 Let f() ¼ a, wherein a is a nonnegative real number and   0.
Note that f is a constant function.
Now: f ðnÞ ¼ a  a  1 for all   a: Let c ¼ a, 0 ¼ a, and g() ¼ 1.
It now follows that f() ¼ O(g()) ¼ O(1).
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
In Example 18-8, we use the preceding theorem to establish the Big-O of certain functions.
EXAMPLE 18-8 In the following, f() is a nonnegative real-valued function.
Function f() = an + b, in which a and b are real numbers and a is nonzero f () = 2 + 5 + 1 f () = 46 + 33 + 1 f () = 107 + 23 f () = 615 Big-O.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Asymptotic Notation: Big-O Notation.
This code contains nested for loops.
The outer for loop, at Line 1, executes m times.
For each iteration of the outer loop, the inner loop at Line 2 executes  times.
For each iteration of the inner loop, the output statement in Line 3 executes.
It follows that the total number of iterations of the nested for loop is mn.
So the number of times the statement in Line 3 executes is mn.
It follows that this algorithm is O(mn).
Note that if m ¼ , then this algorithm is O(2).
Table 18-7 shows some common Big-O functions that appear in the algorithm analysis.
Let f() ¼ O(g()), wherein  is the problem size.
TABLE 18-7 Some Big-O Functions That Appear in Algorithm Analysis.
It can be shown that: Oð1Þ  Oðlog2 nÞ  OðnÞ  Oðnlog2 nÞ  Oðn2 Þ  Oð2 Þ: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Table 18-8 summarizes the algorithm analysis of the search algorithms discussed earlier.
TABLE 18-8 Number of Comparisons for a List of Length.
Sequential search nþ1 1 1 2 2.
Lower Bound on Comparison-Based Search Algorithms Sequential and binary search algorithms search the list by comparing the target element with the list elements.
For this reason, these algorithms are called comparison-based search algorithms.
Earlier sections of this chapter showed that a sequential search is of the order , and a binary search is of the order log2, where  is the size of the list.
The obvious question is: Can we devise a search algorithm that has an order less than log2.
Before we answer this question, first we obtain the lower bound on the number of comparisons for the comparison-based search algorithms.
Theorem: Let L be a list of size  > 1.
Suppose that the elements of L are sorted.
If SRH() denotes the minimum number of comparisons needed, in the worst case, by using a comparison-based algorithm to recognize whether an element x is in L, then SRH()  log2( + 1).
Corollary: The binary search algorithm is an optimal worst-case algorithm for solving search problems by the comparison method.
From these results, it follows that if we want to design a search algorithm that is of an order less than log2, then it cannot be comparison based.
Sorting Algorithms There are several sorting algorithms in the literature.
In this chapter, we discuss some of the commonly used sorting algorithms.
To compare their performance, we also provide some analysis of these algorithms.
These sorting algorithms can be applied to either arraybased lists or linked lists.
We will specify whether the algorithm being developed is for array-based lists or linked lists.
Sorting a List: Bubble Sort Many sorting algorithms are available in the literature.
This section describes using the sorting algorithm called the bubble sort to sort a list.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sorting a List: Bubble Sort.
We want to rearrange, that is, sort, the elements of list in increasing order.
The bubble sort algorithm works as follows.
In a series of  - 1 iterations, the successive elements list[index] and list[index + 1] of the list are compared.
If list[index] is greater than list[index + 1], then the elements list[index] and list[index + 1] are swapped.
It follows that the smaller elements move toward the top, and the larger elements move toward the bottom.
In the first iteration, we consider the list[0_0__0_.
As you will see after the first iteration, the largest element of the list is moved to the last position, which is position – 1, in the list.
In the second iteration, we consider the list[0_0__0_.
After the second iteration, the second largest element in the list is moved to the position  – 2, which is second to the last position in the list.
In the third iteration, we consider the list[0_0__0_.
As you will see, after each iteration, the size of the unsorted portion of the list shrinks.
Consider the list[0_0__0__0_4] of five elements, as shown in Figure 18-6.
Iteration 1: Sort list[0_0__0__0_4].
Figure 18-7 shows how the elements of list get rearranged in the first iteration.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
In the second diagram, list[1] and list[2] are compared.
The third diagram of Figure 18-7 compares list[2] with list[3]; because list[2] > list[3], list[2] is swapped with list[3].
Then, in the fourth diagram, we compare list[3] with list[4].
After the first iteration, the largest element is at the last position.
Therefore, in the next iteration, we consider the list[0_0__0__0_3].
Iteration 2: Sort list[0_0__0__0_3].
Figure 18-8 shows how the elements of list get rearranged in the second iteration.
Here, only the list elements list[0] through list[3] are considered.
After the second iteration, the last two elements are in the right place.
Therefore, in the next iteration, we consider list[0_0__0__0_2].
Iteration 3: Sort list[0_0__0__0_2].
Figure 18-9 shows how the elements of list get rearranged in the third iteration.
Elements of list during the third iteration Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sorting a List: Bubble Sort.
Therefore, in the next iteration, we consider list[0_0__0__0_1].
Iteration 4: Sort list[0_0__0__0_1].
Figure 18-10 shows how the elements of list get rearranged in the fourth iteration.
Elements of list during the fourth After the fourth , list is sorted.
The following Cplus_plus function implements the bubble sort algorithm: template <class elemType>.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Line 2: Before sorting, : 2 56 34 25 73 46 89 10 5 16 Line 6: After sorting, : 2 5 10 16 25 34 46 56 73 89 The statement in Line 1 declares and initializes  to be an array of 10 components of type int.
The statement in Line 3 outputs the values of the array  before sorting this array.
The statement in Line 5 uses the function bubbleSort to sort list.
Notice that both  and its length (the number of elements) are passed as parameters to the function bubbleSort.
The statement in Line 7 outputs the sorted.
Analysis: Bubble Sort comparisons.
A sorting algorithm makes key comparisons and also moves the data.
Therefore, in analyzing the sorting algorithm, we look at the number of key comparisons as well as the number of data movements.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sorting a List: Bubble Sort.
Consider the function bubbleSort as given in this chapter.
This function contains nested for loops.
Because L is of length n, the outer loop executes n – 1 times.
For each  of the outer loop, the inner loop executes a certain number of times.
Let us consider the first  of the outer loop.
During the first  of the outer loop, the number of iterations of the inner loop is n – 1.
Similarly, during the second of the outer loop, the number of iterations of the inner loop is n – 2, and so on.
Thus, the total number of comparisons is: ðn  1Þ þ ðn  2Þ þ    þ 2 þ 1 ¼ nðn  1Þ 1 1 ¼ n2  n ¼ Oðn2 Þ: 2 2 2 In the worst case, the body of the if statement always executes.
So in the worst case, the number of assignments is: 3 nðn  1Þ 3 3 ¼ n2  n ¼ Oðn2 Þ: 2 2 2 If the list is already sorted, which is the best case, the number of assignments is 0.
It can be nðn  1Þ shown that, on average, bubble sort makes about item assignments.
However, the 4 nðn  1Þ number of comparisons for the bubble sort, as given in this chapter, is always 2.
Therefore, to sort a list of size 1000, bubble sort makes about 500,000 key comparisons and about 250,000 item assignments.
The next section presents the selection sort algorithm that reduces the number of item assignments.
Exercise 9 at the end of this chapter gives a version of the bubble sort algorithm in which the number of comparisons in the best case is O (n).
Bubble Sort Algorithm and the class unorderedArrayListType The class unorderedArrayListType, designed in Chapter 13, does not contain any sorting algorithm.
Now that you know how to implement the bubble sort algorithm, you can learn how to use it in the class unorderedArrayListType.
To use the binary search algorithm within the class unorderedArrayListType, we add the function sort to this class and call the functions bubbleSort with the appropriate parameters.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Selection Sort: Array-Based Lists Chapter 8 described the selection sort algorithm for array-based lists.
However, the selection sort algorithm given in Chapter 8 works only for arrays of type int.
In this section, using templates we give a generic selection sort algorithm.
Note that the algorithm given here is slightly different than the one given in Chapter 8.
Suppose that list is the array to be sorted and length denotes the length, that is, the number of elements in list.
As described in Chapter 9, a selection sort involves the following steps: a.
Find the location of the smallest element.
Move the smallest element to the beginning of the unsorted list.
Given the starting index, first, and the ending index, last, of the list, the following Cplus_plus function returns the index of the smallest element in list[first]_0__0_.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Selection Sort: Array-Based Lists.
A selection sort can also be implemented by selecting the largest element in the unsorted portion of the list and moving it to the bottom of the list.
You can easily implement this form of selection sort by altering the if statement in the function minLocation and passing the appropriate parameters to both the corresponding function and the function swap (when these functions are called in the function selectionSort).
A selection sort can also be applied to linked lists.
The general algorithm is the same, and the details are left as an exercise for you.
See Programming Exercise 7 at the end of this chapter.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The function swap does three item assignments and is executed n  1 times.
Hence, the number of item assignments is 3(n  1) ¼ O(n).
The key comparisons are made by the function minLocation.
For a list of length k, the function minLocation makes k  1 key comparisons.
Also, the function minLocation is executed n  1 times (by the function selectionSort).
The  time, the function minLocation finds the index of the smallest key item in the entire list and, therefore, makes n  1 comparisons.
The  time, the function minLocation finds the index of the smallest element in the sublist of length n  1 and so makes n  2 comparisons, and so on.
Hence, the number of key comparisons is as follows: nðn  1Þ 2 1 2 1 ¼ n  n 2 2 1 2 ¼ n þ OðnÞ 2 ¼ Oðn2 Þ: ðn  1Þ þ ðn  2Þ þ    þ 2 þ 1 ¼ It thus follows that if n ¼ 1000, the number of key comparisons the selection sort algorithm makes is: 1 1 ð1000Þ2  ð1000Þ ¼ 499500  500000: 2 2 Note that the selection sort algorithm does not depend on the initial arrangement of the data.
The number of comparisons is always O(n2) and the number of assignments is O(n).
In general, this algorithm is good only for small lists because O(n2) grows rapidly as n grows.
However, if data movement is expensive and the number of comparisons is not, then this algorithm could be a better choice over other algorithms.
Insertion Sort: Array-Based Lists The previous section described and analyzed the selection sort algorithm.
It was shown that if n ¼ 1000, the number of key comparisons is approximately 500,000, which is quite high.
This section describes the sorting algorithm called the insertion sort, which tries to improve—that is, reduce—the number of key comparisons.
The insertion sort algorithm sorts the list by moving each element to its proper place in the sorted portion of the list.
Consider the list given in Figure 18-11.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Insertion Sort: Array-Based Lists.
In this list, the elements list[0], list[1], list[2], and list[3] are in order.
That is, list[0]_0__0__0_list[3] is sorted (see Figure 18-12).
Sorted and unsorted portion of list Next, we consider the element list[4], the first element of the unsorted list.
Because list[4] < list[3], we need to move the element list[4] to its proper location.
It thus follows that element list[4] should be moved to list[2] (see Figure 18-13).
Move list[4] into list[2] To move list[4] into list[2], first we copy list[4] into temp, a temporary memory space (see Figure 18-14).
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Next, we copy list[3] into list[4] and then list[2] into list[3] (see Figure 18-15).
List before copying list[3] into list[4] and then list[2] into list[3] After copying list[3] into list[4] and list[2] into list[3], the list is as shown in Figure 18-16.
List after copying list[3] into list[4] and then list[2] into list[3] Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Insertion Sort: Array-Based Lists.
We now copy temp into list[2].
Figure 18-17 shows the resulting list.
FIGURE 18-17 sorted list [1] [2] 18 23.
List after copying temp into list[2] Now list[0]_0__0__0_list[4] is sorted, and list[5]_0__0__0_list[7] is unsorted.
We repeat this process on the resulting list by moving the first element of the unsorted list into the sorted list in the proper place.
From this discussion, we see that during the sorting phase, the array containing the list is divided into two sublists: sorted and unsorted.
Elements in the sorted sublist are in order; elements in the unsorted sublist are to be moved one at a time to their proper places in the sorted sublist.
We use an index—say, —to point to the first element in the unsorted sublist; that is,  gives the index of the first element in the unsorted portion of the array.
Initially,  is initialized to 1.
This discussion translates into the following pseudocode algorithm: { copy list[] into temp initialize location to do { a.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
We leave it as an exercise for you to write a program to test the insertion sort algorithm.
An insertion sort can also be applied to linked lists.
The general algorithm is the same, and the details are left as an exercise for you.
See Programming Exercise 9 at the end of this chapter.
Analysis: Insertion Sort Let L be a list of length n.
Suppose L is to be sorted using insertion sort.
The for loop executes n  1 times.
In the best case, when the list is already sorted, for each iteration of the for loop, the if statement evaluates to false, so there are n  1 key comparisons.
Thus, in the best case, the number of key comparisons is n – 1 ¼ O(n).
Let us consider the worst case.
In this case, for each iteration of the for loop, the if statement evaluates to true.
Moreover, in the worst case, for each iteration of the for loop, the do.
It follows that in the worst case, the number of key comparisons is: 1 þ 2 þ    þ ðn  1 ¼ nðn  1=2 ¼ Oðn2 : It can be shown that the average number of key comparisons and the average number of item assignments in an insertion sort algorithm are: 1 2 n þ OðnÞ ¼ Oðn2 : 4 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Lower Bound on Comparison-Based Sort Algorithms.
TABLE 18-9 Average Case Behavior of the Bubble Sort, Selection Sort, and Insertion Sort Algorithms for a List of Length n Algorithm Bubble sort Selection sort Insertion sort Number of Comparisons.
Both of these algorithms are comparison based; that is, the lists are sorted by comparing their respective keys.
Before discussing any additional sorting algorithms, let us discuss the best-case scenario for comparison-based sorting algorithms.
We can trace the execution of a comparison-based algorithm by using a graph called a comparison tree.
Let L be a list of  distinct elements, wherein  > 0.
Because each comparison of the keys has two outcomes, the comparison tree is a binary tree.
While drawing this figure, we draw each comparison as a circle called a node.
The node is labeled as :k, representing the comparison of L[ ] with L[k].
If L[ ] < L[k], follow the left branch; otherwise, follow the right branch.
Figure 18-18 shows the comparison tree for a list of length 3.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
L[2]>L[3] 1:3 L[1] > L[3] L[1] < L[3] 3,1,2 2,1,3 3,2,1 L[1] > L[3] 2,3,1 Comparison tree for sorting three items We call the top node in the figure the root node.
The straight line that connects the two nodes is called a branch.
A sequence of branches from a node, x, to another node, y, is called a path from x to y.
Associated with each path from the root to a leaf is a unique permutation of the elements of L.
This uniqueness follows because the sort algorithm only moves the data and makes comparisons.
Furthermore, the data movement on any path from the root to a leaf is the same regardless of the initial inputs.
For a list of  elements,  > 0, there are.
Thus, the comparison tree must have at least.
Now let us consider the worst case for all comparison-based sorting algorithms.
We state the following result without proof.
Theorem: Let L be a list of  distinct elements.
Any sorting algorithm that sorts L by comparison of the keys only, in its worst case, makes at least (nlog2) key comparisons.
As analyzed in the previous sections, both the selection and insertion sort algorithms are of the order (2).
The remainder of this chapter discusses sorting algorithms that, on average, are of the order (nlog2).
Quick Sort: Array-Based Lists In the previous section, we noted that the lower bound on comparison-based algorithms is (nlog2).
The sorting algorithms bubble sort, selection sort, and insertion sort, discussed earlier in this chapter, are of the order (2).
In this and the next two sections, we discuss sorting algorithms that are of the order (nlog2).
The first algorithm is the quick sort algorithm.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Quick Sort: Array-Based Lists.
The list is partitioned into two sublists, which are then sorted and combined into one list in such a way so that the combined list is sorted.
Thus, the general algorithm is: { a.
Partition the list into two sublists, say lowerSublist and upperSublist.
Quick sort lowerSublist.
Quick sort upperSublist.
Combine the sorted lowerSublist and sorted upperSublist.
In other words, we use recursion to implement the quick sort algorithm.
The quick sort algorithm described here is for array-based lists.
The algorithm for linked lists can be developed in a similar manner and is left as an exercise for you.
In the quick sort algorithm, the list is partitioned in such way that combining the sorted lowerSublist and upperSublist is trivial.
Therefore, in a quick sort, all of the sorting work is done in partitioning the list.
Because all of the sorting work occurs during the partitioning of the list, we first describe the partition procedure in detail.
To partition the list into two sublists, first we choose an element of the list called pivot.
The pivot is used to divide the list into two sublists: lowerSublist and upperSublist.
The elements in lowerSublist are smaller than pivot, and the elements in upperSublist are greater than or equal to pivot.
For example, consider the list in Figure 18-19.
However, pivot is chosen so that, it is hoped, lowerSublist and upperSublist are of nearly equal size.
For illustration purposes, let us choose the middle element of the list as pivot.
The partition procedure that we describe partitions this list using pivot as the middle element, in our case 50, as shown in Figure 18-20.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Thus, after sorting lowerSublist and upperSublist, combining the two sorted sublists is trivial.
The partition algorithm is as follows (we assume that pivot is chosen as the middle element of the list).
Determine pivot, and swap pivot with the first element of the list.
Suppose that the index smallIndex points to the last element less than pivot.
The index smallIndex is initialized to the first element of the list.
For the remaining elements in the list (starting at the second element): If the current element is less than pivot, a.
Swap the current element with the array element pointed to by smallIndex.
Swap the first element, that is, pivot, with the array element pointed to by smallIndex.
Step 2 can be implemented using a for loop, with the loop starting at the second element of the list.
Step 1 determines the pivot and moves pivot to the first array position.
During the execution of Step 2, the list elements get arranged as shown in Figure 18-21.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Quick Sort: Array-Based Lists.
Elements in the lower sublist are less than pivot; elements in the upper sublist are greater than or equal to pivot.
The variable smallIndex contains the index of the last element of the lower sublist; the variable index contains the index of the next element that needs to be moved, either in the lower sublist or in the upper sublist.
As explained in Step 2, if the next element of the list (that is, list[index]) is less than pivot, we advance smallIndex to the next array position and swap list[index] with list[smallIndex].
Next, we illustrate Step 2.
Suppose that the list is as given in Figure 18-22.
List before sorting Step 1 requires us to determine the pivot and swap it with the first array element.
For the list in Figure 18-22, the middle element is at the  (0 + 13) / 2 = 6.
Therefore, after swapping pivot with the first array element, the [0].
Suppose that after executing Step 2 a few times, the list is as shown in Figure 18-24.
List after a few iterations of Step 2 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Because list[index] < pivot, we need to move the element list[index] into the lower sublist.
To do so, we first advance smallIndex to the next array  and then swap list[smallIndex] with list[index].
The lower sublist 52 13.
Now consider the list in Figure 18-26.
List before moving 58 into a sublist For the list in Figure 18-26, list[index] is 58, which is greater than pivot.
Therefore, list[index] is to be moved into the upper sublist.
This is accomplished by leaving 58 at its position and increasing the size of the upper sublist by one, to the next array position.
After moving 58 into the upper sublist, the list is as shown in Figure 18-27.
List after moving 58 into the upper sublist Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Quick Sort: Array-Based Lists.
FIGURE 18-28 Next, we execute Step 3 and move 52, pivot, to the proper position in the list.
This is accomplished by swapping 52 with 45.
The resulting list is as shown in Figure 18-29.
List after swapping 52 with 45 As shown in Figure 18-29, Steps 1, 2, and 3 in the preceding algorithm partition the list into two sublists.
The elements less than pivot are in the lower sublist; the elements greater than or equal to pivot are in the upper sublist.
To partition the list into the lower and upper sublists, we need to keep track of only the last element of the lower sublist and the next element of the list that needs to be moved into either the lower sublist or the upper sublist.
In fact, the upper sublist is between the two indices smallIndex and index.
We now write the function, partition, to implement the preceding partition algorithm.
After rearranging the elements of the list, the function partition returns the location of pivot so that we can determine the starting and ending locations of the sublists.
The definition of the function partition is: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Note that the formal parameters  and last specify the starting and ending indices, respectively, of the sublist of the list to be partitioned.
As you can see from the definition of the function partition, certain elements of the list need to be swapped.
The following function, swap, accomplishes this task.
Once the list is partitioned into lowerSublist and upperSublist, we again apply the quick sort function to sort the two sublists.
Because both sublists are sorted using the same quick sort algorithm, the easiest way to implement this algorithm is to use recursion.
Therefore, this section gives the recursive version of the quick sort algorithm.
As explained previously, after rearranging the elements of the list, the function partition returns the  of  so that the starting and ending indices of the sublists can be determined.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Quick Sort: Array-Based Lists.
Programming Exercise 10 at the end of this chapter.
Analysis: Quick Sort The general analysis of the quick sort algorithm is beyond the scope of this book.
However, let us determine the number of comparisons in the worst case.
Suppose that L is a list of n elements, n  0.
In a quick sort, all of the sorting work is done by the function partition.
From the definition of the function partition, it follows that to partition a list of length k, the function partition makes k – 1 key comparisons.
Also, in the worst case, after partition, one sublist is of length k – 1, and the other sublist is of length 0.
It follows that in the worst case, the  call of the function partition makes n – 1 key comparisons.
In the  call, the function partition partitions a list of length n – 1, so it makes n – 2 key comparisons, and so on.
We can now conclude that to sort a list of length n, in the worst case, the total number of key comparisons made by a quick sort is: ðn  1 þ ðn  2 þ    þ 2 þ 1 ¼ nðn  1=2 ¼ Oðn2 : Table 18-10 summarizes the behavior of the quick sort algorithm for a list of length n.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
However, the worst-case behavior of a quick sort is (2).
This section describes the sorting algorithm whose behavior is always (nlog2).
Like the quick sort algorithm, the merge sort algorithm uses the divide-and-conquer technique to sort a list.
A merge sort algorithm also partitions the list into two sublists, sorts the sublists, and then combines the sorted sublists into one sorted list.
This section describes the merge sort algorithm for linked list-based lists.
We leave it for you to develop the merge sort algorithm for array-based lists, which can be done by using the techniques described for linked lists.
The merge sort and the quick sort algorithms differ in how they partition the list.
As discussed earlier, a quick sort  selects an element in the list, called , and then partitions the list so that the elements in one sublist are less than  and the elements in the other sublist are greater than or equal to.
By contrast, a merge sort divides the list into two sublists of nearly equal size.
For example, consider the list whose elements are as follows: list: 35 28.
Suppose that we have sorted the two sublists.
That is, suppose that the lists are now as follows: sublist: 18 28 35 45 sublist: 30 38 48 62 Next, the merge sort algorithm combines, that is, merges, the two sorted sublists into one sorted list.
Figure 18-30 further illustrates the merge sort process.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Merge Sort: Linked List-Based Lists.
Merge sort algorithm From Figure 18-30, it is clear that in the merge sort algorithm, most of the sorting work is done in merging the sorted sublists.
The general algorithm for the merge sort is as follows: if the list is of a size greater than 1 { a.
Divide the list into two sublists.
Merge sort the first sublist.
Merge sort the second sublist.
Merge the first sublist and the second sublist.
In other words, we use recursion to implement the merge sort algorithm.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Divide the list into two sublists of nearly equal size.
Merge sort both sublists.
Merge the sorted sublists.
Divide Because data is stored in a linked list, we do not know the length of the list.
Furthermore, a linked list is not a random access data structure.
Therefore, to divide the list into two sublists, we need to find the middle node of the list.
Consider the list in Figure 18-31.
Unsorted linked list To find the middle of the list, we traverse the list with two pointers—say, middle and current.
The pointer middle is initialized to the first node of the list.
Because this list has more than two nodes, we initialize current to the third node.
Also, if the list has only two nodes, we set current to nullptr_0_) Consider the list shown in Figure 18-32.
After advancing current by one node, if current is not nullptr, we again advance current by one node.
That is, for the most part, every time middle advances by one node, current advances by two nodes.
Eventually, current becomes nullptr and middle points to the last node of the first sublist.
For example, for the list in Figure 18-32, when current becomes nullptr, middle points to the node with info 25 (see Figure 18-33).
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Merge Sort: Linked List-Based Lists.
First, using the link of middle, we assign a pointer to the node following middle.
Then, we set the link of middle to nullptr.
Figure 18-34 shows the resulting sublists.
List after dividing it into two lists This discussion translates into the following Cplus_plus function, divideList: template <class Type> void unorderedLinkedList<Type>:: divideList(<Type>* 1, {.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Recall that in a merge sort, most of the sorting work is done in merging the sorted sublists.
Merge Once the sublists are sorted, the next step in the merge sort algorithm is to merge the sorted sublists.
Sorted sublists are merged into a sorted list by comparing the elements of the sublists and then adjusting the pointers of the nodes with the smaller info.
Let us illustrate this procedure on the sublists shown in Figure 18-35.
Suppose that 1 points to the  node of the  sublist, and 2 points to the  node of the second sublist.
Sublists before merging We  compare the info of the  node of each sublist to determine the  node of the merged list.
We set newHead to point to the  node of the merged list.
We also use the pointer lastMerged to keep track of the last node of the merged list.
The pointer of the  node of the sublist with the smaller node then advances to the next node of that sublist.
Figure 18-36 shows the sublist of Figure 18-35 after setting newHead and lastMerged and advancing 1.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Merge Sort: Linked List-Based Lists.
So, we again compare the nodes pointed to by 1 and 2, and adjust the link of the smaller node and the last node of the merged list so as to move the smaller node to the end of the merged list.
For the sublists shown in Figure 18-36, after adjusting the necessary links, we have Figure 18-37.
Merged list after putting the node with info 20 at the end of the merged list We continue this process for the remaining elements of both sublists.
Every time we move a node to the merged list, we advance either 1 or 2 to the next node.
Eventually, either 1 or 2 becomes nullptr.
If 1 becomes nullptr, the  sublist is exhausted , so we attach the remaining nodes of the second sublist at the end of the partially merged list.
If 2 becomes nullptr, the second sublist is exhausted , so we attach the remaining nodes of the  sublist at the end of the partially merged list.
Following this discussion, we can now write the Cplus_plus function mergeList to merge the two sorted sublists.
The pointers of the  nodes of the sublists are passed as parameters to the function mergeList.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Finally, we write the recursive merge sort function, recMergeSort, which uses the divideList and mergeList functions to sort a list.
The pointer of the  node of the list to be sorted is passed as a parameter to the function recMergeSort.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Merge Sort: Linked List-Based Lists.
We can now give the definition of the function mergeSort, which should be included as a public member of the class.
It also sets  to point to the  node of the list.
The definition of the function mergeSort is: template <class Type>.
Programming Exercise 13 at the end of this chapter.
Analysis: Merge Sort Suppose that L is a list of n elements, in which n > 0.
Suppose that n is a power of 2, that is, n ¼ 2m for some nonnegative integer m, so that we can divide the list into two sublists, each of size: n 2m ¼ 2m1 : ¼ 2 2 Moreover, each sublist can also be divided into two sublists of the same size.
Each call to the function recMergeSort makes two recursive calls to the function recMergeSort, and each Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
So, the length of the original list is 8.
The  call to the function recMergeSort divides the original list into two sublists, each of size 4.
The  call then makes two recursive calls to the function recMergeSort.
Each of these recursive calls divides each sublist, of size 4, into two sublists, each of size 2.
We now have four sublists, each of size 2.
The next set of recursive calls divides each sublist, of size 2, into sublists of size 1.
So, we now have eight sublists, each of size 1.
It follows that the exponent 3 in 23 indicates the level of the recursion (see Figure 18-38).
Recursion Level: 0 Number of calls to recMergeSort: 1 Each call: recMergeSort 8 elements 8.
FIGURE 18-38 Recursion Level: 1 Number of calls to recMergeSort: 2 Each call: recMergeSort 4 elements 4.
Note that the number of recursion levels is m.
Also, note that to merge a sorted list of size s with a sorted list of size t, the maximum number of comparisons is s + t  1.
Consider the function mergeList, which merges two sorted lists into a sorted list.
Note that this is where the actual work (comparisons and assignments) is done.
The initial call to the function recMergeSort, at level 0, produces two sublists, each of the size /2.
To merge these two lists, after they are sorted, the maximum number of comparisons is: þ  1 ¼   1 ¼ OðnÞ: 2 2 At level 1, we merge two sets of sorted lists, in which each sublist is of the size /4.
To merge two sorted sublists, each of the size /4, we need, at most: þ 1¼ 1 4 4 2 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Merge Sort: Linked List-Based Lists.
Thus, at level 1 of the recursion, the number of comparisons is 2( / 2 – 1) ¼ – 2 ¼ O().
In general, at level k of the recursion, there are a total of 2k calls to the function k+1 mergeList.
Each of these calls merges two sublists, each of the size  / 2 , which requires k a maximum of  / 2  1 comparisons.
Thus, at level k of the recursion, the maximum number of comparisons is: 2k  2k   1 ¼   2k ¼ OðnÞ: It now follows that the maximum number of comparisons at each level of the recursion is O().
Because the number of levels of the recursion is m, the maximum number of comparisons made by the merge sort algorithms is O(nm).
Now  ¼ 2m implies that m ¼ log2.
Hence, the maximum number of comparisons made by the merge sort algorithm is O( log2).
If W() denotes the number of key comparisons in the worst case to sort L, then W() ¼ O( log2).
Let A() denote the number of key comparisons in the average case.
In the average case, during merge, one of the sublists will exhaust before the other list.
From this, it follows that, on average, when merging two sorted sublists of combined size , the number of comparisons will be less than   1.
On average, it can be shown that the number of comparisons for merge sort is given by the following equation: If  is a power of 2, A() ¼  log2  1_0_25 ¼ O( log2).
This is also a good approximation when  is not a power of 2.
We can also obtain an analysis of the merge sort algorithm by constructing and solving certain equations as follows.
As noted before, in merge sort, all of the comparisons are made in the procedure mergeList, which merges two sorted sublists.
If one sublist is of size  and the other sublist is of size , then merging these lists would require, at most, þ   1 comparisons in the worst case.
Hence: ðnÞ ¼  ðsÞ þ  ðtÞ þ  þ   1: Note that  =  / 2 and  =  / 2.
Suppose that  = 2m.
It follows that  þ  =.
Hence: ðnÞ ¼  =2Þ þ  =2Þ þ   1 ¼ 2 =2Þ þ   1;  > 0: Also: ð1Þ ¼ 0: It is known that when  is a power of 2, () is given by the following equation: ðnÞ ¼  log2     1Þ ¼ Oðn log2 nÞ: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter().
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The necessary material is in the file Heap_Sort_0_pdf.
To find the file, navigate to the book' page by typing in the ISBN of this text and then click on Free Materials.
PROGRAMMING EXAMPLE: Election Results The presidential election for the student council of your local university is about to be held.
The chair of the election committee wants to computerize the voting and has asked you to write a program to analyze the data and report the winner.
Watch the Video The university has four major divisions, and each division has several departments.
For the election, the four divisions are labeled as region 1, region 2, region 3, and region 4.
Each department in each division handles its own voting and reports the votes received by each candidate to the election committee.
The voting is reported in the following form: firstName lastName regionNumber numberOfVotes The election committee wants the output in the following tabular form: minus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusElection Resultsminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minus Candidate Name minus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minus-Sheila Bower Danny Dillion Lisa Fisher Greg Goldy Peter Lamba Mickey Miller Region1 minus_minusminus_minusminus_minus23 25 110 75 285 112 Region2 minus_minusminus_minusminus_minus70 71 158 34 56 141 Votes Region3 minus_minusminus_minusminus_minus133 156 0 134 0 156 Region4 minus_minusminus_minusminus_minus267 97 0 0 46 67 Total minus_minusminus_minus-493 349 268 243 387 476 Winner: Sheila Bower, Votes Received: 493 Total votes polled: 2216 The names of the candidates must be in alphabetical order in the output.
For this program, we assume that six candidates are seeking the student council' president post.
This program can be enhanced to handle any number of candidates.
The data are provided in two files.
One file, candData_0_txt, consists of the names of the candidates seeking the president' post.
The names of the candidates in this file are in no particular order.
In the second file, voteData_0_txt, each line consists of the voting results in the following form: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: Election Results.
There is one entry per line.
For example, the input file containing the voting data looks like the following: Greg Goldy 2 34 Mickey Miller 1 56 Lisa Fisher 2 56 Peter Lamba 1 78 Danny Dillion 4 29 Sheila Bower 4 78.
The first line indicates that Greg Goldy received 34 votes from region 2.
PROBLEM ANALYSIS AND ALGORITHM DESIGN Input Two files: One containing the candidates' names and the other containing the voting data, as described previously.
Output The election results in a tabular form, as described previously, and the winner's name.
From the output, it is clear that the program must organize the voting data by region and calculate the total votes received by each candidate and polled for the election overall.
Furthermore, the names of the candidates must appear in alphabetical order.
The main component of this program is a candidate.
Therefore, first we will design the class candidateType to implement a candidate object.
Moreover, in this program, we use an array of candidateType object to implement the list of candidates.
Every candidate has a name and receives votes.
Because there are four regions, we can use an array of four components.
In Example 10-10 (Chapter 10), we designed the class personType to implement the name of a person.
Recall that an object of type personType can store the first name and the last name.
Now that we have discussed operator overloading, we redesign the class personType and define the relational operators so that the names of two people can be compared.
We will also overload the assignment operator for easy assignment and use the stream extraction and insertion operators for input/output.
Because every candidate is a person, we will derive the class candidateType from the class personType.
Therefore, the class personType has two member variables: firstName to store the first name and lastName to store the last name.
We declare these as protected so that the definition of the class personType can be easily extended to accommodate the requirements of a specific application needed to implement a person's name.
The definition of the class personType is given next.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Programming Example: Election Results.
The definitions of the member functions setName, getFirstName, getLastName, and the constructors are the same as those given in Chapter 10.
We, therefore, consider the definitions of the functions to overload the relational and stream operators.
The names of two people are the same if their  and  names are the same.
Therefore, the definition of the function to overload the equality  is: bool personType::==(const personType& right) const.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
As remarked previously, the main component of this program is candidate.
Every candidate has a name and can receive votes.
Because there are four regions, we can use an array of four components to store the votes received.
Therefore, we declare a list of six candidates of type candidateType.
This chapter extended the class unorderedArrayListType by illustrating how to  the searching and sorting algorithms developed in this chapter.
We will use this class to maintain the list of candidates.
This list of the assignment and relational operators for the class candidateType because these operators are used by the searching and sorting algorithms.
Data in the file containing the candidates' data consists of only the names of the candidates.
Therefore, in addition to overloading the assignment  so that the value of one object can be assigned to another object, we also overload the assignment  for the class candidateType so that only the name (of the personType) of the candidate can be assigned to a candidate object.
That is, we overload the assignment  twice: once for objects of type candidateType and once for objects of types candidateType and personType.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: Election Results.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
UML class diagram of class candidateType Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: Election Results.
To set the votes of a particular , the  number and the number of votes are passed as parameters to the function setVotes.
Because an array index starts at 0, 1 corresponds to the array component at position 0, and so on.
Therefore, to set the value of the correct array component, 1 is subtracted from the.
The definition of the function setVotes is:.
The definition of the function updateVotesByRegion is:.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
To overload the relational operators for the class candidateType, the names of the candidates are compared.
For example, two candidates are the same if they have the same name.
The definitions of these functions are similar to the definitions of the functions to overload the relational operators for the class personType and are given next.
Programming Example: Election Results.
Now that the class candidateType has been designed and implemented, we focus on designing the main program.
Because there are six candidates, we create a list, candidateList, containing six components of type candidateType.
The first thing that the program should do is read each candidate's name from the file candData_0_txt into the list candidateList.
Then, we sort candidateList.
The next step is to process the voting data from the file voteData_0_txt, which holds the voting data.
After processing the voting data, the program should calculate the total votes received by each candidate and print the data, as shown previously.
Thus, the general algorithm is: 1.
Read each candidate's name into candidateList.
Process the voting data.
Calculate the total votes received by each candidate.
Print the results.
The following statement creates the object candidateList.
Every component of the array list is an object of type candidateType.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
To save space, whenever needed, we will draw the object candidateList, as shown in Figure 18-41.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: Election Results.
Therefore, we write a function to accomplish this task.
The file candData_0_txt is opened in the function main.
The names of the input file and candidateList are, therefore, passed as parameters to the function fillNames.
Because the member variable list of the object candidateList is protected, it cannot be accessed directly.
We, therefore, create an object temp of type candidateType to store the candidates' names and use the function insertEnd (of list) to store each candidate's name in the object candidateList.
The definition of the function fillNames follows: void fillNames(ifstream& inFile,.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Object candidateList after a call to the function fillNames After reading the candidates' names, we next sort the array list of the object candidateList using any of the (array-based) sorting algorithms discussed in this chapter.
Because candidateList is an object of type unorderedArrayListType, we use the member function sort to sort candidateList.
In fact, you can use any array-based sorting algorithm discussed in this chapter_0_) The following statement accomplishes this task: candidateList_0_sort(); After this statement executes, candidateList is as shown in Figure 18-43.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: Election Results.
Object candidateList after the statement candidateList_0_sort(); executes Processing the voting data is quite straightforward.
Each entry in the file voteData_0_txt is of the form: firstName lastName regionNumber numberOfVotes After reading an entry from the file voteData_0_txt, we locate the row in the array list (of the object candidateList) corresponding to the specific candidate and update the entry specified by regionNumber.
The component votesByRegion is a private member of each component of the array list.
Moreover, list is a private member of candidateList.
The only way we can update the votes of a candidate is to make a copy of that candidate's record into a temporary object, update the object, and then copy the temporary object back into list by replacing the old  with the new  of the temporary object.
We can use the member function retrieveAt to make a copy of the candidate whose votes need to be updated.
After updating the temporary object, we can use the member function replaceAt to copy the temporary object back into the list.
Suppose the next entry read is: Lisa Fisher 2 35 This entry says that Lisa Fisher received 35 votes from region 2.
Suppose that before processing this entry, candidateList is as shown in Figure 18-44.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
After this statement executes, the object temp is as shown in Figure 18-46.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Programming Example: Election Results.
Now we copy the object temp into list (see Figure 18-47).
Essentially, the definition of the function processVotes is: void processVotes(ifstream& inFile,.
After processing the voting data, the next step is to find the total  received by each candidate.
This is done by adding the  received in each.
Now votesByRegion is a private member of candidateType, and list is a protected member of candidateList.
Therefore, to add the  for each candidate, we use the function retrieveAt to make a temporary copy of each candidate's data, add the  in the temporary object, and then copy the temporary object back into candidateList.
The following function does this:.
Programming Example: Election Results.
The following function accomplishes this task: {.
We now describe the function printResults, which prints the results.
Suppose that the variable sumVotes holds the total votes polled for the election, the variable largestVotes holds the largest number of votes received by a candidate, and the variable winLoc holds the index of the winning candidate in the array list.
Further Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The algorithm for this function is: 1.
Initialize sumVotes, , and  to zero.
For each candidate: a.
Retrieve the candidate's data into temp.
Print the candidate's name and relevant data.
Retrieve the total votes received by the candidate and update sumVotes.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Programming Example: Election Results.
Sample Run: After you have written the definitions of the functions of the class candidateType and of the function printResults and then run your program, it Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Quick Review | 1337 Greg Goldy 1 75 Peter Lamba 4 23 Sheila Bower 3 55 Mickey Miller 4 67 Peter Lamba 1 23 Danny Dillion 3 89 Mickey Miller 3 89 Peter Lamba 1 67 Danny Dillion 2 37 Sheila Bower 4 89 Mickey Miller 2 78 Lisa Fisher 1 87 Peter Lamba 1 90 Danny Dillion 4 56 QUICK REVIEW 1.
The sequential search algorithm searches the list for a given item, starting with the first element in the list.
It continues to compare the search item with the elements in the list until either the item is found or no more elements are left in the list with which it can be compared.
On average, the sequential search algorithm searches half of the list.
For a list of length n, in a successful search, on average, the sequential search nþ1 makes ¼ OðnÞ comparisons.
A binary search is much faster than a sequential search.
A binary search requires the list elements to be in order, that is, sorted.
To search for an item in a list of length 1024, a binary search requires no more than 11 iterations of the loop, and so no more than 22 comparisons.
For a list of length , in a successful search, on average, the binary search makes 2log2  3 key comparisons.
Let f be a function of.
By the term asymptotic, we mean the study of the function f as  becomes larger and larger without bound.
Let f and g be real-valued functions.
Assume that f and g are nonnegative, that is, for all real numbers , f()  0 and g()  0.
We say that f() is Big-O of g(), written f() = O(g()), if there exist positive constants c and 0 such that f()  cg() for all   0.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Suppose that the elements of L are sorted.
If SRH() is the minimum number of comparisons needed, in the worst case, by using a comparison-based algorithm to recognize whether an element x is in L, then SRH()  log2( + 1).
The binary search algorithm is the optimal worst-case algorithm for solving search problems by using the comparison method.
To construct a search algorithm of the order less than log2, it cannot be comparison based.
For a list of length , in which  > 0, the selection sort algorithm makes 1 2 1   key comparisons and 3(  1) item assignments.
Any sorting algorithm that sorts L by comparison of the keys only, in its worst case, makes at least O(nlog2) key comparisons.
Both the quick sort and merge sort algorithms sort a list by partitioning it.
To partition a list, the quick sort algorithm first selects an item from the list called pivot.
The algorithm then rearranges the elements so that the elements in one of the sublists are less than pivot and the elements in the other sublist are greater than or equal to pivot.
In a quick sort, the sorting work is done in partitioning the list.
On average, the number of key comparisons in a quick sort is O(nlog2).
In the worst case, the number of key comparisons in a quick sort is O(2).
The merge sort algorithm partitions the list by dividing it in the middle.
In a merge sort, the sorting work is done in merging the list.
The number of key comparisons in a merge sort is O(nlog2).
EXERCISES The number in parentheses at the end of an exercise refers to the learning objective listed at the beginning of the chapter.
Mark the following statements as true or false.
The member that uniquely identifies a data item is called the key of that Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
A binary search is faster on large lists, but a sequential search is faster on f.
For a sorted list of length 128, to determine whether an item is in the list, 4 3 g.
Let f() =   8 + 2, where  is a nonnegative integer.
For a list of length 100, the bubble sort given in this chapter makes j.
For a list of length 100, the selection sort given in this chapter makes k.
For a list of length 100, in the worst case the insertion sort given in this l.
Let L be a list of  distinct elements.
Any sorting algorithm that sorts L by m.
The quick sort algorithm partitions a list into two sublists such that the elements in the first sublist are less than pivot and the elements in the The merge sort algorithm partitions a list into two sublists such that the number of elements in the first sublist is less than the number of elements Consider the following list: b.
Write a version of the sequential search algorithm that can be used to Consider the following list: b.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Show the values of first, last, and middle and the number of comparisons after a.
What is the maximum number of comparisons made by the binary search algorithm, given in this chapter, to Each of the following expressions represents the number of operations for Let L be a sorted list of size 1000.
In the worst case, to determine whether an element x is in L, what is the minimum number of comparisons made by a Sort the following list using the bubble sort algorithm as discussed in this a.
The number of comparisons in the best case of a bubble sort algorithm, as given in this chapter, is O(2).
Show that the following version of the bubble sort algorithm reduces the number of comparisons in the best //list – list to be sorted.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Using the algorithm given in part (a), find the number of iterations 65, 14, 52, 43, 75, 25, 80, 90, 95 10.
Sort the following list using the bubble sort algorithm as discussed in this 46, 58, 16, 25, 83, 98, 8, 70, 5, 62 11.
Assume the following list of keys: 2, 5, 18, 32, 4, 16, 28 12.
The first four keys are in order.
To move 4 to its proper position using the insertion sort algorithm as described in this chapter, exactly how many key Assume the following list of keys: 12, 38, 45, 50, 55, 5, 30 13.
The first five keys are in order.
To move 5 to its proper position using the insertion sort algorithm as described in this chapter, exactly how many key Assume the following list of keys: 90, 12, 2, 80, 55, 11, 17, 15, 58, 98, 36 14.
This list is to be sorted using the insertion sort algorithm as described in this chapter for array-based lists.
Show the resulting list after seven passes of the Recall the insertion sort algorithm (contiguous version) as discussed in this chapter.
Assume the following list of keys: 30, 20, 35, 27, 96, 82, 56, 60, 48, 75, 5, 80 15.
Exactly how many key comparisons are executed to sort this list using the Suppose that L is a list of 10,000 elements.
Find the average number of comparisons made by bubble sort, selection sort, and insertion sort to sort Let L be a list of 1024 distinct elements.
Suppose L is sorted using a comparison-based algorithm.
In the worst case, what is the minimum Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Explain how the merge sort algorithm differs from the quick sort algorithm Assume the following list of keys: 36, 55, 89, 95, 65, 75, 13, 62, 86, 9, 23, 74, 2, 100, 98 This list is to be sorted using the quick sort algorithm as discussed in this chapter.
Give the resulting list after one call to the function partition.
What is the size of the list that the function partition partitioned.
What are the sizes of the two sublists created by the function partition.
Suppose that the list of keys is as given in Exercise 18 and that this list is to be sorted using the quick sort algorithm as discussed in this chapter.
Give the resulting list after two calls to the function partition.
What is the size of the list that the function partition partitioned.
What are the sizes of the two sublists created by the function partition.
Suppose that the list of keys is as given in Exercise 18.
Use the quick sort algorithm, as discussed in this chapter, to determine the number of times the Assume the following list of keys: a.
Use pivot as the median of the first, last, and middle elements What is the pivot.
Give the resulting list after one call to the function partition.
What is the size of the list that the function partition partitioned.
What are the sizes of the two sublists created by the function partition.
Suppose that the list of keys is as given in Exercise 21 and that this list is to be sorted using the quick sort algorithm as discussed in this chapter.
Use pivot as the median of the first, last, and middle elements of a.
What is the pivot during the second call of the function partitioned.
Give the resulting list after two calls to the function partition.
What is the size of the list that the function partition partitioned.
What are the sizes of the two sublists created by the function partition.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Use the quick sort algorithm, as discussed in this chapter, to determine the number of times the Suppose that L is a list of 11 elements and it is sorted using the merge sort What are the sizes of the first and second sublists after the first execution of the function divide.
How many times is the function divide called to sort L.
Suppose that L is a list of 10,000 elements.
Find the average number of Suppose that the elements of a list are in descending order and they need to be put in ascending order.
Write a Cplus_plus function that takes as input an array of items in descending order and the number of elements in the array.
The function rearranges the element of the array in ascending order.
Your function must not incorporate any sorting algorithms, that is, no item comparisons should take place.
PROGRAMMING EXERCISES 1.
Write and implement a recursive version of the sequential search algorithm.
Write and implement a recursive version of the binary search algorithm.
Also, write a program to test your algorithm.
Write a program to test the function you designed in Exercise 3.
Write a program to find the number of comparisons using binarySearch and the sequential search algorithm as follows: Suppose list is an array of 1000 elements.
Use a random number generator to fill list.
Use any sorting algorithm to sort list.
Search list for some items as follows: i.
Use the binary search algorithm to search the list.
Use the binary search algorithm to search the list, switching to a sequential search when the size of the search list reduces to less than 15.
If the item is found in the list, then print its position.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Call this function modifiedBubbleSort.
Also, write a program to test your function.
Write a program to test the selection sort algorithm for array-based lists as given in this chapter.
Write and test a version of the selection sort algorithm for linked lists.
Write a program to test the insertion sort algorithm for array-based lists as given in this chapter.
Write and test a version of the insertion sort algorithm for linked lists.
Write a program to test the quick sort algorithm for array-based lists as given in this chapter.
Hoare) Let L be a list of size n.
The quick sort algorithm can be used to find the kth smallest item in L, wherein 0  k  n  1, without completely sorting L.
Write and implement a Cplus_plus function, kThSmallestItem, that uses a version of the quick sort algorithm to determine the kth smallest item in L without completely sorting L.
Sort an array of 10,000 elements using the quick sort algorithm as follows: a.
Sort the array using pivot as the middle element of the array.
Sort the array using pivot as the median of the first, last, and middle elements of the array.
Sort the array using pivot as the middle element of the array.
However, when the size of any sublist reduces to less than 20, sort the sublist using an insertion sort.
Sort the array using pivot as the median of the first, last, and middle elements of the array.
When the size of any sublist reduces to less than 20, sort the sublist using an insertion sort.
Calculate and print the CPU time for each of the preceding four steps.
To find the current CPU time, declare a variable, say, , of type clock_t.
The statement  = clock(); stores the current CPU time in.
You can check the CPU time before and after a particular phase of a program.
Then, to find the CPU time for that particular phase of the program, subtract the before time from the after time.
Moreover, you must include the header file ctime to use the data type clock_t and the function clock.
Use a random number generator to initially fill the array.
Write a program to test the merge sort algorithm for linked lists as given in this chapter.
Write and test a version of the merge sort algorithm for array-based lists.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The program then sorts list1 using bubble sort, list2 using selection sort, and list3 using insertion sort and outputs the number of comparisons and item assignments made by each sorting algorithm.
Write a program that creates three identical lists, list1, list2, and list3, of 5000 elements.
The program then sorts list1 using quick sort, list2 using insertion sort, and list3 using merge sort and outputs the number of comparisons and item assignments made by quick sort and insertion sort and the number of comparisons made by merge sort.
Write a program to test the function you designed in Exercise 26.
Write the definitions of the function printResults of the Election Results programming example.
Also, write a program to produce the output shown in the sample run of this programming example.
In the Election Results programming example, the class candidateType contains a function calculateTotalVotes, which calculates the total number of votes received by a candidate.
After processing the voting data, this function calculates the total number of votes for a candidate.
The function updateVotesByRegion (of the class candidateType) updates only the number of votes for a particular region.
Modify the definition of this function so that it also updates the total number of votes received by the candidate.
By doing so, the function addVotes in the main program is no longer needed.
Modify and run your program with the modified definition of the function updateVotesByRegion.
In the Election Results programming example, the object candidateList of type unorderedArrayListType is declared to process the voting data.
The operations of inserting a candidate's data and updating and retrieving the votes were somewhat complicated.
The member variable list is a protected member of candidateList, and each component of list is a private member.
To update the candidates' votes, copy each candidate's data from candidateList into a temporary object of type candidateType, update the temporary object, and then replace the candidate's data with the temporary object.
In this exercise, you are to modify the Election Results programming example to simplify the accessing of a candidate's data.
Derive the class candidateListType from the class unorderedArrayListType as follows: class candidateListType: public unorderedArrayListType<candidateType> { public:.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Because the class candidateListType is derived from the class unorderedArrayListType, and list is a protected member of the class unorderedArrayListType (inherited from the class arrayListType), list can be directly accessed by a member of the class candidateListType.
Write the definitions of the member functions of the class candidateListType.
Rewrite and run your program using the class candidateListType.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Learn about the basic terminologies used in binary trees: left and right subtrees, path, height, level of a node, leaves, parent of a node 3.
Explore binary tree traversal algorithms and functions as parameters Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
You have already seen how to store and process data in an array.
Because an array is a random-access data structure, if the data is properly organized (say, sorted), then we can use a search algorithm, such as a binary search, to effectively find and retrieve an item from the list.
However, we know that storing data in an array has its limitations.
For example, item insertion (especially if the array is sorted) and item deletion can be very time consuming, especially if the list  is very large, because each of these operations requires data movement.
To speed up item insertion and deletion, we used linked lists.
Item insertion and deletion in a linked list do not require any data movement; we simply adjust some of the links in the list.
However, one of the drawbacks of linked lists is that they must be processed sequentially.
That is, to insert or delete an item, or simply to search the list for a particular item, we must begin our search at the first node in the list.
As you know, a sequential search is good only for very small lists because the average search length of a sequential search is half the  of the list.
Binary Trees This chapter discusses how to organize data dynamically so that item insertion, deletion, and lookups are more efficient.
We first introduce some definitions to facilitate our discussion.
Definition: A binary tree, T, is either empty or such that: i.
T has a special node called the root node; ii.
T has two sets of nodes, LT and RT, called the left subtree and right subtree of T, respectively; and iii.
LT and RT are binary trees.
Suppose that T is a binary tree with the root node A.
Let LA denote the left subtree of A and RA denote the right subtree of A.
Now LA and RA are binary trees.
Suppose that B is the root node of LA and C is the root node of RA.
B is called the left child of A; C is called the right child of A.
Moreover, A is called the parent of B and C.
A binary tree can be shown pictorially.
In the diagram of a binary tree, each node of the binary tree is represented as a circle, and the circle is labeled by the node.
The root node of the binary tree is drawn at the top.
The left child of the root node (if any) is drawn is drawn below and to the right of the root node.
Children are connected to the parent by an arrow from the parent to the child.
An arrow is usually called a directed edge or a directed branch (or simply a branch) (see Figure 19-1).
Because the root node, B, of LA is already drawn, we apply the same (recursive) procedure to draw the remaining parts of LA.
RA is drawn similarly.
If a node has no left child, for example, we draw an arrow from the node to the left, ending with three stacked lines.
That is, three lines at the end of an arrow indicate that the subtree is empty.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
H 1 9 FIGURE 19-1 Binary tree In Figure 19-1, the root node of this binary tree is A.
The left subtree of the root node, which we denote by LA, is the set LA ¼ {B, D, E, G}, and the right subtree of the root node, which we denote by RA, is the set RA ¼ {C, F, H}.
The root node of the left subtree of A—that is, the root node of LA—is node B.
The root node of RA is C, and so on.
Clearly, LA and RA are binary trees.
Because three lines at the end of an arrow mean that the subtree is empty, it follows that the left subtree of D is empty.
Also, note that for node F, the left child is H and node F has no right child.
Example 19-1 shows nonempty binary trees.
EXAMPLE 19-1 Figure 19-2 shows binary trees with one, two, or three nodes.
B (a) Binary tree with one node FIGURE 19-2 (b) Binary tree with two nodes A C (c) Binary tree with two nodes B C (d) Binary tree with three nodes Binary tree with one, two, or three nodes In the binary tree of Figure 19-2(a), the root node is A, LA ¼ empty, and RA ¼ empty.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The root node of LA ¼ B, LB ¼ empty, and RB ¼ empty.
In the binary tree of Figure 19-2(c), the root node is A, LA ¼ empty, and RA ¼ {C}.
The root node of RA ¼ C, LC ¼ empty, and RC ¼ empty.
In the binary tree of Figure 19-2(d), the root node is A, LA ¼ {B}, and RA ¼ {C}.
The root node of LA ¼ B, LB ¼ empty, and RB ¼ empty.
The root node of RA ¼ C, LC ¼ empty, and RC ¼ empty.
EXAMPLE 19-2 Figure 19-3 shows other cases of nonempty binary trees with three nodes.
Various binary trees with three nodes As you can see from the preceding examples, every node in a binary tree has, at most, two children.
Thus, every node, other than storing its own information, must keep track of its left subtree and right subtree.
This implies that every node has two pointers, say, lLink and rLink.
The pointer lLink points to the root node of the left subtree of the node; the pointer rLink points to the root node of the right subtree of the node.
The following struct defines the node of a binary tree: template <class elemType> struct.
The data is stored in info.
A pointer to the left child is stored in lLink.
A pointer to the right child is stored in rLink.
Furthermore, a pointer to the root node of the binary tree is stored outside of the binary tree in a pointer variable, usually called the root, of type.
Thus, in general, a binary tree looks like the diagram in Figure 19-4.
D E G FIGURE 19-4 C F H Binary tree For simplicity, we will continue to draw binary trees as before.
That is, we will use circles to represent nodes and left and right arrows to represent links.
As before, three lines at the end of an arrow mean that the subtree is empty.
Before we leave this section, let us define a few terms.
A node in a binary tree is called a leaf if it has no left and right children.
Let U and V be two nodes in the binary tree T.
U is called the parent of V if there is a branch from U to V.
A path from a node X to a node Y in a binary tree is a sequence of nodes X0, X1,.
X ¼ X0, Xn ¼ Y ii.
Xi1 is the parent of Xi for all i ¼ 1, 2,.
Because the branches only go from a parent to its children, from the previous discussion it is clear that in a binary tree, there is a unique path from the root to every node in the binary tree.
Definition: The length of a path in a binary tree is the number of branches on that path.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Clearly, the level of the root node of a binary tree is 0, and the level of the children of the root node is 1.
Definition: The height of a binary tree is the number of nodes on the longest path from the root to a leaf.
EXAMPLE 19-3 Consider the binary tree of Figure 19-5.
In this example, the terms such as node A and (node with info A) mean the same thing.
Binary tree In this binary tree, the nodes I, E, and H have no left and right children.
So, the nodes I, E, and H are leaves.
There is a branch from node A to node B.
So, node A is the parent of node B.
Similarly, node A is the parent of node C, node B is the parent of nodes D and E, node C is the parent of node F, node D is the parent of node G, and so on.
A–B–D–G is a path from node A to node G.
Because there are three branches on this path, the length of this path is 3.
Similarly, B–D–G–I is a path from node B to node I.
There are three leaves in this binary tree, which are I, E, and H.
Also, the paths from root to these leaves are: A–B–D–G-I, A–B–E, and A–C–F–H.
Clearly, the longest path from Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The number of nodes on this path is 5.
Hence, the height of the binary tree is 5.
Suppose that a pointer, , to the root node of a binary tree is given.
We next describe a Cplus_plus function, height, to find the height of the binary tree.
The pointer to the root node is passed as a parameter to the function height.
If the binary tree is empty, then the height is 0.
Suppose that the binary tree is nonempty.
To find the height of the binary tree, we first find the height of the left subtree and the height of the right subtree.
We then take the maximum of these two heights and add 1 to find the height of the binary tree.
To find the height of the left (right) subtree, we apply the same procedure because the left (right) subtree is a binary tree.
Therefore, the general algorithm to find the height of a binary tree is as follows.
Suppose height() denotes the height of the binary tree with root.
The definition of the function height uses the function max to determine the larger of two integers.
The function max can be easily implemented.
Similarly, we can implement algorithms to find the number of nodes and number of leaves in a binary tree.
Copy Tree One useful operation on binary trees is to make an identical copy of a binary tree.
A binary tree is a dynamic data structure; that is, memory for the nodes of a binary tree is allocated and deallocated during program execution.
Therefore, if we use just the value of the pointer of the root node to make a copy of a binary tree, we get a shallow copy of the data.
To make an identical copy of a binary tree, we need to create as many nodes as there are in the binary tree to be copied.
Moreover, in the copied tree, these nodes must appear in the same order as they are in the original binary tree.
Given a pointer to the root node of a binary tree, we next describe a function that makes a copy of a given binary tree.
This function is also quite useful in implementing the copy constructor and overloading the assignment operator, as described later in this chapter (see "Implementing Binary Trees").
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Binary Tree Traversal The item insertion, deletion, and lookup operations require that the binary tree be traversed.
Thus, the most common operation performed on a binary tree is to traverse the binary tree, or visit each node of the binary tree.
As you can see from the diagram of a binary tree, the traversal must start at the root node because there is a pointer to the root node of the binary tree.
For each node, we have two choices:.
Visit the node first.
Visit the subtrees first.
These choices lead to three commonly used traversals of a binary tree:.
Inorder traversal Preorder traversal Postorder traversal INORDER TRAVERSAL In an inorder traversal, the binary tree is traversed as follows: 1.
Traverse the left subtree.
Visit the node.
Traverse the right subtree.
PREORDER TRAVERSAL In a preorder traversal, the binary tree is traversed as follows: 1.
Visit the node.
Traverse the left subtree.
Traverse the right subtree.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Traverse the left subtree.
Traverse the right subtree.
Visit the node.
Clearly, each of these traversal algorithms is recursive.
The listing of the nodes produced by the inorder traversal of a binary tree is called the inorder sequence.
The listing of the nodes produced by the preorder traversal is called the preorder sequence, and the listing of the nodes produced by the postorder traversal is called the postorder sequence.
EXAMPLE 19-4 Consider the binary tree in Figure 19-6.
Let T be a binary tree.
Suppose that T is nonempty and the root node of T is A.
Then inorder(T) or inorder(A) denotes the listing of nodes of T in the inorder sequence and root(T) denotes the root node of T.
For simplicity, we assume that visiting a node means to output the data stored in the node.
In the section "Binary Tree Traversal and Functions as Parameters," we will explain how to modify the binary tree traversal algorithms so that by using a function, the user can specify the action to be performed on a node when the node is visited.
Binary tree for an inorder traversal.
Because the binary tree is nonempty, to determine inorder(A), we do the following: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Determine inorder(LA), where LA is the left subtree of A.
Note that LA ¼ {B, D, F}.
Determine inorder(RA), where RA is the right subtree of A.
Note that RA ¼ {C, E, G}.
Now we cannot do Step 2 until we have finished Step 1.
Determine inorder(LB), where LB ¼ {D, F}.
Determine inorder(LD), where LD ¼ empty.
Determine inorder(RD), where RD ¼ {F}.
Because LD ¼ empty, Step 1_0_1_0_1 is completed, so we proceed to Step 1_0_1_0_2, which outputs D.
Because Step 1_0_1_0_2 is also completed, we proceed to Step 1_0_1_0_3.
Determine inorder(RD), where RD ¼ {F}.
Now RD is a binary tree, and root(RD) ¼ F.
So to determine inorder(RD), we do the following: 1_0_1_0_3_0_1.
Determine inorder(LF), where LF ¼ empty.
Determine inorder(RF), where RF ¼ empty.
Because LF ¼ empty, Step 1_0_1_0_3_0_1 is completed, so we proceed to Step 1_0_1_0_3_0_2, which outputs F.
Because Step 1_0_1_0_3_0_2 is also completed, we proceed to Step 1_0_1_0_3_0_3.
Because RF ¼ empty, this step is also completed.
Thus, Step 1_0_1_0_3 is completed, which in turn completes Step 1_0_1.
Next, we proceed to Step 1_0_2, which outputs B.
After completing Step 1_0_2, we proceed to Step 1_0_3.
Now Step 1_0_3 requires us to determine inorder(RB).
However, RB ¼ empty, so Step 1_0_3 is completed, which in turn completes Step 1.
Next, we proceed to Step 2, which outputs A.
At this point we have completed inorder(LA) and visited A.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Now RA is a nonempty binary tree and root(RA) ¼ C, so to determine inorder(RA), we need to do the following: 3_0_1.
Determine inorder(LC), where LC ¼ empty.
Now LC ¼ empty, so Step 3_0_1 is completed.
Next, in Step 3_0_2, we output C, which completes this step.
After completing Step 3_0_2, we proceed to Step 3_0_3.
Determine inorder(RC), where RC ¼ {E, G}.
Now RC is a nonempty binary tree with root(RC) ¼ E.
Thus, inorder(RC) requires us to complete the following steps:.
Determine inorder(RE), where RE ¼ empty.
Now LE is a binary tree with root(LE) ¼{G}.
Determine inorder(LG), where LG ¼ empty.
Determine inorder(RG), where RG ¼ empty.
Now LG ¼ empty, so Step 3_0_3_0_1_0_1 is completed.
Next Step 3_0_3_0_1_0_2 outputs G, which completes this step.
Because RG ¼ empty, Step 3_0_3_0_1_0_3 is also completed.
This in turn completes Step 3_0_3_0_1.
After completing Step 3_0_3_0_1, to complete Step 3_0_3_0_2, we output E.
Next because RE ¼ empty, Step 3_0_3_0_3 is also completed, which in turn completes Step 3_0_3.
Because Step 3_0_3 is completed, Step 3 is also completed, that is we have determined inorder(RA).
It now follows that: inorder(A) ¼ DFBACGE.
The links are only in one direction; that is, the parent node points to the left and right children, but there is no pointer from each child to the parent.
Therefore, before going to a child, we must somehow save a pointer to the Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
A convenient way to do this is to write a recursive inorder function because in a recursive call, after completing a particular call, the control goes back to the caller.
This section described the binary tree traversal algorithms inorder, preorder, and postorder.
If you want to make a copy of a binary tree while preserving the structure of the binary tree, you can use preorder traversal.
To delete all of the nodes of a binary tree, you can use the postorder traversal.
Later in this chapter, we will discuss binary search trees.
The inorder traversal of a binary search tree visits the nodes in sorted order.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Implementing Binary Trees.
In Chapter 20, we discuss graphs.
A binary tree is also a graph.
We discuss how to implement breadth-first traversal algorithms for graphs.
You can modify that algorithm to do a breadth-first traversal of binary trees.
Implementing Binary Trees The preceding sections described various operations that can be performed on a binary tree, as well as the functions to implement these operations.
This section describes binary trees as an abstract data type (ADT).
Before designing the class to implement a binary tree as an ADT, let us list the various operations that are typically performed on a binary tree.
Determine whether the binary tree is empty.
Search the binary tree for a particular item.
Insert an item in the binary tree.
Delete an item from the binary tree.
Find the height of the binary tree.
Find the number of nodes in the binary tree.
Find the number of leaves in the binary tree.
Traverse the binary tree.
Copy the binary tree.
The item search, insertion, and deletion operations all require the binary tree to be traversed.
However, because the nodes of a binary tree are in no particular order, these algorithms are not very efficient on arbitrary binary trees.
That is, no criteria exist to guide the search on these binary trees, as we will see in the next section.
Therefore, we will discuss these algorithms when we discuss special binary trees.
The following class defines binary trees as an ADT.
The definition of the node is the same as before.
However, for the sake of completeness and easy reference, we give the definition of the node followed by the definition of the class: //Definition of the Node template <class elemType>.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Implementing Binary Trees.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
See Exercise 33 at the end of this chapter.
The functions search, insert, and deleteNode are declared as abstract in the definition of the class.
This is because, in this section, we are discussing arbitrary binary trees.
Implementing these operations for arbitrary binary trees is inefficient, if not impossible, as we will discuss in the section "Binary Search Trees_0_" Because the class contains abstract functions, this class is an abstract class.
So, you cannot create objects of this class.
In the section "Binary Search Tree," we will derive a class from the class  and provide the definitions of these functions.
Note that the definition of the class  contains the statement to overload the assignment , copy constructor, and destructor.
This is because the class  contains pointer member variables.
Recall that for classes with pointer member variables, we must explicitly overload the assignment , include the copy constructor, and include the destructor.
The definition of the class  contains several member functions that are private members of the class.
These functions are used to implement the public member functions of the class.
For example, to do an inorder traversal, the function inorderTraversal calls the function inorder and passes the pointer  as a parameter to this function.
Moreover, the pointer  is declared as a protected member so that we can later derive special binary trees.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Implementing Binary Trees.
The binary tree is empty if  is nullptr.
So the definition of the function isEmpty is: template <class elemType>.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Implementing Binary Trees.
The definitions of the functions nodeCount and leavesCount are left as exercises for you.
See Programming Exercises 1 and 2 at the end of this chapter.
Next, we give the definitions of the functions copyTree, destroy, destroyTree; the copy constructor; and the destructor.
The definition of the function copyTree is the same as before; here, this function is a member of the class.
To destroy a binary tree, for each node, first we destroy its left subtree, then its right subtree, and then the node itself.
We must use the operator delete to deallocate the memory occupied by the node.
The definition of the function destroy is: template <class elemType>.
To implement the function destroyTree, we use the function destroy and pass the node of the binary tree to the function destroy.
The definition of the function destroyTree is: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Recall that when a class object is passed by value, the copy constructor copies the value of the actual parameters into the formal parameters.
Because the class has pointer member variables and a pointer is used to create dynamic memory, we must provide the definition of the copy constructor to avoid the shallow copying of data.
The definition of the copy constructor, given next, uses the function copyTree to make an identical copy of the binary tree that is passed as a parameter.
The definition of the destructor is quite straightforward.
When the object of type goes out of scope, the destructor deallocates the memory occupied by the nodes of the binary tree.
The definition of the destructor uses the function destroy to accomplish this task.
Next, we discuss the definition of the function to overload the assignment.
To assign the value of one binary tree to another binary tree, we make an identical copy of the binary tree to be assigned by using the function copyTree.
The definition of the function to overload the assignment  is: //Overload the assignment template <class elemType>.
Binary Search Trees.
Now that you know the basic operations on a binary tree,  section discusses a special type of binary tree called the binary search tree.
FIGURE 19-7 60 98 53 Arbitrary binary tree Suppose that we want to determine whether 53 is in the binary tree.
To do so, we can use any of the previous traversal algorithms to visit each node and compare the search item with the data stored in the node.
However,  could require us to traverse a large part of the binary tree, so the search will be slow.
The reason that we need to visit each node in the binary tree until either the item is found or we have traversed the entire binary tree is that no criteria exist to guide our search.
This case is like an arbitrary linked list, in which we must start our search at the first node and continue looking at each node until either the item is found or the entire list is searched.
On the other hand, consider the binary tree in Figure 19-8.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Binary search tree In the binary tree in Figure 19-8, the data in each node is:.
Larger than the data in its left child Smaller than the data in its right child The binary tree in Figure 19-8 has some order to its nodes.
Suppose that we want to determine whether 58 is in  binary tree.
As before, we must start our search at the node.
We compare 58 with the data in the  node; that is, we compare 58 with 60.
Because 58 6¼ 60 and 58 < 60, it is guaranteed that 58 will not be in the right subtree of the node.
Therefore, if 58 is in the binary tree, then it must be in the left subtree of the node.
We follow the left pointer of the  node and go to the node with info 50.
We now apply the same criteria at  node.
Because 58 > 50, we must follow the right pointer of node and go to the node with info 58.
At  node, we find 58.
This example shows that every time we move down to a child, we eliminate one of the subtrees of the node from our search.
If the binary tree is nicely constructed, then the search is very similar to the binary search on arrays.
The binary tree given in Figure 19-8 is a special type of binary tree called a binary search tree.
T has a special node called the  node; ii.
T has two sets of nodes, LT and RT, called the left subtree and right subtree of T, respectively;.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Binary Search Trees.
The key in the  node is larger than every key in the left subtree and smaller than every key in the right subtree; and iv.
LT and RT are binary search trees.
The following operations are typically performed on a binary search tree.
Determine whether the binary search tree is empty.
Search the binary search tree for a particular item.
Insert an item in the binary search tree.
Delete an item from the binary search tree.
Find the height of the binary search tree.
Find the number of nodes in the binary search tree.
Find the number of leaves in the binary search tree.
Traverse the binary search tree.
Copy the binary search tree.
Clearly, every binary search tree is a binary tree.
The height of a binary search tree is determined in the same way as the height of a binary tree.
Similarly, the operations to find the number of nodes, to find the number of leaves, and to do inorder, preorder, and postorder traversals of a binary search tree are the same as those for a binary tree.
Therefore, we can inherit all of these operations from the binary tree.
That is, we can extend the definition of the binary tree by using the principle of inheritance and hence define the binary search tree.
The following class defines a binary search tree as an ADT by extending the definition of the binary tree: template <class elemType> class bSearchTreeType: public binaryTreeType<elemType> { public: bool search(const elemType& searchItem) const;.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
See Exercise 34 at the end of this chapter.
Next, we describe each of these operations.
SEARCH The function search searches the binary search tree for a given item.
If the item is found in the binary search tree, it returns true; otherwise, it returns false.
Because the pointer root points to the root node of the binary search tree, we must begin our search at the root node.
Furthermore, because root must always point to the root node, we need a pointer—say, current—to traverse the binary search tree.
The pointer current is initialized to root.
If the binary search tree is nonempty, we first compare the search item with the info in the root node.
If they are the same, we stop the search and return true.
Otherwise, if the search item is smaller than the info in the node, we follow lLink to go to the left subtree; otherwise, we follow rLink to go to the right subtree.
We repeat this process for the next node.
If the search item is in the binary search tree, our search ends at the node containing the search item; otherwise, the search ends at an empty subtree.
Thus, the general algorithm is: if root is nullptr Cannot search an empty tree, returns false.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Binary Search Trees.
INSERT After inserting an  in a binary search , the resulting binary  must be a binary search.
To insert a new , first we search the binary search  and find the place where the new  is to be inserted.
The search algorithm is similar to the search algorithm of the function search.
Here, we traverse the binary search  with two pointers—a pointer, say, , to check the   and a pointer, say, trailCurrent, pointing to the parent of.
Because duplicate items are not allowed, our search must end at an empty subtree.
We can then use the pointer trailCurrent to insert the new  at the proper place.
The  to be inserted, insertItem, is passed as a parameter to the function insert.
The general algorithm is: a.
Create a new  and copy insertItem into the new.
Also set lLink and rLink of the new  to nullptr.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Binary Search Trees.
DELETE As before, first we search the binary search  to find the  to be deleted.
To help you better understand the delete operation, before describing the function to delete an from the binary search , let us consider the binary search  in Figure 19-9.
Binary search  before deleting a After deleting the desired  (if it exists in the binary search ), the resulting must be a binary search.
The delete operation has four cases, as follows: Case 1: The  to be deleted has no left and right subtrees; that is, the  to be deleted is a leaf.
For example, the  with info 45 is a leaf.
Case 2: The  to be deleted has no left subtree; that is, the left subtree is empty, but it has a nonempty right subtree.
For example, the left subtree of  with info 40 is empty, and its right subtree is nonempty.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
For example, the left subtree of  with info 80 is empty, and its right subtree is nonempty.
Case 4: The  to be deleted has nonempty left and right subtrees.
For example, the left and the right subtrees of  with info 50 are nonempty.
Figure 19-10 illustrates these four cases.
Binary trees of Figure 19-9 after deleting various items Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Binary Search Trees.
We search the binary tree and arrive at the node containing 45.
Because this node is a leaf and is the left child of its parent, we can simply set the lLink of the parent node to nullptr and shows the resulting binary search tree.
Case 2: Suppose that we want to delete 30 from the binary search tree in Figure 19-9.
In this case, the node to be deleted has no left subtree.
Because 30 is the left child of its parent node, we make the lLink of the parent node point to the right child of 30 and then deallocate the memory occupied by 30.
Figure 19-10(b) shows the resulting binary tree.
Case 3: Suppose that we want to delete 80 from the binary search tree of Figure 19-9.
The node containing 80 has no right child and is the right child of its parent.
Thus, we make the rLink of the parent of 80—that is, 70—point to the left child of 80.
Figure 19-10(c) shows the resulting binary tree.
Case 4: Suppose that we want to delete 50 from the binary search tree in Figure 19-9.
The node with info 50 has a nonempty left subtree and a nonempty right subtree.
Here, we first reduce this case to either case 2 or case 3 as follows.
To be specific, suppose that we reduce it to case 3—that is, the node to be deleted has no right subtree.
For this case, we find the immediate predecessor of 50 in this binary tree, which is 48.
This is done by first going to the left child of 50 and then locating the rightmost node of the left subtree of 50.
To do so, we follow the rLink of the nodes.
Because the binary search tree is finite, we eventually arrive at a node that has no right subtree.
Next, we swap the info in the node to be deleted with the info of its immediate predecessor.
In this case, we swap 48 with 50.
This reduces to the case wherein the node to be deleted has no right subtree.
We now apply case 3 to delete the node.
In each case, we clearly see that the resulting binary tree is again a binary search tree.
From this discussion, it follows that to delete an item from the binary search tree, we must do the following: 1.
Find the node containing the item (if any) to be deleted.
Delete the node.
We accomplish the second step by a separate function, which we will call deleteFromTree.
Given a pointer to the node to be deleted, this function deletes the node by taking into account the previous four cases.
From the preceding examples, it is clear that whenever we delete a node from the binary tree, we adjust one of the pointers of the parent node.
Because the adjustment has to be made in the parent node, we must call the function deleteFromTree by using an appropriate pointer of the parent node.
For example, suppose that the node to be deleted is 35, which is the right child of its parent node.
Suppose that trailCurrent points to the node containing 30, the parent node of 35.
A call to the function deleteFromTree is: deleteFromTree(trailCurrentarrow_operatorrLink); Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Binary Search Trees.
Next, we describe the function deleteNode.
The function deleteNode first searches the binary search tree to find the node containing the item to be deleted.
The item to be deleted, deleteItem, is passed as a parameter to the function.
If the node containing deleteItem is  in the binary search tree, the function deleteNode calls the function deletefromTree to delete the node.
The definition of the function deleteNode is given next.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Binary Search Tree: Analysis Let T be a binary search tree with n nodes, in which n > 0.
Suppose that we want to determine whether an item, x, is in T.
The performance of the search algorithm depends on the shape of T.
Let us first consider the worst case.
In the worst case, T is linear.
That is, the T is one of the forms shown in Figure 19-11.
Linear binary search trees Because T is linear, the performance of the search algorithm on T is the same as its performance on a linear list.
Therefore, in the successful case, on average, the search algorithm makes n þ 1 ¼ OðnÞ key comparisons.
In the unsuccessful case, it makes n comparisons.
In the successful case, the search would end at a node.
Because there are n items, there are n.
We assume that all n.
Let S(n) denote the number of comparisons in the average successful case, and let U(n) denote the number of comparisons in the average unsuccessful case.
The number of comparisons required to determine whether x is in T is one more than the number of comparisons required to insert x in T.
Furthermore, the number of Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Nonrecursive Binary Tree Traversal Algorithms.
From this, it follows that: SðnÞ ¼ 1 þ Uð0Þ þ Uð1Þ þ ::: þ Uðn  1Þ n ð19-1Þ It is also known that:  SðnÞ ¼  1 1 þ UðnÞ  3 n ð19-2Þ Solving equations (19-1) and (19-2), it can be shown that: UðnÞ  2:77log2 n ¼ Oðlog2 nÞ and: SðnÞ  2:77log2 n ¼ Oðlog2 nÞ We can now formulate the following result.
Theorem: Let T be a binary search tree with n nodes, in which n > 0.
The average number of nodes visited in a search of T is approximately 1_0_39log2n ¼ O(log2n), and the number of key comparisons is approximately 2_0_77log2n ¼ O(log2n).
Nonrecursive Binary Tree Traversal Algorithms The previous sections described how to do the following:.
Traverse a binary tree using the inorder, preorder, and postorder methods.
Construct a binary tree.
Insert an item in the binary tree.
Delete an item from the binary tree.
The traversal algorithms—inorder, preorder, and postorder—discussed earlier are recursive.
Because traversing a binary tree is a fundamental operation, this section discusses the nonrecursive inorder, preorder, and postorder traversal algorithms.
Nonrecursive Inorder Traversal In the inorder traversal of a binary tree, for each node, the left subtree is visited first, then the node, and then the right subtree.
It follows that in an inorder traversal, the first node visited is the leftmost node of the binary tree.
For example, in the binary tree in Figure 19-12, the leftmost node is the node with info 28.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Binary tree; the leftmost node is 28 To get to the leftmost node of the binary tree, we start by traversing the binary tree at the root node and then follow the left link of each node until the left link of a node becomes null.
From this point, we back up to the parent node, visit the node, and then move to the right node.
Because links go in only one direction, to get back to a node, we must save a pointer to the node before moving to the child node.
Moreover, the nodes must be backtracked in the order they were traversed.
It follows that while backtracking, the nodes must be visited in a last-in first-out manner.
We, therefore, save a pointer to a node in a stack.
The general algorithm is as follows: 1.
Nonrecursive Binary Tree Traversal Algorithms.
Nonrecursive Preorder Traversal In a preorder traversal of a binary tree, for each node, first the node is visited, then the left subtree is visited, and then the right subtree is visited.
As in the case of an inorder traversal, after visiting a node and before moving to the left subtree, we must save a pointer to the node so that after visiting the left subtree, we can visit the right subtree.
The general algorithm is as follows: 1.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Nonrecursive Postorder Traversal In a postorder traversal of a binary tree, for each node, first the left subtree is visited, then the right subtree is visited, and then the node is visited.
As in the case of an inorder traversal, in a postorder traversal, the first node visited is the leftmost node of the binary tree.
Because—for each node—the left and right subtrees are visited before visiting the node, we must indicate to the node whether the left and right subtrees have been visited.
After visiting the left subtree of a node and before visiting the node, we must visit its right subtree.
Therefore, after returning from a left subtree, we must tell the node that the right subtree needs to be visited, and after visiting the right subtree, we must tell the node that it can now be visited.
To do this, other than saving a pointer to the node (to get back to the right subtree and to the node itself), we also save an integer value of 1 before moving to the left subtree and an integer value of 2 before moving to the right subtree.
Whenever the stack is popped, the integer value associated with that pointer is popped as well.
This integer value tells whether the left and right subtrees of a node have been visited.
The general algorithm is: 1.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Binary Tree Traversal Algorithms and Functions as Parameters.
We will use two (parallel) stacks: one to save a pointer to a node and another to save the integer value (1 or 2) associated with this pointer.
We leave it as an exercise for you to write the definition of a Cplus_plus function to implement the preceding postorder traversal algorithm.
See Programming Exercise 6 at the end of this chapter.
Binary Tree Traversal Algorithms and Functions as Parameters Suppose that you have stored employee data in a binary search tree, and at the end of the year pay increases or bonuses are to be awarded to each employee.
This task requires that each node in the binary search tree be visited and that the salary of each employee be updated.
The preceding sections discussed various ways to traverse a binary tree.
However, in these traversal algorithms—inorder, preorder, and postorder—whenever we visited a node, for simplicity and for illustration purposes, we output only the data contained in each node.
How do we use a traversal algorithm to visit each node and update the data in each node.
One way to do so is to first create another binary search tree in which the data in each node is the updated data of the original binary search tree and then destroy the old binary search tree.
This would require extra computer time and perhaps extra memory and, therefore, is not efficient.
Another solution is to write separate traversal algorithms to update the data.
This solution requires you to frequently modify the definition of the class implementing the binary search tree.
However, if the user can write an appropriate function to update the data of each employee and then pass the function as a parameter to the traversal algorithms, we can considerably enhance the program's flexibility.
This section describes how to pass functions as parameters to other functions.
In Cplus_plus, a function name without any parentheses is considered a pointer to the function.
To specify a function as a formal parameter to another function, we specify the function type, followed by the function name as a pointer, followed by the parameter types of the function.
For example, consider the following statements:.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The statement in Line 2 declares fParamFunc2 to be a function that takes as a parameter any void function that has one reference parameter of type elemType.
We can now rewrite, say, the inorder traversal function of the class.
Alternately, we can overload the existing inorder traversal functions.
To further illustrate function overloading, we will overload the inorder traversal functions.
Therefore, we include the following statements in the definition of the class : void inorderTraversal(void (*visit) (elemType&)) const; //Function to do an inorder traversal of the binary tree.
The definitions of these functions are as follows: template <class elemType> void <elemType>::inorderTraversal (void (*visit) (elemType& item)) const { inorder(root, *visit); }.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Binary Tree Traversal Algorithms and Functions as Parameters.
EXAMPLE 19-5 This example shows how to pass a user-defined function as a parameter to the binary tree traversal algorithms.
For illustration purposes, we show how to use only the inorder traversal function.
The following program uses the class bSearchTreeType, which is derived from the class binaryTreeType, to build the binary tree.
The traversal functions are included in the class binaryTreeType, which are then inherited by the class bSearchTreeType.
Sample Run: In this sample run, the user input is shaded.
Line 3: Enter numbers ending  -999.
The statement in Line 1 declares treeRoot to be a binary search tree object, in which the data in each node is of type int.
The statements in Lines 4 through 7 build the binary search tree.
The statement in Line 9 uses the member function inorderTraversal of treeRoot to traverse the binary search tree treeRoot.
The parameter to the function inorderTraversal, in Line 9, is the function print (defined at Line 17).
Because the function print outputs the value of its argument, the statement in Line 9 outputs the data of the nodes of the binary search tree treeRoot.
The statement in Line 10 outputs the height of the binary search tree.
The statement in Line 12 uses the member function inorderTraversal to traverse the binary search tree treeRoot.
In Line 12, the actual parameter of the function inorderTraversal is the function update (defined at Line 19).
The function update doubles the value of its argument.
Therefore, the statement in Line 12 updates the data of each node of the binary search tree by doubling the value.
The statements in Lines 14 and 15 output the nodes and the height of the binary search tree.
The necessary material is in the file AVL Trees_0_pdf.
To find the file, navigate to the book's page by typing in the ISBN of this text and then click on Free Materials.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
PROGRAMMING EXAMPLE: Watch the Video DVD Object.
In Chapter 16, we designed a program to help a DVD store automate its DVD rental process.
That program used an (unordered) linked list to keep track of the DVD inventory in the store.
Because the search algorithm on a linked list is sequential and the list is fairly large, the search could be time consuming.
In this chapter, you learned how to organize data into a binary tree.
If the binary tree is nicely constructed (that is, it is not linear), then the search algorithm can be improved considerably.
Moreover, in general, item insertion and deletion in a binary search tree are faster than in a linked list.
We will, therefore, redesign the DVD store program so that the DVD inventory can be maintained in a binary tree.
As in Chapter 16, we leave the design of the customer list in a binary tree as exercises for you.
In Chapter 16, a linked list was used to maintain a list of DVDs in the store.
Because the linked list was unordered, to see whether a particular DVD was in stock, the sequential search algorithm used the equality operator for comparison.
However, in the case of a binary tree, we need other relational operators for the search, insertion, and deletion operations.
We will, therefore, overload all of the relational operators.
Other than this difference, the class dvdType is the same as before.
However, we give its definition for the sake of completeness.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The DVD list is maintained in a binary search tree.
Therefore, we derive the class dvdBinaryTree from the class bSearchTreeType.
The //parameter  specifies the name of the DVD for //which the number of copies is to be updated.
The definitions of the member functions isDVDAvailable, dvdCheckIn, dvdCheckOut, dvdCheckTitle, dvdUpdateInStock, dvdSetCopiesInStock, and dvdSearch of the class dvdBinaryTree are similar to the definitions of these functions given in Chapter 16.
The only difference is that, here, these are members of the class dvdBinaryTree.
You can find the complete definitions of these functions on the Web site that accompanies this book.
Next, we discuss the definitions of the remaining functions of the class dvdBinaryTree.
The function searchDVDList uses a search algorithm similar to the search algorithm for a binary search tree given earlier in this chapter.
It returns true if the search item is found in the list.
It also returns a pointer to the node containing the search item.
The definition of this function is as follows: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Given a pointer to the  node of the binary tree containing the DVDs, the function inorderTitle uses the inorder traversal algorithm to print the titles of the DVDs.
Notice that this function outputs only the DVD titles.
The definition of this function is as follows: void dvdBinaryTree::inorderTitle (<dvdType> *) const {.
MAIN PROGRAM | 1393 The main program is the same as before.
Here, we give only the listing of this program.
We assume that the name of the header file containing the definition of the.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
A binary tree is either empty or it has a special node called the root node.
If the tree is nonempty, the root node has two sets of nodes, called the left and right subtrees, such that the left and right subtrees are also binary trees.
The node of a binary tree has two links in it.
A node in the binary tree is called a leaf if it has no left and right children.
A node U is called the parent of a node V if there is a branch from U to V.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Quick Review | 5.
That is, there is a branch from X0 to X1, X1 to X2, _0_, Xi1 to Xi,.
The length of a path in a binary tree is the number of branches on that path.
The level of a node in a binary tree is the number of branches on the path from the root to the node.
The level of the root node of a binary tree is 0, and the level of the children of the root node is 1.
The height of a binary tree is the number of nodes on the longest path from the root to a leaf.
In an inorder traversal, the binary tree is traversed as follows: Traverse the left subtree.
Visit the node.
Traverse the right subtree.
In a preorder traversal, the binary tree is traversed as follows: a.
Visit the node.
Traverse the left subtree.
Traverse the right subtree.
In a postorder traversal, the binary tree is traversed as follows: a.
Traverse the left subtree.
Traverse the right subtree.
Visit the node.
A binary search tree T is either empty or: a.
T has two sets of nodes, LT and RT, called the left subtree and the right subtree of T, respectively; iii.
The key in the root node is larger than every key in the left subtree and smaller than every key in the right subtree; and iv.
LT and RT are binary search trees.
To delete a node from a binary search tree that has both left and right nonempty subtrees, first its immediate predecessor is located, then the predecessor's info is copied into the node, and finally the predecessor is deleted.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Mark the  statements as true or false.
If a tree has only one node, the height of the tree is 0 because the d.
The level of a node in a binary tree is the number of branches on the e.
The inorder traversal of a binary tree always outputs the data in ascending f.
In preorder traversal of a binary tree, the node is visited before visiting g.
In a binary search tree, the data in a node is larger than the data in its h.
In a binary search tree, the left and right subtrees of a node are binary i.
To insert a new  in a binary search tree, first we search the binary j.
In Cplus_plus, a function name without any parentheses is considered a The binary tree of Figure 19-13, is to be used for Exercises 3 through 20.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
C D H E I L O FIGURE 19-13 J K M P.
F 1 9 N Q R Figure for Exercises 3 to 20 4.
The binary search tree of Figure 19-14 is to be used for Exercises 21 through 25.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Figure for Exercises 21 to 25 A node with info 58 is to be inserted in the tree.
List the nodes that are visited Delete nodes 50 and 95 in that order.
Redraw the binary tree after each Insert 28, 25, 26, 42, 47, 30, 45, 29, 5 into an initially empty binary Prove that a binary tree with n nodes has exactly n + 1 empty subtree Suppose that you are given two sequences of elements corresponding to the inorder sequence and the preorder sequence.
Prove that it is possible to The following lists the nodes in a binary tree in two different orders: preorder: inorder: ABCDEFGHIJKLM CEDFBAHJIKGML Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Figure for Exercises 31 and 32 Recall the nonrecursive inorder traversal algorithm for a binary tree given in this chapter.
Do an inorder traversal of the binary tree in Figure 19-15.
Recall the nonrecursive preorder traversal algorithm for a binary tree given in this chapter.
Do a preorder traversal of the binary tree in Figure 19-15.
Draw the UML class diagram of the class binaryTreeType.
Draw the UML class diagram of the class bSearchTreeType.
Also, show the inheritance hierarchy.
PROGRAMMING EXERCISES 1.
Write the definition of the function, nodeCount, that returns the number of nodes in the binary tree.
Add this function to the class binaryTreeType and create a program to test this function.
Write the definition of the function, leavesCount, that takes as a parameter a pointer to the root node of a binary tree and returns the number of leaves in a binary tree.
Add this function to the class binaryTreeType and create a program to test this function.
Write a function, swapSubtrees, that swaps all of the left and right subtrees of a binary tree.
Add this function to the class binaryTreeType and create a program to test this function.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Add this function to the class binaryTreeType and create a program to test this function.
Write the definition of the function to implement the nonrecursive postorder traversal algorithm.
Write a version of the preorder traversal algorithm in which a user-defined function can be passed as a parameter to specify the visiting criteria at a node.
Also, write a program to test your function.
Write a version of the postorder traversal algorithm in which a user-defined function can be passed as a parameter to specify the visiting criteria at a node.
Also, write a program to test your function.
Write a function that inserts the nodes of a binary tree into an ordered linked list.
Also write a program to test your function.
Write a program to do the following: Build a binary search tree, T1.
Do a postorder traversal of T1 and, while doing the postorder traversal, insert the nodes into a second binary search tree T2.
Do a preorder traversal of T2 and, while doing the preorder traversal, insert the node into a third binary search tree T3.
Do an inorder traversal of T3.
Output the heights and the number of leaves in each of the three binary search trees.
Because the search on a linked list is sequential and, therefore, can be time consuming, design and implement the class customerBTreeType so that this customer data can be stored in a binary search tree.
The class customerBTreeType must be derived from the class bSearchTreeType, as designed in this chapter.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Examine and implement the minimal spanning tree algorithm Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
This chapter discusses how to implement and manipulate graphs, which have numerous applications in computer science.
Introduction In 1736, the following problem was posed.
In the town of Königsberg (now called Kaliningrad), the river Pregel (Pregolya) flows around the island Kneiphof and then divides into two branches (see Figure 20-1).
C c d g A Königsberg a.
Königsberg bridge problem The river has four land areas (A, B, C, D), as shown in the figure.
These land areas are connected using seven bridges, as shown in Figure 20-1.
The bridges are labeled a, b, c, d, e, f, and g.
The Königsberg bridge problem is as follows: Starting at one land area, is it possible to walk across all of the bridges exactly once and return to the starting land area.
In 1736, Euler represented the Königsberg bridge problem as a graph, as shown in Figure 20-2, and answered the question in the negative.
This marked (as recorded) the birth of graph theory.
C c g d e A a D b f B FIGURE 20-2 Graph representation of Königsberg bridge problem Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Graph Definitions and Notations.
Over the past 200 years, graph theory has been applied to a variety of applications.
Graphs are used to model electrical circuits, chemical compounds, highway maps, and so on.
They are also used in the analysis of electrical circuits, finding the shortest route, project planning, linguistics, genetics, social science, and so forth.
In this chapter, you will learn about graphs and their applications in computer science.
Graph Definitions and Notations To facilitate and simplify our discussion, we borrow a few definitions and terminology from set theory.
Let X be a set.
If a is an element of X, then we write a 2 X.
If Y is a subset of X, we write Y  X.
For sets A and B, the set A  B is the set of all of the ordered pairs of elements of A and B; that is, A  B ¼ {(a, b) | a 2 A, b 2 B}.
A graph G is a pair, G ¼ (V, E), in which V is a finite nonempty set, called the set of vertices of G, and E  V  V.
That is, the elements of E are the pair of elements of V.
E is called the set of edges.
Let V(G) denote the set of vertices and E(G) denote the set of edges of a graph G.
If the elements of E(G) are ordered pairs, G is called a directed graph or digraph; otherwise, represent the same edge.
If (u, v) is an edge in a directed graph, then sometimes the vertex u is called the origin of the edge, and the vertex v is called the destination.
Let G be a graph.
A graph H is called a subgraph of G if V(H )  V(G) and E(H )  E(G ); that is, every vertex of H is a vertex of G, and every edge in H is an edge in G.
To learn more about sets and graph terminology, the interested reader is referred to the book Discrete Mathematics: Theory and Applications (Revised Edition), listed in Appendix H.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The vertices are drawn as circles, and a label inside of the circle represents the vertex.
In an undirected graph, the edges are drawn using lines.
In a directed graph, the edges are drawn using arrows.
Moreover, in a directed graph, the tail of a pictorial directed edge is the origin, and the head is the destination.
EXAMPLE 20-1 Figure 20-3 shows some examples of undirected graphs.
Various undirected graphs Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Graph Definitions and Notations.
Let G be an undirected graph.
Let u and v be two vertices in G.
Then, u and v are called adjacent if there is an edge from one to the other; that is, (u, v) 2 E(G).
Let e ¼ (u, v) be an edge in G.
We then say that edge e is incident on the vertices u and v.
An edge incident on a single vertex is called a loop.
If two edges, e1 and e2, are associated with the same pair of vertices, then e1 and e2 are called parallel edges.
A graph is called a simple graph if it has no loops and no parallel edges.
There is a path from u to v if there is a sequence of vertices u1, u2,.
Vertices u and v are called connected if there is a path from u to v.
A simple path is a path in which all of the vertices, except possibly the first and last vertices, are distinct.
A cycle in G is a simple path in which the first and last vertices are the same.
G is called connected if there is a path from any vertex to any other vertex.
A maximal subset of connected vertices is called a component of G.
Let G be a directed graph, and let u and v be two vertices in G.
If there is an edge from u to v, that is, (u, v) 2 E(G), then we say that u is adjacent to v and v is adjacent from u.
The definitions of the paths and cycles in G are similar to those for undirected graphs.
G is called strongly connected if any two vertices in G are connected.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Graph Representation To write programs that process and manipulate graphs, the graphs must be stored—that is, represented—in computer memory.
A graph can be represented (in computer memory) in several ways.
We now discuss two commonly used methods: adjacency matrices and adjacency lists.
Adjacency Matrix Let G be a graph with n vertices, in which n > 0.
The adjacency matrix AG of G is a two-dimensional n  n matrix such that the (i, j)th entry of AG is 1 if there is an edge from vi to vj; otherwise, the (i, j)th entry is zero.
That is:  AG ði; jÞ ¼ 1 if ð i ;  j Þ 2 EðGÞ 0 otherwise In an undirected graph, if (vi, vj) 2 E(G), then (vj, vi) 2 E(G), so AG(i, j) ¼ 1 ¼ AG( j, i).
It follows that the adjacency matrix of an undirected graph is symmetric.
EXAMPLE 20-3 Consider the directed graphs of Figure 20-4.
The adjacency matrices of the directed graphs G1 and G2 are as follows: 2 0 60 6 AG1 ¼ 6 60 40 0 1 0 0 1 0 0 1 0 1 0 1 0 0 0 0 3 0 17 7 07 7 and 15 0 2 0 0 16 60 26 61 36 60 AG 2 ¼ 4 6 60 56 60 66 61 740 8 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0 1 0 0 0 0 0 0 1 0 0 0 1 0 0 0 0 1 0 0 1 0 0 0 0 0 0 3 0 07 7 07 7 07 7 17 7 07 7 07 7 05 0 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Operations on Graphs.
In the adjacency list representation, corresponding to each vertex, v, there is a linked list such that each node of the linked list contains the vertex, u, such that (v, u) 2 E(G).
Because there are n nodes, we use an array, A, of size n, such that A[i] is a reference variable pointing to the first node of the linked list containing the vertices to which vi is adjacent.
Clearly, each node has two components, say vertex and link.
The component vertex contains the index of the vertex adjacent to vertex i.
EXAMPLE 20-4 Consider the directed graphs of Figure 20-4.
Figure 20-5 shows the adjacency list of the directed graphs G1 and G2.
Adjacency list of graphs of Figure 20-4 Operations on Graphs Now that you know how to represent graphs in computer memory, the next obvious step is to learn the basic operations on a graph.
The operations commonly performed on a graph are as follows: 1.
Create the graph.
That is, store the graph in computer memory using a particular graph representation.
Clear the graph.
This operation makes the graph empty.
Determine whether the graph is empty.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Traverse the graph.
Print the graph.
We will add more operations on a graph when we discuss a specific application or a particular graph later in this chapter.
How a graph is represented in computer memory depends on the specific application.
For illustration purposes, we use the adjacency list (linked list) representation of graphs.
Therefore, for each vertex, v, the vertices adjacent to v (in a directed graph, also called the immediate successors) are stored in the linked list associated with v.
To manage the data in a linked list, we use the class unorderedLinkedList, discussed in Chapter 16.
The labeling of the vertices of a graph depends on a specific application.
If you are dealing with the graph of cities, you could label the vertices by the names of the cities.
However, to write algorithms to manipulate a graph as well as to simplify the algorithm, there must be some ordering to the vertices.
That is, we must specify the first vertex, the second vertex, and so on.
Therefore, for simplicity, throughout this chapter, we assume that the n vertices of the graphs are numbered 0, 1,.
Moreover, it follows that the class that we will design to implement the graph algorithm will not be a template.
Graphs as ADTs In this section, we describe the class to implement graphs as an abstract data type (ADT) and provide the definitions of the functions to implement the operations on a graph.
The following class defines a graph as an ADT: class graphType { public:.
Graphs as ADTs.
The definitions of the functions of the class graphType are discussed next.
A graph is empty if the number of vertices is zero—that is, if  is 0.
Therefore, the definition of the function isEmpty is: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The definition of the function createGraph depends on how the data is input into the program.
For illustration purposes, we assume that the data to the program is input from a file.
The user is prompted for the input file.
The data in the file appears in the following form: 5 0 2 4 _0__0_.
The first line of input specifies the number of vertices in the graph.
The first entry in the specify the vertices that are adjacent to the vertex.
Each line ends with the number -999.
Using these conventions, the definition of the function createGraph is:.
Graphs as ADTs.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
This section discusses the traversal algorithms.
Traversing a  is similar to traversing a binary tree, except that traversing a  is a bit more complicated.
Recall that a binary tree has no cycles.
Also, starting at the root node, we can traverse the entire tree.
On the other hand, a  might have cycles, and we might not be able to traverse the entire  from a single vertex (for example, if the is not connected).
Therefore, we must keep track of the vertices that have been visited.
We must also traverse the  from each vertex (that has not been visited) of the This ensures that the entire  is traversed.
The two most common  traversal algorithms are the depth first traversal and breadth first traversal, which are described next.
For simplicity, we assume that when a vertex is visited, its  is output.
Moreover, each vertex is visited only once.
We use the bool array visited to keep track of the visited vertices.
Depth First Traversal The depth first traversal is similar to the preorder traversal of a binary tree.
The general algorithm is: for each vertex, v, in the if v is not visited start the depth first traversal at v Consider the  G of Figure 20-6.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
After visiting all of the vertices that can be reached starting at the vertex 0, the depth first search starts at the next vertex that is not visited.
There is a path from the vertex 0 to every other vertex except the vertices 6 and 9.
Therefore, when the depth first search starts at the vertex 0, all of the vertices except 6 and 9 are visited before these vertices.
After completing the depth first search that started at the vertex 0, the depth first search starts at the vertex 6 and then at the vertex 9.
Note that there is no path from the vertex 6 to the vertex 9.
Therefore, after completing the depth first search that started at the vertex 6, the depth first search starts at the vertex 9.
The general algorithm to do a depth first traversal at a given node, v, is: 1.
Mark node  as visited 2.
Visit the node 3.
We use a recursive function, dft, to implement this algorithm.
The vertex at which the depth first traversal is to be started, and the bool array visited, are passed as parameters to this function:.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Breadth First Traversal The breadth first traversal of a  is similar to traversing a binary tree level by level (the nodes at each level are  from left to right).
All of the nodes at any level, i, are before visiting the nodes at level i + 1.
A breadth first ordering of the vertices of the  G (Figure 20-6) is: 0, 1, 3, 4, 2, 5, 7, 8, 6, 9 For the  G, we start the breadth traversal at vertex 0.
After visiting the vertex 0, next we visit the vertices that are directly connected to it and are not , which are Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Next, we visit the vertices that are directly connected to 1 and are not , which is 4.
After this, we visit the vertices that are directly connected to 3 and are not , which in this instance is the single vertex 2.
After this, we visit the vertices that are directly connected to 2 and are not , and so on.
As in the case of the depth first traversal, because it might not be possible to traverse the entire graph from a single vertex, the breadth first traversal also traverses the graph from each vertex that is not.
Starting at the first vertex, the graph is traversed as much as possible; we then go to the next vertex that has not been.
To implement the breadth first search algorithm, we use a queue.
The general algorithm is: a.
Mark  as c.
Remove vertex u from the queue c_0_2.
Retrieve the vertices adjacent to u c_0_3.
Add  to the queue c_0_3_0_2.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Shortest Path Algorithm Watch the Video The graph theory has many applications.
For example, we can use graphs to show how different chemicals are related or to show airline routes.
They can also be used to show the highway structure of a city, state, or country.
The edges connecting two vertices can be assigned a nonnegative real number, called the weight of the edge.
If the graph represents a highway structure, the weight can represent the distance between two places or the travel time from one place to another.
Such graphs are called weighted graphs.
Let G be a weighted graph.
Let  and  be two vertices in G, and let P be a path in G from  to.
The weight of the path P is the sum of the weights of all the edges on the path P, which is also called the weight of  from  via P.
Let G be a weighted graph representing a highway structure.
Suppose that the weight of an edge represents the travel time.
For example, to plan monthly business trips, a salesperson wants to find the shortest path (that is, the path with the smallest weight) from her or his city to every other city in the graph.
Many such problems exist in which we want to find the shortest path from a given vertex, called the source, to every other vertex in the graph.
This section describes the shortest path algorithm, also called a greedy algorithm, developed by Dijkstra.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Shortest Path Algorithm.
Let W be a two-dimensional n  n matrix such that:  W ði; jÞ ¼ wij if ði ; j Þ is an edge in G and wij is the weight of the edge ði ; j Þ 1 if there is no edge from i to j The input to the program is the graph and the weight matrix associated with the graph.
To make inputting the data easier, we extend the definition of the class graphType (using inheritance) and add the function createWeightedGraph to create the graph and the weight matrix associated with the graph.
Let us call this class weightedGraphType.
The functions to implement the shortest path algorithm will also be added to this class.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Next, we describe the shortest path algorithm.
Shortest Path Given a , say,  (that is, a source), this section describes the shortest path algorithm.
The general algorithm is: 1.
Initialize the array smallestWeight so that: smallestWeight[] = weights[, ] 2.
Set smallestWeight[] = 0.
Find the , v, that is closest to the  for which the shortest path has not been determined.
Mark v as the (next)  for which the smallest weight is found.
For each   in G, such that the shortest path from  to  has not been determined and an edge (v, ) exists, if the weight of the path to  via v is smaller than its current weight, update the weight of to the weight of v + the weight of the edge (v, ).
Because there are n vertices, Steps 3 through 5 are repeated n  1 times.
Example 20-5 illustrates the shortest path algorithm.
If the smallest weight for a , from the source, has been found, then this 's corresponding entry in the array weightFound is set to true; otherwise, the corresponding Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Shortest Path Algorithm.
FIGURE 20-7 2 0 Weighted graph G Suppose that the source  of G is 0.
The graph shows the weight of each edge.
After Steps 1 and 2 execute, the resulting graph is as shown in Figure 20-8.
We do this by finding a  in the array smallestWeight that has the smallest weight and a corresponding entry in the array weightFound of false.
Therefore, in this iteration, we select the  3.
At Step 4, we mark weightFound[3] as true.
Next, at Step 5, we consider vertices Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
We then check if the path from the  0 to the vertices 1 and 4 via the  3 can be improved.
The weight of the path 0–3–1 from 0 to 1  less than the weight of the path 0–1.
The weight of the path 0-3-4, which  2 + 7 = 9, greater than the weight of the path 0–4, which  3.
So we do not update the weight of the vertex 4.
Figure 20-9 shows the resulting graph.
Next, we execute Steps 4 and 5.
At Step 4, we set weightFound[4] to true.
At Step 5, we consider vertices 1 and 2 because these are the vertices for which there  an edge from the vertex 4, and the shortest path from 0 to these vertices has not been found.
We then check if the path from the vertex 0 to the vertices 1 and 2 via the vertex 4 can be improved.
Clearly, the weight of the path 0–4–1, which  13,  smaller than the current weight of 1, which  14.
Similarly, we update smallestWeight[2].
Figure 20-10 shows the resulting graph.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Shortest Path Algorithm 16 0 =13 1 =2 1423 3 5 3 12 2 3 | 2 10 7 4 =7 4 =3 5.
At Step 4, we set weightFound[2] to true.
Next, at Step 5, we consider the vertex 1 because this  the vertex for which there  an edge from the vertex 2, and the shortest part from 0 to this vertex has not been found.
We then check if the path from the vertex 0 to the vertex 1 via the vertex 2 can be improved.
Clearly, the weight of the path 0–4–2–1, which is 10, from 0 to 1 is smaller than the current weight of 1 (which is 13).
Figure 20-11 shows the resulting graph.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
In this iteration, the action of Step 5 is null because the shortest path from the vertex 0 to every other vertex in the graph has been determined.
Figure 20-12 shows the final graph.
Shortest Path Algorithm.
Note that the function shortestPath records only the weight of the shortest path from the source to a.
We leave it for you to modify this function so that the shortest path from the source to a  is also recorded.
Moreover, this function used the named constant DBL_MAX, which is defined in the header file cfloat.
The definitions of the function printShortestDistance and the constructor and destructor are:.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Minimal Spanning Tree Consider the graph of Figure 20-13, which represents the airline connections of a company between seven cities.
The number on each edge represents some cost factor of maintaining the connection between the cities.
The graphs of Figure 20-14(a), (b), and (c) show three different solutions.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Minimal Spanning Tree | 0 6 0.
The total cost factor of maintaining the remaining connections in Figure 20-14(a) is 33, in Figure 20-14(b) it is 28, and in Figure 20-14(c) it is 25.
Out of these three solutions, obviously, the desired solution is the one shown by the graph of Figure 20-14(c) because it gives the lowest cost factor.
The graphs of Figure 20-14 are called spanning trees of the graph of Figure 20-13.
Let us note the following from the graphs of Figure 20-14.
Each of the graphs is a subgraph of the graph of Figure 20-13, and there is a unique path from a node to any other node.
Such graphs are called trees.
There are many other situations in which, given a weighted graph, we need to determine a graph with the smallest weight, such as in Figure 20-14.
In this section, we give an algorithm to determine such graphs.
However, first we introduce some terminology.
A (free) tree T is a simple graph such that if u and v are two vertices in T, then there is a unique path from u to v.
A tree in which a particular vertex is designated as a root is called a rooted tree.
If a weight is assigned to the edges in T, T is called a weighted tree.
If T is a weighted tree, the weight of T, denoted by W(T ), is the sum of the  of all of the edges in T.
A tree T is called a spanning tree of graph G if T is a subgraph of G such that V(T ) ¼ V(G); that is, all of the vertices of G are in T.
Suppose that G denotes the graph of Figure 20-13.
Then, the graphs of Figure 20-14 show three spanning trees of G.
Let us note the following theorem.
Theorem: A graph G has a spanning tree if and only if G is connected.
From this theorem, it follows that in order to determine a spanning tree of a graph, the graph must be connected.
Let G be a weighted graph.
A minimal spanning tree of G is a spanning tree with the minimum weight.
Prim's algorithm and Kruskal's algorithm are two well-known algorithms that can be used to find the minimal spanning tree of a graph.
This section discusses Prim's algorithm Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The interested reader can find the Kruskal's algorithm in the discrete structures book or a data structures book listed in Appendix H.
Prim's algorithm builds the tree iteratively by adding edges until a minimal spanning tree is obtained.
We start with a designated , which we call the source.
At each iteration, a new  that does not complete a cycle is added to the tree.
Let G be a weighted graph such that V(G) ¼ {v0, v1,.
Let v0 be the source.
Let T be the partially built tree.
Initially, V(T ) contains the source , and E(T ) is empty.
At the next iteration, a new that is not in V(T ) is added to V(T ), such that an  exists from a  in T to the new  so that the corresponding  has the smallest weight.
Let us illustrate Prim's algorithm using the graph G of Figure 20-15 (which is same as the graph of Figure 20-13).
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Minimal Spanning Tree | 1429 Let N denote the set of vertices of G that are not in.
Suppose that the source  is 0.
After Steps 1 and 2 execute, (), (), and N are as shown in Figure 20-16(a).
Edge Edge Weight 6 7 8 0 1 5.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
In Figure 20-16(a), Step 3_0_2 checks the edges shown in this figure; and the edge with the least weight is identified.
Figure 20-16(b), shows the resulting graph, (), (), and.
Thus, in Figure 20-16 in each graph, we identify (), (), and ; identify the edges checked by Step 3_0_2; and identify the edge with the least weight.
Also in each figure, the dotted lines show the edges in.
In Figure 20-16(g), the dotted lines show a minimal spanning tree of G of weight 25.
Note that the graph in Figure 20-16(b) is obtained after the first iteration of Step 3, the graph in Figure 20-16(c) is obtained after the second iteration of Step 3, and so on.
Finally, the graph in Figure 20-16(g) is obtained after the sixth iteration of Step 3.
Before we give the definition of the function to implement Prim's algorithm, let us first define the spanning tree as an ADT.
Let mstv be a bool array such that mstv [] is true if the vertex vi is in , and false otherwise.
Let edges be an array such that edges[] = k if there is an edge connecting vertices vj and vk.
Suppose that the edge (vi, vj) is in the minimal spanning tree.
Let edgeWeights be an array such that edgeWeights[] is the weight of the edge (vi, vj).
Using these conventions, the following class defines a spanning tree as an ADT: class msTreeType: public graphType { public: void createSpanningGraph(); //Function to create the graph and the weight matrix.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
We leave the UML class diagram of the class msTreeType and the inheritance hierarchy as an exercise.
The definition of the function createSpanningGraph is also left as an exercise for you.
This function creates the graph and the weight matrix associated with the graph.
The following Cplus_plus function, minimalSpanning, implements Prim's algorithm, as described previously:.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The definition of the function minimalSpanning contains three nested for loops.
Therefore, in the worst case, Prim's algorithm given in this section is of the order O(n3).
It is possible to design Prim's algorithm so that it is of the order O(n2).
Programming Exercise 5 at the end of this chapter asks you to do this.
The definition of the function printTreeAndWeight is:.
Quick Review |.
The necessary material is in the file TopologicalOrder_0_pdf.
To find the file, navigate to the book's page by typing in the ISBN of this text and then click on Free Materials.
QUICK REVIEW 1.
A graph G is a pair, G ¼ (V, E ), in which V is a finite nonempty set, called the set of vertices of G, and E  V  V, called the set of edges.
In an undirected graph G ¼ (V, E ), the elements of E are unordered pairs.
In a directed graph G ¼ (V, E ), the elements of E are ordered pairs.
Let G be a graph.
A graph H is called a subgraph of G if every vertex of H is a vertex of G and every edge in H is an edge in G.
Two vertices u and v in an undirected graph are called adjacent if there is an edge from one to the other.
Let e ¼ (u, v) be an edge in an undirected graph G.
The edge e is said to be incident on the vertices u and v.
An edge incident on a single vertex is called a loop.
In an undirected graph, if two edges e1 and e2 are associated with the same pair of vertices, then e1 and e2 are called parallel edges.
A graph is called a simple graph if it has no loops and no parallel edges.
A path from a vertex u to a vertex v is a sequence of vertices u1, u2,.
The vertices u and v are called connected if there is a path from u to v.
A simple path is a path in which all of the vertices, except possibly the first and last vertices, are distinct.
A cycle in G is a simple path in which the first and last vertices are the same.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
A maximal subset of connected vertices is called a component of G.
Suppose that u and v are vertices in a directed graph G.
If there is an edge from u to v, that is, (u, v) 2 E, we say that u is adjacent to v and v is adjacent from u.
A directed graph G is called strongly connected if any two vertices in G are connected.
Let G be a graph with n vertices, in which n > 0.
The adjacency matrix AG is a two-dimensional n  n matrix such that the (, )th entry of AG is 1 if there is an edge from vi to vj; otherwise, the (, )th entry is zero.
In an adjacency list representation, corresponding to each vertex v is a linked list such that each node of the linked list contains the vertex u, and (v, u) 2 E(G).
The depth first traversal of a graph is similar to the preorder traversal of a binary tree.
The breadth first traversal of a graph is similar to the level-by-level traversal of a binary tree.
The shortest path algorithm gives the shortest distance for a given node to every other node in the graph.
In a weighted graph, every edge has a nonnegative weight.
The weight of the path P is the sum of the  of all of the edges on the path P, which is also called the weight of v from u via P.
A (free) tree T is a simple graph such that if u and v are two vertices in T, there is a unique path from u to v.
A tree in which a particular vertex is designated as a root is called a rooted tree.
Suppose T is a tree.
If a weight is assigned to the edges in T, T is called a weighted tree.
If T is a weighted tree, the weight of T, denoted by W(T ), is the sum of the weights of all the edges in T.
A tree T is called a spanning tree of graph G if T is a subgraph of G such that V(T ) ¼ V(G), that is, if all of the vertices of G are in T.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Mark the following statements as true or false.
If an entry in the adjacency matrix of a graph is 1, the corresponding In the adjacency list representation of a graph G, corresponding to each vertex, v, there is an array such that each vertex adjacent from v is stored The breadth first traversal of a graph is similar to traversing a binary tree 2 0 Use the graphs in Figure 20-17 for Exercises 2 through 10.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Also determine if there In Figure 20-17(a), determine if the vertices 0 and 9 are connected.
If these In Figure 20-17(b), determine if the vertices 3 and 8 are connected.
In Figure 20-17(b), determine if the vertices 0 and 5 are connected.
In Figure 20-17(b), find a path, if any, from vertex 0 to vertex 7 that has In Figure 20-17(b), find a path, if any, from vertex 0 to vertex 11 that has In Figure 20-17(b), determine if the graph is simple.
Also determine if there Use the graphs in Figure 20-18 for Exercises 11 through 16.
Graphs for Exercises 11 through 16 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Graph for Exercise 17 Consider the graph in Figure 20-20.
Find the shortest distance from node 0 3.
Graph for Exercise 18.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Graph for Exercise 20 Find the minimal spanning tree for the graph in Figure 20-23, using the 4 0 1 3 3 6 3.
Graph for Exercise 21 PROGRAMMING EXERCISES 1.
Write a program that outputs the nodes of a graph in a depth first traversal.
Write a program that outputs the nodes of a graph in a breadth first traversal.
Write a program that outputs the shortest distance from a given node to every other node in the graph.
Write a program that outputs the minimal spanning tree for a given graph.
The algorithm to determine the minimal spanning tree given in this chapter is of the order O(n3).
The following is an alternative to Prim's algorithm that is of the order O(n2).
Input: A connected weighted graph G ¼ (V, E ) of n vertices, numbered 0, 1,.
Output: The minimal spanning tree.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Furthermore, write a program to test this version of Prim' algorithm.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter().
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter().
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Become familiar with the three basic components of the STL: containers, iterators, and algorithms 3.
Explore how various containers, such as deque and list, are used to manipulate data in a program 9.
Explore how to use various generic algorithms Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter().
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
With the help of class templates, we developed (and used) a generic code to process lists.
For example, we used the class listType to process a list of integers and a list of strings.
In Chapters 16 and 17, we studied the three most important data structures: linked lists, stacks, and queues.
In these chapters, using class templates, we developed generic code to process linked lists.
In addition, using the second principle of object-oriented programming (OOP), we developed generic code to process ordered lists.
Furthermore, in Chapter 17, we used class templates to develop generic code to implement stacks and queues.
Along the way, you saw that a template is a powerful tool that promotes code reuse.
ANSI/ISO Standard Cplus_plus is equipped with a Standard Template Library (STL).
Among other things, the STL provides class templates to process lists (contiguous or linked), stacks, and queues.
This chapter discusses many important features of the STL and shows how to use the tools provided by the STL in a program.
Components of the STL The main objective of a program is to manipulate data and generate results.
Achieving this goal requires the ability to store data into computer memory, access a particular piece of data, and write algorithms to manipulate the data.
For example, if all data items are of the same type and we have some idea of the number of data items, we could use an array to store the data.
We can then use an index to access a particular component of the array.
Using a loop and the array index, we can step through the elements of the array.
Algorithms, such as those for initializing the array, sorting, and searching, are used to manipulate the data stored in an array.
On the other hand, if we do not want to be concerned about the size of the data, we can use a linked list to process it.
If the data needs to be processed in a Last In First Out (LIFO) manner, we can use a stack.
Similarly, if the data needs to be processed in a First In First Out (FIFO) manner, we can use a queue.
The STL is equipped with these features to effectively manipulate data.
More formally, the STL has three main components:.
Containers Iterators Algorithms Containers and iterators are class templates.
Iterators are used to step through the elements of a container.
Algorithms are used to manipulate data.
The following sections discuss each of these components in detail.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter().
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Components of the STL.
The STL containers are classified into three categories, as follows:.
Associative containers Container adapters Sequence Containers Every object in a sequence container has a specific position.
The three predefined sequence containers are:.
We do so because vector containers are similar to arrays and thus can be processed like arrays.
Also, with the help of vector containers, we can describe several properties that are common to all containers.
In fact, all containers use the same names for the common operations.
Of course, there are operations that are specific to a container, which will be discussed when describing a specific container.
Sequence Container: vector A vector container stores and manages its objects in a dynamic array.
Because an array is a random access data structure, the elements of a vector can be accessed randomly.
Item insertion in the middle or beginning of an array is time consuming, especially if the array is large.
However, inserting an item at the end is quite fast.
The name of the class that implements the  container is.
Thus, to use a  container in a program, the program must the following statement: # <>.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Therefore, a  container can be declared and initialized several ways.
Table 21-1 describes how a  container of a specific type can be declared and initialized.
TABLE 21-1 Various Ways to Declare and Initialize a Vector Container.
Both beg and end are pointers, called iterators in STL terminology.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Components of the STL.
In order to manipulate the data in a container, we must know the following basic operations:.
Item insertion Item deletion Stepping through the elements of a  container The elements in a  container can be accessed directly by using the operations given in Table 21-2.
The name of the function is shown in bold.
TABLE 21-2 Operations to Access the Elements of a Vector Container.
From Table 21-2, it follows that the elements in a  can be processed just as they can in an array.
See Example 21-1.
Similarly, EXAMPLE 21-1 Consider the following statement, which declares intList to be a  container of size 5 with an element type of int: <int> intList(5);.
Similarly, you can use a for loop to output the elements of intList.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Table 21-3 describes some of these operations.
The TABLE 21-3 Operations to Determine the Size of a Vector Container.
The class  also contains member functions that can be used to manipulate the data, as well as insert and delete items, in a  container.
Suppose that vecList is a container of type.
Item insertion and deletion in vecList are accomplished using the operations given in Table 21-4.
These operations are implemented as member functions of the class  and are shown in bold.
Table 21-4 also shows how these operations are used.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Components of the STL.
A copy of elem is inserted at the position specified by position.
The position of the new  is returned.
A copy of the elements, starting at beg until end-1, is inserted into vecList at the position specified by position.
In Table 21-4, the identifiers position, beg, and end in STL terminology are called iterators.
An iterator is just like a pointer.
In general, iterators are used to step through the elements of a container.
In other words, with the help of an iterator, we can walk through the elements of a container and process them one at a time.
Because iterators are an integral part of the STL, they are discussed in the section "Iterators" located later in this chapter.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
We declare intList to be a  object of size 5.
Does this mean that we can store only five elements in intList.
We can, in fact, add more elements to intList.
However, because when we declared intList we specified the size to be 5, in order to add elements past position 4, we use the function push_back.
Furthermore, if we initially declare a  object and do not specify its size, then to add elements to the  object, we use the function push_back.
Example 21-2 explains how to use the function push_back.
EXAMPLE 21-2 The following statement declares  to be a  object of size 0: <int> ;.
In Example 21-2, because  is declared to be of size 0, we use the function push_back to add elements to.
However, we can also use the resize function to increase the size of  and then use the array subscripting operator.
For example, suppose that  is declared as in Example 21-2.
Then, the following statement sets the size of  to 10: _0_resize(10);.
However, at times, the push_back function is more convenient because it does not need to know the size of the ; it simply adds the elements at the end.
Next, we describe how to declare an iterator in a  container.
DECLARING AN ITERATOR TO A VECTOR CONTAINER The class  contains a typedef iterator, which is declared as a public member.
An iterator to a  container is declared using the typedef iterator.
For example, the statement: <int>::iterator intVecIter; declares intVecIter to be an iterator in a  container of type int.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Components of the STL.
The expression: plus_plusintVecIter advances the iterator intVecIter to the next  in the container, and the expression: *intVecIter returns the  at the current iterator position.
Note that these operations are the same as the operations on pointers, discussed in Chapter 12.
Recall that when used as a unary operator, * is called the dereferencing operator.
We now discuss how to use an iterator in a  container to manipulate the data stored in the  container.
Suppose that we have the following statements:.
The statement in Line 1 declares  to be a  container, and the  type is int.
The statement in Line 2 declares  to be an iterator in a container whose  type is int.
CONTAINERS AND THE FUNCTIONS begin AND end Every container has the member functions begin and end.
The function begin returns the position of the first  in the container; the function end returns the position of one past the last  in the container.
Also, these functions have no parameters.
After the following statement executes: = _0_begin();.
Example 21-3 shows how the function insert works with  objects.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The statement in Line 4 initializes the iterator  to the first element of ; the statement in Line 5 advances  to the second element of The statement in Line 6 inserts 22 at the position specified by.
After the statement in Line 6 executes,  = {1, 22, 3, 5, 7, 9, 11, 13}.
Notice that the size of the container also increases.
The following example illustrates how to use a  container in a program and how to process the elements in a  container.
Components of the STL.
Sample Run: Line Line Line Line 7: List elements: 13 75 28 35 13: List elements: 26 150 56 70 18: List elements: 26 150 56 70 25: List elements: 26 150 88 56 70 The statement in Line 1 declares a  container (or  for short), , of type int.
The statement in Line 2 declares  to be an int variable.
The statements in Lines 3 through 6 use the operation push_back to insert four numbers—13, 75, 28, and 35—into intList.
The statements in Lines 8 and 9 use the for loop and the array subscripting operator, [], to output the elements of intList.
In the output, see the line marked Line 7, which contains the output of Lines 7 through 10.
The statements in Lines 11 and 12 use a for loop to double the value of each element of intList; the statements in Lines 14 and 15 output the elements of intList.
In the output, see the line marked Line 13, which contains the output of Lines 13 through 16.
The statement in Line 17 declares  to be a  iterator that processes any container whose elements are of type int.
Using the iterator , the statements in Lines 19 and 20 output the elements of intList.
After the statement in Line 22 executes,  points to the first element of intList.
The statements in Lines 23 and 24 advance  twice; after these statements execute,  points to Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The statement in Line 25 inserts 88 into intList at the position specified by the iterator.
Because  points to the component at position 2 (the third element of intList), 88 is inserted at position 2 in intList; that is, 88 becomes the third element of intList.
The statements in Lines 27 and 28 output the modified intList.
Member Functions Common to All Containers The previous section discussed  containers.
This section discusses operations that are common to all containers.
For example, every container class has the default constructor, several constructors with parameters, the destructor, a function to insert an element into a container, and so on.
Recall that a class encapsulates data and operations on that data into a single unit.
Because every container is a class, several operations are directly defined for a container and are provided as part of the definition of the class.
Also, recall that the operations to manipulate the data are implemented with the help of functions and are called member functions of the class.
Table 21-5 describes the member functions that are common to all containers; that is, these functions are included as members of the class template implementing the container.
Suppose ct, ct1, and ct2 are containers of the same type.
In Table 21-5, the name of the function is shown in bold.
This table also shows how a function is called.
TABLE 21-5 Operations Common to All Containers.
Constructor with parameters In addition to the default constructor, every container has constructors with parameters.
We will describe these constructors when we discuss a specific container.
Copy constructor Executes when an object is passed as a parameter by value and when an object is declared and initialized using another object of the same type.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Components of the STL.
Because these operations are common to all containers, when discussing a specific container, to save space, these operations will not be listed again.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
In addition to these member functions, Table 21-6 describes the member functions that are common to all sequence containers, that is, containers of type vector, deque, and list.
TABLE 21-6 Member Functions Common to All Sequence Containers.
A copy of elem is inserted at the position specified by the iterator position.
The position of the new element is returned.
A copy of the elements, starting at beg until end-1, is inserted into seqCont at the position specified by the iterator position.
Also, beg and end are iterators.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Components of the STL.
The STL provides a convenient way to output the elements of a container with the help of the function copy.
The function copy is provided as a part of the generic algorithm and can be used with any container type.
Because we frequently need to output the elements of a container, before continuing with our discussion of containers, let us describe this function.
The function copy does more than output the elements of a container.
In general, it allows us to copy the elements from one place to another.
For example, to output the elements of a vector or to copy the elements of a vector into another vector, we can use the function copy.
The prototype of the function template copy is: template <class inputIterator, class outputIterator> outputIterator copy(inputIterator first1, inputIterator last, outputIterator first2);.
Therefore, the parameters first1 and last specify the source; parameter first2 specifies the destination.
Note that the elements within the range first1.
The definition of the function template copy is contained in the header file algorithm.
Thus, to use the function copy, the program must  the statement: # <algorithm>.
This statement creates an array  of nine components.
The statement: <int> vecList(9); creates an empty container of nine components of type  and the element type int.
Recall that the array name, , is actually a pointer and contains the base address of the array.
Therefore,  points to the first component of the array,  + 1 points to the second component of the array, and so on.
Now consider the statement: copy(,  + 9, vecList_0_begin()); This statement copies the elements starting at the location , which is the first component of the array , until  + 9 - 1 (that is,  + 8), Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Also, first2 is ; that is, first2 points to the location of the first element of the array.
Therefore, the second array element is copied into the first array component, the third array element into the second array component, and so on.
After the preceding statement executes: = {6, 8, 3, 40, 36, 98, 29, 75, 75}.
Therefore, _0_rbegin() + 2 returns a pointer to the third-to-last element into the container.
Similarly, the function rend (reverse end) returns a pointer to the first element into a container.
The previous statement shifts the elements of the container to the right by two positions.
After the previous statement executes, the container  is: = {5, 6, 5, 6, 8, 3, 40, 36, 98} Example 21-5 shows the effect of the preceding statements using a Cplus_plus program.
Before discussing Example 21-5, let us describe a special type of iterators called ostream iterators.
These iterators work well with the function copy to copy the elements of a container to an output device.
THE ostream ITERATOR AND THE FUNCTION copy One way to output the contents of a container is to use a for loop, the function begin to initialize the for loop control variable, and the function end to set the limit.
Alternatively, the function copy can be used to output the elements of a container.
In this case, an iterator of type ostream specifies the destination.
Components of the STL.
The iterator screen has two arguments: the object cout and a space.
Thus, the iterator screen is initialized using the object cout.
When this iterator outputs elements, they are separated by a space.
The statement: copy(,  + 9, screen);.
We will frequently use the function copy to output the elements of a container by using an ostream iterator.
Also, until we discuss ostream iterators in detail, we will use statements similar to Line A to create an ostream iterator.
Of course, we can directly specify an ostream iterator in the function copy.
For example, the statement (shown previously): copy(_0_begin(), _0_end(), screen);.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sample Run: Line 4: : 5 6 8 3 40 36 98 29 75 Line 8: : 5 6 8 3 40 36 98 29 75 Line 12: After shifting the elements one position to the left, : 6 8 3 40 36 98 29 75 75 Line 16: After shifting the elements down by two positions, : 5 6 5 6 8 3 40 36 98 Range-Based for Loops In the previous section, we described how to use the copy function to output the elements of a  container.
Moreover, Chapter 8 introduced range-based for loops, which is a feature of Cplus_plus11 Standard, and discussed how it can be effectively used to Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Components of the STL.
In Chapter 12, we explained that if a formal parameter of a function is an array, a range-based for loop cannot be used on that formal parameter, and we explained why a range-based for loop cannot be used on dynamic arrays.
However, a range-based for loop can be used on sequence containers such as objects, even if they are declared as formal parameters to a function.
Next, we explain how to use range-based for loops to process the elements of a  object.
Consider the following statements:.
The statements in Lines 2 through 5 use the function push_back to insert four numbers—13, 75, 28, and 35—into intList.
Next, consider the following for loop: <<  << " "; << endl; In this for loop, after the statement auto  : list executes,  will point to the first element of intList.
We used auto so that the compiler can infer the correct type for.
In this for loop,  ranges over the elements of list.
You can read this as "for all  in list_0_" As we can see, this for loop outputs the elements of intList.
In Example 21-4, we used a for loop to multiply each element of intList by 2.
Next, we illustrate how to use a range-based for loop to multiply each element of intList by 2.
In fact, we write a function that uses a formal parameter of type <int> to multiply each element of a  object of type int by 2.
So consider the following function:.
The function doubleList takes as a parameter a reference to an object of type <int>.
Note that the definition of this function uses a range-based for loop to process the elements of list.
Example 21-6 further illustrates how to use a range-based for loop on  objects.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Components of the STL.
However, note that the preceding program uses the function printList to output the elements of intList and the function doubleList to multiply each element of intList by 2.
Both these functions use a range-based for loop to process the elements of an object of type <int>.
Initializing  Objects during Declaration Cplus_plus allows variables of simple data types or arrays to be initialized when they are.
The second statement declares  to be an int array of 4 elements and initializes the elements of to 2, 3, 4, and 5, respectively.
In Examples 21-4 and 21-6, we declared intList to be a  object of type int and then used the function push_back to store int values in intList.
To be specific, the following statements were used to declare to be a <int> object and store 13, 75, 28, and 35 in :.
However, at the time of the writing of this book, the compiler that we used to test the Cplus_plus code has not implemented this feature of Cplus_plus11.
Therefore, we will continue to use the array subscripting operator or the function push_back, whichever is applicable, to store data or initialize a object.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The term deque stands for double-ended queue.
Deque containers are implemented as dynamic arrays in such a way that the elements can be inserted at both ends.
Thus, a deque can expand in either direction.
Elements can also be inserted in the middle.
Inserting elements in the beginning or at the end is fast; inserting elements in the middle, however, is time consuming because the elements in the queue need to be shifted.
The name of the class defining the deque containers is deque.
The definition of the class deque, and the functions to implement the various operations on a deque object, are also contained in the header file deque.
Therefore, to use a deque container in a program, the program must  the following statement: # <deque> The class  contains several constructors.
Thus, a  object can be initialized in various ways when it is declared, as described in Table 21-7.
TABLE 21-7 Various Ways to Declare a  Object.
Both beg and end are iterators.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Components of the STL.
The name of the function implementing the operations is shown in bold.
Each statement also shows how to use a particular function.
Suppose that deq is a container.
TABLE 21-8 Various Operations that Can Be Performed on a  Object.
Example 21-7 illustrates how to use a  container in a program.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Components of the STL.
Sample Run: Line 7: : 13 75 28 35 Line 12: After adding two more elements, one at the front and one at the back, : 0 13 75 28 35 100 Line 17: After removing the first two elements, : 75 28 35 100 Line 22: After removing the last two elements, = 75 28 Line 29: After inserting 444, : 75 444 28 Line 33: After assigning two copies of 45, : 45 45 Line 38: After inserting two elements, one at the front and one at the back, : -10 45 45 -999 The statement in Line 1 declares a  container  of type int; that is, all of the elements of  are of type int.
The statement in Line 2 declares screen to be an ostream iterator initialized to the standard output device.
The statements in Lines 3 through 6 use the push_back operation to insert four numbers—13, 75, 28, and 35— into.
The statement in Line 8 outputs the elements of.
In the output, see the line marked Line 7, which contains the output of the statements in Lines 7 through 9.
The statement in Line 10 inserts 0 at the beginning of ; the statement in Line 11 inserts 100 at the end of.
The statement in Line 13 outputs the modified.
The statements in Lines 15 and 16 use the function pop_front to remove the first two elements of ; the statement in Line 18 outputs the modified.
The Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The statement in Line 25 declares  to be a  iterator that processes all containers whose elements are of type int.
After the statement in Line 26 executes,  points to the first element of.
The statement in Line 27 advances  to the next element of.
The statement in Line 28 inserts 444 into  at the position specified by.
The statement in Line 30 outputs.
The statement in Line 32 assigns two copies of 45 to.
After the statement in Line 32 executes, the old elements of  are removed and  now contains only two copies of 45.
The output of the statement in Line 34 illustrates this.
In the output, see the line marked Line 33, which contains the output of the statements in Lines 33 through 35 of the program.
The meaning of the remaining statements is self-explanatory.
Sequence Container: list This section describes the sequence container list.
List containers are implemented as doubly linked lists.
Thus, every element in a list points to both its immediate predecessor and its immediate successor (except the first and last elements).
Recall that a linked list is not a random access data structure, such as an array.
Therefore, to access, say, the fifth element in the list, we must first traverse the first four elements.
The name of the class containing the definition of the class list is list.
The definition of the class list, and the definitions of the functions to implement the various operations on a list, are contained in the header file list.
Therefore, to use list in a program, the program must  the following statement: # <list> Like other container classes, the class list contains several constructors.
Thus, a list object can be initialized in several ways when it is declared, as described in Table 21-9.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Components of the STL.
Both beg and end are iterators.
Table 21-5 described the operations that are common to all containers.
Table 21-6 described the operations that are common to all sequence containers.
In addition to these common operations, Table 21-10 describes the operations that are specific to a container.
The name of the function implementing the operation is shown in bold.
In Table 21-10, listCont is a container of type.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Assigns all of the elements in the range beg_0__0__0_end-1.
Both beg and end are iterators.
If the consecutive elements in listCont have the same value, removes the duplicates.
If the consecutive elements in listCont have the same value, removes the duplicates, for which oper is true.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Components of the STL.
All of the elements of listCont2 are moved to listCont1 before the position specified by the iterator pos.
After this operation, listCont2 is empty.
All of the elements starting at pos2 of listCont2 are moved to listCont1 before the position specified by the iterator pos.
All of the elements in the range beg_0__0__0_end-1 of listCont2 are moved to listCont1 before the position specified by the iterator pos.
Both beg and end are iterators.
The elements of listCont are sorted.
The sort criteria is specified by oper.
Suppose that the elements of listCont1 and listCont2 are sorted.
This operation moves all of the elements of listCont2 into listCont1.
After this operation, the elements in listCont1 are sorted.
Moreover, after this operation, listCont2 is empty.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Suppose that the elements of listCont1 and listCont2 are sorted according to the sort criteria oper.
This operation moves all of the elements of listCont2 into listCont1.
After this operation, the elements in listCont1 are sorted according to the sort criteria oper.
Example 21-8 illustrates how to use the various operations on a list container.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Components of the STL.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sample Run: Line 12: 1: 23 58 58 58 36 15 93 98 58 Line 16: 2: 23 58 58 58 36 15 93 98 58 Line 20: After removing the consecutive duplicates, 1: 23 58 36 15 93 98 58 Line 24: After sorting, 2: 15 23 36 58 58 58 58 93 98 Line 32: 3: 13 23 25 136 198 Line 38: 4: -2 -7 -8 Line 42: After moving the elements of 4 into 3, 3: -2 -7 -8 13 23 25 136 198 Line 46: After sorting, 3: -8 -7 -2 13 23 25 136 198 Line 50: After merging 2 and 3, 2: -8 -7 -2 13 15 23 23 25 36 58 58 58 58 93 98 136 198 Line 54: After removing the consecutive duplicates, 2: -8 -7 -2 13 15 23 25 36 58 93 98 136 198 For the most part, the output of the preceding program is straightforward.
The statements in Lines 3 through 11 insert the element numbers 23, 58, 58, 58, 36, 15, 93, 98, and 58 (in that order) into 1.
The statement in Line 15 copies the elements of 1 into 2.
After this statement executes, 1 and 2 are identical.
The statement in Line 19 removes any consecutive occurrences of the same elements.
For example, the number 58 appears consecutively three times.
The operation unique removes two occurrences of 58.
Note that this operation has no effect on the 58 that appears at the end of 1.
The statement in Line 23 sorts 2.
The statements in Lines 27 through 31 insert 13, 23, 25, 136, and 198 into 3.
Similarly, the statements in Lines 35 through 37 insert -2, -7, and -8 into 4.
The statement in Line 41 uses the operation splice to move the elements of 4 to the beginning of 3.
After the splice operation, 4 is empty.
The statement in Line 45 sorts 3, and the statement in Line 49 merges 2 and 3 into 2.
After the merge operation, 3 is empty.
The meanings of the remaining statements are similar.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Now range-based for loops are a feature of Cplus_plus11 Standard and they can be used to process the elements of any sequence container object such as  and deque.
For example, in Example 21-8, the statement in Line 13, which outputs the elements of 1, can also be written as: <<  << " "; Similarly, the statements in Lines 17, 21, 25, and 33 can be written using range-based for loops.
The file STL_Example21-8_list_Modified_0_cpp, available at the Web site accompanying this book, contains the modified program, given in Example 21-8, that uses range-based for loops to output the elements of  containers 1, 2, and 3.
Examples 21-5, 21-7, and 21-8 further clarify that iterators are important to efficiently process the elements of a container.
Before describing associative containers, let us discuss iterators in some detail.
Iterators Iterators are similar to pointers.
In general, an iterator points to the elements of a container (sequence or associative).
Thus, with the help of iterators, we can successively access each element of a container.
The two most common operations on iterators are plus_plus (the increment operator) and * (the dereferencing operator).
Suppose that cntItr is an iterator into a container.
Types of Iterators There are five types of iterators:.
Input iterators Output iterators Forward iterators Bidirectional iterators Random access iterators The following sections describe these iterators.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
These iterators are provided for reading data from an input stream.
Suppose inputIterator is an input iterator.
Table 21-11 describes the operations on inputIterator.
TABLE 21-11 Operations on an Input Iterator Expression.
OUTPUT ITERATORS Output iterators, with write access, step forward element by element.
These iterators are provided for writing data to an output stream.
Suppose  is an output iterator.
Table 21-12 describes the operations on.
TABLE 21-12 Operations on an Output Iterator Expression.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Thus, if we write data at the same position twice, there is no guarantee that the new  will replace the old.
FORWARD ITERATORS Forward iterators combine all of the functionality of input iterators and almost all of the functionality of output iterators.
Suppose forwardIterator is a forward iterator.
Table 21-13 describes the operations on forwardIterator.
TABLE 21-13 Operations on a Forward Iterator Expression.
BIDIRECTIONAL ITERATORS Bidirectional iterators are forward iterators that can also iterate backward over the elements.
Suppose biDirectionalIterator is a bidirectional iterator.
The operations defined for forward iterators (Table 21-13) are also applicable to bidirectional iterators.
To step backward, the decrement operations are also defined for biDirectionalIterator.
Table 21-14 shows additional operations on a bidirectional iterator.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Bidirectional iterators can be used with containers of type vector, deque, list, set, multiset, map, and multimap.
RANDOM ACCESS ITERATORS Random access iterators are bidirectional iterators that can randomly process the elements of a container.
These iterators can be used with containers of types vector, deque, and string, as well as arrays.
The operations defined for bidirectional iterators (for example, Tables 21-13 and 21-14) are also applicable to random access iterators.
Table 21-15 describes the additional operations that are defined for random access iterators.
Suppose rAccessIterator is a random access iterator.
TABLE 21-15 Additional Operations on a Random Access Iterator Expression.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Figure 21-1 shows the iterator hierarchy.
Input iterators Output iterators.
Iterator hierarchy Now that you know the different types of iterators, next we describe how to declare an iterator into a container.
Thus, an iterator into a container is declared using the typedef iterator.
For example, the statement: <int>::iterator intVecIter; declares intVecIter to be an iterator into a  container of type int.
Because iterator is a typedef defined inside a container (that is, a class) such as , we must use the appropriate container name, container element type, and the scope resolution operator to use the typedef iterator.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
However, if a container is declared as const, then we must prevent the iterator from modifying the elements of the container, especially accidentally.
To handle this situation, every container contains another typedef const_iterator.
For example, the statement: <int>::const_iterator intConstVecIt; declares intConstVecIt to be an iterator into a  container whose elements are of type int.
The iterator intConstVecIt is used to process the elements of those containers that are declared as constant  containers of type <int>.
An iterator of type const_iterator is a read-only iterator.
An iterator of this type is used to iterate through the elements of a container in reverse.
It is required if the container is declared as const, and we need to iterate through the elements of the container in reverse.
In addition to the previous four typedefs, several other typedefs are common to all containers and are described in Table 21-16.
TABLE 21-16 Various typedefs Common to All Containers typedef.
A constant reference is read-only.
This type is also used to index through sequence containers, except list containers.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
This section describes both types of iterators.
The istream iterator is used to input data into a program from an input stream.
The class  contains the definition of an input stream iterator.
The general syntax to use an istream iterator is: <Type> isIdentifier(istream&); in which Type is either a built-in type or a user-defined class type, for which an input iterator is defined.
The identifier isIdentifier is initialized using the constructor whose argument is either an istream class object, such as cin, or any publicly defined istream subtype, such as ifstream.
The ostream iterators are used to output data from a program into an output stream.
These iterators were defined earlier in this chapter.
We review them here for the sake of completeness.
The class  contains the definition of an output stream iterator.
The general syntax to use an ostream iterator is:.
The identifier osIdentifier is initialized using the constructor whose argument is either an ostream class object, such as cout, or any publicly defined ostream subtype, such as ofstream.
In the second form used to declare an ostream iterator, by using the second argument (deLimit) of the initializing constructor, we can specify a character separating the output.
Associative Containers This section discusses associative containers.
Elements in an associative container are automatically sorted according to some ordering criteria.
The default ordering criterion is the relational operator < (less than).
Users also have the option of specifying their own ordering criterion.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
A convenient and fast way to implement this type of data structure is to use a binary search tree.
This is, in fact, how associative containers are implemented.
Thus, every element in the container has a parent node (except the root node) and, at most, two children.
For each element, the key in the parent node is larger than the key in the left child and smaller than the key in the right child.
The predefined associative containers in the STL are:.
Sets Multisets Maps Multimaps This book discusses only the associative containers set and multiset.
Associative Containers: set and multiset As described earlier, both the containers set and multiset automatically sort their elements according to some sort criteria.
The default sorting criterion is the relational operator < (less than); that is, the elements are arranged in ascending order.
The user can also specify other sorting criteria.
For user-defined data types, such as classes, the relational operators must be overloaded properly.
The only difference between the containers set and multiset is that the container multiset allows duplicates; the container set does not.
The name of the class defining the container set is set; the name of the class defining the container multiset is multiset.
The name of the header file containing the definitions of the classes set and multiset, and the definitions of the functions to implement the various operations on these containers, is set.
Thus, to use any of these containers, the program must  the following statement: # <set> Declaring set or multiset Associative Containers The classes set and multiset contain several constructors to declare and initialize containers of these types.
This section discusses the various ways that these types of associative containers are declared and initialized.
Table 21-17 describes how a set/ multiset container of a specific type can be declared and initialized.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The sort criterion is specified by sortOp.
The elements of otherCt are copied into ct.
The sort criterion is <.
Both ct and otherCt are of the same type.
The elements of otherCt are copied into ct.
The sort criterion is specified by sortOp.
Both ct and otherCt are of the same type.
Note that the sort criteria of ct and otherCt must be the same.
The elements starting at the position beg until the position end-1 are copied into ct.
Both beg and end are iterators.
The elements starting at the position beg until the position end-1 are copied into ct.
Both beg and end are iterators.
The sort criterion is specified by sortOp.
If you want to use sort criteria other than the default, you must specify this option when the container is declared.
For example, consider the following statements: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The statement in Line 2 declares otherIntSet to be an empty  container, the element type is int, and the sort criterion is -than.
That is, the elements in the container otherIntSet will be arranged in descending order.
The statements in Lines 3 and 4 have similar conventions.
The function  is defined in the header file functional.
Other functions and their purposes from this header are discussed in the section Function Objects later in this chapter.
The statements in Lines 2 and 4 illustrate how to specify the descending sorting criterion.
In the statements in Lines 2 and 4, note the space between the two > symbols—that is, the space between <int> and >.
If you are using an old compiler, then this space is important because >> is also a shift operator in Cplus_plus.
However, this restriction is removed in Cplus_plus11 and the compiler that we used to write programs in this book has implemented it.
Therefore, in Cplus_plus11, the statements in Lines 2 and 4 can be written as:.
Item Insertion and Deletion from  / Suppose that ct is either of type  or.
Table 21-18 describes the operations that can be used to insert or delete elements from a.
It also illustrates how to use these operations.
The name of the function is shown in bold.
TABLE 21-18 Operations to Insert or Delete Elements from a Set Expression.
Inserts a copy of elem into ct.
The position where elem is inserted is returned.
The first parameter, position, hints where to begin the search for insert.
The parameter position is an iterator.
Both beg and end are iterators.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Example 21-9 shows the various operations on a / container.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sample Run: Line Line Line Line 9: intSet: 3 8 16 20 19: intSetA: 238 156 84 59 39 36 30 23: After removing 59, intSetA: 238 156 84 39 36 30 31: After removing the fourth element, intSetA: 238 156 84 36 30 Line 35: intSetB: 238 156 84 36 30 Line 39: After removing all the elements, intSetB: Line 51: namesMultiSet: Zippy Hungry Goofy Goofy Donny Donny The statement in Line 1 declares intSet to be a  container.
The statement in Line 2 declares intSetA to be a  container whose elements are to be arranged in descending order.
The statement in Line 3 declares  to be a  iterator.
The iterator can process the elements of any  container whose elements are of type int and are arranged in descending order.
The statement in Line 4 declares screen to be an ostream iterator that outputs the elements of any container whose elements are of type int.
The statements in Lines 5 through 8 insert 16, 8, 20, and 3 into intSet, and the statement in Line 10 outputs the elements of intSet.
In the output, see the line marked Line 9; it contains the output of the statements in Lines 9 through 11.
The statements in Lines 12 through 18 insert 36, 84, 30, 39, 59, 238, and 156 into intSetA, and the statement in Line 20 outputs the elements of intSetA.
In the output, see the line marked Line 19.
It contains the output of the statements in Lines 19 through 21.
Notice that the elements of intSetA appear in descending order.
The statement in Line 22 removes 59 from intSetA.
After the statement in Line 26 executes,  points to the first element of intSetA.
The statement in Line 27 advances  to the next element of intSetA.
After the statement in Line 29 executes,  points to the fourth element of intSetA.
The statement in Line 30 removes the element of intSetA pointed to by.
The meanings of the statements in Lines 34 through 41 are similar.
The statement in Line 42 declares namesMultiSet to be a container of type.
The elements in namesMultiSet are of type string and are arranged in descending order.
The statement in Line 43 declares iter to be a  iterator.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The statement in Line 52 outputs the elements of namesMultiSet.
Container Adapters The previous sections discussed several types of containers.
In addition to the containers that work in a general framework, the STL provides containers to accommodate special situations.
These containers, called container adapters, are adapted standard STL containers to work in a specific environment.
The three container adapters are:.
Stacks Queues Priority queues Container adapters do not support any type of iterator.
That is, iterators cannot be used with these types of containers.
The next two sections describe two types of container adapters: stack and queue.
Stack Chapter 17 discussed the data structure stack in detail.
Because a stack is an important data structure, the STL provides a class to implement a stack in a program.
The name of the class defining a stack is stack; the name of the header file containing the definition of the class stack is stack.
Table 21-19 defines the various operations supported by the stack container class.
TABLE 21-19 Various Operations on a stack Object Operation.
This operation is implemented as a value-returning function.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
For example, the relational == can be used to determine whether two stacks are identical.
The program in Example 21-10 illustrates how to use the  container class.
Sample Run: Line 6: The  element of intStack: 3 Line 8: After the pop operation, the  element of intStack: 20 Line 9: intStack elements: 20 8 16 The preceding output is self-explanatory.
The details are left as an exercise for you.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Because a queue is an important data structure, the STL provides a class to implement queues in a program.
The name of the class defining the queue is queue, and the name of the header file containing the definition of the class queue is queue.
Table 21-20 defines the various operations supported by the queue container class.
TABLE 21-20 Various Operations on a queue Object Operation.
This operation is implemented as a value-returning function.
This operation is implemented as a value-returning function.
In addition to the operations size, empty, push, front, back, and pop, the container class provides relational operators to compare two stacks.
For example, the relational  == can be used to determine whether two stacks are identical.
The program in Example 21-11 illustrates how to use the  container class.
Sample Run: Line Line Line Line 6: The  element of intQueue: 26 7: The last element of intQueue: 33 9: After the pop operation, the  element of intQueue: 18 10: intQueue elements: 18 50 33 The preceding output is self-explanatory.
The details are left as an exercise for you.
Containers, Associated Header Files, and Iterator Support The previous sections discussed various types of containers.
Recall that every container is a class.
The definition of the class implementing a specific container is contained in the header file.
Table 21-21 describes the container, its associated header file, and the type of iterator supported by the container.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
TABLE 21-21 Containers, Their Associated Header Files, and the Type of Iterator Supported by Each Container Sequence containers Associated header file.
No iterator support Algorithms Several operations can be defined for a container.
Some of the operations are very specific to a container and, therefore, are provided as part of the container definition (that is, as member functions of the class implementing the container).
However, several operations—such as find, sort, and merge—are common to all containers.
These operations are provided as generic algorithms and can be applied to all containers, as well as the built-in array type.
The algorithms are bound to a particular container through an iterator pair.
The generic algorithms are contained in the header file algorithm.
This section describes several of these algorithms and shows how to use them in a program.
Because algorithms are implemented with the help of functions, in this section, the terms function and algorithm mean the same thing.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
However, those algorithms were tied to a specific container in terms of the members of a specific class.
All of those algorithms and a few others are also available in more general forms, called generic algorithms, and can be applied in a variety of situations.
This section discusses some of these generic algorithms.
The STL contains algorithms that look only at the elements in a container and that move the elements of a container.
It also has algorithms that can perform specific calculations, such as finding the sum of the elements of a numeric container.
In addition, the STL contains algorithms for basic set theory operations, such as set union and intersection.
You have already encountered some of the generic algorithms, such as the copy algorithm.
This algorithm copies the elements from a given range of elements to another place, such as another container or the screen.
The algorithms in the STL can be classified into the following categories:.
Nonmodifying algorithms Modifying algorithms Numeric algorithms Heap algorithms 2 1 The next four sections describe these algorithms.
Most of the generic algorithms are contained in the header file algorithm.
Certain algorithms, such as the numeric algorithms, are contained in the header file numeric.
NONMODIFYING ALGORITHMS Nonmodifying algorithms do not modify the elements of the container; they merely investigate the elements.
Table 21-22 lists the nonmodifying algorithms.
TABLE 21-22 Nonmodifying Algorithms adjacent_find.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Table 21-23 lists the modifying algorithms.
TABLE 21-23 Modifying Algorithms copy.
For example, next_permutation, partition, prev_permutation, random_shuffle, reverse, reverse_copy, rotate, rotate_copy, and stable_partition are mutating algorithms.
NUMERIC ALGORITHMS Numeric algorithms are designed to perform numeric calculations on the elements of a container.
Table 21-24 lists these algorithms.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
In the heap sort algorithm, the array containing the data is viewed as a binary tree.
Thus, a heap is a form of binary tree represented as an array.
In a heap, the first element is the largest element, and the element at the ith position (if it exists) is larger than the elements at positions 2i and 2i + 1 (if they exist).
In the heap sort algorithm, first the array containing the data is converted into a heap, and then the array is sorted using a special type of sorting algorithm.
Table 21-25 lists the basic algorithms required by the heap sort algorithm.
TABLE 21-25 Heap Algorithms make_heap.
For the most part, the function prototypes of these algorithms are given along with a brief explanation of what each algorithm does.
You will then learn how to use these algorithms with the help of a Cplus_plus program.
The STL algorithms are very powerful and accomplish amazing results.
Furthermore, they have been made general, in the sense that other than using the natural operations to manipulate containers, they allow the user to specify the manipulating criteria.
For example, the natural sorting order is ascending, but the user can specify criteria to sort the container in descending order.
Thus, every algorithm is typically implemented with the help of overloaded functions.
Before starting to describe these algorithms, we discuss function objects, which allow the user to specify the manipulating criteria.
Function Objects To make the generic algorithms flexible, the STL usually provides two forms of an algorithm using the mechanism of function overloading.
The first form of an algorithm uses the natural operation to accomplish this goal.
In the second form, the user can specify criteria based on which algorithm processes the elements.
For example, the algorithm adjacent_find searches the container and returns the position of the first two elements that are equal.
In the second form of this algorithm, we can specify criteria (say, less than) to look for the first two elements, such that the second element is less than the first element.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
More formally, a function object contains a function that can be treated as a function using the function call operator, ().
In fact, a function object is a class template that overloads the function call operator, operator().
In addition to allowing you to create your own function objects, the STL provides arithmetic, relational, and logical function objects, which are described in Table 21-26.
The STL's function objects are contained in the header file functional.
TABLE 21-26 Arithmetic STL Function Objects Function object name.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sample Run: 3:  = 90 8:  = Hello There 9: Sum of 34  26 = 60 13: : 1 2 3 4 5 6 7 8 17: Sum of the elements of  = 36 19: Product of the elements of  = 40320 Table 21-27 describes the relational STL function objects.
TABLE 21-27 Relational STL Function Objects Function object name Description Returns true if the two arguments are equal, false otherwise.
Returns true if the two arguments are not equal, false otherwise.
Returns true if the first argument is  than the second argument,  false otherwise.
For example, <Type>.
The value of  is true.
Returns true if the first argument is  than or equal to the second argument,  false otherwise.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook /or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Function object name Description Returns true if the first argument is  than the second argument,  false otherwise.
For example, <Type>.
The value of  is true.
Returns true if the first argument is  than or equal to the second argument,  false otherwise.
The STL relational function objects can also be applied to containers, as shown next.
The STL algorithm adjacent_find searches a container  returns the position in the container where the two elements are equal.
This algorithm has a second form that allows the user to specify the comparison criteria.
For example, consider the following , : = {2, 3, 4, 5, 1, 7, 8, 9};.
The function adjacent_find starts at the position _0_begin()—that is, at the first element of — looks for the first set of consecutive elements such that the first element is  than the second.
The function returns a pointer to element 5, which is stored in.
The program in Example 21-13 further illustrates how to use the relational function objects.
EXAMPLE 21-13 This example shows how the relational STL function objects work.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook /or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
TABLE 21-28 Logical STL Function Objects Function object name.
PREDICATES Predicates are special types of function objects that return Boolean values.
There are two types of predicates: unary and binary.
Unary predicates check a specific property for a single argument; binary predicates check a specific property for a pair—that is, two arguments.
Predicates are typically used to specify searching or sorting criteria.
In the STL, a predicate must always return the same result for the same value.
Therefore, the functions that modify their internal states cannot be considered predicates.
The statement in  1 declares and initializes  to be an array of five components.
The statement in  2 declares vList to be a.
Because no size is specified for vList, no memory space is reserved for the elements of vList.
Now suppose that we want to copy the elements of  into vList.
The statement: copy(,  + 8, vList_0_begin()); Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
One solution to this problem is to use a for loop to step through the elements of  and use the function push_back of vList to copy the elements of.
However, there is a better solution, which is convenient and applicable whenever no memory space is allocated at the destination.
The STL provides three iterators, called insert iterators, to insert the elements at the destination: back_inserter, front_inserter, and inserter.
The argument to this iterator is the container itself.
For example, for the preceding problem, we can copy the elements of  into vList by using back_inserter as follows: copy(,  + 5, back_inserter(vList));.
The argument to this iterator is the container itself.
Because the  class does not support the push_front operation, this iterator cannot be used for the container.
There are two arguments to this iterator: the first argument is the container itself; the second argument is an iterator to the container specifying the position at which the insertion should begin.
The program in Example 21-14 illustrates the effect of inserters on a container.
Sample Run: Line 6: vecList1: 1 2 3 4 5 6 7 8 Line 10: vecList2: 1 2 3 4 5 6 7 8 Line 15: tempList: 8 7 6 5 4 3 2 1 STL Algorithms The following sections describe most of the STL algorithms.
For each algorithm, we give the function prototypes, a brief description of what the algorithm does, and a program showing how to use it.
In the function prototypes, the parameter types indicate for which type of container the algorithm is applicable.
For example, if a parameter is of type randomAccessIterator, then the algorithm is applicable only on random access type containers, such as vectors.
Throughout, we use abbreviations such as outputItr to mean output iterator, inputItr to mean input iterator, forwardItr to mean forward iterator, and so on.
The Functions fill and fill_n The function fill is used to fill a container with elements; the function fill_n is used to fill in the next n elements.
The element that is used as a filling element is passed as a parameter to these functions.
Both of these functions are defined in the header file algorithm.
The prototypes of these functions are: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The first parameter of the function fill_n is a forward iterator that specifies the starting position of the container, the second parameter specifies the number of elements to be filled, and the third parameter specifies the filling element.
The program in Example 21-15 illustrates how to use these functions.
Sample Run: Line 4: After filling vecList with 2s: 2 2 2 2 2 2 2 2 Line 8: After filling first three elements with 5s: 5 5 5 2 2 2 2 2 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The statement in Line 3 uses the function fill to fill vecList with 2; that is, all eight elements of vecList are set to 2.
Recall that vecList_0_begin() returns an iterator to the first element of vecList, and vecList_0_end() returns an iterator to one past the last element of vecList.
The statement in Line 5 outputs the elements of vecList using the copy function.
The statement in Line 7 uses the function fill_n to store 5 in the elements of vecList.
The first parameter of fill_n is vecList_0_begin(), which specifies the starting position to begin copying.
The second parameter of fill_n is 3, which specifies the number of elements to be filled.
The third parameter, 5, specifies the filling character.
Therefore, 5 is copied into the first three elements of vecList.
The statement in Line 9 outputs the elements of vecList.
The Functions generate and generate_n The functions generate and generate_n are used to generate elements and fill a sequence.
These functions are defined in the header file algorithm.
The prototypes of these functions are: template <class forwardItr, class function> void generate(forwardItr first, forwardItr last, function gen); template <class forwardItr, class size, class function> void generate_n(forwardItr first, size n, function gen); The function generate fills a sequence in the range first_0__0__0_last-1, with successive calls to the function gen().
The function generate_n fills a sequence in the range first_0__0__0_first+n-1—that is, starting at position first, with n successive calls to the function gen().
Note that gen can also be a pointer to a function.
Moreover, if gen is a function, it must be a value-returning function without parameters.
The program in Example 21-16 illustrates how to use these functions.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sample Run: Line 4: vecList after filling with numbers: 1 2 3 4 5 6 7 8 Line 8: vecList after filling the first three elements with the next number: 9 10 11 4 5 6 7 8 This program contains a value-returning function, nextNum, which contains a static variable  initialized to 1.
A call to this function returns the current value of  and then increments the value of.
Therefore, the first call of nextNum returns 1, the second call returns 2, and so on.
The statements in Lines 1 and 2 declare vecList to be a sequence container of size 8 and screen to be an ostream iterator initialized to  with the delimit character space.
The statement in Line 3 uses the function generate to fill vecList by successively calling the function nextNum.
Notice that after the statement in Line 3 executes, the value of the static variable  of nextNum is 9.
The statement in Line 5 outputs the elements of vecList.
The statement in Line 7 calls the function generate_n to fill the first three elements of vecList by calling the function nextNum three times.
The starting position is Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The statement in Line 9 outputs the elements of vecList.
The Functions find, find_if, find_end, and find_first_of The functions find, find_if, find_end, and find_first_of are used to find the elements in a given range.
These functions are defined in the header file algorithm.
The prototypes of the functions find and find_if are: template <class inputItr, class size, class Type> inputItr find(inputItr first, inputItr last, const Type& searchValue); template <class inputItr, class unaryPredicate> inputItr find_if(inputItr first, inputItr last, unaryPredicate op); The function find searches the range of elements first_0__0__0_last-1 for the element searchValue.
If searchValue is found in the range, the function returns the position in the range where searchValue is found; otherwise, it returns last.
The function find_if searches the range of elements first_0__0__0_last-1 for the element for which op(rangeElement) is true.
If an element satisfying op(rangeElement) is true is found, it returns the position in the given range where such an element is found; otherwise, it returns last.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sample Run: Line 4: Character : a i C d e f o H u j Line 10: The element is found at  3 Line 15: The first uppercase letter is found at  2 The statement in Line 1 creates and initializes a character array, , of 10 components.
The statement in Line 2 creates the  container charList and initializes it using the character array.
The statement in Line 3 creates an ostream iterator.
The statement in Line 5 outputs charList.
The statement in Line 8 searches charList for the first occurrence of 'd' and returns an iterator, which is stored in.
The statements in Lines 9 through 12 output the result of the search.
Because 'd' is the fourth character in charList, its  is 3.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Note that the function isupper from the header file cctype is passed as the third parameter to the function find_if (see Line 13).
The statements in Lines 14 through 17 output the result of the search.
The first uppercase character in charList is 'C', which is the third element of charList; its Next, we describe the functions find_end and find_first_of.
Both of these functions have two forms.
The prototypes of the function find_end are: template <class forwardItr1, class forwardItr2> forwardItr1 find_end(forwardItr1 first1, forwardItr1 last1, forwardItr2 first2, forwardItr2 last2); template <class forwardItr1, class forwardItr2, class binaryPredicate> forwardItr1 find_end(forwardItr1 first1, forwardItr1 last1, forwardItr2 first2, forwardItr2 last2, binaryPredicate op); Both forms of the function find_end search the range first1_0__0__0_last1-1 for the last occurrence as a subrange of the range first2_0__0__0_last2-1.
If the search is successful, the function returns the  in first1_0__0_last1-1 where the match occurs; otherwise, it returns last1.
That is, the function find_end returns the  of the last element in the range first1_0__0__0_last1-1 where the range first2_0__0__0_last2-1 is a subrange of first1_0__0__0_last1-1.
In the first form, the elements are compared for equality; in the must be true.
The prototypes of the function find_first_of are: template <class forwardItr1, class forwardItr2> forwardItr1 find_first_of(forwardItr1 first1, forwardItr1 last1, forwardItr2 first2, forwardItr2 last2); template <class forwardItr1, class forwardItr2, class binaryPredicate> forwardItr1 find_first_of(forwardItr1 first1, forwardItr1 last1, forwardItr2 first2, forwardItr2 last2, binaryPredicate op); The first form returns the , within the range first1_0__0__0_last1-1, of the first element of first2_0__0__0_last2-1 that is also in the range first1_0__0__0_last1-1.
The second form returns the , within the range first1_0__0__0_last1-1, of the first element of first2_0__0__0_last2-1 for which op(elemRange1, elemRange2) is true.
If no match is found, both forms return last1-1.
The program in Example 21-18 illustrates how to use the functions find_end and find_first_of.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sample Run: Line 7: 1: 12 34 56 21 34 78 34 56 12 25 Line 10: 2: 34 56 Line 15: 2 is found in  1.
The last occurrence of 2 in  1 is at position 6 Line 18: 3: 56 21 35 Line 25: 3 is not in 1.
Line 26: 4: 33 48 21 34 73 Line 31: The first element 34 of 4 is found in 1 at position 1 The statements in Lines 1 through 4 create and initialize the int arrays 1, 2, 3, and 4.
The statements in Lines 5 and 6 declare an int pointer and an ostream iterator, respectively.
The statements in Lines 8 and 11 output the values of 1 and 2.
The last occurrence of 2 in 1 starts at position 6 (that is, at the seventh element).
The statements in Lines 14 through 17 output the result of the search.
The statement in Line 21 uses the function find_end to find the last occurrence of 3, as a subsequence, within 1.
Because 3 does not appear as a subsequence in 1, it is an unsuccessful search.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The statement in Line 29 uses the function find_first_of to find the position in 1 where the first element of 4 is also an element of 1.
The first element of 4, which is also an element of 1, is 33.
Its position in 1 is 1, the second element of 1.
The statements in Lines 30 The Functions remove, remove_if, remove_copy, and remove_copy_if The function remove is used to remove certain elements from a sequence, and the function remove_if is used to remove elements from a sequence by using some criteria.
The function remove_copy copies the elements of a sequence into another sequence by excluding certain elements of the first sequence.
Similarly, the function remove_copy_if copies the elements of a sequence into another sequence by excluding certain elements, using some criteria, of the first sequence.
These functions are defined in the header file algorithm.
The prototypes of the functions remove and remove_if are: template <class forwardItr, class Type> forwardItr remove(forwardItr first, forwardItr last, const Type& value); template <class forwardItr, class unaryPredicate> forwardItr remove_if(forwardItr first, forwardItr last, unaryPredicate op); The function remove removes each occurrence of a given element in the range first.
The element to be removed is passed as the third parameter to this function.
The function remove_if removes those elements, in the range first.
Both of these functions return forwardItr, which points to the position after the last element of the new range of elements.
These functions do not modify the size of the container; in fact, the elements are moved to the beginning of the container.
For example, if the sequence is {3, 7, 2, 5, 7, 9} and the element to be removed is 7, then after removing 7, the resulting sequence is {3, 2, 5, 9, 9, 9}.
The function returns a pointer to element 9 (which is after 5).
The program in Example 21-18 further illustrates the importance of this returned Let us now look at the prototypes of the functions remove_copy and remove_copy_if.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Similarly, the function remove_copy_if copies all of the elements in the range first1_0__0__0_last1-1, except the elements for which op(element) is true, into the sequence starting at the position destFirst.
Both of these functions return an outputItr, which points to the position after the last element copied.
The program in Example 21-19 shows how to use the functions remove, remove_if, remove_copy, and remove_copy_if.
EXAMPLE 21-19 //STL Functions remove, remove_if, remove_copy, and.
Sample Run: Line 6: Character : A a A B A c D e F A Line 9: Character  after removing A: a B c D e F Line 13: Character  after removing the uppercase letters: a c e Line 20: intList: 12 34 56 21 34 78 34 55 12 25 Line 25: temp1  after copying all the elements of intList except 34: 12 56 21 78 55 12 25 Line 30: temp2 after copying all the elements of intList except numbers less than 50: 56 78 55 0 0 0 0 0 0 0 The statement in Line 2 creates a  , charList, of type char and initializes charList using the array  created in Line 1.
The statement in Line 3 declares two iterators:  and.
The statement in Line 4 declares an ostream iterator, screen.
The statement in Line 6 outputs the value of charList.
The statement in Line 8 uses the function remove to remove all occurrences of 'A' from charList.
The function returns a pointer to one past the last element of the new , which is stored in.
The statement in Line 10 outputs the elements in the new.
The statement in Line 14 outputs the elements in the new.
The statement in Line 17 creates a , intList, of type int and initializes intList using the array , created in Line 16.
The statement in Line 21 outputs the elements of intList.
The statement in Line 24 copies all of the elements, except the occurrences of 34, of intList into temp1.
The  intList is not modified.
The statement in Line 26 outputs the elements of temp1.
The statement in Line 28 creates a , temp2, of type int of 10 components and initializes all of the elements of temp2 to 0.
The statement in Line 29 uses the function remove_copy_if to copy those elements of intList that are greater than 50.
The statement in Line 31 outputs the elements of temp2.
The Functions replace, replace_if, replace_copy, and replace_copy_if The function replace is used to replace all occurrences, within a given , of a given element with a new.
The function replace_if is used to replace the values of the elements, within a given , satisfying certain criteria with a new.
The prototypes of these functions are: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The function replace_if replaces all of the elements in the  first_0__0__0_last-1, for which op(element) is true, with the  specified by newValue.
The function replace_copy is a combination of replace and copy.
Similarly, the function replace_copy_if is a combination of replace_if and copy.
Let us first look at the prototypes of the functions replace_copy and replace_copy_if.
If the  of an element in this  is equal to oldValue, it is replaced by newValue.
The function replace_copy_if copies all of the elements in the  first_0__0__0_last-1 into the container starting at destFirst.
If, for any element in this , op(element) is true, at the destination, its  is replaced by newValue.
Both of these functions return an outputItr (a pointer) positioned one past the last element copied at the destination.
The program in Example 21-20 shows how to use the functions replace, replace_if, replace_copy, and replace_copy_if.
EXAMPLE 21-20 //STL Functions replace, replace_if, replace_copy, and.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sample Run: Line 4: Character : A a A B A c D e F A Line 8: Character  after replacing A with Z: Z a Z B Z c D e F Z Line 12: Character  after replacing the uppercase letters with *: * a * * * c * e * * Line 18: intList: 12 34 56 21 34 78 34 55 12 25 Line 23: temp1  after copying intList and replacing 34 with 0: 12 0 56 21 0 78 0 55 12 25 Line 28: temp2 after copying intList and replacing any numbers less than 50 with 50: 50 50 56 50 50 78 50 55 50 50 The statement in Line 2 creates a  , charList, of type char and initializes charList using the array  created in Line 1.
The statement in Line 3 declares an ostream iterator, screen.
The statement in Line 5 outputs the  of charList.
The statement in Line 7 uses the function replace to replace all occurrences of 'A' with 'Z' in charList.
The statement in Line 9 outputs the elements of charList.
In the output, the line marked Line 8 contains the outputs of Lines 8 through 10.
The statement in Line 11 uses the function replace_if to replace the uppercase letters with ' *' in the charList.
The statement in Line 13 outputs the elements of charList.
In the output, the line marked Line 12 contains the output of Lines 12 through 14.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The statement in Line 19 outputs the elements of intList.
The statement in Line 21 declares a  temp1 of type int.
The statement in Line 22 copies all of the elements of intList and replaces 34 with 0.
The intList is not modified.
The statement in Line 24 outputs the elements of temp1.
The statement in Line 26 creates a , temp2, of type int, of 10 components.
The statement in Line 27 uses the function replace_copy_if to copy the elements of intList and replaces all of the elements less than 50 with 50.
The statement in Line 29 outputs the elements of temp2.
In the output, the line marked Line 28 contains the output of Lines 28 through 30.
The Functions swap, iter_swap, and swap_ranges The functions swap, iter_swap, and swap_ranges are used to swap elements.
These functions are defined in the header file algorithm.
The prototypes of these functions are: template <class Type> void swap(Type& object1, Type& object2); template <class forwardItr1, class forwardItr2> void iter_swap(forwardItr1 first, forwardItr2 second);.
The function iter_swap swaps the values to which the iterators first and second point.
The function swap_ranges swaps the elements of the range first1_0__0__0_last1-1 with the consecutive elements starting at position first2.
It returns the iterator of the second range positioned one past the last element swapped.
The program in Example 21-21 illustrates how to use these functions.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sample Run: Line 5: Character : A B C D F G H I J K Line 9: Character  after swapping the first and second : B A C D F G H I J K Line 13: Character  after swapping the third and fourth : B A D C F G H I J K Line 18: Character  after swapping the fifth and sixth : B A D C G F H I J K Line 24: intList: 1 2 3 4 5 6 7 8 9 10 Line 28: intList after swapping the first four with four  starting at the sixth element of intList: 6 7 8 9 5 1 2 3 4 10 Line 32:  and intList after swapping their Line 33: : 6 7 8 9 5 1 2 3 4 10 List 36: intList: 1 2 3 4 5 6 7 8 9 10 The statement in Line 2 creates the  charList and initializes it using the array declared in Line 1.
The statement in Line 6 outputs the values of charList.
The statement in Line 8 swaps the first and second  of charList.
The statement in Line 12, using the function iter_swap, swaps the third and fourth  of charList.
The statement in Line 17 uses the iterator  to swap the fifth and sixth  of charList.
The statement in Line 19 outputs the values of the  of charList.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The statement in Line 25 outputs the values of the  of intList.
The statement in Line 27 uses the function swap_ranges to swap the first four  of intList with the four  of intList, starting at the sixth element of intList.
The statement in Line 29 outputs the  of intList.
The statement in Line 34 outputs the  of the array , and the statement in Line 37 outputs intList.
The Functions search, search_n, sort, and binary_search The functions search, search_n, sort, and binary_search are used to search and sort.
These functions are defined in the header file algorithm.
Watch the Video The prototypes of the function search are: template <class forwardItr1, class forwardItr2> forwardItr1 search(forwardItr1 first1, forwardItr1 last1, forwardItr2 first2, forwardItr2 last2); template <class forwardItr1, class forwardItr2, class binaryPredicate> forwardItr1 search(forwardItr1 first1, forwardItr1 last1, forwardItr2 first2, forwardItr2 last2, binaryPredicate op); Given two ranges of , first1_0__0__0_last1-1 and first2_0__0__0_last2-1, the function search searches the first element in the range first1_0__0__0_last1-1 where the range first2_0__0__0_last2-1 occurs as a subrange of first1_0__0__0_last1-1.
The first form makes the equality comparison between the  of the two ranges.
For the second form, the comparison op(elemFirstRange, elemSecondRange) must be true.
If a match is found, the function returns the position in the range first1_0__0__0_last1-1 where the match occurs; otherwise, the function returns last1.
The prototypes of the function search_n are: template <class forwardItr, class size, class Type> forwardItr search_n(forwardItr first, forwardItr last, size count, const Type& value); Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
The first form returns the position in the range first_0__0__0_last-1 where a subsequence of count consecutive  has values equal to value.
The second form returns the position in the range first_0__0__0_last-1 where a is true.
If no match is found, both forms return last.
The prototypes of the function sort are: template <class randomAccessItr> void sort(randomAccessItr first, randomAccessItr last); template <class randomAccessItr, class compare> void sort(randomAccessItr first, randomAccessItr last, compare op); The first form of the sort function reorders the  in the range first_0__0__0_last-1 in ascending order.
The second form reorders the  according to the criteria specified by op.
The prototypes of the function binary_search are: template <class forwardItr, class Type> bool binary_search(forwardItr first, forwardItr last, const Type& searchValue); template <class forwardItr, class Type, class compare> bool binary_search(forwardItr first, forwardItr last, const Type& searchValue, compare op); The first form returns true if searchValue is found in the range first_0__0__0_last-1, and false otherwise.
The second form uses a function object, op, that specifies the search criteria.
Example 21-22 illustrates how to use these searching and sorting functions.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sample Run: Line 6: vecList: 12 34 56 34 34 78 38 43 12 25 34 56 62 5 49 Line 9: : 34 56 Line 14:   in vecList.
The first occurrence of in vecList is at the position 1 Line 19: two consecutive occurrences of 34  in vecList at the position 3 Line 23: vecList after sorting: 5 12 12 25 34 34 34 34 38 43 49 56 56 62 78 Line 29: 78  in vecList.
The statement in Line 2 creates a , vecList, and initializes it using the array created in Line 1.
The statement in Line 3 creates an array, , of two components and initializes.
The statement in Line 7 outputs vecList.
The statement in Line 12 uses the function search and searches vecList to find the position (of the first occurrence) in vecList where  occurs as a subsequence.
The statements in Lines 13 through 16 output the result of the search; see the line marked Line 14 in the output.
The statement in Line 17 uses the function search_n to find the position in vecList where two consecutive instances of 34 occur.
The statements in Lines 18 through 21 output the result of the search.
The statement in Line 22 uses the function sort to sort vecList.
The statement in Line 24 outputs vecList.
In the output, the line marked Line 23 contains the output of the statements in Lines 23 through 25.
The statement in Line 27 uses the function binary_search to search vecList.
The statements in Lines 28 through 31 output the search result.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The prototypes of the functions implementing this algorithm are: template <class forwardItr> forwardItr adjacent_find(forwardItr first, forwardItr last); template <class forwardItr, class binaryPredicate> forwardItr adjacent_find(forwardItr first, forwardItr last, binaryPredicate op); The first form of adjacent_find uses the equality criteria; that is, it looks for the first consecutive occurrences of the same element.
In the second form, the algorithm returns an iterator to the element in the range first_0__0__0_last-1 for which op(elem, nextElem) is true, in which elem is an element in the range first_0__0__0_last-1 and nextElem is an element in this range next to elem.
If no matching elements are , both algorithms return last.
The algorithm merge merges the sorted lists.
The result is a sorted.
Both lists must be sorted according to the same criteria.
For example, both lists should be in either ascending or descending order.
The prototypes of the functions to implement the merge algorithms are: template <class inputItr1, class inputItr2, class outputItr> outputItr merge(inputItr1 first1, inputItr1 last1, inputItr2 first2, inputItr2 last2, outputItr destFirst); template <class inputItr1, class inputItr2, class outputItr, class binaryPredicate> outputItr merge(inputItr1 first1, inputItr1 last1, inputItr2 first2, inputItr2 last2, outputItr destFirst, binaryPredicate op); Both forms of the algorithm merge merge the elements of the sorted ranges first1_0__0__0_last1-1 and first2_0__0__0_last2-1.
The destination range, beginning with the iterator destFirst, contains the merged elements.
The first form uses the less-than operator, <, for ordering the elements.
The second form uses the binary predicate op to order the elements; that is, op(elemRange1, elemRange2) must be true.
Both forms return the position after the last copied element in the destination range.
Moreover, the source ranges are not modified, and the destination range should not overlap with the source ranges.
The algorithm inplace_merge is used to combine the sorted consecutive sequences.
The prototypes of the functions implementing this algorithm are: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The merged elements overwrite the two ranges beginning at first.
The first form uses the less-than criterion to merge the two consecutive sequences.
The second form uses the binary predicate op to merge the sequences; that is, for the elements of the two sequences, op(elemSeq1, elemSeq2) must be true.
For example, suppose that: = {1, 3, 5, 7, 9, 2, 4, 6, 8}.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sample Run: Line 10: intList : 0 1 1 2 3 4 4 5 6 6 Line 15: Adjacent equal elements are The first set of adjacent equal elements: 1 Line 20: intList after merging 3 and 4: 0 1 2 3 4 5 6 7 8 9 Line 24: Last element of first sorted : 9 Line 26: First element of second sorted : 0 Line 27:  before inplace_merge: 1 3 5 7 9 0 2 4 6 8 Line 31:  after inplace_merge: 0 1 2 3 4 5 6 7 8 9 The statement in Line 5 creates an intList of type <int> and initializes intList using 2.
Thus, intList is a linked.
The statement in Line 7 creates the of type int and initializes it using 1.
The statement in Line 11 outputs intList.
The statement in Line 13 uses the function adjacent_find to find the position of the (first set of) consecutive identical elements.
The function returns a pointer to the first set of consecutive elements, which is stored in.
The statements in Lines 14 through 17 output those consecutive identical elements, if any are.
Notice that the statement in Line 15 outputs *—the contents of the memory space to which  is pointing.
The statement in Line 18 clears intList by deleting all of the elements of intList.
The statement in Line 19 uses the function merge to merge 3 and 4.
The third parameter of the function merge, in Line 19, is a call to back_inserter, which places the merged  into intList.
After the statement in Line 19 executes, intList contains the merged.
The statement in Line 21 outputs intList.
In the output, see the line marked Line 20, which contains the output of the statements in Lines 20 through 22.
Notice that  is {1, 3, 5, 7, 9, 0, 2, 4, 6, 8}, which contains two sorted subsequences.
The statement in Line 23 uses the second form of the function adjacent_find to find the starting position of the second subsequence.
Notice that the third parameter of the function adjacent_find is the binary predicate , which returns the position in  where the first element is  than the second element.
The returned position is stored in the iterator , which now points to element 9.
The statement in Line 25 advances  to point to element 0, which is the first element of the second subsequence.
The statement in Line 30 uses the function Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
In the output, the line marked Line 27 contains the output of the statements in Lines 27 through 29; the line marked Line 31 contains the output of the statements in Lines 31 through 33.
The Functions reverse, reverse_copy, rotate, and rotate_copy The algorithm reverse reverses the order of the elements in a given range.
The prototype of the function to implement the algorithm reverse is: template <class biDirectionalItr> void reverse(biDirectionalItr first, biDirectionalItr last); The elements in the range first_0__0__0_last-1 are reversed.
For example, if  = {1, 2, 5, 3, 4}, then the elements in reverse order are  = {4, 3, 5, 2, 1}.
The algorithm reverse_copy reverses the elements of a given range while copying into a destination range.
The source is not modified.
The prototype of the function implementing the algorithm reverse_copy is: template <class biDirectionalItr, class outputItr> outputItr reverse_copy(biDirectionalItr first, biDirectionalItr last, outputItr destFirst); The elements in the range first_0__0__0_last-1 are copied in the reverse order at the destination, beginning with destFirst.
The function also returns the position one past the last element copied at the destination.
The algorithm rotate rotates the elements of a given range.
Its prototype is: template <class forwardItr> void rotate(forwardItr first, forwardItr newFirst, forwardItr last); The elements in the range first_0__0__0_newFirst-1 are moved to the end of the range.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
That is, the elements of the source are copied at the destination in a rotated order.
The source is not modified.
The prototype of the function implementing this algorithm is: template <class forwardItr, class outputItr> outputItr rotate_copy(forwardItr first, forwardItr middle, forwardItr last, outputItr destFirst); The elements in the range first_0__0__0_last-1 are copied into the destination range beginning with destFirst in the rotated order, so that the element specified by middle in the range first_0__0__0_last-1 becomes the first element of the destination.
The function also returns the position one past the last element copied at the destination.
The algorithms reverse, reverse_copy, rotate, and rotate_copy are contained in the header file algorithm.
The program in Example 21-24 illustrates how to use these algorithms.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sample Run: Line Line Line Line Line Line 6: intList: 1 3 5 7 9 0 2 4 6 8 10: intList after reversal: 8 6 4 2 0 9 7 5 3 1 14: resultList: 1 3 5 7 9 0 2 4 6 8 20: intList before rotating: 8 6 4 2 0 9 7 5 3 1 24: intList after rotating: 4 2 0 9 7 5 3 1 8 6 29: intList after rotating and copying: 4 2 0 9 7 5 3 1 8 6 Line 32: resultList after rotating and copying: 0 9 7 5 3 1 8 6 4 2 Line 37: resultList after rotating and copying: 6 4 2 0 9 7 5 3 1 8 The Functions count, count_if, max, max_element, min, min_element, and random_shuffle The algorithm count counts the occurrences of a given value in a given range.
The prototype of the function implementing this algorithm is: template <class inputItr, class type> iterator_traits<inputItr>:: difference_type count(inputItr first, inputItr last, const Type& value); The function count returns the number of times the value specified by the parameter value occurs in the range first_0__0__0_last-1.
The algorithm count_if counts the occurrences of a given value in a given range, satisfying a certain criterion.
The prototype of the function implementing this algorithm is: template <class inputItr, class unaryPredicate> iterator_traits<inputItr>::difference_type count_if(inputItr first, inputItr last, unaryPredicate op);.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
It has two forms, as shown by the following prototypes: template <class Type> const Type& max(const Type& aVal, const Type& bVal); template <class Type, class compare> const Type& max(const Type& aVal, const Type& bVal, compare comp); In the first form, the greater-than operator associated with Type is used.
The second form uses the comparison operation specified by comp.
The algorithm max_element is used to determine the largest element in a given range.
This algorithm has two forms, as shown by the following prototypes: template <class forwardItr> forwardItr max_element(forwardItr first, forwardItr last); template <class forwardItr, class compare> forwardItr max_element(forwardItr first, forwardItr last, compare comp); The first form uses the greater-than operator associated with the data type of the elements in the range first_0__0__0_last-1.
In the second form, the comparison operation specified by comp is used.
Both forms return an iterator to the element containing the largest value in the range first_0__0__0_last-1.
The algorithm min is used to determine the minimum of two values.
It has two forms, as shown by the following prototypes: template <class Type> const Type& min(const Type& aVal, const Type& bVal); template <class Type, class compare> const Type& min(const Type& aVal, const Type& bVal, compare comp); In the first form, the less-than operator associated with Type is used.
In the second form, the comparison operation specified by comp is used.
The algorithm min_element is used to determine the smallest element in a given range.
This algorithm has two forms, as shown by the following prototypes: template <class forwardItr> forwardItr min_element(forwardItr first, forwardItr last); template <class forwardItr, class compare> forwardItr min_element(forwardItr first, forwardItr last, compare comp); The first form uses the less-than operator associated with the data type of the elements in the range first_0__0__0_last-1.
The second form uses the comparison operation specified by comp.
Both forms return an iterator to the element containing the smallest value in the range first_0__0__0_last-1.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
There are two forms of this algorithm, as shown by the following prototypes: template <class randomAccessItr> void random_shuffle(randomAccessItr first, randomAccessItr last); template <class randomAccessItr, class randomAccessGenerator> void random_shuffle(randomAccessItr first, randomAccessItr last, randomAccessGenerator rand); The first form reorders the elements in the range first_0__0__0_last-1 using a uniform distribution random number generator.
The second form reorders the elements in the range first_0__0__0_last-1 using a random number-generating function object or a pointer to a function.
Example 21-25 illustrates how to use these functions.
Sample Run: Line Line Line Line 4: : Z a Z B Z c D e F Z 8: Number of Zs in  = 4 10: Number of uppercase letters in  = 7 13: : 12 34 56 21 34 78 34 55 12 25 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The details are left as an exercise for you.
The Functions for_each and transform The algorithm for_each is used to access and process each element in a given range by applying a function, which is passed as a parameter.
The prototype of the function implementing this algorithm is: template <class inputItr, class function> function for_each(inputItr first, inputItr last, function func); The function specified by the parameter func is applied to each element in the range first_0__0__0_last-1.
The function func can modify the element.
The returned value of the function for_each is usually ignored.
The algorithm transform has two forms.
The prototypes of the functions implementing this algorithm are: template <class inputItr, class outputItr, class unaryOperation> outputItr transform(inputItr first, inputItr last, outputItr destFirst, unaryOperation op); template <class inputItr1, class inputItr2, class outputItr, class binaryOperation> outputItr transform(inputItr1 first1, inputItr1 last, inputItr2 first2, outputItr destFirst, binaryOperation bOp); The first form of the function transform has four parameters.
This function creates a sequence of elements at the destination, beginning with destFirst, by applying the unary operation op to each element in the range first1_0__0__0_last-1.
This function returns the position one past the last element copied at the destination.
The second form of the function transform has five parameters.
This function creates a sequence of elements by applying the binary operation bOp—that is, bOp(elemRange1, elemRange2)—to the corresponding elements in the range first1_0__0__0_last1-1 and the range beginning with first2.
The resulting sequence is placed at the destination beginning with destFirst.
The function returns the position one element past the last element copied at the destination.
Example 21-26 illustrates how to use these functions.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sample Run: Line 4: : a b c d e Line 8:  after changing all lowercase letters to uppercase: A B C D E Line 13: : 2 8 5 1 7 11 3 Line 16: The effect of for_each function: 4 16 10 2 14 22 6 Line 19:  after a call to for_each function: 4 16 10 2 14 22 6 The statement in Line 7 uses the function transform to change every lowercase letter of into its uppercase counterpart.
The statement in Line 9 outputs the elements of.
In the output, the line marked Line 8 contains the output of the statements in Lines 8 through 10 in the program.
Notice that the fourth parameter of the function transform (in Line 7) is the function toupper from the header file cctype.
The statement in Line 17 calls the function for_each to process each element in the using the function doubleNum.
The function doubleNum has a reference parameter, , of type int.
Moreover, this function doubles the value of  and then outputs the value of.
Because  is a reference parameter, the value of the actual parameter is changed.
In the output, the line marked Line 16 contains the output produced by the  statement in the function doubleNum, which is passed as the third parameter of the function for_each (see Line 17).
The statement in Line 20 outputs the values of the elements of.
In the output, Line 19 contains the output of the statements in Lines 19 through 20.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
All of these algorithms assume that the elements within each given range are already sorted.
The algorithm includes determines whether the elements in one range appear in another range.
This function has two forms, as shown by the following prototypes: template <class inputItr1, class inputItr2> bool includes(inputItr1 first1, inputItr1 last1, inputItr2 first2, inputItr2 last2); template <class inputItr1, class inputItr2, class binaryPredicate> bool includes(inputItr1 first1, inputItr1 last1, inputItr2 first2, inputItr2 last2, binaryPredicate op); Both forms of the function includes assume that the elements in the ranges first1.
The function returns true if all of the elements in the range first2.
In other words, the function returns true if first1.
The first form assumes that the elements in both ranges are in ascending order.
The second form uses the operation op to determine the ordering of the elements.
Example 21-27 illustrates how the function includes works.
EXAMPLE 21-27 //STL function includes //This function assumes that the elements in the given ranges.
Sample Run: Line Line Line Line Line 5: : A B C D E 8: : A B C D E F I J K L 11: : A E I O U 15:  is a subset of 21:  is not a subset of The preceding output is self-explanatory.
The details are left as an exercise for you.
The algorithm set_intersection is used to find the elements that are common to two ranges of elements.
This algorithm has two forms, as shown by the following prototypes: template <class inputItr1, class inputItr2, class outputItr> outputItr set_intersection(inputItr1 first1, inputItr1 last1, inputItr2 first2, inputItr2 last2, outputItr destFirst); Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The created sequence is placed in the container beginning with destFirst.
Both forms return an iterator positioned one past the last element copied at the destination range.
The first form assumes that the elements are in ascending order; the second form assumes that both ranges are sorted using the operation specified by op.
The elements in the source ranges are not modified.
Notice that because 8 appears only once in , 8 appears only once in , even though 8 appears twice in.
However, because 4 appears twice in both setD and setE, 4 also appears twice in.
The algorithm set_union is used to find the elements that are contained in two ranges of elements.
This algorithm has two forms, as shown by the following prototypes: template <class inputItr1, class inputItr2, class outputItr> outputItr set_union(inputItr1 first1, inputItr1 last1, inputItr2 first2, inputItr2 last2, outputItr destFirst); template <class inputItr1, class inputItr2, class outputItr, class binaryPredicate> outputItr set_union(inputItr1 first1, inputItr1 last1, inputItr2 first2, inputItr2 last2, outputItr result, binaryPredicate op); Both forms create a sequence of sorted elements that appear in either two sorted ranges, first1.
The created sequence is placed in the container beginning with destFirst.
Both forms return an iterator positioned one past the last element copied at the destination range.
The first form assumes that the elements Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The second form assumes that both ranges are sorted using the operation specified by op.
The elements in the source ranges are not modified.
Suppose that you have setA, , setC, setD, and setE as defined previously.
Then: AunionB AunionC BunionD DunionE = = = =.
Notice that because 8 appears twice in setC, it appears twice in AunionC.
Because 4 appears twice in setD and setE, 4 appears twice in DunionE.
Example 21-28 illustrates how the functions set_union and set_intersection work.
EXAMPLE 21-28 //STL set theory functions set_union and set_intersection //These functions assume that the elements in the given ranges //are ordered according to some sorting criteria.
The details are left as an exercise for you.
The algorithm set_difference is used to find the elements in one range of elements that do not appear in another range of elements.
This algorithm has two forms, as shown by the following prototypes: template <class inputItr1, class inputItr2, class outputItr> outputItr set_difference(inputItr1 first1, inputItr1 last1, inputItr2 first2, inputItr2 last2, outputItr destFirst); template <class inputItr1, class inputItr2, class outputItr, class binaryPredicate> outputItr set_difference(inputItr1 first1, inputItr1 last1, inputItr2 first2, inputItr2 last2, outputItr destFirst, binaryPredicate op); Both forms create a sequence of sorted elements that are in the sorted range first1.
The created sequence is placed in the container beginning with destFirst.
Both forms return an iterator positioned one past the last element copied at the destination range.
The first form assumes that the elements are in ascending order.
The second form assumes that both ranges are sorted using the operation specified by op.
The elements in the source ranges are not modified.
Suppose that: setE = = = =.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
In other words, the sequence of elements created by set_symmetric_difference contains the elements that are in range1_difference_range2 union range2_difference_range1.
The created sequence is placed in the container beginning with destFirst.
Both forms return an iterator positioned one past the last element copied at the destination range.
The first form assumes that the elements are in ascending order.
The second form assumes that both ranges are sorted using the operation specified by op.
The elements in the source ranges are not modified.
It can be shown that the sequence created by set_symmetric_difference contains elements that are in range1_union_range2 but not in range1_intersection_range2.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sample Run: 8:  = 2 4 5 7 8 11:  = 3 4 5 6 7 8 10 14:  = 1 5 6 8 15 18: : 2 4 7 22: : 1 3 4 7 10 15 The preceding output is self-explanatory.
The details are left as an exercise for you.
The Functions accumulate, adjacent_difference, inner_product, and partial_sum The algorithms accumulate, adjacent_difference, inner_product, and partial_sum are numerical functions and thus manipulate numeric data.
Each of these functions has two forms.
The first form uses the natural operation to manipulate the data.
For example, the algorithm accumulate finds the sum of all of the elements in a given range.
In the second form, we can specify the operation to be applied to the elements of the range.
For example, rather than add the elements of a given range, we can specify the multiplication operation to the algorithm accumulate to multiply the elements of the range.
Next, we give the prototype of each of these algorithms followed by a brief explanation.
The algorithms are contained in the header file numeric.
For example, if the value of init is 0, the algorithm returns the sum of all of the elements.
In the second form, we can specify a binary operation, such as multiplication, to be applied to the elements of the range.
For example, if the value of init is 1 and the binary operation is multiplication, the algorithm returns the products of the elements of the range.
Next, we describe the algorithm adjacent_difference.
Its prototypes are: template <class inputItr, class outputItr> outputItr adjacent_difference(inputItr first, inputItr last, outputItr destFirst); Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
For example, if the range of elements is: {2, 5, 6, 8, 3, 7}.
The first element is the same as the first element in the original range.
The second element is equal to the second element in the original range minus the first element in the original range.
Similarly, the third element is equal to the third element in the original range minus the second element in the original range, and so on.
In the second form of adjacent_difference, the binary operation op is applied to the elements in the range.
The resulting sequence is copied at the destination specified by destFirst.
For example, if the sequence is {2, 5, 6, 8, 3, 7} and the operation is multiplication, the resulting sequence is {2, 10, 30, 48, 24, 21}.
Both forms return an iterator positioned one past the last element copied at the destination.
The algorithm inner_product is used to manipulate the elements of two ranges.
The prototypes of this algorithm are: template <class inputItr1, class inputItr2, class Type> Type inner_product(inputItr1 first1, inputItr1 last, inputItr2 first2, Type init); template <class inputItr1, class inputItr2, class Type class binaryOperation1, class binaryOperation2> Type inner_product(inputItr1 first1, inputItr1 last, inputItr2 first2, Type , binaryOperation1 op1, binaryOperation2 op2); The first form multiplies the corresponding elements in the range first1.
The products of the elements are then added to the value specified by the parameter.
To be specific, suppose that elem1 ranges over the first range and elem2 ranges over the second range starting with first2.
The first form computes: =  + elem1 * elem2 for all of the corresponding elements.
For example, suppose that the two ranges are {2, 4, 7, 8} and {1, 4, 6, 9} and that  is 0.
The function computes and returns: 0 + 2 * 1 + 4 * 4 + 7 * 6 + 8 * 9 = 132 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
This form, in fact, computes: =  op1 (elem1 op2 elem2); The algorithm partial_sum has two forms, as shown by the following prototypes: template <class inputItr, class outputItr> outputItr partial_sum(inputItr first, inputItr last, outputItr destFirst); template <class inputItr, class outputItr, class binaryOperation> outputItr partial_sum(inputItr first, inputItr last, outputItr destFirst, binaryOperation op); The first form creates a  of elements in which each element is the sum of all of the previous elements in the range first.
For example, the first element of the new  is the same as the first element in the range first.
For example, for the of elements: {1, 3, 4, 6}.
Example 21-30 illustrates how the functions of this section work.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sample Run: Line Line Line Line Line 4: : 1 7: Sum of the 9: Product of 11: : 14: : 2 3 4 5 6 7 8 elements of  = 36 the elements of  = 40320 1 1 1 1 1 1 1 1 1 2 6 12 20 30 42 56 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Quick Review | Line Line Line Line 17: 19: 21: 24: 1551 Inner  of  and : 1093 Inner  of  and , using - for *: -133 with partial : 1 3 6 10 15 21 28 36 with partial multiplication: 1 2 6 24 120 720 5040 40320 The preceding output is self-explanatory.
The details are left as an exercise for you.
QUICK REVIEW 1.
The three main components of the STL are containers, iterators, and algorithms.
STL containers are class templates.
Iterators are used to step through the elements of a container.
Algorithms are used to manipulate the elements in a container.
The main categories of containers are sequence containers, associative containers, and container adapters.
The three predefined sequence containers are , deque, and.
A  container stores and manages its objects in a dynamic array.
Because an array is a random access data structure, elements of a  can be accessed randomly.
The name of the class that implements the  container is.
Item insertion in a  container is accomplished by using the operations insert and push_back.
Item deletion in a  container is accomplished by using the operations pop_back, erase, and clear.
An iterator to a  container is declared using the typedef iterator, which is declared as a public member of the class.
Member functions common to all containers are the default constructor, constructors with parameters, the copy constructor, the destructor, empty, size, max_size, swap, begin, end, rbegin, rend, insert, erase, clear, and the relational operator functions.
The member function begin returns an iterator to the first element into the container.
The member function end returns an iterator to one past the last element into the container.
In addition to the member functions listed in item 13 above, the other member functions common to all sequence containers are insert, push_back, pop_back, erase, clear, and resize.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The copy algorithm is used to copy the elements in a given range to another place.
The function copy, using an ostream iterator, can also be used to output the elements of a container.
When we create an iterator of type ostream, we also specify the type of element that the iterator will output.
Deque containers are implemented as dynamic arrays in such a way that the elements can be inserted at both ends of the array.
A deque can expand in either direction.
The name of the class containing the definition of the class deque is deque.
In addition to the operations that are common to all containers, other operations that can be used to manipulate the elements of a deque are assign, push_front, pop_front, at, the array subscripting operator [], front, and back.
List containers are implemented as doubly linked lists.
Thus, every element in the list points to its immediate predecessor and its immediate successor (except the first and last elements).
The name of the class containing the definition of the class list is list.
In addition to the operations that are common to sequence containers, other operations that can be used to manipulate the elements in a list container are assign, push_front, pop_front, front, back, remove, remove_if, unique, splice, sort, merge, and reverse.
The five categories of iterators are input, output, forward, bidirectional, and random access iterator.
Input iterators are used to input data from an input stream.
Output iterators are used to output data to an output stream.
A forward iterator can refer to the same element in the same collection and process the same element more than once.
Bidirectional iterators are forward iterators that can also iterate backward over the elements.
Bidirectional iterators can be used with containers of type list, set, multiset, multimap, map, and multimap.
Random access iterators are bidirectional iterators that can randomly process the elements of a container.
Random access iterators can be used with containers of type vector, dequeue, and string, as well as arrays.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Quick Review | 35.
The default ordering criterion is the relational operator less-than, <.
The predefined associative containers in the STL are set, multiset, map, and multimap.
Containers of the type set do not allow duplicates.
Containers of the type multiset allow duplicates.
The name of the class defining the container set is set.
The name of the class defining the container multiset is multiset.
The name of the header file containing the definition of the classes set and multiset, and the definitions of the functions to implement the various operations on these containers, is set.
The operations insert, erase, and clear can be used to insert or delete elements from sets.
Most of the generic algorithms are contained in the header file algorithm.
The main categories of STL algorithms are nonmodifying, modifying, numeric, and heap.
Nonmodifying algorithms do not modify the elements of the container.
Modifying algorithms modify the elements of the container by rearranging, removing, and/or changing the values of the elements.
Modifying algorithms that change the order of the elements, not their values, are also called mutating algorithms.
Numeric algorithms are designed to perform numeric calculations on the elements of a container.
A function object is a class template that overloads the function call operator, operator().
The predefined arithmetic function objects are plus, minus, multiplies, divides, modulus, and negate.
The predefined relational function objects are equal_to, not_equal_to, greater, greater_equal, less, and less_equal.
The predefined logical function objects are logical_not, logical_and, and logical_or.
Predicates are special types of function objects that return Boolean values.
Unary predicates check a specific property for a single argument; binary predicates check a specific property for a pair—that is, two arguments.
Predicates are typically used to specify a searching or sorting criteria.
In the STL, a predicate must always return the same result for the same value.
The functions that modify their internal states cannot be considered predicates.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The STL provides three iterators—back_inserter, front_inserter, and inserter—called insert iterators to insert the elements at the destination.
The back_inserter uses the push_back operation of the container in place of the assignment operator.
The front_inserter uses the push_front operation of the container in place of the assignment operator.
Because the vector class does not support the push_front operation, this iterator cannot be used for the vector container.
The inserter iterator uses the container's insert operation in place of the assignment operator.
The function fill is used to fill a container with elements, and the function fill_n is used to fill in the next n elements.
The functions generate and generate_n are used to generate elements and fill a sequence.
The functions find, find_if, find_end, and find_first_of are used to find the elements in a given range.
The function remove is used to remove certain elements from a sequence.
The function remove_if is used to remove elements from a sequence using a specified criterion.
The function remove_copy copies the elements in a sequence into another sequence by excluding certain elements from the first sequence.
The function remove_copy_if copies the elements in a sequence into another sequence by excluding certain elements, using a specified criterion, from the first sequence.
The functions swap, iter_swap, and swap_ranges are used to swap elements.
The functions search, search_n, sort, and binary_search are used to search elements.
The function adjacent_find is used to find the first occurrence of consecutive elements satisfying a certain criterion.
The algorithm merge merges two sorted lists.
The algorithm inplace_merge is used to combine two sorted, consecutive sequences.
The algorithm reverse reverses the order of the elements in a given range.
The algorithm reverse_copy reverses the elements in a given range while copying into a destination range.
The source is not modified.
The algorithm rotate rotates the elements in a given range.
The algorithm rotate_copy copies the elements of the source at the destination in a rotated order.
The algorithm count counts the occurrences of a given value in a given range.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The algorithm max is used to determine the maximum of two values.
The algorithm max_element is used to determine the largest element in a given range.
The algorithm min is used to determine the minimum of two values.
The algorithm min_element is used to determine the smallest element in a given range.
The algorithm random_shuffle is used to randomly order the elements in a given range.
The algorithm for_each is used to access and process each element in a given range by applying a function, which is passed as a parameter.
The function transform creates a sequence of elements by applying certain operations to each element in a given range.
The algorithm includes determines whether the elements of one range appear in another range.
The algorithm set_intersection is used to find the elements that are common to two ranges of elements.
The algorithm set_union is used to find the elements that are contained in two ranges of elements.
The algorithm set_difference is used to find the elements in one range of elements that do not appear in another range of elements.
Given two ranges of elements, the algorithm set_symmetric_difference determines the elements that are in the first range but not the second range or the elements that are in the second range but not the first range.
The algorithms accumulate, adjacent_difference, inner_product, and partial_sum are numerical functions and manipulate numeric data.
EXERCISES The number in parentheses at the end of an exercise refers to the learning objective listed at the beginning of the chapter.
Mark the following statements as true or false.
The STL containers are classified into the following categories: When you declare a vector object and specify its size as 10, then only Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The function end returns the position of the last element in the h.
The function copy is used to copy the elements from one place to i.
A range-based for loop can be used on sequence containers even if j.
Elements in an associative container are sorted according to some m.
You can use iterators to step through the elements of container n.
A function object is a class template that overloads the function call p.
The function replace_if replaces all occurrences, within a given q.
The function adjacent_find is used to find the first occurrence of Suppose that  is a vector container and: e.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Suppose that setA, setB, setC, and setD are defined as follows: int int int int setA[] setB[] setC[] setD[] = = = =.
Further suppose that you have the following declarations: int int int int int.
What is stored in AunionB, AunionC, BunionD, AintersectB, and set_union(setA, setA + set_union(setA, setA + set_union(setB, setB + set_intersection(setA, set_intersection(setA, 8, setB, setB + 8, setC, setC + 7, setD, setD + setA + 8, setB, setA + 8, setC,.
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Redo the Election Results programming example of Chapter 18 so that it uses the STL class  to process candidates data.
Redo the DVD Store programming example of Chapter 16 so that it uses the STL class  to process a  of DVDs.
Redo Programming Exercise 14 of Chapter 16 so that it uses the STL class to process the  of DVDs rented by the customer and the  of store members.
Redo Programming Exercise 15 of Chapter 16 so that it uses the STL class to process the  of DVDs owned by the store, the  of DVDs rented by each customer, and the  of store members.
Redo the Postfix Expression Calculator program of Chapter 17 so that it uses the STL class stack to evaluate the postfix expressions.
Redo Programming Exercise 10 of Chapter 17 so that it uses the STL class stack to convert the infix expressions to postfix expressions.
Redo the simulation program of Chapter 17 so that it uses the STL class queue to maintain the  of waiting customers.
Write a program to play the Card Guessing Game.
Your program must give the user the following choices: a.
Guess only the face value of the card.
Guess only the suit of the card.
Guess both the face value and suit of the card.
Before the start of the game, create a deck of cards.
Before each guess, use the function random_shuffle to randomly shuffle the deck.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Right to left Right to left dynamic_cast.
Right to left reinterpret_cast plus_plus ~.
Left to right Left to right >>.
Right to left sizeof _0_* /.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Right to left = <<= += >>= -= *= &= |= /= ^= %= Right to left Right to left throw.
Left to right Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
For example, 1565 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Therefore, the character at position 65 (which is the 66th character) is A.
Moreover, the character b at position 32 represents the space character.
The first 32 characters, that is, the characters at positions 00-31 and at position 127 are nonprintable characters.
The following table shows the abbreviations and meanings of these characters.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
EBCDIC (Extended Binary Coded Decimal Interchange Code) | 1567 EBCDIC 11 >.
For example, the character in the row marked 19 (the number in the first column) and the column marked 3 (the number in the second row) is A.
Therefore, the character at position 193 (which is the 194th character) is A.
Moreover, the character b at position 64 represents the space character.
The preceding table does not show all the characters in the EBCDIC character set.
In fact, the characters at positions 00-63 and 250-255 are nonprintable control characters.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
APPENDIX D O PERATOR O VERLOADING ª HunThomas/Shutterstock_0_com The following table lists the operators that can be overloaded.
Operators that can be overloaded +.
The following table lists the operators that cannot be overloaded.
Operators that cannot be overloaded.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
APPENDIX E ADDITIONAL Cplus_plus TOPICS ª HunThomas/Shutterstock_0_com Binary (Base 2) Representation of a Nonnegative Integer Chapter 1 remarked that A is the 66th character in the ASCII character set, but its position is 65 because the position of the first character is 0.
Furthermore, the binary number 1000001 is the binary representation of 65.
The number system that we use daily is called the decimal number system or base 10 system.
The number system that the computer uses is called the binary number system or base 2 system.
In this section, we describe how to find the binary representation of a nonnegative integer and vice versa.
Note that: 65 ¼ 1  26 þ 0  25 þ 0  24 þ 0  23 þ 0  22 þ 0  21 þ 1  20 Similarly: 711 ¼ 1  29 þ 0  28 þ 1  27 þ 1  26 þ 0  25 þ 0  24 þ 0  23 þ 1  22 þ 1  21 þ 1  20 In general, if m is  nonnegative integer, then m can be written as: m ¼ ak  2 þ ak1  21 þ ak2  22 þ    þ 1  21 þ 0  20 ; for some nonnegative integer , and where  = 0 or 1, for each  = 0, 1, 2,.
The binary number akak1ak2.
In this case, we usually write: m10 ¼ ðak ak1 ak2    1 0 Þ2 and say that m to the base 10 is akak-1ak-2.
For example, for the integer 65,  = 6, 6 = 1, 5 = 0, 4 = 0, 3 = 0, 2 = 0, 1 = 0, and 0 = 1.
Thus, 6543210 = 1000001, so the binary representation of 65 is 1000001, that is: 6510 ¼ ð1000001Þ2 : If no confusion arises, then we write (1000001)2 as 10000012.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Thus: 71110 ¼ 10110001112 : It follows  to find the binary representation of  nonnegative, we need to find the coefficients, which are 0 or 1, of various powers of 2.
However, there is an easy algorithm, described next,  can be used to find the binary representation of  nonnegative integer.
First, note : 010 ¼ 02 ; 110 ¼ 12 ; 210 ¼ 102 ; 310 ¼ 112 ; 410 ¼ 1002 ; 510 ¼ 1012 ; 610 ¼ 1102 ; 710 ¼ 1112 : Let us consider the integer 65.
We can show this continuous division obtaining the remainder with the help of Figure E-1.
Determining the binary representation of 65 Notice  in Figure E-1(), starting at the second , the second column contains the quotient when the number in the previous  is divided by 2  the third column contains the remainder of  division.
For example, in the second , 65 / 2 = 32, 65 % 2 = 1.
For each , the number in the second column is divided by 2, the quotient is written in the next , below the current ,  the remainder is written in the third column.
When using Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook /or eChapter(s).
Editorial review has deemed  any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Binary (Base 2) Representation of  Nonnegative Integer.
You can write the binary representation of the number starting with the last remainder in the third column, followed by the second to last remainder,  so on.
Figure E-2 shows the quotients  the remainders.
Determining the binary representation of 711 From Figure E-2, it follows that: 71110 ¼ 10110001112 : Converting a Binary Number (Base 2) to Base 10 To convert a number from base 2 to base 10, we first find the weight of each bit in the binary number.
The weight of each bit in the binary number is assigned from right to left.
The weight of the rightmost bit is 0.
The weight of the bit immediately to the left of the rightmost bit is 1, the weight of the bit immediately to the left of it is 2,  so on.
Consider the binary number 1001101.
The weight of each bit is as follows: weight 6.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook /or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
For each bit, we multiply the bit by 2 to the power of its weight  then we add all of the numbers.
For the above binary number, the equivalent decimal number is: 1  26 þ 0  25 þ 0  24 þ 1  23 þ 1  22 þ 0  21 þ 1  20 ¼ 64 þ 0 þ 0 þ 8 þ 4 þ 0 þ 1 ¼ 77: The previous sections described how to convert a binary number to a decimal number (base 2).
Even though the language of a computer is binary, if the binary number is too long, then it will be hard to manipulate it manually.
To effectively deal with binary numbers, two more number systems, octal (base 8)  hexadecimal (base 16), are of interest to computer scientists.
The digits in the octal number system are 0, 1, 2, 3, 4, 5, 6,  7.
The digits in the hexadecimal number system are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E,  F.
So A in hexadecimal is 10 in decimal, B in hexadecimal is 11 in decimal,  so on.
The algorithm to convert a binary number into an equivalent number in octal (or hexadecimal) is quite simple.
Before we describe the method to do so, let us review some notations.
Suppose ab represents the number a to the base b.
For example, 2A016 means 2A0 to the base 16,  638 means 63 to the base 8.
First we describe how to convert a binary number into an equivalent octal number vice versa.
Table E-1 describes the first eight octal numbers.
TABLE E-1 Binary representation of first eight octal numbers.
To find the equivalent octal number, starting from right to left we consider three digits at a time and write their octal representation.
Note that the binary number 1101100010101 has only 13 digits.
So when Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Binary (Base 2) Representation of a Nonnegative Integer.
In this case, we just add two 0s to the left of the binary number; the equivalent binary number is 001101100010101.
To convert an octal number into an equivalent binary number, using Table E-1, write the binary representation of each octal digit in the number.
Next we discuss how to convert a binary number into an equivalent hexadecimal number and vice versa.
The method to do so is similar to converting a number from binary to octal and vice versa, except that here we work with four binary digits.
Table E-2 gives the binary representation of the first 16 hexadecimal numbers.
TABLE E-2 Binary representation of first 16 hexadecimal numbers.
F Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Now, 11111010100010101012 ¼ 111 1101 0100 0101 01012 ¼ 0111 1101 0100 0101 01012, add one zero to the left ¼ 7D45516 Hence, 11111010100010101012 ¼ 7D45516.
Next, to convert a hexadecimal number into an equivalent binary number, write the four-digit binary representation of each hexadecimal digit into that number.
More on File Input/Output In Chapter 3, you learned how to read data from and write data to a file.
This section expands on the concepts introduced in that chapter.
Binary Files In Chapter 3, you learned how to make a program read data from and write data to a file.
However, the files that the programs have used until now are called text files.
Data in a text file is stored in the character format.
For example, consider the number 45.
If 45 is stored in a file, then it is stored as a sequence of two characters—the character '4' followed by the character '5'.
The eight-bit machine representation of '4' is 00000100 and the eight-bit machine representation of '5' is 00000101.
Therefore, in a text file, 45 is stored as 0000010000000101.
When this number is read by a Cplus_plus program, it must first be converted to its binary format.
Suppose that the integers are represented as 16-bit binary numbers.
The 16-bit binary representation of 45 is then 0000000000101101.
Similarly, when a program stores the number 45 in a text file, it first must be converted to its text format.
It thus follows that reading data from and writing data to a text file is not efficient, because the data must be converted from the text to the binary format and vice versa.
On the other hand, when data is stored in a file in the binary format, reading and writing data is faster because no time is lost in converting the data from one format to another format.
Such files are called binary files.
More formally, binary files are files in which data is stored in the binary format.
Data in a text file is also called formatted data, and in a binary file it is called raw data.
Cplus_plus allows a programmer to create binary files.
This section explains how to create binary files and also how to read data from binary files.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
More on File Input/Output.
Consider the following statement: outFile_0_open("employee_0_dat", ios::binary); This statement opens the file employee_0_dat.
Data in this file will be written in its binary format.
Therefore, the file opening mode ios::binary specifies that the file is opened in the binary mode.
Next, you use the stream function write to write data to the file employee_0_dat.
The syntax to use the function write is: fileVariableName_0_write(reinterpret_cast<const char *> (buffer), sizeof(buffer)); where fileVariableName is the object used to open the output file, and the first argument buffer specifies the starting address of the location in memory where the data is stored.
The expression sizeof(buffer)specifies the size of the data, in bytes, to be written.
For example, suppose num is an int variable.
The following statement writes the value of num in the binary format to the file associated with outFile: outFile_0_write(reinterpret_cast<const char *> (&num), sizeof(num)); Similarly, suppose empSalary is an array of, say, 100 components and the component type is double.
The following statement writes the entire array to the file associated with outFile: outFile_0_write(reinterpret_cast<const char *> (empSalary), sizeof(empSalary)); Next, let us discuss how to read data from a binary file.
The operation of reading data from a binary file is similar to writing data to a binary file.
First, the binary file must be opened.
For example, suppose inFile is an ifstream variable, and a program has already created the binary file employee_0_dat.
The following statement opens this file: inFile_0_open("employee_0_dat");.
To read data in the binary format, the stream function read is used.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
The expression sizeof(buffer) specifies the size of the data, in bytes, to be read.
The program in the following example further explains how to create binary files and read data from a binary file.
The details are left as an exercise for you.
In the program in Example E-1, the statement in Line 2 declares the struct variable and also initializes it.
Because  has three components and we want to initialize all the components, three values are specified in braces separated by commas.
In other words, struct variables can also be initialized when they are declared.
The program in the following example further explains how to create binary files and then read the data from the binary files.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Sample Run: ID 77234 12345 87123 81234 11111 23422 22222 54234 55555 23452 32657 82722 First Name Ashley Brad Lisa Sheila Rita Ajay Jose Sheila Tommy Salma Jennifer Steve Last Name White Smith Johnson Robinson Gupta Kumar Ramey Duffy Pitts Quade Ackerman Sharma 4563_0_50 128923_0_45 2345_0_93 674_0_00 14863_0_50 72682_0_90 25345_0_35 65222_0_00 892_0_85 2812_0_90 9823_0_89 78932_0_00 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the  to remove additional content at any time if subsequent rights restrictions require it.
More specifically, you used ifstream objects to read data from a file and ofstream objects to write data to a file.
However, the files were read and/or written sequentially.
Reading data from a file sequentially does not work very well for a variety of applications.
For example, consider a program that processes customers' data in a bank.
Typically, there are thousands or even millions of customers in a bank.
Suppose we want to access a customer's data from the file that contains such data, say, for an account update.
If the data is accessed sequentially, starting from the first position and read until the desired customer's data is found, this process might be extremely time consuming.
Similarly, in an airline's reservation system to access a passenger's reservation information sequentially, this might also be very time consuming.
In such cases, the data retrieval must be efficient.
A convenient way to do this is to be able to read the data randomly from a file, that is, randomly access any record in the file.
In the preceding section, you learned how to use the stream function read to read a specific number of bytes, and the function write to write a specific number of bytes.
The stream function seekg is used to move the read position to any byte in the file.
The general syntax to use the function seekg is: fileVariableName_0_seekg(offset, position);.
The offset can be calculated from the beginning of the file, end of the file, or the current position in the file.
Moreover, offset is a long integer representation of an offset.
Table E-3 shows the values that can be used for position.
TABLE E-3 Values of position.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the  to remove additional content at any time if subsequent rights restrictions require it.
More on File Input/Output.
One byte is used to store each character of this line of text.
Moreover, the position of the first character is 0.
Sets the reading position of inFile to the 11th byte (character), which is at position 10.
That is, it sets the reading position just after the digit 9 or just before the letter A.
That is, it sets the reading position just before the letter U.
The program in the following example further explains how the functions seekg and seekp work.
Sample Run: Line Line Line Line 8: The first : 0 11: Current  read: 7 14: Seventh  from the beginning: 7 17: Byte 26 from the end: A The input file contains the following line of text: 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ The following program illustrates how the function seekg works with structs.
EXAMPLE E-5 Suppose customerType is a struct defined as follows: struct customerType.
More on File Input/Output.
You can use the function seekg to move the reading position of this file to any record.
Suppose inFile is an ifstream object used to open the binary file customer_0_dat.
The following statement calculates the size of a customerType struct and stores it in the variable : long  = sizeof(cust);.
The following program further illustrates how the function seekg works with structs.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
More on File Input/Output.
Using the function seekg, the reading position in a file can be moved to any location in the file.
Similarly, the function seekp can be used to move the write position in a file to any location.
Furthermore, these functions can be used to create a binary file in which the is organized according to the values of either a variable or a particular component of a struct.
For example, suppose there are at most, say, 100 students in a class.
Each student has a unique ID in the range 1 to 100.
Using the students' IDs, we can create a random access binary file in such a way that in the file, a student's  is written at the location specified by its ID.
This is like treating the file as an array.
The advantage is that, once the file is created, a student's  from the file can be read, directly, using the student's ID.
Another advantage is that in the file, the  is sorted according to the IDs.
Here, we are assuming that the student IDs are in the range 1 to 100.
However, if you use, say, a three-, four-, or five-digit number as a student ID and there are only a few students in the class, the  in the file could be scattered.
In other words, a lot of space could be used just to store only a few students'.
In such cases, more advanced techniques are used to organize the  so that it can be accessed efficiently.
The program in Example E-7 illustrates how to use the students' IDs to organize the in a binary file.
The program also shows how to output the file.
More on File Input/Output.
Sample Run: 2 10 12 16 23 34 36 41 45 56 67 75 First Name Sheila Ajay Ashley Tommy Rita Brad Salma Steve Sheila Lisa Jose Jennifer Last Name Duffy Kumar White Pitts Gupta Smith Quade Sharma Robinson Johnson Ramey Ackerman Current 4_0_00 3_0_60 3_0_90 2_0_40 3_0_40 3_0_50 3_0_90 3_0_50 2_0_50 2_0_90 3_0_80 4_0_00 The data in the file studentData_0_txt is as follows: 12 Ashley White 3_0_9 34 Brad Smith 3_0_5 56 Lisa Johnson 2_0_9 45 Sheila Robinson 2_0_5 23 Rita Gupta 3_0_4 10 Ajay Kumar 3_0_6 67 Jose Ramey 3_0_8 2 Sheila Duffy 4_0_0 16 Tommy Pitts 2_0_4 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the  to remove additional content at any time if subsequent rights restrictions require it.
As indicated in Chapter 1, there are two versions of Cplus_plus—ANSI/ISO Standard Cplus_plus and Standard Cplus_plus.
For the most part, these two standards are the same.
The header files in Standard Cplus_plus have the extension _0_h, while the header files in ANSI/ISO Standard Cplus_plus have no extension.
Moreover, the names of certain header files, such as math_0_h, in ANSI/ISO Standard Cplus_plus start with the letter c.
The language Cplus_plus evolved from C.
The header files—such as iostream_0_h, iomanip_0_h, and fstream_0_h—were specially designed for Cplus_plus.
Recall that when a header file is included in a program, the global identifiers of the header file also become the global identifiers of the program.
In ANSI/ISO Standard Cplus_plus, to take advantage of the namespace mechanism, all of the header files were modified so that the identifiers are declared within a namespace.
Recall that the name of this namespace is std.
In ANSI/ISO Standard Cplus_plus, the extension _0_h of the header files that were specially designed for Cplus_plus was dropped.
For the header files that were brought from C into Cplus_plus, the extension _0_h was dropped and the names of these header files start with the letter c.
Following are the names of the most commonly used header files in Standard Cplus_plus and ANSI/ISO Standard Cplus_plus: Standard Cplus_plus Header File Name ANSI/ISO Standard Cplus_plus Header File Name assert_0_h ctype_0_h float_0_h fstream_0_h iomanip_0_h iostream_0_h limits_0_h math_0_h stdlib_0_h string_0_h cassert cctype cfloat fstream iomanip iostream climits cmath cstdlib cstring Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Naming Conventions of Header Files in ANSI/ISO Standard Cplus_plus and Standard Cplus_plus |.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
This appendix discusses some of the most widely used library routines (and several named constants).
For additional explanation and information on functions, named constants, and so on, check your system documentation.
The names of the Standard Cplus_plus header files are shown in parentheses.
The following table describes the function assert.
Its specification is contained in the header file cassert (assert_0_h).
If the value of expression is 0 (false), execution of the program terminates immediately.
The expression, the name of the file containing the source code, and the line number in the source code are displayed.
To disable all of the assert statements, place the preprocessor directive #define NDEBUG before the directive # <cassert>.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Function Name and Parameters.
Function Return Value Function returns an int value as follows:.
If ch is a letter or a digit character, that is ('A'-'Z', 'a'-'z', '0'-'9'), it.
Function returns an int value as follows:.
If ch is a control character (in ASCII, a character value 0-31 or 127), it returns a.
Function returns an int value as follows:.
If ch is a digit ('0'-'9'), it returns a.
Function returns an int value as follows:.
If ch is lowercase ('a'-'z'), it returns a.
Function returns an int value as follows:.
If ch is a printable character, including blank (in ASCII, ' ' through '~'), it returns.
Function returns an int value as follows:.
If ch is a punctuation character, it returns a.
Function returns an int value as follows:.
If ch is a whitespace character (blank, newline, tab, carriage return, form feed), it.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
If ch is an uppercase letter ('A'-'Z'), it.
Function returns an int value as follows:.
If ch is an uppercase letter, it returns the ASCII value of the lowercase equivalent of ch.
ASCII value of ch, otherwise.
Function returns an int value as follows:.
If ch is a lowercase letter, it returns the ASCII value of the uppercase equivalent of ch.
ASCII value of ch, otherwise In Chapter 2, we listed the largest and smallest values belonging to the floating-point data types.
We also remarked that these values are system dependent.
These largest and smallest values are stored in named constants.
The header file cfloat contains many such named constants.
The following table lists some of these constants.
Minimum positive long double value Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
In Chapter 2, we listed the largest and smallest values belonging to the integral data types.
We also remarked that these values are system dependent.
These largest and smallest values are stored in named constants.
The header file climits contains many such named constants.
The following table lists some of these constants.
Named Constant Description.
Minimum short Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Hyperbolic sine of Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Function Name and.
The returned  is as follows:.
An int  > 0 if 1 > 2 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Associated with the string type are a data type string::size_type and a named constant string::npos.
These are defined as follows: string::size_type An unsigned integer type.
The maximum value of type string::size_type The type string contains several functions for string manipulation.
In addition to the string functions listed in Table 7-1, the following table describes additional string functions.
In this table, we assume that strVar is a string variable and  is a string variable, a string constant, or a character array.
The name of the function is shown in bold.
Expression Effect getline(istreamVar, strVar); istreamVar is an input stream variable (of type istream or ifstream).
Characters until the newline character are input from istreamVar and stored in strVar.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Removes all of the characters from strVar starting at index pos.
If n is less than the current storage size of strVar, the storage size of the string is truncated to n.
If n is greater than the current storage size, the string is expanded to size n and the additional space is filled with copies of the character specified by the char variable ch.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
APPENDIX G MEMORY SIZE ON A SYSTEM AND RANDOM NUMBER GENERATOR ª HunThomas/Shutterstock_0_com A program similar to the following prints the memory size of the built-in data types on your system.
Sample Run: Size Size Size Size Size Size Size Size Size Size Size Size of of of of of of of of of of of of = 1 = 4 = 2 unsigned  = 4 = 4 = 8 = 1 = 4 = 8 = 8 unsigned  = 2 unsigned  = 4 1603 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
To use the function rand, the program must  the header file cstdlib.
The header file cstdlib also contains the constant RAND_MAX.
Typically, the value of RAND_MAX is 32767.
To find the exact value of RAND_MAX, check your system's documentation.
The function rand generates an integer between 0 and RAND_MAX.
The following program illustrates how to use the function rand.
It also prints the value of RAND_MAX:.
Sample Run: The value of : 32767 A random : 41 A random  between 0 and 9: 7 A random  between 0 and 1: 0_0_19330 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Booch, Object-Oriented Analysis and Design, 2nd ed_0_, Addison-Wesley, Reading, MA, 1995.
Sahni, and S.
Rajasekaran, Computer Algorithms Cplus_plus, Computer Science Press, 1997.
Josuttis, The Cplus_plus Standard Library: A Tutorial and Reference, Addison-Wesley, Reading, MA, 1999.
Knuth, The Art of Computer Programming, Volume 1: Fundamental Algorithms, 3rd ed_0_, Addison-Wesley, Reading, MA, 1997.
Knuth, The Art of Computer Programming, Volume 2: Seminumerical Algorithms, 3rd ed_0_, Addison-Wesley, Reading, MA, 1998.
Knuth, The Art of Computer Programming, Volume 3: Searching and Sorting, 2nd ed_0_, Addison-Wesley, Reading, MA, 1998.
Lippman and J.
Lajoie, Cplus_plus Primer, 3rd ed_0_, Addison-Wesley, Reading, MA, 1998.
Sen, Discrete Mathematics: Theory and Applications (Revised Edition), Cengage Learning Asia, Singapore, 2010.
Hensen, Data Structures in Pascal, Little Brown and Company, Boston, MA, 1986.
Sedgewick, Algorithms in C, 3rd ed_0_, Addison-Wesley, Reading, MA, Parts 1-4, 1998; Part 5, 2002.
Stroustrup, The Design and Evolution of Cplus_plus, Addison-Wesley, Reading, MA, 1994.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
APPENDIX I ANSWERS TO ODD-NUMBERED EXERCISES ª HunThomas/Shutterstock_0_com Chapter 1 1.
All programs must be loaded into main memory before they can be executed.
Similarly, all data must be brought into main memory before a program can manipulate it.
The operating system monitors the overall activity of the computer and provides services.
In machine language the programs are written using the binary codes while in high-level language the programs are closer to the natural language.
For execution, a high-level language program is translated into the machine language while a machine language need not be translated into any other language.
To load an executable program into main memory.
A compiler reports syntax errors.
Analyze the problem, outline the problem and its solution requirements, and design an algorithm to solve the problem.
Implement the algorithm in a programming language, such as Cplus_plus, and verify that the algorithm works.
Maintain the program by using and modifying it if the problem domain changes.
To find the weighted average of the four test scores, first you need to know each test score and its weight.
Next, you multiply each test score with its weight and then add these numbers to get the average.
Get Get Get Get testScore1, weightTestScore1 testScore2, weightTestScore2 testScore3, weightTestScore3 testScore4, weightTestScore4 1607 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Then we divide the price of the pizza by the  of the pizza.
Let radius denote the radius,  denote the  of the circle, and price denote the price of the pizza.
Also, let  denote the price per square inch.
Get radius b.
Get price d.
The following algorithm computes the volume and surface  of the sphere.
The following algorithm computes and outputs the billing amount.
Enter the number of items bought.
Get price iii.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Suppose averageTestScore denotes the average test score, highestScore denotes the highest test score, testScore denotes a test score, sum denotes the sum of all of the test scores, count denotes the number of students in class, and studentName denotes the name of a student.
First, you design an algorithm to find the average test score.
To find the average test score, first you need to count the number of students in the class and add the test score of each student.
You then divide the sum by count to find the average test score.
The algorithm to find the average test score is as follows: i.
Set sum and count to 0.
Repeat the following for each student in class.
Increment count and update the value of sum by adding the current test score to sum.
Use the following formula to find the average test score: = 0; otherwise = sum / count; b.
The following algorithm determines and prints the names of all of the students whose test score is below the average test score.
Repeat the following for each student in class: i.
Get studentName and testScore print studentName c.
The following algorithm determines the highest test score.
Get first student's test score and call it highestTestScore.
Repeat the following for each of the remaining students in class: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Get testScore = testScore; d.
To print the names of all of the students whose test score is the same as the highest test score, compare the test score of each student with the highest test score, and if they are equal, print the name.
The following algorithm accomplishes this.
Repeat the following for each student in class: i.
Get studentName and testScore print studentName You can use the solutions of the subproblems obtained in parts a through d to design the main algorithm as follows: 1.
Use the algorithm in part a to find the average test score.
Use the algorithm in part b to print the names of all of the students whose score is below the average test score.
Use the algorithm in part c to find the highest test score.
Use the algorithm in part d to print the names of all of the students whose test score is the same as the highest test score.
Cplus_plus is case sensitive.
The fifth letter of quizNo1 is uppercase N while the fifth character of quizno1 is lowercase n.
Both the operands of the operator % must be integers.
Because the first operand,  * , is a floating-point value, the expression is invalid.
Both the operands of the operator % must be integers.
Because the second operand, , is a floating-point value, the expression is invalid.
Both the operands of the operator % must be integers.
Because the second operand,  + , is a floating-point value, the expression is invalid.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Input failure: 1 = 28,  = 35, trying to read the.
The values of  and  are unchanged.
The function getline reads until it reaches the end of the current line.
The newline character is also read but not stored in the string variable.
The file contains the output produced by the program.
The file contains the output produced by the program.
The old contents are erased.
The program would prepare the file and store the output in the file.
Amy < Bob -12 ** 9.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Omit the semicolon after else.
The correct statement is: << "You _0_" << endl; else << "You _0_" << endl;.
The correct code is:.
The output is: Discount ¼ 10%.
The semicolon at the end of the  statement terminates the  statement.
So the  statement is not part of the statement.
The  statement will execute regardless of whether the expression in the  statement evaluates to true or false.
The output is: Discount ¼ 10%.
The semicolon at the end of the  statement terminates the  statement.
So the  statement is not part of the statement.
The  statement will execute regardless of whether the expression in the  statement evaluates to true or false.
Replace the while loop statement with the following: Replace the  statement: << endl;.
Loop control variable: The initialization statement:  = 1; Loop condition:  <= 10; Update statement: jplus_plus The statement that updates the value of :  =  +  * ( - 1); 21.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter().
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
In a pretest loop, the loop condition is evaluated before executing the body of the loop.
In a posttest loop, the loop condition is evaluated after executing the body of the loop.
A posttest loop executes at least once, whereas a pretest loop may not execute at all.
In f, the second argument in the function call is missing.
In g and h, the function call requires one more argument.
The function 1 requires 2 actual parameters.
The type and the order of these parameters is: int, double f.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter().
The function computes mk  1, where m and n are the arguments of the function and k ¼ abs(n).
This function computes 1+4+9+16+25+36+49+64+81+100.
In a void function, a return statement is used without any  such as return;.
In a void function, a return statement is used to exit the function early.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
If the input is 10, the output is: 96 6 4 10 24 34 4 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Because there is no  for an anonymous type, you cannot pass an anonymous type as a parameter to a function and a function cannot return an anonymous type value.
Also, values used in one anonymous type can be used in another anonymous type, but variables of those types are treated differently.
The statement in Line 2 should be: using namespace std;.
Heelo Thlre Giamond Dold c.
Regular exercise Regular exercise and low fat diet 33 8 8 health insurance insurance Regular exercise can reduce health insurance $$$$.
This declaration is correct.
Array size must be positive.
A correct answer is: int testScores[10];.
This declaration is correct.
Array size must be a positive integer not a range.
A correct answer is: int list100[100]; Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
This declaration is correct.
The size of score is 50, so the call should be tryMe(score, 50);.
The array gpa is of type double, whereas the parameter x of tryMe is of type int.
So there will be a mismatch data type error.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Invalid; the assignment operator is not defined for C-strings.
Invalid; the relational operators are not defined for C-strings.
Invalid; the assignment operator is not defined for C-strings.
First row of beta: 0 1 2 c.
Second row of beta: 1 2 3 Third row of beta: 2 3 4 First row of beta: 0 0 0 Second row of beta: 0 1 2 Third row of beta: 0 2 4 First row of beta: 0 2 0 Second row of beta: 2 0 2 Third row of beta: 0 2 0 First row of beta: 0 0 0 Second row of beta: 0 1 2 Third row of beta: 0 2 1 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Invalid; the member  of newEmployee is a struct.
There are no aggregate output operations on a struct.
A correct statement is: c.
Invalid; employees is an array.
There are no aggregate assignment operations on arrays.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The type of function print is missing.
Also, a constructor has no type.
The statements in Lines 5 and 6 should be:.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The functions print, getSalary, and getNumOfServiceYears are accessors; functions setData and updateSalary are mutators.
The class temporary has only one constructor.
Because this is a constructor with default parameters, it can be used to initialize an object without specifying any parameters.
For example, the following statement creates the object newObject and its instance variables are initialized to " ", 0, and 0, respectively: temporary newObject 15.
The statement in Line 1 creates object1 and initializes the instance variables of this object to " ", 0, 0, that is, object1_0_description ¼ " ";, object1.
The statement in Line 2 creates object2 and initializes the instance variables of this object as follows: object2_0_description ¼ "rectangle";, object2.
The statement in Line 3 creates object3 and initializes the instance variables of this object as follows: object3_0_description ¼ "circle";, object3.
The statement in Line 4 creates object4 and initializes the instance variables of this object as follows: object4_0_description = "cylinder";, object4.
There are two built-in operations for class objects: Member access (_0_) and (=).
A constructor is a member of a class, and it executes automatically when a class object is instantiated and a call to the constructor is specified in the object declaration.
A constructor is included in a class so that the objects are properly initialized when they are declared.
A destructor is a member of a class, and if it is included in a class, it executes automatically when a class object goes out of scope.
Its main purpose is to deallocate the dynamic memory created by an object.
The statement in Line 3 should be: myClass::printCount();.
The statement in Line 4 is invalid because the member function printX is not a static member of the class, and so cannot be called by using the  of class.
The statement in Line 5 is invalid because  is a private static member variable of the class.
Some of the member variables that can be added to the class employeeType are: department, salary, employeeCategory (such as supervisor and president), and employeeID.
Some of the member functions are: setInfo, setSalary, Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 11 | 1631 getSalary, setDepartment, getDepartment, setCategory, getCategory, setID, and getID.
The base class is computers and the derived class is personalComputers.
This is a public inheritance.
Private members of the object newCylinder are xCoordinate, yCoordinate, radius, and.
Missing : in the  statement.
The  statement should be: class derivedFromTemp: public temp.
First a constructor of class one will execute, then a constructor of class two will execute, and finally a constructor of class three will execute.
It cannot be accessed directly outside of the class.
Also z is a private member of the class superSmart.
It cannot be accessed directly outside of the class.
Valid Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
It cannot be used to call its member function print.
It cannot be used to access its members.
Between the preprocessor directive #ifndef and #endif.
The definitions of the classes one and two can be placed between these directives as follows: #ifndef H_one #define H_one #ifndef H_two.
In a private inheritance, the public members of the base class are private members of the derived class.
The protected members of the base class are private members of the derived class.
The private members of the base class are hidden in the derived class.
They cannot be directly accessed in the derived class.
They can be accessed by the member functions (and friend functions) of the derived class through the public or protected members of the base class.
In a public inheritance, the public members of the base class are public members of the derived class.
They can be directly accessed in the derived class.
The protected members of the base class are protected members of the derived class.
They can be directly accessed by the member functions (and friend functions) of the derived class.
The private members of the base class are hidden in the derived class.
They cannot be directly accessed in the derived class.
They can be accessed by the member functions (and friend functions) of the derived class through the public or protected members of the base class.
The protected members of a base class can be directly accessed by the member functions of the derived class, but they cannot be directly accessed in a program that uses that class.
The public members of a class can be directly accessed by the member functions of any derived class as well as in a program that uses that class.
The members setX, print, , and setY are protected members in class third.
The private member  of class first is hidden in class third, and it can be accessed in class third only through the protected and public members of class first.
Because the memberAccessSpecifier is not specified, it is a private inheritance.
Therefore, all of the members of the class first become private members in class fifth.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
To create a pointer in the variable declaration, operator * is placed between the data type and the variable name.
For example the statement int *p; declares p to be a pointer of type int.
To dereference a pointer in an expression, the operator * is placed to the left of the pointer.
For example, if p is a pointer of type int, the expression  << *p << endl; outputs the data stored in the memory space to which p points.
So the expression *nextPtr, in Line 9, does not have a valid value.
The operator delete deallocates the memory space to which a pointer points.
Because at compile time dynamic arrays have no first and last elements, so the functions begin and end cannot be called on dynamic arrays.
In a shallow copy of data, two or more pointers point to the same memory space.
In a deep copy of data, each pointer has its own copy of the data.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The copy constructor makes a copy of the actual variable.
Classes with pointer data members should include the destructor, overload the assignment operator, and explicitly provide the copy constructor by including it in the class definition and providing its definition.
ClassA x: 4 ClassA x: 6 ClassB y: 10 37.
Because employeeType is an abstract class, you cannot instantiate an object of this class.
Therefore, this statement is illegal.
This statement is legal.
This statement is legal.
A friend function is a nonmember of a class, whereas a member function is a member of a class.
Because the left operand of << is a stream object, which is not of the type mystery.
In Line 3, the return type of the function < should be bool.
The correct statement is: friend bool <(const mystery& a, const mystery& b);.
In Lines 3  11, the return type of the function + should be discover.
Also since + is a friend function of the class, the name of the class  the scope resolution  in the heading of the function, in Line 11, are not needed.
The correct statements are: Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook /or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Chapter 14 | friend discover +(const discover&, const discover&); discover +(const discover& a,.
Suppose that a class, say temp, overloads the pre-  postincrement  plus_plus, tempObj is an object of the class temp.
Then, the statement plus_plustempObj; is compiled as tempObj_0_operatorplus_plus();,  the statement tempObjplus_plus; is compiled as tempObj_0_operatorplus_plus(0);.
The dummy parameter distinguishes between the pre-  post-increment  functions.
Similar conventions for the pre-  post-increment operators.
The answer to this question is available at the Web site accompanying this book.
When the class has pointer data members.
Error in Line 4.
A template instantiation can be for only a built-in type or a userdefined type.
The word "type" between the angular brackets must be replaced either with a built-in type or a user-defined type.
Sunny Day 37.
If an exception is thrown in a try block, the remaining statements in that try block are ignored.
The program searches the catch blocks in the order that they appear after the try block  looks for an appropriate exception handler.
If the type of thrown exception matches the parameter type in one of the catch blocks, the code of that catch block executes,  the remaining catch blocks after this catch block are ignored.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook /or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Also, the try block has no associated catch block, that is, there is no catch block that follows the try block.
The  statement just before the catch block disassociates the catch block from the try block.
The correct code is: double ;.
Leaving the try block.
Current balance: 975 Balance must be greater than 1000_0_00 c.
Current balance: -2000 Balance must be greater than 1000_0_00 15.
Entering the try block.
Exception: Lower limit violation.
After the catch block Entering the try block.
Exception: 0 After the catch block Entering the try block.
Exiting the try block.
After the catch block Entering the try block.
Exception: 0 After the catch block 17.
A throw statement.
A function specifies the exceptions it throws in its heading using the throw clause.
The case in which the solution is defined in terms of smaller versions of itself.
A function that calls another function and eventually results in the original function call is said to be indirectly recursive.
The statements in Lines 2 and 3.
The statements in Lines 4 and 5.
Any nonpositive integer.
It is a valid call.
It is an invalid call.
It will result in infinite recursion.
It is a valid call.
It does not produce any output.
It does not produce any output.
It does not produce any output.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The general case is specified by the option otherwise.
Before deletion, the link field of the third node stores the address of the fourth node.
After deletion, the link field of the third node will store the address of the next node, which is the old fifth node.
If there was no fifth node, then after deletion, the link field will store the value nullptr.
Therefore, after deleting the fourth node, the link field of the third node is changed.
So a pointer to the third node is needed.
After the execution of the statement in Line 5,  is nullptr, so trailarrow_operatorinfo does not exist.
This code will result in a run-time error.
The output of this code is: 43 12 72 8 a.
The function begin returns an iterator to the first node of a linked list.
The function end returns an iterator one past the  node of a linked list.
The item to be deleted is not in the list.
The answer to this question is available at the Web site accompanying this book.
The answer to this question is available at the Web site accompanying this book.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
If the stack is nonempty, the statement stack_0_top(); returns the top element of the stack, and the statement stack_0_pop(); removes the top element of the stack.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The answer to this question is available at the Web site accompanying this book.
The answer to this question is available at the Web site accompanying this book.
Suppose that the list is of  n.
Consider the first of the outer for loop, that is, when the value of  = 1.
Now the inner loop executes  – 1.
Before the execution of the inner for loop, the variable isSorted is set to true, assuming that the list is sorted.
If the list is already sorted, then the expression list[index] > list[index + 1] in the if statement always evaluates to false, so the body of the if statement never executes.
Because the inner loop executes  – 1 times, there are  – 1 comparisons.
In the second  of the outer loop, because the variable isSorted is true, the loop condition, ( < ) && _0_isSorted, evaluates to false, so the outer for loop terminates.
It follows that, if the list is already sorted, the outer for loop executes only once.
Hence, the total number of comparisons is  – 1 = O().
After partitioning, elements in the first sublist are smaller than the pivot and in the second sublist they are larger than the pivot.
The merge sort partitions the list by dividing it into two sublists of nearly equal size by breaking the list in the middle.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The function partition is called 9 times and the number of comparisons to sort the list is 37.
Quick sort: 10000  log2(10000) ¼ 132878; merge sort: 132878.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Thus, there are 2 pointers in all the nodes of the binary tree.
The pointer pointing to the root node is an external pointer.
Each of the remaining 1 nodes has one pointer pointing to it, which is a pointer from the parent node.
The remaining pointers in all the nodes, which is 2 ( 1) =  + 1, are nullptr.
This implies that the binary tree has  + 1 empty subtrees.
Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
The vertices 0 and 9 are connected.
A path from vertex 0 to vertex 9 is 0-4-3-8-9.
The vertices 0 and 5 are not connected.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
A container is used to store data, while an algorithm is used to manipulate the data stored in a container.
An STL function object contains a function that can be treated as a function using the function call operator.
A back_inserter uses the push_back operation of the container, while a front_inserter uses the push_front operation of the container to add elements to the container.
Furthermore, a front_inserter cannot be used for the vector container.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
N o t e : P a g e n u mb e r s i n b o l d fa c e i n d i c a t e k e y t e r m s.
A abacus, 2 abs function, 347, 350–353 absolute value, 211 abstract classes, 860–867 abstract data type (ADT), 680–681, 774 binary search trees, 1369–1379 binary trees, 1359–1367 graphs, 1410–1413 implementing, 681–682 linked lists, 1085–1097, 1106–1117 lists, 681–682, 869 abstraction, 680 acceptAmount function, 705–706 accessor functions, 664–667, 780, 783 accumulate algorithm, 1493 accumulate function, 1546–1551 A class, 763 action statement, 190 actual parameter list, 354 actual parameters, 352 changing value, 384 corresponding to formal parameters, 354, 377 virtual functions, 856 Ada, 774 addFirst function, 395–397 additionalBonus variable, 16 addition compound  (+=), 94–95 addition  (+), 43, 45, 903, 922 overloading, 923–924 add operation, 1216–1217 addQueue function, 1216, 1218, 1220–1221, 1225, 1229–1230, 1232, 1246 addresses, 4–5 address of  (&), 814, 881–883 addressOfX function, 882, 883 addressType struct, 624–625 addVotes function, 1333 adjacency lists, 1409 adjacency matrix, 1408 adjacent, 1407 adjacent_difference function, 1493, 1546–1551 adjacent_find function, 1491, 1493, 1497, 1524–1528 adjacent from, 1407 adjacent to, 1407 A function, 1042 age variable, 66, 141, 197, 210 aggregate operations, 531, 554 Aiken, Howard, 3 algorithm header file, 1455, 1490, 1501, 1505, 1510, 1517, 1520, 1529 algorithms, 11–13, 1442 classifications, 1491 dominant operations, 1277 function overloading, 1493 generic, 1491 heap sort algorithms, 1493 implementing, 21 modifying algorithms, 1492 nonmodifying algorithms, 1491 numeric algorithms, 1492–1493 recursive algorithms, 1041 repetition, 21 subproblems and, 13 aliases, 881–883 allocating memory.
See memory allocation American National Standards Institute (ANSI), 22 American Standard Code for Information Interchange (ASCII), 7, 40–41, 203 amountDue variable, 14–15, 57 analog signals, 6 analytical engine, 2 and (&&) logical , 197–203, 209–210, 213 and  (&), 200 Android, 5 anitaHouse variable, 615 anonymous data types, 475 ANSI/ISO Standard Cplus_plus, 22, 485 namespace mechanism, 81, 485–490 Standard Template Library (STL), 1442–1551 string data type, 53 append function, 494 Apple computer, 3 apple object, 708 application programs, 5 areaAndPerimeter, 378 area function, 689–690, 742–745, 747, 752–753, 910 area variable, 19, 33 arguments, 131, 134 arithmetic expressions, 30, 45 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Index floating-point (decimal) expressions, 48–49 grouping with parentheses (), 46 infix notation, 1201 integral expressions, 48–49 mixed expressions, 48, 49–50 operands, 45 Polish notation, 1201 postfix notation, 1202 prefix notation, 1201 Reverse Polish notation, 1201 arithmetic function objects, 1494 arithmetic operators, 43–45 addition  (+), 43, 45 associativity, 46 division  (/), 43, 45 floating-point data type, 43 integral data type, 43–44 modulus (mod)  (%), 43–45 multiplication operator (*), 43–45 negation operator (-), 43, 45 order of precedence, 46–47, 200 remainder operator (%), 43–45 subtraction operator (-), 43, 45 arithmetic overflow and underflow exceptions, 1010 arrayAsParameter function, 538 array-based lists, 868–875, 972–978 binary search algorithm, 1270 insertion sort, 1292–1297 pivot, 1299–1303 quick sort algorithm, 1298–1306 selection sort, 1290–1292 sequential search, 1267–1269 sequential search algorithm, 877 sublists, 1299 arrayClass class, 932–933 array index operator ([]), overloading, 958–966 arrayListType class, 869–872, 875, 879, 972, 975, 978 as abstract data type (ADT), 972 arrays, 21, 520, 521 accessing components, 523–524 aggregate operations, 531, 554 auto declaration of elements, 549–550 base address, 535–538, 1173 in bounds, 529 circular, 1220–1221 class objects, 658, 677–679 components, 523–524 component-wise copying, 532 constant arrays as formal parameters, 533–535 constructors, 677–679 copying elements between, 531–532, 535 C-strings and, 572–573 declaring, 542 default size, 874, 1222 dynamic, 525, 831–833, 868 elements, 521 implementing queues, 1218–1227 implementing stacks, 1170–1188 index, 523, 527, 535 index out of bounds, 529–530 initializing, 526, 534 initializing during declaration, 530, 552, 1461 integral data types and indexes, 541–542 largest element in, 526–528, 1043–1046 for loops, 22 manipulating lists, 868–875 memory location, 535–538 multidimensional, 574–575 number of components in, 522 one-dimensional, 521 outputting data, 525–526 parallel, 558–559 parameters to functions, 532–533 partial initialization during declaration, 530–531 passed by reference, 532–533 passed by value, 538 pointers to, 840 printing, 526, 534 processing, 525–529, 531–533 random access data structure, 1170 range-based for loops, 834–835 reading data into, 526, 534 searching for specific item, 542–549 selection sort, 545–549 sequential lists, 1072 size, 525, 530–531, 552, 831, 868–869, 872 smallest element in, 528 sorted and unsorted sublists, 1295 sorting, 545–549 static, 831 stepping through with loops, 525–528 strings, 572 struct data type in, 621–623 in structs, 619–621 versus structs, 618 summing elements, 534–535 two-dimensional, 560–574 variables, 524, 824–825 arraySize variable, 525 array subscript operator ([]), 491–492, 523 arrivalTimeEmp array, 677–678 arrivalTime variable, 1235, 1237 artificial intelligence, 3 ASCII.
See American Standard Code for Information ASCII character set, 188, 280, 551 assemblers, 8 assembly languages, 8 assert function, 234–236, 961, 998, 1001–1002, 1094 assert statement, 235, 959 assign function, 1463, 1468 assignment  (=), 43, 58–59, 187, 814, 844, 903, 1172, 1453 associativity, 61, 966 classes, 657–658, 843–844 versus equality relational  (==), 220–221 order of precedence, 200 overloading, 929–937, 974, 1092, 1097, 1179–1180, 1197–1198, 1362, 1366–1367 pointer variables, 829–830 assignment statements, 43, 57–61 assigning value of struct variable, 615–616 compound, 94–95 initializing variables, 66–69 peek function, 137 simple, 94, 95 value-returning functions, 351 associative containers automatically sorted elements, 1479–1480 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Index | binary search trees, 1480 multiset associative container, 1480–1486 set associative container, 1480–1486 associativity, 46, 200 assignment  (=), 61 operators, 904 relational operators, 211–213 asymptotic notation, 1276–1284, 1280 at function, 494, 1445, 1463 Augusta, Ada, Countess of Lovelace, 2 auto declaration and range-based for loops, 549–550 automatic variables, 409–410, 698 a variable, 61, 71–72 averageAndGrade function, 379 average parameter, 379 average variable, 18, 301 AVL trees, 1386 B Babbage, Charles, 2 back, 1215–1216 back function, 1094, 1125–1126, 1216, 1225, 1229–1230, 1445, 1463, 1468, 1488 back_inserter insert iterator, 1500, 1527 back pointer variable, 1122, 1126–1127 backslash escape sequence (\\), 78 backspace escape sequence (\b), 78 bad allocation error message, 1013 bad_alloc exception, 825, 1010–1013 bar graphs, 431–432 base 2, 7 base 10, 7 base cases, 1040–1041 baseClass class, 741, 754 base classes, 739–741, 855, 859–861 constructors, 748–756 copying values of derived class object into, 858 destructors, 757, 859 private members, 748, 750 redefining (overriding) member functions of, 741–748 virtual destructors, 859 baseSalary variable, 16 base 2 system, 1055, 1059 base 10 system, 1055, 1059 Basic, 8 bCh variable, 765–767 B class, 763 bClass class, 764–767 bDay object, 771 begin function, 835, 1094–1095, 1449, 1453, 1456, 1503, 1505 beg iterator, 1444, 1447, 1454, 1462, 1467, 1481 beg pointer, 1444 Bell Laboratories, 22 B function, 1042 bidDirectional bidirectional iterator, 1475–1476 bidirectional iterators, 1475–1476 Big-O notation, 1276–1280, 1281–1284 billingAmount function, 781, 786 binary code, 6 binary digits, 6 binary numbers, 6–7 converting decimal number to, 1059–1062 converting to decimal, 1055–1059 1651 binary  (+), 491–492 binary operators, 45 overloading, 918–924 overloading as member functions, 918–922 overloading as nonmember functions, 922–924 relational operators, 187 binary search, 1269–1276 binary search algorithm, 1269 array-based lists, 1270 divide-and-conquer technique, 1269 key comparisons, 1271, 1274–1275 recursive algorithm, 1271 while loops, 1271, 1274–1275 binarySearch function, 1274 binary_search function, 1491, 1520–1523 binary search trees, 1368 abstract data type (ADT), 1369–1379 analysis, 1378–1379 associative containers, 1480 deleting nodes, 1373–1378 height, 1369 inserting items, 1371 key comparisons, 1378–1379 key in root node, 1369 left subtree, 1368–1369, 1373–1375 right subtree, 1368–1369, 1373–1375 root node, 1368, 1370 search algorithm, 1378–1379 searching, 1370–1371 traversing, 1370–1371 binary system, 7, 1055 binary trees, 1297, 1348 abstract data type (ADT), 1359–1367 binary search trees, 1368–1379 branches, 1348, 1351 breadth-first traversal, 1359 children, 1348, 1350 copying, 1353–1354, 1358, 1366 deleting nodes, 1358 destroying, 1365 directed branch, 1348 directed edge, 1348 empty, 1353 functions as parameters, 1383–1386 height, 1352–1353 implementing, 1359–1367 inorder sequence, 1355 inorder traversal, 1354–1359 leaf, 1351 left child, 1348, 1368 left subtree, 1348, 1349 length of path, 1351 level-by-level traversal, 1359 level of node, 1352 nodes, 1348–1351, 1353 nonrecursive inorder transversal, 1379–1381 nonrecursive postorder traversal, 1382–1383 nonrecursive preorder traversal, 1381–1382 nonrecursive traversal algorithms, 1379–1383 parent, 1348, 1351 paths, 1351 postorder sequence, 1355 postorder traversal, 1355–1359 preorder sequence, 1355 preorder traversal, 1354–1359 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Index right child, 1348, 1368 right subtree, 1348–1349 root node, 1348–1350, 1353 shallow copy of data, 1353 traversal algorithms, 1383–1386 traversing, 1354–1359, 1367 visiting nodes in sorted order, 1358 binaryTreeType class, 1360–1367, 1384–1385 binding, 854 binSearch function, 1275–1276, 1290 binToDec function, 1056–1059 bits, 6 bitWeight variable, 1056–1059 blank space (' '), 40 blanks parameter, 380 blank special symbol, 35 block of statements, 205 blocks, 398, 409 Bloodshed Software, 11 board array, 562, 571, 837, 839 board pointer, 837 *board pointer, 837 body, 351 bool data type, 38–40, 189, 196–197 Boolean alias, 476 bool reserved word, 40, 196 bool variables flag variable, 281–284 logical (Boolean) expressions, 202–203 bottom-up design, 20 boxType class, 744–750, 752–754 brackets, 90 branch control structures, 189–192 branches, 186, 1298, 1348, 1351 breadth-first traversal, 1359 breadth first traversal algorithm, 1414, 1416–1418 breadthFirstTraversal function, 1417–1418 break reserved word, 225 break statement, 226–227, 229–230, 234, 311–313 breed variable, 856 bSearchTreeType class, 1369–1379, 1385–1386 bubble sort, 1284–1290 bubble sort algorithm, 1289–1290 bubbleSort function, 1287–1290 bugs avoiding, 213–217, 232–234 patches, 319–322 build command, 11, 688 buildListBackward function, 1084–1085 buildListForward function, 1083 business function, 369–373 b variable, 61, 71–72 bX variable, 765–766 bytes, 6–7 C C, 8 C#, 8 Cplus_plus, 2, 8, 22, 80, 774 case sensitivity, 36 integrated development environments (IDEs), 10, 11 Cplus_plus11, 22 calBurnedInAWeek variable, 265–266 calBurnedInOneDay variable, 265–266 calculateAverage function, 424–426 calculatePay function, 756, 861 calculateTotalVotes function, 1323 callPrint function, 853–854, 856 candidateList object, 1325–1329, 1331 candidateType class, 1317, 1320–1326, 1332 capacity function, 1446 carDealers multidimensional array, 575 carType enumeration type, 563 case reserved word, 225–226 case sensitivity, 36 case statements, 226–227, 229–231, 234 cashOnHand member variable, 706 cashRegister class, 705–707 cassert header file, 235, 961 cAssignmentOprOverload class, 933–937 casting, 51–53 cast operator, 51–53, 350, 469–470, 500 catch block parameter, 1003 catch blocks, 1002–1006, 1006, 1009, 1011, 1013–1014, 1017, 1022, 1024, 1027 catching exceptions, 1027 Cplus_plus Builder, 11, 688 cctype header file, 348, 350, 1507, 1537 cCustomer object, 1244 ceil function, 347 celsius variable, 158–159 CENTIMETERS_PER_INCH constant, 91 central processing units (CPUs), 4 cExpObject object, 822 cExpPtr pointer, 822–823 cfloat header file, 1425 change variable, 475 character arrays, 551–558, 572 characterCount function, 583, 584 characters, 40–41 arithmetic operations, 46 ASCII values, 280 bytes, 7 char variables, 67 collating sequence, 188–189 comparing, 40 encoding schemes, 7 maximum number ignored in line, 135–136 next available, 137–139 putting last from input stream back, 137–139 reading, 134, 137–139 relative position in strings, 53 storing in memory, 137–139 strings, 53–54 character sets, 40–41 char data type, 38–41, 470–471 arithmetic operations, 46 converting to int data type, 53 extraction operator (>>), 126–130 pointer variables, 813 reading values, 134 relational operators, 188–189 charItr iterator, 1519 charList vector, 1506–1507, 1519, 1537 charList vector list, 1513, 1516 char variables, 67, 584 checkTitle function, 1142 chExp variable, 135 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Index | children, 1350 chips, 3 ch pointer variable, 813 ch variable, 551, 582 cin (common input) statement, 19, 36, 63–66, 79, 80–81, 124–125, 161, 284, 488, 555, 762 extraction operator (>>) and, 125–130 get function, 133–134 ignore function, 135–136 cinget identifier, 139 cin variable, 139, 285 circle class, 739–740, 860 circle object, 1021 circle1 object, 691 circle2 object, 691 circleType class, 689–691, 1019–1021 circular array, 1220–1221 circular linked lists, 1131 circumference function, 689, 690 citySalesTax variable, 14–15 classes, 21, 139, 650, 773 abstract classes, 860–867 abstract data type (ADT), 681–682 address of  (&), 881–883 assignment  (=), 657–658 assignment operators, 843–844 base classes, 739 built-in operations on, 657 class templates, 967, 969–971 clients, 664 components, 650 constructors, 669–671, 675 copy constructor, 845–848, 847–848 declaring variables, 654–655 defining, 650–651, 768–772 derived classes, 738–739 destructors, 679–680, 842–843 examples of, 689–698 exception classes, 1009–1013 formal parameters, 855 friend functions, 912–914 functions, 658–659, 821–823 identifying, 774–775 inheritance, 738–767, 859 instance variables, 664 manipulating sets, 879 member access  (_0_), 657 members, 650 nodes as, 1073 non-static member variables, 700–702 object-oriented design (OOD), 773 object-oriented programming (OOP), 773 pointers, 821–823 pointer variables, 841–852, 944 private members, 651–653, 668–669, 683, 763, 820, 881–882 protected members, 763 public members, 651–653, 668–669, 763 pure virtual functions, 860–861 relating, 738 reusing, 773 static members, 698–704 versus structs, 682–683 Unified Modeling Language (UML) diagrams, 654 virtual destructors, 859 1653 classExample class, 821–823 classifyDigits function, 695–698 classifyNumber function, 418–420 classIllusFriend class, 912 class instances, 654–655 class keyword, 967 class members, 650–651, 655–656, 658 class objects, 654–655, 658–659 arrays, 677–679 initializing, 677 class reserved word, 651 class templates, 967, 969–971 containers, 1443 classTest class, 958–959 clear function, 142–143, 156, 494, 496–497, 1447, 1453–1454, 1483 clearGraph function, 1413 clearList function, 874 clients, 664 C-like casting, 53 cList array, 1506, 1516, 1519 clocks array, 679 clockType abstract data type (ADT), 681 clockType class, 651–653, 655, 657, 659–660, 664–665, 668-670, 675–679, 683–687, 738, 902-903, 905–907, 944–952 clockType_0_h header file, 684, 687 clockType objects, 978 close file stream function, 162–163 cmath header file, 79, 81, 131–133, 211, 347–348, 350, 488, 490 cntItr iterator, 1473 COBOL, 3, 8 code, prewritten, 11 codeOk variable, 578 coins enumeration type, 475 collating sequence, 40, 203 colors enumeration type, 467 colorType enumeration type, 563 column processing, 565 columns variable, 839 commands, 3 commas (,), 35, 90 comments, 31, 34–35 common input, 124 common output, 124 compareCode function, 578–579 compare function, 494 compareThree function, 358–360 comparison-based search algorithms, 1284, 1297 comparison-based sorting algorithms, 1297–1298 comparison tree, 1297–1298 compilers, 9–11 error messages, 13 integral data types, 39 syntax errors, 85–89 compile-time binding, 854 complex numbers, 953–958 complexType class, 953–958 components, 1407 classes, 650 grouping different types, 610–626 composition (aggregation), 738, 767–772, 775–796 compound assignment statements, 94–95 compound statements, 205, 215 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Index compStudent enumeration type, 468 Computer History Museum, 2 computer programs, 28 computers, 3–5 language of, 5–7 machine language, 6 processing programs, 186 software, 5 concatenating strings, 491 conditional expressions, 221 conditional operator (_0_:), 221–222 connected vertices, 1407 constant functions, 665 constants declaring references parameters as, 385 memory allocation, 54–57 named constants, 55–56 const reserved word, 55, 385, 533, 621, 653, 658–659, 780, 783 constructors, 669–671, 966 arguments, 672 arrays, 677–679 automatically executing, 670, 771 base classes, 748–756 containers, 1452 default, 670 default parameters, 675, 753 derived classes, 748–756 formal parameter list, 670 invoking, 671–674 name of, 670 number of arguments, 672 parameters, 670, 675–676 passing arguments to, 771–772 without parameters, 670, 675–676 contactType struct, 624–625 container adapters, 1486–1489 containers, 1442 associative containers, 1479–1489 class templates, 1443 constructor, 1452 copy constructor, 1452 copying elements, 1455–1458 default constructor, 1452 destructor, 1452 filling with elements, 1501–1503 header files, 1489–1490 iterators, 1477–1478, 1489–1490 for loops, 22 member functions, 1452–1453 number of elements in, 1446 operations, 1490 outputting elements of, 1455–1458 pointers, 1456 position of elements, 1449 sequence containers, 1443–1452, 1466–1472 stepping through elements, 1447 continue statement, 311–313 control statements, 206–210 control structures, 21, 186 associativity of relational operators, 211–213 block of statements, 205 bool data type and logical (Boolean) expressions, 196–197 comparing floating-point numbers, 210–211 compound statements, 205 do_0__0__0_while loops, 307–311 if statements, 189–192 int data type and logical (Boolean) expressions, 196 logical expressions, 187–222 for loops, 295–306 multiple selections, 205–208 nested, 278, 314–319 one-way selection, 189–192 relational operators and string data type, 203–204 repetition, 186–187, 264–266 selection, 186–222 switch structures, 225–232 two-way selection, 192–196 while loop, 267–295 conversion constructor, 964 CONVERSION named constant, 55 convertEnum function, 478, 481–482 copiesInStock variable, 1140, 1142 copy algorithm, 1455–1458, 1491–1492 copyArray element, 535 copy_backward algorithm, 1492 copy constructor, 845–848, 875 containers, 1452 overloading, 1362 copy function, 1455–1458, 1499–1500 copyList function, 1092, 1095–1096, 1123 copyStack function, 1172, 1178 copyText function, 583–584 copyTree function, 1354, 1365–1366 cos function, 347 cost member variable, 709 costOfOneBox variable, 274, 277 counted for loops, 295 counter-controlled while loops, 272–275, 316 counter variable, 43, 272, 274–275, 293, 304, 317, 380, 998 count function, 1491, 1521, 1531–1535 count_if function, 1491, 1531–1535 count variable, 70, 290, 398, 699–700, 703, 998, 1086, 1099, 1101, 1108–1110, 1123, 1128, 1222, 1224–1225 course enumeration type, 470 courseGrade array, 558–559 courseGrade function, 362–363 courseGrade variable, 474, 614, 617 courseScore parameter, 386–388 coursesEnrolled array, 783, 787 courses enumeration type, 473–474 courseType class, 650–651, 777–780, 783, 786–787 cout (common output) statement, 31, 72–81, 124–125, 138, 161, 488, 556, 762, 1457 debugging, 157–160 setprecision manipulator, 145 switch statement and break statement, 234 cout variable, 139 _0_cpp extension, 9, 82, 684 Cplus_plus programs See also programs creation, 81–85 expressions, 30 functions, 31–32, 34, 81 header files, 80–82 main function, 31–32, 34 multiple-line comments (/* */), 35 output statements, 29, 30–31 preprocessor directives, 82 processing, 9–11 single-line comments (//), 31, 34–35 subprograms, 34 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Index | createDVDList function, 1145 createGraph function, 1412–1413 createSpanningGraph function, 1431 createWeightedGraph function, 1419–1420 creditCardBalance variable, 191 cScore formal parameter, 387 cstddef header file, 823 cstlib header file, 282 c_str function, 557 cstring header file, 552–553, 960 C-strings, 551–558, 572, 960–966 aggregate operations, 554 arrays of strings and, 572–573 character arrays, 551 comparing, 552–553 copying, 552 double quotation marks (""), 554–555 functions, 552–553 length, 552, 554 null terminated, 551, 554 output, 556 reading, 555–556 storing in memory, 551 C-structs, 683 ct container, 1452–1453 ctime header file, 282 curly braces ({ }), 90 currentCustomer variable, 1238 current parameter, 1143 current pointer, 1074–1076, 1108–1109, 1111, 1113, 1122, 1129, 1141–1142, 1212–1214, 1308, 1370–1371, 1371 current variable, 292–293 customerNumber variable, 1235, 1237 customers, 1234–1238, 1246 customerType class, 1145, 1235–1238 c variable, 61 cycle, 1407, 1408 cylinders, 774–775 cylinderType class, 774–775 D dangling, 827 pointers, 841 data First In First Out (FIFO), 1442 fixed, 55–56 Last In First Out (LIFO), 1442 list form, 559 manipulating, 21, 38, 81, 124 member-wise copying, 844, 847 modifying, 56–57 nodes, 1072 operations on, 681 retrieving, 124 shallow copy, 844–847 table form, 559–560 writing to output stream, 1474–1475 data abstraction, 680 dataTypeName, 51 data types, 38–42 anonymous, 475 bool data type, 38–40 1655 char data type, 38–40 comparing values, 189 conversion, 51–53 defining, 611 domains, 812 double data type, 41–42 enumeration types, 38, 466–475 explicit type conversion, 51–53 float data type, 41–42 floating-point data type, 38, 41–42 formal parameter list, 377 implicit type conversion, 51 int data type, 38–40 integral, 38–41 long data type, 38 long double data type, 41 long long data type, 22, 38–39 names, 812 operators, 904 parameters, 351 short data type, 38 simple data types, 38–41, 57, 520 string data type, 53–54 structured, 520 synonyms or aliases, 475–476 unsigned char data type, 38 unsigned int data type, 38 unsigned long data type, 38 unsigned long long data type, 38 unsigned short data type, 38 user-defined, 38, 466–475 value-returning functions, 353 variables, 42–43, 61, 468 dateType class, 768–770 dateType struct, 624 _0_dat extension, 162 dA variable, 766 DBL_MAX constant, 1425 dClass class, 765–767 dDay variable, 769–770 debugging cout statements, 157–160 drivers, 411–413 logic errors, 157–160 loops, 322 software patches, 319–322 stubbs, 412–413 syntax errors, 85–88 decimal alias, 476 decimal data type, 42 decimal numbers, 38, 41–42 converting binary number to, 1055–1059 converting to binary number, 1059–1062 decimal point and trailing zeros, 146–149 precision, 42 decimalNumber variable, 1056–1059 decimal reference parameter, 1056–1059 decimal system, 7, 1055 decision making, 190, 267 if statements, 220 programs, 21 declaration statements, 83 declarative statements, 82 decreaseTransactionTime function, 1241 decrement operator (minus_minus), 70–72, 830, 832–833 overloading, 937–938 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Index decToBin function, 1060–1062 deep copy, 841 versus shallow copy, 839–841 default constructor, 670, 675–676 automatically providing, 676 containers, 1452 invoking, 671–672 default parameters, 415–417, 675 default reserved word, 225 #define NDEBUG preprocessor statement, 236 #define statement, 759 definition, 352 deleteFromTree function, 1375–1377 deleteItem item, 1377 deleteNode function, 1092, 1097, 1100–1106, 1113–1114, 1130–1131, 1362, 1377–1378 delete operation, 1216–1217 delete operator, 825–827, 829, 842, 1092, 1365 deleteQueue function, 1216, 1218–1219, 1221, 1225–1226, 1229–1232, 1246 denominator variable, 235 departureTimeEmp array, 677, 679 depth first traversal algorithm, 1414–1416 depthFirstTraversal function, 1416 deq deque container, 1462 deqIt iterator, 1466 deque class, 1462 deque containers and bidirectional iterators, 1476 deque header file, 1462 deque objects, 1462 deque sequence container, 1454, 1462–1466 dereferencing operator (*), 815, 1087, 1449, 1478 iterators, 1473 precedence, 820–821 derivedClass class, 741, 754 derived classes, 738–739, 859, 860–861 actual parameter to formal parameter, 856 base class, 763 constructors, 748–756 copying values into base class object, 858 destructors, 757–758, 859 formal parameter of base class, 852–853 functions, 859–860 header files, 757–758 member variables, 741, 754 private members, 740 private member variables, 748 protected members, 764–767 public member function, 745, 746 public members of base class, 740 redefining (overriding) member functions of base class, 741–748 destFirst iterator, 1524 destination, 1405 destroy function, 1123, 1365–1365 destroyList function, 846, 848, 1092–1093, 1096 destroyTree function, 1365–1366 destructors, 679–680, 842–843 base classes, 757 containers, 1452 derived classes, 757–758 naming, 679 overloading, 1362 DevCplus_plus IDE, 11 dftAtVertex function, 1416 dft function, 1415 die class, 691–693 die default constructor, 691–692 difference engine, 2 digital signals, 6 digraph, 1405 dimensions, 774–775 directed branch, 1348 directed edge, 1348 directed graphs, 1405–1410 directly recursive functions, 1042 discardExp function, 1204, 1208 Discrete Mathematics: Theory and Applications (Malik and Sen), 322, 1405 discriminant, 257 dispenserType class, 707–709 displayMenu function, 1145 displayResults function, 478, 482 displayRules function, 478–479 divByZero class, 1014–1015 divByZeroObj parameter, 1017 divideList function, 1309–1310, 1312–1313 dividend variable, 1000, 1006, 1009 divides function object, 1494 division by zero, 234–236 divisionByZero class, 1016–1017, 1022 divisionByZero exception, 1024 division by zero exception, 998, 999–1002, 1005–1009 division compound  (/=), 94–95 division  (/), 43, 45, 903 divisor, 309 divisor variable, 999–1002, 1006, 1009, 1017, 1024 dMonth variable, 769–770 documenting programs, 92 doDivision function, 1018, 1024 dog object, 854, 856–859 dogType class, 853, 855–858 dogType_0_h header file, 855, 857 domains, 681, 812 do reserved word, 307 doSomething function, 550 dot notation, 139 dot  (_0_), 820–821 double data type, 41–42, 56, 126–130, 355, 542 doubleDimensions function, 908 double-ended queues, 1462–1466 doubleFirst function, 395–397 doubleList function, 1459 doubleNum function, 1537 double precision, 42 double quotation escape sequence (\"), 78 doublyLinkedList class, 1120–1131 doubly linked lists back pointer, 1120 deleting nodes, 1123, 1128–1131 empty state, 1123 first element, 1125–1126 initializing, 1124 inserting nodes, 1126–1128 last element, 1125–1126 length, 1124 list sequence container, 1466 pointers, 1120, 1122 printing, 1124 reverse order printing, 1124–1125 searching, 1125 traversing, 1120 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Index | do_0__0__0_while loops, 307–311, 313, 364, 408, 1027, 1054, 1296 draw function, 860 drivers, 411–413 drivingCode variable, 220–221 dummyClass class, 676 dummyExceptionClass class, 1013 dummy parameter, 939 d variable, 61 dvdBinaryTree class, 1390–1392 dvdCheckIn function, 1391 dvdCheckOut function, 1391 dvdCheckTitle function, 1391 dvdListType class, 1138–1140, 1143–1145, 1148–1151 dvdPrintTitle function, 1392 dvdSearch function, 1391 dvdSetCopiesInStock function, 1391 dvdTitle variable, 1140 dvdType class, 1133–1135, 1141, 1148–1151, 1387–1390 dvdUpdateInStock function, 1391 dYear variable, 769–770 dynamic arrays, 525, 831–833, 868 accessing components, 832 deallocating, 842 deque sequence container, 1462 list pointer variable pointing to, 834 new , 831 range-based for loops, 834–835, 1459 two-dimensional, 836–839 vector sequence container, 1443 dynamic binding, 854 dynamic memory, 757 dynamic two-dimensional arrays, 836–839 dynamic variables, 824–827 E early binding, 854 EBCDIC.
See Extended Binary-Coded Decimal Interchange edges, 1405–1407 edges array, 1430 edgeWeights array, 1430 Eiffel, 774 electrical signals, 6 Electronic Numerical Integrator and Calculator (ENIAC), 3 elem element, 1524 elements auto declaration, 549–550 copying between arrays, 531–532 largest, 526–528 returning values, 1474 smallest, 528 sum of, 550 elemNext element, 1524 elemType parameter, 971, 1384 ellipse class, 860 else reserved word, 193 pairing with if statements, 206–208, 216 else statements, 195, 280 employee_0_dat file, 622 employees array, 621–622, 626 employeeType class, 861–862 employeeType struct data type, 621, 623–626 empty function, 494–497, 1446, 1452, 1486, 1488 1657 empty strings, 53 encapsulation, 773, 902 encoding schemes, 7 end function, 835, 1094–1095, 1449, 1453, 1456, 1503 #endif statement, 759 end iterator, 1444, 1447, 1454, 1462, 1467, 1481 endl keyword, 30–31, 488 endl manipulator, 72, 75, 144, 156 end-of-file (EOF)-controlled while loops, 284–290 end pointer, 1444 enumeration types, 38, 466, 477 arithmetic operations, 469 cast , 469–470 declaring variables, 468, 474–475 identifiers, 466–467 illegal, 467–468 increment and decrement operations, 469 indexes, 542 input/output (I/O), 470–472 legal, 468 loops, 470 operations on, 469 as parameter to functions, 473–474 relational operators, 469–470 two-dimensional arrays, 563–566 enumerators, 467 enum reserved word, 467 EOF-controlled while loops, 317–318 eof function, 285–290 equal algorithm, 1491 equal_range algorithm, 1491 equalTime function, 652–656, 660, 662–665, 686, 905 equal_to function object, 1496 equal to  (==), 187, 830, 905–907, 1453, 1487–1488 versus assignment  (=), 220–221 overloading, 923–924 erase function, 494–497, 1447, 1453–1454, 1483 error messages compilers, 13 user-defined exception classes, 1015 error variable, 150–151 escape character (\), 73, 162 escape sequences, 78–79 evaluateExpression function, 1204–1205, 1208 evaluateOpr function, 1204, 1206–1208 evens variable, 304–305, 418–419 exabytes (EB), 6 example function, 534–535 exception class, 1009–1010 exception classes, 1009–1013 user-defined, 1013–1021 exception handling division by zero exception, 999–1002 exception classes, 1009–1013 fixing error and continuing, 1026–1027 logging error and continuing, 1027–1028 mechanisms, 1002–1009 stack unwinding, 1028–1031 terminating program, 1026 try/catch blocks, 1002–1009 user-defined exception classes, 1013–1021 exceptions, 998 catching, 1027 division by zero, 999–1002 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Index logging, 1027–1028 processing thrown in function calling environment, 1029–1031 propagating, 1028–1029 throwing, 1003–1004, 1013–1021 throwing and rethrowing, 1022–1025 executable code, 82, 687–688 executable statements, 82–83 _0_exe file extension, 82 exit function, 1206 expert systems, 3 exp function, 347 explicit type conversion, 51–53 expN namespace, 490 expressions, 30 assigning value to variable, 61 columns exceeding required columns, 151–153 if statements, 220 left-justifying output, 154–155 outputting value in columns, 149–153 precedence, 202 right-justifying output, 151–152, 154–155 saving value of, 53, 61–62 switch statement, 225–227, 230 true or false, 187 while loops, 267, 269, 271, 290–291 extClockType class, 738 Extended Binary-Coded Decimal Interchange Code (EBCDIC), 7, 40, 551 external variables, 401 extern reserved word, 401 extraction  (>>), 63–66, 133–134, 156–157, 161, 284, 318, 555, 762, 903 binary, 125 char data type, 126–130 cin (common input) statement, 125–130 double data type, 126–130 file stream variables, 162 int data type, 126–130 newline character, 130, 134 operands, 125 overloading, 924, 926–929 reading multiple data items, 126 white spaces, 130, 156 F fabs function, 211, 347 fact function, 1041–1042, 1042 factorization function, 760 fahrenheit variable, 158–159 FALSE named constant, 476 false reserved word, 40, 196 feetAndInchesToMetersAndCent function, 406–408 feet variable, 64, 66 fenceCostPerFoot variable, 752 fertilizerCostPerSquareFoot variable, 752 Fibonacci number, 291–295, 366–368, 1047–1050 Fibonacci sequence, 291–292, 366 file I/O (input/output), 160–163 files, 160 appending, 164 closing, 162–163 end of, 284–290 opening, 161, 163 reading data from, 162 file stream variables, 161–163 fileStreamVariable variable, 161 fillArray function, 534 fill function, 156, 839, 1492, 1501–1503 fillNames function, 1327 fill_n function, 1492, 1501–1503 find_end function, 1491, 1507–510 find_first_of function, 495, 1491, 1507–1510 find function, 495, 498–500, 1490–1491, 1505–1507 find_if function, 1491, 1505–1507 finishedSquareFootage member, 611 first, 1072 first formal parameter, 395, 1304 First In First Out (FIFO), 1234, 1442 queues, 1215 first iterator, 1517 first member, 626 firstName variable, 65–66, 613, 1317 firstNum variable, 85, 350 firstOutOfOrder index, 1295, 1296 first1 parameter, 1455–1456 first2 parameter, 1455–1456 first1 pointer, 1310–1311 first2 pointer, 1310–1311 first pointer variable, 840–841, 1084, 1086, 1092–1093, 1096, 1099–1101, 1103, 1108–1109, 1113, 1123, 1126, 1128, 1131, 1232, 1313 first125000PrimeNum function, 760 firstRect variable, 924 first variable, 58, 62–63, 395, 1081–1082, 1091–1092, 1270–1273, 1290 fixed data, 55–56 fixed decimal format, 145–146, 194 fixed manipulator, 145–146, 147–149, 156, 371 flag-controlled while loops, 281–284, 290 flag variable, 281–284, 476 float data type, 41–42, 56 floating-point data type, 38, 41–43 floating-point (decimal) expressions, 48–49 floating-point notation, 41 floating-point numbers, 49 absolute value, 211 comparing for equality, 210–211 converting to integer, 51–52 decimal point and trailing zeros, 146–149 default type, 56, 145 division operator (/), 903 double data type, 42, 56 fixed decimal format, 145–147, 194 formatting, 144–145 precision, 144–145 scientific notation, 144–146 floor function, 347–348 for_each function, 1491, 1535–1537 foreignLanguages variable, 475 for indexed variable, 296 for loop control, 296 for loops, 22, 305, 316, 380, 527–528, 839, 1012, 1054, 1296, 1300, 1415, 1448–1449, 1451, 1456 auto declaration of elements, 549–550 body, 296 break statement, 311 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Index | component-wise copying, 532 continue statement, 313 counted, 295 counter, 303 counting backward, 299 immediately exiting, 311–312 indexed, 295 infinite, 298, 300 initializing array components, 832 initial statement, 296–298 inputting data, 567 largest element, 568 loop condition, 296–298, 300, 308 loop control variables (LCV), 299 nesting, 314–315, 1289 range-based, 550, 834–835, 1458–1461 scope of identifier, 398 simple or compound statements, 297 sorting lists, 547 stepping through array elements, 525–528 terminating, 300 two-dimensional arrays, 565–566 update statement, 296–298, 313 versus while loops, 301–302 formal parameter lists, 353–354, 413, 414 and&, 384 constructors, 670 data types, 377 formal parameters, 352, 834 actual parameters, 354, 377, 620 base address passed to, 537–538 base class objects, 852–853 changing value of, 659 constant arrays as, 533–535 const reserved word, 533 memory allocation, 388 as pointer, 852–853, 855–856 range-based for loops and, 1459 reference parameter, 378, 836, 852–853, 856 value parameter, 378, 856–857 virtual functions, 856 void functions, 376 formatting flags, 762 FORTRAN, 3, 8 forwardIterator forward iterator, 1475 forward iterators, 1475 forwardItr iterator, 1510 found parameter, 1140, 1143 fParamFunc1 function, 1384 free tree, 1427 friend functions, 912 extraction operator (>>), 915 insertion operator (<<), 915 operator functions as, 915–917 operator overloading, 943–944 pre-increment operator (plus_plusu), 939 friend reserved word, 912 front, 1215–1216 front function, 1094, 1125–1126, 1216, 1225, 1229–1230, 1445, 1463, 1488 front_inserter insert iterator, 1500 fstream class, 762 fstream header file, 160–161, 762–763 fullTimeEmployee class, 861–865 funcA function, 374 1659 funcArrayAsParam function, 533 funcB function, 374 funcExp function, 416 func parameter, 1535 functionABC function, 414 functionA function, 1030 functional header file, 1482 functionB function, 1030–1031 function call, 131, 357, 374 functionC function, 1030–1031 function header, 351 function objects, 1493, 1494–1499 arithmetic, 1494 logical, 1499 predicates, 1499 relational, 1496–1499 function overloading, 413–415, 966–969 algorithms, 1493 function prototypes, 358–360, 374, 416, 651, 659 functions, 21, 31–32, 34, 81, 186, 346 arguments, 131, 134 arrays as parameters to, 532–533 body, 351 calling, 353–354 classes and, 658 class members, 650–651 class templates, 971 constructors, 669–671 C-strings, 552–553 default parameters, 415–417 definition, 352, 659, 684 depending on another function, 411–413 derived classes, 859–860 destructors, 679–680 directly recursive, 1042 empty, 860 enumeration types parameter to, 473–474 exceptions thrown by, 1022 formal parameter lists, 354, 413–414 formal parameters, 352, 834 function templates, 967 global identifier access, 398 header files, 131 heading, 351, 352, 414 identifiers, 373 illegal arguments, 1010 immediately exiting, 218–219 inability to nest, 398 indirectly recursive, 1042 infinite recursion, 1042–1043 I/O, 347 istream (input stream) data type, 130 local variables, 388 mathematical, 347 names, 398, 413 overloaded operators, 903 overloading, 773–774 parameters, 131, 134, 347, 1383–1386 passing by reference, 388 pointers, 836, 1383 pointer variables, 836 predefined, 34, 131–140, 346–350 processing thrown exceptions, 1029–1031 pure virtual functions, 860–861 recursive, 1041–1042 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Index returning multiple values from, 384 reusing, 350 run-time binding, 860 search algorithm growth rate, 1278–1281 signatures, 414 stacks implementing calls, 1166 stack unwinding, 1028–1031 standard, 34 static, 698–704 string data type, 494–503 structured programming, 773 struct variables and, 617–618 tail recursive functions, 1042 testing, 411–413 throwing and rethrowing exceptions, 1022–1025 two-dimensional arrays as parameters, 568–571 user-defined, 350–351 value-returning, 351–375 virtual, 860 void functions, 351, 376–382 writing other functions with, 358 functionSeven function, 413 functionSix function, 413 function stub, 412–413 function templates, 902, 967–969, 971, 974, 976 function type, 347 functionXYZ function, 414 funcValueParam function, 383–384 funExample function, 401 funOne function, 390–393, 403 funTwo function, 392–393 G gameCount variable, 478 gameResult function, 478, 480–481 gamewinner variable, 478 general cases, 1040 generate function, 1492, 1503–1505 generate_n function, 1492, 1503–1505 generic algorithms, 1491 gen function, 1503 getArrivalTime function, 1238 getCost function, 707, 709 getCourseName function, 778, 780 getCourseNumber function, 778, 780 getCredits function, 777, 780, 786 getCurrentBalance function, 705, 706 getCurrentCustomerArrivalTime function, 1241 getCurrentCustomerNumber function, 1241 getCurrentCustomerTransactionTime function, 1241 getCurrentCustomerWaitingTime function, 1241 getCustomerNumber function, 1238 getData function, 631–633 getDay function, 768–769 getEvensCount function, 695–698 getFirstName function, 694–695, 1317 getFreeServerID function, 1243–1244 get function, 130, 133–134, 137–139, 156, 161, 318, 555, 582, 762 getGpa function, 781, 787 getHeight function, 744, 747 getHoursEnrolled function, 781, 786 getLastName function, 694–695, 1317 getLength function, 742–743, 747, 910 getline function, 156–157, 318, 556 getMonth function, 768–769 getNoOfItems function, 707–708 getNumber function, 418–420, 422 getNumberOfBusyServers function, 1244 getNum function, 691–692, 695–698 getOddsCount function, 696–698 getRadius function, 689, 690 getRemainingTransactionTime function, 1241 getScore function, 385–388 getStudentData function, 789–790 getTime function, 652–653, 660–661, 664–665, 685, 949 getTotalVotes function, 1323 getTransactionTime function, 1238, 1241 getWaitingTime function, 1238 getWidth function, 742–743, 747, 910 getYear function, 768, 770 getZerosCount function, 696–698 gigabytes (GB), 6 global identifiers, 397–398 header files, 485 iostream header file, 488–489 global named constants, 403 global positioning satellites (GPS), 3 globalType namespace, 486–487 global variables, 401–403 memory allocation, 409 scope resolution operator (::), 401 static variables, 409 struct variables, 612 gpa component, 820–821 gpa variable, 153 grade enumeration type, 474 grade parameter, 379 grade variable, 18, 43, 227, 232, 290 graphics and binary trees, 1359 graphIt iterator, 1415 graph pointer, 1415 graphs, 1405 abstract data type (ADT), 1410–1413 adjacency lists, 1409–1410 adjacency matrix, 1408 applications, 1418 breadth first traversal algorithm, 1414, 1416–1418 cycle, 1407–1408 definitions, 1405–1408 depth first traversal algorithm, 1414–1416 destination, 1405 directed, 1405–1408 edges, 1405–1406 empty, 1411, 1413 free tree, 1427 minimal spanning tree, 1427–1433 notations, 1405–1408 operations on, 1409–1410 origin of edge, 1405 paths, 1407 printing, 1413 representations, 1408–1409 rooted tree, 1427 shortest path, 1418–1426 simple graphs, 1407 source vertex, 1428 spanning tree, 1427 strongly connected, 1407 subgraphs, 1405 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Index | traversing, 1414–1418 undirected, 1405–1407 vertices, 1405–1406, 1410 weight, 1418 weighted graphs, 1418 weighted tree, 1427 weight of the path, 1418 graph theory, 1404–1405, 1418 graphType class, 1410–1413, 1419 greater_equal function object, 1496 greater function, 1482, 1496 greater than  (>), 187 greater than or equal to  (>=), 187, 903 greedy algorithm, 1418 guess variable, 17, 284 H Hamblin, Charles, 1201 hand-held devices, 3 hardware, 4–5 Harvard University, 3 "has-a" relationship, 738, 767–772 head, 1072 header files, 80–82, 131, 684–686, 1489–1490 class templates, 971 derived classes, 757–758 functions, 131 global identifiers, 485 _0_h extension, 684 multiple inclusions of, 758–761 ordered linked lists, 1114–1115 predefined functions, 348, 350–351 system-provided, 684, 757 unordered linked lists, 1105–1106 user-defined, 684, 757 heading, 351–352 head pointer, 1074, 1076 heap sort algorithms, 1493 height binary search trees, 1369 binary trees, 1352–1353 subtrees, 1353 height function, 1353, 1364 height variable, 141, 148–149, 197, 746, 749–750, 752 _0_h extension, 684 high-level languages, 8–10 Hollerith, Herman, 2–3 horizontal tab character (\t), 41 hours variable, 150–151, 193–194, 235 hoursWorked variable, 126 houseType struct, 611–612, 614–615 hr variable, 651–654, 656–657, 660, 663–664, 671, 675, 677–678, 902, 950 H_test preprocessor identifier, 759 I IBM, 3 identifiers, 36–37, 80, 85 blanks in, 90 blocks, 398 cmath header file, 490 declaring before using, 57, 83 1661 enumeration data types, 466–467 functions, 373 global, 397 iomanip header file, 490 iostream header file, 490 legal and illegal, 37 local, 397 named constants, 55, 91 naming, 90–91 predefined, 36 rules to access, 397–399 run-together words, 91 scope of, 397–401 self-documenting, 91 std namespace, 80 switch structure, 226 undeclared, 358 user-defined, 36 #ifdef statement, 759 if_0__0__0_else statements, 189, 192–196, 206, 225, 232, 388 comparing with if statements, 208–209 compound statements, 205 conditional  (_0_:), 221–222 expressions and semicolon (;), 224 incorrect, 215 logical expressions, 193 nesting, 206, 278 range of values, 232 if reserved word, 190, 193 if statements, 189–192, 225, 280, 931, 1118, 1289, 1291 comparing with if_0__0__0_else statements, 208–209 compound statements, 205 decision maker, 220 ending, 195 exceptions, 998 expressions, 220 input failure, 217–219 input variables, 217 logical errors, 195 and (&&) logical operator, 213 nested, 205–208 one-way selection, 215 pairing else with, 206–208, 216 problems with expression in, 212–213 semantic errors, 192, 195–196 ifstream class, 763 ifstream data type, 160, 762 ifstream variables, 161, 290, 388 ignore function, 130, 135–136, 139, 156, 161, 762 illusObject1 object, 700–704 illusObject2 object, 700–704 illustrate class, 699, 703–704 immediate successors, 1410 implementation files, 684–686 class templates, 971 object code, 684 implicit type conversion, 51, 69 in bounds, 529 inches variable, 64, 66 incident, 1407 #include preprocessor directive, 80–81, 124 includes function, 1491, 1538–1546 include statement, 684 incrementHours function, 652–654, 662, 664, 685–686 incrementMinutes function, 652–654, 662, 664, 685 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Index increment operator (plus_plus), 70–72, 830, 832–833, 902, 1087 iterators, 1473 overloading, 937–938 post-increment operator (uplus_plus), 937, 939–943 pre-increment operator (plus_plusu), 937–939 incrementSeconds function, 652–654, 660, 662, 664, 685 incrementWaitingTime function, 1238 incrementY function, 699–700, 703–704 inData variable, 161 indentation, 222 nested if statements, 206–208 indexed for loops, 295 indexes, 523, 527 enumeration type, 542 integral data types, 541–542 out of bounds, 529–530 two-dimensional arrays, 561–566 indexLargestElement function, 535, 538 index variable, 527, 1301, 1303 indirection operator (*), 815 indirectly recursive functions, 1042 infile stream variable, 316–318, 558, 582, 622, 789 inFile variable, 290 infile variable, 217–218, 286 infinite loops, 267, 270 for loops, 300 infinite recursion, 1042–1043 infix expressions, 1201–1202 infix notation, 1201 info component, 1074, 1094–1095, 1098, 1103–1104, 1107–1108, 1110, 1118, 1129, 1211–1212, 1310, 1351 information hiding, 683–687 inheritance, 738–767, 773, 775–796, 859 multiple, 739 private members, 739–740, 763–764 protected members, 763–764 public members, 740, 763–764 single, 739 stream classes, 762–763 initializeArray function, 534 initialize function, 418, 420, 533, 574, 583, 630 initializeList function, 1093, 1124, 1200, 1232 initializeQueue function, 1216, 1222, 1224, 1229, 1232 initializeStack function, 1168, 1173–1174, 1192, 1200 initializing variables, 58 init parameter, 1547 inner_product function, 1493, 1546–1551 inorder function, 1358, 1362, 1364, 1384 inorder sequence, 1355 inorderTitle function, 1392 inorder transversal nonrecursive algorithm, 1379–1381 inorderTraversal function, 1362–1363, 1384, 1386 inplace_merge function, 1492, 1524–1528 inpStr object, 1009 input discarding portion of, 135–136 strings, 554–556 input devices, 5, 160–163 input failure, 130, 140–143 if statements, 217–219 input files extensions, 162 nonexistent, 217, 998 reading beyond end of, 217 specifying at execution time, 557 input file stream, 160 inputIterator input iterator, 1474 input/output (I/O), 79, 85, 762 enumeration types, 470–472 files, 160–163 prewritten operations, 124 streams, 124 string data type, 156–157, 557–558 input/output (I/O) functions, 139 input (read) statement, 63–66 input streams, 124, 137–139 fail state, 140–143, 217, 285 next available character, 137–139 opening nonexistent input file, 217–218 reading invalid data, 217 restoring to working state, 142–143 input stream variables, 125 if statements, 217 inputting strings, 556 reading string into variables, 156–157 returning true or false, 285 returning value, 284–285 insertAt function, 872, 875–876, 879 insertEnd function, 872, 875–876, 879, 975, 978, 1327 inserter insert iterator, 1500 insertFirst function, 1092, 1097, 1099–1100, 1106, 1112–1113, 1200, 1232 insert function, 495, 500–501, 872, 875, 879–880, 971, 1106, 1111–1112, 1117, 1127–1128, 1362, 1371–1373, 1447, 1449–1450, 1453–1454, 1482 insertion operator (<<), 32, 59, 72, 161, 556, 762, 902–903 associativity, 926 file stream variables, 162 friend functions, 915 overloading, 924–929 setprecision manipulator, 145 syntax error, 87 insertion point, 72–76 insertion sort, 1292 analysis, 1296–1297 array-based lists, 1292–1297 average case behavior, 1297 key comparisons, 1292, 1296 insertionSort function, 1296 insertItem item, 1371 insert iterators, 1500–1501 insertLast function, 1092, 1097, 1099, 1106, 1112–1113 insertNode function, 1113 instance variables, 664 inStock array, 563–564 intArray array, 1455–1456 intConstVecIt iterator, 1478 int data type, 38–40, 681, 812 converting to char data type, 53 extraction operator (>>), 126–130 logical (Boolean) expressions, 196 pointer variables, 813 intDeq deque container, 1465–1466 integer alias, 476 integerManipulation class, 695–698, 759–760 integers, 38–40, 49 converting floating-point numbers to, 51–52 division operator (/), 903 larger of two, 223 relational operators, 187–188 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Index | integral data types, 38–41 arithmetic operators, 43–45 array indices, 541–542 integral expressions, 48–49 integrated circuits, 3 integrated development environments (IDEs), 10, 11 resources provided by, 82 _0_txt file creation, 162 interestRate variable, 43 interface files, 684 International Organization for Standardization (ISO), 22 intersection, 1405 intExp variable, 135 intGtIt iterator, 1485 intItr iteration, 1497, 1528 intList array, 1274, 1288, 1523, 1527 intList list, 971 intList1 list container, 1472, 1473 intList2 list container, 1472, 1473 intList3 list container, 1472, 1473 intList4 list container, 1472 intList object, 970 intList1 object, 936–937 intList2 object, 936–937 intList3 object, 936–937 intList struct variable, 619 intList vector, 1517, 1520 intList vector container, 1445, 1449, 1451, 1452, 1459, 1513 intList vector object, 1448, 1461 int pointer, 812 int reserved word, 92 intSetA set associative container, 1485 intSet set associative container, 1482, 1485 int variables logical (Boolean) expressions, 202–203 memory allocation, 830 intVecIter iterator, 1448–1450 invalid_argument class, 1010 invalid string position error message, 1011 inventory class, 673–674 I/O functions, 347 iomanip header file, 81, 145, 148–149, 152, 156, 490 ios class, 762 iostream class, 762 iostream header file, 79–80, 85, 124–125, 156, 160, 347, 757, 762 global identifiers, 488–489 identifiers, 490 I/O stream variables, 139 "is-a relationship," 738–767 isDVDAvailable function, 1391 isEmpty function, 872, 1363, 1411–1412 isEmptyList function, 1092, 1123, 1200, 1232 isEmptyQueue function, 1216, 1229, 1232, 1246 isEmptyStack function, 1168, 1174, 1191–1192, 1200 isFound variable, 281 isFree function, 1240 isFull function, 872 isFullQueue function, 1216, 1229, 1246 isFullStack function, 1168, 1174, 1190–1192, 1200 isFull variable, 281 isGuessed variable, 282, 284 isIdentifier identifier, 1479 isItemAtEqual function, 873, 973 islower function, 348, 350–351 1663 isNegative variable, 312 isObject parameter, 927 isPalindrome function, 368–369 isstreamVar variable, 137 isTallEnough variable, 281 istream class, 762–763 istream class object, 1479 istream (input stream) data type, 124–125, 130, 139, 285 istream_iterator class, 1479 istream iterators, 1479 istream object, 139, 927 istreamVar input stream variable, 156, 285 isupper function, 348, 1507 isVowel function, 504, 505 iteration and problem solving, 1054 iterative control structures, 1053–1054 iterators, 1087–1089, 1442, 1489–1490 bidirectional iterators, 1475–1476 declaring, 1477–1478 dereferencing operator (*), 1473 forward iterators, 1475 increment operator (plus_plus), 1473 input iterators, 1474 linked lists, 1094–1095 output iterators, 1474–1475 random access iterators, 1476–1477 stream iterators, 1479 vector container declaration, 1448–1449 iter iterator, 1485 iter_swap function, 1492, 1517–1520 i variable, 269–271, 299–300, 308, 314–315, 321, 523, 1451 J Jacquard, Joseph, 2 Java, 8, 774 Jobs, Steven, 3 j variable, 832 K keyboard, 124 keys, 1267 keywords, 36 kilobytes (KB), 6 Kruskal's algorithm, 1427–1428 L languages variable, 475 larger function, 355–360, 374–376, 967 local declaration, 355 overloading, 414–415 larger function template, 968–969 largerInt function, 414 largest function, 1044–1046 largestInRows function, 570–571 largestVotes variable, 1333–1334 lastElem vector iterator, 1513 last formal parameter, 1304 Last In First Out (LIFO), 1167, 1170, 1212, 1442 last member, 626 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Index lastMerged pointer, 1310 lastName variable, 65–66, 613, 1317 last parameter, 1455–1456 last pointer variable, 1081, 1084, 1086, 1091–1093, 1096, 1099, 1101, 1103–1104, 1123, 1232, 1313 last variable, 1270–1273, 1290 late binding, 854 leaf, 1297, 1351 leavesCount function, 1365 left child, 1348, 1368 left manipulator, 154–156, 779 left subtree, 1348–1350, 1368–1369, 1373–1375 legalAge variable, 196–197 lenCodeOk variable, 577 length, 868, 1351 length_error class, 1010–1011 length function, 131–133, 495–498, 1094, 1124 length identifier, 30 lengthPtr pointer variable, 829 length variable, 19, 33, 742, 744, 746, 749–750, 752, 869, 872, 874, 876, 913, 917, 924, 935, 1271, 1290 less_equal function object, 1497 less function object, 1497 less than  (<), 187, 1479–1480 less than or equal to  (<=), 187 letterCount array, 583–584 letterCount variable, 582 letter variable, 280–281 level, 1352 level-by-level traversal, 1359 libraries, 11, 79–80 predefined functions, 347 linear searches, 542–545, 877, 1267 lineCount variable, 582–583 link component, 1074–1075, 1409 linked implementation of queue, 1227–1232 linked implementation of stacks, 1188–1201 adding node, 1192–1194 copying, 1196–1197 empty stack, 1191–1192 full stack, 1191–1192 initializing stack, 1192 overloading assignment  (=), 1197–1198 removing element, 1194–1196 top element, 1194 linked list-based lists merge sort algorithm, 1306–1315 merging sublists, 1310–1313 middle node, 1308 sublists, 1306–1315 linkedListIterator class, 1087–1089 linked lists, 1072 abstract data type (ADT), 1085–1097, 1106–1117 building backward, 1084–1085 building forward, 1080–1083 circular linked lists, 1131 copy constructor, 1096 copying, 1095–1096 deallocating memory, 1092–1093 deleting items, 1076, 1079–1080 destructor, 1096 doubly linked lists, 1120–1131 first, 1072 head, 1072 implementing stacks, 1188–1201 initializing, 1093 inserting items, 1076–1078 iterators, 1087–1089, 1094–1095 length, 1093–1094 links, 1072 nodes, 1072–1075 ordered, 1106–1117 overloading assignment  (=), 1097 pointers, 1080 printing, 1093 printing backward, 1211–1215 printing in reverse order, 1117–1119 processing nodes, 1087 properties, 1073–1075 quick sort algorithm, 1299 retrieving data from nodes, 1094 selection sort, 1291 sequential search, 1267 sorted, 1085 structure of nodes, 1086 traversing, 1075–1076, 1087, 1096, 1211–1212 unordered, 1085, 1097–1106 linkedListType class, 1085, 1089–1097, 1106, 1200, 1232 default constructor, 1092 iterator, 1087–1089 member variables, 1086 linkedQueueType class, 1227–1233 linkedStackType class, 1189–1201 linkedStackType function, 1191 linker, 11 links, 1072, 1076 Linux, 5 list array, 525, 530–531, 535, 543, 546–549, 572–573, 832–834, 869, 933, 935, 970, 1012, 1043–1046, 1101, 1110, 1290, 1293–1295, 1300–1306, 1325, 1461, 1499–1500, 1517, 1520, 1523, 1537 list1 array, 959, 1509–1510 list2 array, 1509 list3 array, 959, 1509 list4 array, 1509, 1510 list class, 1466 list containers and bidirectional iterators, 1476 listCont list container, 1467 listElem member, 619–620 list formal parameter, 620, 835, 1459 list header file, 1466 listIt iterator, 1451–1452 listLength member, 619–620 list list container bubble sort, 1285–1290 operations, 1468–1472 list objects, 1467 listOne object, 851–852 listOne parameter, 533 list pointer, 1173 list pointer variable, 834–835 lists, 619 abstract data type (ADT), 681–682, 869 array-based, 868–875, 972–978 empty, 872 equal items, 873 full, 872 index, 874 length, 868, 872 linked lists, 1072 maximum size, 872 operations performed on, 868 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Index | ordered, 879–880 outputting elements, 873 removing elements from, 873–874 repeating elements, 879 searching, 620 sequential, 1072 sorted or unsorted, 868, 872 sorting, 1284–1290 unordered, 875–879 list sequence container, 1454, 1466–1472 listSize function, 872 listTwo object, 852 listTwo parameter, 533 listType class, 682, 969–971, 1442 listType class template, 969–971 listType struct, 619 list variable, 832–833, 978, 1327, 1329, 1331–1332 lLink pointer, 1350–1351, 1370, 1375 loader, 11 local declaration, 355 local identifiers, 397–398 local variables, 388 logical_and function object, 1499 logical (Boolean) expressions, 40, 189, 196, 476 assert function, 235 associativity of relational operators, 211–213 bool data type, 196–197 bool variables, 202–203 evaluating, 209 int data type, 196 int variables, 202–203 logical expressions, 197–199 order of precedence, 199–203 reversing value, 198 short-circuit evaluation, 209–210 true and false values, 201 logical (Boolean) operators, 197 logical expressions, 197–199 logical values as operators, 197 order of precedence, 199–203 logical errors if statement, 195 silent killer, 221 logical expressions, 187–222 if_0__0__0_else statements, 193 input stream variable in if statements, 217 logical (Boolean) operators, 197–199 logical function objects, 1499 logical_not function object, 1499 logical_or function object, 1499 logic_error class, 1010 logic errors, 157–160, 1010 long data type, 38 long double data type, 41 *long long data type, 22, 38–39 loop condition, 1212–1215 loop control variable (LCV), 270–272, 281, 298–299 loop invariants, 322 loops, 186, 1407 body, 267 break statement, 311 component-wise copying, 532 debugging, 322 do_0__0__0_while loops, 307–311 enumeration types, 470 exiting early from, 311 1665 index out of bounds, 530 infinite, 267, 270 iterative control structures, 1053–1054 for loops, 295–306 multidimensional arrays, 575 number of iterations, 301 "off-by-one problem," 322 posttest, 308 pretest, 308 sentinel, 275–278 stepping through array elements, 525–528 verifying with loop invariants, 322 while loop, 267–295 lower_bound algorithm, 1491 lowerSublist sublist, 1299–1306 Lukasiewicz, Jan, 1201, 1202 luxuryTax variable, 14–15 M machine language, 6–9, 9, 62, 1055 Mac OS X, 5 main function, 31–34, 34, 81–82, 85, 89, 130, 217–218, 346, 351, 355, 359–360, 374, 376, 380, 382–383, 385–388, 390–393, 395, 401, 403, 424, 488–490, 577, 684, 712–713, 822, 839, 850–851, 853–854, 998, 1018, 1024, 1030–1031, 1145, 1204, 1250, 1327 main memory, 4–5, 62 make command, 688 make_heap algorithm, 1493 makeSale function, 707, 709 manipulating data, 81 manipulators, 72, 81, 156 map containers and bidirectional iterators, 1476 Mark I, 3 mathematical functions, 79, 81, 347 mathStudent enumeration type, 468 matrix array, 565–571, 574 max_element function, 1491, 1531–1535 max function, 1353, 1365, 1491 maxIndex variable, 527–528 maxListSize function, 872 maxQueueSize variable, 1218, 1224, 1226 maxSaleByPerson function, 635 maxSaleByQuarter function, 635–636 max_size function, 1446, 1453 maxSize variable, 869, 872, 935 maxStackSize variable, 1172, 1174 max variable, 355, 374 megabytes (MB), 6 member access operator (_0_), 139, 612, 655, 657 member access operator arrow (arrow_operator), 821 member functions, 907–911 binary operators, 918–922 calling member functions, 662 constant functions, 665 definitions, 660 implementing, 659–664 member variables, 664–667, 907 objects, 655 operator functions as, 915–917 overloaded operators, 915, 943–944 post-increment operator (plus_plus) as, 940 pre-increment operator (plus_plusu) as, 938 redefining (overriding) from base class, 741–748 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Index member objects passing arguments to constructors, 771–772 member selection operator, 903 member variables access by member functions without modifying, 664–667 base classes, 741 derived classes, 741 initializing, 675 member functions modifying, 664–667 member-wise copy, 929 objects, 655 memory data transfer between devices and, 762 optimizing use of, 39 memory allocation constants, 54–57 dynamic variables, 826 formal parameters, 388 global variables, 409 int variables, 830 new , 824–825 non-static member variables, 700–702 recursive functions, 1054 reference parameters, 388–397 static member variables, 700–702 value parameters, 388–397 variables, 54–57, 388, 409 memory cells, 4 memory leak, 826–827 merge function, 1313, 1469–1470, 1472, 1490, 1492, 1524–1528 mergeList function, 1311–1312, 1314–1315 merge sort algorithm analysis, 1313–1315 divide-and-conquer technique, 1306 linked list-based lists, 1306–1315 merging sublists, 1310–1313 partitioning list, 1306–1310 pivot, 1306 mergeSort function, 1313 merging sorted lists, 1524–1528 message variable, 1020 metersAndCentToFeetAndInches function, 406–408 methodologies.
See programming methodologies microprocessors, 3 middle member, 626 middle pointer variable, 1308–1309 mid variable, 1272–1273 miles variable, 63, 150–151 min_element function, 1491, 1531–1535 min function, 1491, 1531–1535 minimalSpanning function, 1431–1432 minimal spanning tree, 1427–1433 minLocation function, 1291–1292 minus function object, 1494 min variable, 651–654, 656–657, 660, 663–664, 671, 675, 677–678, 902, 950 mismatch algorithm, 1491 mixed expressions, 48, 49–50 mnemonic, 8 mobile computing applications, 3 modifying algorithms, 1492 mod  (%), 303 Modula-2, 774 modular programming, 20 modules, 346 modulus compound  (%=), 94–95 modulus function object, 1494 modulus (mod)  (%), 43–45, 48 month variable, 209 moveDisks function, 1053 move function, 860 movieDirector variable, 1140 movieProducer variable, 1140 movieProductionCompany variable, 1140 movieStar1 variable, 1140 movieStar2 variable, 1140 msTreeType class and abstract data type (ADT), 1430–1431 mstv array, 1430 multidimensional arrays, 574–575 dynamic, 836–839 multimap containers and bidirectional iterators, 1476 multiple inheritance, 739 multiple-line comments (/* */), 35 multiple selections, 205–208 multiplication compound  (*=), 94–95 multiplication  (*), 43–45 multiplies function object, 1494 multiset associative container, 1480–1486 multiset containers and bidirectional iterators, 1476 mutator functions, 664–667 m variable, 1283 myBox object, 749–750 myClass class, 700 myClock object, 655–658, 660–663, 672, 902, 907 myException class, 1028–1029 myList array, 531–532, 536–538 myList variable, 542 myRectangle object, 749, 911, 917–918, 922, 929, 931–932, 938 myRectangle parameter, 925–926 mySport variable, 468–470, 475 myStack class, 1186–1188 myStack_0_h header file, 1180–1183 myString variable, 157 myTime object, 677 myYard object, 914 N name array, 551–552, 554 named constants, 55–56 declaring, 81 global, 403 identifiers, 55, 91 name member, 626 name object, 771 name pointer variable, 827, 854 namesMultiSet multiset associative container, 1485–1486 namespace mechanism, 80–81 namespace member, 486–487 namespace_name identifier, 485, 487 namespace reserved word, 81, 486 namespaces, 485–490 nameType struct, 624–625 name variable, 57, 141, 153, 156, 274, 277–278, 491, 556, 856–858 n-dimensional arrays, 574–575 negate function object, 1494 negation  (-), 43, 45 negative integer operands and modulus (mod)  (%), 48 negativeNumber class, 1019–1021 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Index | negative numbers, 45 nested, 207 blocks, 398 control statements, 206–208 control structures, 278, 314–319 if_0__0__0_else statements, 278 if statements, 205–208 for loops, 314–315, 566–568, 1289, 1432 switch statements, 231–232 while loops, 278 newElement variable, 1194 newEmployee struct variable, 625–626 newHead variable, 1310 newHouse struct variable, 611 newItem variable, 1174–1175 newLastElem vector iterator, 1513 newline escape sequence (\n), 40–41, 73, 75–76, 78), 156, 555–556 extraction  (>>), 130 newNode node, 1078, 1081–1082, 1084, 1095, 1109 newNode variable, 1194 newNum variable, 301 new , 1010–1012 dynamic arrays, 831 memory allocation, 824–825 newString class, 958, 960–966, 998 newString data type, 964, 970 newStudent struct variable, 612–618 newYard object, 909 nextNum function, 1504 next_permutation algorithm, 1492 next pointer variable, 1122, 1127 nodeCount function, 1365 nodes, 1072–1075, 1297 binary trees, 1348–1351, 1353 children, 1350 as class or struct, 1073 comparison-based search algorithms, 1297 data, 1072 deallocating memory, 1079–1080, 1096 deleting, 1100–1104, 1113–1114, 1123, 1128–1131, 1358 info component, 1074, 1094–1095, 1098, 1103–1104, 1107–1108, 1110, 1118, 1129, 1211–1212, 1310, 1351 inserting, 1077–1078, 1108–1113, 1126–1128 iterators to first and last, 1094–1095 level, 1352 link component, 1074 linked lists, 1086 links, 1072 paths, 1351 pointers, 1212, 1350–1351 processing, 1087 retrieving data from, 1094 root node, 1348 visiting in sorted order, 1358 nodeType struct, 1086, 1350, 1359 nodeType type, 1351 nonmember functions binary operators as, 922–924 functions as, 915–917 overloading, 915, 943–944 post-increment  (plus_plus) as, 940–941 pre-increment  (plus_plusu) as, 939 nonmodifying algorithms, 1491 nonprintable characters, 126 1667 nonrecursive algorithms converting recursive algorithms to, 1166 printing linked list backward, 1211–1215 nonrecursive inorder transversal, 1379–1381 nonRecursiveInTraversal function, 1380–1381 nonrecursive postorder traversal, 1382–1383 nonrecursive preorder traversal, 1381–1382 nonRecursivePreTraversal function, 1381–1382 nonrecursive traversal algorithms binary trees, 1379–1383 inorder transversal, 1379–1381 postorder traversal, 1382–1383 preorder traversal, 1381–1382 non-static member variables memory allocation, 700–702 noOfGuesses variable, 290 noOfServiceYears variable, 16 NO_OF_STUDENTS named constant, 55 noOfStudents variable, 789 Notepad, 162 not_equal_to function object, 1496 not equal to  (_0_=), 187, 830, 1453 not  (_0_), 197–198–203 nth_element algorithm, 1492 nthFibonacciNum function, 366–368 nthFibonacci variable, 293 null character (\0), 41, 551 NULL named constant, 823, 827 null pointer (0), 823 nullptr null pointer, 823, 1072, 1074, 1076, 1081–1082, 1084, 1092–1093, 1101, 1109, 1111, 1123, 1191–1192, 1212–1213, 1228, 1308–1309, 1311, 1363, 1375 null strings, 53 null-terminated strings, 557–558 num array, 522 NUMBER named constant, 85 numberOfBlanks variable, 380 numberOfItems variable, 707–709 numberOfStudents variable, 425 numbers converting from binary to decimal, 1055–1059 converting from decimal to binary, 1059–1062 double data type, 355 inputting, 64 larger, 355–357 manipulating, 1546–1551 outputting in columns, 149–151 reading, 65–66 reading characters as, 137–139 number variable, 303–304, 383–384 numeric algorithms, 1492–1493 numeric header file, 1546 num identifier, 87 numOfBathrooms member, 611, 615 numOfBedrooms member, 611, 615 numOfBoxesSold variable, 274, 277 numOfCarsGarage member, 611 numOfVolunteers variable, 274–275, 277 numptr pointer variable, 814 num reference parameter, 1537 num variable, 17, 59, 74, 91, 134, 212–213, 229, 284, 310, 312, 316, 356, 364, 374, 384, 395, 550, 815, 1081 num1 variable, 58–60, 356–357, 814 num2 variable, 58, 60, 356–357, 814 num3 variable, 60 n variable, 303, 1283, 1504 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Index O object code, 82, 684, 688 objectOne object, 842–847 object-oriented design (OOD), 20–21, 650, 772–775 object-oriented programming (OOP), 772–775 object-oriented programming (OOP) languages, 20, 774 Object Pascal, 774 objects, 21, 139, 650, 654, 774 accessing class members, 655–656 accessing implementation details, 687–688 aliases, 881–883 identifying, 20, 774–775 information hiding, 683–687 initializing, 677, 845 iterators, 1087 member functions, 655, 907–911 member variables, 655 operations performed on data, 20, 21 overloading, 903 out of scope, 843 passed by reference, 852 passed by value, 847, 852 pointer to itself, 907 private member variables, 683 relevant data, 20–21 objectThree object, 845, 847 objectTwo object, 843–844 objectType enumeration type, 477 _0_obj file extension, 82 odds variable, 304–305, 418–419 "off-by-one problem," 322 ofstream class, 763, 786 ofstream data type, 160, 762 ofstream variables, 161, 290, 388, 426, 431, 634–635 oldYard object, 909 one class, 757 one-dimensional arrays, 521 declaring, 521–525, 569 processing, 525–529 simulating table form data, 560 size, 532–533 one function, 401, 907 one value parameter, 395 ONE variable, 758–759 one-way selections, 189–192, 215 OOD.
See object-oriented design OOP.
See object-oriented programming (OOP) language open function, 557–758 open stream member function, 161 operands, 45 data types, 49–50 extraction  (>>), 125 postfix expressions, 1206–1208 returning address of, 814 operating systems, 5 operations, 681 _0_= function, 920, 949 # function, 918, 922–923 * function, 920 + function, 920, 923–924 operatorplus_plus function, 937–943, 947 < function, 949 << function, 925–926, 950, 955–956 <= function, 948–949 = function, 929–937 == function, 905–907, 924, 947–949 >> function, 926–927, 950–951, 963 [] function, 958–966 () function call , 1494 functions, 903–904, 915–917 overloading, 902, 903 member functions, 943–944 nonmember functions, 943–944 restrictions, 904–907 this pointer, 907–911 reserved word, 903–904 operators associativity, 200, 904 built-in data types, 904 explicitly overloading, 904 order of precedence, 200 overloading, 773–774, 1319–1320, 1324–1325 postfix expressions, 1203 precedence, 202, 213, 904, 1201 op , 915, 944 opOverClass class, 915 orderedArrayListType class, 872, 879–881, 972, 978, 1275–1276 orderedLinkedList class, 1085, 1091–1092, 1106–1117 ordered linked lists deleting nodes, 1113–1114 header file, 1114–1115 insert first node, 1112–1113 inserting node, 1108–1112 insert last node, 1112–1113 operations on, 1116–1117 searching, 1107–1108 traversing, 1111 ordered lists, 879–880 orderedListType class, 1114–1115 ordered sets, 881 orderedSetType class, 881 origin, 1405 or logical  (||), 197, 199–203, 209–210 osIdentifier identifier, 1479 osObject parameter, 925 ostream class, 762, 786 ostream class object, 1479 ostream_iterator class, 1479 ostream iterators, 1456, 1479 copy function and, 1456–1458 ostream object, 139, 925 ostream (output stream) data type, 124–125, 139 ostreamVar variable, 152, 154 otherClock object, 663–664 otherClock reference parameter, 659, 663–664 otherDeq deque container, 1462 otherIntSet set associative container, 1482 otherList list container, 1467 otherList object, 935 otherVecList vector container, 1444 outData variable, 161 _0_out extension, 162 outfile object, 786 outfile stream variable, 582 outFile variable, 290, 789 outF parameter, 779, 783, 786 out-of-bounds exception, 998 out_of_range class, 1010–1011 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Index | out_of_range exception, 1011 output, 72–79, 144–155 columns, 149–151 floating-point numbers, 144–145 formatting, 72, 81, 144–155 generating, 31 left-justified, 154–155 new , 75–76, 144 right-justified, 151–152, 154–155 sending to output device, screen, or file, 786 output devices, 5, 152–153 output files extensions, 162 specifying at execution time, 557 output file stream, 160 outputIterator output iterator, 1474 output iterators, 1474–1475 output  (<<), overloading, 1135 output statements, 29–31, 59, 72–79, 351 output streams, 124 writing data to, 1474–1475 output stream variables, 125, 556 overflow, 1175 overflow_error class, 1010 overloaded operators, 903–904, 915 overloading array index  ([]), 958–966 assignment  (=), 929–937, 974, 1092, 1097, 1179–1180, 1197–1198, 1362, 1366–1367 binary operators, 918–924 copy constructor, 1362 decrement  (minus_minus), 937–938 destructor, 1362 extraction  (>>), 924, 926–929 function name, 413–415 functions, 966–969 increment  (plus_plus), 937–938 insertion  (<<), 924–929 operators, 1319–1320, 1324–1325 output  (<<), 1135 post-increment  (uplus_plus), 939–943 pre-increment  (plus_plusu), 937–939 unary operators, 937–943 P package object, 752, 753 paintSale array, 541 palindromes, 368–369 parallel arrays, 558–559 parallel edges, 1407 parameterized stream manipulators, 156 parameterized types, 969 parameter passing, 389–397 parameters, 131, 134 arrays as, 532–533 data types, 351 default, 415–417 functions as, 1383–1386 manipulators, 156 names, 398 objects as, 658 passed by reference, 925 predefined functions, 351 1669 reference variables as, 384–388 struct variables, 617–618 two-dimensional arrays passing, 568–571 void functions, 377–378 parametric polymorphism, 774 paramObject formal parameter, 846–848 paramObject object, 848 parent, 1348, 1351 p array, 851–852 partial_sort algorithm, 1492 partial_sort_copy algorithm, 1492 partial_sum function, 1493, 1546–1551 partition function, 1303–1305, 1492 partTimeEmployee class, 738, 755–757, 861, 865–867 partTimeEmployee_0_h header file, 757–758 Pascal, Blaise, 2 Pascaline, 2 passed by reference arrays, 532–533 struct data type, 621 struct variables, 617–618 two-dimensional arrays, 568–571 variables, 658 passed by value arrays, 538 class objects, 658 struct data type, 621 struct variables, 617–618 variables, 620, 658 patches, 319–322 paths, 1298, 1351, 1407 payCheck variable, 622 payment variable, 192 payRate variable, 125–126, 162 p dynamic array, 832 peek function, 130, 136–139, 161 perimeter function, 742, 744, 752, 910 perimeter variable, 19, 33 personal computers (PCs), 3 personalInfo class, 768, 770–772 personalInfo constructor, 770, 772 personType class, 693–695, 738, 755, 757, 767–768, 780, 783, 861, 1145, 1317–1320, 1320 personType_0_h header file, 757 petabytes (PB), 6 pet object, 854, 858 pet pointer, 859 petType class, 852–854, 856–858 petType_0_h header file, 855, 857 p formal parameter, 853–854, 856–858 pigLatinString function, 505, 506–507 PI named constant, 148–149 pivot, 1299–1304, 1306 play1 variable, 478 play2 variable, 478 plus function object, 1494 p member variable, 851 p object, 857–858 pointer arithmetic, 830–831 pointer data type, 812 pointerParameters function, 836 pointers, 1072 accessing class or struct components, 821 address of operator (&), 814 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Index to arrays, 840 class member functions and, 821–823 dangling, 827, 841 data types, 812 dereferencing, 820, 825 dereferencing operator (*), 815 dynamic variables, 824–827 first container element, 1456 formal parameters as, 852–853 to functions, 1383 last container element, 1456 memory space, 827 nodes, 1212, 1350–1351 related memory, 839–840 return type of function, 836 root node, 1351, 1353 shallow versus deep copy, 839–841 value parameter, 836 pointer variables, 812 assigning value to another pointer variable, 829–830 assignment  (=), 829–830 asterisk symbol (*) and, 812–813 char data type, 813 classes and, 841–852, 944 comparing for equality, 830 data types, 812 declaring, 812–813 functions, 836 increment and decrement operations, 830 initializing, 823 int data type, 813 integer values, 830–831 operations on, 829–831 root, 1351 storing memory addresses, 812, 881–883 value of, 812 point1X variable, 133 point2X variable, 133 point1Y variable, 133 point2Y variable, 133 Poisson distribution, 1248 Polish notation, 1201 polymorphism, 773–774 polynomials, factoring, 403–406 poolCapacity function, 412–413 poolFillTime function, 412 pop_back function, 1447, 1454, 1466 pop_front function, 1463, 1465, 1468 pop function, 1176–1178, 1192, 1194–1196, 1200, 1486, 1488 pop_heap algorithm, 1493 pop operation, 1167–1168 popularSport variable, 468–470 position iterator, 1447, 1454, 1506 positive integers, 40 postcondition, 685 post-decrement  (variableminus_minus), 70 postfix expressions, 1201–1202 evaluating, 1204–1208 operands, 1206–1208 operators, 1203 printing result, 1208–1209 # symbol, 1203–1204 postfix notations, 1202 post-increment  (uplus_plus), 70, 937 overloading, 939–943 postorder function, 1358, 1364 postorder sequence, 1355 postorder traversal and nonrecursive traversal algorithms, 1382–1383 postorderTraversal function, 1363 posttest loops, 308 pos variable, 1274 power function, 131 pow function, 131–133, 347–348, 350–352, 488 p pointer, 1353 p pointer variable, 813–815, 824–827, 831, 833, 835–836, 842–844, 1077–1078, 1080 precision, 42 precondition, 685 pre-decrement  (minus_minusvariable), 70 predefined functions, 34, 131–140, 346–351 predefined identifiers, 36 predicates, 1499 p reference parameter, 836 prefix notation, 1201 pre-increment  (plus_plusu), 70 overloading, 937–939 preorder function, 1358, 1364 preorder sequence, 1355 preorder traversal and nonrecursive traversal algorithms, 1381–1382 preorderTraversal function, 1363 preprocessor, 9, 79–80 preprocessor directives, 10, 79–82, 759 pretest loops, 308 previous1 variable, 292–293 previous2 variable, 292–293 prev_permutation algorithm, 1492 prewritten code, 11 price member, 611, 615 primeFactorization class, 760–761 Prim's algorithm, 1427–1433 printArray function, 534 printData function, 1323 printDate function, 768, 770 print function, 693–695, 699–702, 741–742, 744, 746, 749, 755–756, 766, 777, 779, 781, 783–786, 788, 839, 853–855, 857, 861, 873, 910, 928, 973, 1093, 1124, 1333, 1386 printGrade function, 385–388 printGradeReports function, 790 printGraph function, 1413 printHeading function, 432 printing arrays, 526, 534 doubly linked lists, 1124 graphs, 1413 linked list backward, 1211–1215 linked lists, 1093 linked lists in reverse order, 1117–1119 postfix expression result, 1208–1209 reverse order doubly linked lists, 1124–1125 struct variables contents, 618 two-dimensional arrays, 566–567 printMatrix function, 570–571 printpersonalInfo function, 770, 772 printReport function, 634–635 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Index | printResult function, 424, 426, 431–432, 486, 490, 1204, 1208–1209 printResults function, 418–420, 1333–1334 printShortestDistance function, 1425 printStars function, 379–382 printTime function, 652–654, 656, 660–662, 664–665, 685, 950 printTreeAndWeight function, 1432 private access specifier, 651, 683 private inheritance, 739–740 private members, 651–653, 656, 668–669, 763–764, 774 private member variable, 881–882 problem analysis-coding-execution cycle, 11–19 problems analysis, 19 object-oriented design (OOD), 21 structured design, 21 subproblems, 18 problem solving, 11 identifying objects, 20 iteration, 1054 largest element in array, 1043–1046 recursion, 1040, 1043–1054 subproblems, 20 problem-solving techniques, 11–13 processVotes function, 1331–1332 program development environment, 80 programming, 28 problem analysis-coding-execution cycle, 11–19 problem solving, 11 structured, 772–775 programming languages, 2, 3, 7–9, 34 equality  (=), 220 high-level languages, 8–9 semantic rules, 34 semantics, 90 syntax, 10, 13 syntax errors, 10, 11 syntax rules, 34 programming methodologies object-oriented design (OOD), 20–21 structured design, 20 programmingScore member, 614 programs, 2, 28, 774–775 See also Cplus_plus programs altering sequential flow of execution, 186 basic operations, 124 blank spaces, 90, 92 brackets, 90 commas (,), 90 curly braces ({ }), 90 decision making, 21, 189 documentation, 92 error messages, 234–236, 530 executing, 13 expressions, 30 fixing exception and continuing, 1026–1027 functions, 31–32, 34, 186 handling exceptions, 998–1013 header files, 80–81 identifiers, 36–37, 90–91 indentation, 222 keywords, 36 line numbers, 74–75 logging exception and continuing, 1027–1028 logic errors, 1010 1671 machine language version of, 10 main function, 31–32, 34 menu-driven, 406–408 multiple-line comments (/* */), 35 numeric data, 64 object-oriented design (OOD), 773 output statements, 29, 30–31 placing and indenting braces ({}), 222 predefined functions, 131–140 processing, 9–11, 186 prompt lines, 91–92 proper structure, 89 pseudocode, 223–225 reading data from file, 162 repetitively processing, 186 reserved words, 36 runtime errors, 1010 selection, 21 selectively processing, 186 sequentially processing, 186 single-line comments (//), 31, 34–35 special symbols, 35 structured programming, 773 style and form, 89–94 subprograms, 34 syntax errors, 92 syntax rules, 89 terminating, 217–219, 234–236, 530, 1026 tokens, 35–36 translating pseudocode into, 223–224 try/catch blocks, 1005–1009 whitespaces, 37 progScore parameter, 379 project files, 688 prompt lines, 91–92 protected access specifier, 651, 763 protected members, 763–767 protected variables, 872 pseudo, 223 pseudocode, 223–225 ptrMemberVarType class, 841–850 ptrMemberVarType_0_h file, 850 public access specifier, 651, 668 public inheritance, 740 public member functions, 745–746 public members, 651–653, 656, 668–669, 763–764, 774 public static member, 699 pure virtual functions, 860–861 push_back function, 1447–1448, 1451, 1454, 1459, 1461, 1465, 1500 push_front function, 1463, 1468 push function, 1174–1176, 1192–1194, 1200, 1486, 1488 push_heap algorithm, 1493 push operation, 1167–1168 putback function, 130, 136–139, 161 p value parameter, 856 Q q pointer variable, 813, 825, 836, 1078, 1080 queueADT class, 1217, 1222 abstract data type (ADT), 1217 queue class, 1488–1489 queueFront pointer variable, 1216, 1218, 1220, 1222, 1224–1228, 1230, 1232 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Index queue header file, 1488 queueRear pointer variable, 1216, 1218–1222, 1224–1227, 1229, 1232 queues, 1215–1233, 1488–1489 adding elements, 1216–1218, 1221, 1225, 1229–1230, 1246 back, 1215–1216 breadth first traversal algorithm, 1417 constructors, 1226–1227 deleting elements, 1216–1219, 1221, 1225–1226, 1230–1231, 1246 destructors, 1226–1227 double-ended, 1462–1466 empty, 1216, 1224, 1228–1229 first element, 1218, 1220, 1222, 1224–1225 First In First Out structure, 1215, 1234 front, 1215–1216 full, 1216, 1224, 1228–1229 implementation as arrays, 1218–1227 initializing, 1216, 1224, 1229 last element, 1218, 1220, 1222, 1225, 1230 linked implementation of, 1227–1232 maximum size, 1218, 1224 middle elements, 1216 operations, 1216–1217 rear, 1215 relational operators, 1488 temporary, 1246 waiting customers queue, 1245–1247 queues simulation, 1233–1251 queueType class, 1222–1227, 1245–1246 queuing systems, 1234 customers, 1234–1238 designing, 1234–1235 main program, 1247–1251 server list, 1241–1245 servers, 1234, 1238–1241 transaction time, 1234–1235 waiting customers queue, 1245–1247 waiting time, 1234–1235 quick sort algorithm analysis, 1305–1306 array-based lists, 1298–1306 divide-and-conquer technique, 1299 key comparisons, 1305 for loops, 1300 partitioning list, 1299–1306 recursion, 1305 quotient variable, 235, 1006 q value parameter, 836 R rAccessIterator random access iterator, 1476–1477 radiusPtr pointer variable, 819–820, 827, 829 radius variable, 148–149, 691, 819–820, 827, 1021 rand function, 282 random access data structure, 1170 random access iterators, 1476–1477 random access memory (RAM), 4–5 random number generator, 363 random numbers, 17, 282 random_shuffle function, 1492, 1531–1535 range-based for loops, 550, 1458–1461 arrays, 834–835 auto declaration, 550 dynamic arrays, 834–835, 1459 formal parameters, 1459 sequence containers, 1473 syntax errors, 834–835 vector objects, 1459–1461, 1473 ranges accessing and processing elements by applying function, 1535–1537 consecutive elements meeting criteria, 1524–1528 copying elements, 1513–1517 counting occurrences of values, 1531–1535 elements appearing in another range, 1538–1546 elements common to two ranges, 1538–1546 elements not appearing in another range, 1538–1546 element sum of previous elements, 1546–1551 finding elements, 1505–1507 largest element in, 1531–1535 last element, 1507–1510 maximum of values, 1531–1535 minimum of values, 1531–1535 multiplying elements in multiple, 1546–1551 randomly ordering values, 1531–1535 replacing elements, 1513–1517 reversing order of elements, 1528–1531 rotating elements, 1528–1531 searching elements, 1520–1523 sequence of elements, 1535–1537 smallest element in, 1531–1535 sorting elements, 1520–1523 subrange, 1507–1510 summing elements, 1546–1551 swapping elements, 1517–1520 RATE member, 486–487 rate variable, 146, 194, 235 rbegin function, 1453, 1456 readCode function, 577 readCourses function, 473–474 readIn function, 617–618 read statements, 66–69 real alias, 476 real numbers and relational operators, 187–188 rear, 1215 rebuild command, 1, 688 recFriendObject formal parameter, 913 recMergeSort function, 1312–1314 records, 610–626 recQuickSort function, 1305 rectangle class, 739, 750, 860–861 rectangleFriend function, 913–914 rectangle1 object, 922 rectangle2 object, 922 rectangle3 object, 922 rectangle4 object, 922 rectangleType class, 742–743, 745, 747–750, 752–753, 908–911, 914–918, 922–929, 937–944 overloading binary operators, 919–922 private members, 746 rectangleType constructor, 742, 744, 753–754 recursion, 1040 direct, 1042 Fibonacci number, 1047–1050 indirect, 1042 infinite, 1042–1043 largest element in array, 1043–1046 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Index | printing linked lists in reverse order, 1117–1119 problem solving, 1043–1054 quick sort algorithm, 1305 removing, 1211–1215 selection control structures, 1054 Tower of Hanoi, 1051–1053 recursive algorithms, 1041, 1043–1053, 1353 base cases, 1041 binary search algorithm, 1271 converting into nonrecursive algorithms, 1166 largest element in array, 1043–1046 sequential search algorithm, 1268 recursive definitions, 1040 base cases, 1040 directly recursive functions, 1042 general cases, 1040 indirectly recursive functions, 1042 infinite recursion, 1042–1043 recursive algorithms, 1041 recursive functions, 1041–1042 tail recursive functions, 1042 recursive functions, 1041 designing, 1043 local variables, 1054 memory allocation, 1054 parameters, 1054 unlimited copies of itself, 1042 reference parameters, 378, 406–408 and&, 378 changing values of parameter, 384 class objects, 658–659 declaring as constant, 385 formal parameters, 836, 852–853 manipulating actual parameters, 394–397 memory allocation, 388–397 value-returning functions, 397 reference variables as parameters, 384–388 ref formal parameter, 395 regionNumber variable, 1329 registered variable, 470–471 relational function objects, 1496–1499 relational operators, 187, 616–617, 902–903 associativity, 211–213 binary operators, 187 char data type, 188–189 enumeration types, 469–470 integers, 187–188 order of precedence, 200 queues, 1488 real numbers, 187–188 simple data types, 187–188 stacks, 1487 string data type, 203–204 remainder operator (%), 43–45 removeAt function, 873–874, 877, 973 remove_copy function, 1492, 1510–1513 remove_copy_if function, 1492, 1510–1513 remove function, 872, 875, 877, 975, 1468, 1492, 1510–1513 remove_if function, 1468, 1492, 1510–1513 rend function, 1453, 1456 re object, 1011 repetition, 21, 186–187, 264–266 do_0__0__0_while loops, 307–311 for loops, 295–306 while loop, 267–295 1673 replaceAt function, 872, 875, 877–879, 975, 1329 replace_copy function, 1492, 1513–1517 replace_copy_if function, 1492, 1513–1517 replace function, 495, 500–501, 1492, 1513–1517 replace_if function, 1492, 1513–1517 reserved words, 36, 90 residential function, 369–373 resize function, 1447–1448, 1454 rethrowing exceptions, 1022–1025 retrieveAt function, 874, 973, 1329, 1332 retrievePlay function, 478–480 return escape sequence (\r), 78 return reserved word, 355 return statement, 85, 217–218, 369 returning only one value, 361–362 secret function, 361 value-returning functions, 351, 354–355 void functions, 376 reverse_copy function, 1492, 1528–1531 reverse function, 1470, 1492, 1528–1531 reverseNum function, 695–698 Reverse Polish notation, 1201 reversePrint function, 1117–1119, 1124–1125 rFibNum function, 1047–1050 right child, 1348, 1368 right manipulator, 154–155, 779 rightmost bit, 1059 rightObject formal parameter, 932 right subtree, 1348–1350, 1368–1369, 1373–1375 rLink pointer, 1350–1351, 1370, 1375 rollDice function, 363–365, 691 roll function, 691–692 root, 1351 rooted tree, 1427 root node, 1298, 1348–1350 binary search trees, 1368, 1370 level of, 1352 pointer, 1351, 1353 root pointer, 1362–1363, 1370 rotate_copy function, 1492, 1528–1531 rotate function, 504–505, 1492, 1528–1531 row order form, 569 row processing, 565 rows variable, 839 runSimulation function, 1249–1250 run-time binding, 854, 860 runtime_error class, 1010 runtime errors, 1010 run-together words, 55, 91 ryanHouse variable, 615 S saleByQuarter function, 633 salePrice variable, 14–15 sales array, 526, 527–528, 530, 560, 561 salesPersonList array, 628–631, 633–635 salesPersonRec struct data type, 628 salesTax variable, 14–15 sale variable, 58 scholarship variable, 153 scientific manipulator, 145–146, 156 scientific notation, 41, 144–146 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Index scope class members, 658 function names, 398 identifiers, 397–401 namespace member, 486 scope resolution operator (::), 401, 486–487, 489, 660, 704, 745–747, 1449, 1477 score parameter, 386–388 score variable, 195–196, 207, 230, 232, 425, 614 screen, 124 screen ostream iterator, 1457, 1465, 1485, 1503–1504, 1513 search algorithms, 1266–1276, 1491 asymptotic notation, 1276–1284 binary search, 1269–1276 binary search trees, 1378–1379 comparison-based search algorithms, 1284 dominant operations, 1277–1278 growth rate of functions, 1278–1281 keys, 1267 number of comparisons, 1278–1281 sequential search algorithm, 877, 1267–1269 while loops, 1277 searchDVDList function, 1140, 1142, 1391–1392 search function, 1092, 1097–1099, 1106, 1108, 1125, 1362, 1371, 1520–1523 searching arrays for specific item, 542–549 criteria, 1499 doubly linked lists, 1125 elements, 1520–1523 linear search, 542–545, 877 ordered linked lists, 1107–1108 sequential search, 542–545, 877 server list, 1243–1244 unordered linked lists, 1098–1099 searchItem function, 542, 544 searchItem variable, 620 search_n function, 1491, 1520–1523 searchValue element, 1505 second formal parameter, 395 second iterator, 1517 secondNum variable, 85, 350 second pointer variable, 840–841 secondRect variable, 924 second variable, 62–63, 395 secret function, 361 sec variable, 651–654, 656–657, 660, 663–664, 671, 675, 677–678, 902, 950 selection control structures, 1054 selections, 21, 186–222 multiple, 205–208, 232 one-way, 189–192, 215 two-way, 192–196 selection sort, 545–549, 1290–1292, 1297 selectionSort function, 548–549, 1291–1292 selection structures if_0__0__0_else statements, 225 if statements, 225 switch structures, 225–232 selection1 variable, 478 selection2 variable, 478 selector, 226 self-assignment, 931–933 self-documenting identifiers, 91 sellProduct function, 710–712 semantic errors, 90 if statements, 192, 195–196 semicolon (;) at end of for loops, 298 semantic rules, 34 semantics, 90 semicolons (;), 35 sentence object, 1011 sentinel, 275–278, 316, 318 sentinel-controlled while loops, 275–281, 316 seqCont sequence container, 1454 seqSearch function, 543–545, 620–621, 872, 875, 877, 975, 978 sequence containers deque sequence container, 1462–1466 list sequence container, 1466–1472 member functions, 1454 range-based for loops, 1459–1461, 1473 vector sequence container, 1443–1449 sequences copying elements, 1510–1513 filling, 1503–1505 removing elements, 1510–1513 sequential lists, 1072 sequential search, 542–545, 877 array-based lists, 1267–1269 linked lists, 1267 sequential search algorithm, 1267–1269 array-based lists, 877 serverID variable, 1244 server list, 1241–1245 serverListType class, 1241–1245 servers, 1234, 1238–1241 busy, 1244–1245 set of, 1241–1245 serverType class, 1238–1241 set associative container declaring, 1480–1482 inserting and deleting items, 1482–1483 operations on, 1483–1486 setBusy function, 1240 set containers and bidirectional iterators, 1476 setCopiesInStock function, 1142 setCourseInfo function, 777–779 setCurrentCustomer function, 1241 setCustomerInfo function, 1237 setData function, 765–766 setDate function, 768–769 set_difference function, 1492, 1538–1546 setDimension function, 742–744, 747, 752–753, 910 setfill manipulator, 152–153, 156, 161 setFree function, 1241 setInfo function, 781, 783 set_intersection function, 1492, 1538–1546 setLength function, 910 setName function, 694–695, 783, 1317 setNameRateHours function, 756 setNum function, 695–698 setpersonalInfo function, 770, 772 setprecision manipulator, 144–145, 147–149, 156 setRadius function, 689, 691, 1019–1020 sets, 879 manipulating, 879 ordered, 881 setServerBusy function, 1244 setSimulationParameters function, 1247–1248 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Index | set_symmetric_difference function, 1492, 1538–1546 setTime function, 652–654, 656, 660–661, 664, 669, 685, 949 setTransactionTime function, 1241 set_union function, 1492, 1538–1546 setVotes function, 1323 setWaitingTime function, 1238 setWidth function, 910 setw manipulator, 149–152, 156, 963 setX function, 699–700 shallow copy, 841 versus deep copy, 839–841 shape class, 739–740, 860–861 shift operator (>>), 1482 short-circuit evaluation, 209–210 short data type, 38 shortest path, 1418–1426 shortest path algorithm, 1418–1426 shortestPath function, 1424–1425 showChoices function, 406–408 showpoint manipulator, 146–149, 156, 371 showSelection function, 710 signatures, 414 significant digits precision, 42 silent killer, 221 simple assignment statements, 94, 95 simple data types, 38–41, 57, 520 initializing during declaration, 1461 relational operators, 187–188 valid input, 127–130 variables, 125–127 simple graphs, 1407 simple paths, 1407 Simula, 774 simulation parameters, 1247 simulations implementing, 1249–1250 queues, 1233–1251 time-driven, 1234 single inheritance, 739 single-line (//) comments, 31, 34–35 single precision, 42 single quotation escape sequence (\'), 78 size function, 495–497, 1446, 1452, 1486, 1488 slicing problem, 858 smallestWeight array, 1420–1423 smallIndex variable, 1300–1303 Smalltalk, 774 software, 2, 5 patches, 319–322 sortCourses function, 782–783, 787–788 sorted linked lists, 1085–1086 sorted lists, 868, 872 binary search, 1269–1276 merging, 1524–1528 sort function, 1289–1290, 1328, 1469, 1490, 1492, 1520–1523 sort_heap algorithm, 1493 sorting arrays, 545–549 criteria, 1499 elements, 1520–1523 lists, 1284–1290 selection sort, 545–549 sorting algorithms, 1266, 1284–1316 bubble sort, 1284–1290 1675 comparison-based, 1297–1298 insertion sort, 1292–1297 key comparisons, 1288–1289 merge sort algorithm, 1306–1315 quick sort algorithm, 1298–1306 selection sort, 1290–1292 source, 1418 source code, 9, 82, 688 source code file, 82 source file, 82 sourceName file, 161 source program, 9 source vertex, 1428 spanning tree, 1427 special symbols, 35 speed variable, 150–151 sphereRadius variable, 133 sphereVolume variable, 133 splice function, 1469, 1472 sports enumeration type, 468–469 sqrt function, 131–133, 347–348, 350 square class, 739 squareFirst function, 395 srand function, 282 stable_partition algorithm, 1492 stable_sort algorithm, 1492 stackADT class, 1168–1169, 1189–1190, 1192 stack class, 1486–1487 stack header file, 1486 stack object, 1172, 1175, 1178, 1190, 1212 stacks, 1166–1168, 1486–1487 adding elements, 1168, 1192–1194 base address of array, 1173 comparing, 1487 converting recursive algorithms into nonrecursive algorithms, 1166 copying, 1172, 1178 empty, 1172, 1174, 1191–1192 full, 1191–1192 implementing as arrays, 1170–1188 implementing function calls, 1166 initializing, 1173–1174, 1192 Last In First Out (LIFO) data structure, 1167, 1170 linked implementation of, 1188–1201 overflow, 1175 pop operation, 1167–1168 push operation, 1167–1168, 1174–1176 relational operators, 1487 removing elements, 1168, 1176–1178 top element, 1172, 1176, 1194 top operation, 1166–1168 underflow, 1178 unorderedLinkedList class, 1200–1201 unwinding, 1028–1031 stackTop variable, 1170, 1172–1174, 1176, 1178–1179, 1189, 1191–1192 stackType class, 1170–1184 stand-alone else statements, 195 Standard Cplus_plus, 22, 398, 485 standard functions, 34 standard input device, 63–66, 124 standard output device, 72, 124 Standard Template Library (STL), 1442 algorithms, 1442, 1490–1551 associative containers, 1479–1489 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Index components, 1442–1473 container adapters, 1486–1489 containers, 1442–1473 function objects, 1493, 1494–1499 insert iterators, 1500–1501 iterators, 1442, 1473–1479 standing enumeration type, 467 starsInLine parameter, 380 statements, 81–82 repetition, 264–266 self-assignment, 931–933 statement terminator (;), 90 statement terminator (;), 90 stateSalesTax variable, 14–15 static arrays, 831 static binding, 854 static_cast reserved word, 51–53 static functions, 698–704 static members, 698–704 static member variables memory allocation, 700–702 static reserved word, 409, 698–699 static variables, 409–410, 698–704 status variable, 1238 stdexcept header file, 1010 std namespace, 80–81, 490 stepwise refinement, 20 strcmp function, 552–554 strcpy function, 552–554 stream classes, 762–763 stream extraction operator (>>), 63–66, 903 overloading, 924, 926–929 stream functions, 130, 156 stream insertion operator (<<), 32, 59, 72, 903 overloading, 924, 925–926 syntax error, 87 stream manipulators, 156 stream member functions, 130 stream objects, 139 streams, 124 stream variables, 125 passing by reference to functions, 388 string concatenation operator (+), 1010 string data type, 53–54, 471–474, 572 additional operations, 494–503 binary operator (+), 491–492 functions, 494–503 input/output (I/O), 156–157, 557–558 predefined operations, 573 processing array of strings, 572 relational operators, 203–204 usage, 81 variables, 558 string header file, 81, 131–133, 490, 557 stringList object, 970, 978 stringList vector container, 1443 string::npos named constant, 494 string objects, 1010 strings, 30–31, 31, 53–54, 551 accessing individual character in, 492 arrays, 572 character-by-character comparison, 203–204 clearing, 496–497 concatenating, 491 containing blanks, 156 containing message, 1010 converting to null-terminated string, 557–558 empty, 53, 496–497 input, 554–556 inserting, 500–501 length, 53–54, 131–133, 496–498 manipulating, 54 multiple-line, 78 null, 53 null-terminated, 557–558 output, 77–78, 149–151, 556 output statements, 77–78 palindromes, 368–369 reading, 65–66, 156–157, 554–555, 555 relative position of characters, 53 replacing, 500–501 searching, 498–500 size, 496–497 slash (\) within, 162 storing in string variable, 67 subscript out of range error, 1010 substrings, 502–503 writing, 554 string::size_type data type, 494, 498, 500 string variables, 67, 491–492, 503 strlen function, 552–554 strongly connected, 1407 Stroustrup, Bjarne, 22 str pointer, 827 str string variable, 494 struct data type accessing members, 612–615 arrays, 619–623 versus arrays, 618 versus classes, 682–683 components, 682 defining, 611–612 length, 619–621 members, 610 passing by reference, 621 passing by value, 621 public members, 683 struct data type, 623–626 values, 619–621 struct reserved word, 610 structs accessing components with pointer, 821 declaring, 820 nodes as, 1073, 1086 public members, 820 struct statement, 610–611 structured data types, 520 structured design, 20–21 structured programming, 20, 772–775 struct variables assigning value, 615–616 comparing member-wise, 616–617 declaring, 611–612 functions and, 617–618 as global variables, 612 input/output (I/O), 617 name, 612 passing as parameter by value or by reference, 617–618 printing contents, 618 reading and writing, 617 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Index | str variable, 58, 978 str1 variable, 491, 498, 966 str2 variable, 491, 498, 966 str3 variable, 491, 966 strVar string variable, 156, 494, 557 stubbs, 412–413 studentID array, 558–559 studentList array, 789 studentName array, 552 student object, 771, 820 studentPtr pointer variable, 820–821 student struct variable, 616 studentType class, 780–788 studentType struct, 820–821 studentType struct variable, 618 style member, 611 subgraphs, 1405 subproblems, 18, 20 subprograms, 34 subscript  ([]), 1448, 1451 overloading, 958–966 subset, 1405 substr function, 495, 502–503, 1010–1011 subtraction compound  (-=), 94–95 subtraction  (-), 43, 45, 903 subtrees, 1353 sumArray function, 534–535, 538 sumDigits function, 696–698 sumRows function, 569–571 sum variable, 290, 301, 303, 310, 312, 316, 364, 998 sumVotes variable, 1333–1334 surface area, 774–775 swap function, 495, 503, 1291–1292, 1304, 1453, 1492, 1517–1520 swap_ranges function, 1492, 1517–1520 switch reserved word, 225 switch statements, 189, 281, 290, 303, 471 break statement, 227, 234, 311 case statement, 226–227 default label, 227 evaluating expression to logical value, 231 expressions, 225–227, 230 general rules for, 226–227 identifier, 226 immediately exiting, 227, 311 multiple selections, 232 nesting, 231–232 range of values, 232 selector, 226 skipping remainder of, 311 switch structures, 225–232 syntax, 13 syntax errors, 10–11, 92, 157 correcting in top-down fashion, 87 detecting, 89 identifying, 85 range-based for loops, 834–835 semicolon (;) after expressions in if_0__0__0_else statements, 224 two-way selections, 194–195 understanding and fixing, 85–88 syntax rules, 34, 89 system programs, 5 system-provided header files, 684, 757 1677 T tab escape sequence (\t), 78, 79 tableType data type, 574 tail recursive functions, 1042 target, 1269 tax member, 611 temp array, 963 temperature variable, 208 temp formal parameter, 852 tempHouse variable, 612 template instantiations, 971 template reserved word, 967 templates, 774, 902, 967–978 class templates, 967, 969–971 function templates, 967–969 tempNum variable, 87 temp object, 1330–1331, 1334 temporary queue, 1246 tempRect object, 917 tempRect variable, 924 temp variable, 939, 1293 temp1 vector, 1513, 1517 temp2 vector, 1513, 1517 terabytes (TB), 6 terminate function, 1028 ternary , 221 testAddress class, 881–883 testA_0_h header file, 758–759 test class, 907 testCopyConstr function, 852 testExp() function, 836 testFunc function, 835 test function, 410 test_0_h header file, 758–759 testScore member, 614 testScore parameter, 379 testScore variable, 173, 233–234, 290 testTime function, 659 test1 variable, 173 test2 variable, 173 test3 variable, 173 test4 variable, 173 test5 variable, 173 text editors, 9, 11 TextPad, 162 t global variable, 401 this pointer, 931–932, 938 overloading, 907–911 this reserved word, 907 three class, 757 three function, 401 throwing exceptions, 1003–1004, 1013–1025 throw reserved word, 1004 throw statement, 1003, 1006, 1013, 1022 time-driven simulations, 1234 time function, 282 timeZone variable, 738 title parameter, 1142 t member, 490 tokens, 35–36 tolerance variable, 146 tolower function, 348 top-down design, 20 top function, 1176, 1192, 1194, 1486 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Index topological ordering, 1433 top operation, 1166–1168 totalAverage variable, 18–19 totalNumOfBoxesSold variable, 274–275, 277 totalSaleByPerson function, 633–634 totalSaleByQuarter array, 628, 633–635 totalSales variable, 16 totalScore variable, 425 totalVotes variable, 1326 toupper function, 348, 350–351, 1537 trailCurrent pointer, 1108–1109, 1111, 1113, 1122, 1371, 1375 transaction time, 1234–1235 transactionTime function, 1241 transactionTime variable, 1235, 1237–1238, 1244–1245 transform function, 1492, 1535–1537 transistors, 3 traversal algorithms and binary trees, 1383–1386 treeHeight function, 1363 treeLeavesCount function, 1364 treeNodeCount function, 1363 treeRoot object, 1386 TRUE named constant, 476 true reserved word, 40, 196 try blocks, 1002–1003, 1005–1006, 1010, 1022, 1027 try/catch blocks, 1002–1009, 1013, 1028, 1031 tTime parameter, 1244 tuitionRate variable, 789 Turbo Pascal, 774 t variable, 403, 489–490 two class, 757 two-dimensional arrays, 560 accessing components, 561–562 column processing, 565 declaring, 569, 573–574 dynamic, 836–839 entering elements, 839 enumeration types, 563–566 indexes, 561–566 initialization during declaration, 562–563 initializing, 566 outputting elements, 839 passing as parameters to functions, 568–571 passing by reference, 568–571 printing, 566–567 processing, 564–566 row order form, 569 row processing, 565 single-element processing, 565 storing in memory, 569 table-form data, 560 two formal parameter, 912 two function, 912 two local variable, 912 two value parameter, 395 TWO variable, 758, 759 two-way selections, 192–196 _0_txt extension, 162 type casting, 51–53 type conversion, 51–53 Type data type, 959 typedef const_iterator iterator, 1478 typedef const_reference iterator, 1478 typedef const_reverse_iterator iterator, 1478 typedef difference_type iterator, p1478 typedef iterator, 1448–1449, 1477–1478 typedef pointer iterator, 1478 typedef reference iterator, 1478 typedef reserved word, 475, 574 typedef reverse_iterator iterator, 1478 typedef size_type iterator, 1478 typedef statement, 475–476 typedef value_type iterator, 1478 Type formal parameter, 967 type name, 681 typename keyword, 967 U u member, 490 unary operators, 45 overloading, 937–943 underflow, 1178 underflow_error class, 1010 undirected graphs, 1405–1408 Unicode, 7 Unified Modeling Language (UML) diagram, 654 union, 1405 unique_copy algorithm, 1492 unique function, 1468, 1472, 1492 Universal Automatic Computer (UNIVAC), 3 University of Pennsylvania, 3 UNIX, end-of-file marker, 286 unorderedArrayListType class, 872, 875–879, 972, 975, 978, 1320 bubble sort algorithm, 1289–1290 function templates, 976 unorderedLinkedList class, 1085, 1091, 1097–1106, 1138, 1266, 1313, 1410 queue derived from, 1232–1233 stacks derived from, 1200–1201 unordered linked lists, 1085 deleting nodes, 1100–1104 elements unordered, 1085 header file, 1105–1106 inserting first node, 1099–1100 inserting items, 1086 inserting last node, 1099 searching, 1098–1099 unordered lists, 868, 872, 875–879 inserting item, 875–876 length, 876 removing item from, 877 replacing items, 877–878 traversing, 1104 unorderedListType class, 1105–1106 unordered sets, 879 unorderedSetType class, 879 unorderLinkedList class, 1139 unsetf stream member function, 145, 154 unsigned char data type, 38 unsigned int data type, 38 unsigned long data type, 38 unsigned long long data type, 38 unsigned short data type, 38 unwinding stack, 1028–1031 update function, 1386 updateServers function, 1244–1245 updateVotesByRegion function, 1323 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Index | updateWaitingQueue function, 1246–1247 upper_bound algorithm, 1491 upperSublist sublist, 1299–1306 The United States Census Bureau, 3 usCoins variable, 475 user-defined data types, 38, 466–475 user-defined exception classes anonymous object of, 1014–1015 error messages, 1015 throwing exceptions, 1013–1021 user-defined functions, 350–351 order in programs, 358 scope of identifier, 397–401 value-returning functions, 351–375 void functions, 351, 376–382 user-defined header files, 684, 757 user-defined identifiers, 36 user-defined variables, 161 using namespace statement, 85 using reserved word, 81 using statement, 486–489 u variable, 490 V validSelection function, 478–479 value parameters, 378, 382–384, 406–408 class objects as, 659 formal parameters as, 856–857 memory allocation, 388–397 not passing results to calling function, 384 value-returning functions actual parameter list, 354 assignment statements, 351 calling, 353–354 data types, 353 formal parameter list, 353–354 function prototypes, 358–360 function stub, 412 local declaration, 355 output statements, 351 as parameter in function call, 351 reference parameters, 397 returning value, 360–361, 374 return statements, 351, 354–355, 361, 397 return type, 353 syntax, 353 using value, 351 values functions unable to return value of type array, 538–541 ordered set of, 467 tracing through sequence, 61 val value parameter, 395 varChar variable, 134 variables, 33, 56–57 allocating, 824–825 arrays, 524 assigning value to, 57–61 auto declaration, 22 automatic, 409–410, 698 changing value, 68–69 as class members, 650–651 data types, 42–43, 61, 468 declared within block, 409 1679 declaring, 42–43, 56–57, 61, 81, 83, 92, 194 declaring and initializing, 62–63, 549–550 declaring when defining enumeration type, 474–475 dynamic, 824–827 incrementing and decrementing values, 70–72 initializing, 58, 66–69, 418 input stream, 125 int data type, 812 invalid data, 998 memory allocation, 54–57, 388, 409 naming, 57 not initialized, 224, 669 output stream, 125 passed by reference, 658 passed by value, 620, 658 protected, 872 putting data into, 57–61 reading string into, 156–157 simple data types, 125–127 standard input device, 63–66 static, 409–410, 698–704 storing value in, 43, 468–469 string data type, 203–204, 558 using value without initializing, 67 using without declaring or initializing, 213 vecCount container, 1446 vecItr iterator, 1525, 1528 vecList vector, 1497, 1503–1505, 1523, 1525, 1527–1528 vecList vector container, 1444, 1446, 1450, 1456–1457 vector class, 1443–1449 vector containers, 1455, 1478 bidirectional iterators, 1476 declaring iterator, 1448–1449 first element 0 (zero), 1445 manipulating data, 1445–1447 number of elements in, 1446 processing elements, 1450–1452 vector header file, 1443 vector objects declaring, 1444–1445 initializing during declaration, 1461 inserting element, 1449–1450 multiplying each element by 2, 1459 range-based for loops, 1459–1461, 1473 vector sequence container, 1443–1449, 1454 vertex component, 1409, 1420 vertices, 1405, 1406 adjacent, 1407 adjacent from, 1407 adjacent to, 1407 component, 1407 connected, 1407 cycle, 1407, 1408 depth first ordering, 1414–1415 incident, 1407 labeling, 1410 loops, 1407 simple paths, 1407 source, 1418 weight of the edge, 1418 virtual destructors, 859 virtual functions, 774, 854–856, 859–860 virtual reserved word, 854 visited array, 1415 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.
Index visit pointer, 1384 Visual Cplus_plus 2012 Express, 11, 688 Visual Studio 2012, 11, 688 Visual Studio _0_NET, 162 vList vector, 1499–1500 void functions, 351, 376–382, 660 function stub, 412 volume, 774–775 volume function, 744, 747 volume variable, 148–149 von Leibniz, Gottfried, 2 von Neumann, John, 3 votesByRegion array, 1326 votesByRegion variable, 1329, 1332 W wages variable, 193, 235 waitingCustomerQueueType class, 1245–1247 waiting customers queue, 1245–1247 waitingCustomersQueue variable, 1249 waitingTime variable, 1235, 1237 walk-through, 61, 69 weight, 1418 weighted graphs, 1418 weightedGraphType class, 1419–1420 weighted tree, 1427 weightFound array, 1420–1424 weight of the edge, 1418 weight of the path, 1418 weight reference parameter, 1056–1059 weight variable, 66, 141, 197 w global variable, 401 what function, 1009–1011, 1015, 1017 while loops, 267–295, 1054, 1213, 1215 binary search algorithm, 1271, 1274–1275 body, 267, 269, 271 break statement, 311 continue statement, 313 counter-controlled, 272–275, 316 decision maker, 267 empty or null, 270 EOF-controlled, 284–290, 317–318 equivalent to for loops, 301–302 expressions, 267, 269, 271, 290–291 Fibonacci number, 291–295 flag-controlled, 281–284, 290 flow of execution, 267 immediately exiting, 311–312 iterations, 269 loop condition, 308 loop control variable (LCV), 270–271 loop entry condition, 267, 271 nesting, 278 never executing, 308–309 positive numbers, 312 repeating statements, 267–268 search algorithms, 1277 sentinel-controlled, 275–281, 316 sequential search algorithm, 1268 while reserved word, 267 white spaces, 37, 126 extraction operator (>>), 130, 156 inputting, 134 width variable, 19, 33, 742, 744, 746, 749–750, 752, 913, 917 winCount1 variable, 478 winCount2 variable, 478 Windows 8, 5 Windows console environment, 286 winLoc variable, 1333–1334 winningObject function, 478, 482 Wordpad, 162 Wozniak, Stephen, 3 wrappingCostPerSquareFeet variable, 752 writeTotal function, 583, 584–585 X x x x x x x array, 534–535 catch block parameter, 1003 formal parameter, 967 member, 490 object, 907 variable, 57, 61, 71, 94, 211, 221, 409–410, 656, 700–704, 814–815, 824, 881, 1461 Y y alias, 881 yard object, 752–753 y array, 534–535 yearBuilt member, 611 yearToDatePaid variable, 622 y formal parameter, 967 y object, 907 yourClock object, 655–658, 662, 667, 669, 672, 902, 907 yourList array, 531–532, 537 yourList variable, 542 yourRectangle object, 911, 917–918, 922, 929–930, 938 yourTime object, 677 y private static variable, 699–700 y static member variable, 700, 703 y variable, 57, 61, 71, 94, 211, 221, 410, 656, 700–704 Z zeros variable, 304–305, 418–419 zettabytes (ZB), 6 z variable, 221, 656 Copyright 2015 Cengage Learning.
All Rights Reserved.
May not be copied, scanned, or duplicated, in whole or in part.
Due to electronic rights, some third party content may be suppressed from the eBook and/or eChapter(s).
Editorial review has deemed that any suppressed content does not materially affect the overall learning experience.
Cengage Learning reserves the right to remove additional content at any time if subsequent rights restrictions require it.