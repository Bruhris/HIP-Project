Hansen All rights reserved.
ISBN 978-1-304-66105-0 Rook's Guide Press 19 Black Road Berlin, VT 05602 http://rooksguide_0_org November 2013 Preface What you are reading is the ﬁrst of what I hope to be many everimproving iterations of a useful Cplus_plus textbook.
We've gone fairly quickly from whim to print on an all-volunteer basis, and as a result, there are many things that I'd add and change if I had an inﬁnite amount of time in my schedule.
Some of it is mine, and some was added by our crack team of technical editors as we translated sleep-deprived poor grammar into sleep-deprived beer grammar.
If there's a section that's missing or in need of clariﬁcation, please take a bit of time and make those changes.
If you don't want to bother yourself with the GitHub repository, send me your additions and modiﬁcations directly.
I want to ﬁrst thank my family for the time I didn't spend with them on the writing weekend and throughout the summer when I was editing and typeseing.
I promise I won't do this next summer.
My next thanks go out to the technical editors and typeseers, without whom you would have a much uglier book.
I also thank Craig Robbins iii and Levi Schuck, who, on diﬀerent sides of the planet, managed to contribute extensively to the heavy liing of geing the book into the shape it's in now.
If we ever meet, I owe you a beer or whatever you're having.
I also would like to thank all of the Kickstarter backers not only for the money which made this possible, but for reinforcing the idea that this is a worthwhile contribution to the community.
Peter Stephenson and Andrew Pedley also contributed food directly over the textbook writing hackathon weekend, and without them we'd never have goen our saturated fat quota.
It didn't anks to Ma Russo for shooting the video and organizing the media and social networking eﬀorts with the Kickstarter project through the writing weekend.
Special thanks to Allyson LeFebvre1 for the textbook photography, several diagrams, and the extensive search through the semiﬁnal textbook that turned up a bunch of mistakes that I missed.
And my last (and not at all least) thanks go out to all the students who showed up in person or digitally.
And without geing too grandiose, you remind us all that we can make the world beer by showing up.
Keep showing up.
Jeremy jeremyhansen@acm_0_org 26 November 2013 1 at's "la-fave", everyone Contents 1 History 1 2 Variables 2_0_1 How do I decide which data type I need.
Review estions Review Answers.
Hansen (jeremyhansen@acm_0_org) is licensed under a Creative Commons Aribution-NonCommercial-ShareAlike 3_0_0 Unported License, as described at http://creativecommons_0_org/licenses/by-nc-sa/3_0_0/legalcode xi Dramatis Personæ Managing Editor: Jeremy A.
Hansen, PhD, CISSP Technical Editing & Typesetting: Jeremy A.
Hansen Ma Jadud, PhD Craig D.
Robbins eodore M.
Levi Schuck Media & Outreach: Mahew E.
Russo Cover Art & Graphic Design: Allyson E.
LeFebvre Content Authors: Tyler Atkinson, Troy M.
Dundas, Connor J.
Fortune, Jeremy A.
Hansen, Sco T.
Heimann, Benjamin J.
Jones, Michelle Kellerman, Michael E.
Kirl, Zachary LeBlanc, Allyson E.
LeFebvre, Gerard O.
McEleney, Phung P.
Pham, Megan Rioux, Alex Robinson, Kyle R.
Robinson-O'Brien, Jesse A.
Rodimon, Matthew E.
Russo, Yosary Silvestre, Dale R.
Stevens, Ryan S.
Sutherland, James M.
Verderico, Christian J.
Vergnes, Rebecca Weaver, Richard Z.
Wells, and Branden M.
Funding & Support: Peter Stephenson, PhD, VSM, CISSP, CISM, FICAF, LPI at the Norwich University Center for Advanced Computing & Digital Forensics Andrew Pedley at Depot Square Pizza xiii Kickstarter contributors: Nathan Adams, Chris Aldrich, Jay Anderson, Kent Archie, Erik Arvedson, Astrolox, Phoebe Ayers, Papa Joe Barr, Julia Benson-Slaughter, Georgia Perimeter College, Patrick Berthon, Francis Bolduc, Greg Borenstein, Patrick Breen, Igor Bronshteyn, Valdemar Bučilko, Ross Buckley, Nikita Burtsev, Jakob Bysewski, David Camara, Dave M.
Campbell, Brian V.
Campbell III, S.
Canero, Serge Canizares, Andrew Carlberg, Casey B.
Cessnun, Winston Chow, W.
Jesse Clements, Greg Crawford, Sean Cristofori, Jordan G Cundiﬀ, Michael David, Joseph Davies, Ashley Davis, David C.
Dean, DJS, Carlton Doc Dodd, Phil Dodds, Dominic, Sankar Dorai, dryack, Ma DuHarte, Brandon Duong, Van Van Duong, Daniel Egger, Chris Fabian, Jorge F.
Falcon, Tek Francis, Fuchsi, Steve Gannon, Michael Gaskins, Gavlig, Adam Gibson, Russell E.
Gibson, Goldenwyrm, James Green, Brian J.
Green, Casey Grooms, Vitalik Gruntkovskiy, Vegar Guldal, Felix Gutbrodt, Jeremy Gwinnup, Beau T.
Hahn, Paul R.
Harms - Norwich 1975, Corey H.
Hart, MBA, Aaron A.
Haviland, Josh Heﬀner, Greg Holland, Henry Howard, Mark V Howe, Ivaliy Ivanov, Ma Jadud, Joseph Jaoudi, Tim R.
Johnson, Ibi-Wan Kentobi, Mark King, Mitchell Kogut III, Sigmund Kopperud, Michael Korolev, Jamie Kosoy, Aria Kra, Alexander Týr Kristjánsson, Richard Kutscher, Eric Laberge, John Lagerquist, Philip Lawrence, Mark Brent Lee, John and Nancy LeFebvre, Nevin :-) Liber, Jonathan Lindquist, omas Lockney, Stuart A.
Pedro Maciel, Troels Holstein Madsen, William Marone, Fred Mastropasqua, Miles Mawyer, michael mazzello, Ryan McDonough, Matthew McFadden, John McIntosh II, Sean McNamara, mdsaravanan, Brandon Meskimen, Andrew Mike, G_0_F.
Miller IV, Marcus Millin, Salvador Torres Morales, Danny Morgan, Ken Moulton, Aaron Murray, mvi, Jon Nebenfuhr, Philip K.
Nicholson, chris nielsen, Pontus Nilsson, Mike Noble, Aleksander R.
Nordgarden-Rødner, Greg O'Hanlon, Doug Oo, Randy Padawer, Ph_0_D_0_, J Palmer, Tasos Papastylianou, Paul, James Pearson-Kirk, Mahew Peterson, Grigory Petrov, pezmanlou, Joachim Pileborg, Kyle Pinches, pkh, Mary Purdey, Marshall Reeves, Mahew Ringman, Craig D.
Robbins, Antonio Rodriguez, Armando Emanuel Roggio, Victor Suarez Rovere, Christian Sandberg, Jaymes Saler, Paolo Scalia, Patrice Scheidt, Daniel Schmi, Levi Schuck, Raman Sharma_Himachali, Michael Shashoua, Daniel Shiﬀman, Clay Shirky, sillygoatgirl, Kevin J.
Slonka, Brian Smith, Hazel Smith & Rebecca Twigg, Andrey Soplevenko, Kasper Souren, Derek A.
Spangler, Speckman, Kellan St_0_Louis, Nick Stefanou, Steve, Andrew Stewart, Jeremy Sturdivant, Cyrille Tabary, Adam 8T Tannir, M Taylor, Telecat Productions, Aron Temkin, Mitchell Tilbrook, Nathan Tolbert, Devin M.
Tomlinson - Vermont Born, Todd Trimble, Michiel van Slobbe, James A.
Velez, Marco Verdecchia, David Walter, Lothar Werzinger, Wayne West, Sean Whaley '05 & M'08, Mark Wheeler, Tommy Widenﬂycht, Dylan Widis, Tony Williamitis, Adam M.
Williams, Stephen D.
Williams, Dylan Wilson, Wesley Wiser, wizzy, Sam Wright, Janet Hong Yam, and Jy Yaworski.
Chapter 1 History Developed by Bjarne Stroustrup, Cplus_plus has become one of the most popular programming languages in the world.
Originally, it was designed as an improvement upon the C language, which was developed by Bell Labs.
Developed in the early 1970s, C's name is derived from the B programming language, which in turn was derived from the BCPL language.
C gained a large following, in part due to its use in the development of the UNIX operating system.
Due to both its popularity and the commiee was formed in 1982 to create a standard for the C language, which was adopted in 1989.
Stroustrup began with the idea that object oriented programming would be an important addition to C, and created C with Classes.
In 1983, Stroustrup's contributions oﬃcially became known as Cplus_plus, its name stemming from C and adding the plus_plus (increment) operator.
It wasn't until 1998 that the international standard for Cplus_plus was established.
Since then, most changes have been minor.
In 2005, a report was released by the ISO on features that were intended to be included in the next version of Cplus_plus.
In this book, we'll favor older techniques, pre-Cplus_plus11.
When Cplus_plus11 features are discussed, they will be pointed out as such.
While not all of the new features are discussed, we will be trying our best to explain them as we go.
Very simply put, a variable is a space in memory that can store some range of values.
Some of the basic data types are shown in Table 2_0_1.
For a deeper discussion of data types, refer to Chapter 9.
How do I decide which data type I need.
What you can do with a variable depends on the type of data they contain.
For instance, you can't store the number 100000 in a char because a char stores only character data.
To store 100000 the programmer should use an int.
If you think you are dealing with numbers that have fractional parts, you need at least a float.
You generally want to use the smallest variable type that will get your job done.
Simply put, if it is a round number, int works ﬁne; if it's a true or false, use bool; for a leer, use char; for fractional numbers, use float; for a really big number or a number with many digits aer the decimal point, use double.
How do we have the program diﬀerentiate between multiple ints, chars, or doubles.
An identiﬁer can be almost anything you'd like, provided the identiﬁer does not begin with a number or symbol_0_1 Remember that the variable name can only be one word long.
You may use a an underscore to replace a space if you so desire, and note that Cplus_plus is case sensitive.
A declaration is the A declaration for an integer variable named myVariable looks like this: i n t myVariable ; e speciﬁc syntax—the set of grammatical rules for the language—is important to follow when declaring variables.
Notice that the ﬁrst part (int) is the data type of the variable.
You can think of the semicolon in Cplus_plus as equivalent to a period at the end of a sentence; 1 ere are a few exceptions, including those words that describe data types (as in the table above) and other keywords such as if and while, which you'll learn about in later chapters.
Note that you may declare several variables of.
To do this, the variable's name is followed by an equals  (=, the assignment operator), the value, and  semicolon.
Consider this example: int  = 20; double  = 2.
When  variable is declared, it contains whatever was already in that space of memory, which can give them unpredictable values.
All assignment statements have the variable being assigned the value on the le side of an equals  and the value to assign on the right side.
Note that the expression on the right side of the assignment may contain arithmetic operations such as multiplication, division, addition, and subtraction, or even other variables.
Consider the following example:.
Declare two variables of type int and initialize them to an appropriate value.
Declare three integer variables: sum, ,.
Initialize the variables  and to an appropriate integer and use an assignment statement to assign sum the result of  plus.
Declare  double variable called number and initialize it to 13_0_6.
Create  program in which 3 variables are declared.
Create one float named myFloat, one int named myInt, and one double named myDouble.
Literals and Constants 3_0_1 Literals A literal is  value outside of  variable such as 5, 9, 103, and −21.
Each of those is an int, but  literal can be of any data type.
In other words, you can't convince the compiler to give the literal 3 the value of 4, because 3 is constant.
Table 3_0_1 contains  few examples.
Aer you declare constant, you are unable to change it, no maer what.
Since it is  constant, we will also need to initialize the value at the time we declare the variable.
Here is an example (we cover the cout object shortly in Chapter 5): const f l o  t  = 3.
Describe the diﬀerence between literals and declared constants.
When would declared constant be more useful than  literal constant.
What is the diﬀerence between  normal variable and  constant.
Build  program in Cplus_plus that does the following: () Declare  double variable named Feet.
Initialize it to your height.
Set it to Feet multiplied by MetersPerFoot.
Create  program that displays the diameter and  of  circle for any given Use  const float to represent π.
A literal is  value not stored in  variable;  constant is an unchanging value stored in  variable.
Normal variables can be changed or overwrien; constants cannot be changed or overwrien.
Chapter 4 Assignments Assignments are  way for  user   programmer to assign  value to  variable.
In mathematics we are allowed to say that  = 3  3 = , but in Cplus_plus the only acceptable way to assign the value of 3 to  is to type  = 3.
Here are some examples of seing  value to diﬀerent types of variables:.
We are able to declare variables and assign  value to those variables immediately by using the assignment operator.
When we assign literal values to variables of type char, the value must be surrounded by single quotes (for example, 'A').
When we assign values to variables of type string, the literal value must be surrounded by double quotes (for example, "Alpha").
We do not have to initialize the values of the variables, however.
We can set them later in the code like this: i n t  ; / / some c o d = 0 ;.
In all of the lines of code in this section where  variable is set using the assignment operator, the "thing that is being given  value" is known as an lvalue,.
For example, if 2 had  value of 6, would then be assigned to the value 6 with the above code.
We can also store the results of an arithmetic expression in  variable like this: = 5 + 6 ; / /  s s i g n s   v  l u  o f 11 But we can't write 5 + 6 =  ; / / ERROR.
Make sure that the variable , the variable 2, and the literal 4 are of the same type.
For example, the following code will result in an error:.
When we try to combine diﬀerent variable types, the compiler will get very mad at us.
Some exceptions to this rule are if we try to combine floats, ints, because they are all numeric values.
Both doubles and floats can hold values with  decimal point such as −3_0_14, 0_0_003,  5_0_167289 whereas an int can only hold round values such as 2, −18,  100.
Refer to Chapter 9 for more information on converting between data types.
Which of the following is an incorrect way to assign  value to  variable.
When we store  value in  variable, the variable goes on the le of the assignment operator, and the value being stored in that variable goes to the right of the assignment operator.
String literals must be surrounded by double quotes, not single quotes; single quotes are used for single characters like 'b'.
Chapter 5 Output Output in Cplus_plus is done with the object cout ("console output").
For example, if we wanted to prompt the user with Type in your name: we would use cout.
Let's make  program that outputs something to the screen: # include <iostream > u s i n  namespace s  d ;.
In this case, we are displaying  string literal "Go Cadets_0_".
As you know, every statement in Cplus_plus ends with  semicolon, and this one is no exception.
What if we want to print more, though.
Try to compile and run that.
It works, but it's not really the desired output.
How do we get those on  diﬀerent line.
One of the ways we can do it is to use the object endl.
You will also need another redirect operator between the string literal and the endl.
Puing all of this together looks like this: # include <iostream > u  i n  namespace   d ;.
Alternatively, we can combine the two lines that use cout into  single one like this: c o u  << " Go C  d.
Another thing we can use with the console output object is the special character '\'.
Printing this character is the same as pressing the tab key on your keyboard, and is used for indentation and formaing.
Let' look at an example that uses the newline character, the tab character, and some text: # include <iostream > u  i n  namespace   d ;.
We don' always have to output words the screen using cout.
We can also print variables of type int, double, and float and can control the number of digits that appear er the decimal point.
For example, if we had  variable that contained the value 3_0_14159265 we might only care about the ﬁrst two numbers er the decimal point and just want to output 3_0_14 to the screen.
In the following code, the number of digits is set to 2: # include <iostream > u  i n  namespace   d ;.
Notice the use of the left ﬂag in the following code, which positions the output on the le side of the ﬁeld; the default is for the output to be on the right side: # include <iostream > u  i n  namespace   d ;.
Write several lines of code using the width() and fill() functions in a main() that prints Programming.
Write code to  the values 124, 12_0_376, z, 1000000, and strings.
What is the  of the following program.
Input When a programmer wants a user to enter data, such as the price of an item, he or she will use the cin object, pronounced "see-in", in conjunction with >>, the extraction operator in the program.
Let us look at the following code: # include <iostream > u  i  g namespace   d ;.
Please enter a value for : As a user you may want to check the value that was entered.
To do this, simply 21 add an additional  statement like this: # include <iostream >.
Do not be afraid to insert additional  statements throughout a program to check the values of variables when debugging.
If you want to have a user input more than one value, just repeat the code for each individual variable: # include <iostream > u  i  g namespace   d ;.
We can' always trust that the user will input the correct data into a variable.
For example, if a user was prompted to input an age into a variable of type int but typed the character z, the program would not behave properly because the user entered the wrong data type.
We can check for improper input like this by using the cin_0_fail() function in a conditional statement.
Look at the following code:.
Which of the following numbered lines of code are proper cin statements.
What is the redirect operator, and how is it used to process user input.
Can you use cin to store a value in a variable that already has a value.
Write code that allows the user to enter an integer value and store it in a variable.
Your code should prompt the user, receive their input, and then print their input value back to them.
Add some functionality to the code you wrote for the previous exercise.
Add two new , one char and one float or double.
Prompt the user properly for each value.
Only #2 (cin >> ;) is correct.
You do not need to to use cin statements exclusively with  statements, though it is good practice to provide adequate feedback to users.
Yes, and the previous value is overwrien.
Arithmetic One of the most important things provided by Cplus_plus is the ability to do math.
Everything a computer sees is a number.
To a computer, its ability to do math and manipulate numbers is as essential to it as breathing is to us.
Addition is still a plus sign ( + ) and subtraction is still a minus sign ( - ).
On the other hand, multiplication becomes an asterisk ( * ) and division becomes a forward slash ( / ).
To do math in Cplus_plus, you will either want a variable to store the answer, or output the answer to the user.
When you use more complicated equations, you can use parentheses to help.
Cplus_plus uses a familiar order of operations (Parentheses, Exponents, Multiply, Divide, Add, and Subtract, or PEMDAS), but without the exponent operation (this topic is covered in Chapter 17).
However, unlike in normal arithmetic, parentheses do not imply multiplication.
For 25 example, (4)(3), which we might expect to mean "4 times 3" does not mean the same as 4 * 3, the correct syntax.
Conversely, the decrement ( minus_minus ) operator decreases the value by 1.
Keep in mind that order does maer with the increment and decrement operators.
Starting with similarities, Cplus_plus and plus_plusC both increase value of C by one.
Table 7_0_1: Examples of compound assignment updates int = = / /.
Compound assignment  can decrease the amount you type  can make your code more readable.
What makes these  special is that they use the value you want to change in the operation.
For example,  += 2 is equivalent to  =  + 2.
Keep in mind the order that was used, as this becomes important with subtraction  division.
Let's say we have   ,  want to set equal to the value of  divided by the value of.
Here is some sample code using the concepts we presented in this chapter: # include <iostream > u s i n g namespace s t  ; { int  = 5 ,  = 10 ,  = 15 ,  = 20; cout cout cout cout } << << << << " " " " + − * / = = = = << << << << + − * / << << << << endl endl endl endl.
Write  statement declaring two integer variables     initialize them to 6  3, respectively.
Without changing the last line, ﬁx the following code so there will be an output of 12.
Chapter 8 Comments As  Cplus_plus programmer, comments will make your life easier.
To this end, comments are  quick explanation of the code.
Single-line comments typically come er  line of code.
For  single-line comment, simply type  double slash // at the end of the line, and follow it with whatever notes you like, preferably to explain what that line of code does.
Alternatively, the comment can start on  line of its own.
Here are some examples: i    o u   ; / / T h i s v  r i   l e was  e  l  r e / / to count something o u   =  o u   + 1 ; / / I   r e  e   s  o u   by 1 / / V  r i   l e  e  l  r e  , and i  i  i  l i z e   o p i f l o    = 3_0_14159; Multi-line comments, sometimes called block comments, are used when you have  lot to say.
Here is an example: /* * This i s *  u l  i −l i  e * comment */ / * T h i s i s  l s o  comment * / 33 Block comments do not need  star at the beginning of every line (as in the preceding example), but many programmers write it anyways, because it makes it.
Comment each line of this code: # include <iostream > u s i  g namespace s   ;.
Explain the purpose of commenting.
Why would someone else need to be able to understand your code.
Write and properly comment your own simple program.
Go back to the program you wrote from the previous question.
Add further comments that explain what's happening and share the commented code with  classmate or friend.
Ask them if they understand what's happening from just the comments.
Add comments to the following code.
Note: Save percentages in hockey are shown to three decimal places and not multiplied by 100: _0_900 instead of 90%.
Comments help you check that you know what you're doing and make sure you are doing everything that needs to be done.
Answers will vary.
Keep trying until someone else understands the code from the comments alone.
Answers will vary.
Chapter 9 Data Types and Conversion Suppose you need to carry two products across a farmyard: apples and water.
You might choose a small hand basket to carry a few apples, and a larger bushel basket to carry a large number of apples.
Similarly, you could use a one-gallon bucket or a ﬁve-gallon bucket, depending on how much water you expected to move.
In a similar way, we choose data types to describe the type of data we would like to store in a variable, and "how much" of that data we expect to store.
Every variable has a data type which describes the range of possible values that may be stored in the variable.
Additionally, the Cplus_plus11 standard provides for the long long int data type as described in Table 9_0_2.
Several of the integer types have unsigned versions, which may only contain values greater than or equal to zero.
Variables of this type will be at least as large as a double.
Type unsigned unsigned unsigned unsigned unsigned char short int long long long2 Size 1 byte 2 bytes 4 bytes 4 bytes 8 bytes Range of Values 0 to 255 0 to 65, 535 0 to 4, 294, 967, 295 0 to 4, 294, 967, 295 0 to 18, 446, 744, 073, 709, 551, 615 Table 9_0_3: Unsigned types Type float double Exponent Range 0 to 255 0 to 2, 048 long double 0 to 2, 048 Signiﬁcand Range 223 : 8, 388, 608 possible values 252 : 4, 503, 599, 627, 370, 496 possible values 252 : 4, 503, 599, 627, 370, 496 possible values Table 9_0_4: Floating point types diﬀerent ranges of signiﬁcand and exponents, as shown in Table 9_0_4.
In fact, we can use scientiﬁc notation in conjunction with ﬂoating-point variables.
Other types introduced by Cplus_plus11 Cplus_plus11 provides the cstdint library, which deﬁnes several additional types that may be convenient.
Type intmax_t int8_t int16_t int32_t int64_t Purpose e integer of maximum size supported on the platform An integer of exactly 8 bits An integer of exactly 16 bits An integer of exactly 32 bits An integer of exactly 64 bits Unsigned version uintmax_t uint8_t uint16_t uint32_t uint64_t Table 9_0_5: Data types found in Cplus_plus11's cstdint library ese types are provided in part because the basic types like int and short are not guaranteed to be of any particular size, which can cause problems when compiling the same code on diﬀerent platforms.
On the other hand, we can do the reverse conversion: int  ; double  = 2.
We refer to this as a narrowing conversion.
If we change the code slightly, we can see where problems can occur: int  ; double  = 2.
In this case, we know that we want an integer value, so we can tell the compiler to explicitly convert the doubles to ints using explicit casts, as follows: n t  = (  n t ) 3_0_3 + (  n t ) 4.
Doing this removes the warning that the compiler produces when it coerces the double to int.
At compile time, the data type of the value that is assigned determines the data type that replaces the auto type.
Some of the syntax in the second line below may be unfamiliar—for a description of what's happening there, refer to Chapter 19.
Here is an example: std : :  <int > v ; / / Create a  of i n t e g e r s v.
What's the diﬀerence between the various data types that store numbers.
If you assign the result of an int divided by an int to a float (e_0_g.
Declare a variable named  and set it to 14_0_58093.
Write code that increases  by 12_0_495.
Conditionals Conditionals are used to direct the program to diﬀerent sections of code.
In plain English, we might have a statement "If X is greater than Y, do this…" Conditionals direct the program to behave diﬀerently depending on the results of a comparison.
Several common comparison operators used in Cplus_plus are: Symbol == _0_= >= <= > < &&, and ||, or Meaning Is equal to Is not equal to Greater than or equal to Less than or equal to Greater than Less than Logical AND: e condition on the le AND the condition on the right must be true Logical OR: e condition on the le OR the condition on the right must be true Table 10_0_1: Common comparison operators 47.
An if statement looks like this: { / / Code h  r     c u t  s o n l  when / / t h  v a l u  o f v a r i a b l  i s t h  same a s v a r i a b l  2 }  keyword if is used to start the statement.
Parentheses are used to contain the conditional expression.
If the expression inside the parentheses is true, then the following expression will be executed.
However, having only one expression within a code block is the same as not having it in a code block.
For example, suppose you have some code for baking bread, like the following.
No Else Figure 10_0_1: if and else statement ﬂow of execution Except that is really the same as:.
An empty expression does nothing, and so now every bread type will have the fan on, which is not what the baker wanted.
An else statement is used when you want some code to execute in any other case where the if statement is not true.
An example of how this works is also shown in Figure 10_0_1.
An else if could also be placed er the if statement.
An else if is an additional if statement checked only when the previous if statement is false.
While else is  catch-all, else if chains an if to test for other conditions.
Multiple else if statements can be used, and they are all checked sequentially, and if necessary, an else statement can be included at the end as  ﬁnal catch-all.
Take  look at Figure 10_0_2 for  ﬂowchart example.
Here's what the three statements would look like all together: {.
Note that every conditional expression is in parentheses.
Each if must be followed by  (_0__0__0_) (with  Boolean expression inside the parentheses) in Cplus_plus.
Conditional expressions also appear in loops (discussed in Chapter 12) and switch statements.
It does the  job as many if statements, but can simplify the job when used correctly.
Here is an example: switch ( v   i  b l  ) : { case 1: / / c o d   o  x  c u   when v   i  b l  i s  q u  l  o 1 break ; case 2: / / c o d   o  x  c u   when v   i  b l  i s  q u  l  o 2 break ; default : / / c o d   o  x  c u   when v   i  b l  i s n  i  h   1 nor 2.
If variable is equal to 1 then the code following case 1: will be executed.
If it is equal to 2, then the code following case 2: will be executed, and if it is equal to neither, then the code following default: will be executed.
When there are only  few cases, if, else if, and else statements are oen easier.
However, when you get to  greater number of cases, switch statements become easier.
In switch statements, only one case's code executes, provided that each case is followed by break.
Otherwise, the program continues execution until it reaches  break statement or the end of the switch block.
With an if and else if, only one branch may be executed, and the condition in the else if is only evaluated if the condition in the if is false.
Here is some code that uses both switch and if statements.
Compiling and running the following code results in the output in Table 10_0_2.
User enters //Program start 1 2 3 //anything other than 2, or 3 Output <1> Addition <2> Subtraction <3> Compare Type the number of your desired option:  result of this addition is 9_0_3  result of this subtraction is 0_0_9 A is greater than B Not an option 1,.
When are braces ({}) needed in an if statement.
Write  program that checks which number is higher than another and prints out an appropriate message.
Bonus: Rewrite it to also check if the numbers are equal.
Braces are needed for any code longer than 2 lines following an if.
Strings Let's discuss strings.
A string is  data type typically used to hold  collection of printable characters such as words, sentences, or longer sequences.
In order to use strings in your program you must ﬁrst include the string library: # include <string > u s i  g namespace s  d ; Also note that  string, for convenience, can be treated like an array of individual characters.
When we declare variables of type string, we declare them just like we would an int, float, or double.
We can create  variable named myString of type string by doing this: # include <string > u s i  g namespace s  d ; s  r i  g myString ;.
We can store "Hello" in the string by doing the following: s  r i  g  ; c i  >> m y S  r i  g ; / / U s  r  y p  s : H    o It is also possible to use the arithmetic operator + with strings to concatenate (combine) the two strings.
If we combined one string that contained "Hello" and another string that contained "World" the connected string would then read "HelloWorld".
Alternatively,  space can be added like so: s  r i  g 1 = " H e   o " , 2 = " World " ; c o u  << 1 + " " + 2 << e  d  ; / /−−−−−−−−−−−−^−−−−−−−−−−−−−−−−−−− / / Outputs : / / H e   o World e ﬁrst two concatenates the two strings to create one string that contains "Hello World", and the third concatenates three strings to produce the same result.
When reading strings from std::cin, the default behavior is to collect all characters until the ﬁrst whitespace ( tab, space, or newline) character that it ﬁnds in the input.
For example, if the user inputs "Hello World" in the following code, std::cin stops reading at the ﬁrst whitespace, and thus the string would contain only "Hello".
If we want to read the entire line of text, we need to use the getline() function, which reads until the ﬁrst newline character.
We can also ﬁnd out the length of the string by using the member function length() with any string object.
For example, if we wanted to ﬁnd the length of  string entered by  user and store it in  variable named stringLength, we might do this:.
Figure 11_0_1: A string viewed as an array is code results in the value 5 being stored in the variable named  because the space character is stored at index 5 if you treat the string as an array, as shown in Figure 11_0_1.
Remember that we start at index 0, so even though the space is in the sixth position, it is at index 5 in the string.
When a line of text is stored in a string, think of it as being stored in memory in an array of the same length as there are characters in the string.
For example, the string "Hello World" can be contained in an array with 11 slots, therefore the space character would be found in [5].
We can also use the rfind() function to ﬁnd a character in reverse direction from the end of the string, or from some starting point, as above.
If we wanted to ﬁnd the single character string "o" before the space we might do something like this: s  r i n  m y S  r i n  = " H e l l o World " ; i n   , 2 ;.
Sometimes the string you search for cannot be found, as in this example: s  r i n  m y S  r i n  = " H e l l o World " ;.
Write code to declare a string and take input from a user.
Can a string be treated as a character array.
What is the #include needed to use strings.
What function do you have to use to take an input with a space.
Write code that takes in 5 words and outputs each of them 4 times.
Write a program that takes in an input of at least two words of the same length.
When you need to hold a collection of printable characters such as words, sentences, or longer sequences.
Loops 12_0_1 Introduction Okay, so you know how to do some programming, but now you need to be able to handle a dozen or more operations that are obnoxiously repetitive.
Imagine that you have a program that needs to allow data to be entered about your employees.
Do you really want to have to write out the code to do that for every single individual.
No—you want to set it up so you write it out as concisely as possible, and copy and paste just won' work.
What we need to do is write the relevant code once and have it repeated for us as many times as necessary.
For this, we'll use a structure known as a loop, which does exactly what you expect it would.
A loop allows you to repeat a section of code as many times as you need.
When the code reaches the end of the section, it goes back to the top of the section and the loop starts again.
Aer each repetition of the loop (which we call an iteration), it will check for an end condition that is speciﬁed by the programmer.
It's referred to as a pretest loop as it's designed to check the loop's end condition prior to a repetition of the loop.
In Figure 12_0_1, the basic model of a pretest loop is shown.
A diamond is used to represent where a decision must be made.
In this case, it's a Boolean expression.
If the expression is true, control passes to the rectangle, which represents an action (or actions) to be performed: the statements that represent the body of the loop.
When the Boolean expression is false, remember, the loop is ﬁnished.
Also, note that, like an if statement, the braces are not necessary if there is only one statement following the line with the while keyword and Boolean expression.
Is it recommended to use the braces with only one statement.
For your own sanity, and that of others reading your code, yes.
No, but some organizations' coding standards might say otherwise, because it makes the code easier to read and edit.
So remember, it's best to start with good habits early.
Let's look at an actual example of a while loop.
Well, a do-while loop is known as a post-test loop for a similar reason.
Let's take a look at the ﬂowchart in Figure 12_0_2 and take a guess as to why.
Post-test loops perform the statements in the body of the loop before it tests the end condition.
Let's look at how this will aﬀect the syntax you will use when implementing the loop.
Figure 12_0_2: Logic of a do-while loop.
In this case, the line with the while and the end condition are aer the main section of code.
In a normal while loop, the program can potentially meet the end condition before even entering the loop body, and just pass over it.
In a do-while loop, the program checks the end condition aer each iteration of the loop, so it will run at least once before the loop ends.
Event-Based Loops vs Count-Based Loops Loops can be organized into two categories based on how you use them.
Let's look at code examples to diﬀerentiate the two.
We've needed to initialize a variable that we want to check.
We've also needed an end condition to test that variable against.
Finally, we needed a way of modifying that variable to meet that end condition.
Aer that, it's whatever we've felt like puing in.
With the for loop, we put those three elements into the loop header, separated by semicolons (;).
A for loop would would look something like this: {.
You use this kind of loop to count up (or down) each iteration until you get to the speciﬁed value.
Let's run through how a for loop should run, following the code below.
Assuming everything is correct, you would initialize the ﬁrst value to something such as an int  that is set to 1.
Finally, let's say counterplus_plus is the update expression.
In each iteration (unless you also decide to change  from the body of the loop) you will move through this pretest loop four times.
Picking a Loop Which loop you use is dependent on your preferences and needs.
A for loop is nice, but it's more convenient as a count-controlled loop.
If you needed to use an event-controlled loop, you may prefer to use a while or do-while loop.
A for loop is a nice way to condense the initialization, end conditions and update statement of the loop into one short line.
When choosing between a do-while and a while loop, you should remember that with a do-while, it will always run at least once, while a while loop may run zero or more times.
Just remember to practice good formaing habits to keep the code from being too confusing.
Take a look at the example below, then let' talk our way through it.
For those readers who concluded that this is a clock simulation, you are correct.
Our system of time is set up that we have 24 hours in a day, and each hour is a 60 minute cycle, and each minute is a 60 second cycle.
Aer 60 minutes, the hour  loop is incremented.
Each time an outer loop starts another iteration, variables inside the inner loops are reset.
What will happen if you can' reach that end condition from within the loop.
Most likely an inﬁnite loop will occur, which is a loop that can' stop itself.
Depending on the operation of the loop, you may not know what is happening, and the loop could potentially cause disastrous results.
Let' look at an example of a while loop that suﬀers from an inﬁnite loop.
Create a while loop that increments some integer variable x initialized with a value of 0 by 3 until the value of x reaches a value of 30.
Make sure you declare the variable and initialize it ﬁrst.
Create a do-while loop that reads integer values given by the user into an integer variable x, initialized to 0, then adds those values onto some variable named totalVal until totalVal reaches at least 20.
Create a for loop that outputs your name to the screen 10 times before exiting the loop.
Spot the logic error and correct it in the following code: {.
Arrays An array is a series of variables that are the same of the same type (int, float, double, char, and so on).
Arrays are held in a computer' memory in a strict linear sequence.
An array does not hold anything other than the elements of the speciﬁed type, so there is no assigning an array of type float and hoping to store a string there.
Doing so would cause a "type mismatch error" and the program wouldn' compile.
To create an array, the programmer types something like this: char S c o   [ 5 ] ; e char is the data type for all elements in the array, Scott is the name of the array (you can be as creative as you want with the name), and the 5 inside the square brackets represents the size of the array.
So char Scott[5] can hold 5 pieces of data that are of type char.
When trying to visualize an array, think of a rectangle split up into as many pieces as the array has places to hold data.
In Figure 13_0_1, the rectangle has ﬁve spaces, each of type char awaiting some values.
In order to refer to the individual elements in an array, we start with the number 0 and count upwards.
We use [0] to access the ﬁrst element in the array, [1] for the second, [2] for the third, and so on.
In order to read or write certain locations of the array, we state the name of the array and the element we want to access.
It should look like this: S c o   [ 3 ] = 'Q ' ;.
To do so, you need to enclose the values of the appropriate type in brackets and separate the values with a comma.
Below are two examples, one an array where each element is of type char and another where each element is of type int.
In Cplus_plus, this is represented by the special character '\0'.
Because the null temrinator takes up one element in the array, any character array that is intended to be used as a printable string must be declared having a size one larger than the longest string that you expect to store.
Initializing the above character array should really be done as the following (notice that we make the array one element larger_0_): char S c o   [6] = { ' S ' , ' c ' , ' o ' , '  ' , '  ' , ' \0 ' } ;.
Multi-dimensional Arrays A two-dimensional array (some might call it a "matrix") is the same thing as an array, but is an "array of arrays".
Here's a two-dimensional three-by-three array: n  R  c h [ 3 ] [ 3 ] ; / / 2D Declaring arrays with more dimensions are possible with similar syntax.
Here's a three-dimensional 10 × 10 × 10 example: n  Sam [ 1 0 ] [ 1 0 ] [ 1 0 ] ; / / 3D And here is a four-dimensional 10 × 10 × 10 × 10 array.
Declare an integer array named myInt with a size of 10.
If an array has a size of 20, how many indexes are there in the array and what are they.
Declare a character array named myArray with a size of 4, and initialize the characters in the array to 'Z', 'a', 'c', and 'h'.
Create a program in which an integer array named myArray is declared with a size of 10.
Use a for loop to prompt the user to store a value in every index of the array.
Aer the array is given values, output the values of the array to the screen using a for loop.
Output each value of the array on its own line.
Blocks, Functions, and Scope 14_0_1 Blocks Since we've covered if statements and loops, let's go into more detail about the code that's contained within them.
When you need to contain multiple lines of code, we've shown how to use braces.
Take a look at the example below.
Notice the variables declared in each, y and z.
When these are declared, they are only usable within the blocks that they were declared.
When that block reaches its end, they are lost to the rest of the program.
We discuss scope further at the end of this chapter.
Functions are an important part of Cplus_plus programming.
Without them, programs would be confusing and diﬃcult to troubleshoot.
When programs are wrien, they tend to be wrien in logical chunks which we call subprograms.
Simply put, functions are like miniature programs that when pieced together form the actual program that you are trying to write.
With basic functions, your declarations should start with a return type such as double, int, and so on; this is the data type your function will return.
Aer the return type, the next item that needs to be wrien is the function's name, which can be almost anything you want.
Remember that you will be using it again later in your code, so it makes sense to make it something short and logical that you can remember.
Now that you have your data type and your function name, it's time for zero or more function parameters.
Each parameter is in turn made Function return type.
A comma separates function parameters and your declaration must end with a semicolon aer the closing right parenthesis.
Here is an example of a function declaration: / / c o s  and p r  c e a r e p a r a m e  e r s double p r o f   (    cost , double p r  c e ) ; Using a function looks much like an abbreviated version of the function declaration.
A function call is responsible for telling the compiler when and how to execute a function.
Function calls are found in another function like main().
Often the user is prompted to enter necessary data with cout statements and his or her response is collected with cin.
Once this data is collected, the program holds it until a function call is made somewhere in the code.
Once the function call is made, the compiler takes the entered data and then uses the code in the function deﬁnition (which we will go over shortly) to operate on the parameters and return a value.
For your function call, write your function name followed by the variables or values you want to pass in.
In a functiton call, it is not necessary to speciy the data types, as they are already understood.
Here is an example of a function call: # include <iostream > u s   g namespace s  d ;.
You have  declaration and  function call now.
As  result, the deﬁnition and body are also more diﬃcult to write than the declaration or call.
Multiple function deﬁnitions and bodies can be placed er your main() in no particular order, though it makes it less confusing if you use the same order as when they were declared.
Start your function deﬁnition with your function heading, which looks exactly like your function declaration but without  semicolon.
Following your heading, you need your function body.
Start your function body by placing an opening le brace ({) on the line following your heading.
Aer the code in the body is ﬁnished, you end the body with  closing right brace (}).
Notice that the semicolon is not necessary either er your heading or er your closing brace.
What goes inside the function body depends completely on what you want the function to do.
You may declare variables to be used just in your function and can leave the function using return statements at any time.
Below is an example of  function deﬁnition: // function definition { double  ; / / temporary   r   b l = price − cost ; / / c  l c u l    the  r o f return  ; / / return the r  s u l  to the c  l l   g function } Great, now that you have  grasp of the three major parts of basic functions we can move on to other related material.
Predeﬁned functions are functions that are already wrien and deﬁned.
In order to use predeﬁned functions, the programmer needs to include the necessary library and then call the function wherever they need it.
In the following example we will use the sqrt() function to calculate the square root of the user's input.
Notice that other function declarations that do return  value start with their return type such as double, int, or the like.
A common application where  void function is used is printing the result of calculations to the screen.
Syntax for void functions works in the same way as normal functions, but the keyword void is wrien where the return data type would normally go.
Note that, like other functions, there does not necessarily need to be parameters in  void function.
Here is an example of  simple void function declaration: void displayMessage ( ) ; Remember the deﬁnition and calling of displayMessage() would be the same as any other function with the exception of the void return type and that no value is returned.
Here is an example of  deﬁnition, declaration, and how this function would be called: # include <iostream > u s i  g namespace s  d ;.
Overloading Function Names Overloading function names allows the same name to be used in multiple function deﬁnitions but with diﬀerent parameter listings.
Function names can be reused using this feature.
Function name overloading eliminates problems associated with having multiple names for functions with similar purposes and can make the code both more understandable and more convenient for the programmer to write.
Below is an example of an overloaded function name.
Notice that both functions have the same name, but diﬀerent parameter types.
Scope As we dive into more complex programs there is  need for  wide variety of variables in diﬀerent locations in the code.
Some of these variables are declared within individual blocks of code, such as within loops or conditionals.
Others are declared completely outside functions.
Local variables are declared within  block of code.
A local variable is available to code from the point of its declaration through the end of that block of code.
A simple example is  variable declared in main():.
It cannot be used anywhere outside main() without some additional work (such as passing it by reference to  function).
Similarly, variables declared in other functions are not available to code in main().
If  is referenced anywhere else outside that function, the program will not compile.
An easy way to understand local variables is to compare them to your neighbors.
Everyone that lives on your street and around you are variables, and since you all share the same street, they are local.
You can think of these neighbors on the adjacent street as other functions.
While they might be close by, they do not share the same street.
Global variables are quite diﬀerent from local variables.
Global variables can be used by code anywhere within the program.
A global variable is declared outside of any function.
Using similar code as in the example above, we make the variable global:.
Both functions print the same variable, causing the program to produce the following output: 5 5 To sum it up, local variables work only within the block of code that it is declared.
Global variables are declared outside functions, and can be used at any point in the program.
What are the three parts of a function.
Can a void function return a value.
How many functions can one program have.
What is the output of the following code snippet.
Write code using at least one function that will ask the user to guess a "magic" number (of your choice) between 1 and 100 until they get it right.
Aer a guess, the program should output whether the number they guessed is higher or lower than the "magic" number.
It should also display how many guesses the user makes, and loop until the guess is correct.
Using at least one function, write code that prompts the user for a number of miles travelled and a number of hours, then calculates the user's speed in miles per hour.
Problem Solving & Troubleshooting Problem solving and troubleshooting in programming is oen referred to as debugging.
Does your program not compile.
Does it not achieve the desired eﬀect.
Debugging is your answer.
And, unless  are a perfect programmer,  are likely to do quite a bit of debugging.
Because the code is incorrect, the compiler can only guess at what  meant and give  a hint.
For example, one of the most common errors a beginning programmer will encounter is forgeing a semicolon.
In some development environments (like NetBeans in Figure 15_0_1), this will cause the error to be reported not on the line with the missing semicolon, but on the following line.
When the code is executed, however, the result is wrong.
Another common issue is misplacement of parentheses, as a misplaced parenthesis can cause problems in complex expressions.
For an inﬁnite loop to occur, the conditional expression  a while, for, or do-while loop remains true.
Figure 15_0_2: An inﬁnite loop in the NetBeans development environment.
How does it aﬀect the output  the code.
Review Answers (a) retun should be return.
Remove the unused variable cont and cout_0_unsetf lines.
Because shots and goals are both integers, the program does the math as though are looking for an int result and doesn' store the fractional parts, even though it stores the result in a double.
Change shots, goals, and  to be  type double and the program will work as intended.
Chapter 16 e Preprocessor Preprocessor directives are lines  code that are executed before the compilation the code begins.
One  the most frequently-used preprocessor directives is #include.
When we want to include in our code a system library or some other ﬁle, we use the keyword #include followed by the library name or the ﬁle name.
For example, when we want to use objects like cout or cin, we need to include the iostream library like so: # include <iostream > If we want to include a ﬁle, such as a ﬁle named myFile_0_h, we can write: However, when we include ﬁles, they must be in the same directory as the ﬁle where the #include appears.
We discuss the Standard Template Library in Chapter 23, and include a short sample  other libraries in Table 16_0_1.
Table 16_0_1: Some useful libraries and a sampling  what they provide.
Which  the following demonstrate correct syntax for # statements.
Identify the the preprocessor statements in the following code: #  <cstdlib > #  <iostream > u s i n g namespace s   ;.
Is using namespace std; a preprocessor directive.
If you want to be able to use the funtion pow(), which library do you need.
Chapter 17 Advanced Arithmetic Advanced arithmetic in Cplus_plus includes mathematics that can' be used in code without the use of the <cmath> library.
As we have seen before, some simple arithmetic might look like:.
Doing simple operations like these does not require any special libraries or unusual commands.
Any compiler can look at a +, -, *, or / in a line of code and know exactly what the programmer expects to happen.
Some math requires a lile extra help, though.
In this case, help is the <cmath> library.
Using the <cmath> library in code is as simple as including it at the top of your source code ﬁle with the rest of your libraries.
For example: #  <iostream > # i n c l u   <cmath > Aer the inclusion of the <cmath> library, you can use certain mathematical functions in your code such as pow(, y), which raises the parameter  to the 97 power of parameter y, and sqrt(z), which returns the square root of z.
In your ﬁrst few Cplus_plus programs you will probably not use the more advanced mathematical functions included in the <cmath> library, but for a full list of the functions provided in <cmath>, refer to "Further Reading" at the end of this chapter.
First, we are declaring two variables:  and.
Now we get to a more interesting section of code.
We are asking the compiler to raise the value of  plus 1 to the power of 3, add 6, and then place the result in.
To use the pow function, you must understand its syntax.
Here is the breakdown: In pow( + 1, 3) + 6, we are raising the starting value  + 1 to the power of 3.
Before the power of 3 is applied, 1 is added to.
In this case it is the simple operation of 4+1, which yields 5.
Aer we get 5, we raise it to the 3rd power to get a value of 125.
Aer we reach the value of 125 we are ﬁnished with the pow function and resume using normal operators when we add 6 to 125 resulting in the ﬁnal value of 131.
Undoubtedly there are more complicated uses of the pow function, such as multiple uses of pow in the same line of code.
You might use multiple pow operations in code that calculates the length of one side of a triangle using the Pythagorean eorem.
Look at the following code and see if you can ﬁgure out what the output value would be:.
For visual reference,.
Since sqrt returns  double, you should usually assign the result to  double variable, but in this example, sqrt returns exactly 5, so it is implicitly converted to an int without any issues.
When writing such code, it is very important to keep track of the parentheses and to use correct syntax.
One such syntax mistake is made when programmers think that Cplus_plus syntax is the same as algebraic syntax.
When the compiler sees this, it doesn' view it as multiplication, but instead as (according to  professional), "function shenanigans_0_" It is important to be explicit with mathematical symbols in Cplus_plus.
So instead of the incorrect code above, use: i n   = 5 * ( pow ( 3 , 3 ) ) ;.
Which #include library is needed to use advance arithmetic operators.
Write Cplus_plus code to calculate 29.
Write  statement to set the value of  variable of type double to the square root of 10001.
Complete the code below to ﬁnd the length of the hypotenuse of  right triangle (remember that 2 + 2 = c2 ) given the lengths of the other two sides.
What is the ﬁnal output of your code.
Chapter 18 File I/O File I/O refers to the input and output (I/O) from and to ﬁles.
So far we have been using cin to get input from the keyboard and cout to output to the screen.
Just like output can be sent to the screen, output can be sent to  ﬁle.
Input can be taken either from  keyboard or from  ﬁle.
Input and output is handled in the program through objects called streams.
File I/O is useful because ﬁles provide  way to store data permanently.
With keyboard input and screen output, the data is temporary and goes away once the program is ﬁnished.
When it comes to ﬁles, the data is there for us and we do not have to waste our time typing it over and over again.
If data is ﬂowing out of the program it is called an output stream.
We have actually been using both types of streams already.
If an input stream object is connected to  ﬁle, then the program can get its input from that ﬁle.
Similarly, an output stream object can send data to the screen or to  ﬁle.
A ﬁle can be opened for both reading and writing, in which case it can be accessed by both input and output streams.
File I/O When the program opens  ﬁle for input, the program is reading from the ﬁle.
When the program opens  ﬁle for output, the program is writing to the ﬁle.
Cplus_plus provides us with the ifstream, ofstream, and fstream classes for reading from and writing to ﬁles.
All of these classes are available through the fstream library, which means we must #include it in our code in order to use them: # include <fstream > e ofstream type (read that as "output file stream") is used to write data to ﬁles.
Objects of type fstream ("file stream") can combine the behavior of ifstream and ofstream and allow us to both read from and write to ﬁles.
However, in order to use ifstream, ofstream and fstream objects, you must declare one like you would any other variable.
Declaring these objects looks like this: / / D e  l   e s  v   i   l e o f   p e i f s   e  m named i n p u ifstream inFile ; / / D e  l   e s  v   i   l e o f   p e o f s   e  m named o u  p u ofstream outFile ; e variable inFile will deal with geing input from  ﬁle, while the variable outFile will deal with outpuing data to  ﬁle.
Every ﬁle on  computer has its own name and  location (or path).
An example of  text ﬁle name is TextFile_0_txt and its location in  Windows operating system might be :\storage\TextFile_0_txt.
In  UNIX-based operating system, the same ﬁle might be in /home/user1/TextFile_0_txt.
Regardless of the operating system, we need to know the ﬁle's path in order to tell the program where to ﬁnd the ﬁle.
In order to open  ﬁle you must ﬁrst make an object of type ifstream, ofstream, or fstream just like we did earlier.
We open  ﬁle using  member function named open.
Otherwise, if the ﬁle already exists, the open function will erase existing data in the ﬁle by default.
Once you are done with the ﬁle, it is good practice to close it.
Closing the ﬁle disconnects it from the program and prevents the program from continuing to read from or write to the ﬁle.
If the program ends normally or crashes, the ﬁles will be automatically closed.
Closing ﬁles is even simpler than opening them.
All you need to do is use the close function with empty parentheses.
For example, to close both inFile and outFile: inFile.
Reading from  File We use the ifstream class to read data from  ﬁle.
Instead of having  user input data from the keyboard, we now input the data from  ﬁle.
As you recall from earlier in the book, we used cin with >>, the extraction operator.
Once we have declared our variable of type ifstream and opened  ﬁle, we can use it to input data.
Using this is very similar to cin except we replace cin with the name of our variable.
For example: # include <iostream > # include <fstream > u s i n g namespace s t d ;.
Overall, ifstream objects are very similar to cin—you just have to declare one and remember to use the variable name instead of cin.
Just like cout, ofstream objects use <<, the insertion operator.
Using this is very similar to cout except we replace the cout with the name of our variable.
For example: # include <iostream > # include <fstream > u s i n g namespace s t d ;.
Both cin and cout are objects.
An object is a variable that has functions built in and may have multiple pieces of data associated with it.
For example, the function open() (along with close() and many others) is considered a member function of ifstream and ofstream, which means it is a function that is associated with object of those two types.
Geing a lile more into detail, these object types are deﬁned as part of a class.
A class is a blueprint for complex data types.
We already know data types such as integers, doubles, and chars, but using classes, you will be able to design your own data type.
When calling the functions open or close, you will notice we use a period between the object name and the function.
We call this the dot operator and it is used to reference member functions and member variables of a class.
One example is the fail() function.
We use this function to determine whether the ﬁle was opened successfully or not.
We usually use if statements with the function so that if the ﬁle does not open correctly we can warn the user.
When we use the >> operator, spaces, tabs and newlines—the whitespace characters—around data are skipped automatically.
However with get(), nothing is done automatically, so the whitespace characters can be extracted, too.
For example: char Character ;.
Even if the next character is a space, tab, or newline, the program will store that character in the variable.
For example: char  = ' \ n ' ; / / newline c h a  a c ofstream outFile ;.
What do we call the type of object used to control data ﬂowing into your program.
What do we call the type of object used to control data ﬂowing out of your program.
What header ﬁle must you #include in order to use ifstream and ofstream.
What are ifstream and ofstream used for.
How do you declare an ifstream object named input and an ofstream object named output.
How would you open a ﬁle named TextFile_0_txt with an ifstream object called input.
How would you close a ﬁle named TextFile_0_txt with an ofstream object called output.
What kind of function is the eof() function and what does it do.
What are the beneﬁts of using ﬁles for input and output.
What is the diﬀerence between cin >> c; and cin_0_get(c); if c is of type char.
Write a program that outputs the contents of some ﬁle to the screen.
Write a program that reads in a text ﬁle and prints to the screen the of times the character '' shows up.
An input stream 2.
You need to #include <fstream> 4.
It returns true if the program has reached the end of the ﬁle.
File input and output are useful because ﬁles provide a way to store data permanently.
With keyboard input and screen output, the data is temporary and disappears once the program is ﬁnished.
Also, an input ﬁle can be used by many programs at the same time without having to store multiple copies or re-enter the data over and over again.
Pointers Pointers do just what they sound like they do.
A pointer is an address in memory.
It is declared using an asterisk following the data type: int * ptr ;  variable named  is of type int*, an "integer pointer" that stores the address of a variable of type int.
To indicate that a pointer variable is not pointing toward any usable data, we oen set its value to NULL, which is deﬁned as zero when you #include <cstdlib>: i n  * p   = NULL ;.
It "follows" the address stored in the pointer and returns whatever is in that location.
You will use this to produce a pointer 111.
D e c l a  e an i n  , s e  i   o 2 Take  h e a d d  e s s o f v a  1 and s  o  e i  i n Go  o  h e a d d  e s s s  o  e d i n  ; e  u  n the value ;   i n  i  out e output of this code is: 2 Here is a slightly longer example: int * ; i n  1 =.
Aer the fourth line is executed,  will store the address of 1.
Figure 19_0_2 shows the state of the variables.
Aer the ﬁh line of code is executed, the location where  points is assigned the value stored in 2.
Since  contains the address of 1, 1 receives that value.
Figure Figure 19_0_2: e state of the variables aer line 4 Figure 19_0_3: e state of the variables aer line 5 19_0_3 shows the state of the variables.
Use caution when declaring pointers.
If you are declaring more than one pointer in a single line, make sure to indicate each pointer variable with the * before the variable name.
Here is a correct declaration of two pointers: int * , *q ;.
Review Answers 1.
Allocating space for variables at compile time is adequate in many cases, but occasionally  program will need to allocate space for data in memory while it is running.
Consider the following code: int arraySize ; o u  << " E n  e   h e number o f e l e m e n  s i n your     y : " ;.
In order to allocate the space for myArray, the compiler needs to know how many elements make up the array so that there is enough room in memory to accommodate the array.
Unfortunately, the value of arraySize is not known until the user enters something on the keyboard er the program has started running and as  result, the compiler returns  syntax error.
In Cplus_plus, pointers are used to keep track of dynamically-allocated data: l o   *  P   = NULL ; / / ( 1 ) D e  l   e   o i n  e   o   l o   , / / which  u   e n  l y  o i n  s nowhere In order to dynamically allocate an object of type float, we use the new operator: e created object of type float does not have  name, so the new operator.
When  value is assigned to * (notice the dereference operator), the ﬂoatingpoint value at the address stored in  is changed.
In order to free up the memory properly, we use the delete operator: float *  ;.
Write code to declare an integer pointer and dynamically allocate an integer.
On the next line, assign this dynamically-allocated integer the value 13.
Given the following code, write a few lines that deallocate any dynamicallyallocated memory and set all pointer values to NULL: int int int = 20_0_2 1.
Classes and Abstraction Imagine for  second you're behind the wheel of an automobile.
You're driving along, but do you know your engine is working right if it's not making any horrendous screeching sounds.
Do you have any idea how your steering actually works when you turn the wheel.
So long as you can press down on the accelerator to move forward and the steering handles correctly, you probably don' care about the speciﬁcs of how things work.
Abstract  types (ADTs) are the automobiles of Cplus_plus, and one of the reasons Cplus_plus is known as an object-oriented programming language.
It's their job to package and obscure the information from the average user, and at the same time make their lives more convenient.
ADTs can be thought of as  group of  of different types that are treated as  single item.
For example, if we wanted to record the name, identiﬁcation number, age, graduation date, and sex of all of the students on  campus, we could create  new  type named Student with those variables.
In the following sections we will show you how to use and deﬁne two types of ADTs: structures and classes.
Points store int, float, or double variables x and y, which represent the position of the Point on the the 123.
In the example, the keyword struct is used to declare the structure deﬁnition while the identiﬁer, the word directly to the right of struct (Point), is the structure name and the name of  new  type.
However, directly er the closing brace, there must be  semicolon.
Once  structure is deﬁned, it can be used just like the  types int, char, string, and so on.
For example, we might declare  Point structure named input like this: Point input ;.
Assigning values to member variables Any variable of type Point such as the one above is  collection of two variables, and y.
Any variables contained in the struct can be accessed by combining the structure name—input in our example—followed by  symbol called the dot operator (the period, _0_) and the member variable's name.
For example, if we wanted to set  in input, we would use the dot operator as follows: input.
Classes classes are like structs except classes contain both variables and functions, whereas structs only contain variables_0_1 Also, in  struct, member variables are public by default while all members of  class are private by default.
We'll discuss the distinction more in  minute.
First, let's take  look at an actual class deﬁnition.
Notice the similar syntax to the struct.
Like  struct, the declaration starts with the class keyword, followed by the name of the class, and er the closing right brace,  semicolon.
Notice the public: and private: sections of the deﬁnition.
To indicate that  set of member variables or functions is private, we use the private keyword followed by  colon.
Everything er the keyword will be considered private.
We will discuss what this means in the next section.
On the other hand, if we want to indicate that  set  member variables or functions is public, we use the keyword public followed by  colon.
Everything er this keyword will be considered public.
A general rule of thumb is to put variables in the private: section, where they would be referred to as private member variables, and related functions in the public: section, where they would be referred to as public member functions.
Private members can only be accessed by the class's member functions and nowhere else, while public members can be used anywhere, in the same way that the members of  struct can be used.
Within the above class deﬁnition, we have seven member functions that we need to deﬁne.
Each function has  speciﬁc purpose to set the values of private member variables, return the values of private member variables, or perform some other operation using those member variables.
Functions that are declared in the above code with names starting with the word get will be used to access the variables; these functions are called accessors.
Functions that are declared in the above code that have names starting with the word set will be used to change the variables' values; these functions are called mutators.
Accessors and mutators can be named whatever you like, but it is common convention to name them get and set plus the name of the variable you are accessing or mutating.
When  Rectangle object is created, it will be initialized according to the code in this constructor.
By the end of this chapter, you'll understand how useful these are in object-oriented programming.
When we deﬁne  member function, all the member variables within the class are accessible to the function.
For example, we can deﬁne the member function setBase() from Rectangle above like this:.
In this code, we are able to directly access the member variable  because both the function setBase() and the member variable  are  part of the class.
Since we are not returning anything to the user, the function is deﬁned as void function.
In order to deﬁne  member function, we have to use  special operator called the scope resolution operator (::).
We do this by requiring them to pass a value to the mutator member function which sets the member variable.
In the above code, we start by creating a Rectangle variable named r.
Aer the user is prompted for the length of the base, which is stored in the variable b, we call the setBase() member function with the dot operator and pass b as a parameter to the function.
To retrieve the value of a member variable, we need to create accessor functions.
When it comes to using accessors, it is very simple.
Just match the  type that you want to access, in this case it was a float, and deﬁne the member function with that return type.
For example, if we wanted to take in three points we could create a Triangle class with these points which are individually of type Point, a struct that contains  and y variables:.
Here we have the ability to combine a struct with a class in order to have all three points, a, b, and c that each contain their own variables  and.
Despite the fact that the variables in the struct are public, we cannot access those speciﬁc values outside the Triangle unless we use a member function.
If we had a mutator function for Point a, it might look like this:.
A constructor is a member function with the same name as the class and cannot be called directly.
Constructors are what we use to initialize the variables of the class when it's ﬁrst created.
For example, if we wanted to set default values for a class named student deﬁned as: class student.
Overloading Member Functions Note that, like other functions, you can overload any of the functions in a class.
Going back to the Rectangle example used earlier, take a look at the following code.
Create a class called Animal that can store information about animals in a zoo and has the following private variables: s  r i n g  ; / /  h e  o f  h e a n i m a l i n  pounds ; / / number o f pounds o f f o o  e a  e n char animalType ; / / the type of animal : / / 'h ' for herbivore // 'c ' for carnivore You should have public member functions that get and set each variable, and a function called print() that prints all the information about the animal.
Write a program that can calculate the slope of a line.
You will have a struct called Point which contain the following variables: double  ,  ;.
Point a , b ; Your class should have accessor and mutator functions, a function that calculates and returns the slope of a line between the two Points as a double, and a function that outputs the data to the user called print().
Only (a) is correct: (b) through (e) will result in syntax errors.
Separate Compilation Separate compilation is the process of breaking a Cplus_plus program into separate ﬁles to improve organization.
Parts of the program can be spread out over a number of diﬀerent ﬁles that are later compiled individually, then linked using a linker to produce the ﬁnal, working program.
When changes are made, only those ﬁles with changes need to be recompiled, the result of which can then be relinked with the previously-compiled ﬁles.
When the development environment takes care of these details, the user is le with the sole task of making changes where they are needed.
One of the most basic applications of separate compilation is used when writing abstract data types.
Recall from Chapter 21 that there are declaration and deﬁnition sections in a class.
Declarations will be put into the interface ﬁle or the header ﬁle which typically has a _0_h suﬃx.
In most code wrien by novice programmers, there will be only one class declaration in each header ﬁle.
To use the class in your code elsewhere, you should use #include followed by the ﬁle  in double quotes.
Below is an example of the contents of an interface ﬁle called student_0_h.
For example, the  ﬁle for student will probably be student_0_cpp.
To ensure that a new  ﬁle is compiled into your program, you do not need to #include anything.
However, the development environment will automatically compile and link the  ﬁle if it has been added to your project.
To avoid linker errors, your ﬁles should have safeguards to ensure that classes and functions are not declared more than once within the same program.
For example, we place the following two lines at the top of the ﬁle student_0_h: # i f n  e f STUDENT_H / / STUDENT_H c o u l  be a n y t h i n g #  e f i n e STUDENT_H / / a s l o n g a s i t i s u n i q u e t o t h i s f i l e e following line should go at the end of the same ﬁle: # e n  i f / / STUDENT_H − a r e m i n  e r a b o u t t h e # i f n  e f ab o ve e above three lines do the following: 1.
Test if STUDENT_H has been previously #defined, usually because this header ﬁle has been #included elsewhere.
If it has not been #defined, #define it now and proceed with compiling the code between the #ifndef and #endif.
Close the #ifndef block.
If STUDENT_H was previously deﬁned, skip to the line aer this one.
Here is an example of what these lines look like alongside some actual code: # i f n d e f STUDENT_H # d e f i n e STUDENT_H class student { / / c l a s s d e c l a r a t i o n b e c a u s e t h i s i s an i n t e r f a c e.
What is a header ﬁle.
What ﬁle extension do we typically use for a Cplus_plus header ﬁle.
What ﬁle extension do we typically use for a Cplus_plus  ﬁle.
How do you incorporate a header ﬁle named something_0_h into a ﬁle named main_0_cpp.
Do you incorporate an  ﬁle into your project the same way.
How do you prevent redeclaration of ADTs and functions in header ﬁles.
A header ﬁle stores the interface of an ADT 2.
A header ﬁle ends in _0_h 3.
An  ﬁle ends in _0_cpp 4.
In the interface ﬁle 5.
Add #include "something_0_h" alongside the other #include statements in main_0_cpp.
No, the  ﬁle will automatically be compiled and linked by your development environment as long as the  ﬁle is in your project.
You prevent redeclaration by adding lines similar to the following to the top of your header ﬁle: # i f n d e f SOMETHING_H # d e f i n e SOMETHING_H en add the following to the end of the header ﬁle: # e n d i f / / SOMETHING_H 22_0_3.
Chapter 23 STL e Standard Template Library (STL) provides a set of tools beyond those that are provided by the "base" Cplus_plus language.
While a comprehensive discussion of the features of the STL is far beyond the scope of this text, there are several libraries that oﬀer extremely important features with which you should become comfortable.
Note: rather than assuming that u s i n g namespace s t d ; is at the top of every code example, each data type, function, or variable derived from the STL will be shown with the preﬁx std::.
For example, to link a student's identiﬁcation number (an integer) and their grade point average (a float), we can write: std : :  <int , float >  = { 112233 , 3_0_81 } ;.
Iterators are objects that refer to elements within a container object (like std::vector, std::map, and std::array) and allow for traversal through those elements.
While the speciﬁcs of the iterators vary, most iterators belong to one of the following categories, based on the operations that may be performed on them.
Everything a bidirectional iterator can do and:.
Can use arithmetic operators to move forward and backward a certain number of items at once.
Allows comparisons between iterators to determine relative positions in the container.
Can use -style access to elements in the container / / C  e a  e an a   a  o f 5 i   e  e  s.
For example: std : : << std : : <<.
An associative container diﬀers from an  in that items in an  are referenced with a number which indicates the item's position in memory: [ 1 0 ] ; / / An a   a  o f  e     e  e  s [ 0 ] = −5; / / S e   h e f   s     e  e     h e a   a   o −5 An associative container, on the other hand, can use any data type to reference the items in the container.
For example, you might choose to use a string to reference a collection of int items to store a list of students' ages according to their names.
Objects of type  may be iterated, and in Cplus_plus11, their contents can be printed in a range-based for loop as we brieﬂy demonstrate here.
Each item in the std::<std::string, int> is of type std::pair<std::string,int>.
This code p      : John   19  e a   o Max   19  e a   o C h       e   20  e a   o Ma   a   18  e a   o J u  e   18  e a   o 19  e a   o.