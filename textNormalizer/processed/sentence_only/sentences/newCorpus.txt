Practical Cplus_plus Programming Steve Oualline O'Reilly & Associates, Inc.
Beijing · Cambridge · Köln · Paris · Sebastopol · Taipei · Tokyo Page iv Practical Cplus_plus Programming by Steve Oualline Copyright © 1995 O'Reilly & Associates, Inc.
All rights reserved.
Printed in the United States of America.
Editors: Adrian Nye and Dale Dougherty Production Editor: Nicole Gipson Printing History: August 1995 First Edition.
January 1997: Minor corrections.
Nutshell Handbook, the Nutshell Handbook logo, and the O'Reilly logo are registered trademarks and The Java Series is a trademark of O'Reilly & Associates, Inc.
Many of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks.
Where those designations appear in this book, and O'Reilly & Associates, Inc.
While every precaution has been taken in the preparation of this book, the publisher assumes no responsibility for errors or omissions, or for damages resulting from the use of the information contained herein.
This book is printed on acid-free paper with 85% recycled content, 15% post-consumer waste.
O'Reilly & Associates is committed to using paper with the highest recycled content available consistent with high quality.
Page xv Preface This book is devoted to practical Cplus_plus programming.
It teaches you not only the mechanics of the language, but also style and debugging.
The entire life cycle of a program is discussed, including conception, design, writing, debugging, release, documentation, maintenance, and revision.
Style is emphasized.
Creating a good program involves more than just typing code.
It is an art in which writing and programming skills blend to form a masterpiece.
A well-written program not only functions correctly, but also is simple and easy to understand.
Comments allow programmers to include descriptive text in their programs.
Clearly written, well-commented programs are highly prized.
A program should be as simple as possible.
Avoid the use of clever tricks.
Cleverness and complexity can kill programs.
This book stresses simple, practical rules.
For example, the 15 operator-precedence rules in Cplus_plus can be simplified to 2: 1.
Multiply and divide before you add and subtract.
Put parentheses around everything else.
One was written by a clever programmer, using all the tricks.
The program contains no comments, but it works.
The other is nicely commented and well structured, but doesn't work.
Which program is more useful.
In the long run, the "broken" one is more useful because it can be fixed and maintained easily.
Although the clever one works now, sooner or later it will have to be modified.
The hardest work you will ever have to do is modifying a cleverly written program.
Page xvi Scope of This Handbook This handbook is written for people with no previous programming experience, for programmers who know C and want to upgrade their skills to Cplus_plus, and for those who already know Cplus_plus and want to improve their programming style and reliability.
You should have access to a computer and know how to use the basic functions such as the text editor and file system.
Computer languages are best learned by writing and debugging programs.
Sweating over a broken program at two o'clock in the morning only to find that you  = where you should have  == is a very effective teaching tool.
Many programming examples are used throughout this book.
Most of them contain deliberate errors.
You are encouraged to enter the examples into your computer and then run and debug them.
This process introduces you to common errors using short programs so you will know how to spot and correct such errors in your own larger programs.
A "generic" UNIX compiler that should work on most UNIX systems.
Microsoft's Visual Cplus_plus for MS-DOS/Windows As far as standard Cplus_plus is concerned there are only minor differences among the various compilers.
This book clearly indicates where compiler differences can affect the programmer.
Specific instructions are given for producing and running programs using each of these compilers.
The book also gives examples of using the programming utility make for automated program production.
How This Book Is Organized You must crawl before you walk.
In Part I: The Basics you learn how to crawl.
These chapters teach you enough to write very simple programs.
You start with the mechanics of programming and programming style.
Next, you learn how to use variables and very simple decision and control statements.
Page xvii At this point you will have learned enough to create very simple programs; therefore, in Chapter 7, The Programming Process, you embark on a complete tour of the programming process that shows you how real programs are created.
Chapter 1, What Is Cplus_plus_0_, gives you an overvie ins the basic programming process and gives you enough information to write a very simple program_0_w of Cplus_plus, describes its history uses,  explains how the language is organized.
Chapter 2, The Basics  Program Writing, expla Chapter 3, Style, discusses programming style.
Ho Chapter 4, Basic Declarations  Expressions, int w to comment a program is covered, as well as how to write clear  simple code.
Basic variables the assignment statement are covered in detail along with the arithmetic operators: +, -, *, /,  %.
Chapter 5, Arrays, Qualifiers,  Reading Numbers, covers arrays  more complex variables.
The shorthand operators plus_plus, , *=, =, +=, -=,  %= are described.
Chapter 6, Decision  Control Statements, explains simple decision statements including if, else  for.
The problem  ==  = is discussed.
Chapter 7, The Programming Process, takes you through the steps required for creating a simple program, from specification through release.
Structured programming, fast prototyping, debugging are discussed.
Part II: Simple Programming, describes all the other simple statements  operators that are used in programming.
You also learn how to organize these statements into simple functions.
Chapter 8, More Control Statements, describes additional control statements.
Included are while, break,  continue.
The switch statement is discussed in detail.
Chapter 9, Variable Scope  Functions, introduces local variables, functions, parameters.
Chapter 10, The Cplus_plus Preprocessor, describes the Cplus_plus preprocessor, which gives you great flexibility in creating code.
It also provides a tremendous number  ways for you to screw up.
Simple rules that help keep the preprocessor from becoming a problem are described.
Chapter 11, Bit Operations, discusses the logical Cplus_plus operators that work on bits.
In Part III: Advanced Types  Classes, you learn how basic declarations  statements can be used in the construction  advanced types such as structures, unions,  classes.
You also learn about the concept  pointers.
Page xviii Chapter 12, Advanced Types, explains structures  other advanced types.
The sizeof operator  the enum type are included.
Chapter 13, Simple Classes, introduces the concept  a class.
This is one  the more powerful features  Cplus_plus.
Classes allow you to group data  the operations that can be performed on that data into one object.
Chapter 14, More on Classes, describes additional operations that can be performed with classes.
Chapter 15, Simple Pointers, introduces Cplus_plus pointer variables  shows some  their uses.
Advanced programming techniques are explored in Part IV: Advanced Programming Concepts.
In this section, you explore a number  Cplus_plus features that let you create complex, yet easy-to-use objects or classes.
Chapter 16, File Input/Output, describes both buffered  unbuffered input/output (I/O).
ASCII  binary files are discussed  you are shown how to construct a simple file.
Old C-style I/O operations are also included.
Chapter 17, Debugging  Optimization, describes how to debug a program, as well as how to use an interactive debugger.
You are shown not only how to debug a program, but also how to write a program so that it is easy to debug.
This chapter also describes many optimization techniques to make your programs run faster  more efficiently.
Chapter 18, Operator Overloading, explains that Cplus_plus allows you to extend the language by defining additional meanings for the language's operators.
In this chapter, you create a complex type  the operators that work on it.
Floating Point, uses a simple decimal floating-point format to introduce the problems inherent in using floating points, such as roundoff errors, precision loss, overflow, underflow.
Chapter 20, Advanced Pointers, describes advanced use  pointers to construct dynamic structures such as linked lists  trees.
Chapter 21, Advanced Classes, shows how to build complex, derived classes out  simple, base ones.
Finally a number  miscellaneous features are described in V: Other Language Features.
Chapter 22, Exceptions, explains how to handle unexpected conditions within a program.
Page xix Chapter 23, Modular Programming, shows how to split a program into several files  use modular programming techniques.
The make utility is explained in more detail.
Chapter 24, Templates, allows you to define a generic function or class that generates a family functions.
Chapter 25, Portability Problems, describes the problems that can occur when porting a program (moving a program from one machine to another).
Chapter 26, Putting It All Together, details the steps necessary to take a complex program from conception to completion.
Information hiding  modular programming techniques, as well as object-oriented programming, are stressed.
Chapter 27, From C to Cplus_plus, describes how to turn C code into Cplus_plus code,  addresses many  the traps lurking in C code that bite the Cplus_plus programmer.
Chapter 28, Cplus_plus's Dustier Corners, describes the do/while statement, the comma operator, the _0_: operators.
Chapter 29, Programming Adages, lists programming adages that will help you construct good Cplus_plus programs.
Appendix A, ASCII Table, contains a list  character codes  their values.
Appendix B, Ranges, lists the numeric ranges  some Cplus_plus variable types.
Appendix C, Operator Precedence Rules, lists the rules that determine the order in which operators are evaluated.
Appendix D, Computing sine Using a Power Series, contains a program that shows how the computer can compute the value  the sine function.
How to Read This Book If You Already Know C Cplus_plus is built on the C language.
If you know C, you will find much  the material presented in Chapters 2 through 12 familiar.
Cplus_plus does introduce a number  new , including:.
An entirely new /O system.
The new  system is discussed in detail in Chapter 16, File.
Constant  reference variables.
Function overloading, inline functions, reference parameters,  default parameters.
Classes are unique to Cplus_plus  are one  the more powerful   the language.
Font Conventions The following conventions are used in this book: Italic is used for directories and to emphasize new  and  when they are introduced.
Italic is also used to highlight comments in examples.
Bold is used for C keywords.
Constant Width is used for programs and the elements of a program and in examples to show the contents of files or the output from commands.
A reference in text to a word or item used in an example or code fragment is also shown in constant width font.
Constant Bold is used in examples to show commands or other text that should be typed literally by the user.
We usually use this for examples that should be executed only by root.
Page xxi [] surround optional values in a description of program syntax.
The notation CTRL-X or ^X indicates use of control characters.
It means hold down the "control" key while typing the character "x".
We denote other keys similarly (e_0_g_0_, RETURN indicates a carriage return).
All examples of command lines are followed by a RETURN unless otherwise indicated.
Obtaining Source Code You can obtain the source code for the programs presented in this book from O'Reilly & Associates through their Internet server.
The example programs in this book are available electronically in a number of ways: by FTP, Ftpmail, BITFTP, and UUCP.
The cheapest, fastest, and easiest ways are listed first.
If you read from the top down, the first one that works for you is probably the best.
Use FTP if you are directly on the Internet.
Use Ftpmail if you are not on the Internet, but can send and receive electronic mail to Internet sites (this includes CompuServe users).
Use BITFTP if you send electronic mail via BITNET.
Use UUCP if none of the above works.
FTP To use FTP, you need a machine with direct access to the Internet.
A sample session is shown, with what you should type in boldface.
Name (ftp_0_uu_0_net:joe): anonymous 331 Guest login ok, send domain style e-mail address as password.
You must specify binary transferfor 200 Type set to.
Page xxii ftp> quit 221 Goodbye.
This includes any company or service provider that allows email connections to the Internet.
In the message body, give the FTP commands you want to run.
The server will run anonymous FTP for you and mail the files back to you.
To get a complete help file, send a message with no subject and the single word "help" in the body.
The following is a sample mail session that should get you the examples.
This command sends you a listing of the files in the selected directory and the requested example files.
The listing is useful if there's a later version of the examples you're interested in.
BITFTP BITFTP is a mail server for BITNET users.
You send it electronic mail messages requesting files, and it sends you back the files by electronic mail_0_BITFTP currently Page xxiii serves only users who send it mail from nodes that are directly on BITNET, EARN, or NetNorth.
BITFTP is a public service of Princeton University.
Here's how it works.
To use BITFTP, send mail containing your ftp commands to BITFTP@PUCC.
For a complete help file, send HELP as the message body.
The following is the message body you send to BITFTP: FTP ftp_0_uu_0_net NETDATA USER anonymous CD /published/oreilly/nutshell/practcpp DIR BINARY GET examples_0_tar_0_gz QUIT Once you've got the desired file, follow the directions under FTP to extract the files from the archive.
Since you are probably not on a UNIX system, you may need to get versions of uudecode, uncompress, atob, and tar for your system.
VMS, DOS, and Mac versions are available.
UUCP UUCP is standard on virtually all UNIX systems and is available for IBM-compatible PCs and Apple Macintoshes.
The examples are available by UUCP via modem from UUNET; UUNET'S connect-time charges apply.
You can get the examples from UUNET whether you have an account there or not.
If you or your company has an account with UUNET, you have a system somewhere with a direct UUCP connection to UUNET.
Find that system, and type: uucp uunet\_0_~/published/oreilly/nutshell/practcpp/examples_0_tar_0_gz yourhost\_0_~/yourname/ The backslashes can be omitted if you use the Bourne shell (sh) instead of csh.
The file should appear some time later (up to a day or more) in the directory /usr/spool/uucppublic yourname.
If you don't have an account, but would like one so that you can get electronic mail, contact UUNET at 703-204-8000.
It's a good idea to get the file /published/oreilly/ls-lR_0_Z as a short test file containing the filenames and sizes of all the files available.
Once you've got the desired file, follow the directions under FTP to extract the files from the archive.
Page xxiv Comments and Questions Please address comments and questions concerning this book to the publisher: O'Reilly & Associates, Inc.
Special thanks to Dale Dougherty for ripping apart my first book and forcing me to put it together correctly.
I greatly appreciate the hard work put in by Phil Straite and Gregory Satir.
I especially thank all those people who reviewed and edited my book.
My thanks also go to the production group at O'Reilly & Associates—Nicole Gipson, project manager and production editor; John Files, Juliette Muellner, and Jane Ellln, production assistants; and Mike Sierra, book design implementor.
Finally, special thanks go to all the hard-working programmers out there whose code has taught me so much.
Page 1 I The Basics Page 3 1 What Is Cplus_plus.
A Brief Histoty of Cplus_plus.
How to Learn Cplus_plus Profanity is the one language that all programmers understand.
Computers are designed to handle and process large amounts of information quickly and efficiently.
Cplus_plus is a high-level programming  that allows a software engineer to efficiently communicate with a computer.
Cplus_plus is a highly flexible and adaptable.
Since its creation in 1980, it has been used for a wide variety of programs including firmware for micro-controllers, operating systems, applications, and graphics programming.
Cplus_plus is quickly becoming the programming of choice.
There is a tremendous demand for people who can tell computers what to do, and Cplus_plus lets you do so quickly and efficiently.
A Brief History of Cplus_plus In 1970 two programmers, Brian Kernighan and Dennis Ritchie, created a new  called C.
The was extremely simple and flexible and soon was used for many different types of programs.
It quickly became one of the most popular programming languages in the world.
Page 4 C had one major problem, however.
It was a procedure-oriented.
This meant that in designing a typical C program, the programmer would start by describing the data and then write procedures to manipulate that data.
Programmers eventually discovered that it made a program clearer and easier to understand if they were able to take a bunch of data and group it together with the operations that worked on that data.
Such a grouping is called an object or class.
Designing programs by designing classes is known as object-oriented design (OOD).
In 1980 Bjarne Stroustrup started working on a new , called "C with Classes_0_" This improved on C by adding a number of new , the most important of which was classes.
This  was improved, augmented, and finally became Cplus_plus.
Cplus_plus owes its success to the fact that it allows the programmer to organize and process information more effectively than most other languages.
Also, it builds on the work already done with the C.
In fact, most C programs can be transformed into Cplus_plus programs with little trouble.
These programs usually don't use all the new  of Cplus_plus, but they do work.
In this way, Cplus_plus allows programmers to build on an existing base of C code.
Cplus_plus Organization Cplus_plus is designed as a bridge between the programmer and the raw computer.
The idea is to let the programmer organize a program in a way that he or she can easily understand.
The compiler then translates the  into something the machine can use.
Computer programs consist of two main parts: data and instructions.
The computer imposes little or no organization on these two parts.
After all, computers are designed to be as general as possible.
The idea is for the programmer to impose his or her own organization on the computer and not the other way around.
The data in a computer is stored as a series of bytes.
Cplus_plus organizes those bytes into useful data.
Data declarations are used by the programmer to describe the information he or she is working with.
You can let the compiler decide what particular bytes of memory to use; that's a minor bookkeeping detail you don't need to worry about.
Page 5 The variable total is a simple variable.
It can hold only one integer and describe only one total.
A series of integers can be organized into an array.
Again, Cplus_plus will handle the details,.
Width of rectangle in pixels Height of rectangle in pixels Color of the rectangle Fill pattern However, data is only one part of a program.
You also need instructions.
As far as the computer is concerned it knows nothing about the layout of the instructions.
It knows only what it's doing for the current instruction and where to get the next instruction.
Cplus_plus is a high-level.
It lets you write a high-level statement such as:.
The compiler translates this statement into a series of cryptic machine instructions.
This sort of statement is called an assignment statement.
It is used to compute and store the value of an arithmetic expression.
You can also use control statements to control the order of processing.
Statements such as the if and switch statements enable the computer to make simple decisions.
Statements can be repeated by using looping statements such as while and for.
Groups of statements can be wrapped to form functions.
Thus you only need to write a general-purpose function to draw a  once and then you can reuse that function whenever you want to draw a new.
Cplus_plus provides a rich set of standardfunctions that perform common functions such as searching, sorting, input, and output.
A set of related functions can be grouped together to form a module, and modules are linked to form programs.
One of the major goals of the Cplus_plus  is to organize instructions into reusable components.
After all, you can write programs much faster if you "borrow" most of your code from somewhere else.
Groups of reusable modules can be combined into a library.
For example, if you need a sort routine, you can use the standard function qsort from the library and link it into your program.
Page 6 A computer divides the world into data and instructions.
For a long time, highlevel languages such as C kept that dividing line in place.
In C you can define data or write instructions, but you can't combine the two.
One of Cplus_plus's major innovations is the idea of combining data and instructions together in a construct called a class or object.
Object-oriented programming allows you to group data with the operations that can be performed on that data.
This concept is taken one step further in Cplus_plus by allowing you to derive new  from existing ones.
This last feature is extremely powerful.
It allows you to build complex  on top of smaller, simpler ones.
It also allows you to define a basic, abstract class and then derive specific  from it.
For example, an abstract class of shape might be used to define the shapes , triangle, and circle.
Organization is the key to writing good programs.
In this book, you know that the table of contents is in the front and the index is in the back, because that's the way books are organized.
Organization makes this book easier to use.
The Cplus_plus  lets you organize your programs using a simple yet powerful syntax.
This book goes beyond the Cplus_plus syntax and teaches you style rules that enable you to create highly readable and reliable programs.
By combining a powerful syntax with a good programming style you can create powerful programs that perform complex and wonderful operations.
How to Learn Cplus_plus The only way to learn how to program is to write programs.
You'll learn a lot more by writing and debugging programs than you ever will by reading this book.
This book contains many programming exercises, and you should try to do as many of them as possible.
When doing the exercises keep good programming style in mind.
Always comment your programs, even if you're doing the exercises only for yourself.
Commenting helps you organize your thoughts, Don't let yourself be seduced by the idea that, "I'm only writing these programs for myself, so I don't need to comment them_0_" First of all, code that looks obvious to you when you write it can often be confusing and cryptic when you revisit it a week later.
Writing comments also helps you organize your ideas.
I once wrote a program that was designed to work only on the computer at Caltech.
The program was highly system dependent.
As I was the only one who would ever Page 7 use the program, the program would print the following message if I got the command line wrong: _0_LSTUIT User is a twit A few years later I was a student at Syracuse University.
The secretary at the School Computer Science needed a program that was similar to my Caltech listing program, so I adapted my program for her use.
Unfortunately, I had forgotten about my funny little error message.
Imagine how horrified I was when I came into the Computer Science office and was accosted by the chief secretary.
This lady had so much power she could make the dean cringe.
She looked at me and said, "User is a twit, huh_0_" Luckily she had a sense  humor, or I might not be here today.
Sprinkled throughout this book are "broken" programs.
Spend the time to figure out why they don't work.
Often the problem is very subtle, such as a misplaced semicolon or  = instead ==.
These programs let you learn how to spot mistakes in a small program.
That way when you make similar mistakes in a big program, and you will make mistakes, you will be trained to spot them.
Page 9 2 The Basics  Program Writing In This Chapter:.
Programs from Conception to Execution.
Creating a Real Program.
Creating a Program Using a CommandLine Compiler.
Creating a Program Using an Integrated Development Environment.
Programming Exercises The first and most important thing  all, at least for writers today, is to strip language clean, to lay it bare down to the bone —Ernest Hemingway Computers are very powerful tools that can store, organize, and process a tremendous amount information.
However, they can't do anything until someone gives them detailed instructions.
Communicating with computers is not easy.
They require instructions that are exact and detailed.
Wouldn't life be easier if we could write programs in English.
Then we could tell the computer, "Add up all my checks and deposits, and then tell me the total," and the machine would balance our checkbooks.
But English is a lousy language when you must write exact instructions.
The language is full ambiguity and imprecision.
Grace Hopper, the grand old lady  computing, once commented on the instructions she found on a bottle  shampoo: Wash Rinse Repeat She tried to follow the directions, but she ran out  shampoo.
Of course, we can try to write in precise English.
We'd have to be careful and make sure to spell everything out and be sure to include instructions for every contingency.
If we worked really hard, we could write precise English instructions, right.
Page 10 As it turns out, there is a group  people who spend their time trying to write precise English.
They're called the government, and the documents they write are called government regulations.
Unfortunately, in their effort to make the regulations precise, the government also has made the documents almost unreadable.
If you've ever read the instruction book that comes with your tax forms, you know what precise English can be like.
Still, even with all the extra verbiage the government puts in, problems can occur.
A few years ago California passed a law requiring all motorcycle riders to wear a helmet.
Shortly after this law went into effect a cop stopped a guy for not wearing a helmet.
The man suggested the police officer take a closer look at the law.
The cop couldn't give the motorcyclist a ticket because the man did have a helmet firmly strapped on—to his knee.
So English, with all its problems, is out as a computer language.
Now, how do we communicate with a computer.
The first computers cost millions  dollars, while at the same time a good programmer cost about $15,000 a year.
Programmers were forced to program in a language where all the instructions were reduced to a series  numbers, called machine language.
This language could be directly input into the computer.
A typical machine-language program looks like: 1010 1111 0011 0111 0111 0110 _0_.
To program these ancient machines, software engineers would write out their programs  a simple language where each word would stand for a single instruction.
This was called assembly language because the programmers had to manually translate, or assemble, each line into machine code.
A typical program might look like: Program Translation MOV A,47 1010 1111 ADD A,B 0011 0111 HALT 0111 0110 _0_.
Translation was a difficult, tedious, exacting task.
One software engineer decided this was a perfect job for a computer, so he wrote a program, called an assembler, that would do the job automatically.
Page 11 Figure 2-1.
Assembling a program He showed his new  to his boss and was immediately chewed out: "How dare you even think   such an expensive machine for a mere 'clerical' task_0_" Given the cost  an hour  computer time versus the cost  an hour  programmer's time, this was not an unreasonable attitude.
Fortunately, as time passed the cost  programmers went up and the cost  computers went down.
So it became more cost-effective to let the programmers write programs in assembly language and then use a program called an assembler to translate the programs into machine language.
Assembly language organized programs in a way that was easier for the programmers to understand.
However, the program was more difficult for the machine to use.
The program had to be translated before the machine could execute it.
This was the start of a trend.
Programming languages became more and more convenient for programmers to use and started requiring more and more computer time to translate them into something useful for computers.
Over the years a series of high-level languages has been devised.
These languages are attempts to let programmers write in something that is easy for them to understand and that is also precise and simple enough for computers to understand.
Early high-level languages were designed to handle specific types of applications.
FORTRAN was designed for number crunching; COBOL, for writing business reports; and PASCAL, for student use.
It is rumored that Nicklaus Wirth has said, "If I had known that PASCAL was going to be so successful, I would Later on, Brian Kernighan and Dennis Ritchie developed C and Bjarne Stroustrup turned it into Cplus_plus.
Page 12 Programs from Conception to Execution Cplus_plus programs are written in a high-level language using letters, numbers, and the other symbols you find on a computer keyboard.
Computers actually execute a very low-level language called machine code (a series of numbers).
So, before a program can be used, it must undergo several transformations.
Programs start out as an idea in a programmer's head.
He writes down his thoughts in a file, called a sourcefile or source code, using a text editor.
This file is transformed by the compiler into an objectfile.
Next a program called the linker takes the object file, combines it with predefined routines from a standard library, and produces an executable program (a set of machine-language instructions).
In the following sections, you'll see how these various forms of the program work together to produce the final program.
Figure 2-2 shows the steps that must be taken to transform a program written in a high-level language into an executable program.
Figure 2-2 Transformation of a high-level language into a program Wrappers Fortunately you don't have to run the compiler, assembler, and linker individually.
Most Cplus_plus compilers use "wrapper" programs, which determine which tools need to be run and then run them.
Page 13 Some programming systems go even farther and provide the developer with an integrated development environment (IDE).
The IDE contains an editor, compiler, linker, project manager, debugger, and more in one convenient package.
Both Borland and Microsoft provide IDES with their compilers.
Creating a Real Program Before you can actually start creating your own programs you need to know how to use the basic programming tools.
This section will take you step by step through the process of entering, compiling, and running a simple program.
This section describes how to use two different types of compilers.
The first type is the standalone or command-line compiler.
This type of compiler is operated in a batch mode from the command line.
In other words, you type a command and the compiler turns your source code into an executable program.
The other type of compiler is contained in an IDE.
Most UNIX systems use command-line compilers.
A few IDE-type compilers are available for UNIX, but they are rare.
On the other hand almost all the compilers used with MS-DOS and Windows contain an integrated development environment.
For command-line die-hards, these compilers do contain command-line compilers as well.
Creating a Program Using a Command-Line Compiler In this section you'll go through the step-by-step process needed to create a program using a command-line compiler.
Instruction is given for using a generic UNIX compiler, the Free Software Foundation's gplus_plus compiler, Turbo-Cplus_plus, Borland Cplus_plus, and Microsoft Visual Cplus_plus.
However, if you are using a Borland or Microsoft compiler, you might want to skip ahead to the section on using the IDE.
Step 1: Create a Place for Your Program It is easier to manage things if you create a separate directory for each program you are working on.
In this case you'll create a directory called hello to hold your hello program.
In UNIX, type: % mkdir hello % cd hello Page 14 In MS-DOS, type: C: MKDIR HELLO C: CD HELLO Step 2: Create the Program A program starts out as a text file.
Example 2-1 shows the hello program in source form.
Example 2-1 Source for the hello_0_cc program.
Use your favorite text editor to enter the program.
In UNIX your file should be named hello_0_cc and in MS-DOS/Windows the file should be named HELLO_0_CPP.
WARNING MS-DOS/Windows users should not use a word-processing program such as Microsoft Word or WordPerfect to write their programs.
Word-processing programs add formatting codes to the file that confuse the compiler.
You must use a text editor such as the MS-DOS EDIT program that is capable of editing ASCII files.
Step 3: Run the Compiler The compiler changes the source file you just created into an executable program.
Each compiler has a different command line.
The commands for the most popular compilers are listed below.
Most UNIX-based compilers follow the same generic standard.
The Cplus_plus compiler is named CC.
To compile our hello program we need the following command: % CC -g -ohello hello_0_cc The -g option enables debugging.
See your compiler manual for details on all the possible options.
There are several different Cplus_plus compilers for UNIX, so your command line may be slightly different.
Page 15 Free Software Foundation's gplus_plus Compiler The Free Software Foundation, the GNU people, publishes a number of high-quality programs.
To compile a program using the gplus_plus compiler, use the following command line: % gplus_plus -g -Wall -ohello hello_0_cc The additional switch -Wall turns on all the warnings.
Borland's Turbo Cplus_plus in MS-DOS Borland International makes a low-cost MS-DOS Cplus_plus compiler called Turbo-Cplus_plus.
This compiler is ideal for learning.
The command line for Turbo-Cplus_plus is: C:> tcc -ml -v -N -P -w -ehello hello_0_cpp The -ml tells Turbo-Cplus_plus to use the large memory model.
This book discusses none of them.
Instead we take the attitude, "Use large and don't worry about it until you become an The -v switch tells Turbo-Cplus_plus to put debugging information in the program.
Warnings are turned on by -w; stack checking by -N.
The compiler will actually compile both C and Cplus_plus.
We force a Cplus_plus compile using the -P switch.
Finally, -ehello tells Turbo-Cplus_plus to create a program named hello, and hello_0_cpp is the name of the source file.
See the Turbo-Cplus_plus reference manual for a complete list of options.
Borland Cplus_plus in MS-DOS and Windows In addition to Turbo-Cplus_plus, Borland International also makes a full-featured, professional compiler for MS-DOS/Windows called Borland Cplus_plus.
Its command line is: C:> bcc -ml -v -N -P -w -ehello hello_0_cpp The command-line options are the same for both Turbo-Cplus_plus and Borland Cplus_plus.
Microsoft Visual Cplus_plus Microsoft Visual Cplus_plus is another Cplus_plus compiler for MS-DOS/Windows.
It is not as robust or full featured as its Borland counterpart, but it will compile most of the programs in this book.
To compile, use the following command line: C:> cl /AL /Zi /W1 hello_0_cpp Page 16 The /AL option tells the program to use the large memory model.
Debugging is turned on with the /Zi option and warnings with the /W1 option.
Step 4: Execute the Program Now, when you run the program by typing, for example: hello at the UNIX or MS-DOS prompt, the message: Hello World will appear on the screen.
Creating a Program Using an Integrated Development Environment Integrated development environments provide a one-stop shop when it comes to programming.
They take a compiler, editor, and debugger and wrap them into one neat package for the programmer.
Since development environments tend to change, the particular version you use may require slightly different keystrokes.
Create a Place for Your Program It is easier to manage things if you create a separate directory for each program you are working on.
In this case you'll create a directory called HELLO to hold your hello program.
In MS-DOS, type: C: MKDIR HELLO C: CD HELLO Step 2: Enter, Compile, and Run Your Program Each IDE is a little different, so we've included separate instructions for each one.
Start the Turbo-Cplus_plus IDE with the command: C: TC 2.
Use the Options | Compiler | Code Generation command to pull up the Code Generation dialog box as seen in Figure 2-3.
Change the memory model to large.
Use the Options | Compiler | Entry/Exit command to turn stack checking on, as shown in Figure 2-4.
Page 17 Figure 2-3.
Code Generation dialog box Figure 2-4.
Entry/Exit Code Generation dialog box 4.
Use the Options | Compiler | Messages | Display command to bring up the Compiler Messages dialog box as seen in Figure 2-5.
Select All to display all the warning messages.
Use the Options I Save command to save all the options you've used so far.
Page 18 Figure 2-5.
Compiler Messages dialog box 6.
Use the Open Project File dialog box to select a project file.
In this case your project file is called HELLO_0_PRJ.
The screen should look like Figure 2-6 when you're finished.
Figure 2-6 Open Project File dialog box 7.
Press the Insert key to add a file to the project.
The file you want to add is HELLO_0_CPP as seen in Figure 2-7.
Page 19 Figure 2-7.
Add to Project List dialog box 8.
Press ESC to get out of the "add file" cycle.
Press the up-arrow key to go up one line.
The line with hello_0_cpp should now, be highlighted as seen in Figure 2-8.
Figure 2-8 "Hello "project 10.
Press Return to edit this file.
Finished project 12.
Use the Run I Run command to execute the program.
After the program runs, control returns to the IDE.
This means that you can't see what your program output.
To see the results of the program you must switch to the user screen using the command Window I User.
Pressing any key will return you to the IDE.
Figure 2-10 shows the output of the program.
When you are finished you can save your program with the File ISave command.
To exit the IDE use the File I Quit command.
Page 21 Figure 2-10.
User screen Borland Cplus_plus 1.
Create a directory called HELLO to hold the files for our hello program.
You can create a directory using the Windows' File Manager Program or by typing the following command at the MS-DOS prompt: mkdir \HELLO 2.
From Windows, double-click on the Borland Cplus_plus icon to start the IDE The program begins execution and displays a blank workspace as seen in Figure 2-11.
Select the Project I New Project item to create a project for our program.
Fill in the "Project Path and Name:" blank with c:\hello\hello_0_ide.
For the Target Type select EasyWin[_0_exe].
The Target Model is set to Large.
The results are shown in Figure 2-12.
Click on the Advanced button to bring up the Advanced Options dialog.
Clear the _0_rc and _0_def items as shown in Figure 2-13.
Click on OK to return to the New Target dialog.
Press Alt-F10 to bring up node sub-menu shown in Figure 2-14.
Select Edit Node Attributes to bring up the dialog shown in Figure 2-15.
In the Style Sheet blank, select the item "Debug Info and Diagnostics_0_" Click on OK to return to the main window.
Page 22 Figure 2-11 Borland Cplus_plus initial screen.
Figure 2-15 Node Attributes dialog box 8.
Go to the Project Options dialog by selecting the Options | Project Options item.
Go down to the Compiler item and click on the "+" to expand the options.
Turn on the Test stack overflow option shown in Figure 2-16.
Click on OK to save these options.
Click on OK to return to the main window.
Press the down arrow to select the hello[_0_cpp] item in the project (see in Figure 2-17).
Press Return to start editing the file hello_0_cpp.
Type in the following code:.
When you have finished, your screen will look like Figure 2-18.
Compile and run the program by selecting the Debug | Run menu item.
The program will run and display "Hello World" in a window, as shown in Figure 2-19.
Page 25 Figure 2-16 Project Options dialog box.
Page 27 Microsoft Visual Cplus_plus 1.
Create a directory called HELLO to hold the files for our hello program.
You can create a directory using the Windows File Manager Program or by typing the following command at the MS-DOS prompt: mkdir \HELLO 2.
From Windows, double-click on the Visual Cplus_plus icon to start the IDE.
A blank workspace will be displayed as shown in Figure 2-20.
Figure 2-20 Microsoft Visual Cplus_plus initial screen 3.
Click on Project | New to bring up the New Project dialog shown in Figure 2-21.
Fill in the Project Name blank with \hello\hello_0_mak.
Change the Project Type to QuickWin application [_0_EXE].
Visual Cplus_plus goes to the Edit dialog to allow you to name the source files in this project (see Figure 2-22).
In this case we have only file hello_0_cpp.
Click on Add to enter the name in the project and then click on Close to tell Visual Cplus_plus that there are no more files in the program.
Select Options | Project Options to bring up the Project Options dialog shown in Figure 2-23.
Click on the Compiler button to change the compiler options.
Page 28 Figure 2-21 Project create screen.
Figure 2-23 Project Options dialog box 6.
Go down to the Custom Options item in the Category and change the warning level to 4 as shown in Figure 2-24.
Change to the Memory Model category and change the memory model to large (see Figure 2-25).
Close the dialog by clicking on the OK button.
This brings you back to the Project Options dialog.
Click on OK to dismiss this dialog as well.
Select "File | New" to start a new  file.
Type in the following lines:.
Your results should look like Figure 2-26.
Use the File I Save As menu item to save the file under the name hello_0_cpp.
Use the Project | Build command to compile the.
The compiler will output messages as it builds.
When it is finished your screen should look like Figure 2-27.
Page 30 Figure 2-24 Compiler Options dialog box.
The  can now be started with the Debug | Go command.
The results appear in Figure 2-28.
Figure 2-28 "Hello World" results Getting Help in UNIX Most UNIX systems have an online documentation system called the "man pages_0_" These can be accessed with the man command.
This item activates a hypertext-based Help system.
Programming Exercises Exercise 2-1: On your computer, type in the hello  and execute it.
Exercise 2-2: Take several programming examples from any source, enter them into the computer, and run them.
Page 35 3 Style In This Chapter:.
Indentation and Code Format.
Consistency and Organization.
Summary There is no programming language, no matter how structured, that will prevent programmers from writing bad programs —L.
Flon It is the nobiliy, of their style which will make our writers of 1840 unreadable forty years from now —Stendhal This chapter discusses how to use good programming style to create a simple.
Style is what separates the gems from the junk.
It is what separates the programming artist from the butcher.
You must learn good programming style first, before typing in your first line of code, so everything you write will be of the highest quality.
Contrary to popular belief, programmers do not spend most of their time writing programs.
Far more time is spent maintaining, upgrading, and debugging existing code than is ever spent on creating new.
The amount of time spent on maintenance is skyrocketing.
From 1980 to 1990 the average number of lines in a typical application went from 23,000 to 1_0_2 million.
The average system age has gone from 4_0_75 to 9_0_4 years.
To make matters worse, 74% of the managers surveyed at the 1990 Annual Meeting and Conference of the Software Maintenance Association reported that they "have systems in their department that have to be maintained by specific individuals because no one else understands Page 36 Most software is built on existing software.
I recently completed coding for 12 new.
Only one of these was created from scratch; the other 11 are adaptations of existing.
Programmers believe that the purpose of a  is only to present the computer with a compact set of instructions.
Programs written only for the machine have two problems:.
They are difficult to correct because sometimes even the author does not understand them.
Modifications and upgrades are difficult to make because the maintenance programmer must spend a considerable amount of time figuring out what the  does from its code.
Comments Ideally, a  serves two purposes: First, it presents the computer with a set of instructions and, second, it provides the programmer with a clear, easy-to-read description of what the  does.
Example 2-1 contains a glaring error.
It is an error that many programmers still make and one that causes more trouble than any other problem.
The  contains no comments.
A working but uncommented  is a time bomb waiting to explode.
Sooner or later someone will have to modify or upgrade the , and the lack of comments will make the job ten times more difficult.
A well-commented, simple  is a  of art.
Learning how to comment is as important as learning how to code properly.
Cplus_plus has two flavors of comments.
The first type starts with /* and ends with */.
This type of comment can span multiple lines as shown: /* This is a single-line comment.
Page 37 The advantage of the /* */ comment style is that you can easily span multiple lines, whereas with the // style you have to keep putting the // on each line.
The disadvantage of /* */ is that forgetting a */ can really screw up your code.
Whichever one makes your program as clear and as easy to read as possible.
Mostly, it's a matter of taste.
In this book we use the /* */ style comments for big, multiline comments while the // style is reserved for comments that take up only a single line.
Whatever comment style you decide to use, you must comment your.
Example 3-1 shows how the "hello world" program looks after comments are added.
One of the best ways to organize your thoughts is to write them down in a language that is clear and easy to understand.
Once the process has been clearly stated, it can be translated into a computer program.
Understanding what you are doing is the most important part of programming.
I once wrote two pages of comments describing a complex graphics algorithm.
The comments were revised twice before I even started coding.
The actual instructions Page 38 Poor Person's Typesetting In typesetting you can use font style and size, bold, and italic to make different parts of your text stand out.
In programming, you are limited to a single, monospaced font.
However, people have come up with ingenious ways to get around the limitations of the typeface.
Some of the various commenting tricks are: /******************************************************** ******************************************************** ******** WARNING: This is an example of a ******* ******** message that grabs the ******* ******** attention of the programmer.
Even though we don't have * the bold typeface we can **emphasize** words.
Because I had organized my thoughts well (and was lucky), the program worked the first time.
Page 39 Your program should read like an essay.
It should be as clear and easy to understand as possible.
Good programming style comes from experience and practice.
The style described in the following pages is the result of many years of programming experience.
It can be used as a starting point for developing your own style.
These are not rules, but only suggestions.
The only rules are: Make your program as clear, concise, and simple as possible.
At the beginning of the program is a comment block that contains information about the program.
Boxing the comments makes them stand out.
The list that follows contains some of the sections that should be included at the beginning of your program.
Not all programs will need all sections, so use only those that apply.
Heading The first comment should contain the name of the program.
Also  a short description of what it does.
You may have the most amazing program, one that slices, dices, and solves all the world's problems, but it is useless if no one knows what it does.
Author You've gone to a lot of trouble to create this program.
Take credit for it.
Also, if someone else must later modify the program, he or she can come to you for information and help.
Purpose Why did you write this program.
Usage In this section give a short explanation of how to run the program.
In an ideal world, every program comes with a set of documents describing how to use it.
The world is not ideal.
Oualline's law of documentation states: 90% of the time the documentation is lost.
Out of the remaining 10%, 9% of the time the revision of the documentation is different from the revision of the program and therefore completely useless.
The 1% of the time you actually have documentation and the correct revision of the documentation, the documentation will be written in Japanese.
To avoid falling prey to Oualline's law of documentation, put the documentation in the program.
References Creative copying is a legitimate form of programming (if you don't break the copyright laws in the process).
In the real world, it doesn't matter how you get a working program, as long as you get it; but, give credit where credit is due.
In this section you should reference the original author of any work you copied.
Page 40 File formats List the files that your program reads or writes and a short description of their format.
Restrictions List any limits or restrictions that apply to the program, such as: The data file must be correctly formatted; the program does not check for input errors.
Revision history This section contains a list indicating who modified the program and when and what changes have been made.
Many computers have a source control system (UNIX: RCS and SCCS; MS-DOS/Windows: MKS-RCS, PCVS) that will keep track of this information for you.
Error handling If the program detects an error, what does it do with the error.
Notes Include special comments or other information that has not already been covered.
The format of your beginning comments will depend on what is needed for the environment in which you are programming.
For example, if you are a student, the instructor may ask you to include in the program heading the assignment number, your name, student identification number, and other information.
In industry, a project number or part number might be included.
Comments should explain everything the programmer needs to know about the program, but no more.
It is possible to overcomment a program.
Inserting Comments—The Easy Way If you are using the UNIX editor vi, put the following in your _0_exrc file to make it easier to construct boxes.
Typing #e<return> will end a box.
The number of stars was carefully selected so the end of the box is aligned on a tab stop.
Page 41 Cplus_plus Code The actual code for your program consists of two parts: variables and executable instructions.
Variables are used to hold the data used by your program.
Executable instructions tell the computer what to do with the data.
Cplus_plus classes are a combination of data and the instructions that work on the data.
They provide a convenient way of packaging both instructions and data.
A variable is a place in the computer's memory for storing a value.
Cplus_plus identifies that place by the variable name.
Names can be any length and should be chosen so their meaning is clear.
The reader has no idea.
They could represent the number of angels on the head of a pin, or the location and acceleration of a plasma bolt in a game of Space Invaders.
By putting a comment after each declaration we, in effect, create a mini-dictionary where we define the meaning of each variable name.
Since the definition of each variable is in a known place, it's easy to look up the meaning of a name.
I was once asked to modify a program that converted plot data files from one format to another.
Many different units of length were used throughout the program and none of the variable declarations was Page 42 commented.
I tried very hard to figure out what was going on, but it was impossible to determine what units were being used in the program.
Finally, I gave up and put the following comment in the program: /******************************************************** * Note: I have no idea what the input units are, nor * * do I have any idea what the output units are, * * but I have discovered that if I divide by 3 * * the plots look about the right size.
Cleverness makes for unreadable and unmaintainable programs.
Programs, by their nature, are extremely complex.
Anything you can to do to cut down on this complexity will make your programs better.
Consider the following code, written by a very clever programmer.
Even a novice programmer who does not know Cplus_plus well can tell that this program has something to do with moving data from a source to a destination.
The computer doesn't care which version is used.
A good compiler will generate the same machine code for both versions.
It is the programmer who benefits from the verbose code.
Naming Style Names can contain both uppercase and lowercase letters.
In this book we use all lowercase names for variables (e_0_g_0_, source_ptr, current_index).
All uppercase Page 43 is reserved for constants (e_0_g_0_, MAX_ITEMS, SCREEN_WIDTH).
This convention is the classic convention followed by most C and Cplus_plus programs.
Many newer programs use mixed-case names (e_0_g_0_, RecordsInFile).
Sometimes they use the capitalization of the first letter to indicate information about the variable.
For example, recordsInFile might be used to denote a local variable while RecordsInFile would denote a global variable.
It is more a matter of religion than of style.
However, using a consistent naming style is extremely important.
In this book we have chosen the first style, lowercase variable names and uppercase constants, and we use it throughout the book.
Coding Religion Computer scientists have devised many programming styles.
These include structured programming, top-down programming, and goto-less programming.
Each of these styles has its own following or cult.
I use the term "religion" because people are taught to follow the rules blindly without knowing the reasons behind them.
For example, followers of the goto-less cult will never use a goto statement, even when it is natural to do so.
The rules presented in this book are the result of years of programming experience.
I have discovered that by following these rules, I can create better programs.
You do not have to follow them blindly.
If you find a better system, by all means use it.
The general rule for a Cplus_plus program is to indent one level for each new  or conditional.
In Example 3-1 there are three levels of logic, each with its own indentation level.
The while statement is outermost.
The statements inside the while are at the next level.
The statement inside the if (break) is at the innermost level.
There are two styles of indentation, and a vast religious war is being waged in the programming community as to which is better.
The first is the short form:.
Both formats are commonly used.
You should use the format you feel most comfortable with.
This book uses the short form.
The amount of indentation is left to the programmer.
Two, four, and eight spaces are common.
Studies have shown that a four-space indent makes the most readable code.
You can choose any indent size as long as you are consistent.
Clarity A program should read like a technical paper.
It should be organized into sections and paragraphs.
Procedures form a natural section boundary.
You should organize your code into paragraphs.
It is a good idea to begin a paragraph with a topic sentence comment and separate.
A better version would be: /* * Swap the two corners */ /* Swap X coordinate */ = 1;.
Simplicity Your program should be simple.
Some general rules of thumb are:.
A single function should not be longer than one or two pages.
This rule comes about because the human mind can hold only so much in short-term memory.
Three pages is about the most the human mind can wrap itself around in one sitting.
Avoid complex logic such as multiple nested ifs.
The more complex your code, the more indentation levels you will need.
About the time you start running into the right margin, you should think about splitting your code into multiple procedures and thus decreasing the level of complexity.
Did you ever read a sentence, like this one, where the author went on and on, stringing together sentence after sentence with the word "and," and didn't seem to understand the fact that several shorter sentences would do the job much better, and didn't it bother you.
Long statements should be avoided.
If an equation or formula looks like it is going to be longer than one or two lines, you probably should split it into two shorter equations.
Split large single code files into multiple smaller ones.
That way they aren't too difficult to edit and print.
When using classes (see Chapter 13, Simple Classes), put one class per module.
Finally, the most important rule: Make your program as simple and easy to understand as possible, even if it means breaking some of the rules.
The goal Page 46 is clarity, and the rules given in this chapter are designed to help you accomplish that goal.
If the rules get in the way, get rid of them.
I have seen one program with a single statement that spanned more than 20 pages.
However, because of the specialized nature of the program, this statement was simple and easy to understand.
Consistency and Organization Good style is only one element in creating a high-quality program.
Consistency is also a factor.
This book is organized with the table of contents at the front and the index at the back.
Almost every book printed has a similar organization.
This consistency makes it easy to look up a word in the index or find a chapter title in the table of contents.
Unfortunately the programming community has developed a variety of coding styles.
Each has its own advantages and disadvantages.
The trick to efficient programming in a group is to pick one style and then use it consistently.
That way you can avoid the problems and confusion that arise when programs written in different styles are combined.
Good style is nice, but consistency is better.
Further Reading In this chapter we have touched only the basics of style.
Later chapters expand on this base, adding new   as you learn new  of the language.
Summary A program should be concise and easy to read.
It must serve as a set of computer instructions, but also as a reference work describing the algorithms and data used inside it.
Everything should be documented with comments.
Comments serve two purposes.
First, they describe your program to any maintenance programmer who has to fix it and, second, comments help you remember what you did.
Class  1: Create a style sheet for class assignments.
Discuss what comments should go into the programs and why.
Class  2: Analyze the style of an existing program.
Is the program written in a manner that is clear and easy to understand.
What can be done to improve the style of the program.
Page 47 Exercise 3-1: Go through all the other programming exercises in this book and write comment blocks for them.
This will serve several purposes.
First, it will give you practice commenting.
Second, it will short-circuit the old programmer's excuse, "But I didn't have time to put in the Page 49 4 Basic Declarations and Expressions In This Chapter:.
The Elements of a Program.
The  Output Class.
Basic Program Structure.
Variables and Storage.
Floating Point Numbers.
Answers to Chapter Questions A journey of a thousand miles must begin with a single step —Lao-Zi If carpenters made buildings the way programmers make programs, the first woodpecker to come along would destroy all of civilization —Anonymous The Elements of a Program If you are going to construct a building, you need two things: the bricks and a blueprint that tells you how to put them together.
In computer programming you also need two things: data (variables) and instructions (code).
Variables are the basic building blocks of a program.
Instructions tell the computer what to do with the variables.
Comments are used to describe the variables and instructions.
They are notes by the author documenting the program so it is clear and easy to read.
Comments are ignored by the computer.
In construction, before we can start we must order our materials: "We need 500 large bricks, 80 half-size bricks, and 4 flagstones_0_" Similarly, in Cplus_plus you must declare all variables before to use.
After the variables are defined you can begin to use them.
In construction the basic structure is a room.
By combining many rooms we form a building.
In Cplus_plus the basic structure is a function.
Functions can be combined to form a program.
Page 50 An apprentice builder does not start out building the Empire State Building.
He starts on a one-room house.
In this chapter you will concentrate on constructing simple, one-function programs.
Basic Program Structure The basic  of a program are the data declarations, functions, and comments.
Let's see how these can be organized into a simple Cplus_plus program.
The basic structure of a one-function program is: /*************************************** * Heading comments * ***************************************/ data declarations.
The heading comments tell the programmer all about the program.
The data declarations describe the data that the program is going to use.
Our single function is named main.
The name main is special, because it is the first function called.
Any other functions are called directly or indirectly from main.
The function main begins with:.
A nonzero  indicates an error—the bigger the return value, the more severe the error.
Typically 1 is used for most simple errors, such as a missing file or bad command-line syntax.
Now let's take a look at the "Hello World" program (Example 3-1).
At the beginning of the program is a comment box enclosed in /* and */.
Following this is the line: # <iostream_0_h> Page 51 This statement signals Cplus_plus that you are going to use a set of standard classes called the I/O stream classes.
This is a type of data declaration.
Cplus_plus uses a semicolon to end a statement in much the same way we use a period to end a sentence.
Unlike with line-oriented languages such as BASIC, the end of a line does not end a statement.
The sentences in this book can span several lines—the end of a line is treated as a space separating words.
Cplus_plus works the same way.
A single statement can span several lines.
Similarly, you can put several sentences on the same line, just as you can put several Cplus_plus statements on the same line.
However, most of the time your program is more readable if each statement starts on a separate line.
We are using the standard class  (console out) to output the message.
A standard class is a generally useful Cplus_plus object that has already been defined and put in the standard library.
A library is a collection of classes, functions, and data that have been grouped together for reuse.
The standard library contains classes and functions for input, output, sorting, advanced math, and file manipulation.
See your Cplus_plus reference manual for a complete list of library functions and standard classes.
It contains no computations, merely sending a single message to the screen.
It is a starting point.
Once you have mastered this simple program, you have done a great deal of things right.
The program is not as simple as it looks.
But once you get it working, you can move on to create more complex code.
Simple Expressions Computers can do more than just print strings.
They can also perform calculations.
Expressions are used to specify simple computations.
Cplus_plus has the five simple operators listed in Table 4-1.
Page 52 Table 4-1.
Simple Operators Operator Meaning.
Multiply (*), divide (/), and modulus (%) have precedence over addition (+) and subtraction (-).
Parentheses may be used to group terms.
The program in Example 4-1 computes the value of the expression (1 + 2) * 4.
Although we calculate the answer, we don't do anything with it.
We'll learn what a class is later in Chapter 13, Simple Classes.
But for now all we have to know is that the operator <<* tells Cplus_plus what to output.
So the statement: << " World\n"; tells Cplus_plus to take the string " World\n" and write it to the console.
When this  executed it will write: Half  64  32 on the console.
Note that we had to put a space after the "" in "Half _0_" There also  a space on either side  the "" string.
These spaces are needed in the output to separate the numbers.
But these spaces are not inside any string, so they will not be output.
The result  this code : Half 6432 Omitting needed spaces  a common first-time programming mistake.
Remember, only the text inside the quotation marks will be output.
Variables and Storage Cplus_plus allows you to store values in variables.
Each variable  identified by a variable name.
Additionally, each variable has a variable type.
The type tells Cplus_plus how the variable  going to be used and what kind  numbers (real, integer) it can hold.
To avoid confusion, it  better to use different names for variables and not depend on case differences.
Most Cplus_plus programmers use all lowercase variable names.
Some names, such as int, while, for, and float, have a special meaning to Cplus_plus and are considered reserved words.
The following  an example  some variable names: average // average  all grades pi // pi to 6 decimal places number_of_students // number  students in this class The following are not variable names: 3rd_entry all$done the end int.
Begins with a number Contains a space Reserved word Avoid variable names that are similar.
For example the following illustrates a poor choice variable names: total // total number  items in current entry.
A variable cannot be used unless it  declared.
A variable declaration serves three purposes: 1.
It defines the name  the variable.
It defines the type  the variable (integer, real, character, etc_0_).
It gives the programmer a description  the variable.
The declaration  a variable answer can be: int answer; // the result  our expression.
The keyword int tells Cplus_plus that this variable contains an integer value.
The semicolon  used to indiPage 55 cate the statement end, and the comment  used to define this variable for the programmer.
The general form  a variable declaration :.
Type  one  the Cplus_plus variable types (int, float, etc_0_) Name  any valid variable name.
The comment explains what the variable  and what it will be used for.
Variable declarations come just before the main() line at the top  a program.
Integers (also known as whole numbers) have no fractional part or decimal point.
Numbers such as 1, 87, and -222 are integers.
The number 8_0_3  not an integer because it contains a decimal point.
The general form  an integer declaration : int.
A calculator with an eight-digit display can only handle numbers between 99,999,999 and -99,999,999.
If you try to add 1 to 99,999,999, you will get an overflow error.
Computers have similar limits.
The limits on integers are implementation dependent, meaning they change from computer to computer.
Calculators use decimal digits (0-9).
Computers use binary digits (0-1) called bits.
Eight bits make a byte.
The number  bits used to hold an integer varies from machine to machine.
Numbers are converted from binary to decimal for printing.
On most UNIX machines integers are 32 bits (4 bytes), providing a range  2,147,483,647 (231- 1) to -2,147,483,648 (-231).
On the PC in Turbo Cplus_plus, only 16 bits (2 bytes) are used, so the range  32,767 (215- 1) to -32,768 (-215).
Question 4-1: The following will work on a UNIX machine but willfail on a PC int ;.
What will be the result when run on a PC.
Page 56 Assignment Statements Variables are given a value through the use  assignment statements.
Before a variable can be used it must be declared.
For example: int ;.
The variable  on the left side  the equals  (=)  assigned the value  the expression (1 + 2) * 4 on the right side.
The semicolon ends the statement.
When you declare a , Cplus_plus allocates storage for the  and puts an unknown value inside it.
You can think  the declaration as creating a box to hold the data.
When it starts out it  a mystery box containing an unknown quantity.
This  illustrated in Figure 4-1A.
The assignment statement computes the value  the expression and drops that value into the box as shown in Figure 4-1B.
Declaration and assignment statements.
The equals  (=) is used for assignment, not equality.
Page 57 In Example 4-2 the  term is used to store an integer value that is used in two later expressions.
Variables, like expressions, can be output using the output operator <<, so we use this operator to check the results.
Example 4-2 tterm/tterrm_0_cc.
Real numbers are numbers that have a fractional part.
Because of the way they are stored internally, real numbers are also known as floating point numbers.
The numbers 5_0_5, 8_0_3, and -12_0_6 are all floating point numbers.
Cplus_plus uses the decimal point to distinguish between floating point numbers and integers, so a number such as 5_0_0  a floating point number while 5  an integer.
Floating point numbers must contain a decimal point.
Numbers such as 3_0_14159, 0_0_5, 1_0_0, and 8_0_88 are floating point numbers.
Although it  possible to omit digits before the decimal point and specify a number as _0_5 instead of 0_0_5, the extra 0 makes it clear that you are using a floating point number.
A similar rule applies to 12.
Floating point zero should be written as 0_0_0.
Additionally, a floating point number may  an exponent specification of the form e±exp.
For example, 1_0_2e34  shorthand for 1_0_2*1034.
The form of a floating point declaration :.
Again, there  a limit on the range of floating-point numbers the computer can handle.
The range varies widely from computer to computer.
Floating point accuracy  discussed further in Chapter 19, Floating Point.
Floating point numbers may be output using.
For example: << "The   " << (1_0_0 / 3_0_0) << "\n"; Page 58 Floating Point Versus Integer Divide The division operator  special.
There  a vast difference between an integer divide and a floating-point divide.
In an integer divide, the result  truncated (any fractional part discarded).
For example, the integer divide value of 19/10  1.
If either the divisor or the dividend  a floating-point number, a floating point divide executed.
Table 4-2 Expression Examples Expression Result.
Floating point Cplus_plus allows the assignment of an integer expression to a floating-point.
It will automatically perform the integer-to--point conversion and then make the assignment.
A similar conversion  performed when assigning a  point number to an integer.
Floating point numbers are truncated when assigned to  variables.
Example 4-3 float/float1c.
Page 59 Question 4-2: Why does Example 4-4 print "The value of 1/3  0".
What must be done to this program to fix it.
Characters are enclosed in single quotation marks (').
The backslash character (\)  called the escape character.
It  used to signal that a special character follows.
For example, the character \t can be used to represent the single character "tab_0_" \n  the new- character.
It causes the output device to go to the beginning of the next , similar to a return key on a typewriter.
The character \\ the backslash itself.
Finally, characters can be specified by \nnn where nnn  the octal code for the character.
Table 4-3 summarizes these special characters.
For a full list of ASCII character codes, see Appendix A.
Special Characters Character Name.
Tab Advance to the next tab stop (eight-column \' Apostrophe or single quotation mark The character '.
Page 60 NOTE While characters are enclosed in single quotes ('), a different data type, the string,  enclosed in double quotes (").
A good way to remember the difference between these two types of quotes  that single characters are enclosed in single quotes Strings can have any number of characters (including double quote characters), and they are enclosed in double quotes.
Example 4-5 reverses three characters.
Example 4-5 print3/print3 cc.
ABC reversed  CBA Boolean The Cplus_plus Draft Standard defines a boolean , bool, that can have the value true or false.
Most compilers do not yet support this new , so we will not discuss it here.
Instead, it can Programming Exercises Exercise 4-1: Write a program to print your name, Social Security number, and date of birth.
Exercise 4-2: Write a program to print a block E using asterisks (*), where the E  7 characters high and 5 characters wide.
Page 61 Exercise 4-3: Write a program to compute the area and circumference of a rectangle 3 inches wide by 5 inches long.
What changes must be made to the program so it works for a rectangle 6_0_8 inches wide by 2_0_3 inches long.
Exercise 4-4: Write a program to print "HELLO" in big block letters where each letter  7 characters high and 5 characters wide.
Answers to Chapter Questions Answer 4-1: The largest number that can be stored in an int on a UNIX machine 2,147,483,647.
When using Turbo-Cplus_plus the limit  32,767.
The zip code 92126  larger than 32,767, so it  mangled and the result  26,590.
This problem can be fixed by using a long int instead of just an int.
The various types of integers are discussed in Chapter 5, Arrays.
Qualifiers, and Reading Numbers.
Answer 4-2: The problem concerns the division: 1/3.
The number 1 and the number 3 are both integers, so this  an  divide.
Fractions are truncated in an  divide.
The expression should be written as: = 1_0_0 / 3_0_0 Page 63 5 Arrays, Qualifiers, and Reading Numbers In This Chapter:.
Types of Integers.
Types of Floats.
Programming Exercises That mysterious independent variable of political calculations, Public Opinion.
That is fine for a small number of bricks, but what happens when we want to construct something larger.
We would like to point to a stack of bricks and say, "That's for the left wall.
That's brick 1, brick 2, This declares data_list to be an array of the three elements data_list[0], data_list [1], and data_list[2], which are separate variables.
To reference an element of an array, you use a number called the index (the number inside the square brackets []).
Cplus_plus is a funny language and likes to start counting at 0, so these three elements are numbered 0-2.
Page 64 NOTE Common sense tells you that when you declare data_list to be three elements long, data_list[3] would be valid.
Common sense is wrong and data_list[3] is illegal.
Example 5-1 computes the total and average of five numbers.
The special character ' \0' (NUL) is used to indicate the end of a string.
This creates a character array four elements long.
Note that we had to allocate one character for the end-of-string marker.
String constants consist of text enclosed in double quotes (").
You may have already noticed that we've used string constants extensively for output with the  standard class.
NOTE The line # <string_0_h> is needed to inform Cplus_plus that you are using the string function library.
Cplus_plus uses variable-length strings.
For example, the declaration:.
The size of the array is 50, but the length of the string is 3.
Any string up to 49 characters long can be stored in string.
These are listed in Table 5-1.
Table 5-1 String Functions Function.
Page 66 Function.
Example 5-3 takes a first  and a last  and combines the two strings.
The program works by initializing the variable first to the first  (Steve).
The last  (Oualline) put in the variable last.
To construct the full , the first   copied into full_name.
Then strcat  used to add a space.
We call strcat again to tack on the last.
The dimension of the string variables  100 because we know that no one we are going to encounter has a  more than 99 characters long.
Note: strcat not strcpy Page 67.
The    Steve Oualline Reading Data So far you've learned how to compute expressions and output the results.
You need to have your programs read numbers as well.
The output class variable  uses the operator << to write numbers.
The input class variable cin uses the operator >> to read them.
For example, the code: cin >> price >> numbero_on_hand; reads two numbers: price and number_on_hand.
The input to this program should be two numbers, separated by white space.
For example, if you type: 32 5 then price gets the value 32 and number_on_hand gets 5.
NOTE This does not give you very precise control over your input.
Cplus_plus does a reasonable job for simple input.
If your program expects a number and you type <enter> instead, the program will skip the <enter> (it's white space) and wait for you to type a number.
Sometimes this may lead you to think your program's stuck.
In Example 5-4, we use cin to get a number from the user and then we double it: Example 5-4 double/double_0_cc # <iostream_0_h> char.
This program asks the user for a single number and doubles it.
Notice that there  no \n at the end of Enter a :.
This  because we do not want the computer to print a newline after the prompt.
For example, a sample run of the program might look like: Enter a : 12 12  24 If we replaced Enter a : with Enter a : \n the result would be: Enter a : 12 12  24 Question 5-1: Example 5-5  designed to compute the area of a triangle, given its width and height.
For some strange reason, the compiler refuses to believe that we declared the variable width.
The declaration  right there on line two, just after the definition of height.
Why isn't the compiler seeing it.
Example 5-5 comment/comment_0_cc # <iostream_0_h> int int.
When reading a string, the cin class considers anything up to the end-of-line part of the string.
Enter a :test The  of the  : 4 Initializing Variables Cplus_plus allows variables to be initialized in the declaration statement.
The number of elements in the curly braces ({}) does not have to match the array size.
If too many numbers are present, a warning will be issued.
If there are not enough numbers, the extra elements will be initialized to 0.
Page 70 If no dimension  given, Cplus_plus will determine the dimension from the number of elements in the initialization list.
For example, we could have initialized our variable  with the statement: // Product numbers for the parts we are making int [] = {10, 972, 45};.
Cplus_plus uses variable-length strings.
For example, the declaration: char [50] = "Sam"; creates an array () that can contain up to 50 characters.
The size of the array  50, and the length of the   3.
Any  up to 49 characters long can be stored in.
The other 46 elements are not initialized and may contain random data.
Multidimensional Arrays Arrays can have more than one dimension.
The declaration for a two-dimensional array :.
Additional dimensions can be tacked on.
Last element  0x201e8 Your answers may vary.
Page 72 Types of Integers Cplus_plus  considered a medium-level language because it allows you to get very close to the actual hardware of the machine.
Some languages, such as BASIC, go to great lengths to completely isolate the user from the details of how the processor works.
This consistency comes at a great loss of efficiency.
Cplus_plus lets you give detailed information about how the hardware  to be used.
For example, most machines let you use different-length numbers.
Simple BASIC allows the programmer to use only one number type.
This simplifies the programming, but BASIC programs are extremely inefficient.
Cplus_plus allows the programmer to specify many different kinds of integers, so the programmer can make best use of the hardware.
The type specifier int tells Cplus_plus to use the most efficient size (for the machine you are using) for the integer.
This can be 2 to 4 bytes depending on the machine.
Sometimes you need extra digits to store numbers larger than are allowed in a normal int.
The declaration: long int answer; // the answer of our calculations used to allocate a long integer.
The long quantifier informs Cplus_plus that you wish to allocate extra storage for the integer.
If you are going to use small numbers and wish to reduce storage,.
Cplus_plus guarantees that the storage for  <=  <= long.
In actual practice,  almost always allocates 2 bytes; long, 4 bytes; and , 2 or 4 bytes.
The type   uses 2 bytes, or 16 bits.
Fifteen bits are used normally for the number and 1 bit for the sign.
This gives it a range of -32,768 (-215) to 32,767 (215 - 1).
An unsigned uses all 16 bits for the number, giving it the range of 0 to 65,535 (216 - 1).
All declarations default to signed, so that the declaration: signed long  answer; // final result Page 73.
Character variables take up 1 byte.
They can also be used for numbers in the range of-128 to 127 or 0 to 255.
Unlike integers, they do not default to signed; the default  compiler dependent.
It's compiler dependent.
If you always specify signed or unsigned you don't have to worry about problems like.
Reading and writing very  integers  a little tricky.
If you try to use a char variable in an output statement, it will be written, as a character.
You need to trick Cplus_plus into believing that the char variable  an integer.
This can be accomplished with the  operator.
Example 5-8 shows how to write out a very  integer as a number.
Example 5-8 two2/tuo2 cc.
On the next line we write out the value of the variable.
If we tried to write  directly, Cplus_plus would treat it as a character.
The * Turbo-Cplus_plus even has a command-line switch to make the default for type char either signed or unsigned Page 74 Reading a very  integer  not possible.
You must first read it as a   and then assign it to a very  integer.
Summary of Integer Types long  declarations allow the programmer to explicitly specify extra precision where it needed (at the expense of memory).
The most compact integers have type char.
They also have the most limited range.
The kind of number you use will depend on your program and storage requirements.
The range of the various types of integers  listed in Appendix B.
Types of Floats The float type also comes in various flavors.
Double precision gives the programmer twice the range and precision of single-precision (float) variables.
The quantifier long double denotes extended precision.
On some systems   the same as double; on others, it offers additional precision.
All types of floating-point numbers are always signed.
On most machines, single-precision floating-point instructions execute faster (but less accurately) than double precision.
Double precision gains accuracy at the expense of time and storage.
In most cases float  adequate; however, if accuracy  a problem, switch to double (see Chapter 19, Floating Point).
Constant and Reference Declarations Sometimes you want to use a value that does not change, such as π.
The keyword const.
NOTE By convention variable names use lowercase only while constants use uppercase only.
However, there  nothing in the language that requires , and several programming systems use a different convention.
Page 75 Constants must be initialized at declaration time and can never be changed.
However, some compilers, such as Borland-Cplus_plus Version 3_0_1, won't allow integer constants in  type of expression.
The special character "&"  used to tell Cplus_plus that   a reference.
Reference variables Page 76 This form of the reference variable  not very useful.
In fact, in actual programming it almost never used.
In Chapter 9, Variable Scope and Functions, you'll see how another form of the reference variable can be very useful.
Qualifiers As you've seen, Cplus_plus allows you to specify a number of qualifiers for variable declarations.
Qualifiers may be thought of as adjectives that describe the type that follows.
Table 5-2 summarizes the various qualifiers.
Table 5-2 Qualifiers and Simple Types Special volatile <blank> Class register static extern auto <blank> Size long short double <blank> Sign signed unsigned <blank> Type int float char <blank> Special The volatile keyword  used for specialized programming such as I/O drivers and shared memory applications.
It  an advanced modifier whose use  far beyond the scope of this book.
A brief description of the various classes follows: register This indicates a frequently used variable that should be kept in a machine register.
See Chapter 17, Debugging and Optimization.
This keyword is described in Chapter 9, Variable Scope and Functions, and Chapter 23, Modular Programming.
Page 77 extern The variable is defined in another file.
Size The size qualifier allows you to select the most efficient size for the variable.
Sign Numbers can be signed or unsigned.
This qualifier applies only to char and int types.
Floating-point numbers are always signed.
The default is signed for int and undefined for characters.
Type This specifies the type of the variable.
Simple types include: int Integer float Floating-point number char Single characters, but can also be used for very short integers Page 78 Hexadecimal and Octal Constants Integer numbers are specified as a string of , such as 1234, 88, -123, and so on.
These are decimal (base 10) numbers: 174 or 17410.
Computers deal with binary (base 2) numbers: 101011102.
The octal (base 8) system easily converts to and from binary.
Each group of three (23 = 8) can be transformed into a single octal digit.
Thus 101011102 can be written as 10 101 1102 and changed to the octal 2568.
Hexadecimal (base 16) numbers have a similar conversion, but 4 bits at a time are used.
The Cplus_plus language has conventions for representing octal and hexadecimal values.
Leading zeros are used to signal an octal constant.
For example, 0123 is 123 (octal) or 83 (decimal).
Starting a number with "Ox" indicates a hexadecimal (base 16) constant.
Table 5-3 shows several numbers in all three bases.
Table 5-3 Integer Examples Base 10 Base 8.
Operators for Performing Shortcuts Cplus_plus not only provides you with a rich set of declarations, but also gives you a large number of special-purpose operators.
Frequently a programmer wants to increment (add 1 to) a variable.
Using a normal assignment statement, this would look like: =  + 1; Page 79.
Each of the simple operators shown in Table 5-4 can be used in this manner.
Table 5-4 Shorthand Operators Operator Shorthand.
Side Effects Unfortunately, Cplus_plus allows the programmer to use side effects.
A side effect  an operation that performed in addition to the main operation executed by the statement.
For example, the following  legal Cplus_plus code:.
The first statement assigns  the value of 5.
The second statement: But in what order.
There are four possible answers: 1.
The answer  compiler dependent and varies from computer to computer.
If you don't write code like this, you don't have to worry about these sorts of questions.
The correct answer  2: The increment occurs before the assignment.
The main effects of Cplus_plus are confusing enough without having to worry about side effects.
NOTE Some programmers highly value compact code.
This  a holdover from the early days of computing when storage cost a significant amount of money.
It  my view that the art of programming has evolved to the point where clarity  much more valuable than compactness.
The programmer doesn't read this statement, he decodes it.
If you never use plus_plus or minus_minusas part of any other statement, but always put them on a line by themselves, the difference between the two forms of these operators  not noticeable.
NOTE The prefix form plus_plusvariable  preferred over the suffix form variable plus_plus because it allows the compiler to generate slightly simpler code.
Page 81 More complex side effects can confuse even the Cplus_plus compiler.
Consider the following code.
Multiply  by 5 and add 1 to.
Multiply  by 3 and add 1 to.
Add the results of the two multiples together.
Steps 1 and 2 are of equal priority, unlike the previous example, so the compiler can execute them in any order it wants to.
Suppose it decides to execute step 1 first, as shown in Figure 5-2.
Expression evaluation, method 1 But it may execute step 2 first, as shown in Figure 5-3.
By using the first method, we get a  of 11; using the second method the   13.
The of this expression  ambiguous.
By using the operator plus_plus in the middle of a larger expression, we created a problem.
We To avoid trouble and keep the program simple, always put plus_plus and minus_minus on a line by themselves.
Page 82 Figure 5-3 Expression evaluation, method 2 Programming Exercises Exercise 5-1: Write a program that converts Celsius to Fahrenheit.
Exercise 5-3: Write a program to print out the  of a rectangle given its height and width.
Exercise 5-4: Write a program that converts kilometers per hour to  per hour.
Exercise 5-5: Write a program that takes hours and  as input and outputs the total of  ( 1 hour 30  = 90 ).
Exercise 5-6: Write a program that takes an integer as the  of  and outputs the total hours and  (90  = 1 hour 30 ).
Answers to Chapter Questions Answer 5-1: The programmer accidentally omitted the end-comment symbol ( */ ) after the comment for height.
The comment continues onto the next line and Page 83 engulfs the width variable declaration.
Example 5-9 shows the program with the comments underlined.
Answer 5-2: The problem  with the way we specified the element of the array: array[2,4].
The reason that the specification array[2,4] does not generate a syntax error  that it legal (but strange) Cplus_plus.
There  a comma operator in Cplus_plus (See Cplus_plus's Darker Corners) so the expression 2,4 evaluates to 4.
Cplus_plus treats this as a pointer (See Simple pointers) and written shows up as a memory address.
Answer 5-3: The problem  that the zip code 02137 begins with a zero.
That tells Cplus_plus that 02137  an octal constant.
When we print it, we print in decimal.
Because 021378  111910 the program prints: New York's zip code : 1119 Page 85 6 Decision and Control Statements In This Chapter:.
The Assignment Anywhere Side Effect.
Answers to Chapter Questions Once a decision was made, I did not worry about it afteruard —Harry Truman Calculations and expressions are only a small part of computer programming.
Decision and control statements also are needed, to specify the order in which statements are to be executed.
So far you have constructed linear programs, which are programs that execute in a straight line, one statement after another.
In this chapter you will see how to change the control flow of a program with branching statements and looping statements.
Branching statements cause one section of code to be executed or not, depending on a conditional clause.
Looping statements are used to repeat a section of code a number of times or until some condition occurs.
The general form of the if statement : statement; If the expression  true (nonzero) the statement will be executed.
If the expression  zero, the statement will not be executed.
For example, suppose you are writing a billing program.
At the end, if the customer owes nothing or if he has credit (owes a negative amount) you want to print a message.
In Cplus_plus this  written: << "You owe nothing_0_\n"; Page 86 <=  a relational  that represents less than or equal to.
This statement reads "if the   less than or equal to zero, print the message_0_"  complete list of relational operators  found in Table 6-1.
Relational Operators Operator Meaning.
Not equal Multiple relational expressions may be grouped together with logical operators.
For example, the statement: << "Quit\n"; uses the logical OR  ( || ) to cause the if statement to print "Quit" if either a lowercase "q" or an uppercase "_0_" Table 6-2 lists the logical operators.
Table 6-2 Logical Operators Operator Usage.
For readability, the statements enclosed in curly braces are usually indented.
This allows the programmer to quickly tell which statements are to be conditionally executed.
As you will see later, mistakes in indentation can result in programs that are misleading and hard to read.
Page 87 else Statement An alternative form of the if statement : statement; else statement; If the condition  true, the first statement  executed.
If it  false, the second statement executed.
In our accounting example, we wrote out a message only if nothing was owed.
In real life we probably want to tell the customer how much he owes if there is a balance due.
Now consider this program fragment: // If #1.
You don't have to worry about this situation if you never write code like this.
According to the Cplus_plus syntax rules, the else goes with the nearest if, so 2 is syntactically correct.
But writing code like this violates the KISS principle (Keep It Simple, Stupid).
It is best to write your code as clearly and simply as possible.
This code fragment should be written as:.
From our original example, it was not clear which if statement had the else clause; however, adding an extra set of braces improves readability, understanding, and clarity.
How Not to Use strcmp function strcmp compares two strings and returns zero if they are equal and nonzero if they are different.
To check whether two strings are equal, we use  code: // Check for equal.
Unfortunately,  obvious is wrong.
If  strings are equal strcmp returns zero, and   is not executed.
Because of this backwards behavior of strcmp, you should be very careful in your use of strcmp and always comment its use.
Looping Statements Computers not only do calculations, but also will do them over and over and over.
To get a computer to repeat its work, you need a loop statement.
Looping statements have many uses.
For example, loops are used to   number of words in a document or to   number of accounts that have past due balances.
The Fibonacci sequence is: 1 1 2 3 5 8.
The terms are computed from  equations: 1 1 2=1+1 3=2+1 5=3+2 etc.
In general terms this is: = - + -2 This is a mathematical equation using math-style variable names ().
Mathematicians use this very terse style of naming variables.
In programming, terse is dangerous, so we translate these names into something verbose for Cplus_plus.
We want to loop until our current term is 100 or larger.
The while loop: will repeat our computation and printing until we reach this limit.
In our while loop we compute  value of current_number and print it Next we need to advance one term.
This completes  body of  loop.
The first two terms of  Fibonacci sequence are 1 and 1.
We initialize our first two terms to these values.
Figure 6-1 shows what happens to  variables during  execution of  program.
We print  value of  current term.
Then  variable  is computed (value 2).
Next we advance one term by putting  into current_number and current_number into old_number.
This is repeated until we compute  last term and  while loop exits.
Page 90 Example 6-1 shows this written as Cplus_plus code.
Example 6-1 fib/fib cc # <iostream_0_h> int old_number;.
Page 91 Break Statement We have used a while statement to compute Fibonacci numbers less than 100.
The loop exits when  condition at  beginning becomes false.
Loops also can be exited at any point through  use of a break statement.
Suppose you want to add a series of numbers and you don't know how many numbers are to be added together.
You need some way of letting  program know it has reached  end of list.
In Program 6-2 you use  number zero (0) to signal  end of  list.
Note that  while statement begins with: while (1) { The program will loop forever because  while will exit only when  expression 1 is zero.
The only way to exit this loop is through a break statement.
When we see  end-of-list indicator (zero), we use  statement: break; to exit  loop.
For example, if you modify  previous program to  only numbers larger than 0, you get Example 6-3.
The first version buries the assignment of  inside the expression.
Programs should be clear and simple and should not hide anything.
The most important rule of programming is KEEP IT SIMPLE.
Cplus_plus also allows you to put assignment statements in the while conditional.
For example: // do not program like this << " " <<  << '\n';.
Sample output: Enter number of dollars owed: 12 You  0 dollars.
Programming Exercises Exercise 6-1: Write a program to find the square of the distance between two points.
Find the distance only if you want to do the independent research needed to perform a square root in Cplus_plus.
Exercise 6-2: A professor generates letter grades using Table 6-3.
Table 6-3 Grade Values % Correct Grade.
A Given a numeric grade, print the letter.
Exercise 6-3: Modify the previous program to print out a + or - after the letter grade based on the last digit of the score.
The modifiers are listed in Table 6-4.
Table 6-4 Grade-Modification Values Last digit Modifier.
Note: An F is only an F.
NOTE Programmers frequently have to modify code that someone else wrote.
Exercise 6-4: Given an amount (less than $1_0_00), compute the number of quarters, dimes, nickels,  pennies needed.
Exercise 6-5:  leap year is any year divisible by 4 unless it is divisible by 100, but not 400.
Write a program to tell whether a year is a leap year.
Page 95 Exercise 6-6: Write a program that, given the number of hours an employee worked  his hourly wage, computes his weekly pay.
Count any hours over 40 as overtime at time--a-half.
Answers to Chapter Questions Answer 6-1: This program illustrates the most common Cplus_plus error  one of the most frustrating.
The problem is that Cplus_plus allows assignment statements inside of if conditionals.
The statement: uses a single equal sign instead of the double equal.
Cplus_plus will assign  the value 0  then test the result (which is zero).
If the result were nonzero (true), the if clause would be executed.
Since the result is zero (false).
The statement is equivalent to = 0; The statement should be written: This is the most common error that beginning programmers make.
It is also one  the most difficult  frustrating to find.
I once taught a course  C programming.
One day about a month after the course had ended I saw one  my former students on the street.
He greeted me  said, "Steve, I have to tell you the truth.
During the class I thought you were going a bit overboard on  =.
Mark Up the Program.
Programming Exercises It's just a simple matter  programming.
Software has a life cycle.
It is born, grows up, becomes mature,  finally dies, only to be replaced by a newer, younger product.
Understanding  cycle is important because as a programmer you will spend only a small amount  time actually writing new.
Most programming time is spent modifying debugging existing.
Software does not exist  a vacuum; it must be documented, maintained, enhanced,  sold.
In  section we take a look at a small programming project using one programmer.
Larger projects that involve many people are discussed  Chapter 23, Modular Programming.
Although the final  is fewer than a hundred lines, the principles used  its construction can be applied to programs with thousands  lines.
Figure 7-1 illustrates the software life cycle.
The major steps  making a program are:.
Programs start when someone gets an idea  assigns you to implement it.
The requirement document describes,  very general terms, what is wanted.
In the beginning, a Preliminary Specification is used to describe what the program is going to do.
Later, as the program becomes more refined, so does the specification.
Finally, when the program is finished, the specification serves as a complete description  what the program does.
Page 98 Figure 7-1.
Software life cycle.
The programmer does an overall design  the program.
The design should include major algorithms, class definitions, module specifications, file formats,  data structures.
One thing cannot be over-stressed; "Think before you act_0_" Studies have shown that a good design can result  a program that is 1/10  the size  a poorly designed one.
This is especially true when using Cplus_plus, where designPage 99 ing good objects is critical to writing a good program.
The next step is writing the program.
This involves first writing a prototype then filling it  to create the full program.
The programmer should design a test plan  use it to test the program.
It is a good idea, when possible, to have someone else test the program.
Unfortunately, very few programs work the first time.
They must be corrected tested again.
The program is packaged, documented, and sent out into the world to be used.
Programs are never perfect.
Bugs will be found and will need correction.
Revising and updating.
After a program has been working for a while, the users will want changes, such as more features or more intelligent algorithms.
At  point a new specification is created and the process starts again.
Setting Up The operating system allows you to group files  directories.
Just as file folders serve as a way  keeping papers together  a filing cabinet, directories serve as a way  keeping files together.
In  chapter you will be creating a simple calculator program.
All the files for program will be stored  a directory named calc.
To create a directory  UNIX, execute the following commands: % cd % mkdir calc In MS-DOS, type: C:\> cd \ C:\> mkdir calc To tell the operating system which directory you want to use,  UNIX type the command: % cd ~/calc In MS-DOS, type: C:\> cd \calc C: \CALC> Page 100 More information on how to organize directories can be found  your operating system documentation.
The Specification For  chapter we are going to assume that you have been given the assignment to "write a program that acts like a four-function calculator_0_" Typically, the specification you are given is vague and incomplete.
It is up to you to refine it into something that exactly defines the program you are going to produce.
The first step is to write a document called The Preliminary Users' Specification, which describes what your program is going to do and how to use it.
This document does not describe the internal structure  the program or the algorithm you plan to use.
A sample specification for the four-function calculator is: Calc A four-function calculator Preliminary Specification Dec.
Any resemblance to any software living or dead is purely coincidental.
Calc is a program that allows the user to turn his $10,000 computer into a $1_0_98 four-function calculator.
The program adds, subtracts, multiplies, and divides simple integers.
When the program is run, it zeros the result register and displays its contents.
The user can then type in an operator and number.
The result is updated and displayed.
The following operators are valid: Operator Meaning.
Division calc Result: 0 Enter operator and number: + 123 Result: 123 Enter operator and number: - 23 Result: 100 Page 101 Enter operator and number: / 25 Result: 4 Enter  and number: * 4 Result: 16 The preliminary specification serves two purposes.
First, you should give it to your boss (or customer) to make sure that what he thought he said and what you thought he said agree.
Second, you can circulate it among your colleagues to see whether they have any suggestions or corrections.
This preliminary specification was circulated and received the comments: 1) "How are you and we add another paragraph: Dividing by 0 results in an error message and the result register is left unchanged.
The professor didn't say what sort of numbers had to be used, so the student created a program that worked only with Roman numerals ( +  = VII).
The program came with a complete user manual—written in Latin.
Code Design After the preliminary specification has been approved, you can start designing code.
In the code-design phase, you plan your work.
In large programming projects involving many people, the code would be broken up into modules for each programmer.
At this stage, file formats are planned, data structures are designed, and major algorithms are decided upon.
This simple calculator uses no files and requires no fancy data structures.
What's left for this phase is to design the major algorithm.
Outlined in pseudo-code, a shorthand halfway between English and real code, it is: Loop Read an  and number Do the calculation Page 102 Display the result End-Loop The Prototype Once the code design is completed, you can begin writing the program.
But rather than try to write the entire program at once and then debug it, you will use a method called fast prototyping.
This consists of writing the smallest portion of the specification you can implement that will still do something.
In our case, you will cut the four functions down to a one-function calculator.
Once you get this small part working, you can build the rest of the functions onto this stable foundation.
Also, the prototype gives the boss something to look at and play around with so he has a good idea of the direction the project is taking.
Good communication is the key to good programming, and the more you can show someone, the better.
The code for the first version of the four-function calculator is found in Example 7-1.
Example 7-1 calc/calc cc # <iostream_0_h> int char.
These are parsed and stored in the variables and value.
If the  is a plus (+), you perform an addition using the line: if ( = '+') { += value;.
The Makefile Once the source has been entered, it needs to be compiled and linked.
Up to now we have been running the compiler manually.
This is somewhat tedious and prone to error.
Also, larger programs consist of many modules and are extremely difficult to compile by hand.
Fortunately, both UNIX and Turbo-Cplus_plus have a utility called make that handles the details of compilation.
For now, just use this example as a template and substitute the name of your program in place of calc.
The make program is discussed in detail in Chapter 23, Modular Programming.
Basically, make looks at the file called Makefile for a description of how to compile your program and runs the compiler for you.
For a UNIX system using the generic  compiler, the Makefile should be: [File: calcl/makefile_0_unx] # # Makefile for many UNIX compilers using the # "standard" command name # = =-g all: calc calc: calc_0_cc Page 104 $() $() -o calc calc_0_cc clean: rm calc If you are using the Free Software Foundation's gplus_plus compiler, the Makefile is: [File: calcl/makefile_0_gnu] # # Makefile for the Free Software Foundations gplus_plus compiler # =gplus_plus =-g -Wall all: calc calc: calc_0_cc $() $() -o calc calc_0_cc clean: rm calc For Turbo-Cplus_plus, the Makefile should be: [File: calcl/makefile_0_tcc] # # Makefile for Borland's Turbo-Cplus_plus compiler # =tcc # # Flags # -N minus_minus Check for stack overflow # -v minus_minus Enable debugging # -w minus_minus Turn on all warnings # -ml minus_minus Large model # =-N -v -w -ml all: calc_0_exe calc_0_exe: calc_0_cpp $() $() -ecalc calc_0_cpp clean: erase calc_0_exe For Borland Cplus_plus, the Makefile is the same except the compiler is named bcc.
Finally, for Microsoft Visual Cplus_plus, the Makefile is: [File: calcl/makefile_0_msc] # # Makefile for Microsoft Visual Cplus_plus # =cl # # Flags # AL minus_minus Compile for large model Page 105 # Zi minus_minus Enable debugging # W1 minus_minus Turn on warnings # =/AL /Zi /W1 all: calc_0_exe calc_0_exe: calc_0_cpp calc_0_cpp.
To compile the program, just execute the command make.
Compilation creates an object file.
The modification date of the object file is later than the modification date of its source.
If the source is edited, its modification date is updated, making the object file out of date.
Testing Once the program is compiled without errors, you can move on to the testing phase.
Now is the time to start writing a test plan.
This document is simply a list of the steps you perform to make sure the program works.
It is written for two reasons.
If a bug is found, you want to be able to reproduce it.
If you ever change the program, you will want to retest it to make sure new  did not break any of the sections of the program that were previously working.
The test plan starts out as: Try the following operations + 123 + 52 x 37 Result should be 123 Result should be 175 Error message should be output Page 106 Running the program you get: Result: 0 Enter operator and number: + 123 Result: 123 Enter operator and number: + 52 Result: 175 Enter operator and number: x 37 Result: 212 Something is clearly wrong.
The entry "x 37" should have generated an error message but didn't.
There is a bug in the program, so you begin the debugging phase.
One advantage to making a small working prototype is that you can isolate errors early.
Debugging First you inspect the program to see if you can detect the error.
In such a small program it is not difficult to spot the mistake.
However, let's assume that instead of a 21-line program, you have a much larger one containing 5,000 lines.
Such a program would make inspection more difficult, so you need to proceed to the next step.
Most systems have Cplus_plus debugging programs, but each debugger is different.
Some systems have no debugger.
In that case you must resort to a diagnostic print statement.
Then put a  where the data is bad.
Run the program and keep putting in 's until you isolate the area in the program that contains the mistake.
NOTE The ## at the beginning of each  line flags the line as a debug line.
This makes it easy to tell the temporary debug output from the real program output.
Also, when you finally find the bug the ## makes it easy to find and remove the debug lines with your editor.
Page 107 Running the program again results in: Result: 0 Enter  and number: + 123 Result: 123 Enter  and number: + 52 ## after  + ## after  + Result: 175 Enter  and number: x 37 ## after  x ## after  + Result: 212 From this you see that something is going wrong with the  statement.
Somehow the variable is an x going in and a + coming out.
Closer inspection reveals that you have the old mistake   = instead  ==.
After you fix this bug, the program runs correctly.
Building on this working foundation, you add in the  for the other operators, -, *, and /, to create Example 7-2.
Example 7-2 calc3/calc3_0_c # <iostream_0_h> int ;.
You expand the test plan to  the new  and try it again.
The word "Preliminary" is removed from the specification and the program, test plan, and specification are released.
Maintenance Good programmers put their programs through a long and rigorous testing process before releasing it to the outside world.
Then the first user tries the program and almost immediately finds a bug.
This starts the maintenance phase.
Bugs are fixed, the program is tested (to make sure the fixes didn't break anything), and the program is released again.
Revisions Although the program is officially finished, you are not finished with it.
After it is in use for a few months, someone will come to us and ask, "Can you add a modulus _0_" So you revise the specifications, add the change to the program, update the test plan, test the program, and release it again.
As time passes, more people will come to you with additional requests for changes.
Soon the program has trig functions, linear regressions, statistics, binary arithmetic, and financial calculations.
The design is based on the idea  -character.
Soon you find yourself running out  characters to use.
At this point the program is doing work far beyond what it was initially designed to do.
Sooner or later you reach the point where the program needs to be scrapped and a new  written from scratch.
At this point you write a new Preliminary Specification and start the process over again.
Page 109 Electronic Archaeology Unfortunately, most programmers don't start a project at the design step.
Instead they are immediately thrust into the maintenance or revision stage.
This means the programmer is faced with the worst possible job: understanding and modifying someone else's code.
Contrary to popular belief, most Cplus_plus programs are not written by disorganized orangutans Zen programming techniques and poorly commented in Esperanto.
They just look that way.
Electronic archeology is the art  digging through old code to discover amazing things (like how and why the code works).
Your computer can aid greatly in your search to discover the true meaning  someone else's code.
Many tools are available for examining and formatting code.
Many C tools have yet to be upgraded for Cplus_plus.
See earlier sections on revisions_0_) Some  these tools :.
These programs have names like xref, cxref, and cross.
System V UNIX has the utility cscope.
They print out a list  variables and where the variables are used.
A pretty printer such as vgrind or cprint typesets source code for printing on a laser printer.
On System V UNIX the program cflow analyzes the structure  the program.
On other systems there is a public domain utility, calls, that produces call graphs, showing who calls whom and who is called by whom.
A class browser allows you to display the class hierarchy so you can tell what components went into building the class as well as its structure.
You'll learn what a class is in Chapter 13, Simple Classes.
Different programmers work in different ways.
Some techniques for examining code are listed below.
Choose the ones that work for you and use them.
Mark Up the Program Take a printout  the program and make notes all over it.
Use red or blue ink so you can tell the difference between the printout and the notes.
Use a highlighter to emphasize important sections.
These notes are useful; put them in the program as comments, and then make a new printout and start the process over again.
Page 110 Use the Debugger The debugger is a great tool for understanding how something works.
Most debuggers allow you to step through the program  line at a time, examining variables and discovering how things really work.
Once you find out what the code does, make notes and put them in as comments.
Use the Text Editor as a Browser One of the best tools for going through someone else's code is your text editor.
Suppose you want to find out what the variable sc is used for.
Use the search command to find the first place sc is used.
Search again and find the second.
Continue searching until you know what the variable does.
Suppose you find out that sc is used as a sequence counter.
Since you're already in the editor, you can easily do a global search-and-replace to change the variable sc to sequence_counter.
Also make sure you do a word replacement or you'll find you replaced sc in places you didn't intend_0_) Comment the declaration and you're on your way to creating an understandable program.
Add Comments Don't be afraid to put any information you have, no matter how little, into the comments.
As you go through someone else's code adding comments and improving style, the structure will become clearer to you.
By inserting notes (comments), you make the code better and easier to understand for future programmers.
Suppose you are confronted with the following program written by someone from the "The Terser the Better" school of programming.
Your assignment is to figure out what this program does.
First you pencil in some comments as shown in Figure 7-2.
Page 111 Figure 7-2.
A terse program This mystery program requires some work.
After going through it and applying the principles described in this section, you get the well-commented, easy-to-understand version shown in Example 7-3.
Example 7-3 guess/good_0_cc /******************************************************** * guess minus_minus a simple guessing game * * * * Usage: * * guess * * * * A random number is chosen between 1 and 100.
Because () returns a number * * 0 <= () <= maxint this slightly favors * Page 112 * the lower numbers.
Programming Exercises For each assignment, follow the software life cycle from specification through release.
Exercise 7-1: Write a program to convert English units to metric (e_0_g_0_, miles to kilometers, gallons to liters, etc_0_).
Include a specification and a code design.
Exercise 7-2: Write a program to perform date arithmetic, such as how many days there are between 6/1/90 and 8/3/92.
Include a specification and a code design.
Exercise 7-3: A serial transmission line can transmit 960 characters a second.
Write a program that will calculate how long it will take to send a file, given the file's size.
Try it on a Exercise 7-4: Write a program to add an 8% sales tax to a given amount and round the result to the nearest penny.
Exercise 7-5: Write a program to tell whether a number is prime.
Exercise 7-6: Write a program that takes a series of numbers and counts the number of positive and negative values.
Page 115 II Simple Programming Page 117 8 More Control Statements In This Chapter:.
Answers to Chapter Questions Grammar, which knows how to control even kings —Molière for Statement The for statement allows you to execute a block of code a specified number of times.
The general form of the for statement is:.
Normally you count five items as 1, 2, 3, 4, 5.
You will get along much better in Cplus_plus if you change your thinking to zero-based counting and count five items as 0, 1, 2, 3, 4.
Careful examination of the two flavors of this program reveals the similarities between the two versions, as shown in Figure 8-1.
Many older programming languages do not allow you to change the control variable (in this case ) inside the loop.
You can change the control variable anytime you wish—you can jump into and out of the loop and generally do things that would make a PASCAL or FORTRAN programmer cringe.
Similarities between while and for Question 8-1: Example 8-3 contains an error.
Page 120 Question 8-2: Example 8-4 reads a list of five numbers and counts the number of threes and sevens in the data.
Why does it give us the wrong answers.
Number of sevens in the data The data to count 3 and 7 in Number of threes in the data Index into the data.
The general form of a switch statement : case constantl: statement _0__0__0_.
Duplicate labels are not allowed, so only one case will be selected.
The expression must evaluate to a integer, character, or enumeration.
The default label can be put anywhere in the switch.
When Cplus_plus sees a switch statement, it evaluates the expression and then looks for a matching case label.
If none  found, the default label  used.
If no default  found, the statement does nothing.
A break statement inside a switch tells the computer to continue the execution after the switch.
If the break  not there, execution continues with the next statement.
NOTE The switch statement  very similar to the PASCAL case statement.
The main differences are that while PASCAL allows only one statement after the label, Cplus_plus allows many.
Cplus_plus keeps executing until it hits a break statement.
In PASCAL you can't "fall through" from one case to another.
The calculator program in Chapter 7, The Programming Process, contains a series of if-else statements.
This section of code can easily be rewritten as a switch statement.
In this switch, we use a different case for each operation.
The default clause takes care of all the illegal operators.
Rewriting the program using a switch statement makes it not only simpler, but also easier to read as seen in Example 8-5.
Example 8-5 calc-sw/calc3_0_cc # <iostream_0_h> int ;.
A break statement is not required at the end of a case.
If the break is not there, execution will continue with the next statement.
For example: = 0; // A not so good example of programming case 0: << "Reset\n"; case 1:.
Reset Initializing Case 0 does not end with a break statement.
After printing "Reset" the program falls // A better example of programming.
But suppose we modify the program slightly and add another case to the switch: // We have a little problem case 0: << "Reset\n";.
Working Closing down This is an unpleasant surprise.
The problem is caused by the fact that case 2 is no longer the last case.
If you always put in a break statement, you don't have to worry about whether or not it is really needed.
Finally, we ask the question: What happens when  == 5.
In this case, since there is no matching case or a default clause, the entire switch statement is skipped.
In this example, the programmer did not  a default statement because  will never be anything but 0, 1, or 2.
However, variables can get assigned strange values, so we need a little more defensive programming.
Used inside a switch it causes the  to exit the switch statement.
Inside of a for or while loop, it causes a loop exit.
The continue statement is only valid inside a loop and causes the  to go to the top of the loop.
To illustrate how these statements work, we've produced a new  of the calculator The new  prints the  only after valid data is input and has a Help command.
The Help command is special.
We don't want to print the  after the Help command, so instead of ending the Help case with a break we end it with a continue.
The continue forces execution to go to the top of the loop.
When an unknown  is entered, we print an error message.
As with the Help case, we use a continue statement to skip printing the.
Finally, there is one special command: quit.
This command is handled outside the switch.
It is handled by the break at the top of the loop.
Since the break is outside the switch, it belongs to the while loop and causes the  to exit the while.
The  flow for this  can be seen in Figure 8-2.
Page 126 Figure 8-2 switch/continue Page 127 Programming Exercises Exercise 8-1: Print a checkerboard (8-by-8 grid).
Each square should be 5-by-3 characters wide.
A 2-by-2 example follows: +minus_minusminus_minus-+minus_minusminus_minus-+ | | | | | | | | | +minus_minusminus_minus-+minus_minusminus_minus-+ | | | | | | | | | +minus_minusminus_minus-+minus_minusminus_minus-+ Exercise 8-2: The total resistance of n resistors in parallel is: Suppose we have a network of two resistors with the values 400Ω and 200Ω.
Then our equation would be: Substituting in the value of the resistors we get: So the total resistance of our two-resistor network is 133_0_3Ω.
Write a  to compute the total resistance for any number of parallel resistors.
Exercise 8-3: Write a  to average n numbers.
Exercise 8-4: Write a  to print out the multiplication table.
Exercise 8-5: Write a  that reads a character and prints out whether or not it is a vowel or a consonant.
Page 128 Exercise 8-6: Write a  that converts numbers to words.
Example: 895 results in "eight Answers to Chapter Questions Answer 8-1: The problem lies with the semicolon (;) at the end of the for statement.
The body of the for statement is between the closing parentheses and the semicolon.
Even though the  statement is indented, it is not part of the for statement.
The indentation is misleading.
The Cplus_plus compiler does not look at indentation.
The  does nothing until the expression <= 100 becomes false ( == 101).
Answer 8-2: The problem is that we read the number into data[1] through data[5].
In Cplus_plus the range of legal array indices is 0 to <array size>-1 or in this case 0 to 4.
When we use it strange things happen; in this case the variable three_count is changed.
The solution is to use only data[0] to data[4].
Page 129 9 Variable Scope and Functions In This Chapter:.
Scope and Storage Class Functions Summary of Parameter Types Structured Programming Basics Recursion Programming Exercises Answers to Chapter Questions But in the gross and scope of my opinion This bodes some strange eruption to our state.
These are variables that can be set or used almost anywhere in the program.
In this chapter you learn about other kinds of variables and how to use them.
This chapter also tells you how to divide your code into functions.
Many aspects of functions are detailed, including function overloading, using functions to build structured programs, and the use of recursive function calls.
Scope and Storage Class All variables have two attributes, scope and storage class.
The scope of a variable is the area of the program where the variable is valid.
A global variable is valid from the point it is declared to the end of the program.
A local variable's scope is limited to the block where it is declared and cannot be accessed (set or read) outside that block.
A block is a section of code enclosed in curly braces ({}).
Figure 9-1 illustrates the difference between local and global variables.
It is possible to declare a local variable with the same name as a global variable.
Normally, the scope of the variable count (first declaration in Figure 9-2) would be the whole program.
The declaration of a second, local count takes precedence over the global declaration inside the small block where the local count is declared.
In this block, the global count is hidden.
You can also nest local declarations and hide local variables.
These "very local" variables have an even smaller and more local scope than the "normal local" variables.
Local and global variables of the previous sentence gives you some idea why using nesting to hide local variables does not make your program easy to understand_0_) Figure 9-2 illustrates a hidden variable.
Figure 9-2 Hidden variables The variable count is declared both as a local variable and as a global variable.
Normally the scope of  (global) would be the entire program, but when a variable is declared inside a block, that instance of the variable becomes the Page 131 active one for the length of the block.
The global  has been hidden by the local for the scope of this block.
The shaded area in the figure shows where the scope of (global) is hidden.
It is not good programming practice to hide variables.
The problem is that when you have the statement: = 1; it is difficult to tell which  you are referring to.
Is it the global , the one declared at the top of main, or the one in the middle of the while loop.
It is better to give these variables different names, such as total_count, current_ , and item_count.
The storage class of a variable may be either permanent or temporary.
Global variables are always permanent.
They are created and initialized before the program starts and remain until it terminates.
Temporary variables are allocated from a section of memory called the stack at the beginning of the block.
If you try to allocate too many temporary variables you will get a stack overflow error.
The space used by the temporary variables is returned to the stack at the end of the block.
Each time the block is entered, the temporary variables are initialized.
The size of the stack depends on the system and compiler you are using.
On many UNIX systems, the program is automatically allocated the largest possible stack.
On other systems, a default stack size is allocated that can be changed by a compiler switch.
In Turbo-Cplus_plus the stack space must be fewer than 64,000 bytes.
This may seem like a lot of space, but several large arrays can eat it up quickly.
You should consider making all large arrays permanent.
Local variables are temporary unless they are declared static.
NOTE static has an entirely different meaning when used with global See Chapter 23, Modular Programming.
For a complete discussion of the many meanings of the word "static," see Table 14-1.
Example 9-1 illustrates the difference between permanent and temporary variables.
We have chosen obvious variable names; temporary is a temporary variable while permanent is permanent.
Cplus_plus initializes temporary each time it is created (at the beginning of the for statement block), while permanent gets initialized only once, at program start-up time.
In the loop both variables are incremented.
However, at the top of the loop temporary is initialized to 1.
Page 132 Example 9-1 perm/perm_0_cc.
The output of this program is: Temporary 1  1 Temporary 1  2 Temporary 1  3 NOTE Temporary variables are sometimes referred to as automatic variables because the space for them is allocated automatically.
The qualifier auto can be used to denote a  variable; however, in practice auto is almost never used.
Table 9-1 describes the different ways a variable can be declared.
Table 9-1 Declaration Modifiers Declared Scope.
Once NOTE The keyword static is the most overloaded Cplus_plus operator.
It means a lot of different things depending on how it is used.
For a complete list see Table 14-1.
Page 133 Functions Functions allow you to group commonly used code into a compact unit that can be used repeatedly.
You have already encountered one function, main.
It is a special function called at the beginning of the program.
All other functions are directly or indirectly called from main.
Suppose you want to write a program to compute the area of three triangles.
You could write out the formula three times, or you could create a function to do the work and then use that function three times.
Each function should begin with a comment block containing the following: Name Name of the function Description Description of what the function does Parameters Description of each parameter to the function Returns Description of the return value of the function Additional sections may be added such as file formats, references, or notes.
Refer to Chapter 3, Style, for other suggestions.
The function to compute the area of a triangle begins with: /******************************************* * Triangle minus_minus compute area of a triangle * * * * Parameters * * width minus_minus width of the triangle * * height minus_minus height of the triangle * * * * Returns * * area of the triangle * *******************************************/ The function proper begins with the lines: float is the function type.
This defines the type of data returned by the function.
Parameters are variables local to the function that are used to pass information into the function.
Page 134 NOTE The function type is not required by Cplus_plus.
If no function type is declared, the type defaults to int.
However, if you omit the function type, it is not clear whether you want to have the function default to int or you just forgot the function type.
To avoid this confusion, always declare the function type and do not use the default.
The function computes the  with the statement: = width * height / 2_0_0;.
What's left is to give the result to the caller.
This is done with the return statement: The full triangle function can be seen in Example 9-2.
When Cplus_plus sees this function call it performs the following operations: Triangle's variable  = 1_0_3 Triangle's  = 8_0_3 Begin execution of the first line of the function triangle.
Page 135 The technical name for this type of parameter passing is "call by value_0_" The assignment only occurs when the function is called, so data flows through the parameters only one way: in.
The return statement is how you get data out of the function.
In the triangle example, the function assigns the local variable  the value 5_0_4 and then executes the statement return (), so the return value of this function is 5_0_4.
This value is assigned to.
Example 9-3 computes the  of three triangles.
Functions must be declared just like variables.
The declaration tells the Cplus_plus compiler about the function's return value and parameters.
There are two ways of declaring a function.
The first is to write the entire function before it's used.
The other is to define what's called a function prototype, which gives the compiler just enough information to call the function.
A function prototype looks like the first Page 136 line of the function, only the function has no body.
For example, the prototype for the function is: float (float , float ); Note the semicolon at the end of the line.
This is used to tell Cplus_plus that this is a prototype and not a real function.
Cplus_plus allows you to leave out the parameter names when declaring a prototype.
This function could just as easily have been written: float (float, float); However, this technique is not commonly used.
The reason is that it's very easy to create a prototype by simply using the editor to copy the first line of a function and put that line where you want the prototype.
Functions that have no parameters are declared with a parameter list of void.
For example: int get_value(void); The keyword void  also used to indicate a function that does not return a value (similar to the FORTRAN SUBROUTINE or PASCAL Procedure).
For example, this function just prints a result, it does not return a value.
Ordinary parameters can be changed inside functions, but the changes will not be passed back to the calling program.
Page 137 For example, in the  function, we never change  or.
These could easily be declared const.
Since the return value  also something that cannot be changed, it can be declared const as well.
The const declarations serve to notify the programmer that the parameters do not change inside the functions.
If you do attempt to change a const parameter, the compiler generates an error.
The improved  function with the const declarations can be seen in Example 9-4.
Reference Parameters and Return Values Remember that in Chapter 4, Basic Declarations and Expressions, we discussed reference variables.
A reference variable  a way of declaring an additional name for a variable.
For global and local variables, reference variables are not very useful.
However, when used as parameters they take on an entirely new.
Suppose you want to write a subroutine to increment a counter.
If you write it like Example 9-5, it won't work.
Because Cplus_plus defaults to call by value.
This means that values go in, but they don't come out.
What happens if you convert the parameter counter to a reference.
References are just another way of giving the same variable two names.
When inc_counter  called, counter becomes a reference to.
That means that anything done to counter results in changes to.
Example 9-6, using a reference parameter, works properly.
Examining this program we find that it looks a lot like Example 9-5 except for the "&" in front of counter.
This "&" tells Cplus_plus that counter  a reference and not a normal call-by-value parameter.
Reference declarations can also be used for return values.
For example, Example 9-7 finds the biggest element in an array.
When used on  it returns a reference to [2].
Remember that in the following code,  (, 5) [2].
The following three code sections all perform equivalent operations.
The actual variable, [2], does not change; however, the way we refer to it does.
Page 140 Dangling References You should be careful when using "return by reference_0_" If you're not careful, you can wind up with a reference to a variable that no longer exists.
Example 9-8 illustrates this problem.
Example 9-8 ref/ref cc 1 # <iostream_0_h> 2 4 { 5 6 return (1); 7.
It returns a reference to the smaller of two integers.
In line 12 we call this function.
Before the function min  called Cplus_plus creates a temporary integer to hold the value of the expression 1 + 2.
A reference to this temporary  passed to the min function as the parameter 1.
Cplus_plus creates another temporary for the 2 parameter.
The function min  then called and returns a reference to 1.
It refers to a temporary that Cplus_plus created in main.
At the end of the statement Cplus_plus can destroy all the temporaries.
Let's look at the call to min (line 12) in more detail.
Here's a pseudocode version of line 12, including the details that Cplus_plus normally hides from the programmer: create integer tmp1, assign it the value 1 + 2 create integer tmp2, assign it the value 3 + 4 bind parameter 1 so it refers to tmpl bind parameter 2 so it refers to tmp2.
Page 141 At the end of line 12 we have a bad situation:  refers to a temporary variable that has been destroyed.
In other words,  points to something that does not exist.
This is called a dangling reference and should be avoided.
Array Parameters So for you've dealt only with simple parameters.
Cplus_plus treats arrays a little differently.
First of all, you don't have to put a size in the prototype declaration.
For example: int sum(int array[]); Cplus_plus uses a parameter-passing scheme called "call by address" to pass arrays.
Another way of thinking of this is that Cplus_plus automatically turns all array parameters into reference parameters.
This allows any size arrays to be passed.
The function sum we just declared may accept integer arrays of length 3, 43, 5,000, or any length.
However, if you want to put in a size you can.
Cplus_plus allows this although it ignores whatever number you put there.
But by putting in the size you alert the people reading your program that this function takes only fixed-size arrays.
Now we have two functions with the same name.
In older languages such as C and PASCAL that would be true.
Cplus_plus allows function overloading, which means you can define multiple functions with the same names.
Thus you can define a square function for all types of things: int, float, short int, double, and even char if we could figure out what it means to square a character.
To keep your code consistent, all functions that use the same name should perform the same basic function.
For example you could define the following two square functions: // Square an integer.
This is perfectly legal Cplus_plus code, but it is confusing to anyone who has to read the code.
The problem is that Cplus_plus uses the parameter list to tell the functions apart.
But the parameter list of the two get_number routines is the same: (void).
The result is that Cplus_plus can't tell these two routines apart and flags the second declaration as an error.
Default Parameters Suppose you want to define a function to draw a rectangle on the screen.
This function also needs to be able to  the rectangle as needed.
The function definition is: After using this function for a while, you discover that 90% of the time you don't use the ability of draw to.
In other words, 90% of the time the  factor is 1_0_0.
Cplus_plus allows you to specify a default value for.
Can you tell whether the programmer intended for the  to be 1_0_0 or just forgot to put it in.
Although sometimes useful, the default parameter trick should be used sparingly.
Unused Parameters If you define a parameter and fail to use it, most good compilers will generate a warning.
But what about the times you really don't want to use a parameter.
Is there a way to get Cplus_plus to shut up and not bother you.
The trick is to leave out the name of the parameter.
Some people consider this style ugly and confusing.
They're right that it's not that easy to read.
There ought to be a better way; I just wish I could think of one.
One question you might be asking by now is, "Why would I ever write code like this.
Why not It turns out that many programming systems make use of callback functions.
For example, you can tell the X Window System, "When the 'EXIT' button is pushed call the function exit_button_0_" Your callback function may handle many buttons, so it's important to know which button is pushed.
So X supplies button as a parameter to the function.
What happens if you know that only button can cause X to call exit_button.
Well, X is still going to give it to you, you're just going to ignore it.
That's why some functions have unused parameters.
Whenever Cplus_plus calls a function there is some overhead generated.
This includes putting the parameters on the stack, entering and leaving the function, and a stack fix-up after the function returns.
For example, the code:.
As you can see from this code, there are eight lines of overhead for two lines of work.
Cplus_plus allows you to cut out that overhead through the use of the inline function.
The inline keyword tells Cplus_plus that the function is very small.
This means that it's simpler and easier for the Cplus_plus compiler to put the entire body of the function in the code stream instead of generating a call to the function.
Expanding the function inline has eliminated the eight lines of overhead and results in much faster execution.
The inline modifier provides Cplus_plus a valuable hint it can use when generating code.
Inline tells the compiler that the code is extremely small and simple.
Like Page 146 register, the inline modifier is a hint.
If the Cplus_plus compiler can't generate a function inline, it will create it as an ordinary function.
Summary of Parameter Types Table 9-2 lists the various parameter types.
Table 9-2 Parameter Types Type Declaration.
Value is passed into the function and can be changed inside.
Constant call by value.
Reference is passed to the function.
Constant reference Value cannot be changed in the function.
This form of a parameter is more efficient than "constant call by value" for Array.
Value is passed in and may be modified.
Call by address.
Passes a pointer to an item.
Pointers are covered in Chapter 15, Simple Pointers.
Structured Programming Basics Computer scientists spend a great deal of time and effort studying how to program.
The result is that they come up with the absolutely, positively, best programming methodology—a new one each month.
Some of these systems include flow charts, top-down programming, bottom-up programming, structured programming, and object-oriented programming.
Now that you have learned about functions, we can talk about using structured programming techniques to design programs.
This is a way of dividing up or structuring a program into small, well-defined functions.
It makes the program easy to write and easy to understand.
I don't claim that this system is the absolute best way to program.
It happens to be the system that works best for me.
If another system works better for you, use it.
Page 147 Structured programming concentrates on a program's code.
Later you'll see how to merge code and data to form classes and begin to perform object-oriented programming.
The first step in programming is to decide what you are going to do.
This has already been described in Chapter 7, The Programming Process.
Next, decide how you are going to structure your data.
Finally, the coding phase begins.
When writing a paper, you start with an outline, with each section in the paper described by a single sentence.
The details are filled in later.
Writing a program is similar.
You start with an outline, but this outline is your main function.
The details can be hidden within other functions.
For example, the program in Example 9-10 solves all of the world's problems.
A global solution.
Of course, some of the details remain to be filled in.
Start by writing the main function.
It should be less than two pages long.
If it grows longer, consider splitting it up into two smaller, simpler functions.
The size of the function should be limited to three pages because that is about the maximum amount of information a human being can store in short-term memory at one time.
After the main function is complete, you can start on the other functions.
This type of structured programming is called top-down programming.
You start at the top (main) and work your way down.
Another type of coding is called bottom-up programming.
This involves writing the lowest-level function first, testing it, and then building on that working set.
I tend to use some bottom-up techniques when I'm working with a new  function that I haven't used before.
I write a small function to make sure I really know how the function works and continue from there.
This is the approach used in Chapter 7 to construct the calculator program.
In actual practice, both techniques are useful.
This results in a mostly top-down, partially bottom-up technique.
Computer scientists have a term for this methodology: chaos.
The one Page 148 Recursion Recursion occurs when a function calls itself directly or indirectly.
Some programming functions lend themselves naturally to recursive algorithms, such as the factorial.
A recursive function must follow two basic rules: 1.
It must have an ending point.
It must make the problem simpler.
A definition of factorial is: (0) = 1.
Second, it simplifies the problem because (-1) is simpler than ().
Factorial is legal only for  >= 0.
But what happens if we try to compute (-3).
The program aborts with a stack overflow or similar message.
There is no ending point.
This is called an infinite recursion error.
Many things we do iteratively can be done recursively, such as summing the elements of an array.
You can define a function to add elements m through  of an array as follows: If you have only one element, then the sum is simple.
Otherwise, it is the sum of the  element and the sum of the rest.
Exercise 9-2: Write a function "begins (string1, string2)" that returns true if string1 begins string2.
Write a program to test the function.
Exercise 9-3: Write a function count (, array, length) that will count the of times  appears in array.
The array has length elements.
The function should be recursive.
Write a test program to go with the function.
Exercise 9-4: Write a function that will take a character string and return a primitive hash code by adding up the value of each character in the string.
Exercise 9-5: Write a function that returns the maximum value of an array of numbers.
Exercise 9-6: Write a function that scans a string for the character "-" and replaces it with "_".
Answers to Chapter Questions 9-1: The programmer went to a lot of trouble to explain that the for loop did nothing (except increment the index).
However, there is no semicolon at the end of the for.
Cplus_plus keeps reading until it sees a statement (in this case return(index)) and puts that in the for loop.
Example9-11 contains a correctly written version of the program.
Page 150 * Loop until we reach the end of string character */.
When C was still being developed, it soon became apparent that C needed a facility for handling named constants, macros, and include files.
The solution was to create a preprocessor that is run on the programs before they are passed to the C compiler.
The preprocessor is nothing more than a specialized text editor.
Its syntax is completely different from C's and it has no understanding of C constructs.
It is merely a dumb text editor.
The preprocessor was very useful and soon it was merged into the main C compiler.
The Cplus_plus compiler kept this pre-processor.
On some systems, like UNIX, it is still a separate program, automatically executed by the compiler wrapper cc.
Some of the newer compilers, like Turbo-Cplus_plus, have the pre-processor built in.
For example, the following two lines perform similar functions: #define  20.
This takes the drudgery and guesswork out of making changes.
Page 152 All preprocessor commands begin with a hash mark (#) in column 1.
Cplus_plus is free format.
Language elements can be placed anywhere on a line, and the end-of-line is treated just like a space.
The preprocessor is not free format.
It depends on the hash mark (#) being in the column.
As you will see, the preprocessor knows nothing about Cplus_plus and can be (and is) used to edit things other than Cplus_plus programs.
WARNING The preprocessor is not part of the Cplus_plus compiler.
It uses an entirely different syntax and requires an entirely different mind-set to use it well.
Most problems you will see occur when the preprocessor is treated like Cplus_plus.
Preprocessor directives terminate at the end of the line.
In Cplus_plus a semicolon (;) ends a statement.
The preprocessor directives do not end in a semicolon, and putting one in can lead to unexpected results.
A preprocessor directive can be continued by putting a backslash (\) at the end of the line.
The simplest use of the preprocessor is to define a replacement macro.
For example, the command: #define FOO bar occurs.
It is common programming practice to use all uppercase letters for macro names.
This makes it very easy to tell the difference between a variable (all lowercase) and a macro (all uppercase).
The general form of a simple define statement is: #define Name Substitute-Text Name can be any valid Cplus_plus identifier.
Substitute-Text can be anything as long as it fits on a single line.
The Substitute-Text can include spaces, operators, and other characters.
It is possible to use the following definition: and use it like: /* * Clear the array */.
Page 153 programmer wants to know what the loop does, he must search the beginning of the program for the definition of FOR_ALL.
It is even worse to define macros that do large-scale replacement of basic Cplus_plus programming constructs.
For example, you can define the following: #define BEGIN { #define END }.
BEGIN << "Starting\n"; END The problem is that you are no longer programming in Cplus_plus, but in a half-Cplus_plus half-PASCAL mongrel.
The preprocessor can cause unexpected problems because it does not check for correct Cplus_plus syntax.
For example, Example 10-1 generates an error on line 11.
Example 10-1 big/big_0_cc 1 #define BIG_NUMBER 10 ** 10 2 4 { 5.
The definition in line 1 causes the pre-processor to expand line 11 to look like: Because * * is an illegal operator, this generates a syntax error.
Page 154 Question 10-1: The following program generates the answer 47 instead of the expected Example 10-2.
CC -E prog_0_cc sends the output of the preprocessor to the standard output.
In MS-DOS/Windows, the command: cpp prog_0_cpp creates a file called prog  containing the output of the preprocessor.
Running the program For Example 10-1 through thepreprocessor gives you.
Example 10-3 first/first-ed_0_out # 1 "/usr/local/lib/gplus_plus-include/iostream_0_h" 1 3 // About 900 lines of #include stuff omitted.
NOTE The output of the Cplus_plus preprocessor contains a lot of information, most of which can easily be ignored.
In this case, you need to scan the output till you reach the  line.
Examining this line will give you an idea of what caused the error.
Question 10-2: Example 10-4 generates a warning that counter is used before it is set.
This is a surprise because the for loop should set it.
You also get a very strange warning, "null effect, "for line 11.
Question 10-3: Example 10-3 computes the wrong valuefor.
Question 10-4: The following program  supposed to print the message "Fatal Error: Abort" and exit when it receives bad data.
But when it gets good data, it exits.
Example 10-6 dis/die_0_cc 1 2 3 4 5 6 7 8 9 10 11.
However, the use of const preferred over #define for several reasons.
First of all, Cplus_plus checks the syntax of const statements immediately.
The #define directive  not checked until the macro  used.
Also, const uses Cplus_plus syntax, while #define has a syntax all its own.
Finally, const follows normal Cplus_plus scope rules, whereas constants defined by a #define directive continue on forever.
In most cases a const statement  preferred over #define.
Here are two ways of defining the same constant.
Conditional Compilation One problem programmers have  writing code that can work on many different machines.
In theory, Cplus_plus code  portable; in actual practice many machines have little quirks that must be accounted for.
For example, this book covers UNIX, MSDOS, and Windows compilers.
Although they are almost the same, there are some differences, as you will see in Chapter 25, Portability Problems.
The preprocessor allows you great flexibility in changing the way code  generated through the use of conditional compilation.
Suppose you want to put debugging code in the program while you are working on it and then remove the debugging code in the production version.
You could do this by including the code in an #ifdef-#endif section.
If the beginning of the program contains the directive: #define DEBUG /* Turn debugging on */ the   included.
If the program contains the directive: #undef DEBUG /* Turn debugging off */ the   omitted.
Strictly speaking the #undef DEBUG  unnecessary.
If there  no #define DEBUG statement, then DEBUG  undefined.
The #undef DEBUG statement  used to indicate explicitly to anyone reading the code that DEBUG  used for conditional compilation and now turned off.
The directive #ifndef will cause the code to be compiled if the symbol  not defined.
Page 158 #else reverses the sense of the conditional.
For example: #ifdef DEBUG << "Test version.
Debugging  on\n"; #else /* DEBUG */ << "Production version\n"; #endif /* DEBUG */ A programmer may wish to temporarily remove a section of code.
A common method of doing this  to comment out the code by enclosing it in /* */.
This can cause problems, as shown by the following example: /***** Comment out this section section_report(); /* Handle the end-of-section stuff */ dumptable(); **** End of commented out section */ This generates a syntax error for the fifth line.
A better method  to use the #ifdef construct to remove the code.
For example, the command: -DDEBUG -g -o prog prog_0_cc compiles the program prog_0_c and includes all the code in #ifdef DEBUG/#endif /* DEBUG */ pairs even though there  no #define DEBUG in the program.
The Turbo-Cplus_plus equivalent : tcc -DDEBUG -g -N -eprog_0_exe prog_0_c The general form of the option is - or -=.
For example, the following sets  to 10: -=10 -o prog prog_0_c Most Cplus_plus compilers automatically define some system-dependent symbols.
For example, Turbo-Cplus_plus defines the symbol _TURBOC_ and MS-DOS defines_ MSDOS_.
The ANSI standard compiler C defines the symbol _STDC_.
Cplus_plus compilers define the symbol _cplusplus.
Most UNIX compilers define a name for the system (e_0_g_0_, Sun, VAX, celerity, etc_0_); however, they are rarely documented.
The symbol unix is always defined for all UNIX machines Page 159 NOTE Command-line options specify the initial  of a symbol only.
Any #define and #undef directives in the program can change the symbol's.
For example, the directive: #undef DEBUG results in DEBUG being undefined whether or not you use -DDEBUG.
This tells the preprocessor to take the file iostream_0_h and insert it in the current program.
Files that are included in other programs are called headerfiles.
In UNIX, these files are usually located in /usr/.
In MS-DOS/Windows, they are located in the Turbo-Cplus_plus directory (installation dependent).
Standard  files are used for defining data structures and macros used by library routines.
For example,  is a standard class that (as you know by now) prints data on the standard output.
The ostream class definition used by  and its related routines is defined in iostream_0_h.
Sometimes you may want to write your own set of  files.
Local  files are particularly useful for storing constants and data structures when a program spans several files.
They are especially useful for information sharing when a team of programmers is working on Local  files may be specified by using double quotation marks (") around the filename.
The filename ("defs_0_h") can be any valid filename.
This can be a simple file, "defs_0_h"; a relative path, called "_0__0_/_0__0_/data_0_h"; or an absolute path, called Page 160 Include files may be nested.
This can cause problems.
Suppose you define several useful constants in the file const_0_h.
If the files data_0_h and io_0_h both  const_0_h and you put the.
Defining a constant twice is not a fatal error; however, defining a data structure or union twice is an error and must be avoided.
One way around this problem is to have const_0_h check to see whether it has already been included and not define any symbols that have already been defined.
Look at the following code: #ifndef _CONST_H_INCLUDED_ /* Define constants */ #define _CONST_H_INCLUDED_ #endif /* _CONST_H_INCLUDED_ */ When const_0_h is included, it defines the symbol _CONST_H_INCLUDED_.
If that symbol is already defined (because the file was included earlier), the #ifdef conditional hides all the other defines so they don't cause trouble.
NOTE It is possible to put code in a header file.
This is considered poor programming practice.
By convention, code goes in _0_cc files and definitions, declarations, macros, and inline functions go in the _0_h files.
Parameterized Macros So far we have discussed only simple #defines or macros.
Macros can take parameters.
The following macro computes the square of a number:.
It is a good rule always to put parentheses around the parameters of a macro.
Example 10-7 illustrates the problems that can occur if this rule is not followed: Example 10-7.
When used in an expression, they are considered side effects, and this can lead to unexpected results as illustrated in Example 10-8.
Why does this not produce the expected output.
In the program shown in Example 10-8 the SQR() is expanded to (() * ()) in this case.
The result is that  goes up by 2 each time through the loop.
The actual result of this expression is system dependent.
Question 10-6: The following program tells us we have an undefined variable, but our only variable name is.
Example 10-9 rec/rec_0_cc # <iostream_0_h>.
For a more extensive example of how to use this operator see Chapter 26, Putting It All Together.
Parameterized Macros Versus Inline Functions In most cases it is better to use an inline function instead of a parameterized macro, to avoid most of the traps caused by parameterized macros.
But there are cases where a parameterized macro may be better than an inline function.
For example, the SQR macro works for both float and int data types.
We'd have to write two inline functions to perform the same functions.
Advanced Features This book does not cover the complete list of Cplus_plus preprocessor directives.
Among the more advanced features are an advanced form of the #if directive for Page 163 conditional compilations and the #pragma directive for inserting compiler-dependent commands into a file.
See your Cplus_plus reference manual for more information on these features.
Summary The Cplus_plus preprocessor is a very useful part of the Cplus_plus language.
It has a completely different look and feel from Cplus_plus.
However, it must be treated apart from the main Cplus_plus compiler.
Problems in macro definitions often do not show up where the macro is defined, but result in errors much further down in the program.
By following a few simple rules, you can decrease the chances of having problems.
Put parentheses around everything.
In particular they should enclose #define constants and macro parameters.
When defining a macro with more than one statement, enclose the code in {}.
Programming Exercises Exercise 10-1: The Cplus_plus standard contains a boolean type (bool) that defines the values true and false.
The problem is most compilers haven't implemented this type yet.
Create a boolean type by using #define to define values for BOOLEAN, TRUE, and FALSE.
Exercise 10-2: Write a macro that returns true if its parameter is divisible by 10 and false otherwise.
Exercise 10-3: Write a macro is_digit that returns true if its argument is a decimal digit.
Write a second macro is_hex that returns true if its argument is a hex digit (0-9 A-F a-f).
The second macro should reference the first.
Exercise 10-4: Write a preprocessor macro that swaps two integers.
If you change  definition of ALL_PARTS to: program executes correctly.
Answer 10-2: The preprocessor is a very simple-minded program.
When it defines a macro, everything past  identifier is part of  macro.
In this case,  definition of MAX is literally "=10".
When  for statement is expanded,  result is: Cplus_plus allows you to compute a result and throw it away.
For this statement,  program checks to see whether  is 10 and discards  answer.
Answer 10-3: As with  previous problem,  preprocessor does not respect Cplus_plus syntax conventions.
In this case  programmer used a semicolon to end  statement, but preprocessor included it as part of  definition for.
The assignment statement for , expanded, is: = 10; -2;; The two semicolons at  end do not hurt anything, but  one in  middle is a killer.
This line tells Cplus_plus to do two things: 1) assign 10 to  and 2) compute   -2 and throw it away (this results in  null effect warning).
Answer 10-4: The output of  preprocessor looks like:.
The problem is that two statements follow  if line.
Normally they would be put on two lines.
If we properly indent this program we get:.
From this it is obvious why we always exit.
The fact that there were two statements after if was hidden by using a single preprocessor macro.
The cure for this problem is to put curly braces around all multistatement macros.
To avoid this problem,  inline functions instead of parameterized macros.
Answer 10-6: The only difference between a parameterized macro and one without parameters is  parentheses immediately following  macro name.
In this case, a space follows definition of RECIPROCAL, so it is not a parameterized macro.
Instead it is a simple text replacement macro that replaces RECIPROCAL with: space between RECIPROCAL and (number) corrects  problem.
Page 167 11 Bit Operations In This Chapter:.
Bit Operators The AND Operator Bitwise OR The Bitwise Exclusive OR The Ones Complement Operator The Left and Right Shift Operators Setting, Clearing, and Testing Bits Bitmapped Graphics Exercises Answers to Questions To be or not to be, that is  question.
A bit is  smallest unit of information.
Normally it is represented by  values 1 and 0.
They allow  programmer to get "under  hood" of  machine.
Many higher-level programs will never need bit operations.
Lowlevel coding such as writing device drivers or pixel-level graphic programming requires bit operations.
If you plan to program only at a higher level, this chapter may be safely skipped.
Eight bits together form a byte, represented by  Cplus_plus data type char.
A byte might contain following bits: 01100100.
This can also be written as  hexadecimal number 0x64.
Table 11-1 gives hexadecimal (hex) to binary conversion: Table 11-1.
Hex and Binary Hex Binary.
So the hexadecimal number 0xAF represents the binary number 10101111.
Bit Operators Bit, or bitwise, operators allow the programmer to work on individual bits.
For example, a short integer holds 16 bits (on most machines).
The bit operators treat each of these as an independent bit.
By contrast, an add operator treats the 16 bits as a single 16-bit number.
Bit operators allow you to set, clear, test, and perform other operations on bits.
The bit operators are listed in Table 11-2.
Table 11-2 Bit Operators Operator Meaning.
These operators work on any integer or character-data type.
The AND operator compares two bits.
The results of the AND operator are defined in Table 11-3.
Table 11-3 AND Operator Bit1 Bit2.
Page 169 When two eight-bit variables (char variables) are "ANDed" together, the AND operator works on each bit independently.
The following program segment illustrates this operation:.
The output  this program is: 45 & 71 = 41 This is because: = 0x45 & 2= 0x71.
In the logical AND if both operands are true (nonzero), the result is true (1).
In bitwise AND (&), if the corresponding bits  both operands are true (1s), then the corresponding bits  the results are true (1s).
So the bitwise (&) works on each bit independently while the logical AND (&&) works on the operands as a whole.
AND However, & and && are different operators, as Example 11-1 illustrates:.
Answer: The operator & is a bitwise AND.
The result  the bitwise AND is zero.
If the programmer had used the first form: and made the mistake  using & instead  &&: the program would still have executed correctly.
NOTE Soon after discovering the bug illustrated by this program I told my office mate, "I now understand the difference between AND and AND AND), and he understood me.
How we understand language has always fascinated me, and the fact that I could utter such a sentence and have someone understand it without trouble amazed me.
You can use the bitwise AND operator to test whether a number is even or odd.
In base 2, the last digit  all even numbers is zero and the last digit  all odd numbers is one.
The following function uses the bitwise AND to pick off this last digit.
If it is zero (an even number), the the function is true.
The inclusive OR operator (also known as just the OR operator) compares its two operands.
Table 11-4 lists the truth table for the OR operator.
The truth table for the exclusive OR operator is listed in Table 11-5.
Table 11-5 Exclusive OR Bit1 Bit2.
Table 11-6 NOT Operator Bit ~Bit.
Page 172 On a byte this is: = ~= 0x45 0xBA 01000101 10111010 The left shift operator moves the data left a specified number of bits.
Any bits that are shifted out the left side disappear.
New bits coming in from the right are zeros.
The right shift does the same thing in the other direction.
For example: << 1 >> 2 =0xlC =0x38 =0x07 00011100 00111000 00000 11 Shifting left by one (x << 1) is the same as multiplying by 2 (x * 2).
Shifting left by two (x << 2) is the same as multiplying by 4 (x * 4, or x * 22).
You can see a pattern forming here.
Shifting left by n places is the same as multiplying by 2n.
Why shift instead of multiply.
Shifting is faster than multiplication, so.
The compiler is smart enough to perform the speedup automatically.
This means that putting in a shift gains you nothing at the expense of clarity.
The left shift operator multiplies; the right shift divides.
Again, this clever trick should not be used in modern code.
Right Shift Details Right shifts are particularly tricky.
When a variable is shifted to the right, Cplus_plus needs to fill the space on the left side with something.
For signed variables, Cplus_plus Page 173 uses the value of the sign bit.
For unsigned variables, Cplus_plus uses zero.
Table 11-7 illustrates some typical right shifts.
Table 11-7 Right Shift Examples Signed Character Signed Character Unsigned Character Expression.
Each of these can be treated as a separate flag.
Bit operations can be used to pack eight single-bit values in a single byte.
For example, suppose you are writing a low-level communications program.
You are going to store the characters in an 8K buffer for later use.
With each character you will also store a set of status flags.
The flags are listed in Table 11-8.
Table 11-8 Communications Status Values Name Description.
Power was lost on the communication device You could store each flag in its own character variable.
That would mean that for each character buffered, you would need five bytes of status storage.
For a large buffer, that adds up.
By instead assigning each status flag its own bit within an eight-bit status character, you cut storage requirements down to 1/5 of the original need.
You can assign the flags the bit numbers listed in Table 11-9.
Bit Assignments Bit Name.
Page 174 Table 11-9 Bit Assignments Bit Name.
CHANNEL_DOWN Bits are numbered 76543210 by convention.
The constants for each bit are defined in Table 11-10.
Table 11-10 Bit Values Bit Binary Value.
Table 11-11 shows how you can use the left shift operator (<<) to define bits.
The Left Shift Operator and Bit Definition Cplus_plus Representation Base 2 Equivalent.
Bit 2 Page 175 Cplus_plus Representation Base 2 Equivalent.
Bit 7 Although it is hard to tell what bit is represented by 0x10, it's easy to tell what bit is meant by 1 << 4.
The flags can be defined as: // True if any error is set const int  = (1 << 0); // A framing error occurred for this character const int  = (1 << 1); // Character had the wrong parity const int  = (1 << 2); // The carrier signal went down const int  = (1 << 3); // Power was lost on the communication device const int  = (1 << 4); Now that you have defined the bits, you can manipulate them.
To set a bit, use the | operator.
Suppose you want to clear the bit.
In binary this bit is 00000100.
You want to create a mask that has all bits set except for the bit you want to clear (11111011).
The mask is then ANDed with the number to clear the bit.
More and more computers now have graphics.
For the PC, there are graphics devices like EGA and VGA cards.
For UNIX, there is the X windowing system.
In bitmapped graphics, each pixel on the screen is represented by a single bit in memory.
For example, Figure 11-1 shows a 14-by-14 bitmap as it appears on the screen and enlarged so you can see the bits.
Suppose we have a small graphic device—a 16-by-16 pixel monochrome display.
We want to set the bit at 4, 7.
The bitmap for this device is shown as an array of bits in Figure 11-2.
There is no data type for an array of bits in Cplus_plus.
The closest we can come is an array of bytes.
Our 16-by-16 array of bits now becomes a 2-by-16 array of bytes, as shown in Figure 11-3.
To set the pixel at bit number 4,7 we need to set the fourth bit of byte 0,7.
To set this bit we would use the statement: [0] [7] |= (0x80 >> (4) ); Page 177.
Figure 11-3 Array of bytes The constant 080 is the leftmost bit.
We can generalize this process to produce a macro that turns on the bit (pixel) located at (, y).
We need to compute two values: the coordinate of the byte and the number of the bit within the byte.
Our bit address is (, y).
Bytes are groups of eight bits, so that means that our byte address is (/8, ).
The bit within the byte is not so simple.
We want to generate a mask consisting of the single bit we want to set.
For the leftmost bit this should be 1000 00002, or 080.
The next bit is 0100 00002, or (080 >> 1), and occurs when (%8) == 1.
So to generate our bit mask we use the expression (080 >> (%8)).
Now that we have the byte location and the bit mask, all we have to do is set the bit.
The following function sets a given bit in a bitmapped graphics array named graphics.
Example 11-2 draws a diagonal line across the graphics array and then prints the array on the terminal.
The constant /8 is used since we have  bits across, which translates to /8 bytes.
The main for loop: set_bit(, ); draws a diagonal line across the graphics array.
Since we do not have a bitmapped graphics device we will simulate it with the subroutine print_graphics.
There are eight bits in each byte handled by the loop:.
This loop causes the variable  to start with  7 (the leftmost ).
For each iteration of the loop, the  is moved to the right one  by  = ( >> 1).
When we run out of bits, the loop exits.
The loop counter cycles through.
Finally, at the heart of the loops is the code: Binary Hex.
Programming Exercises Exercise 11-1: Write a set of inline functions, clear_bit and test_bit, to go with the set_bit operation defined in Example 11-2.
Write a main program to test these functions.
Exercise 11-2: Write a program to draw a 10-by-10 bitmapped square.
Page 182 Exercise 11-3: Change Example 11-1 so it draws a white line across a black background.
Exercise 11-4: Write a program that counts the number of bits set in an integer.
For example, the number 5 (decimal), which  0000000000000101 (binary), has two bits set.
Exercise 11-5: Write a program that takes a 32- integer (long int) and splits it into eight Exercise 11-6: Write a program that will take all the bits in a number and shift them to the left end.
For example, 01010110 (binary) would become 11110000 (binary).
Answers to Chapter Questions Answer 11-1: DIRECT_CONNECT  defined to be  number 8 by the  (1 << 8); however, the eight bits in a character variable are numbered 76543210.
A solution to this problem  to make flags a short integer with 16 bits.
Answer 11-2: The problem  that   a character (8 bits).
The value 080 represented in 8 bits  1000 00002.
The first , the sign ,  set.
When a right shift  done on this variable, the sign   used for fill, so 1000 00002 >> 1  1100 00002.
The variable  works even though it  signed because it  16 bits long.
Notice that the  we've got set  nowhere near the sign.
The solution to the problem  to declare  as an unsigned variable.
Page 183 III Advanced Types and Classes Page 185 12 Advanced Types In This Chapter:.
Structures Unions typedef enum Type Bit Fields or Packed Structures Arrays of Structures Programming Exercises Total grandeur of a total edifice.
Chosen by an inquisitor ofstructures —Wallace Stevens Cplus_plus provides a rich set of data.
Through the use of structures, unions, enum, and class , the programmer can extend the language with new.
Structures Suppose you are writing an inventory program for a warehouse.
The warehouse  filled with bins each containing a bunch of parts.
All the parts in a bin are identical, so you don't have to worry about mixed bins or partials.
For each bin you need to know:.
The name of the part it holds (character string 30 long).
The price (integer cents).
In previous chapters you have used arrays for storing a group of similar  , but in this example you have a mixed bag: two integers and a string.
Instead of an array, you will use a new  type called a structure.
In an array, all the elements are of the same type and are numbered.
In a structure, each element, or field,  named and has its own  type.
Page 186 The general form of a structure definition :.
Name of the part How many are in the bin Where we put the print cables This definition actually tells Cplus_plus two things.
The first  what a struct bin looks like.
This statement defines a new  type that can be used in declaring other variables.
This statement also declares the variable printer_cable_box.
Since the structure of a bin has been defined, you can use it to declare additional variables: struct bin terminal_cable_box; // Place to put terminal cables The structure-name part of the definition may be omitted.
Name of the part How many are in the bin Where we put the print cables The variable printer_cable_box  still to be defined, but no  type  created.
The type for this variable  an anonymous structure.
The variable-name part also may be omitted.
This would define a structure type but no variables.
In an extreme case, both the variable-name and the structure-name parts may be omitted.
This creates a section of correct but totally useless code.
Once the structure type has been defined you can use it to define variables: struct bin printer_cable_box; // Define the box holding printer cables Cplus_plus allows the struct to be omitted, so you can use the following declaration: bin printer_cable_box; // Define the box holding printer cables Page 187 You have defined the variable printer_cable_box containing three named fields: name, quantity, and.
To access them you use the syntax: variable.
Structures may be initialized at declaration time by putting the list of elements in curly braces ({ }).
Unions A structure is used to define a  type with several fields.
Each field takes up a separate.
The fields i_value and f_value share the same space.
You might think of a structure as a large box divided up into several different compartments, each with its own name.
A union is a box, not divided at all, with several different labels placed on the single compartment inside.
In a structure, the fields do not interact.
Changing one field does not change any others.
In a union, all fields occupy the same space, so only one may be active at a time.
In other words, if you put something in i_value, assigning something to f_value wipes out the old value of i_value.
Page 189 The following shows how a union may be used: /* * Define a variable to hold an integer or */.
Suppose you want to store the information about a shape.
The shape can be any standard shape such as a circle, rectangle, or triangle.
The information needed to draw a circle is different from the  needed to draw a rectangle, so you need to define different structures for each shape:.
The first field is a code that tells you what type of shape you have.
The second is a union that holds the shape information:.
Graphically you can represent shape as a large box.
Inside the box is the single integer kind and our union shape_union.
The union is a box with three labels on it.
The question is which one is the "real" label.
You can't tell from looking at the union, but that's why you defined  It tells us which label to read.
The layout of the shape structure is illustrated by Figure 12-2.
Figure 12-2 "shape" layout.
This provides a way for you to extend Cplus_plus's basic types.
The general form of the typedef statement is: typedef -declaration The -declaration is the same as a variable declaration except a  name is used instead of a variable name.
For example: typedef int width; // Define a  that is the width of an object defines a new , width, that is the same as an integer.
These values are referenced by name (tag).
The compiler assigns each tag an integer value internally, such as the days of the week.
You could use the directive const to create values for the days of the week (day_of_the_week) as follows: typedef int day_of_the_week; const const const const const const const int int int int int int int // Define the  for days of the week.
As with structures, the enum-name or the variable-name may be omitted.
The tags may be any valid Cplus_plus identifier; however, tags are usually all uppercase.
An additional advantage of using an enum  is that Cplus_plus will restrict the values that can be used to the ones listed in the enum declaration.
The following will result in a compiler error: = 5; // 5 is not a day_of_the_week One disadvantage of using enum is that enum variables cannot be used to index an array.
This accomplished through the cast or typecast operation.
The expression int() tells Cplus_plus, "I know   not an integer, but treat it like one_0_" To fix the above problem, use the statement: << "Today  " << [int()] << '\n'; Page 193 Casts are also useful in expressions to make sure the variables have the correct.
In general, you can change the  of almost any expression with the expression: This  particularly useful when working with integers and floating point numbers.
Cplus_plus also supports the older C-style casting.
The syntax for C-style casting : () value For example: (float) // Turn "" into a floating point number C-style casts are frowned upon because they can easily be ambiguous.
For example, in the expression: (float)3 + 5 does the (float) apply to 3 or 3 + 5.
To make this expression clearer you need to add parentheses: ((float)3) + 5 As you can see, this form  more complex than Cplus_plus casts.
Simpler  better, so use Cplus_plus casting.
Packed structures allow you to declare structures in a way that takes up a minimum of storage.
For example, the following structure takes up 6 bytes (on a 16-bit machine):.
Unpacked structure However, the fields list and seen can have only two values, 0 and 1, so only 1 bit needed to represent them.
You never plan on having more than 16383 items (0x3fff or 14 bits).
You can redefine this structure using bit fields, so, it takes only 2 bytes, by following each field with a colon and the number of bits to be used for that field.
Packed structure Packed structures should be used with care.
The machine code to extract data from bit fields relatively large and slow.
Unless storage  a problem, packed structures should not be used.
In Chapter 11, Bit Operations, you needed to store character data and five status flags for 8,000 characters.
In this case, using a different byte for each flag would eat up a lot of storage (five bytes for each incoming character).
You used Page 195 bitwise operations to pack the five flags into a single byte.
Alternatively, a packed structure.
Character from device True if any error  set A framing error occurred Character had the wrong parity The carrier signal went down Power was  on the channel Using packed structures for flags  clearer and less error-prone than using bitwise operators.
However, bitwise operators allow additional flexibility.
You should use the one that clearest and easiest for you to use.
Arrays of Structures Structures and arrays can be combined.
Suppose you want to record the time a runner.
Each element consists of a single time structure.
You can use this as follows: /* * Runner just past the timing point */.
Suppose you want to write a program to handle a mailing list.
Mailing labels are 5 lines high and 60 characters wide.
You need a structure to store names and addresses.
The mailing list will be sorted by name for most printouts, and sorted in zip-code order for actual mailings.
The mailing list structure looks like:.
Exercise 12-2: Design a structure to store time and date.
Write a function to find the difference between two times in minutes.
Exercise 12-3: Design an airline reservation data structure that contains the following data: Flight number Departure time Arrival time Write a program that lists all the planes that leave from two airports specified by the user.
Page 197 13 Simple Classes In This Chapter:.
Stacks Improved Stack Using a Class Introduction to Constructors and Destructors Automatically Generated Member Functions Shortcuts Style Programming Exercises She thinks that even up in heaven Her class lies late and snores —Cyril Connolly So far you've used simple variables and structures to hold data and functions to process the data.
Cplus_plus classes allow you to combine data and the functions that use it.
In this chapter you'll see how a class can improve your code by implementing a simple stack two ways: first, using a structure and functions, and then using a class.
Stacks A stack is an algorithm for storing data.
Data can be put in the stack using a push operation.
The pop operation removes the data.
Data is stored in last-in-first-out (LIFO) order.
You can think of a stack as a stack of papers.
When you perform a push operation, you put a new  on top of the stack.
You can push as many times as you want.
Each time the new data goes on top of the stack.
You get data out of a stack using the pop operation, which takes the top off the stack and gives it to the caller.
Suppose you start with an empty stack and put three elements on it, 4, 5, and 8, using three push operations.
The first pop would return the top element: 8.
The elements 4 and 5 remain in the stack.
Popping again will give us 5.
You then Page 198 push another value, 9, on the stack.
Popping twice will give us the numbers 9 and 4, in that order.
This is illustrated by Table 13-1.
Stack Operation Operation Stack After Operation.
This structure will need a place to put the data (called data) and a count of the number of items currently pushed on the stack (called count):.
Note: This version of the program does not check for stack overflow or other error conditions.
Later, in Chapter 14, More on Classes, you'll see how you can use this simple stack to make a safer, more complex one.
Popping simply removes the top item and decreases the number of items in the stack.
Notice that you don't need to zero the data field in the stack, since the elements of data are overwritten by the push operation.
You are now finished.
To actually use the stack you declare it with a struct statement.
Next you must make sure that you initialize it, and then you can push and pop to your heart's content (or at least within the limits of the stack).
Example 13-1 contains a complete implementation of the structure version of the stack and a short test routine.
Improved Stack The structure version of the  works but has a few drawbacks.
The first is that the data and the functions are defined separately, forcing you to pass a struct  variable into each procedure.
There is also the problem of data protection.
The fields data and  are accessible to anyone.
The design states that only the  functions should have access to these fields, but there is nothing to prevent rogue code from modifying them.
A Cplus_plus struct is a mixed collection of data.
The Cplus_plus class not only holds data like a structure, but also adds a set of functions for manipulating the data and access protection.
Turning the struct  into a class you get: class  { private:.
This declares two fields:  and data.
In a class these items are not called fields; they are called member variables.
The keyword private indicates the access privileges associated with these two member variables.
There are three levels of access privileges: public, private, and protected.
Class , both data and functions, marked private cannot be used outside the class.
They can be accessed only by functions within the class.
The opposite of private is public, which indicates  that anyone can access.
Finally, protected is similar to private except that it allows access by derived You've finished defining the data for this class.
Now you need to define the functions that manipulate the data.
This section starts with the keyword public.
This tells Cplus_plus that you want all these member functions to be available to the outside.
In this case, you just define the function prototypes.
The code for the function will be defined later.
Next comes the body of the init function.
Since this function belongs to the  class, you prefix the name of the procedure with ::.
This procedure zeroes the 's.
In the structure version of the stack_ init function you must pass the  in as a parameter.
Since this function is part of the  class, that's unnecessary.
This also means that you can access the member variables directly.
Using a Class Using a class is much like using a structure.
Declaring a class variable is the same, except you use the word class instead of struct.
To call the init member function of the  class all you need to do is: _0_init();.
Example 13-2 contains a class version of the.
Introduction to Constructors and Destructors This stack class has one minor inconvenience.
The programmer must call the init member function before using the stack.
However, programmers are terribly forgetful and sooner or later someone is going to forget to initialize the stack.
Wouldn't it be nice if Cplus_plus had an automatic way of initializing the stack.
Actually Cplus_plus will automatically call a number of member functions.
The first you are concerned about is called when the class is created.
This is called the constructor function and has the same name as the class.
For example, the constructor for the stack class is named stack (also known as stack: :stack outside the class body).
A variable is created when it is declared.
Constructors can never return a value so the void is not needed.
In fact the compiler will complain if it's present.
Destructors The constructor is automatically called when the variable is created.
The destructor is automatically called when the variable is destroyed.
This occurs when the variable goes out of scope or when a pointer variable is deleted.
So, for the stack class the destructor would be named ~stack.
Page 207 Suppose you make the rule that the stack should be empty when the programmer is finished with it.
In other words, for every push you do, a  must be done.
If this doesn't happen, it's an error and you should warn the user.
All you have to do is create a destructor for the stack that checks for an empty stack and issues a warning if the stack is not empty.
The destructor looks like:.
The constructor for a class can take parameters.
Suppose you want to define a class that holds a person's name and phone number.
The data members for this class would look like: class person {.
Parameterized Destructors There is no such thing as a parameterized destructor.
Destructors take no parameters and supply no return value.
All they do is destroy the variable.
Copy Constructor The copy constructor is a special constructor that is used to make an exact copy of a class.
This function is expected to turn the current class into an exact copy of the parameter.
On the face of it, the copy constructor doesn't seem that important.
But if you remember, back in Chapter 9, Variable Scope and Functions, you discussed the various ways Cplus_plus can pass parameters to a function.
One of these was call by value.
That's where a copy of the parameter is made and passed to the function.
When a  or any other class is passed as a call-by-value parameter, a copy is made of that class using the copy constructor.
In the following code, we've added some commentary to show you the functions that Cplus_plus will automatically call behind your back.
As you can see, Cplus_plus does a lot of work behind the scenes.
It starts when a_stack is declared.
Cplus_plus calls the default constructor to create a_stack.
The variable a_stack is used, and then passed to the function use_stack.
Since a_stack is passed by value, a copy must be made of the  using the copy constructor local_stack_0_(a_stack).
The function then adds a few items to local_stack.
Note: This is a copy of a_stack, so anything you do to local_stack does not affect a_stack.
At the Page 210 end of the function local_stack contains four items, 1, 2, 9, 10, and a_stack contains two items, 1, 2.
Finally after the function call, you print out the top element of a_stack, which is "2".
Automatically Generated Member Functions Every class has a constructor and a destructor.
If the programmer does not write these member functions, Cplus_plus will automatically generate them.
Also, there are several member functions such as the copy constructor that can be called automatically.
Automatically Generated and Used Functions Default constructor.
Automatically generated if no other constructors are defined.
The generated code fills the data members of the class with random values.
Automatically called when a variable of this class is declared with no parameters, such as: class_type var; Copy constructor.
Automatically generated unless the programmer explicitly defines a copy constructor.
The function Cplus_plus generates copies all the data members from the old class to the new.
Automatically called when passing a call-by-value parameter to a function.
This member function may also be called when creating a duplicate of a variable:.
Automatically generated unless the programmer defines.
Page 211 Automatically called when a variable is destroyed.
This occurs when a variable goes out of scope.
The function Cplus_plus generates copies all the data members from the old class to the new.
So far you have used only function prototypes in the classes you've created.
It is possible to define the body of the function inside the class itself.
Thus: class  { public:.
Page 212 Style Programming style for classes looks pretty much like the style for structures and functions.
Every member variable should be followed by a comment explaining it and every member function should be commented like a function.
However, you comment the prototypes for member functions differently from normal function prototypes.
For normal functions you put a full function comment block in front for the prototype.
If you did this for the member functions of a class, the comments would obscure the structure of the class.
This is  of the few cases when too many comments can cause trouble.
So you put a -line comment in front of each member function prototype and full comments in front of the function itself.
But what about inline-member functions, where the entire body of the function is declared inside the class.
If you put in full comments, you obscure the structure of the class.
If you put in -liners, you omit a lot of useful information.
Proper commenting is a balancing act.
You need to put in what's useful and leave out what's not.
The solution is to keep the size of the inline-member function small.
There are two reasons for this, first all inline functions should be small and, secondly, large functions declared inside a class make the class excessively complex.
A good rule of thumb is that if the function requires more than about five lines of code, put a prototype in the class and put the body of the function elsewhere.
The structure of very small member functions should be obvious and thus not require a full-blown comment block.
If the function is not obvious and requires extensive comments, you can always put in a prototype and comment the body of the function later in the program.
Cplus_plus does not require an access protection declaration (public, private, or protected) before the first member variable.
The following is perfectly legal:.
If you put in an explicit declaration, then you don't have to worry about questions like this.
Suppose you have a class that does not specify a copy constructor, such as: Page 213 // Comments describing the class // Note: The style of this class leaves something to be desired class queue {.
Will the copy constructor automatically generated by Cplus_plus work, or did the programmer design this class knowing that the copy constructor would never be called.
These important questions are not answered by the class as written.
All classes have a default constructor, copy constructor, assignment , and destructor.
If you want to use the  Cplus_plus generates automatically, put a comment in the class indicating that the default is being used.
Use automatically generated destructor.
Now it is obvious what member functions the programmer wanted to let Cplus_plus generate automatically, and being obvious is very important in any programming project.
The copy constructor automatically generated by Cplus_plus is rather simple and limited.
It doesn't work in all cases, as you'll see later when you start to construct more complex classes.
But what happens when the automatic copy constructor won't work as you desire and you don't want to go to the trouble to create your own.
Page 214 After all, you may decide that a class will never be copied (or that if it is, it's an error).
One solution is to create a dummy copy constructor that prints an error message and aborts the program: class no_copy {.
This works, sort of.
The problem is that errors are detected at runtime instead of compile time.
You want to catch errors as soon as possible, so this solution is at best a hack.
However, you can prevent the compiler from automatically calling the copy constructor.
The trick is to declare it private.
That's your way of saying to the world, "Yes, there is a copy.
Now when the compiler attempts to use the copy constructor you will get an error message like Programming Exercises Exercise 13-1: Write a parity class.
This class allows the program to put any number of items into it and returns TRUE if an even number of items is put in and FALSE if an odd number is used.
Page 215 Exercise 13-2: Write a "checkbook" class.
You put a list of numbers into this class and get a total out.
A queue is very similar to a stack except the data is removed in first-in-first-out (FIFO) order.
Exercise 13-4: Define a class that will hold the set of integers from 0 to 31.
An element can be set with the set member function and cleared with the clear member function.
It is not an error to set an element that's already set or clear an element that's already clear.
The function test is used to tell whether an element is set.
I then go through the stack of flash Page 216 cards one at a time.
If I  a word right, that card is discarded.
If I  it wrong, the card goes to the back of the stack.
Write a class to implement this system.
Friends Constant Functions Constant Members Static Member Variables Static Member Functions The Meaning of static Programming Exercises This method is, to define as the number of a class the class of all classes similar to the given class.
Suppose you want to write a function to see whether two stacks are equal.
At first glance this is simple.
The function looks like Example 14-1.
Example 14-1 stack_c/s_equal_0_cc /******************************************************** * stack_equal minus_minus Test to see whether two stacks are * * equal * * * * s1, s2 minus_minus the two stacks * * * * Returns * * 0 minus_minus stacks are not equal * * 1 minus_minus stacks are equal * ********************************************************/ { int ; // Index into the items in the array.
Like many programs, this solution is simple, clear, and wrong.
The problem is that the member variables  and data are private.
That means you can't access them.
One solution is to make these variables public.
That gives the function stack_equal access to  and data.
The problem is that it also gives everyone else access, and you don't want that.
Fortunately Cplus_plus gives you a way to say, "Let stack_equal and only stack equal have access to the private data of the class stack_0_" This is accomplished through the friend directive.
Classes must declare their friends.
No function from the outside may access the private data from the class, unless the class allows it.
NOTE stack_equal is not a member function of the class stack.
It is a normal, simple function.
The only difference is that because the function is a friend it has access to private data for any class that calls it friend.
Page 219 Friend Classes Friends are not restricted to just functions.
One class can be a friend of another.
For example: int ; // Current  into the data array const int DATA_MAX(100); // Maximum number of items in the array These two items are treated differently.
For example, you can change the value of  but you can't change DATA_MAX.
Now let's consider a class to implement a set of numbers from 0 to 31.
The definition of this class is: // Warning: The member functions in this class are incomplete // See below for a better definition of this class class int_set {.
There is also a function test that changes nothing.
Obviously you don't want to allow set and clear to be used on a constant.
However, it is okay to use the test member function.
But how does Cplus_plus know what can be used on a constant and what can't.
The trick is to put the keyword const at the end of the function header.
This tells Cplus_plus that this member function can be used for a constant variable.
So if you put const after the member function test, Cplus_plus will allow it to be used in a constant.
The member functions set and clear do not have this keyword, so they can't be used in a constant.
Constant Members Classes may contain constant members.
The problem is that constants behave a little differently inside classes than outside.
Outside, a constant variable declaration must be initialized.
For example: const int  = 1024; // Number of data items in the input stream Page 221.
Use a syntax trick to fool Cplus_plus into defining a constant: class foo { public: enum { = 100}; // Number of data items in the list This defines  as a constant whose value is 100.
It does this by actually declaring as a element of an enum type and giving it the explicit value 100.
Because Cplus_plus treats enums as integers, this works for defining integer constants.
Page 222 The drawbacks to the method are that it's tricky, it only works for integers, and it exploits some holes in the Cplus_plus syntax that may go away as the language is better defined.
Such code can easily cause difficulties for other programmers trying to maintain your code who aren't familiar with the trick.
Static Member Variables Suppose you want to keep a running count of the number of stacks in use at any given time.
One way to do this is to create a global variable  that is incremented in the stack constructor and decremented in the destructor.
Note that  is a single global variable.
No matter how many different stacks you create, there is one and only one.
Although this system works, it has some drawbacks.
The definition of the class stack contains everything about the stack, except the variable.
It would be nice to put  in the class, but if you define it as a member variable, you'll get a new copy of  each time you declare a stack class variable.
Cplus_plus has a special modifier for member variables: static.
This tells Cplus_plus that one and only one variable is to be defined for the class.
This is done with the statement: int stack:: = 0; // No stacks have been defined The difference between static and non-static member variables is that if you define three stacks, you create three different data_count member variables, but there is one and only one.
Member variables belong to the individual stack.
Static variables belong to the class.
So if you have: stack a_stack; stack b_stack;.
Cplus_plus allows you to access this using the syntax: <class>::<variable> Thus you can get to  with the statement: << "The number of active stacks is " << stack:: <<.
Static Member Functions The member variable  is defined as private.
This means that nothing outside the class can access it.
You want to know how many stacks are defined, so you need a function to get the value of.
A first cut might be: class stack {.
They can't access nonstatic member variables or functions in the class.
They can access static member data, static member functions, and functions and data outside the class.
The Meaning of static The keyword static has many different meanings in Cplus_plus.
Table 14-1 is a complete list of the various ways static can be used.
Table 14-1 The Meanings of static Usage Meaning Variable outside the body of any function The scope of the variable is limited to the file in which it is declared.
Variable declaration inside a function The variable is permanent.
It is initialized once and only one copy is created even if the function is called recursively.
Function declaration The scope of the function is limited to the file in which it is declared.
Page 225 Usage Meaning Member variable One copy of the variable is created per class (not one per variable).
Member function Function can only access static members of the class.
Programming Exercises Exercise 14-1: Two classes share a file.
Other areas of the program need to know when this file is busy.
Create a function that returns 1 when the file is being used by either of these two classes.
Exercise 14-2: You are asked to write a booking program for the veterinarian: Dr.
Able Smith, PHD (Pigs, Horses, Dogs).
Define a class type for each animal.
Each class should keep track of the number of animals that have been defined using that class in a private static variable.
Define a function that returns the total number of animals (all three types combined).
Exercise 14-3: Write a class where each instance of the class can access a stack-not one stack per instance, but one stack period.
Any instance of the class can lock the stack for its own exclusive use and unlock it later.
Define member functions to perform the lock and unlock functions.
As an added attraction, make the unlock function check to see that the current instance of the class was the same instance that locked the stack in the first place.
Exercise 14-4: You need to supply some I/O routines for handling lines in a file.
The basic definition of the line-number class is: class line_number {.
Page 226 Several line_number classes may be in use at any time.
The class maintains its own internal list so that it knows which line_number classes are in use.
When goto_line is called, the function will scan the list of line_number classes to find the one nearest the given line number and use it to start scanning for the given line number.
For example, suppose there are four active line_number variables: Variable Position.
Line 52 You wish to move current_location to line 90.
The goto_line function would search the list for the line nearest the new  (in this case chapter_start) and use it to jump to line 87.
It then would read the file character by character until it saw three end-of-line characters to position itself at line 90.
Page 227 15 Simple Pointers In This Chapter:.
Constant Pointers Pointers and Printing Pointers and Arrays Splitting Strings Pointers and Structures Command-Line Arguments Programming Exercises Answers to Chapter Questions The choice of a point of view is the initial act of culture —Ortega y Gasset There are things and there are pointers to things (Figure 15-1).
A thing and a pointer to a thing Things can come in any size; some may be big, some may be small.
Pointers come in only one size (relatively small)_0_* Throughout this book you use a box to represent a thing.
The box may be large or small, but things are always a box.
Pointers are represented by arrows.
Most novice programmers get pointers and their contents confused.
To limit this problem, all pointer variables in this book end with the extension _ptr.
You probably want to follow this convention in your own programs.
Although not as common as it should be, this notation is extremely useful.
Because of the strange architecture of the 8086, Turbo-Cplus_plus is forced to use both near pointers (16 bits) and far pointers (32 bits) See the Turbo- Cplus_plus manual for details Page 228 Figure 15-1 shows one thing: a variable named thing.
The name of the variable is written on the box that represents it.
This variable contains the value 6.
The actual address of this variable is 0x1000.
Cplus_plus automatically assigns an address to each variable at compile time.
The actual addresses differ from machine to machine.
Most of the time you don't have to worry about variable addresses, as the compiler takes care of that detail.
Pointers are also called address variables since they contain the addresses of other variables.
In this case, the pointer contains the address 0x1000.
Since this is the address of thing, you say that thing_ptr points to thing.
For example, you might live in a house (a thing).
The street address might be "123 W.
Main Street_0_" An address is a small thing that can be written down on a piece of paper.
Putting a house on a piece of paper is something else requiring a lot of work and a very large crane.
Street addresses are approximately the same size: one line.
Houses come in various sizes.
Pennsylvania Ave_0_" might refer to a big house and "8347 Skid Row" might refer to a one-room shack, both addresses are the same size.
Many different address variables can point to the same thing.
This is true for street addresses as well.
Table 15-1 lists the  of important services in a small town.
Table 15-1 Small-town Directory.
Ed's Gas Station In this case you have one, large, multipurpose building that is used by several services.
Although there are three address variables (Services), there is only one address (1 Main As you will see in this chapter, pointers can be used as a quick and simple way to access arrays.
In later chapters you will discover how pointers can be used to create new variables and complex data structures such as linked lists and trees.
As you go through the rest of the book, you will be able to understand these data structures as well as create your own.
Page 229 A pointer is declared by putting an asterisk (*) in front of the variable name in the declaration.
Pointer Operators Operator Meaning.
The ampersand operator (&) changes a  into a pointer.
The * changes a pointer into a These operators can easily cause confusion.
Let's look at some simple uses of these operators in detail.
The declaration int  does not contain an asterisk, so  is not a pointer.
The asterisk (*) in the declaration indicates this is a pointer.
Also, you have put the extension _ptr onto the name.
The variable  is a pointer.
The * (de-reference operator) tells Cplus_plus to look at the data pointed to, not at the pointer itself.
Note: This points to an integer, any integer.
It may or may not point to the specific variable.
The following examples show misuse of pointer operators.
Asks Cplus_plus to get the object pointed to by the variable.
Since  is not a pointer, this is an invalid operation.
Page 230 Figure 15-2 Pointer operators & Legal, but strange.
The & (address of) operator gets a pointer to the object (in this case ).
The result is a pointer to a pointer.
It declares one object, , and a pointer,.
Several pointers can point to the same : 1: 2: 3: 4: 5: 6: 7: 8: 9:.
In line 8 you use the & operator to change a simple variable () into a pointer that can be assigned to.
Because  and  are both pointers, you can do a direct assignment in line 9.
After executing this program fragment, you have the situation illustrated by Figure 15-3.
Two pointers and a.
Finally, there is a special pointer called NULL that points to nothing.
Figure 15-4 NULL.
Declaring constant pointers is a little tricky.
For example, although the declaration:.
Instead it tells Cplus_plus that the data pointed to by  is a constant.
The data cannot be changed, but the pointer can.
Again we need to make sure we know the difference between "things" and "pointers to What's.
Yes, it's just a pointer_0_.
A const char array.
Can the data pointed to by  be changed.
A constant pointer.
Integer  0x58239A In this case, the value 0x58239A represents a memory address.
This address may vary from program to program.
Cplus_plus treats character pointers a little differently from other pointers.
A character  is treated as a  to a string.
For example: char [10] = "Hello"; // A simple set of characters char * = &[O]; // Pointer to a character << "String  " <<  << '\n';.
String  Hello Pointers and Arrays Cplus_plus allows  arithmetic.
Addition and subtraction are allowed with pointers.
Note the use of parentheses.
The +1 is outside the parentheses so it is added after the de-reference.
Page 234 Figure 15-5 Pointers and an array At first glance this may seem like a complex way of representing simple array indices.
You are starting with simple  arithmetic.
In later chapters you will use more complex pointers to handle more difficult functions efficiently.
Pointers are merely memory addresses.
In an array each element is assigned to consecutive addresses.
For example, array[0] may be placed at address 0xff000024.
Then array[1] would be placed at address 0xff000025 and so on.
Example 15-2 prints out the elements and addresses of a simple character array.
When run this program prints: &array[]=020090 &array[]=020091 &array[]=020092 &array[]=020093 &array[]=020094 &array[]=020095 &array[]=020096 &array[]=020097 &array[]=020098 &array[]=020099 (array+)=020090 (array+)=020091 (array+)=020092 (array+)=020093 (array+)=020094 (array+)=020095 (array+)=020096 (array+)=020097 (array+)=020098 (array+)=020099 array[]=030 array[]=031 array[]=032 array[]=033 array[]=034 array[]=035 array[]=036 array[]=037 array[]=038 array[]=00 Characters usually take up one byte, so the elements in a character array will be assigned consecutive addresses.
A short int takes up two bytes, so in an array of short ints the addresses increase by two.
Does this mean short_array+1 will not work for anything other than characters.
Cplus_plus automatically scales  arithmetic so it works correctly.
In this case short_array+1 will point to element number 1.
Cplus_plus provides a shorthand for dealing with arrays.
Cplus_plus blurs the distinction between pointers and arrays by treating them the same in many cases.
Here you used the variable  as a  and Cplus_plus automatically did the necessary conversion.
Example 15-3 counts the number of elements that are non-zero and stops when a zero is found.
No limit check is provided, so there must be at least one  in the.
The expression at the end of this program,  , computes how far  is into the.
When passing an  to a procedure, Cplus_plus will automatically change the  into a.
In fact, if you put an & before the , Cplus_plus will issue a warning.
Example 15-5 illustrates passing.
Splitting Strings Suppose you are given a string of the form "Last/First_0_" You want to split this into two strings, one containing the first name and one containing the last name.
Example 15-6 reads in a single line, stripping the newline character from it.
The function strchr is called to find the location of the slash (/).
You then split the string by replacing the slash (/) with an end-of-string (NUL or '\0').
Now last_ptr points to just the last name and first_ptr points to a null string.
Moving first_ptr to the next character makes first_ptr point to the beginning of the first name.
Graphically what you are doing is illustrated in Figure 15-6.
Example 15-6 contains the full program.
Page 238 Figure 15-6.
Splitting a string Example 15-6 split/split_0_cc /* ****************************************************** * Split minus_minus split an entry of the form Last/First * * into two parts * ********************************************************.
Question 15-1: Example 15- 7 is supposed to print out: Name: tmpl but instead you get: Name: _0__@$#ds80 (Your results may vary_0_) Why does this happen.
Two lines of street address Two-character abbreviation Numeric zip code Mailing lists must frequently be sorted   order and zip-code order.
You could sort the entries themselves, but each entry is 226 bytes long.
That's a lot of data to move around.
This sorting is much faster.
Imagine that you had a warehouse full of big heavy boxes and you needed to locate any box quickly.
One way of doing this would be to put the boxes alphabetical order.
But that would require a lot of moving, so you assign each location a number, write down the  and number on index cards, and sort the cards by.
Command-Line Arguments The procedure main actually takes two arguments.
They are called argc and argv.
The parameter argc is the number of arguments on the command  (including the program ).
The array argv contains the actual arguments.
For example, if the program args were run with the command : args this is a test then: argc argv[0] argv[1] argv[2] = = = = 5 NOTE The UNIX shell expands wildcard characters like *, _0_, and [] before sending the command line to the program.
See your sh or csh manual for details.
Turbo-Cplus_plus will expand wildcard characters if the file WILDARG_0_OBJ is linked with your program.
See the Turbo-Cplus_plus manual for details.
Page 242 Almost all UNIX commands use a standard command-line format.
This "standard" has carried over into other environments.
A standard UNIX command has the form: command options filel filel file3 _0__0_.
Options are preceded by a hyphen (-) and are usually a single letter.
For example, the option -v might turn on verbose mode.
If the option takes a parameter, the parameter follows the letter.
For example, the switch -m1024 sets the maximum number of symbols to 1024 and -ooutfile sets the output file  to outfile.
You have been given the assignment to write a program that will format and print files.
Part of the documentation for the program looks like: print_file [-v] [-l<length>] [-o<>] [filel] [file2] _0__0_.
In this line, -v sets verbose options, which turns on a lot of progress information messages.
The option -l<length> sets the page size to <length> lines ( = 66) and -o<> sets the output file to <> ( = print_0_out).
A list of files to print follows these options ([fiel], [file2], etc_0_).
If no files are specified, then print the file print_0_in.
The while loop cycles through the options.
The actual loop is: while ((argc > 1) && ([1][0] == '-')) { There is always one argument, the program.
The expression (argc > 1) checks for additional arguments.
The first one will be numbered 1.
The first character of the first argument is [1][0].
If this character is a dash you have an option.
At the end of the loop is the code:.
This consumes an argument.
The number of arguments is decremented to indicate one less option, and the pointer to the first option is incremented, shifting the list to the left one place.
The switch statement is used to decode the options.
Character 0 of the argument is the hyphen (-).
Character 1 is the option character, so you use the expression: switch ([1[1]) {.
Page 243 The option -v has no arguments; it just causes a flag to be set.
The -1 option takes an integer argument.
The library function atoi is used to convert the string into an integer.
From the previous example you know that [1][2] starts the string containing the number.
This string is passed to atoi.
The option -o takes a filename.
Rather than copy the whole string, you set the character pointer to point to the  part of the string.
By this time you know that: [1][0] = '-' [1][1] = 'o' [][2] = start of the file You set  to point to the string with the statement: = &[1][2]; Finally all the options are parsed and you fall through to the processing loop.
This merely executes the function do_file for each file argument.
Example 15-8 contains the complete option-decoding program.
Example 15-8 print/print cc /******************************************************** * Print minus_minus format files for printing * ********************************************************/.
Output file Number of lines per page /******************************************************** * do_file minus_minus dummy routine to handle a file * * * * Parameter * * minus_minus  of the file to print * ********************************************************/.
This  one way of parsing the argument list.
The use of the while loop and switch statement  simple and easy to understand.
This method does have a limitation.
The argument must immediately follow the options.
For example, -o data_0_out will work, but -o data_0_out will not.
An improved parser would make the program more friendly, but this works for simple programs.
Exercise 15-2: Write a function that takes a single string as its argument and returns a pointer to the first nonwhite character in the string.
Answers to Chapter Questions Answer 15-1: The problem  that the variable   a temporary variable.
The compiler allocates space for the  when the function  entered and reclaims the space when the function exits.
The function assigns  the correct value and returns a pointer to it.
However, the function  over, so  disappears and you have a pointer with an illegal value.
The solution  to declare  static.
Consequently, it  a permanent variable and will not disappear at the end of the function.
Page 246 Question 15-2: After fixing the function, you try using it for two filenames.
Example 15-9 should print out: Name: tmpl Name: tmp2 but it doesn't.
Answer 15-2: The first call to tmp_name returns a pointer to.
There is only one The second call to tmp_name changes  and returns a pointer to it.
So you have two pointers, and they point to the same thing,.
Several library functions return pointers to static strings.
A second call to one of these routines will overwrite the first value.
A solution to this problem is to copy the values:.
IV Advanced Programming Concepts Page 251 16 File Input/Output In This Chapter:.
Cplus_plus File I/O Conversion Routines Binary and ASCII Files The End-of-Line Puzzle Binary I/O Buffering Problems Unbuffered I/O Designing File Formats C-Style I/O Routines C-Style Conversion Routines I am the heir of all the ages, in the foremost files of time —Tennyson A file is a collection of related data.
Cplus_plus treats a file as a series of bytes.
Many files reside on disk; however, devices such as terminals, printers, and magnetic tapes are also considered files.
The Annotated Cplus_plus Reference Manual (Ellis and Stroustrup) is the current widely used standard for Cplus_plus.
This book does not contain a specification of the I/O system.
A de facto standard has evolved based on the library supplied with the cfront compiler from AT&T.
The problem is that some of the details may differ from compiler to compiler.
For example, Turbo-Cplus_plus flushes  at the end of each line while the SunPro UNIX Cplus_plus compiler does not.
The current version of the ANSI Cplus_plus Draft Standard (September 1994) does contain a detailed description of I/O calls.
However, currently no compilers support this, and the standard also is still undergoing revision.
This chapter discusses three different I/O packages.
The first is the Cplus_plus I/O stream classes.
This is the most commonly used I/O system and the one we've been using up to now.
Next, we examine the raw I/O routines that give us direct access to the low-level I/O.
Finally we look at the C I/O system.
Although it is somewhat outdated, C I/O calls still appear in old code.
Also, in some cases, the C-style I/O routines are superior to the ones provided with Cplus_plus.
Page 252 Cplus_plus File I/O Cplus_plus file I/O is based on three classes: the istream class for input, the ostream class for output, and the iostream class for input/output.
Cplus_plus refers to files as streams since it considers them a stream of bytes.
Four class variables are automatically created when you start a program.
These are listed in Table 16-1.
Table 16-1 Predefined I/O Class Variables Variable Use.
Console log These variables are defined in the standard include file <iostream_0_h>.
Normally cin is assigned to the keyboard and , cerr, and clog are assigned to the screen.
Most operating systems allow you to change these assignments through I/O redirection (see your operating system manual for details).
For example, the command my_prog <file_0_in runs the program my_prog and assigns cin to the file file_0_in.
When doing I/O to disk files (except through redirection) you must use the file version of the stream classes.
These are ifstream, ofstream, and fstream and are defined in the include file <fstream_0_h>.
NOTE The ifstream class is actually derived from the istream class.
Similarly, ofstream is derived from ostream and fstream is derived from iostream.
You'll learn about derived classes in Chapter 21, Advanced Classes.
Suppose you want to read a series of 100 numbers from the file numbers_0_dat.
You start by declaring the input file variable: ifstream data_file; // File we are reading the data from.
Closing the file frees resources that can then be used again by the program.
Cplus_plus allows the open call to be combined with the constructor.
For example, instead of writing: ifstream data_file; // File we are reading the data from.
But what if the file numbers_0_dat is missing.
How can you tell if there is a problem.
The member function bad returns "true" if there is a problem, and "false" otherwise.
So to test for problems all you need is:.
A better version of the program for reading numbers is Example 16-1.
This function  defined as: The parameters to this function are: buffer A buffer to store the data that has been read.
The function reads up to len -1 bytes of data into the buffer.
The character used to signal end-of-line.
This function returns a reference to the input file.
The function reads up to and including the end-of-line character.
The end-of-line character  not stored in the buffer.
Problems can occur if the size specified  too big.
Cplus_plus provides a convenient way to make sure the size parameter  just right through the use of the sizeof operator.
The sizeof operator returns the size in bytes of its argument.
The sizeof(string)  30 and sizeof(array)  40 (4 bytes per long * 10 longs in the array).
NOTE sizeof  not the same as length.
The sizeof operator returns the number of bytes in string (used or not).
Output Files The functions for output files are similar to input files.
For example, the declaration: ofstream out_file("out_0_dat"); creates a file named out_0_dat and lets you write to the file using the file variable out_file.
Actually, the constructor can take two additional parameters.
The full definition of the output file constructor : ofstream::ofstream(const char *name, int =ios::out, int  = filebuf::openprot); The parameters for this function are: name The name of the file.
A set of flags ORed together that determine the open.
The flag ios: :out required for output files.
Other flags are listed in Table 16-2.
This operator  discussed in more detail in Chapter File protection.
This  an operating-system-dependent value that determines the protection  for the file.
In UNIX the protection defaults to 0644 (read/write owner, group read, others read).
For MS-DOS/Windows this defaults to 0 (normal file).
Open Flags Flag Meaning.
Open file for output (must be supplied to ofstream opens).
Page 256 Flag Meaning ios: :binary Binary file (if not present, the file  opened as an ASCII file) See the section "Binary I/O" on page 262 for a definition of a binary file.
Input files always fail if there ios::noreplace Do not overwrite existing file.
If a file exists, cause the open to fail.
Conversion Routines So far we have just considered writing characters and strings.
In this section, we consider some of the more sophisticated I/O operations: conversions.
To write a number to a printer or terminal you must convert the number to characters.
The printer understands only characters, not numbers.
For example, the number 567 must be converted to the three characters "5", "6", and "7" to be printed.
The << operator  used to convert data to characters and put them in a file.
This function extremely flexible.
It can convert a simple integer into a fixed- or variable-size string as a hex, octal, or decimal number with left or right justification.
So far you've been using the default conversion for your output.
It serves pretty well, but if you want to control your output exactly, you need to learn about conversion flags.
The member functions setf and unsetf are used to set and clear the flags that control the conversion process.
The general form of the functions :.
Table 16-3 I/0 Conversion Flags Flag Meaning.
Output  left justified.
Page 257 Flag Meaning.
When converting numbers to characters the member function: int file_var_0_width(int size); determines the minimum characters to use.
For example, the  3 would normally convert to the character string "3" (note the lack of spaces).
If the width is set to four, then the result 3" where represents a single space.
Page 258 The member function: int flie_var_0_precision(int digits);.
This character is used for padding when a  is smaller than the specified width.
NOTE Some of these flags and parameters are reset after each output call and some are not.
Which flags are permanent and which are temporary seems to change from compiler to compiler.
In general, don't assume anything is going to remain set and you'll be okay.
You can think of a manipulator as a magic bullet that when sent through an input or output file changes the state of the file.
A manipulator doesn't cause any output; it just changes the state.
For example, the manipulator  changes the output conversion to hexadecimal.
The I/O manipulators are defined in the  file <iomanip_0_h>.
Table 16-4 contains the full list of I/O manipulators.
I/O Manipulators Manipulator.
Page 259 Manipulator Description.
Example 16-2 shows how some of the I/O manipulators may be used.
It  a set of 95 printable characters and 33 control codes.
When you write a program, the prog_0_cc file  ASCII.
Terminals, keyboards, and printers deal with character data.
When you want to write a like 1234 to the screen, it must be converted to four characters (1, 2, 3, -4) and written.
Similarly, when you read a  from the keyboard, the data must be converted from characters to integers.
The ASCII character "0" has the value 48, "1" the value 49, and so on.
When you want to convert a single digit from ASCII to , you must subtract this value :.
Computers work on binary data.
When reading numbers from an ASCII file, the program must process the character data through a conversion routine like the  conversion routine just defined.
Binary files require no conversion.
They also generally take up less space than ASCII files.
The drawback  they cannot be directly printed on a terminal or printer.
They can be moved from machine to machine with very little trouble.
Binary files are almost certainly nonportable.
Unless you are an expert programmer, it  almost impossible to make a portable binary file.
In most cases, ASCII  best.
If you have small to medium amounts of data, the conversion time does not seriously affect the performance of your program.
Page 261 Only when you are using large amounts of data will the space and performance problems force you to use the binary format.
The End-of-Line Puzzle Back in the dark ages BC (Before Computers), there existed a magical device called a Teletype Model 33.
This amazing machine contained a shift register made out of a motor and a rotor as well as a keyboard ROM consisting solely of levers and springs.
The teletype contained a keyboard, a printer, and a paper tape reader/punch.
It could transmit messages over telephones using a modem at the blazing rate of 10 characters a second.
But teletype had a problem.
It took 2/10 second to move the printhead from the right side to the 2/10 second  two character times.
If a second character came while the printhead was in the middle of a return, that character was lost.
The teletype people solved this problem by making end-of- two characters: <carriage return> to position the printhead at the  margin, and < feed> to move the paper up one That way the < feed> "printed" while the printhead was racing back to the  margin.
When the early computers came out, some designers realized that using two characters for end-of- wasted storage (at this time storage was very expensive).
Some picked < feed> for their end-of-, and some chose <carriage return>.
Some of the die-hards stayed with the two-character sequence.
UNIX uses < feed> for end-of-.
The new- character \n is code 0xA (LF or < feed>).
MS-DOS/Windows uses the two characters <carriage return>< feed>.
Compiler designers had problems in dealing with the old C programs that thought new- was just < feed>.
The solution was to add code to the I/O library that stripped out the <carriage return> characters from ASCII input files and changed < feed> to <carriage return>< feed> on output.
In MS-DOS/Windows, whether or not a file is opened as ASCII or binary is important to note.
The flag ios: :binary is used to indicate a binary file: // Open ASCII file for reading ascii_file_0_open("name", ios::in); // Open binary file for reading binary_file_0_open("name", ios::in|ios::binary); Question 16-1: The member function put can be used to write out a single byte of a binary file.
The follouing program writes numbers 0 to 127 to afile called test_0_out.
Page 262 It works just fine in UNIX, creating a 128-byte long file; however, in MSDOS/Windows, thefile contains 129 bytes.
In fact, you can write a half-ASCII/half-binaryfile if you want to.
Binary I/O Binary I/O is accomplished through two member functions: read and write.
The syntax for read is: in_file_0_read(dataptr, size); data_ptr Pointer to a place to put the data.
Page 263 size Number of bytes to be read.
The member function gcount returns the number of bytes gotten by the last read.
This may be less than the number of bytes requested.
For example, the read might encounter an end-of-file or error: struct { int.
In this example you are reading in the structure rectangle.
The & operator makes rectangle into a pointer.
The cast "(char *)" is needed since read wants a character array.
The sizeof operator is used to determine how many bytes to read in as well as to check that read was successful.
The member function write has a calling sequence similar to read.
Instead, the data is kept in a buffer until there is enough for a big write, or until it is flushed.
The following program is designed to print a progress message as each section is finished.
Instead of writing the messages as each step completes,  puts them in a buffer.
Only after the program is finished does the buffer get flushed, and all the messages come spilling out at once.
Page 264 The I/O manipulator flush forces the flushing of the buffers.
Properly written, the above.
Unbuffered I/O In buffered I/O, data is buffered and then sent to the file.
In unbuffered I/O, the data is immediately sent to the file.
If you drop a number of paperclips on the floor, you can pick them up in buffered or unbuffered mode.
In buffered mode, you use your right hand to pick up a paper clip and transfer it to your left hand.
The process is repeated until your left hand is full, and then you dump a handful of paperclips into the box on your desk.
In unbuffered mode, you pick up a paperclip and dump it into the box.
There is no left-hand buffer.
In most cases buffered I/O should be used instead of unbuffered.
In unbuffered I/O, each read or write requires a system call.
Any call to the operating system is expensive.
Buffered I/O minimizes these calls.
Unbuffered I/O should be used only when reading or writing large amounts of binary data or when direct control of a device or file is required.
Back to the paperclip example—if you were picking up small items like paperclips you would probably use a left-hand buffer.
But if you were picking up cannon balls (which are much larger), no buffer would be used.
The open system call is used for opening an unbuffered file.
The macro definitions used by this call differ from system to system.
You are using both UNIX and MS-DOS/Windows, so you have used conditional compilation (#ifdef / #endif) to bring in the correct files.
Page 265 #endif /* _MSDOS_ int.
An integer that is used to identify the file for the read, write and close calls.
If is less than 0 an error occurred.
Open flags are described in Table 16-5.
Table 16-5 Open Flags Flag Meaning.
Normally this is 0666 for most files.
For example, to open the existing file _0_txt in text mode for reading, you use the following: = open("_0_txt", O_RDONLY);.
Notice that you combined flags using the OR (|) operator.
This is a quick and easy way of merging multiple flags.
When any program is initially run, three files are already opened.
Page 266 Table 16-6.
Standard Unbuffered Files File Number Description.
A 0 indicates end-of-file and a negative number indicates an error.
File descriptor of an open file.
This is the size of the request.
The actual number of bytes read The format of a write call is: = write(, buffer, size); Actual number of bytes written.
A negative number indicates an error.
File descriptor of an open file.
The system will try to write this many bytes, but if the device is full or there is some other problem, a smaller number of bytes may be written.
Finally, the close call closes the file: 0 for success, negative for error.
File descriptor of an open file.
Page 267 Example 16-4 copies a file.
Unbuffered I/O is used because of the large buffer size.
It makes no sense to use buffered I/O to read 1K of  into a buffer (using an ifstream) and then transfer it into a 16K buffer.
Example 16-4 copy_0_2/copy2_0_cc /**************************************** * Copy minus_minus copy one file to another * * * * Usage * * copy <from> <to> * * * * <from> minus_minus the file to copy from * * <to> minus_minus the file to copy into * ****************************************/.
Buffer for Input file descriptor Output file descriptor Number of bytes on last read.
Several things should be noted about this program.
First of all, the buffer size is defined as a constant, so it is easily modified.
Rather than have to remember that 16K is 16,384, the programmer used the expression (16 * 1024).
This form of the constant is obviously 16K.
If the user improperly uses the program, an error message results.
To help the user get it right, the message tells how to use the program.
You may not read a full buffer for the last read.
That is why  is used to determine the number of bytes to write.
Designing File Formats Suppose you are designing a program to produce a graph.
The height, width, limits, and scales are to be defined in a graph configuration file.
You are also assigned to write a user-friendly program that asks the operator questions and writes a configuration file so he or she does not have to learn the text editor.
How should you design a configuration file.
One way would be as follows: x lower limit x upper limit y lower limit y upper limit x-scale y-scale Page 269 A typical plotter configuration file might look like: 10_0_0 7_0_0 0 100 30 0_0_5 2_0_0 This file does contain all the data, but in looking at it, you have trouble identifying what, for example, is the value of the Y lower limit.
A solution is to comment the file so the configuration program writes out not only the data.
But suppose a user runs the plot program and types in the wrong filename, and the program gets the lunch menu for today instead of a plot configuration file.
The program is probably going to get very upset when it tries to construct a plot whose The result is that you wind up with egg on your face.
There should be some way of identifying this file as a plot configuration file.
One method of doing this is to put the words "Plot Configuration File" on the first line of the file.
Then, when someone tries to give your program the wrong file, the program will print an error message.
This takes care of the wrong file problem, but what happens when you are asked to enhance the program and add optional logarithmic plotting.
You could simply add another line to the configuration file, but what about all those old files.
It's not reasonable to ask everyone to throw them away.
The best thing to do ( a user's point of view) is to accept old format files.
You can make this easier by putting a version number in the file.
A typical file now looks like: Plot Configuration File V1_0_0 log Logarithmic or normal plot 10_0_0 7_0_0 0 x lower limit Page 270 100 30 300 0_0_5 2_0_0 x upper limit y lower limit y upper limit x-scale y-scale In binary files, it is common practice to put an identification number in the first four bytes of the file.
This is called the magic number.
The magic number should be different for each type of file.
One method for choosing a magic number is to start with the first four letters of the program name (e_0_g_0_, list) and convert them to hex: 0x6c607374.
Then add 0x80808080 to the number: 0xECEOF3F4.
This generates a magic number that is probably unique.
The high bit is set on each byte to make the byte non-ASCII and avoid confusion between ASCII and binary files.
When reading and writing a binary file containing many different types of structures, it is easy to get lost.
For example, you might read a name structure when you expected a size structure.
This is usually not detected until later in the program.
To locate this problem early, the programmer can put magic numbers at the beginning of each structure.
Then if the program reads the name structure and the magic number is not correct, it knows something is wrong.
Magic numbers for structures do not need to have the high bit set on each byte.
Making the magic number just four ASCII characters makes it easy to pick out the beginning of structures in a file dump.
C-Style I/O Routines allows you to use the C I/O library in  programs.
Many times this occurs because someone took a C program and translated it to  and didn't want to bother translating the I/O calls.
In some cases, the old C library is better and easier to use than the new  library.
For example, C string-conversion routines such as sscanf and sprintf are far easier to use than their  counterparts.
The declarations for the structures and functions used by the C I/O functions are stored in the standard  file <stdio_0_h>.
The declaration for a file variable is: FILE *file_variable, /* Comment */.
The format for fopen is: = fopen(name, mode); file_variable A file variable.
Mode is "w" for writing and "r" for reading.
The function fclose closes the file.
The format of fclose is: = fclose (file_variable); The variable  will be zero if the fclose was successful or non-zero for an error.
C provides three preopened files.
These are listed in Table 16-7.
Standard Files File Description.
Equivalent to 's cerr.
There is no C file equivalent to 's clog.
The function fgetc reads a single character from a file.
If there is no more data in the file the function returns the constant EOF (EOF is defined in stdio_0_h).
Note that fgetc returns an integer, not a character.
This is necessary because the EOF flag must be a noncharacter value.
Example 16-5 counts the number of characters in the file input_0_txt.
The format of the fgets call : = fgets (string, size, file); sring_ptr Equal to string if the read was successful, or NULL if EOF or an error  detected.
It then ends the string with a null (\0).
Example: char _0__0_.
The format of the fputs function : = fputs (string, file); The parameters to fputs are similar to the ones for fgets.
C-Style Conversion Routines uses the << operator for output.
C uses the printf family of functions.
A printf call consists of two parts: a format that describes how to print the data and a list of data to print.
The general form of the printf call : printf (format, parameter-1, parameter-2, _0__0__0_);.
For example, when C sees %d in the format string, it takes the next parameter from the parameter list (which must be an integer) and prints it.
Figure 16-1 shows how the elements of the printf statement work to generate the final result: Figure 16-1.
Other types of parameters use different conversions.
For example, if you want to print a floating point number, you need a %f conversion.
Table 16-8 lists the conversions.
C-style Conversions Conversion Variable Type.
See your reference manual for details.
The printf function  not check for the correct number of parameters on each line.
If you add too many, the extra parameters are ignored.
If you add too few, C will make up values for the missing parameters.
Also C  not type check parameters, so if you use a %d on a floating point number, you will get strange results.
Warning: The return value of sprintf differs from system to system.
The ANSI standard defines it as the  of characters stored in the string; however, some implementations of UNIX C define it to be a pointer to the string.
Reading  accomplished through the scanf family of calls.
The scanf function has similar sister functions: fscanf and sscanf.
The format for fscanf : = fscanf(file, format, &parameter-l,.
In some cases a random variable or instruction will be modified.
This is not common on UNIX machines, but MS-DOS/Windows, with its lack of memory protection, cannot easily detect this problem.
In MS-DOS/Windows, omitting & can cause a system crash.
There is one problem with this scanf: It's next to impossible to get the end-ofline handling right.
However, there's a simple way to get around the limitations of scanf—don't use it.
Instead use fgets followed by the string version of scanf, the function sscanf:.
Use fgets and sscanf instead.
C-Style Binary I/O Binary I/O is accomplished through two routines: fread and fwrite.
The syntax for fread is: = fread (dataptr, 1, size, file); Size of the data that was read.
If this is less than size, then an end-of-file or error occurred.
Example: struct { int.
The cast "(char *)" turns &rectangle into the proper parameter type, and the sizeof operator is used to determine how many bytes to fread in as well as to check that read was successful.
For a full description of these functions see your C reference manual.
Question 16-4: No matter what filename you give the following program, our program can't find it.
Programming Exercises Exercise 16-1: Write a program that reads a file and counts the  of lines in it.
Exercise 16-2: Write a program to copy a file, expanding all tabs to multiple spaces.
Exercise 16-3: Write a program that reads a file containing a list of numbers and writes two files, one with all the numbers divisible by 3 and another containing all the other numbers.
Exercise 16-4: Write a program that reads an ASCII file containing a list of numbers and writes a binary file containing the same list.
Write a program that goes the other way so you can check your work.
Exercise 16-5: Write a program that copies a file and removes all characters with the high bit Exercise 16-6: Design a file format to store a person's name, address, and other information.
Write a program to read this file and produce a set of mailing labels.
Answers to Chapter Questions Answer 16-1: The problem is that you are writing an ASCII file, but you wanted a binary file.
In UNIX, ASCII is the same as binary, so the program runs fine.
In MSDOS/Windows, the end-of- issue causes problems.
When you write a new- character (OxOa) to the file, a carriage return (OxOD) is added to the file.
To write binary data (without output editing) you need to open the file with the binary option: _0_open("test_0_out", ios::out | ios::binary);.
The problem is that the parameter containing the answer was omitted.
When this happens printf gets the answer from a random location and prints garbage.
Properly written, the printf statement is: printf("The answer is %d\n", answer); Page 279 Answer 16-3: The printf call  not check the type of its parameters.
You tell the printf call to print an integer  (%d) and supply it with a floating point parameter (result).
This mismatch causes unexpected results such as printing the wrong answer.
When printing a floating point  you need a %f conversion.
Properly written, our printf statement is: printf("The answer is %f\n", result); Answer 16-4: The problem is that fgets gets the entire  including the new- character (\n).
If you have a file named sam, the program reads sam\n and tries to look for a file by that Because there is no such file, the program reports an error.
The fix is to strip the new- character from the :.
The error message in this case is poorly designed.
True, you did not open the file, but the programmer could supply the user with more information.
Are you trying to open the file for input or output.
What is the  of the file you are trying to open.
You don't even know whether the message you are getting is an error, a warning, or just part of the normal operation.
A better error message is: fprintf(stderr, "Error: Unable to open %s for input\n", ); Notice that this message would also help us detect the programming error.
When you typed in "sam" the error would be: Error: Unable to open sam for input This clearly shows us that you are trying to open a file with a new- in its.
Page 281 17 Debugging and Optimization In This Chapter:.
Debugging Divide and Conquer Debug-Only Code Debug CommandLine Switch Interactive Debuggers Debugging a Binary Search Runtime Errors The Confessional Method of Debugging How to Optimize Case Study Exercises Answers to Questions Bloody instructions which, being learned, return to plague the inventor.
It is here that you find out how your program really works (instead of how you think it works).
To eradicate a bug, you need two things: a way of reproducing the bug and information from the program that lets you locate and correct the problem.
In some cases, finding the bug is easy.
You discover the bug yourself, the test department produces a clear and easy test that displays the bug, or the output always comes out bad.
In some cases, especially with interactive programs, reproducing the bug may be 90 percent of the problem.
This is especially true when dealing with bug reports sent in by users in the field.
A typical call from a user might be: User: That database program you gave me is broken.
Programmer: What's wrong.
User: Sometimes when I'm doing a sort, it gets things in the wrong order.
Page 282 Programmer: What command were you using.
User: The sort command.
Programmer: Tell me exactly what you typed, keystroke by keystroke, to get it to fail.
User: I don't remember it exactly.
Programmer: If I come over can you show me the bug.
User: Of course.
The user types away and the program stubbornly works, no matter what the user does to it.
The programmer gives up and goes back to his office only to find a message from the user: "It Example 17-1 is a short database lookup program.
It asks the user for input and checks the input against a hard-coded list of names.
Although it is very simple, the program's structure is typical of much larger and more complex interactive programs.
A typical execution of this program is: Enter : Sam Sam is not in the Enter : John Page 284 John is in the Enter : When we release this program, the users immediately start complaining about mysterious problems that go away whenever the programmer is around.
Wouldn't it be nice to have a little gremlin sitting on the user's shoulder copying down everything he or she types.
Unfortunately, gremlins are unavailable; however, we can change this program so it produces a save file that contains every keystroke the user typed.
Our program uses the statement: cin_0_getline(, sizeof()); to read the user data.
Let's write a new , extended_getline, and use it instead of getline.
It not only will get a line.
Example 17-2 xgets/xgets_0_cc # <iostream_0_h> # <fstream_0_h> /* * The main program will open this file if -S is on * the command line.
We also change our main program to handle a new : "-Sfile" to specify a save file.
Now we have a complete record of what the user typed.
Looking at the input, we see that he typed: Sam John The second name begins with a space and, although "John" is in the list, "<space>John" is not.
In this case we found the error by inspecting the input; however, more complex programs have much more complex input.
We could type all that in when debugging, or we could add another feature to extended_getline that would add a playback file to it.
When the playback file is enabled, input will not be taken from the keyboard, but instead will be taken from the file.
Example 17-4 xgets/xgets2_0_cc.
Our main program now looks like Example 17-5.
Playback data Save  open flag Save  if any // True if playback in progress char *extended_getline(char *, int size, istream &); main(int { char char char name[80]; // A name to look up *; // Name of the save *playback_file_name; // Name of the playback int lookup(char *name); // lookup a name.
Now when a user calls up with an error report, we can tell him, "Try it again with the save- feature enabled, and then send me a copy of your files_0_" The user then runs the program and saves the input into the  save_0_txt.
In many cases that's half the battle.
Once you can reproduce the problem you can proceed to the next steps: finding it and fixing it.
Once a programmer asked a user to send the programmer a copy of his floppy.
An express package arrived the next day containing a Xerox photocopy of the floppy.
But the user was not completely computer-illiterate: He knew it was a two-sided floppy, so he had photocopied both sides.
Serial Debugging Before you start debugging, save the old, "working" copy of your program in a safe place.
Sometimes you will find you've been barking Page 290 up the wrong tree and need to start over.
That's when the last working copy becomes invaluable.
Once you have reproduced the problem, you must determine what caused it to happen.
Divide and Conquer The divide and conquer method has already been briefly discussed in Chapter 7, The Programming Process.
It consists of putting in  statements where you know the data is good (to make sure it really is good), where the data is bad, and several points in between.
This way you can start zeroing in on the section of code that contains the error.
More statements can further reduce the scope of the error until the bug is finally located.
Debug-Only Code The divide-and-conquer method uses temporary  statements.
They are put in as needed and taken out after they are used.
The pre-processor conditional-compilation directives can be used to put in and take out debugging code.
For example: #ifdef DEBUG << " " <<  << "  " <<  << \n'; #endif /* DEBUG */ The program can be compiled with DEBUG undefined for normal use so you can define it when debugging is needed.
Debug Command-Line Switch Rather than using a compile-time switch to create a special version of the program, you can permanently  the debugging code and add a special program switch that will turn on debugging output.
For example: << " " <<  << "  " <<  << '\n; where debug is a variable set if -D is present on the command line.
This has the advantage that only a single version of the program exists.
One of the problems with "debug-only" code is that unless the code is frequently used, it can easily become stale and out of date.
Frequently a programmer tries to find a bug only to discover that the debug-only code is out of date and needs fixing.
Another advantage of the debug command-line switch is that the user can turn on this switch in the field, save the output, and send it to you for analysis.
The Page 291 runtime switch should be used in all cases instead of conditional compilation, unless there is some reason you do not want the customer to be able to get at the debugging information.
Some programs use the concept of a debug level.
Level 0 outputs only minimal debugging information, level 1 more information, and on up to level 9, which outputs everything.
Another debugging technique can be seen in the Ghostscript* program by Aladdin Enterprises.
This program implements the idea of debugging letters.
The command  -Zxxx sets the debugging flags for each type of diagnostic output wanted.
For example, f is the code for the fill algorithm and p is the code for the path tracer.
If I wanted to trace both these sections, I would specify -Zfp.
The  is implemented by the following code: /* * Even though we only put 1 zero, Cplus_plus will fill in the * rest of the arrays with zeros */.
Free Software Foundation.
Inc, 675 Mass Ave , Cambridge.
MA 02139, phone (617) 876-3296.
This form of debugging allows the user to get a great deal of information easily.
Going Through the Output Enabling  printout is a nice way of getting information, but many times there is so much data that the information you want can easily get lost.
The shell or command-line interpreter allows you to redirect what would normally go to the screen to a file through the use of the ">file".
For example: buggy -D9 >tmp_0_out will run the program buggy with a high level of  set and send the output to the file tmp_0_out.
The text editor on your system also makes a good file browser.
You can use its search capabilities to look for the information you want to find.
Interactive Debuggers Most compiler manufacturers provide an interactive debugger.
They give you the ability to stop the program at any point, examine and change variables, and "single-step" through the program.
Because each debugger is different, a detailed discussion is not possible.
However, we are going to discuss one debugger gdb.
This program is available for many UNIX machines from the Free Software Foundation.
Turbo-Cplus_plus has its own built-in debugger.
Although the exact syntax used by your debugger may be different, the principles shown here will work for all debuggers.
Basic GDB commands are: run Start execution of a program.
When a running program reaches a breakpoint, execution stops and control returns to the debugger.
Commonly, the command break in main is used to stop execution at the beginning of the program.
Page 293 cont Continue execution after a breakpoint.
If the current statement calls a function, the function is single stepped.
This command is used to skip over function calls.
We have a program that should count the number of threes and sevens in a series of numbers.
The problem is it keeps getting the wrong answer for the number of sevens.
Our program is shown in Example 17-6.
Page 294 22 23 24 25 26 27 28 29 30 31 return (0); } /******************************************************** * get_data minus_minus get 5 numbers from the command line * ********************************************************/.
Threes 3  3 We start by invoking the debugger (GDB) with the name of the program we are going to debug (count).
The debugger initializes, outputs the prompt (gdb), and waits for a command.
There is absolutely no warranty for GDB; type "show warranty" for details.
GDB 4_0_12 (m68k-sun-sunos4_0_0_0_3), Copyright 1994 Free Software Foundation, Inc_0__0_.
We don't know where the variable is getting changed, so we'll start at the beginning and work our way through until we get an error.
At every step we'll display the variable just to make sure it's okay.
We need to stop the program at the beginning so we can single-step through it.
The command break main tells GDB to set a breakpoint at the first instruction of the function main.
The command run tells GDB to start the program, which will run until it hits the first breakpoint.
The number 1 is used by GDB to identify the breakpoint.
Now we need to start the program: (gdb) run Starting program: /usr/sdo/count/count Breakpoint 1, main () at count_0_cc:10 10 = 0; The message Breakpoint 1, main_0__0_.
Page 295 We have reached the point where  is initialized.
The command next will execute a single statement, treating function calls as one statement.
We try the next few lines, checking all the time: (gdb) next 12 get_data(data); (gdb) print $2 = 0 (gdb) next Enter 5 numbers 37302 14 for ( = 1;  <= 5; plus_plusindex) { (gdb) print $3 = 2 somehow changed the value to 2.
The last statement we executed was get_data(data); so something is going on in that function.
We add a breakpoint at the beginning of get_data, get rid of the one at main, and start the program over with the run command: (gdb) break get_data Breakpoint 2 at 0x23b2: file count_0_cc, line 29.
Start it from the beginning.
We've narrowed the problem down to one statement.
By inspection we can see that we are using  [5], an illegal member of the array.
Since  is only five elements long, there is no [5].
However, the cin >> [5] has to put the  someplace, so it decided to put it in a random memory location, in this case.
Debugging a Binary Search The binary search algorithm is fairly simple.
You want to see whether a given number is in an ordered list.
Check your number against the one in the middle of the list.
If it is the number, you were lucky—stop.
If your number was bigger, then you might find it in the top half of the list.
Try the middle of the top half.
If it was smaller, try the bottom half.
Keep trying and dividing the list in half until you find the number or the list gets down to a single number.
Example 17-7 uses a binary search to see whether a number can be found in the file numbers_0_dat.
Input file Middle of our search range Upper/lower bound Number to search for.
Our data file is: numbers_0_dat 4 6 14 16 17 -1 When we run this program in UNIX, the results are: % When we run this program on MS-DOS, the system locks up and we have to hit the reset switch.
If the program is run in Windows we get an application error (if we're lucky).
It means something went wrong in our program and the program tried to read memory that wasn't there.
The debugger GDB can read this file and help us determine what happened.
Page 299 There is absolutely no warranty for GDB; type "show warranty" for details.
GDB 4_0_12 (m68k-sun-sunos4_0_0_0_3), Copyright 1994 Free Software Foundation, Inc_0__0_.
The debugger tells us we have been killed by a segmentation fault generated from the procedure.
But we don't have a procedure number.
The routine must belong to the Cplus_plus library.
We now use the where command to find out which function called which function (also known as a stack trace): (gdb) where #0 0xec46320 #1 0xec45cc2 #2 0xec45b34 #3 0x2400 in.
The current function is printed first, then the function that called it, and so on until we reach the outer function main.
From this we see that number was called by _doscan, which was called by sscanf.
We recognize sscanf as a library routine.
The other functions must be subroutines called by sscanf.
The last function that had control was the call of sscanf, which was made from line 48 of main.
Now we use the list command to take a look at the source for this line: (gdb) list 48 43 44 break; 45 46 in_file_0_getline(line, sizeof(line)); 47 48 sscanf(line, "%d", data[maxcount]); 49 50 break; 51 52 plus_plusmax_count; (gdb) quit The program is running.
Quit anyway (and kill it).
Another way of finding the problem is to single-step through the program until the error occurs.
First list a section of the program to find a convenient place to put the breakpoint, and then start the execution and single-step process.
Page 300 Script started on Mon Oct 31 10:07:19 1994 % gdb GDB is free software and you are welcome to distribute copies of it under certain conditions; type "show copying" to see the conditions.
There is absolutely no warranty for GDB; type "show warranty" for details.
GDB 4_0_12 (m68k-sun-sunos4_0_0_0_3), Copyright 1994 Free Software Foundation, Inc_0__0_.
Quit anyway (and kill it).
On inspection we notice that we forgot to put an ampersand (&) in front of the variable for sscanf.
So we change line 48 from:.
Page 301 NOTE You might wonder why we use the function sscanf when the line: in_file >> data[]; performs the same function.
The answer is simple.
We used sscanf to cause problems.
Without the pointer error we would have nothing to debug.
The in_file statement is more reliable, and reliable code has no place in a chapter on debugging.
The first number in our list is 4, so we try it.
This time our output looks like: Enter number to search for or -1 to quit: 4 Found at index 0 Found at index 0 Not found Enter number to search for or -1 to quit: ^C The program should find the number, let us know it's at index 0, and then ask for another number.
Instead we get two found messages and one not found message.
We know that everything is running smoothly up to the time we get the first found message.
Getting back into the debugger, we use the list command to locate the found message and put a breakpoint there.
There is absolutely no warranty for GDB; type "show warranty" for details.
GDB 4_0_12 (m68k-sun-sunos4_0_0_0_3), Copyright 1994 Free Software Foundation, Inc_0__0_.
Page 302 Breakpoint 1, main () at search_0_cc:70 70 << "Found at " <<  << '\n'; (gdb) step Found at  0 73 (gdb) step 78 (gdb) step 81 = ; (gdb) step 67 = ( + ) / 2; (gdb) step 69 (gdb) step 70 << "Found at <<  << '\n'; (gdb) step Found at  0 73 (gdb) quit The program is running.
Quit anyway (and kill it).
Instead it continues with the search.
Because the number has already been found, this search results in strange behavior.
We are missing a break after the.
We need to change: << "Found at  " <<  << '\n'; }.
Making this fix, we try the program again: % search Enter number to search for or -1 to quit: 4 Found at  0 Enter number to search for or -1 to quit: 6 Found at  1 Enter number to search for or -1 to quit: 3 Not found Enter number to search for or -1 to quit: 5 We have a runaway program.
This time instead of setting a breakpoint we just start running the program.
After a few seconds pass and we believe that we are stuck in the infinite loop, we stop the program with a control-C (^C).
Normally Page 303 this would abort the program and return us to the shell prompt.
Since we are running with the debugger, it returns control to GDB.
There is absolutely no warranty for GDB; type "show warranty" for details.
GDB 4_0_12 (m68k-sun-sunos4_0_0_0_3), Copyright 1994 Free Software Foundation, Inc_0__0_.
Quit anyway (and kill it).
Our algorithm has an off-by-one error.
Obviously the  element does not match.
If it did we'd exit with a found at message.
So there is no point including the  element in our new  range.
Our code to adjust the interval is: = ; else = ;.
Example 17-8 /4 cc /******************************************************** * Search minus_minus  a set of numbers * * * * Usage: * * You will be asked numbers to look up * * * Page 305 * Files: * * numbers_0_dat minus_minus numbers 1 per line to * * * ********************************************************/.
Input file Middle of our  range Upper/lower bound Number to  for.
Interactive debuggers work well for most programs.
Sometimes they need a little help.
We try to debug it and find it fails when point_number is 735.
We want to put a breakpoint before the calculation is made.
When the debugger inserts a breakpoint into a program, the program will execute normally until it hits the breakpoint, and then control will return to the debugger.
This allows the user to examine and change variables as well as perform other debugging commands.
When a cont command is typed, the program will continue execution as though nothing happened.
The problem is that there are 734 points before the one we want, and we don't want to stop for each of them.
We can do this by adding the following temporary code: 48: 49: if ( == 735) /* ### Temp code ### */ = ; /* ### Line to stop on ### */ Line 49 does nothing useful except serve as a line that the debugger can stop on.
We can put a breakpoint on that line with the command break 49.
The program will process the first 734 points, and then execute line 49, hitting the breakpoint.
The advanced GDB command break 49 if  == 735 would Runtime Errors Runtime errors are usually the easiest to fix.
Some types of runtime errors are segmentation violation, stack overflow, and divide by 0.
Segmentation violation This error indicates that the program tried to de-reference a pointer containing a bad value.
Stack overflow The program tried to use too many temporary variables.
Sometimes this means the program is too big or using too many big temporary arrays, but most of the time this is due to infinite recursion problems.
Almost all UNIX systems automatically check for this error.
Turbo-Cplus_plus will check for stack overflow only if the compile time option -N is used.
Divide by 0 Divide by 0 is an obvious error.
UNIX masks the problem by reporting an integer divide by zero with the error message Floating exception (core dumped).
In all cases, program execution will be stopped.
In UNIX, an image of the running program, called a core file, is written out.
This file can be analyzed by the debugger to determine why the program died.
Our first run of Example 17-7 resulted in a core dump.
The buffers for buffered files are not flushed.
This can lead to some unexpected surprises.
Starting This might lead you to think the divide had never started, when in fact it had.
What happened to the message "Before divide_0__0__0_".
The  statement executed, and put the message in a buffer, and then the program died.
The buffer never got a chance to be emptied.
By putting explicit flush-buffer commands inside the code, we get a truer picture of what is happening, as shown in Example 17-11.
Page 309 The Confessional Method of Debugging The confessional method of debugging is one by which the programmer explains his program to someone: an interested party, an uninterested party, a wall—it doesn't matter whom he explains it to as long he talks about it.
A typical confessional session goes like this: "Hey, Bill, could you take a look at this.
My program has a bug in it.
The output is computed using this formula and I've checked out the payment value and rate and the date must be correct, unless there is something wrong with the leap-year Optimization And now a word on optimization: Don't.
Most programs do not need to be optimized.
They run fast enough.
Who cares whether an interactive program takes 0_0_5 seconds to start up instead of 0_0_2.
To be fair, there are a lot of slow programs out there that can be sped up.
This is usually done not by the simple optimization steps shown in this chapter, but by replacing poorly designed core algorithms with more efficient ones.
For a well-written program, the simplest way to get your program to run faster is to get a faster computer.
Many times it is cheaper to buy a more powerful machine than it is to optimize a program, because you may introduce new  into your code.
Don't expect miracles from optimization.
Usually most programs can only be sped up 10 percent to 20 percent.
Example 17-12 initializes a matrix (two-dimensional array).
How can this function be optimized.
First we notice we are using two local varibles.
By using the qualifier register on these variables, we tell the compiler that they are frequently used and should be placed in fast registers instead of relavely slow main memory.
The number of registers varies from computer to computer.
Slow machines like the PC have 2, most UNIX systems have about 11,and supercomputers can have as many as 128.
It is possible to declare moreregister variables than you have registers.
Cplus_plus will put the extra variables in mainmemory_0_The program now looks like Example 17-13.
Example 17-13 matrix/matrix2_0_cc.
The outer loop is executed 60 times.
This means the overhead associated with starting the inner loop is executed 60 times.
If we reverse the order of the loops, we will have to deal with the inner loop only 30 times.
In general, loops should be ordered so the innermost loop is the most complex and the outermost loop is the simplest.
Example 17-14 contains the init_matrix function with the loops reordered.
To do this, the program must perform the following steps: 1.
Get the address of the matrix.
Add up all three parts to form the address.
In Cplus_plus this code looks like: *(matrix + ( * ) + ) = -1; However you typically won't write matrix accesses this way because Cplus_plus handles the details.
But being aware of the details can help you generate more efficient code.
Almost all Cplus_plus compilers will convert multiplies by a power of two (2, 4, 8, _0__0__0_) into shifts, thus taking an expensive operation (multiply) and changing it into an inexpensive operation (shift).
For example: = 32 * ; is compiled as: =  << 5; /* 2**5 == 32 */ is 30, which is not a power of two.
By increasing  to 32 we waste some memory but get a faster program.
Example 17-15 shows how we can take advantage of a power of two.
Since we are initializing consecutive memory locations, we can initialize the matrix by starting at the first location and storing a -1 in the next  * Y_ SIZE elements.
Using this method, we cut the number of loops down to one.
The indexing of the matrix has changed from a standard index (matrix[] []), requiring a shift and add, into a pointer de-referent (*matrixptr) and an increment (plus_plusmatrix_ptr).
In Example 17-16 we've turned our arrays into pointers.
But why have both a loop counter and a.
In Example 17-17 we've successfully eliminated the loop counter by combining it with the array pointer.
The function is now well optimized.
The only way we could make it better is to manually code it into assembly language.
This might make it faster; however, assembly language is highly nonportable and very error-prone.
The library routine memset can be used to fill a matrix or array with a single character value.
We can use it to initialize the matrix in this program.
Frequently used library subroutines such as memset are often coded into assembly language and may make use of special processor-dependent tricks to do the job faster than could be done in Cplus_plus.
In Example 17-18 we let the function memset do the work.
Example 17-18 matrix/matrix7_0_cc.
Now our function consists of only a single function call.
It seems a shame to have to call a function just to call another function.
We have to pay for the overhead of two function calls.
It would be better if we called memset from the main function.
Why don't we rewrite the code using memset instead of init_matrix.
Because it has several hundred init_matrix calls and we don't want to do all that editing.
So how do we get rid of the overhead of a function call.
By making the function inline.
Our final version of the function uses inline to eliminate all the call overhead and can be seen in Example 17-19.
How to Optimize Our matrix initialization function illustrates several optimizing strategies.
These are: Removing invariant code Code that does not need to be put inside a loop should be put outside the loop.
For example: matrix[] =  +  * 10;.
Loop ordering Nested loops should be ordered with the simplest loop outermost and the most complex loops innermost.
Page 315 Reduction in strength This is a fancy way of saying use cheap operations instead of expensive ones.
Table 17-1 lists the relative cost of common operations.
Table 17-1 Relative Cost of Operations Operation Relative Cost File input  output (<<  >>), including the C functions printf  scanf.
They then have to do a costly conversion between a character string  a number.
These functions should be avoided in time-critical sections of code.
Reference pa ra meters Use constant reference parameters (const type &) instead of constant parameters for structures, unions,  classes.
Powers of 2 Use a power of 2 when doing integer multiply or divide.
Most compilers will substitute a shift for the operation.
Pointers Pointers are faster than indexing an array.
Inlinefunctions Using inline functions eliminates the overhead associated with a function call.
It also can Page 316 Case Study: Inline Functions Versus Normal Functions I once worked on writing a word-processing program for a large computer manufacturer.
We had a function next_char that was used to get the next character from the current file.
It was used in thousands of places throughout the program.
When we first tested the program with next_char written as a function, the program was unacceptably slow.
Analyzing our program we found that 90 percent of the time was spent in next_char.
So we changed it to an inline function.
The speed doubled; however, our code size went up 40 percent  required a memory expansion card to work.
So the speed was all right, but the size was unacceptable.
We finally had to write the routine as a function in hand-optimized assembly language to get both the size  the speed to acceptable levels.
Case Study: Optimizing a Color-Rendering Algorithm I once was asked to optimize a program that did color rendering for a large picture.
The problem was that the program took eight hours to process a single picture.
This limited us to doing one picture a day.
The first thing I did was run the program on a machine with a floating-point accelerator.
This brought the time down to about six hours.
Next I got permission to use a high-speed RISC computer that belonged to another project but was currently sitting idle.
That reduced the time to two hours.
I saved six hours solely by using faster machines.
No code had changed yet.
Two fairly simple functions were being called only once from the innermost loop.
Rewriting these functions as macros saved about 15 minutes.
Next I changed all the floating-point operations I could from floating-point to integer.
The savings amounted to 30 minutes out of a 1:45 run.
Then I noticed the program was spending about 5 minutes reading an ASCII file containing a long list of floating-point numbers used in the conversion process.
Knowing that scanf is an extremely expensive function, I cut the initialization process down to almost nothing by making the file binary.
Total runtime was now down to 1:10.
By carefully inspecting the code  using every trick I knew, I saved another 5 minutes, leaving me 5 minutes short of my goal of an hour per run.
At this point Page 317 my project was refocused  the program put in mothballs for use at some future date.
Programming Exercises Exercise 17-1: Take one of your previous programs  run it using the interactive debugger to examine several intermediate values.
Exercise 17-2: Write a matrix-multiply function.
Create a test program that not only tests the function, but times it as well.
Optimize the program using pointers  determine the time savings.
Exercise 17-3: Write a program to sum the elements in an array.
Exercise 17-4: Write a program that counts the number of bits in a character array.
Optimize it through the use of register-integer variables.
Time it on several different arrays of different sizes.
Exercise 17-5: Write your own version of the library function memcpy.
Most implementations of memcpy are written in assembly language  take advantage of all the quirks  tricks of the processor.
How does your memcpy compare with theirs.
Answers to Chapter Questions Answer 17-1: The problem is that memset is a character fill routine.
An  consists of 2 or 4 bytes (characters).
Each byte is assigned the value 1.
So a 2-byte  will receive the value: = 0x0101; The 1-byte hex value for -1 is 0xFF.
The 2-byte hex value of -1 is 0xFFFF.
So we can take two single byte -1 values, put them together and come out with - 1.
This works for zero also.
Any other number will produce the wrong answer.
Page 319 18 Operator Overloading In This Chapter:.
Operator Functions Operator Member Functions Full Definition of the Complex Class Programming Exercises Answers to Chapter Questions Overloaded, undermanned, ment to flounder, we Euchred God Almighty's storm, bluffed the Eternal Sea.
But Cplus_plus doesn't have a built-in complex type, so it doesn't know how to add two complex numbers.
However, through a Cplus_plus feature called operator overloading, you can "teach" Cplus_plus how to handle complex numbers.
Operator overloading is used to define a set of functions to add, subtract, multiply and divide complex numbers using the normal operators +, -, *, and /.
In this section we define a complex number class.
Let's start by defining the basic Cplus_plus complex class.
A complex number consists of two parts, the real and the imaginary: class complex { protected:.
Next we define several member functions.
These include the usual constructors and destructors as well as routines to get at the real and imaginary parts of the number.
As you may recall, the const appearing after some functions was discussed in Chapter 14, More on Classes.
Now we want to use our complex numbers.
Declaring variables is simple.
Even initializing them with numbers such as (3 + 2i) is easy.
But what happens when we want to add two complex numbers.
We need to define a function to do it:.
This is the most efficient way of passing structures into a function.
Finally, because it is such a small function, we've defined it as an inline function for efficiency.
In this function, we explicitly declare a result and return it.
We can do both in one step: // Version 2 of the complex add function.
In version 1 of the add function we explicitly allocated a variable for the result.
In version 2, Cplus_plus automatically creates a temporary variable for the result.
This number has no name and doesn't really exist outside the return statement.
Creating the temporary variable causes the constructor to be called.
The temporary variable is then assigned to ; thus we have a call to the assignment function.
After the assignment, Cplus_plus no longer has any use for the temporary variable and throws it away by calling the destructor.
Page 322 Operator Functions Using the add function for complex numbers is a little awkward.
It would be nice to be able to convince Cplus_plus to automatically call this function whenever we try to add two complex numbers together with the + operator.
That's where operator overloading comes in.
All we have to do is to write the add function as:.
Note: The operator overloading functions should be used carefully.
You should try to design them so they follow common-sense rules.
That is, + should have something to do with addition; -, with subtraction; and so on.
The Cplus_plus I/O streams break this rule by defining the shift operators (<< and >>) as input and output operators.
This can lead to some confusion, such as: << 8 << 2; Does this output "8" followed by "2," or does it output the value of the expression (8 << 2).
Unless you're an expert you can't tell.
In this case the numbers "8" and "2" will be output.
You've seen how you can overload the + operator.
Now let's explore what other operators you can use.
Binary Arithmetic Operators Binary operators take two arguments, one on each side of the operator.
One of the parameters must be a class or structure.
We've had to define a lot of different functions just to support the addition of our complex class.
Such diarrhea of the definition is typical when overloading operators.
Table 18-1 lists the binary operators that can be overloaded.
Binary Operators That Can Be Overloaded Operator Meaning + Addition Subtraction *.
Right shift Relational Operators The relational operators include such things as  (==) and not  (_0_=).
Normally they take two constant classes and return either a 0 or a 1.
Table 18-2 Relational Operators Operator Meaning.
Greater than Page 324 Operator Meaning.
Greater than or equal to Unary operators Unary operators, such as negative (-), take a single parameter.
Table 18-3 Unary Operators Operator Meaning.
Ones complement Shortcut Operators Operators such  +=  -= are shortcuts for more complicated operators.
A very close examination  the Cplus_plus standard reveals that these operators return the value  the variable after the increase or decrease.
Note that unlike the other  functions we've defined, the first parameter is not a constant.
Also we, return a reference to the first , not a new  or a copy  the first parameter.
Page 325 Table 18-4 lists the shortcut operators.
Simple Shortcut Operators Operator Meaning.
Shift right Increment  Decrement Operators increment  decrement operators have two forms: prefix  suffix.
Cplus_plus language contains a hack to handle this case.
If we define plus_plus for the complex type to mean increment the  part, then our functions to handle the two forms  plus_plus are: // Prefix.
Cplus_plus has reduced us to using cute tricks: the unused integer parameter.
In actual practice, I never use the suffix version  increment  always put the prefix version on a line by itself.
That way, I can avoid most  these problems.
As you can see, the prefix version is much simpler than the suffix version.
So restricting yourself to the prefix version not only simplifies your code, but it also makes the compiler's job a little easier.
Table 18-5 lists the increment  decrement operators.
Table 18-5 Increment  Decrement operators Operator Meaning.
Decrement Logical Operators Logical operators include AND (&&), OR (||),  NOT (_0_).
They can be overloaded, but just because you can do it doesn't mean you should.
In theory, logical operators work only on Boolean values.
In practice, because Cplus_plus doesn't have a Boolean type, they work on integers.
Don't confuse the issue more by overloading them.
Table 18-6 lists the logical operators.
Table 18-6 Logical Operators Operation Meaning.
Logical NOT I/O Operators You've been using the operators <<  >> for input  output.
Actually these operators are overloaded versions  the shift operators.
This has the advantage  making I/O fairly simple, at the cost  some minor confusion.
We would like to be able to output our complex numbers just like any other data type.
To do this we need to define a <<  for it.
Page 327 We are sending our data to the output stream class ostream.
So our output function is:.
Normally the <<  takes two constant arguments.
In this case the first parameter  a non-constant ostream This  because the <<  when used for output has side effects, the major one being that the data goes to the output stream.
In general, however, it's not a good idea to add side effects to an operator that doesn't already have them.
Input should be just as simple as output.
You might think all we have to do  read the numbers (and the related extra characters): // Simple-minded input operation.
The function set  used to set a flag indicating that the input operation found a problem.
This allows the caller to test to see whether the input worked by calling the bad function.
See Chapter 22, Exceptions, for more We have reached the "(".
Let's read the  part of the number.
Page 329 Example 18-1.
The operator []  used by Cplus_plus to index arrays.
As we will see in Chapter 20, Advanced Pointers, this operator  very useful when defining a class that mimics an array.
Normally, this function takes two arguments, a class that simulates an array  an index,  returns a reference to an item in the array.
We cover the [] operator in more detail in Chapter 23, Modular Programming.
First of all, they aren't introduced until Chapter 20, Advanced Pointers, so you don't know what they do.
Second, when you know what they do, you won't want to override them.
I've seen only one program where the new  delete operators were overridden (or at least their C equivalents).
That program was written by a very clever programmer who liked to do everything a little strangely.
The result was code that was a nightmare to debug.
So unless you are a very clever programmer, leave new  delete alone.
And if you are a clever programmer, please leave new  delete alone anyway.
Some day I might have to debug your code.
Exotic Operators Cplus_plus contains a very rich set of operators.
These include: , Allows you to define a default function for a class.
Allows two expressions to be concatenated.
It  rarely used probably should not be overloaded.
All of these operators are discussed in Chapter 28, Cplus_plus's Dustier Corners.
Operator Member Functions So far we've been using  overloading functions just like ordinary functions.
They can also be defined as  functions.
The only difference  that as  functions the first argument, the class itself,  implied.
So, for example, you can write the  += as an ordinary function or as a  function.
Here's the ordinary version that you've already seen.
In most cases, you don't need to use this.
However, in a few, such   += , it comes in handy.
Which flavor of   overloading functions should you use.
The one that makes your program  clearest  easiest to read.
In general, we use  standard functions for simple operators, such  +, -, *,  /, while I use  functions for  shortcut  unary operators, such  +=, -=, plus_plus,  unary -.
Some overloaded functions only work   functions.
These include  casting operators  well  class specific versions of new  delete.
Casting Finally we come to  cast operators.
Casting  a way of changing one type to another.
For example, let's say that when we cast our complex type to a double, we want  real part.
We can define a cast  for this function : class complex: public: double  double() {return (realpart);} Cplus_plus automatically calls this function whenever it wants to turn a complex into a double.
The trouble is that by defining a cast, you give Cplus_plus something else that it can call behind your back.
Personally, I like to know whenever Cplus_plus calls something, so I avoid creating cast operators.
Unless you have a very good reason to define one, don't create a cast function.
Page 332 Full Definition of  Complex Class Example 18-2 lists  entire complex class.
The beginning of  header file summarizes all functions that are defined.
In creating this class I discovered that it consisted of many (29 to be exact) little one-  two-line functions.
Commenting each of these with a full-function comment block would obscure  code.
In other words, this is one of  few cases ( very few) where adding comments would cause confusion, so most of  small functions have no comments.
When creating this class, I noticed that a lot of  functions have a similar structure.
As a matter of fact, I created  -=  by copying  += functions  editing a little.
Cplus_plus contains a rich  set that causes this sort of repetition to happen when you're trying to define a complete set of operators for a class.
Finally,  simple operations are defined in  file complex_0_h while  longer functions are left in  file complex_0_cc.
Example 18-2 complex/complex_0_h , complex/complex_0_cc File: complex_0_h #ifndef _complex_h_ #define _complex_h__.
Copy constructor called Copy constructor called over and over.
Review the section "Copy Constructor" in Chapter 13.
Thanks to Jeff Hewett for th is problem.
Programming Exercises Exercise 18-1: Write a class to handle fractions such as "1/3_0_" Define addition, subtraction, multiplication, and division operators for these fractions.
Exercise 18-2: Write a fixed-point number class to handle numbers.
All numbers are of the form DDDDD_0_D.
In other words, all numbers have only a single digit to the right of the decimal point.
Use integers to implement  class.
Exercise 18-3: Write a class to implement a sparse integer array.
This is much like a simple integer array: int simple_array[100]; But unlike a simple array, the indices can go from 0 to 1,000,000.
That's the bad news.
The good news is that at most 100 elements will be set at any time.
The rest of the elements will be zero.
Exercise 18-4: Write a time class.
Implement functions to add, subtract, read, and print times.
Exercise 18-5: Write a date class that allows you to add, subtract, read, and print simple dates of the form MM/DD.
Assume year is not a leap year.
Page 342 Exercise 18-6: (Advanced) Write a full-date class that allows you to add, subtract, read, and print dates of the form MM/DD/YY.
Answers to Chapter Questions Answer 18-1: The copy constructor calls the  = function.
The parameter list to function is: trouble trouble:: = (trouble old_trouble) { The parameter to  function is being passed as a call-by-value parameter.
When Cplus_plus sees type of parameter it calls the copy constructor to put the parameter on the stack.
So we have an infinite loop The copy constructor calls the  = function.
Cplus_plus sees the call-by-value parameter and calls the copy constructor, which calls  = and causes the copy constructor to be called.
This keeps up until the system runs out of stack space or the user gets disgusted and aborts the program.
The solution is to pass the parameter to  = as a reference.
This not only is more efficient, but also works.
Floating-Point Format Floating Addition/Subtraction Multiplication Division Overflow and Underflow Roundoff Error Accuracy MinimizingRoundoff Error Determining Accuracy 1 is equal to 2 for sufficiently large values of 1.
The arithmetic is simple, exact, and fast.
Floating point is the opposite.
Computers do floating-point arithmetic only with great difficulty.
This chapter discusses some of the problems that can occur with floating point.
In order to address the principles involved in floating-point arithmetic, we have defined a simple decimal floating-point format.
We suggest you put aside your computer and work through these problems using pencil and paper so you can see firsthand the problems and pitfalls that occur.
The format used by computers is very similar to the one defined in  chapter, except that instead of using base 10, computers use base 2, 8, or 16.
However, all the problems demonstrated here on paper can occur in a computer.
Floating-Point Format Floating point numbers consist of three parts: a sign, a fraction, and an exponent.
Our fraction is expressed as a four-digit decimal.
The exponent is a single-decimal digit.
So our format is: ±f_0_fff x 10 ±e Page 344 where: ±i s the sign (plus or minus).
We represent these numbers in "E" format: ±f_0_fffE±e.
This format is similar to the floating-point format used in many computers.
The IEEE has defined a floating-point standard (#742), but not all machines use it.
Table 19-1 shows some typical floating-point numbers.
Floating-Point Examples Notation Number.
To minimize errors we make use of a guard digit.
That is an extra digit added to the end of the fraction during computation.
Many computers use a guard digit in their floating-point units.
Floating Addition/Subtraction To add two numbers like 2_0_0 and 0_0_3, the computer must perform the following steps: 1.
Start with the numbers.
Add guard digits to both numbers.
Shift the number with the smallest exponent to the right one digit and increment its exponent.
Continue until the exponents of the two numbers match.
Add the two fractions.
The result has the same exponent as the two numbers.
Normalize the number by shifting it left or right until there is just one nonzero digit to the left of the decimal point.
Adjust the exponent accordingly.
A number like +0_0_1234E+0 would be normalized to +1_0_2340E-1.
Because the number +2_0_3000E+0 is already normalized, we do nothing.
Finally, if the guard digit is greater than or equal to 5, round the next digit up.
Otherwise, truncate the number.
For floating-point subtraction, change the sign of the second operand and add.
Multiplication When we want to multiply two numbers such as 0_0_12  11_0_0, the following rules apply.
Add the guard digit.
The number is 11_0_0 +1_0_2000E-1 The number is 0_0_12.
Normalize the result.
If the guard digit is greater than or equal to 5, round the next digit up.
Otherwise, truncate the number.
The rules for multiplication are a lot shorter than those for add.
Integer multiplication is a lot slower than integer addition.
In floating point, multiplication speed is a lot closer to that of addition.
Page 346 Division To divide numbers like 100_0_0 by 30_0_0, we must perform the following steps.
Add the guard digit.
Divide the fractions, and subtract the exponents.
Normalize the result.
If the guard digit is less than or equal to 5, round the next digit up.
Otherwise, truncate the number.
What are the results of the following calculation.
This is an example of overflow (sometimes called exponent overflow).
Some computers generate a trap when this occurs, thus interrupting the program and causing an error message to be printed.
Others are not so nice and generate a wrong answer (like 8_0_100E+9).
Computers that follow the IEEE floating-point standard generate a special value called +Infinity.
Underflow occurs when the numbers become too small for the computer to handle.
Example: 1_0_OOOE-9  1_0_OOOE-9 The result is: 1_0_0  10-18 Because -18 is too small to fit into one digit, we have underflow.
Page 347 Roundoff Error Floating point is not exact.
Everyone knows that 1 + 1 is 2, but did you know that 1/3 + 1/3 _0_= 2/3.
This can be shown by the following floating-point calculations: 2/3 as floating point is 6_0_667E-1 1/3 as floating point is 3_0_333-1 +3_0_333E-1 +3_0_333E-1 +6_0_666E-1, or 0_0_6666 which is not: +6_0_667E-1 Every computer has a similar problem with its floating point.
For example, the number 0_0_2 has no exact representation in binary floating point.
Floating point should never be used for money.
Because we are used to dealing with dollars and cents, it is tempting to define the  $1_0_98 as: float  = 1_0_98; However, the more calculations you do with floating point, the bigger the roundoff error.
Banks, credit cards, and the IRS tend to be very fussy about money.
Giving the IRS a check that's almost right is not going to make them happy.
Money should be stored as an integer number of pennies.
Accuracy How many digits of the fraction are accurate.
At first glance you might be tempted to say all four digits.
Those of you who have read the previous section on roundoff error might be tempted to change your answer to three.
The answer is: The accuracy depends on the calculation.
Certain operations, such as subtracting two numbers that are close to each other, generate inexact results.
Consider the following equation: 1 - 1/3 - 1/3 - 1/3 1_0_000E+0 -3_0_333E-1 Page 348 -3_0_333E-1 -3_0_333E-1 or: 1_0_000E+0 -3_0_333E-1 -3_0_333E-1 -3_0_333E-1 0_0_0010E+0, or 1_0_000E-3 The correct answer is 0_0_000E+0 and we got 1_0_000E-3.
The very first digit of the fraction is wrong.
This is an example of the problem called roundoff error that can occur during floating-point operations.
Minimizing Roundoff Error There are many techniques for minimizing roundoff error.
Guard digits have already been discussed.
Another trick is to use double instead of float.
This gives you approximately twice the accuracy as well as twice the range.
It also pushes away the minimization problem twice as far.
But roundoff errors still can creep in.
Advanced techniques for limiting the problems caused by floating point can be found in books on numerical analysis.
They are beyond the scope of this text.
The purpose of this chapter is to give you some idea of what sort of problems can be encountered.
Floating point by its very nature is not exact.
People tend to think of computers as very accurate machines.
They can be, but they also can give wildly wrong results.
You should be aware of the places where errors can slip into your program.
Determining Accuracy There is a simple way of determining how accurate your floating point is (for simple calculations).
The method used in the following program is to add 1_0_0 + 0_0_1, 1_0_0 + 0_0_01, 1_0_0 + 0_0_001, and so on until the second  gets so small that it makes no difference in the result.
The old C language specified that all floating-point numbers were to be done in double.
Cplus_plus removed that restriction, but because many Cplus_plus compilers are Page 349 really front-ends to a C compiler, frequently Cplus_plus arithmetic is done in double.
This means that the expression: float 1, 2;.
Note the trick used to determine the accuracy of the floating-point numbers in storage.
Example 19-1 float/float_0_cc.
A more precise definition can be found in the standard  file float_0_h.
Precision and Speed A variable of type double has about twice the precision of a normal float variable.
Most people assume that double-precision arithmetic takes longer than single-precision.
Let's assume we have one of the older compilers that does everything in double.
For the equation: float , 1, 2; = 1 + 2; Cplus_plus must perform the following steps: 1.
Convert 1 from single to double precision 2.
Convert 2 from single to double precision 3.
Double-precision add 4.
Convert  into single precision and store in If the variables were of type double, Cplus_plus would only have to perform the steps: 1.
Double-precision add 2.
Store  in As you can see, the second form is a lot simpler, requiring three fewer conversions.
In some cases, converting a program from single precision to double precision makes it run faster.
NOTE Because Cplus_plus specifies that floating point can be done in double or float, you can't be sure of anything.
Changing all floats into doubles may make the program run faster, slower, or the same.
The only thing you can be sure of when using floating point is that the results are unpredictable.
Page 351 Many computers, including the PC and Sun/3 series machines, have a special chip called a floating-point processor that does all the floating-point arithmetic.
Actual tests using the Motorola 68881 floating-point chip (which is used in the Sun/3) as well as floating point on the PC show that single precision and double precision run at the same speed.
Power Series Many trigonometry functions are computed using a power series.
For example, the series for sine is:.
So, different angles require a different number of terms.
If they know ahead of time the number of terms to use, they can optimize their algorithms for that number of terms.
However, they lose accuracy for some angles.
So a compromise must be struck between speed and accuracy.
Don't assume that because the number came from the computer, it is accurate.
The library functions can generate bad answers—especially when working with excessively large or small values.
Most of the time you will not have any problems with these functions, but you should be aware of their limitations.
Finally, there is the question of what is (1,000,000).
Our floating-point format is good for only four digits.
The sine function is cyclical.
Because our floating-point format is good to only four digits, (1,000,000) is actually (1,000,000 mod 1,000).
Since 1,000 is bigger than 2 , the error renders meaningless the result of the sine.
Programming Exercises Exercise 19-1: Write a class that uses strings to represent floating-point numbers in the format used in this chapter.
The class should have functions to read, write, add, subtract, multiply, and divide floating-point numbers.
Page 353 I attended a physics class at Cal Tech taught by two professors.
One was giving a lecture on the sun when he said, "_0__0_.
Exercise 19-2: Create a class to handle fixed-point numbers.
A fixed-point number has a constant (fixed) number of digits to the right of the decimal point.
Page 355 20 Advanced Pointers In This Chapter:.
Pointers, Structures, and Classes delete Operator Linked List Ordered Linked Lists Double-linked List Trees Printing a Tree The Rest of the Program Data Structures for a Chess Program Programming Exercises Answers to Chapter Questions A race that binds Its body in chains and calls them Liberty, And calls each fresh link progress —Robert Buchanan One of the more useful and complex features of Cplus_plus is its use of pointers.
With pointers you can create complex data structures such as linked lists and trees.
Figure 20-1 illustrates some of these data structures.
Up to now all your data structures have been allocated by the compiler as either permanent or temporary variables.
With pointers you can create and allocate dynamic data structures, which can grow or shrink as needed.
In this chapter you will learn how to use some of the more common dynamic data structures.
Pointers, Structures, and Classes Structures and classes may contain pointers, or even a pointer to another instance of the same structure.
In the following example: class item {.
The operator new  storage for a variable and returns a pointer.
It is used to create new  out of thin air (actually out of an area of memory called the Page 356 Figure 20-1 Examples of pointer use Figure 20-2 Item.
The operator   a , unnamed variable and returns a pointer  it.
The "" created by   only be referenced through pointers, never by name.
In the following example, we use   allocate an  from the heap.
The variable will point  our.
The operator   a single argument: the type of the item  be allocated.
According the latest Cplus_plus standard, if   out of memory it should throw an exception and abort the program.
Suppose we are working on a complex database that contains (among other ) a mailing list.
We want  keep our storage use  a minimum, so we only want  allocate memory for a person if he or she exists.
Creating an array of class person would allocate the data statically and use up too much space.
So we will allocate space as needed.
Our structure for a person is: class person { public: char char char float.
Name of the Where he lives Part 2 of address His age His height in inches We want  allocate space for this.
Later the pointer  this record will be put in the database.
Example 20-1 storage for a character array 80 bytes long ('\0' included).
The variable points  this storage.
All we've done is substitute a simple type (such as ) with an array specification ([80]).
To return the memory  the heap you use the.
NOTE The reason there are two forms of the delete  is because there is no way for Cplus_plus  tell the difference between a   an object and a   an array of objects.
The delete relies on the programmer using "[]"  tell the two apart.
Strictly speaking, the line: = NULL; is unnecessary.
However, it is a good idea  "null out" pointers after they are deleted.
That way, you don't try use a   deleted memory, and also you help prevent any attempts delete the same memory twice.
The other problem that  occur is using memory that has been freed.
When delete is used, the memory is returned  the memory pool and  be reused.
Using a  after a delete call is similar  an array index out-of-bounds error.
You are using memory that belongs someone else.
This  cause unexpected results or program crashes.
Linked List Suppose you are writing a program  send a list of names  another computer using a communications line.
The  types in the names during the day, and then after work you dial up the other computer and send the names.
The problem is, you don't know ahead of time how many names are going  be typed.
By using a linked-list data structure, you  create a list of names that  grow as more names are entered.
With a linked list you  also easily insert names into the middle of the list (which would be slow and difficult with an array).
Also, as you will see later, linked lists  be combined with other data structures  handle extremely complex data.
A linked list is a chain of items where each item points  the next item in the chain.
Think about the treasure hunt games you played when you were a kid.
You were given a note that said, "Look in the mailbox_0_" You raced  the mailbox and found the next clue, "Look in the big tree in the back yard," and so on until you found your treasure (or you got lost).
In a treasure hunt each clue points  the next one.
Figure 20-3 graphically illustrates a linked list.
The variable  points  the first  of the list.
In the beginning, before we insert any elements into the list (it is empty), this variable is initialized  NULL.
Figure 20-4 illustrates how a    be added  the beginning of a linked list.
Now all we have  do is translate this into Cplus_plus code.
To do this in Cplus_plus, we execute the following steps: 1.
Create the item we are going  add.
Example 20-2 contains the find function.
Question 20-1: Why does running this program sometimes result in a bus error.
Other times it will report "found" (return 1)for an item that is not in the list.
In our find program we had  use the cumbersome notation (*current ptr) access the  field of the structure.
Cplus_plus provides a shorthand for this construct using the arrow_operator operator.
The dot (_0_) operator means the field of a structure, and the structure pointer operator (arrow_operator) indicates the field of a structure pointer.
The following two expressions are equivalent: (*currentptr).
So far we have only added new  to the head of a linked list.
Suppose we want to add in order.
Figure 20-5 is an example of an ordered linked list.
Page 363 Figure 20-5 Ordered list Figure 20-6 shows the steps necessary to add a new , "53," to the list.
The following member function implements this algorithm.
The first step is to locate the insertion point.
The  points to the first  of the list.
The program moves the variable before_ptr along the list until it finds the proper place for the insertion.
The variable after_ptr is set to point to the previous value.
The new  will be inserted between these.
Adding  "53" to an ordered list Now we know where to insert the new.
This  should point to the new , so: = ; Page 365.
This is accomplished with the code: = ;.
Double-linked List A double-linked list contains two links.
One link points forward to the next ; the other points backward to the previous.
Double-linked lists are useful where the program needs to go through the list both forward and backward.
The classes for a double-linked list are: class double_list { private:.
Page 366 Figure 20-7 Double-linked list * * * */ care of the case where the  is inserted at the head of the list or the end of the list.
Double-linked list insert, part #1 The links are set up for the new.
Now all we have to do is break the old links between items 11 and 36 and connect them to the new  (27).
Getting to  11 is a bit of a trick.
We only have a pointer to  36 ().
However, if we follow the previous link back (), we get the  (11) that we want.
Now all we have to do is fix the next_ptr for this.
The Cplus_plus code for this is surprisingly simple: = ; Visually we can see this operation in Figure 20-9.
The new 's previous pointer: = ;.
Trees Suppose we want to create an alphabetized list of the words that appear in a file.
We could use a linked list, but searching a linked list is slow because we must check each  until we find the correct insertion point.
By using a  type called a tree, we can reduce the number of comparisons tremendously.
A binary tree structure looks like Figure 20-12.
Each box is called a node of the tree.
The box at the top is the root and the boxes at the bottom are the leaves_0_* Each node contains two pointers: a left pointer and a right pointer, which point to the left and right subtrees.
Page 369 Figure 20-10.
Double-linked list insert, part 3.
Trees are often used for storing a symbol table (a list of variables used in a program).
In this chapter we will use a tree to store a list of words and then to * Programming trees are written with the  at the top and the leaves at the bottom Common sense tells you that this is upside down In case you haven't noticed, common sense has very little to do with programming Page 370.
Tree print the list alphabetically.
The advantage of a tree over a linked list is that searching a tree takes considerably less time.
Page 371 In this example, each node stores a single word.
The left subtree stores all the words less than the current word, and the right subtree stores all the words greater than the current word.
For example, Figure 20-13 shows how we descend the tree to look for the word "orange_0_" We would start at the , "lemon_0_" Because "orange" > "lemon," we would descend the right link Figure 20-13.
Tree search Recursion is extremely useful with trees.
Our rules for recursion are 1) the function must make things simpler and 2) there must be some endpoint.
The algorithm for inserting a word in a tree is: 1.
If this is a null tree (or subtree), create a one-node tree with this word.
If this node contains the word, do nothing.
Otherwise, enter the word in the left or right subtree, depending on the value of the word.
Does this algorithm satisfy our recursion rules.
The  has two definite endpoints: 1.
A match is found.
Otherwise, we enter the word into a subtree (which is simpler than the whole tree).
Page 372 To see how this works, consider what happens when we insert the word "fig" into the tree.
First we check the word "fig" against "lemon_0_" "Fig" is smaller, so we go to "apple_0_" Because "fig" is bigger, we go to "grape_0_" Because "fig" is smaller than "grape," we try the left link.
It is NULL, so we create a new.
This code makes use of a new : strdup.
This  creates a copy of a  on the heap and returns a pointer to the new.
The  may later be returned to the heap using the delete operator_0_* The  to enter a value into a tree is:.
This  passes a pointer to the  of the tree to enter_one.
If the  is NULL, enter_one creates the.
Because we are changing the value of a pointer, we must pass a reference to the pointer.
It is, however, available in all the compilers l've seen It appears to be part of an unwritten standard Page 373 Printing a Tree Despite the complex nature of a tree structure, it is easy to print.
The printing algorithm is: 1.
For the null tree, print nothing.
Print the data that comes before this  (left tree).
Print the data that comes after this  (right tree).
The code for printing the tree is:.
The Rest of the Program Now that we have the data structure defined, all we need to complete the program is a few more functions.
The main  checks for the correct number of arguments and then calls the scanner and the print_one routine.
The scan  reads the file and breaks it into words.
It uses the standard macro isalpha.
The macro returns 1 if its argument is a letter and 0 otherwise.
It is defined in the standard include file ctype_0_h.
After a word is found, the  enter is called to put the word in the tree.
Example 20-3 is the listing of words_0_cc.
Question 20-2: I once made a program that read the dictionary into memory using a tree structure and then used it in a program that searched for misspelled words.
Although trees are supposed to befast, this program was so slow you would think I used a linked list.
Hint: Graphically construct a tree using the words "able, " "baker," "cook, " "delta," and "easy" and look at the.
Page 377 Data Structures for a Chess Program A classic problem in artificial intelligence is the game of chess.
So far, in spite of all our advances in computer science, no one has been able to create a program that plays chess better than the best grand masters.
We are going to design a data structure for a chess-playing program.
In chess there are several moves you can make.
Your opponent has many responses, to which you have many answers, and so on back and forth for several levels of moves.
Our data structure is beginning to look like a tree.
But this is not a binary tree, because we have more than two branches for each  (Figure 20-14).
The problem is that the number of moves from any given position varies dramatically.
For example, in the beginning you have lots of pieces running around_0_* * Trivia question.
What are the 21 moves you can make in chess from the starting position.
Page 378 Things like rooks, queens, and bishops can move any number of squares in a straight line.
When you reach the end game (in an evenly matched game), each side probably has only a few pawns and one major piece.
The number of possible moves has been greatly reduced.
We want to be as efficient in our storage as possible because a chess program stresses the limits of our machine.
We can reduce storage requirements by changing the next-move array into a linked list.
The resulting structure is:.
Graphically, this looks like Figure 20-15.
The new  adds a little complexity, but saves a great deal of storage.
Programming Exercises Exercise 20-1: Write a cross-reference program.
Exercise 20-2: Write a function to delete an element of a linked list.
Exercise 20-3: Write a function to delete an element of a double-linked list.
Page 379 Exercise 20-4: Write a function to delete an element of a tree.
Answers to Chapter Questions Answer 20-1: The problem is with the statement: while (( _0_= value) && is checked before we check to see whether  is a valid  (_0_= NULL).
If it is NULL we can easily check a random memory location that could contain anything.
The solution is to check  before checking what it is pointing to: while ( _0_= NULL) { break; Answer 20-2: The problem was as follows: because the first  in the dictionary was the smallest, every other  used the right-hand link.
In fact, because the entire list was ordered, only the right-hand link was used.
Although this was defined as a tree structure, the  was a linked list.
See Figure 20-16.
Figure 20-16 Dictionary tree Page 380 Some of the  advanced books on data structures, such as Wirth's Algorithms + Data = Programs, discuss ways of preventing this by balancing a binary tree.
Trivia Answer: You give up.
That's right, the 21st move is to resign.
Page 381 21 Advanced Classes In This Chapter:.
Derived Classes Virtual Functions Virtual Classes Function Hiding in Derived Classes Constructors and Destructors in Derived Classes Summary Programming Exercises Answers to Chapter Questions Questions The ruling ideas of each age have ever been the ideas of its ruling class —Karl Marx Manifesto of the Communist Party Derived Classes The  class that was defined in Example 13-1 contains one major limitation: it does not check for bad data.
For example, there is nothing that prevents the user from pushing too many things onto the.
We need to define a new -checking  (b_stack).
This new  does everything a simple  does but also includes  checking.
Cplus_plus allows you to build new  on old ones.
In this case we will be building our -checking  (b_stack) on the existing simple  ().
Technically we will be using the class  as a base class to create a new  class, the -checking.
We start by telling Cplus_plus that we are creating b_stack out of.
The keyword public tells Cplus_plus to make all the members of  accessible to the outside world.
If we declared  as private then the public and protected members of would be accessible only inside b_stack.
This declaration tells Cplus_plus that we are going to use  as a base for b_stack.
Figure 21-1 shows how Cplus_plus views this combination.
Now we need to define the new  of the push member function.
We first check to see whether there's room in the.
If there's no  room, we print Page 382 Figure 21-1 Derived class h_stack and base class.
The result is that we call b_stack's push, which performs a limit check and then calls push.
This push belongs to b_stack, so we perform a  check and call push, and so on.
The result is that push will call itself over and over until the system runs out of space.
This is not want we want.
We want to tell Cplus_plus that we want to call the push in.
This can be accomplished by using the scope operator "::".
The new  of b_stack::push looks like:.
The full definition for both the  and b_stack  is shown in Example 21-1.
Even though these two classes are relatively simple, they illustrate some important features of the Cplus_plus language.
First we have declared  as a protected member variable.
This means that this variable can be used only within the class stack and in any classes derived from stack, such as b_stack.
The b_stack functions push and pop can use  to do their work.
However, anyone outside of stack and b_stack cannot use the variable.
Because b_stack is derived from stack, you can use a b_stack type variable wherever a stack type variable is used.
In the following example, we create a b_stack named bound_stack that is used as a parameter to the function push_things, which takes a normal, unbounded stack as a parameter.
The function push_things takes a  as a parameter.
Even though the variable bounded_stack is a b_stack type variable, Cplus_plus turns it into a  when push_things is called.
One way to explain this is that although bounded_stack is of type b_stack, when it is used by push_things the function is looking through a peephole that allows it to see only the  part of the variable as shown in Figure 21-2.
Figure 21-2 How "push_things" sees a b_stack Let's improve the basic  so that instead of always allocating a fixed-size , we allocate the  dynamically.
The new  starts with: class  { private: *; // Pointer to the  in the protected: ; // Current item on the public:.
To use the new  we must give it a size when we declare the.
Page 387 The way we do this is to put the base-constructor unitization just after the declaration of the constructor for the derived class: But this flexibility creates some problems for the bound-checking : the constructor for contains a parameter.
How is the bound-checking  to initialize the simple.
The solution is to use a syntax similar to initializing a constant  member.
NOTE Because the new  of  uses dynamic memory (new and delete), it is vital that we define the "big four" member functions: the constructor, the destructor, the copy constructor, and the assignment  (=).
Virtual Functions Today there are many different ways of sending a letter.
We can mail it by the United States Postal Service, send it via Federal Express, send it Certified Mail, or even fax it.
All of these methods get the letter to the person (most of the time), but they differ in cost and speed.
Let's define a class to handle the sending of a letter.
We start by defining an address class and then use this class to define addresses for the sender and the receiver.
There is, however, one little problem with this class.
We're depending on "magic" to get our letters sent.
The process for sending a letter is different depending on which service we are using.
One way to handle this is to have send_it call the appropriate routine depending on what service we are using:.
This solution is a bit clunky.
Our mail class must know about all the mailing services in the world.
Also consider what happens when we add another function to the class: class mail { public:.
Do we create another big switch statement.
If we do, we'll have two big switch statements to worry about.
What's worse, the sending instructions and cost for each service are now spread out over two functions.
It would be nice if we could group all the functions for the Postal Service in one class, all of Federal Express in one class, and so on.
For example, a class for the Postal Service might be:.
The trouble is that letter is a mail class, so when we call letter_0_send() we call the send of the base class mail.
What we need is a way of telling Cplus_plus, "Please call the send Member Function Type.
Derivedarrow_operatorbase Example 21-2 illustrates the use of virtual functions.
Page 391 However, the derived class doesn't contain a member function named c.
So when we reach the line: a_derived_0_c(); Cplus_plus tries  find c in the derived class and fails.
Then it tries  find the member function in the base class.
In this case it succeeds and we get: base::c called Now let's move on  the function do_base.
Because it takes a base class as its arguments, Cplus_plus restricts its search for member functions  the base class.
So the line: a_base_0_a(); outputs base::a called But what happens when the member function b is called.
That tells Cplus_plus that the search rules are changed.
Cplus_plus first checks whether there is a b member function in the derived class, and then Cplus_plus checks the base class.
In the case of b, there is a b in the derived class, so the line: a_base_0_b(); outputs: derived::b called The member function c is also a virtual function.
Therefore, Cplus_plus starts by looking for the function in the derived class.
In this case it's not defined there, so Cplus_plus then looks in the base class.
It is defined there, so we get: base::c called Now getting back  our mail.
We need a simple base class that describes the basic mailing functions for each different type of service.
Now we can write a routine  send a letter and not have  worry about the details.
All we have  do is call send_it and let the virtual function do the work.
The mail class is an abstraction that describes a generalized mailer.
To associate a real mailing service, we need  use it as the base for a derived class.
But what happens if the programmer forgets  put the right member functions in the derived class.
For example: class federal_express: public mail {.
When we try  find the cost of sending a letter via Federal Express, Cplus_plus will notice that there's no cost function in federal_express and call the one in mail.
The cost function in mail knows that it should never be called, so it spits out an error message and aborts the program.
Getting an error message is nice, but getting it at compilation rather than during the run would be better.
Cplus_plus allows you  specify virtual functions that must be overridden in a derived class.
For this example, the , , abstract mailer is: class mail { public:.
That is, they can never be called directly.
Any class containing one or more pure virtual functions is called an abstract class.
If you tried  use an abstract class as an ordinary type, such as: mail a_mailer;.
Virtual Classes Let's design some classes  handle a tax form.
In the upper right corner of each form is a blank for your name, address, and Social Security number.
All the forms contain this same information, so we'll define a class for this corer of the form.
For deductions we need Schedule A, so let's define a class for it.
Tax return structure problem with this structure is that we have two name classes.
But the taxpayer's name doesn't change from one form to another.
What we want is the class structure shown in Figure 21-5.
Better tax return structure Declaring a base class virtual tells Cplus_plus to combine common base classes.
Redefining tax_return using virtual base classes we get:.
Notice that the class name is used as the base for two derived classes; derived classes cause their base class's constructor to be called to initialize the class.
Does this mean that the constructor for name will be called twice.
Cplus_plus is smart enough to know that name is used twice and to ignore the second initialization.
Function Hiding in Derived Classes Example 21-3 defines a base class with the overloaded function do_it, which comes in both an integer version and a floating-point version.
Clearly, when we are using the derived class and we call the integer version of do_it, we are calling the one in the derived class.
But what happens if we call the floating-point version.
Normally, if we don't have a member function in the derived class, Cplus_plus will look to the base class.
However, since a version of do_it is defined in the derived class, Cplus_plus will look to the derived class for all flavors of do_it.
In other words, if one form of do_it is defined in the derived class, then that locks out all forms of the function.
Constructors and Destructors in Derived Classes Constructors and destructors behave differently from normal member functions especially when used with derived classes.
When a derived-class variable is created, the constructor for the base class is called first, followed by the constructor for the derived class.
Example 21-4 defines a simple base class and uses it to create a derived class.
Example 21-4 cons/class cc # <iostream_0_h>.
So when we destroy the variable.
You see,  is a pointer to a base class.
At this point all the code can see is the base class.
There is no way for Cplus_plus to know that there is a derived class out there.
So when the variable is deleted, Cplus_plus fails to call the derived class destructor.
We need some way to tell Cplus_plus, "Hey, there is a derived class out there and you might want to call its destructor_0_"  way we do this is to make the destructor for the base class a virtual function.
When Cplus_plus sees a virtual destructor, it will call the destructor of the derived class and then call the destructor of the base class.
So with the virtual destructor in place, we can safely delete the base_class variable and the program will output the proper information: destructor called base_class destructor called Question 21-1: Why does Example 21-5 fail when we delete the variable list_ptr program seems to get upset when it tries to call clear at line 20.
Page 398 Example 21-5.
Summary Since programming began, programmers have been trying to find ways of building re-usable code.
Cplus_plus, through the use of derived classes, allows you to Page 399 build classes on top of existing code.
This provides a great deal of flexibility and makes the code easier to organize and maintain.
Programming Exercises Exercise 21-1: Combine the checkbook class of Exercise 13-2 with the queue class of Exercise 13-3 to implement a checkbook class that can print out the last ten entries of your checkbook.
Exercise 21-2: Define a "string-match" base class.
Define derived classes that match words, numbers, and blank strings.
Exercise 21-3: Define a base class shape that can describe any simple shape such as a square, circle or equilateral triangle.
The size of all these shapes can be reduced to a single dimension.
Define derived classes for each of the three shapes.
Create a virtual function in the base class that returns the area of each shape.
Note: You will need to more precisely define what dimensions are stored in the base class.
Define two derived classes called man and woman that define gender specific items.
Write pure virtual functions in the base class for operations that are common to both sexes yet are handled in different ways by each of them.
Exercise 21-5: Write a base class number that holds a single integer value and contains one member function, print_it.
Define three derived classes to print the value in hex, octal, and decimal.
Answers to Chapter Questions Answer 21-1: Remember that destructors are called in the order of derived class first and then base class.
In this case, the destructor for the derived class, , is called to destroy the class.
Next, the destructor for the base class list is called.
It calls the function.
This a pure virtual function, so Cplus_plus must call the  function in the derived class.
This Page 400 makes Cplus_plus very upset and it aborts the program.
Page 401 V Other Language Features Page 403 22 Exceptions In This Chapter:.
Stack Exceptions Runtime Library Exceptions Programming Exercises How glorious it is — and also how painful— to be an exception —Alfred de Musset Airplanes fly from one place to another and 99_0_9% of the time there's no trouble.
But when there is trouble such as a stuck wheel or an engine fire, pilots are trained to handle the emergency.
Let's examine in detail what happens during an airborne emergency such as an engine catching fire.
This is an exception to normal flight.
A fire alarm goes off in the cockpit.
This catches the pilots' attention and they start going through the fire-emergency procedure.
This is an extensive list of things to do in case of fire.
The airline prepared this list ahead of time and the pilots have the list memorized.
The pilots do what's necessary to handle the exception: activate the fire extinguisher, shut down the engine, land very quickly, etc.
Let's break down this procedure into Cplus_plus pseudocode.
When the pilots take off they are going to try to fly the plane from one point to another without problems.
Page 404 But what happens when we get an exception.
We need to handle it.
This is the type of emergency.
It could be a fire in engine number 1, engine number 2, or engine number 3 (assuming a three-engine plane).
Which engine is on fire is stored in the variable fire_info.
The fire_emergency class describes what type of fire occurred.
Its definition is: class fire_emergency { public: int engine;.
Buried within each  is a.
When this code senses a fire, it puts the information in a fire_emergency variable named fire_info and triggers an exception with the throw statement.
When the throw statement is executed, normal processing is stopped.
After all, when a fire occurs, normal flying is stopped.
Execution is transferred to the catch statement for the fire_emergency.
To summarize, exception handling consists of:.
A description of a possible problem, in this case the fire_emergency class.
In this case, the statement is fly_from_point_atopoint b().
Something that causes an exception and triggers the emergency procedures through a throw statement.
Exception-handling code inside a catch block.
Stack Exceptions In Chapter 21, Advanced Classes, we defined a stack with bounds checking.
If the user attempted to push too much data on the stack or to pop too much off, the class would issue an error message and abort.
This is not a good way to handle an exception.
Think of how the pilots would feel if the plane displayed an error message and shut down every time there was a fire.
The first thing we need to do is decide what type of exceptions we are going to handle and describe them as classes.
In our stack example, the only exception we expect is an out-of-bounds error.
We'll describe this error with a simple string.
The class for an out-of-bounds error is: const int  = 80;.
Exception checking starts with the keyword try.
This tells Cplus_plus that exceptions may be generated in the section of code that follows and that they will be handled immediately after the try block.
For example, if we are trying to perform a big stack operation, the code might look like:.
Several catch statements may be used to catch different types of exceptions.
If an exception is not caught, it is considered an unexpected exception and will cause a call to the unexpected-exception handler, which aborts the program by default.
If you want to catch all exceptions, use "_0__0__0_" for the exception type.
Body of catch.
The basic function definition we've been using so far tells Cplus_plus, "Expect any exception to be thrown at any time_0_" The push function can only throw a bound_err exception.
Cplus_plus allows you to list all the possible exceptions in a function by putting a throw directive at the end of the function declaration: inline void b_stack::push(const int item) throw(bound_err) { Page 407 But  happens if we throw an exception that's not in the list of exceptions.
Cplus_plus will turn this into a call to the function unexpected().
Example 22-1 contains a new  of the bound-checking stack with exceptions.
Runtime Library Exceptions exception-handling mechanism is relatively.
However, these "standard" exceptions are so   are still being refined and updated.
There are lots of details still to be worked out.
Compiler makers need time to catch up to the standard.
At the time of this writing, the currently available Cplus_plus compilers generate few if any exceptions in their runtime library, and none generates "standard" exceptions.
This situation will change as the ANSI standard gets better defined and compilers improve.
About the best advice I can give you is to read your compiler's reference manual and watch out.
Programming Exercises Exercise 22-1: Add code to the queue class of Exercise 13-3 that will trigger an exception when too many items are put in the queue.
Exercise 22-2: Take the fraction class from Exercise 18-3 and add code to generate an exception when a divide by zero occurs.
Also add code to generate an exception when a bad number is read.
Exercise 22-3: Update the checkbook class of Exercise 13-2 so it generates an exception when your balance goes below zero.
Page 411 Exercise 22-4: Write a function count_letter that takes a single character.
This function will  the number of consonants and vowels.
If a nonletter is given to the function, it generates an exception.
Page 413 23 Modular Programming In This Chapter:.
Modules Public and Private extern Modifier Headers Body of the Module A Program to Use Infinite Arrays Makefile for Multiple Files Using the Infinite Array Many, hands make light work.
As programs grow larger and larger, should be split into sections, or modules.
Cplus_plus allows programs to be split into multiple files, compiled separately, and then combined (linked) to form a single program.
In this chapter, we go through a programming example, discussing the Cplus_plus techniques needed to create good modules.
You also are shown how to use make to put these modules together to form a program.
Modules A module is a collection of functions or classes that perform related functions.
For example, there could be a module to handle database functions such as lookup, enter, and sort.
Another module could handle complex numbers, and so on.
Also, as programming problems get big, more and more programmers are needed to finish them.
An efficient way of splitting up a large project is to assign each programmer a different module.
That way each programmer only has to worry about the internal details of his or her own code.
In this chapter, we discuss a module to handle infinite arrays.
Page 414 Public and Private Modules are divided into two parts, public and private.
In the infinite array example, we have put the public declarations in the file ia_0_h (see listing on page 417).
Anything internal to the module is private.
Everything that is not directly usable by the outside world should be kept private.
Example 23-1 illustrates a simple use of the extern modifier.
Actually, three modifiers can be used to indicate the files in which a variable  defined, as shown in Table 23-1.
For a complete list of the meanings of static see Table 14-1_0_) For data defined globally, static means "private to this file_0_" For data defined inside a function, it Cplus_plus  very liberal in its use of the rules for static, extern, and <blank> modifiers.
It possible to declare a variable as extern at the beginning of a program and later define it as <blank>.
This ability  useful when you have all your external variables defined in a header file.
The program includes the header file (and defines the variables as extern), and then defines the variable for real.
Another problem concerns declaring a variable in two different files.
The compiler could very carefully analyze both programs, and then pick out the value that most likely to be wrong.
In this case, there  only one global variable called.
It will be initialized to either 1 or 0 depending on the whims of the compiler.
It  entirely possible for the program main to print out: 1 even though we initialized it to zero.
To avoid the problem of hidden initializations, use the keyword static to limit the scope of variables to the file in which they are declared.
If we had written: File: main_0_cc static int.
Headers Information that  shared between modules should be put in a header file.
By convention, all header filenames end with "_0_h".
In the infinite array example, we use the file ia_0_h.
The header should contain all the public information, such as:.
A comment section describing clearly what the module does and what  available to the user.
Public structures Page 417.
This commenting  not excessive; the real guts of the coding  hidden in the program file ia_0_cc.
The ia_0_h file serves both as a program file and as documentation to the outside world.
Notice that there  no mention in the ia_0_h comments about how the infinite array implemented.
At this level, we don't care how something  done.
Adding more elements to the array * * will just cause it to grow.
Any code that  defined  inline.
No actual code or storage  defined in the header file.
The Body of the Module The body of the module contains all the functions and data for that module.
Private functions that are not to be called from outside the module should be declared static.
Variables declared outside of a function that are not used outside the module are declared static.
A Program to Use Infinite Arrays The infinite array module (ia_0_cc)  shown in Figure 23-1.
The program uses a simple linked list to store the elements of the array.
A linked list can grow longer as needed (until you run out of memory).
Each list element, or bucket, can store 10 numbers.
To find element 38, the program starts at the beginning, skips past the first three buckets, and then extracts element 8 from the data in the current bucket.
Infinite array structure Page 419 Example 23-3 contains the code for module ia_0_cc.
The Makefile for Multiple Files The utility make is designed to aid the programmer in compiling and linking programs.
Before make, the user had to explicitly type compile commands each time there was a change in the program: gplus_plus -Wall -g -ohello hello_0_cc NOTE In this chapter we use the commands for the GNU gplus_plus compiler.
The Cplus_plus compiler on your system may have a different name and a slightly different syntax.
As programs grow, the number of commands needed to create them grows.
Typing in a series of 10 or 20 commands is tiresome and error-prone, so programmers started writing shell scripts (or, in MS-DOS,_0_BAT files).
Then all the programmer had to type was do-it and the computer would compile everything.
This was overkill, however, because all the files were recompiled regardless of need.
As the number of files in a project grew, this recompiling became a significant problem.
Changing one small file, starting the compilation, and then having to wait until the  day while the computer executed several hundred compile commands was frustrating—especially when only one compile was really needed.
The program make was created to do intelligent compiles.
Its purpose is to first decide what commands need to be executed and then execute them.
The file Makefile (upper/lowercase is important in UNIX) contains the rules used by make to decide how to build the program.
The Makefile contains the following sections: Page 421.
Default rules Any line beginning with a # is a comment.
A macro has the format: = data Name is any valid identifier.
Data is the text that will be substituted whenever make sees $().
Example: # # Very simple Makefile # = Doing All all: Explicit rules tell make what commands are needed to create the program.
These rules can take several forms.
The most common is: target: source [source2] [source3] command [command] [command].
Target is the  of a file to create.
It is "made," or created, out of the source file source.
If the target is created out of several files, they are all listed.
The command used to create the target is listed on the  line.
Sometimes it takes more than one command to create the target.
Commands are listed one per line.
Each is indented by a tab.
For example, the rule: hello: hello_0_cc gplus_plus -Wall -g -o hello hello_0_cc tells make to create the file hello from the file hello_0_cc using the command: gplus_plus -Wall -g -o hello hello_0_cc Page 422 Make will create hello only if necessary.
The files used in the creation of hello, arranged in chronological order (by modification times), are shown in Table 23-2.
Table 23-2 File Modification Times UNIX MS-DOS/Windows.
Newest If the programmer changes the source file hello_0_cc, the file's modification time will be out of date with respect to the other files.
Another form of the explicit rule is: source: command [command] In this case, the commands are executed each time make is run, unconditionally.
If the commands are omitted from an explicit rule, make uses a set of built-in rules to determine what command to execute.
For example, the rule: hist_0_o: ia_0_h hist_0_cc tells make to create hist_0_o from hist_0_cc and ia_0_h, using the standard rule for making <file>_0_o.
Both files include the header ia_0_h, so they depend on it.
The UNIX Makefile that creates the program hist from hist_0_cc and ia_0_cc is listed in Example 23-4.
Example 23-4 ia/Makefile # Make file = -g = ia_0_cc = ia_0_o needs debugging -Wall hist_0_cc hist_0_o.
If any of the object files are out of date, make will re-create them.
The line: hist_0_o:ia_0_h tells make to create hist_0_o from ia_0_h and hist_0_cc (hist_0_cc is implied).
Because no command is specified, the default is used.
Example 23-5 shows the Makefile for MS-DOS/Windows, using Turbo-Cplus_plus.
There is one big drawback with make.
It only checks to see whether the files have changed, not the rules.
If you have compiled all your program with =-g for debugging and need to produce the production version ( = -0), make will not recompile.
The command touch changes the modification date of a file.
This is useful if you have changed the compile-time flags and want to force a re-compilation.
Make provides a rich set of commands for creating programs.
Only a few have been discussed here_0_* Using the Infinite Array The histogram program (hist) is designed to use the infinite array package.
It takes one file as its argument.
The file contains a list of numbers between 0 and 99.
Any number of entries may be used.
The program prints a histogram showing how many times each number appears.
The first one is: Let the computer do the work whenever possible.
For example, don't program like this:.
Also, the computer is more accurate in its computations.
In the hist program, if the user does not type the correct number of parameters on the command line, a message appears telling what is wrong and how to correct it.
The program uses the library routine memset to initialize the counters array.
This routine is highly efficient for setting all values of an array to zero.
The line: memset(counters, '\0', sizeof(counters)); zeros the entire array counters.
Example 23-6 contains a program that uses the infinite array for storing data used to produce a histogram.
A sample run of this program produces: % test 0: 0- 2 ( 100): ************************ 1: 2- 4 ( 200): ************************************************ 2: 4- 6 ( 100): ************************ 3: 6- 8 ( 100): ************************ 29: 30: 31: 32: 33: 34: 35: 36: 37: 38: 59616365676971737577 61 63 65 67 69 71 73 75 77 79 50): 50): 150): 100): 0): 199): 200): 100): 50): 100): ************ ************ *********************************** ************************ ********************************************** ************************************************ ************************ ************ ************************ Page 429 39: 40: 41: 42: 43: 44: 45: 46: 47: 48: 49: 500 79- 81 ( 100): ************************ 81- 83 ( 200): *************************************** 83- 85 ( 100): ************************ Dividing a Task into Modules Unfortunately, computer programming is more of an art than a science.
There are no hard and fast rules that tell you how to divide a task into modules.
Knowing what makes a good module and what doesn't comes with experience and practice.
This section describes some general rules for module division and how they can be applied to real-world programs.
The techniques described here have worked well for me.
Information is a vital part of any program.
The key to a program is your decision about what information you want to use and what processing you want to perform on it.
Be sure to analyze the information flow before you begin the design.
Design the modules to minimize the amount of information that has to pass between them.
If you look at the organization of the Army, you'll see that it is divided up into modules.
There is the infantry, artillery, tank corps, and so on.
The amount of information that passes between these modules is minimized.
For example, if an infantry sergeant wants the artillery to bombard an enemy position, he calls up artillery command and says, "There's a pillbox at location Y-94.
Get rid of it_0_" The artillery command handles all the details of deciding which battery to use, how much firepower to allocate based on the requirements of other fire missions, maintaining supplies, and many more details_0_* Programs should be organized the same way.
Information that can be kept inside a module should be.
Minimizing the amount of intermodule communication cuts down on communication errors as well as limiting maintenance problems that occur when a module is upgraded.
It is a program that allows the user to display and change text files.
The main piece of information is the text file we are editing.
Most editors are display oriented and continually display about 24 lines of the current file on the screen.
Finally, one more piece of information is needed: the editing commands.
The commands are typed in by the user.
This information must be parsed so the computer can understand it.
The individual commands are small and perform similar functions (delete line is very much like delete character).
Imposing a standard structure on the command execution modules improves readability and reliability.
A block diagram of the editor can be seen in Figure 23-2.
Module division of the text editor There is minimal communication between the modules.
The display section needs to know only two things: 1) where the cursor is and 2) what the file currently looks like.
All the file module needs to do is read the file, write the file, and keep track of changes.
Even the way the changes are made can be minimized.
All Page 431 editing commands, no matter how complex, can be broken down into a series of inserts and deletes.
It is the responsibility of the command module to take the complex user commands and turn them into simple inserts and deletes that the file handler can process.
Information passing between the modules is minimal.
No information passes between the command decoder and the display module.
A word processor is just a fancy text editor.
Where a simple editor only has to worry about ASCII characters (one font, one size), a word processor must be able to handle many different sizes and shapes.
Compiler Construction In a compiler, the information being processed is Cplus_plus code.
The job of the compiler is to transform that information from Cplus_plus source to machine-dependent object code.
There are several stages in this process.
First the code is run through the preprocessor to expand macros, take care of conditional compilation, and read include files.
Next the processed file is passed to the first stage of the compiler, the lexical analyzer.
The lexical analyzer takes as its input a stream of characters and returns a series of tokens.
A token is a computer-science term meaning word or operator.
For example, let's look at the English command: Open the door.
There are 14 characters in this command.
Lexical analysis would turn this into three words and a period.
These tokens are then passed to the parser where they are assembled into sentences.
At this stage a symbol table is started so that the parser can have some idea what variables are being used by the program.
Now the compiler knows what the program is supposed to do.
The optimizer looks at the instructions and tries to figure out how to make them more efficient.
This step is optional and is omitted unless the -O flag is specified on the command line.
The code generator turns the high-level statements into machine-specific assembly code.
In assembly language, each assembly-language statement corresponds to one machine instruction.
The assembler turns assembly language into binary code that can be executed by the machine.
The general information flow of a compiler is diagrammed in Figure 23-3.
Lexical analysis and parsing are very common and used in a wide variety of programs.
The utility lex can generate the lexical analyzer module for a program, given a description of the tokens used by the program.
Another utility, yacc, can generate the parser module.
These programs are described in the book lex &-yacc (O'Reilly & Associates).
Page 432 Figure 23-3 Compiler modules Spreadsheet A simple spreadsheet takes a matrix of numbers and equations and displays the results on screen.
The information managed by this program is the equations and the data.
The core of a spreadsheet is the equations.
To change the equations into numbers, we need to go through lexical analysis and parsing, just like a compiler.
Page 433 But unlike a compiler, we don't generate machine code.
Results are passed off to the display manager, which puts them on the screen.
Add to this an input module that allows the user to edit and change the equations, and you have a spreadsheet, as shown in Figure 23-4.
Figure 23-4 Spreadsheet layout Module Design Guidelines Although there are no hard and fast rules when it comes to laying out the modules for a program, here are some general guidelines.
Modules should contain no more than 1,500 lines.
With more lines, they become difficult to edit, print, and understand.
Programming Exercises Exercise 23-1: Write a class that handles  formatting.
It should contain the following functions:.
Closes the print file.
Exercise 23-2: Write a module called search_open that first receives an array of filenames that it searches until it finds one that exists, and then it opens that file.
Exercise 23-3: Write a symbol table class containing the following functions: Enters a name into the symbol table.
Removes a name from the symbol table.
Exercise 23-4: Take the words program from Chapter 20, Advanced Pointers, and combine it with the infinite array module to create a cross-reference program.
Templates: The Hard Way Function Specialization Class Templates Class Specialization Implementation Difficulties Summary Programming Exercises Thou cunning'st patten of excelling nature —Shakespeare Othello, Act V What Is a Template.
They allow you to write generic classes and functions that work for several different data types.
Templates will be a very useful part of the Cplus_plus language, when they grow up.
The problem is that although the Draft ANSI Cplus_plus Standard specifies the complete syntax for templates, it says nothing about how to implement them.
The result is that each compiler maker has implemented templates differently, so programs that use templates tend to be nonportable.
Templates: The Hard Way Suppose we want to define a function max to return the maximum of two items.
Actually, we don't want to define just one max function, but a family of functions: one to find the maximum of two ints, one for floats, one for chars, and so on.
We start by defining a parameterized macro to generate the code for the function.
This is called the definition stage.
The macro looks like: #define define_max(type) type max(type dl, type d2) { \ \ return (dl); \.
Page 436 NOTE Each line except the last one ends in a backslash (\).
A #define macro spans a single line, so the backslash turns our five lines into one.
By putting the backslashes in the same column we can easily tell if we miss one.
This macro generates no code.
It merely provides the definition that is used in the next phase to generate the functions we want.
This is called the generation phase.
Finally, somewhere in the code we use the functions we've just defined.
Figure 24-1 shows the source code for the #define style templates and the code generated by them.
This method works adequately for simple functions like max.
It doesn't work well for larger functions.
One drawback to this system is that we must invoke the macro define_max for each data type we want to use.
It would be nice if Cplus_plus would call define_max automatically.
Templates allow you to define a generic function.
Cplus_plus then uses this template to generate a specific instance of the function as needed.
For example, to define the function max as a template, we write: template<class kind>.
NOTE The construct <class kind> tells Cplus_plus that the word kind can be replaced by any type.
Like the parameterized macro, it generates no code: it merely provides a definition for the next phase Page 437 Figure 24-1.
Code generated by #define style templates.
Page 438 and sees that it uses the function max (float, float).
It then checks to see whether the code for this function has been generated and generates it if necessary.
In other words, everything is automatic.
From this you can see that the first time max is used for a float it generates the floating point version of max.
Next we use max for int, and the int version of max is created.
Note that the last line:.
Figure 24-2 Template code generation Page 439 Function Specialization Templates go a bit further than simple code generation.
They can handle special cases as well.
What we want to do is tell Cplus_plus, "Use the normal comparison except when the data type is a string, and then use This is done through a process called specialization.
We declare a special version of the max function just for strings:.
Cplus_plus will find the simple function max(char *, char *) before trying to expand the.
Class Templates Class  are a little more complex than function.
Declaring them is easy.
They are defined just like function.
Example 24-2 shows the stack class from Chapter 13, Simple Classes, written as a template.
Example 24-2 -t/stack1 cc.
We could just as well have specified the procedures outside the class.
To do so, we must put the template clause template<class kind> in front of each procedure and put the template parameter (<kind>) in the  of the class.
For example, the push routine would look like: /************************************************* * ::push minus_minus push an item on the * * * * Warning: We do not check for overflow * * * * Parameters * * item minus_minus item to put on the * *************************************************/ template<class kind>.
Cplus_plus will also generate automatically the member functions: <int>: :push, <double>: :push, and <float>::push.
However, if you explicitly declare a member function yourself, Cplus_plus will use your definition before generating its own.
Suppose we want to have a  store strings (char *).
We don't want to store the pointers; we want to store the actual strings.
To do this, we need a special version of the push function that duplicates the string before pushing it onto the :.
Implementation Difficulties The Annotated Cplus_plus Reference Manual by Ellis and Stroustrup is considered the default standard of the Cplus_plus language.
It contains a complete definition of the syntax for.
However, it does not explain how compilers should implement them.
As you shall see, implementing  is not easy.
For example, suppose we put the in a module.
The file _0_h defines the class and the file _0_cc defines the Now we want to use the  for an integer  (<int>) in the file main_0_cc.
Figure 24-3 shows the source-code layout.
This is where the compiler implementors start pulling their hair out.
Page 443 Figure 24-3.
Source-code layout for using a We know that in main_0_cc, we're going to use <int>.
As a matter of fact, the file _0_h defined prototypes for the two member functions push and pop.
So when the compiler sees <int>, it should automatically generate the code for push and pop.
The bodies of these two member functions are tucked away in the file _0_cc.
The compiler is working on main_0_cc.
It doesn't know anything about any other file, so it doesn't know how to generate push<int> and pop<int>.
But couldn't the compiler generate push<int> and pop<int> when it compiles _0_cc.
Yes, if it knew that someone had declared a <int> variable.
But the only one who did that is main_0_cc and the compiler isn't working on that file just now.
Managers call this situation compatible.
Code written for one compiler may not work on another.
In some cases, even code written for one version of a compiler might not work in another version.
Templates are the leading edge of Cplus_plus compiler technology and, like all new , there are just a few bugs to work out.
In the following sections, we discuss the various ways compiler makers have attempted to solve the problems associated with templates.
Compiler technology and standards are constantly evolving, so the information in this section may not be up to date.
Microsoft's Implementation As of this publication date, the Microsoft Cplus_plus and Visual Cplus_plus compilers do not have templates.
Although extremely simple, this form of "implementation" is very Page 444 limited.
On the other hand, I've never had any trouble with templates using a Microsoft compiler.
Turbo-Cplus_plus and GNU gplus_plus Templates The Turbo-Cplus_plus and the GNU gplus_plus compilers take a similar approach.
If you plan to use <float>, then you must have a <float> in the file that defines the member functions: _0_cc.
At the beginning of the _0_cc file, you will need the line: typedef <float> floating_point_stack; Actually you never have to use the type floating_point_stack.
The typedef is there just to tell the compiler to generate the needed member functions.
Both compilers also have switches that tell the compiler what to do about inline functions that can't be handled inline.
Suppose you define the function: <class kind> inline kind max(kind dl, kind d2) {.
Also suppose that the function is so complex that the compiler decided to ignore the When your three files are compiled, three copies of max<float> are generated.
The Turbo-Cplus_plus linker is smart enough to detect this fact and will throw two of them away.
The GNU gplus_plus linker is not so smart, and you'll wind up with three copies of the same routine in your code.
Both Turbo-Cplus_plus and GNU provide you with compiler options that help solve this problem.
If you put the line: #pragma interface // GNU gplus_plus only option.
The options are clunky, nonportable, and difficult to use.
They are meant to solve an implementation problem that has not been properly solved yet.
CFront-Based Compilers CFront is the name of the AT&T Cplus_plus to C translator that was the basis of the first Cplus_plus compiler.
Most Cplus_plus compiler makers consider themselves standard if they are compatible with the latest version of CFront.
CFront handles the problem of  generation by putting it off until link time, so you only compile and link the file main_0_cc.
At link time, CFront notices that main_0_cc uses <float>.
It then looks for a file named _0_cc.
Although this method seems simple enough, there are a lot of details to take care of.
For example, the file _0_h is automatically included when the linker tries to compile _0_cc.
What's worse, if you include it yourself with a #include "_0_h", the compiler gets confused.
The CFront approach is a good attempt at solving the  problem, but there are still many bugs to work out.
Writing Portable Templates How can you write a portable.
The simple answer is, "Don't use them_0_" However, the best way to create a truly portable  is to write everything as inline functions and put all your functions in a single-header file.
As far as I can tell, this method works for every compiler that has templates.
It may not be the most efficient way of doing things, but it is the most portable.
Summary Templates provide a convenient way of writing generic classes and functions.
However, implementation of templates is still undergoing refinement.
As a practical matter, you may want to wait until the language settles down a little before using them.
Programming Exercises Exercise 24-1: Write a template min that returns the minimum of two values.
Make sure you handle strings correctly.
Page 446 Exercise 24-2: Write a template class to implement an array with bounds checking.
Exercise 24-3: Define a template class that implements a set.
The class allows you to set, Page 447 25 Portability Problems In This Chapter:.
Modularity Word Size Byte-Order Problem Alignment Problem NULL-Pointer Problem Filename Problems File Types Summary Answers to Chapter Questions Wherein I spake of most disastrous changes, Of moving accidents by flood and field, Of hair-breadth 'scapes i' the imminent deadly breadth —Shakespeare on Program Porting Othello, Act 1, Scene 3 You've just completed work on your great masterpiece, a ray-tracing program that renders complex three-dimensional shaded graphics on a Cray supercomputer using 30MB of memory and 5GB of disk space.
What do you do when someone comes in and asks you to port this program to an IBM PC with 640K of memory and 100MB of disk space.
Not only is it illegal, but it also is considered unprofessional.
Your only choice is to whimper and start the port.
It is during this process that you will find that your nice, working program exhibits all sorts of strange and mysterious problems.
Cplus_plus programs are supposed to be portable.
However, Cplus_plus contains many machine-dependent features.
Also, because of the vast difference between UNIX and MS-DOS/Windows, system dependencies can frequently be found in many programs.
This chapter discusses some of the problems associated with writing truly portable programs as well as some of the traps you might encounter.
Modularity One of the tricks to writing portable programs is to put all the nonportable code into a separate module.
For example, screen handling differs greatly in MSDOS/Windows and UNIX.
To design a portable program, you'd have to write machine-specific screen-update modules.
Page 448 For example, the HP-98752A terminal has a set of function keys labeled F1-F8.
The PC also has a function-key set.
The problem is that these keys don't send out the same set of codes.
The HP sends "<esc>p<return>" for F1 and the PC sends "<null>".
In this case, you would want to write a get_code routine that gets a character (or function key string) from the keyboard and translates function keys.
Because the translation is different for both machines, a machine-dependent module is needed for each one.
For the HP machine, you would put together the program with main_0_cc and hp-tty_0_cc, while for the PC you would use main_0_cc and pc-tty_0_cc.
Word Size A long int is 32 bits, a short int is 16* bits, and a normal int can be 16 or 32 bits depending on the machine.
This can lead to unexpected problems.
For example, the following code works on a 32-bit UNIX system, but fails when ported to MS-DOS/Windows: int ;.
Byte-Order Problem A short int consists of two bytes.
The two bytes have the value 0x12 and 0x34.
Which value is stored in the first byte.
The answer is machine dependent.
This can cause considerable trouble when you try to write portable binary files.
Motorola 68000-series machines use one type of byte order (ABCD), while Intel and Digital Equipment Corporation machines use another (BADC).
One solution to the problem of portable binary files is to avoid them.
Put an option in your program to read and write ASCII files.
ASCII offers the twin advantages of being far more portable as well as human readable.
Page 449 The disadvantage is that text files are larger.
Some files may be too big for ASCII.
In that case, the magic number at the beginning of a file may be useful.
Suppose the magic number is 0x11223344 (a bad magic number, but a good example).
When the program reads the magic number, it can check against the correct number as well as the byte-swapped version (0x22114433).
The program can automatically fix the file problem: const int MAGIC.
Alignment Problem Some computers limit the addresses that can be used for integers and other types of data.
For example, the 68000 series requires that all integers start on a two-byte boundary.
If you attempt to access an integer using an odd address, you generate an error.
Some processors have no alignment rules, while some are even more restrictive, requiring integers to be aligned on a four-byte boundary.
Alignment restrictions are not limited to integers.
Floating point numbers and pointers also must be aligned correctly.
Cplus_plus hides the alignment restrictions from you.
For example, if you declare the following structure on a 68000:.
Structure on 68000 and 8086 architectures On an 8086-class machine with no alignment restrictions, this is allocated as shown on the right in Figure 25-1.
The problem is that the size of the structure changes from machine to machine.
On a 68000, the structure size is six bytes and on the 8086, it is five.
So if you write a binary file containing 100 records on a 68000, it will be 600 bytes long, while on an 8086 it will be only 500 bytes long.
Obviously the file is not written the same way on both machines.
One way around this problem is to use ASCII files.
As we have said before, there are many problems with binary files.
Another solution is to explicitly declare a pad byte: struct new_funny { char.
The pad character makes the field value align correctly on a 68000 machine while making the structure the correct size on an 8086-class machine.
Using pad characters is difficult and error-prone.
For example, although new_funny is portable between machines with one- and two-byte alignment for 32-bit integers, it is not portable to any machine with a four-byte integer alignment.
NULL-Pointer Problem Many programs and utilities were written using UNIX on VAX computers.
On this computer, the first byte of any program  0.
Many programs written on this computer contain a bug: They use the null pointer as a.
Page 451 Example:.
This  actually an illegal use of.
Null pointers should never be dereferenced.
On the VAX, this error causes no problems.
Because byte zero of the program  zero,  points to a null.
This  due to luck, not design.
On a VAX, this will print: On an old Celerity, the first byte of the program  a "Q_0_" When this program  run on a Celerity, it will print: String  'Q' On other computers, this type of  can generate unexpected results.
Many of the utilities ported from a VAX to a Celerity exhibited the "Q" bug.
Filename Problems UNIX specifies files as /root/sub/file while MS-DOS/Windows uses \root\sub\file.
When porting from UNIX to MS-DOS/Windows, file names must be changed.
For example: #ifndef __MSDOS # <sys/stat_0_h> /* UNIX version of the file */ #else _MSDOS_ # <sys\stat_0_h> /* DOS version of the file */ #endif __MSDOS_ Question 25-1: Why does Example 25-1 work on UNIX, but when we run it in MSDOS/Windows we get the message: oot ew able: file not found Example 25-1.
File Types In UNIX there  only one file type.
In MS-DOS/Windows there are two, text and binary.
The flags O_BINARY and O_TEXT are used in MS-DOS/Windows to indicate file type.
Older versions of UNIX have no such flags.
One way of handling this problem  to write different open calls for each system: #ifndef _MSDOS_ = open("file", O_RDONLY); #else _MSDOS_ = open("file", O_RDONLY|O_BINARY); #endif _MSDOS_ This  messy.
A far better way  to define dummy O_BINARY and O_TEXT flags: #ifndef O_BINARY /* Do we have an O_BINARY.
Because Cplus_plus runs on many different types of machines that use different operating systems, it  not easy.
However, if you keep portability in mind when creating the code, you can minimize the problems.
Porting four-letter words Portability problems are not limited to programming.
When Practical C Programming was translated to Japanese, the translator had a problem with one exercise: "Write a program that removes four-latter words from a file and replaces them with more The problem was, in Japanese, everything  a one-letter word.
When the translator came to a phrase he couldn't directly translate, he did his best and also put in the English.
But for the four-letter words, he decided to  the English as well as some additional help (Stars added.
I don't use words like that_0_): additional help (Stars added.
I don't use words like that_0_): Page 453 Answers to Chapter Questions Answer 25-1: The problem  that Cplus_plus uses the backslash (\) as an escape character.
The character \r  <return>, \n  < >, and \t  <tab>.
What we really have for a name : <return>oot< >ew<tab>able The name should be specified as: NOTE The # uses a filename, not a Cplus_plus.
While you must use double backslashes (\\) in a Cplus_plus , you use single backslashes in an #.
The following two lines are both correct: Page 455 26 Putting It All Together In This Chapter:.
Requirements Code Design Coding Functional Description Testing Revisions A Final Warning Program Files Programming Exercises Exercises For there isn 't a job on the top of the earth the beggar don't know, nor do —Kipling In this chapter we create a complete program.
Every step of the process is covered, from setting forth the requirements to testing the result.
Requirements Before we start, we need to decide what it is we are going to do.
This is a very important step and is left out of far too many programming cycles.
This chapter's program must fulfill several requirements.
First, it must be long enough to demonstrate modular programming, but at the same time be short enough to fit inside a single chapter.
Second, it must be complex enough to demonstrate a wide range of Cplus_plus features, but be simple enough for a novice Cplus_plus programmer to understand.
Finally, it must be useful.
This is not so simple to define.
What's useful to one person might not be useful to another.
We decided to refine this requirement and restate it as "It must be useful to Cplus_plus programmers_0_" The program we have selected reads Cplus_plus source files and generates simple statistics on the nesting of parentheses, and the ratio of comments to code lines.
The specification for our statistics program is: Preliminary Specification for a Cplus_plus Statistics Gathering Program Steve Oualline February 10, 1995 Page 456 The program stat gathers statistics about Cplus_plus source files and prints them.
The command is: stat files where files is a list of source files.
The following shows the output of the program on a short test file.
Maximum nesting of {} : 4 Number of blank lines _0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0_4 Number of comment only lines _0__0__0__0__0__0__0__0__0__0_4 Number of code only lines _0__0__0__0__0__0__0__0__0__0__0__0__0_36 Number of lines with code and comments 4 Comment to code ratio 20_0_5% Code Design There are several schools of code design.
In structured programming, you divide the code up into modules and then divide the module into submodules, divide the sub-modules into sub-submodules, and so on.
This is also known as procedure- oriented programming.
In object-oriented programming, you try to think of the problem as a collection of data that you manipulate through member functions.
There also are other approaches, such as state tables and transition diagrams.
All of these have the same basic principle at heart: "Arrange the program's information in the clearest and Our program breaks down into several logical modules.
First, there is a token scanner, which reads raw Cplus_plus code and turns it into tokens.
Actually, this function sub-divides into two smaller modules.
The first reads the input stream and determines what type of character we have.
The second takes in character-type information and uses it to assemble tokens.
The other module contains the statistics gathering and a small main program.
Token Module Our program scans Cplus_plus source code and uses the tokens to generate statistics.
A token is a group of characters that form a single word, number, or symbol.
For example, the line: = (123 + 456) / 89; // Compute some sort of consists of the tokens: T_ID T_OPERATOR T_L_PAREN T_NUMBER T_OPERATOR Left Parenthesis number 123 Page 458 T_NUMBER T_R_PAREN T_OPERATOR T_NUMBER T_OPERATOR T_COMMENT T_NEWLINE number 456 Right parenthesis divide operator number 89 semicolon // comment end-of-line Our token module needs to identify groups of characters.
For example, an identifier is defined as a letter or underscore, followed by any number of letters or digits.
So our tokenizer needs to contain the pseudocode: If the current  is a letter then scan until we get a  that's not a letter or digit As you can see from the pseudocode, our tokenizer depends a great deal on  types, so we need a module to help us with the type information.
Character-type Module purpose of the -type module is to read characters and decode their types.
Some types overlap.
For example, C_ALPHA_NUMERIC includes the C_ NUMERIC  set.
This module stores most of the type information in an array and requires only a little logic to handle the special types like C_ALPHA_NUMERIC.
Statistics Class In this program, a statistic is an object that consumes tokens and outputs statistics.
We start by defining an abstract class for our statistics.
This class is used as the basis for the statistics we are collecting.
Figure 26-1 Statistics class hierarchy Our definition of a statistic is "something that uses tokens to collect statistics_0_" These statistics may be printed at the beginning of each line or at the end of the file.
Page 459 Our four statistics are more specific.
For example, the class paren_counter counts the nesting of parenthesis as well as the maximum nesting.
It counts the number of T_NEW_LINE tokens and outputs that count at the start of each line.
Coding coding process was fairly simple.
Functional Description This section describes all the classes and major functions in our program.
For a more complete and detailed description, take a look at the listings at the end of this chapter.
For the most part, this is done through a table named type_info.
Some types, such as C_ALPHA_NUMERIC, include two different types of characters, C_ALPHA and C_DIGIT.
Therefore, in addition to our table, we need a little code for the special cases.
It buffers up a line and on command writes the line to the output.
We have an input stream consisting of characters.
Actually, our tokenizer is rather simple, because we don't have to deal with most of the details that a full Cplus_plus tokenizer must handle.
Page 460 One clever trick is used in this section.
TOKEN_LIST macro is used to generate an enumerated list of token types as well as a string array containing the names of each of the tokens.
Let's examine how this is done in more detail.
This allows us to use TOKEN_LIST to generate a list of strings containing the names of the tokens:.
Using tricks like this is acceptable in limited cases.
However, such tricks should be extensively commented so the maintenance programmer who has to fix your code can understand what you did.
It starts with a member function to consume tokens.
This function is a pure virtual function, which means that any derived classes must define the function take_token.
We need some way of printing them.
We print statistics in two places.
The first is at the beginning of each line and the second is at the end of the file.
Our abstract class contains two virtual functions to handle these two cases:.
They don't have to define line_start or eof.
This counting is done through the line_counter class.
The only  it cares about is T_NEW_LINE.
At the beginning of each line it outputs the line number (the current count of the T_NEW_LINE tokens).
At the end of file, this class outputs nothing.
As a matter of fact, the line_counter class doesn't even define an eof function.
Instead, we let the default in the Page 462 brace_counter class This class keeps track of the nesting level of the curly braces {}.
We feed the class a stream of tokens through the take_token member function.
This function keeps track of the left and right curly braces and ignores everything else.
The results of this statistic are printed in two places.
The first is at the beginning of each line.
The second is at the end of file.
We define two member functions to print these statistics: // Output start of line statistics // namely the current line number.
As a matter  fact, it was created by copying the brace_counter class and performing a few simple edits.
We probably should combine the paren_counter class and the brace_counter class into one class that uses a parameter to tell it what to count.
Oh well, something for the next version.
Page 463 comment_counter class In this class, we keep track  lines with comments in them, lines with code in them, lines with both, and lines with none.
The results are printed at the end  file.
But how does it know what statistics classes to use.
There is a list: static static static static.
Counter Counter Counter Counter lines.
Even though line_count, paren_count, brace_count, and comment_count are all different types, they are all based on the type stat.
This means that we can put them in an array called.
This design also makes it easy to add another statistic to the list.
All we have to do is define a new class and put a new  in the.
Testing To test this program, we came up with a small Cplus_plus program that contains every different type possible.
The results are shown in Example 26-2.
Revisions As it stands, the program collects a very limited set  statistics.
It might be nice to add things like average identifier size, per-procedure statistic, and pre-class statistics.
One thing we kept in mind when we designed our program is the need for expendability.
We stopped our statistics collection at four types  statistics because we had fulfilled our mission to demonstrate a reasonable advanced set  Cplus_plus constructs.
We didn't add more because it would make the program too complex to fit in the chapter.
On the whole, the program does its job well.
A Final Warning Just because you can generate a statistic doesn't mean that it's useful.
Program Files The ch_type_0_h file Example 26-3 stat/ch_type_0_h /******************************************************* * char_type minus_minus Character type class * * * * Member functions: * * type minus_minus returns the type  a character.
The token_0_ccfile Example 26-6 stat/token_0_cc /******************************************************** * token minus_minus token handling module * * * * Functions: * * next_token minus_minus get the next token from the input * ********************************************************/.
Can be a T_COMMENT or TNEW_LINE * * depending on what we read.
The stat_0_ccfile Example 26-7 stat/stat_0_cc /********************************************************** * stat * * Produce statistics about a program * * * * Usage: * * stat [options] <file-list> * * * **********************************************************/.
Counter Counter Counter Counter lines.
Page 479 // A list  the statistics we are collecting static stat [] = { &line_count, &paren_count, &brace_count, &comment_count, NULL }; /***************************************************** * do_file minus_minus process a single file * * * * Parameters * * name minus_minus the name  the file to process * *****************************************************/.
Example 26-8 stat/makefile_0_unx # # Makefile for many UNIX compilers using the # "standard" command # = =-g = stat_0_o ch_type_0_o token_0_o all: stat_0_out stat stat_0_out: stat stat _0__0_/calc3/calc3_0_cc >stat_0_out.
Page 481 UNIX Makefile for gplus_plus Example 26-9.
Exercise 26-2: Write a program that removes four-letter words from a file and replaces them with more acceptable equivalents.
Page 484 Exercise 26-3: Write a mailing list program.
This program will read, write, sort and print mailing labels.
Exercise 26-4: Update the statistics program presented in this chapter to add a cross-reference capability.
Exercise 26-5: Write a program that takes a text file and splits each long line into two smaller lines.
The split point should be at the end of a sentence if possible, or at the end of a word if a sentence is too long.
Overview K & R-Functions struct malloc and free Turning Structures into Classes setjmp and longmp Summary Programming Exercise No distinction so little excites envl as that which is derived from ancestors by a long descent.
That's both a blessing and a curse.
It's a curse because it means you'll probably have to deal with a lot of ancient code.
On the other hand, there will always be work for you.
This chapter describes some of the differences between C and Cplus_plus as well as how to migrate from one to the other.
K&R-Style Functions Classic C (also called K&R C after its authors, Brian Kernighan and Dennis Ritchie) uses a function header that's different from the one used in Cplus_plus.
In Cplus_plus the parameter types and names are included inside the () defining the function.
In Classic C, only the names appear.
When Cplus_plus came along, the ANSI C committee decided it would be a good idea if C used the new  definitions.
However, because there was a lot of code out there using the old method, Cplus_plus accepts both types of functions.
Classic C does not require prototypes.
In many cases, prototypes are missing from C programs.
A  that does not have a prototype has an implied prototype of: int funct(_0__0__0_);.
Otherwise, you will have to do it manually.
C has no built-in memory-handling operations.
Instead, it makes use of two library routines: malloc and free.
The  malloc takes a single parameter—the number of bytes to allocate—and returns a pointer to them (as a char * or void *).
But how do we know Page 487 how big a structure is.
That's where the sizeof  comes in.
It returns the number of.
The  calloc is similar to malloc except that it takes two parameters: the number of.
The C memory allocators are messy, however, and should be converted to Cplus_plus whenever possible.
There are a number of traps concerning C-style memory allocation.
Suppose we take our structure  and turn it into a class.
We can but shouldn't use the C memory routines to allocate space for the class: class  {_0__0__0_}; = (struct  *)malloc(sizeof(struct )); // Don't code like this Because Cplus_plus treats struct as a special form of class most compilers won't complain about this code.
The problem is that our malloc statement allocates space for  and that's all.
No constructor is called, so it's quite possible that the class will not get set up correctly.
C uses the  free to return memory to the heap.
The  free takes a single character pointer as a parameter (thus making a lot of casting necessary): free((char *));.
Again, you  be careful when turning  into a class.
The   just returns the memory to the heap.
It does not call the destructor for.
C-style memory allocation is messy and risky.
When converting to Cplus_plus you probably should get rid of all malloc, calloc, and   whenever possible.
WARNING According to the ANSI C draft standard, memory allocated by malloc  be deallocated by.
Similarly, memory allocated by new  be deallocated by delete.
However, most of the compilers I've seen implement new  a call to malloc and delete  a call to.
In other words, mixing new/ or malloc/  will usually work.
To avoid errors, you should follow the rules and avoid mixing C and Cplus_plus operations.
Turning Structures into Classes Frequently when examining C code you may find a number of struct statements that look like they should be classes.
Actually, a structure is really just a data-only class with all the members public.
C programmers frequently take advantage of the fact that a structure only contains data.
One example of this is reading and writing a structure to a binary file.
Cplus_plus keeps extra information, such virtual  pointers, in a class.
When you write the class to disk using a raw write, you are outputting all that information.
What's worse, when you read the class in you overwrite this bookkeeping data.
Page 489 For example, suppose we have the class:.
Internally, this class consists of three member variables: a constant, sample_size (which Cplus_plus won't allow you to change); a simple , cur_sample; and a pointer to the real to be used when get_sample is called.
All three of these are written to disk by the call: sample a_sample;.
When this class is read, all three members are changed.
That includes the constant (which we aren't supposed to change) and the  pointer (which now probably points to something strange).
C programmers also make use of the memset  to set all the members of a structure to zero.
Again, be careful when turning a structure into a class.
If we had used the class a_sample instead of the structure struct_var, we would have zeroed the constant sample_size well  the virtual  pointer.
The result would probably be a crash if we ever tried to call get_sample.
The setjmp  marks a place in a program.
The longjmp  jumps to the place marked by setjmp.
Normally setjmp returns a zero.
This tells the program to execute normal code.
When an exception occurs, the longjmp call returns to the location of the setjmp.
The only difference the program can see between a real setjmp call and a fake setjmp call caused by a longjmp is that a normally setjmp returns a zero.
When setjmp is "called" by longjmp, the return value is controlled by a parameter to longjmp.
The definition of the longjmp call is: void longjmp(jmp_buf env, int return_code); where: env is the environment initialized by a previous setjmp call return_code is the return code that will be returned by the setjmp call Figure 27-1 illustrates the control flow when using setjmp and longjmp There is one problem here, however.
The longjmp call returns control to the corresponding setjmp.
It does not call the destructors of any classes that are "destroyed" in the process.
In Figure 27-1 we can see that in the subroutine we define a class named a_list.
Normally we would call the destructor for a_list at the end of the function or at a return statement.
However, in this case we use longjmp to exit the function.
Since longjmp is a C function it knows nothing about classes and destructors and does not call the destructor for a_list.
So we now have a situation where a variable has disappeared but the destructor has When converting C to Cplus_plus, change all setjmp/longjmp combinations into exceptions.
Page 491 Figure 27-1.
Change K&R-style function headers into standard Cplus_plus headers.
Change setjmp/longjmp calls into catch/throw operations.
Following these three steps you have a C+½ program.
It works, but it's really a C program in Cplus_plus's clothing.
To convert it to a real Cplus_plus program you need to do the following: 4.
Change malloc into new.
Change  into delete or delete [] calls.
Turn printf and scanf calls into cout and cin.
When turning struct declarations into class variables, be careful of read, write, and memset functions that use the entire structure or class.
Programming Exercise Exercise 27-1: There are a lot of C programs out there.
Page 493 28 Cplus_plus's Dustier Corners In This Chapter:.
It is titled Cplus_plus's Dustier Corners because these statements are hardly ever used in real programming.
The program loops, tests the expression, and stops if the expression is false (0).
NOTE This construct always executes at least once.
In actual practice I find I use a goto statement about once every other year.
For those rare times that a goto is necessary, its syntax is: goto label; Page 494.
Labeling a statement is done as follows:.
Unlike if/then/else, the _0_: operators can be used inside of an expression.
The general form of _0_: is: (expression).
NOTE It is better to define min as an inline function instead of as a parameterized macro.
See Chapter 10, The Cplus_plus Preprocessor, for details.
The Comma Operator.
About the only place the comma operator.
Overloading the () operator is rarely done.
Normal member functions can easily be used for the same purpose but have the advantage of providing the user with a function name.
Pointers to Members The operator :: * is used to point to a member of a class.
For example, in the following code we declare data_ptr as a "pointer to an integer in sample": class sample {.
Let's set  so it points to the member i: = &sample::i; An ordinary pointer identifies a single item.
A member pointer identifies a member but does not identify an individual variable.
All we've done is set  to a member of sample.
To use  you need to tell it which class you want: sample a_sample; // A typical sample.
The variable points to an integer member of sample.
Because I've been unable to actually use these features, the information presented here is a bit sketchy.
However, as soon as the compiler makers catch up with the standard, such macros will cause problems.
Answers to Chapter Questions Answer 28-1: The compiler didn't see our default  because we misspelled "default" as "defualt_0_" This was not flagged as an error because "defualt" is a valid goto label.
That's why when we compile the program we get the warning: def_0_c(26): warning: defualt unused in function main which means we defined a label for a goto, but never used it.
Page 499 29 Programming Adages In This Chapter:.
General Design Declarations switch Statement Preprocessor Style Compiling The Ten Commandments for Cplus_plus Programmers Final Note Answers to Chapter Questions Second thoughts are ever wiser —Euripides General.
Comment, comment, comment.
Put a lot of comments in your program.
They tell other programmers what you did.
Use the "KISS" principle (Keep It Simple, Stupid).
Clear and simple is better than complex and wonderful.
Never put an assignment inside a conditional.
Never put an assignment inside any other statement.
Know the difference  =  ==.
Practice is crucial  people involved in almost every other profession that requires a significant level of skill  creativity (e_0_g_0_, artists, athletes).
Help others learn to program.
It makes good practice  you to go over what you already know, or think you know.
Page 500 Design.
If you come to a choice  a relatively "quick hack" or a somewhat more involved but more flexible solution, always go  the more flexible solution.
You're more likely to reuse it or learn from it.
You're also more likely to be thankful later on when requirements shift a little  your code is ready  it.
Never trust any user input to be what you expect.
What would your program do at any given point if a cat walked across the keyboard, several times.
Watch out  signed-unsigned conversions  over/underflow conditions.
Put variable declarations one per line  comment them.
Make variable names long enough to be easily understood, but not so long that they are.
Never use default return declarations.
If a function returns an integer, declare it as type int.
Always put a default case in a switch statement.
Every case in a switch should end with a break or a /* fall through */ statement.
Always put parentheses, (), around each constant expression defined by a pre-processor #define directive: #define BOX_SIZE (3 * 10) /* Size of the box in pixels */.
When using the #ifdef/#endif construct  conditional compilation, put the #define  #undef statements near the top of the program  comment them.
The use of inline functions is preferred over the use of parameterized macros.
A single block of code enclosed in {} should not span more than a couple of pages.
Split up any bigger blocks into several smaller, simpler procedures.
When your code starts to run into the right margin, it's about time to split the procedure into several smaller, simpler procedures.
Always define a constructor, destructor,  copy constructor  a class.
If using the Cplus_plus defaults, "define" these routines with a comment such as:.
Always create a Makefile so others will know how to compile your program.
When compiling, turn on all the warning flags.
You never know what the compiler might find.
The Ten Commandments  Cplus_plus Programmers By Phin Straite 1.
Thou shalt not rely on the compiler default methods  construction, destruction, copy construction, or assignment  any but the simplest of classes.
Thou shalt forget these "big four" methods  any nontrivial class.
Thou shalt declare  define thy destructor as virtual such that others may become heir to the fruits of your labors.
Thou shalt not violate the "is-a" rule by abusing the inheritance mechanism  thine own twisted perversions.
Thou shalt not rely on any implementation-dependent behavior of a compiler, operating system, or hardware environment, lest thy code be forever caged within that dungeon.
Thou shalt not augment the interface of a class at the lowest level without most prudent deliberation.
Such ill-begotten practices imprison thy clients unjustly into thy classes create unrest when code maintenance  extension are required.
Thou shalt restrict thy friendship to truly worthy contemporaries.
Beware,  thou art exposing thyself rudely as from a trenchcoat.
Thou shalt not abuse thy implementation data by making it public or static except in the rarest of circumstances.
Thy data are thine own; share it not with others.
Thou shalt not suffer dangling pointers or references to be harbored within thy objects.
These are nefarious and precarious agents of random and wanton destruction.
Thou shalt make use of available class libraries as conscientiously as possible.
Code reuse, not just thine own but that of thy clients as well, is the holy grail of OO.
Thou shalt forever forswear the use of the vile printf/scanf, rather favoring the flowing streams.
Cast off thy vile C cloak and partake of the wondrous fruit of flexible and extensible I/O.
Final Note Just when you think you've discovered all the things Cplus_plus can do to you—think again.
There are still more surprises in store.
Question 29-1: Why does Example 29-1 think everything is two.
Answers to Chapter Questions Answer 29-1: The statement ( =.
It is equivalent to: = (_0_2); The programmer accidently reversed the not  _0_= so it  =_0_.
The statement should read: Page 505 VI Appendixes Page 507 A ASCII Table Table A-1.
ASCII Character Chart Dec.
Page 508 Dec.
Page 511 B Ranges Tables B-1 and B-2 list the ranges of various variable types.
Accuracy Page 512 Name Bits.
Page 513 C Operator Precedence Rules Practical Subset of the Operator Precedence Rules Table C-1.
Practical Operator Precedence Rules Precedence Operator.
Put parentheses around everything else.
Standard Rules Table C-2.
Standard Cplus_plus Precedence Rules Precedence Operators.
Page 515 D Computing sine Using a Power Series This program is designed to compute the sine function using a power series.
A very limited floating-point format is used to demonstrate some of the problems that can occur when using floating point.
The program computes each term in the power series and displays the result.
It continues computing terms until the last term is so small that it doesn't contribute to the final result.
For comparison purposes, the result of the library function sin is displayed as well as the computed sine.
The program is invoked by: sine value where value is an angle in radians.
For example, to compute (0) we use the command: % sine 0 x**l _0_+00 1.
And to compute ( π ) we use the command: % sine 3_0_141 x**1 3_0_141E+00 1.
Page 517 Makefile Makefilefor UNIX Example D-1.
It is not * * intended to be used to produce exact values for * * the sine function.
Very slow, but it works.
Glossary ^ Symbol for the bitwise exclusive OR operator.
Inverts all bits.
Symbol for the logical NOT operator.
Symbol for the bitwise AND operator.
A symbol used to precede a variable name (as in &x).
Means the address of the named variable (address of x).
Used to assign a value to a pointer variable.
Used to declare a reference variable.
Symbol for the multiply operator.
Symbol used to precede a pointer variable name that means get the value stored at the address pointed to by the pointer variable.
Page 522 minus_minus Symbol for the decrementation operator.
End-of-string character (the NULL character).
If defined, the code following it is included in the source.
If it is currently undefined, the code following is included in the macro expansion.
Page 523 _ptr A convention used in this book.
All pointer variables end with the extension _ptr.
AND A Boolean operation that yields 0 if either operand is 0 and 1 if both operands are 1.
ANSI C Any version of C that conforms to the specifications of the American National Standards Institute Committee X3J.
ANSI Cplus_plus Any version of Cplus_plus that conforms to the specifications of the American National Standards Institute.
At the time of this writing, the standards exist only in draft form and there are still a lot of details to be worked out.
In Cplus_plus, arrays are stored in contiguous memory.
ASCII American Standard Code for Information Interchange.
A code to represent characters.
B base class A class that is used as the base for a derived class.
Page 524 bit field A group of contiguous bits taken together as a unit.
This Cplus_plus language feature allows the access of individual bits.
See also complement.
Borland Cplus_plus A version of the Cplus_plus language for personal computers developed by Borland.
This is the high-end version of Borland's Turbo-Cplus_plus product.
The technique of using a combination of asterisks, vertical and horizontal rules, and other typographic characters to draw a box around a comment in order to set it off from the code.
C C A general-purpose computer programming language developed in 1974 at Bell Laboratories by Dennis Ritchie.
C is considered to be a medium- to high-level language.
Page 525 Cplus_plus A language based on C invented in 1980 by Bjarne Stroustrup.
First called "C with classes," it has evolved into its own language.
Cplus_plus code Computer instructions written in the Cplus_plus language.
Cplus_plus compiler Software that translates Cplus_plus source code into machine code.
Cplus_plus syntax See syntax.
This program was the basis for the first Cplus_plus compilers.
Currently not used for most compilers, as many native Cplus_plus compilers now exist.
CGA Color graphics adapter.
A common color graphics card for the IBM PC.
Page 526 See storage class.
This is not a defined operation in Cplus_plus.
Comments are a programmer's notes to himself and future programmers.
The text is ignored by the compiler.
A logical complement is the same as an invert or NOT operation.
Page 527 continue A flow control statement that causes the next execution of a loop to begin.
When the variable reaches a predetermined value, the loop is terminated.
They are used in Cplus_plus to delimit groups of elements to treat them as a unit.
D debugging The process of finding and removing errors from a program.
See also * derived class A class built on top of another, baseass.
Page 528 directive A command  the preprocessor (as opposed  a statement  produce machine code).
The number usually requires twice as much storage as type float.
See also linked list.
E EGA Enhanced graphics adapter.
A common graphics card for the IBM PC.
The Cplus_plus compiler assigns an integer each member of the set.
EOF End-of-file character defined in stdio_0_h.
This is represented in Cplus_plus by the backslash character, \.
Page 529 exponent underflow A condition resulting from a floating-point operation where the result is an exponent too large in negative value  fit within the bit field allotted  the exponent.
F fast prototyping A top-down programming technique that consists of writing the smallest portion of a specification that can be implemented that will still do something.
From the old C-style I/O package stdio.
From the old C-style I/O package stdio.
From the old C-style I/O package stdio.
From the old C-style I/O package stdio.
FILE A macro definition in stdio that declares a file variable.
From the old C-style I/O package stdio.
The system handles very large and very small numbers.
An error caused by a divide-by-0 or other illegal arithmetic operation.
It is a somewhat misleading error because it is caused by integer as well as floating-point errors.
In personal computers, it is found in the math coprocessor.
More advanced processors such as the 80486 have floating-point units built in.
From the old C-style I/O package stdio.
From the old C-style I/O package stdio.
From the old C-style I/O package stdio.
From the old C-style I/O package stdio.
From the old C-style I/O package stdio.
This has been replaced by the Cplus_plus delete operator See also malloc.
Free Software Foundation A group of programmers who create and distribute high-quality software for free.
Among their products are the editor emacs and the Cplus_plus compiler gplus_plus.
Their address is: Free 876-3296.
From the old C-style I/O package stdio.
From the old C-style I/O package stdio.
G generic pointer A pointer that can point to any variable without restriction as to type of variable.
A pointer to storage without regard to content.
Page 531 Ghostscript A Postscript-like interpreter that is freely available from the Free Software Foundation.
H header file See include file.
I I/O manipulators Functions that when "output" or "input" cause no I/O, but set various conversion flags or parameters.
IEEE floating-point standard IEEE standard 754, which standardizes floating-point format, precision, and certain non-numerical values.
A particular operation may yield different results when run on another system.
Inclusive OR See OR.
Page 532 index A value, variable, or expression that selects a particular element of an array.
The idea is  keep as much information as possible hidden inside the modules and make information public only if absolutely necessary.
L left shift The operation of moving the bits in a bit field left by a specified amount and filling the vacated positions with zeros.
Each node consists of a value and a pointer  the next item in the list.
Page 533 logical AND A Boolean operation that returns true if its two arguments are both true.
When used on integers, each bit is operated on separately.
When used on integers, each bit is operated on separately.
M machine code Machine instructions in a binary format that can be recognized directly by the machine without further translation.
The value of a number without regard  sign.
Modification of a program because of changing conditions external  the computer system.
Makefile The file that contains the commands for the utility make.
This function is now obsolete.
The Cplus_plus operator new  this function.
Page 534 member An element of a class or structure.
MS-DOS An operating system for IBM personal computers developed by Microsoft.
N new Cplus_plus operator to get a new  from the heap.
NOT A Boolean operation that yields the logical inverse of the operand.
NOT 1 yields a 0 and NOT 0 yields a 1.
This indicates that the pointer does not point to valid data.
O object-oriented design A design methodology where the programmer bases his or her design on data objects (classes) and the connections between them.
Ones become zeros and zeros become ones.
Page 535 OR A Boolean operation that yields a 1 if either of the operands is a 1 or yields a zero if both of the operands are 0.
P packed structure A data-structure technique whereby bit fields are only as large as needed, regardless of word boundaries.
Often means the arguments that are passed between a caller and a called procedure.
The insertion occurs during the expansion of the macro.
From Picture Element.
A numeric value can be added to a pointer.
A numeric value can be subtracted from a pointer.
One pointer can be subtracted from another pointer.
Page 536 Portable C compiler A C compiler written by Stephen Johnson making it relatively easy to adapt the compiler to different computer architectures.
From the old C-style I/O package stdio.
It does not return a value (function of type void).
The process of expressing the solution to a problem in a language that represents instructions for a computer.
Page 537 pseudocode A coding technique where precise descriptions of procedures are written in easy-to-read language constructs without the bother of precise attention to the syntax rules of a computer language.
The class containing a pure virtual function cannot be used directly but must be the base for another class.
R radix The positive integer by which the weight of the digit place is multiplied to obtain the weight of the next higher digit in the base of the numbering system.
A similar option, <file, exists for taking input from a file instead of the keyboard.
Page 538 return statement A statement that signals the completion of a function and causes control to return to the caller.
S save file A debugging tool where all the keystrokes typed by the user are saved in a file for future use.
See also replay file.
In most cases an fgets/sscanf combination is used.
From the old C-style I/O package stdio.
Caused by de-referencing a bad pointer.
This is not a defined operation in Cplus_plus.
Used in Cplus_plus to delimit a single character.
From the old C-style I/O package stdio.
From the old C-style I/O package stdio.
Caused by a big program or by infinite recursion.
Inside a set of curly braces, it indicates a permanent variable.
Outside a set of curly braces, it indicates a file-local variable.
For class members it denotes a variable or function that is instance independent.
See Table 14-1 for a complete list of uses.
From the old C-style I/O package stdio.
Page 540 stdin Predefined input source.
From the old C-style I/O package stdio.
From the old C-style I/O package stdio.
Sunview A graphics and windowing system available on SUN workstations.
T temporary variable A variable whose storage is allocated from the stack.
The variable is initialized each time the block in which it is defined is entered.
It exists only during the execution of that block.
This is not a defined operation in Cplus_plus.
Page 541 text editor Software used to create or alter text files.
Turbo-Cplus_plus A version of the Cplus_plus language for personal computers developed by Borland.
U unbuffered I/O I/O in which each read or write results in a system call.
UNIX A popular multiuser operating system first developed by Ken Thompson and Dennis Ritchie of the Bell Telephone Laboratories.
Modification of a  to provide improved performance or new.
V value A quantity assigned to a constant.
The data represented by the variable name can, at different times during the execution of a , assume different values.
Page 542 version A term used to identify a particular edition of software.
A customary practice is to include a version number.
Whole numbers indicate major rewrites.
Fractions indicate minor rewrites or corrections of problems.
When used in casts, it indicates that a given value is to be discarded.
This attribute is used for memory-mapped I/O, shared memory applications, and other advanced programming.
W while An iterative statement that repeats a statement as long as a given condition is true.
X X Window System A graphics and windowing system, available from the X Consortium, that is currently running on many computing systems.
Z zero-based counting A system of counting where the first object is given the count zero rather than one.
Page 543 Index minus_minus (decrement) operator, 79, 80, 325 - (for command-line options), 242 - (negative) operator, 324 - (subtraction) operator, 52, 323 - (unary) operator, 322 (logical NOT) operator, 86, 326 _0_= (not equal to) operator, 86, 323 '(quotation mark), 59 "(quotation mark), 59 with include files, 159 for strings, 60, 65 # (preprocess) operator, 162 ## diagnostic tag, 106 % (modulus) operator, 52, 323 %= (modulus into) operator, 79, 325 %c conversion, 274 %d conversion, 273 %e conversion, 274 %f conversion, 274 %ld conversion, 274 %lu conversion, 274 %o conversion, 274 %s conversion, 274 %u conversion, 274 %x conversion, 274 & (address of) operator, 229, 322, 324 & (bitwise AND) operator, 168-170, 323 & (for reference variables), 75 && (logical AND) operator, 86, 326 &= (AND into) operator, 325 ( ) (default class function) operator, 330 overloading, 495 ( ) parentheses with macro parameters, 160 and simple operators, 52 * (dereference) operator, 229, 324 * (multiplication) operator, 52, 323 *= (multiply by) operator, 79, 325 + (addition) operator, 52, 323 + (positive) operator, 324 plus_plus (increment) operator, 79, 80, 325 += (increase) operator, 79, 325 , (comma) operator, 330, 495 (dot) operator, 362 / (division) operator, 52, 58, 323 /* */ comment markers, 36 /= (divide into) operator, 79, 325 :construct, 495 :: (scope) operator, 382, 496 ; (semicolon), 51 with if-else statements, 87 and preprocessor directives, 152 < (less than) operator, 86, 323 << (left shift) operator, 172, 323 << (number-to-character) operator, 256 << (output) operator, 53, 273, 322, 326-329 <<= (shift left) shortcut operator, 325 <= (less than or equal to) operator, 86, 324 = (assignment) operator, 56 for classes, 211 == (equal to) operator, 95 Page 544 = = (equal to) operator, 86, 323 = (assignment) operator, 95 -= (decrease) operator, 79, 325 arrow_operator (class member) operator, 330 > (greater than) operator, 86 arrow_operator (structure pointer) operator, 362 arrow_operator* (pointer to member) operator, 330 >= (greater than or equal to) operator, 86, 324 > (greater than) operator, 323 >> (character-to-number) operator, 260 >> (input) operator, 67, 322, 326-329 >> (right shift) operator, 172, 323 >>= (shift right) shortcut operator, 325 construct, 495 [] (index) operator, 329 as escape character, 59 in preprocessor directives, 152 \0 character, 64, 237 \b (backspace character), 59 \f (form-feed character), 59 \n (newline character), 59 \r (return character), 59 \t (tab character), 59 ^ (exclusive OR) operator, 171, 323 = (exclusive OR into) operator, 325 {} (curly braces), 69, 86 and structures, 187 | (bitwise OR) operator, 171, 323 to merge flags, 265 |= (OR into) operator, 325 | | (logical OR) operator, 86, 326 ~ (bitwise NOT) operator, 171, 324 ~ (tilde) in class destructor names, 206 abstract classes, 393, 458 stat, 461 accuracy of floating-point arithmetic, 347-352 float  double datatypes, 350 add function (for complex numbers), 321 adding complex numbers, 321 element to linked list, 360 floating-point numbers, 344 addition (+) operator, 52, 323 address of (&) operator, 229, 322, 324 addresses, variable, 228 alignment problems and portability, 449 for reference variables, 75 (&&) operator, logical, 86, 326 (&) operator, binary, 168-170, 323 (&=) operator, 325 argc and argv arguments, 241 arguments, command-line, 241 arrays, 63-64 index operator [], 329 infinite, module for (example), 413-429 initializing, 69, 71, 195 multidimensional, 70-71, 141 as parameters, 141 and pointers, 232-237 optimizing, 315 of structures, 195 ASCII characters, 59 assembly language, 10 (=) operator, 56 for classes, 211 == (equal to) operator, 95 statements, 5, 56-57 placement of, 92 author, comments about, 39 auto qualifier, 132 auto variable class, 77 automatic generation of member functions, 210 variables, 132 B as escape character, 59 in preprocessor directives, 152 backspace character (\b), 59 bad member function, 253 Page 545 base classes, 381 initializing, 386 search order, 389 binary files, 260 with multiple structures, 270 binary I/O, 262, 276 binary operators, 322 - (subtraction), 323 % (modulus), 323 & (), 168-170, 323 logical  (&&), 169 * (multiplication), 323 + (addition), 323 / (division), 323 << (left shift), 172, 323 >> (right shift), 172, 323 ^ (exclusive OR), 171, 323 | (OR), 171, 323 to merge flags, 265 ~ (NOT), 171, 324 binary search, debugging, 296 binary trees, 368-373 nodes, 368 recursion with, 371 bit fields, 193 bitmapped graphics, 176-181 bits, 55 operations on, 167-182 muliplication  shifting, 172 setting, clearing, and testing, 173-176 <blank> modifier, 415 blocks, 129 stack of, 131 boldface in comments, 38 Borland Cplus_plus compiler, 15 Makefile for, 104 bottom-up programming, 147 branching statements, 85 if statements, 85-88 switch statements, 120-125 break command (debugger), 292 break statements, 91, 125 in switch statements, 121, 123 browsers, class, 109 byte order and portability, 448 bytes, 55, 167 pad, 450 C %c conversion, 274 C language, 3 binary I O, 276 and Cplus_plus language, 485-491 compiler, 151 conversion routines, 273 I/O (input/output), 270 handling exceptions in, 489 programming tools for, 109 Cplus_plus compiler Borland, 15 gplus_plus, 15 Microsoft Visual, 15 Turbo, 15 UNIX CC.
Since that time he has studied practical ways of writing programs so that the risk of generating a bug is reduced.
He has worked for Motorola and Celerity Computing, and is currently a special consultant for Hewlett Packard, working in the research department of their Ink-Jet division.
Colophon The animal on the cover of Practical Cplus_plus Programming is an Eastern chipmunk, a striped ground squirrel found mostly in eastern North America.
Eastern chipmunks have five dark and two light stripes on their backs, extending from head to rump, and two stripes on their long, bushy tails.
They are distinguished from other ground squirrels by the white stripes above and below their eyes.
The coloration of chipmunks throughout North America varies, but is quite uniform within regions.
Chipmunks often make their homes in sparse forests or farms, where they can build the entrances to their lodges in stone walls, broken trees, or thick underbrush.
The lodges consist of a maze of tunnels leading to a large leaf-lined nest.
Chipmunks spend most of the daylight hours outdoors, but head for their lodges before nightfall.
Although they are excellent climbers, chipmunks live primarily on the ground.
Chipmunks eat nuts, seeds, insects, and occasionally birds' eggs.
Like all ground squirrels, they have large cheek pouches, sometimes extending as far back as their shoulders, in which they can store food.
They collect and store nuts and seeds through the summer and fall.
When the weather starts to get cool, all the chipmunks in a region will suddenly disappear into their lodges where they begin hibernation.
On warm winter days one can often see chipmunk pawprints in the snow, as they will sometimes wake up and leave their lodges for brief periods when the temperature rises.
Mating season for Eastern chipmunks is mid-March to early April.
The gestation period is 31 days, after which a litter of three to six is born.
Baby chipmunks leave the lodge after one month, and are mature by July.
The chipmunk most likely got its name from the noise it makes, which sounds like a loud "cheep_0_" You can occasionally see a chipmunk hanging upside down from a tree branch "cheeping" its call.
Page 584 Edie Freedman designed the cover of this book, using a 19th-century engraving from the Dover Pictorial Archive.
The cover layout was produced with Quark XPress 3_0_3 using the ITC Garamond font.
Whenever possible, our books use RepKover, a durable and flexible lay-flat binding.
If the page count exceeds RepKover's limit, perfect binding is used.
The inside layout was designed by Edie Freedman, with modifications by Nancy Priest, and implemented in FrameMaker by Mike Sierra.
The text and heading fonts are ITC Garamond Light and Garamond Book.
The illustrations that appear in the book were created in Aldus Freehand 5_0_0 by Chris Reilley and Michelle Willey.
This colophon was written by Clairemarie Fisher O'Leary.