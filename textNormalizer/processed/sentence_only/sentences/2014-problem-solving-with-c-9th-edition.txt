Location of VideoNotes in the Text Chapter 10 , Public  Private Members,.
Cplus_plus Walter Savitch University of California, San Diego Contributor Kenrick Mock University of Alaska, Anchorage Boston Columbus Indianapolis New York San Francisco Upper Saddle River Amsterdam Cape Town Dubai London Madrid Milan Munich Paris Montreal Toronto Delhi Mexico City São Paulo Sydney Hong Kong Seoul Singapore Taipei Tokyo Editorial Director: Marcia Horton Acquisitions Editor: Matt Goldstein Program Manager: Kayla Smith-Tarbox Editorial Assistant: Kelsey Loanes Marketing Coordinator: Kathryn Ferranti Production Director: Erin Gregg Managing Editor: Scott Disanno Senior Operations Supervisor: Vincent Scelta Operations Specialist: Linda Sager Cover Designer: Joyce Wells Permissions Manager: Timothy Nicholls Image Permissions Manager: Karen Sanatar Media Producer: Renata Butera Media Project Manager: Wanda Rockwell Full-Service Vendor: Hardik Popli, Cenveo® Publisher Services Composition: Cenveo Publisher Services Printer/Binder: Courier/Westford Cover Printer: Lehigh-Phoenix Color/Hagerstown Credits  acknowledgments borrowed from other sources  reproduced, with permission, in this textbook appear on appropriate page within text.
Microsoft®  Windows® are registered trademarks of the Microsoft Corporation in the The United States of America  other countries.
Screen shots  icons reprinted with permission from the Microsoft Corporation.
This book is not sponsored or endorsed by or affiliated with the Microsoft Corporation.
Copyright © 2015, 2012, 2009, 2007, 2005, 2003 Pearson Education, Inc.
All rights reserved.
Manufactured in the United States of America.
This publication is protected by Copyright,  permission should be obtained from the publisher prior to any prohibited reproduction, storage in a retrieval system, or transmission in any form or by any means, electronic, mechanical, photocopying, recording, or likewise.
To obtain permission(s) to use material from this work, please submit a written request to Pearson Education, Inc_0_, Permissions Department, 501 Boylston Street, Suite 900, Boston, Massachusetts 02116.
Many of the designations by manufacturers  sellers to distinguish their products are claimed as trademarks.
Where those designations appear in this book,  the publisher was aware of a trademark claim, the designations have been printed in initial caps or all caps.
Library of Congress Cataloging-in-Publication Data Savitch, Walter J_0_, 1943Problem solving with Cplus_plus / Walter Savitch ; contributor, Kenrick Mock.
Cplus_plus (Computer program language) 2.
QA76_0_73_0_C153S29 2014 005_0_13'3minus_minusdc23 2013048487 10 9 8 7 6 5 4 3 2 1—CW—15 14 13 12 11 www_0_pearsonhighered_0_com ISBN 10: 0-13-359174-3 ISBN 13: 978-0-13-359174-3 Preface This book is meant  be used in a first course in programming and computer science using the Cplus_plus language.
It assumes no previous programming experience and no mathematics beyond high school algebra.
If you have used the previous edition of this book, you should read the following section that explains the changes  this ninth edition and then you can skip the rest of this preface.
If you are new  this book, the rest of this preface will give you an overview of the book.
Changes  the Ninth Edition This ninth edition presents the same programming philosophy as the eighth edition.
All of the material from the eighth edition remains, but with the following enhancements: ■ End-of-chapter programs are now split into  Programs and  Projects.
Programs require a direct application of concepts presented in the chapter and solutions are usually short.
Programs are appropriate for laboratory exercises.
Projects require additional problem solving and solutions are generally longer than Programs.
Projects are appropriate for homework problems.
Examples of Cplus_plus11 content includes new  types, the auto type, raw string literals, strong enumerations, nullptr, ranged for loop, conversion between strings and integers, member initializers, and constructor delegation.
These walk students through the process of both problem solving and coding  help reinforce key programming concepts.
An icon appears in the margin of the book when a VideoNote is available regarding the topic covered in the text.
If you are an instructor already using the eighth edition, you can continue teach your course almost without change.
Flexibility in Topic Ordering This book was written  allow instructors wide latitude in reordering the material.
To illustrate this flexibility, we suggest two alternative ways  order v.
Preface the topics.
There is no loss of continuity when the book is read in either of these ways.
To ensure this continuity when you rearrange material, you may need  move sections rather than entire chapters.
However, only large sections in convenient locations are moved.
To help customize a particular order for any class's needs, the end of this preface contains a dependency chart, and each chapter has a "Prerequisites" section that explains what material needs be covered before each section in that chapter.
Reordering 1: Earlier Classes To effectively design classes, a student needs some basic tools such as control structures and function definitions.
This basic material is covered in Chapters 1 through 6.
After completing Chapter 6, students can begin  write their own classes.
One possible reordering of chapters that allows for such early coverage of classes is the following: Basics: Chapters 1, 2, 3, 4, 5, and 6.
This material covers all control structures, function definitions, and basic file I/O.
Chapter 3, which covers additional control structures, could be deferred if you wish  cover classes as early as possible.
Classes and namespaces: Chapter 10, Sections 11_0_1 and 11_0_2 of Chapter 11, and Chapter 12.
This material covers defining classes, friends, overloaded operators, and namespaces.
Arrays, strings and vectors: Chapters 7 and 8 Pointers and dynamic arrays: Chapter 9 Arrays in classes: Sections 11_0_3 and 11_0_4 of Chapter 11 Inheritance: Chapter 15 Recursion: Chapter 14 (Alternately, recursion may be moved  later in the Pointers and linked lists: Chapter 13 Any subset of the following chapters may also be used: Exception handling: Chapter 16 Templates: Chapter 17 Standard Template Library: Chapter 18 Reordering 2: Classes Slightly Later but Still Early This version covers all control structures and the basic material on arrays before doing classes, but classes are covered later than the previous ordering and slightly earlier than the default ordering.
This material covers all control structures, function definitions, and the basic file I/O.
Preface Arrays and strings: Chapter 7, Sections 8_0_1 and 8_0_2 of Chapter 8 Classes and namespaces: Chapter 10, Sections 11_0_1 and 11_0_2 of Chapter 11, and Chapter 12.
This material covers defining classes, friends, overloaded operators, and namespaces.
Pointers and dynamic arrays: Chapter 9 Arrays in classes: Sections 11_0_3 and 11_0_4 of Chapter 11 Inheritance: Chapter 15 Recursion: Chapter 14.
It is not even enough for it  be clear and correct when read by an instructor or other experienced programmer.
The material needs  be presented in a way that is accessible  beginning students.
In this introductory textbook, I have endeavored  write in a way that students find clear and friendly.
Reports from the many students who have used the earlier editions of this book confirm that this style makes the material clear and often even enjoyable  students.
ANSI/ISO Cplus_plus Standard This edition is fully compatible with compilers that meet the latest ANSI/ISO Cplus_plus standard.
At the time of this writing the latest standard is Cplus_plus11.
Advanced Topics Many "advanced topics" are becoming part of a standard CS1 course.
Even if they are not part of a course, it is good  have them available in the text as enrichment material.
This book offers a number of advanced topics that can be integrated into a course or left as enrichment topics.
It gives thorough coverage of Cplus_plus templates, inheritance (including virtual functions), exception handling, and the STL (Standard Template Library).
Although this book uses libraries and teaches students the importance of libraries, it does not require any nonstandard libraries.
This book uses only libraries that are provided with essentially all Cplus_plus implementations.
Preface Dependency Chart The dependency chart on the next page shows possible orderings of chapters and subsections.
A line joining two boxes means that the upper box must be covered before the lower box.
Any ordering that is consistent with this partial ordering can be read without loss of continuity.
If a box contains a section number or numbers, then the box refers only to those sections and not to the entire chapter.
Summary Boxes Each major point is summarized in a boxed section.
These boxed sections are spread throughout each chapter.
Self-Test Exercises Each chapter contains numerous Self-Test Exercises at strategic points.
Complete answers for all the Self-Test Exercises are given at the end of each chapter.
VideoNotes VideoNote VideoNotes are designed for teaching students key programming concepts and techniques.
These short step-by-step videos demonstrate how to solve ­problems from design through coding.
VideoNotes ­allow for self-paced ­instruction with easy navigation including the ability to select, play, rewind, fast-forward, and stop within each VideoNote exercise.
Online Practice and Assessment with MyProgrammingLab MyProgrammingLab helps students fully grasp the logic, semantics, and syntax of programming.
Through practice exercises and immediate, personalized feedback, MyProgrammingLab improves the programming competence of beginning students who often struggle with the basic concepts and paradigms of popular high-level programming languages.
A self-study and homework tool, a MyProgrammingLab course consists of hundreds of small practice problems organized around the structure of this textbook.
For students, the system automatically detects errors in the logic and syntax of their code submissions and offers targeted hints that enable students to figure out what went wrong—and why.
For instructors, a comprehensive gradebook tracks correct and incorrect answers and stores the code inputted by students for review.
MyProgrammingLab is offered to users of this book in partnership with Turing's Craft, the makers of the CodeLab interactive programming exercise system.
For a full demonstration, to see feedback from instructors and students, or to get started using MyProgrammingLab in your course, visit www_0_myprogramminglab_0_com.
Preface DISPLAY P_0_1   Dependency Chart Chapter 1 Introduction Chapter 2 Cplus_plus Basics Chapter 4 Functions 1 Chapter 5 Functions 2 Chapter 3 More Flow of Control Chapter 7 Arrays 7_0_1–7_0_3 Chapter 6 I/O Streams Chapter 14 Recursion Chapter 10 Classes 1 Chapter 7 7_0_4 MultiDimensional Arrays Chapter 11 Classes 2 11_0_1–11_0_2 Chapter 8 Strings and Vectors *Chapter 16 Exception Handling Chapter 12 Separate ­Compilation & Namespaces Chapter 11 11_0_3 Classes & Arrays Chapter 9 Pointers and Dynamic Arrays Chapter 11 11_0_4 Classes & Dynamic Arrays Chapter 13 Pointers and Linked Lists Chapter 15 Inheritance Chapter 17 Templates *Chapter 16 contains occasional references to derived classes, but those references can be omitted Chapter 18 STL ix.
Preface Support Material There is support material available to all users of this book and additional material available only to qualified instructors.
Materials Available to All Users of this Book ■ ■ ■ Source Code from the book PowerPoint slides VideoNotes To access these materials, go to: www_0_pearsonhighered_0_com/savitch Resources Available to Qualified Instructors Only Visit Pearson Education's instructor resource center at www_0_pearsonhighered _0_com/irc to access the following instructor resources: ■ Instructor's Resource Guide—including chapter-by-chapter teaching hints, quiz questions with solutions, and solutions to many programming projects ■ Test Bank and Test Generator ■ PowerPoint Lectures—including programs and art from the text ■ Lab Manual Integrated Development Environment (IDE) Resource Kits Instructors who adopt this text can order it for students with a kit containing five popular Cplus_plus IDEs (Microsoft® Visual Studio 2013 Express Edition, Dev Cplus_plus, NetBeans, Eclipse, and CodeLite) and access to a Web site containing written and video tutorials for getting started in each IDE.
For ordering information, please contact your campus Pearson Education representative.
Contact Us Your comments, suggestions, questions, and corrections are always welcome.
Please e-mail them to savitch_0_programming_0_cpp@gmail_0_com Acknowledgments Numerous individuals and groups have provided me with suggestions, discussions, and other help in preparing this textbook.
Much of the first edition of this book was written while I was visiting the Computer Science Department at the University of Colorado in Boulder.
The remainder of the writing on the first edition and the work on subsequent editions was done in the Computer Science and Engineering Department at the University of California, San Diego (UCSD).
I am grateful to these institutions for providing a conducive environment for teaching this material and writing this book.
Preface I extend a special thanks to all the individuals who have contributed critiques or programming projects for this or earlier editions and drafts of this book.
In alphabetical order, they are: Alex Feldman, Amber Settle, Andrew Burt, Andrew Haas, Anne Marchant, Barney MacCabe, Bob Holloway, Bob Matthews, Brian R.
King, Bruce Johnston, Carol Roberts, Charles Dowling, Claire Bono, Cynthia Martincic, David Feinstein, David Teague, Dennis Heckman, Donald Needham, Doug Cosman, Dung Nguyen, Edward Carr, Eitan M.
Gurari, Ethan Munson, Firooz Khosraviyani, Frank Moore, Gilliean Lee, Huzefa Kagdi, James Stepleton, Jeff Roach, Jeffrey Watson, Jennifer Perkins, Jerry Weltman, Joe Faletti, Joel Cohen, John J.
Westman, John Marsaglia, John Russo, Joseph Allen, Joseph D.
Oldham, Jerrold Grossman, Jesse Morehouse, Karla Chaveau, Ken Rockwood, Larry Johnson, Len Garrett, Linda F.
Wilson, Mal Gunasekera, Marianne Lepp, Matt Johnson, Michael Keenan, Michael Main, Michal Sramka, Naomi Shapiro, Nat Martin, Noah Aydin, Nisar Hundewale, Paul J.
Kaiser, Paul Kube, Paulo Franca, Richard Borie, Scot Drysdale, Scott Strong, Sheila Foster, Steve Mahaney, Susanne Sherba, Thomas Judson, Walter A.
Manrique, Wei Lian Chen, and Wojciech Komornicki.
I extend a special thanks to the many instructors who used early editions of this book.
Their comments provided some of the most helpful reviewing that the book received.
Finally, I thank Kenrick Mock who implemented the changes in this edition.
He had the almost impossible task of pleasing me, my editor, and his own sensibilities, and he did a superb job of it.
Walter Savitch xi.
To improving results get with the programming Through the power of practice and immediate personalized feedback, MyProgrammingLab improves your performance.
Learn more at www_0_myprogramminglab_0_com Brief Contents Table of Location of VideoNotes Inside front cover and inside back cover Chapter 1 Introduction to Computers and Cplus_plus Programming 1.
Chapter 6 I/O Streams as an Introduction to Objects and Classes 251.
Pointers and Dynamic Arrays 377 451 507 Chapter 10 Defining Classes 541 Chapter 11 Friends, Overloaded Operators, and Arrays in Classes xiv.
Brief Contents Chapter 12 Separate Compilation and Namespaces 703 Chapter 13 Pointers and Linked Lists 739 Chapter 14 Recursion 789 Chapter 15 Inheritance 833 Chapter 16 Exception Handling 893 Chapter 17 Templates 925 Chapter 18 Standard Template Library 957 Appendices 1 2 3 4 5 6 Cplus_plus Keywords.
Contents Table of Location of VideoNotes Inside front cover and inside back cover Chapter 1 Introduction to Computers and Cplus_plus Programming 1.
Contents Chapter Summary 32 Answers to Self-Test Exercises Practice Programs 35 Programming Projects 36 Chapter 2.
Contents Global Constants and Global Variables 221 Call-by-Value Formal Parameters Are Local Variables 224 Block Scope 226 Namespaces Revisited 227.
Contents Chapter Summary 360 Answers to Self-Test Exercises 361 Practice Programs 368 Programming Projects 370 Chapter 7.
Contents Chapter Summary 432 Answers to Self-Test Exercises Practice Programs 437 Programming Projects 439 Chapter 8.
Efficiency Issues 493 Chapter Summary 495 Answers to Self-Test Exercises Practice Programs 497 Programming Projects 498 Chapter 9.
Contents Copy Constructors 675 Overloading the Assignment Operator 680 Chapter Summary 683 Answers to Self-Test Exercises 683 Practice Programs 693 Programming Projects 694 Chapter 12.
Contents Pointers as Iterators 755 Inserting and Removing Nodes Inside a List 755 Pitfall: Using the Assignment Operator with Dynamic Data Structures 757 Variations on Linked Lists 760 Linked Lists of Classes 762 13_0_2 Stacks and Queues  765 Stacks 765 Programming Example: A Stack 766 Queues 771 Programming Example: A Queue Class Chapter Summary 776 Answers to Self-Test Exercises Practice Programs 779 Programming Projects 780 Chapter 14.
Standard Template Library 18_0_1 Iterators  959 using Declarations 942.
Contents Programming Tip: Use auto to Simplify Variable Declarations 964 Pitfall: Compiler Problems 964 Kinds of Iterators 966 Constant and Mutable Iterators 970 Reverse Iterators 971 Other Kinds of Iterators 972.
As soon as an Analytical Engine exists, it will necessarily guide the future course of science.
Introduction In this chapter we describe the basic components of a computer, as well as the basic technique for designing and writing a program.
We then show you a sample Cplus_plus program and describe how it works.
The collection of programs used by a computer is referred to as the software for that computer.
The actual physical machines that make up a computer installation are referred to as hardware.
As we will see, the hardware for a computer is conceptually very simple.
However, computers now come with a large array of software to aid in the task of programming.
This software includes editors, translators, and managers of various sorts.
The resulting environment is a complicated and powerful system.
In this book we are concerned almost exclusively with software, but a brief overview of how the hardware is organized will be useful.
Hardware There are three main classes of computers: PCs, workstations, and mainframes.
A PC (personal computer) is a relatively small computer designed to be used by one person at a time.
Most home computers are PCs, but PCs are also widely used in business, industry, and science.
A workstation is essentially a PC.
A mainframe is an even larger computer that typically requires some support staff and generally is shared by more than one user.
The distinctions between PCs, workstations, and mainframes are not precise, but the terms are commonly used and do convey some very general information about a computer.
A network consists of a number of computers connected so that they may share resources such as printers and may share information.
A network might contain a number of workstations and one or more mainframes, as well as shared devices such as printers.
For our purposes in learning programming, it will not matter whether you are working on a PC, a mainframe, or a workstation.
The basic configuration of the computer, as we will view it, is the same for all three types of computers.
The computer can be thought of as having five main components: the input device(s), the output device(s), the processor (also called the CPU, for central processing unit), the main memory, and the secondary memory.
The processor, main memory, and secondary memory are normally housed in a single cabinet.
The processor and main memory form the heart of a computer and can be thought of as an integrated unit.
Other components connect to the main memory and operate under the direction of the processor.
The arrows in Display 1_0_1 indicate the direction of information flow.
An input device is any device that allows a person to communicate information to the computer.
Your primary input devices are likely to be a keyboard and a mouse.
An output device is anything that allows the computer to communicate information to you.
The most common output device is a display screen, referred to as a monitor.
Quite often, there is more than one output device.
For example, in addition to the monitor, your computer probably is connected to a printer for producing output on paper.
The keyboard and monitor are sometimes thought of as a single unit called a terminal.
Display 1_0_1   Main Components of a Computer.
Chapter 1 / Introduction to Computers and Cplus_plus Programming In order to store input and to have the equivalent of scratch paper for performing calculations, computers are provided with memory.
The program that the computer executes is also stored in this memory.
A computer has two forms of memory, called main memory and secondary memory.
The program that is being executed is kept in main memory, and main memory is, as the name implies, the most important memory.
Main memory consists of a long list of numbered locations called memory locations; the number of memory locations varies from one computer to another, ranging from a few thousand to many millions, and sometimes even into the billions.
Each memory location contains a string of 0s and 1s.
The contents of these locations can change.
Hence, you can think of each memory location as a tiny blackboard on which the computer can write and erase.
In most computers, all memory locations contain the same number of zero/one digits.
A digit that can assume only the values 0 or 1 is called a binary digit or a bit.
The memory locations in most computers contain eight bits (or some multiple of eight bits).
An eightbit portion of memory is called a byte, so we can refer to these numbered memory locations as bytes.
To rephrase the situation, you can think of the computer's main memory as a long list of numbered memory locations called bytes.
The number that identifies a byte is called its address.
A data item, such as a number or a letter, can be stored in one of these bytes, and the address of the byte is then used to find the data item when it is needed.
In this case, the entire chunk of memory that holds the data item is still called a memory location.
The address of the first of the bytes that make up this memory location is used as the address for this larger memory location.
Thus, as a practical matter, you can think of the computer's main memory as a long list of memory locations of varying sizes.
The size of each of these locations is expressed in bytes and the address of the first byte is used as the address (name) of that memory location.
Display 1_0_2 shows a picture of a hypothetical computer's main memory.
The sizes of the memory locations are not fixed, but can change when a new  is run on the computer.
Bytes and Addresses Main memory is divided into numbered locations called bytes.
The number associated with a byte is called its address.
A group of consecutive bytes is used as the location for a data item, such as a number or letter.
The address of the first byte in the group is used as the address of this larger memory location.
The fact that the information in a computer's memory is represented as 0s and 1s need not be of great concern to you when programming in Cplus_plus 1_0_1 Computer Systems Display 1_0_2   Memory Locations and Bytes byte 1 byte 2 byte 3 byte 4 byte 5 byte 6 byte 7 byte 8 byte 9 3 byte location with address 1 2 byte location with address 4 1 byte location with address 6 3 byte location with address 7 (or in most other programming languages).
There is, however, one point about this use of 0s and 1s that will concern us as soon as we start to write programs.
The computer needs to interpret these strings of 0s and 1s as numbers, letters, instructions, or other types of information.
The computer performs these interpretations automatically according to certain coding schemes.
A different code is used for each different type of item that is stored in the computer's memory: one code for letters, another for whole numbers, another for fractions, another for instructions, and so on.
For example, in one commonly used set of codes, 01000001 is the code for the letter A and also for the number 65.
In order to know what the string 01000001 in a particular location stands for, the computer must keep track of which code is currently being used for that location.
Fortunately, the programmer seldom needs to be concerned with such codes and can safely reason as though the locations actually contained letters, numbers, or whatever is desired.
A byte is a memory location that can hold eight bits.
There are two reasons why eight is special.
First, eight is a power of 2.
Second, it turns out that eight bits (one byte) are required to code a single character (such as a letter or other keyboard symbol).
Chapter 1 / Introduction to Computers and Cplus_plus Programming The memory we have been discussing up until now is the main memory.
Without its main memory, a computer can do nothing.
However, main memory is only used while the computer is actually following the instructions in a.
The computer also has another form of memory called secondary memory or secondary storage.
Some alternative terms that are commonly used to refer to secondary memory are auxiliary memory, auxiliary storage, external memory, and external storage.
Information in secondary storage is kept in units called files, which can be as large or as small as you like.
A , for example, is stored in a file in secondary storage and copied into main memory when the  is run.
You can store a , a letter, an inventory list, or any other unit of information in a file.
Several different kinds of secondary memory can be attached to a single computer.
The most common forms of secondary memory are hard disks, diskettes, CDs, DVDs, and removable flash memory drives.
CDs and DVDs for computers can be read-only so that your computer can read, but cannot change, the data on the disc; CDs and DVDs for computers can also be read/ write, which can have their data changed by the computer.
Hard disks are fixed in place and are normally not removed from the disk drive.
Diskettes and CDs can be easily removed from the disk drive and carried to another computer.
Diskettes and CDs have the advantages of being inexpensive and portable, but hard disks hold more data and operate faster.
Flash drives have largely replaced diskettes today and store data using a type of memory called flash memory.
Unlike main memory, flash memory does not require power to maintain the information stored on the device.
Other forms of secondary memory are also available, but this list covers most forms that you are likely to encounter.
Main memory is often referred to as RAM or random access memory.
It is called random access because the computer can immediately access the data in any memory location.
Secondary memory often requires sequential access, memory locations until it finds the item it needs.
The processor (also known as the central processing unit, or CPU) is the "brain" of the computer.
When a computer is advertised, the computer company tells you what chip it contains.
The chip is the processor.
The processor follows the instructions in a program and performs the calculations specified by the program.
The processor is, however, a very simple brain.
All it can do is follow a set of simple instructions provided by the programmer.
Typical processor instructions say things like "Interpret the 0s and 1s as numbers, and then add the number in memory location 37 to the number in memory location 59, and 1_0_1 Computer Systems put the answer in location 43," or "Read a letter of input, convert it to its code as a string of 0s and 1s, and place it in memory location 1298_0_" The processor can add, subtract, multiply, and divide and can move things from one memory location to another.
It can interpret strings of 0s and 1s as letters and send the letters to an output device.
The processor also has some primitive ability to rearrange the order of instructions.
Processor instructions vary somewhat from one computer to another.
The processor of a modern computer can have as many as several hundred available instructions.
However, these instructions are typically all about as simple as those we have just described.
Software You do not normally talk directly to the computer, but communicate with it through an operating system.
The operating system allocates the computer's resources to the different tasks that the computer must accomplish.
The operating system is actually a program, but it is perhaps better to think of it as your chief servant.
It is in charge of all your other servant programs, and it delivers your requests to them.
If you want to run a program, you tell the operating system the name of the file that contains it, and the operating system runs the program.
If you want to edit a file, you tell the operating system the name of the file and it starts up the editor to work on that file.
To most users, the operating system is the computer.
Most users never see the computer without its operating system.
The names of some common operating systems are UNIX, DOS, Linux, Windows, Mac OS, iOS, and Android.
A program is a set of instructions for a computer to follow.
As shown in Display 1_0_3, the input to a computer can be thought of as consisting of two parts, a program and some data.
The computer follows the instructions in the program and in that way performs some process.
The data is what we conceptualize as the input to the program.
For example, if the program adds two numbers, then the two numbers are the data.
In other words, the data is the input to the program, and both the program and the data are input to the computer (usually via the operating system).
Whenever we give a computer Display 1_0_3 Simple View of Running a Program Program Data.
Chapter 1 / Introduction to Computers and Cplus_plus Programming both a program to follow and some data for the program, we are said to be running the program on the data, and the computer is said to execute the program on the data.
The word data also has a much more general meaning than the one we have just given it.
In its most general sense, it means any information available to the computer.
The word is commonly used in both the narrow sense and the more general sense.
High-Level Languages There are many languages for writing programs.
In this text we will discuss the Cplus_plus programming language and use it to write our programs.
Cplus_plus is a high-level language, as are most of the other programming languages you are likely to have heard of, such as C, C#, Java, Python, PHP, Pascal, Visual Basic, FORTRAN, COBOL, Lisp, Scheme, and Ada.
High-level languages resemble human languages in many ways.
They are designed to be easy for human beings to write programs in and to be easy for human beings to read.
A high-level language, such as Cplus_plus, contains instructions that are much more complicated than the simple instructions a computer's processor (CPU) is capable of following.
The kind of language a computer can understand is called a lowlevel language.
The exact details of low-level languages differ from one kind of computer to another.
A typical low-level instruction might be the following: ADD X Y Z This instruction might mean "Add the number in the memory location called X to the number in the memory location called Y, and place the result in the memory location called Z_0_" The above sample instruction is written in what is called assembly language.
Although assembly language is almost the same as the language understood by the computer, it must undergo one simple translation before the computer can understand it.
In order to get a computer to follow an assembly language instruction, the words need to be translated into strings of 0s and 1s.
For example, the word ADD might translate to 0110, the X might translate to 1001, the Y to 1010, and the Z to 1011.
The version of the instruction above that the computer ultimately follows would then be: 0110 1001 1010 1011 Assembly language instructions and their translation into 0s and 1s differ from machine to machine.
Programs written in the form of 0s and 1s are said to be written in machine language, because that is the version of the program that the computer (the machine) actually reads and follows.
Assembly language and machine language are almost the same thing, and the distinction between them will not be important to us.
The important distinction is that between 1_0_1 Computer Systems machine language and high-level languages like Cplus_plus: Any high-level language program must be translated into machine language before the computer can understand and follow the program.
Compilers A program that translates a high-level language like Cplus_plus to a machine language is called a compiler.
A compiler is thus a somewhat peculiar sort of program, in that its input or data is some other program, and its output is yet another program.
To avoid confusion, the input program is usually called the source program or source code, and the translated version produced by the compiler is called the object program or object code.
The word code is frequently used to mean a program or a part of a program, and this usage is particularly common when referring to object programs.
Now, suppose you want to run a Cplus_plus program that you have written.
In order to get the computer to follow your Cplus_plus instructions, proceed as follows.
First, run the compiler using your Cplus_plus program as data.
Notice that in this case, your Cplus_plus program is not being treated as a set of instructions.
To the compiler, your Cplus_plus program is just a long string of characters.
The output will be another long string of characters, which is the machine-language equivalent of your Cplus_plus program.
Next, run this machine-language program on what we normally think of as the data for the Cplus_plus program.
The output will be what we normally conceptualize as the output of the Cplus_plus program.
The basic process is easier to visualize if you have two computers available, as diagrammed in Display 1_0_4.
In reality, the entire process is accomplished by using one computer two times.
Compiler A compiler is a program that translates a high-level language program, such as a Cplus_plus program, into a machine-language program that the computer can directly understand and execute.
The complete process of translating and running a Cplus_plus program is a bit more complicated than what we show in Display 1_0_4.
Any Cplus_plus program that have already been programmed for you.
These items that are already programmed for you (like input and output routines) are already compiled and have their object code waiting to be combined with your program's object code to produce a complete machine-language program that can be run on the computer.
Another program, called a linker, combines the object code for these program pieces with the object code that the compiler produced 9.
Chapter 1 / Introduction to Computers and Cplus_plus Programming from your Cplus_plus program.
The interaction of the compiler and the linker are diagrammed in Display 1_0_5.
In routine cases, many systems will do this linking for you automatically.
Thus, you may not need to worry about linking in many cases.
Linking The object code for your Cplus_plus program must be combined with the object code for routines (such as input and output routines) that your program uses.
This process of combining object code is called linking and is done by a program called a linker.
For simple programs, linking may be done for you automatically.
Cplus_plus program Data for Cplus_plus program Compiler.
Computer Output of Cplus_plus program 1_0_1 Computer Systems Display 1_0_5  Preparing a Cplus_plus Program for Running Cplus_plus program Compiler.
What are the five main components of a computer.
What would be the data for a program to add two numbers.
What would be the data for a program that assigns letter grades to students in a class.
What is the difference between a machine-language program and a highlevel language program.
What is the role of a compiler.
What is a source program.
What is an object program.
What is an operating system.
What purpose does the operating system serve.
Chapter 1 / Introduction to Computers and Cplus_plus Programming 9.
Name the operating system that runs on the computer you use to prepare programs for this course.
Find out whether linking is done automatically by the compiler you use for this course.
It can do whatever we know how to order it to perform.
It can follow analysis; but it has no power of anticipating any analytical relations or truths.
Its province is to assist us in making available what we are already acquainted with.
History Note Charles Babbage, Ada Augusta The first truly programmable computer was designed by Charles Babbage, an English mathematician and physical scientist.
Babbage began the project sometime before 1822 and worked on it for the rest of his life.
Although he never completed the construction of his machine, the design was a conceptual milestone in the history of computing.
Much of what we know about Charles Babbage and his computer design comes from the writings of his colleague Ada Augusta, the Countess of Lovelace and the daughter of the poet Byron.
Ada Augusta is frequently given the title of the first computer programmer.
Her comments, quoted in the opening of the this section, still apply to the process of solving problems on a computer.
Computers are not magic and do not, at least as yet, have the ability to formulate sophisticated solutions to all the problems we encounter.
Computers simply do what the programmer orders them to do.
The solutions to problems are carried out by the computer, but the solutions are formulated by the programmer.
Our discussion of computer programming begins with a discussion of how a programmer formulates these solutions.
In this section we describe some general principles that you can use to design and write programs.
They apply no matter what programming language you are using.
Algorithms When learning your first programming language, it is easy to get the impression that the hard part of solving a problem on a computer is translating your ideas into the specific language that will be fed into the computer.
This definitely is not the case.
The most difficult part of solving a problem on a computer is discovering the method of solution.
After you come up with a method of solution, it is routine to translate your method into the required language, be it Cplus_plus or some other programming language.
It is therefore helpful to temporarily ignore the programming language and to concentrate instead on formulating the steps of the solution and writing them down in plain English, as if the instructions were to be given to a human being rather than a computer.
A sequence of instructions expressed in this way is frequently referred to as an algorithm.
A sequence of precise instructions which leads to a solution is called an algorithm.
Some approximately equivalent words are recipe, method, 1_0_2 Programming and Problem-Solving Charles Babbage A model of Babbage's computer Ada Augusta, Countess of Lovelace and the first computer programmer directions, procedure, and routine.
The instructions may be expressed in a programming language or a human language.
Our algorithms will be expressed in English and in the programming language Cplus_plus.
A computer program is simply an algorithm expressed in a language that a computer can understand.
Thus, the term algorithm is more general than the term program.
However, when we say that a sequence of instructions is an algorithm, we usually mean that the instructions are expressed in English, since if they were expressed in a programming language we would use the more specific term program.
An example may help to clarify the concept.
Display 1_0_6 contains an algorithm expressed in English.
The algorithm determines the number of times a specified name occurs on a list of names.
If the list contains the winners of each of last season's football games and the name is that of your favorite team, then the algorithm determines how many games your team won.
The algorithm is short and simple but is otherwise very typical of the algorithms with which we will be dealing.
Chapter 1 / Introduction to Computers and Cplus_plus Programming Display 1_0_6  An Algorithm Algorithm that determines how many times a name occurs in a list of names: 1.
Get the list of names.
Get the name being checked.
Set a counter to zero.
Do the following for each name on the list: Compare the name on the list to the name being checked, and if the names are the same, then add one to the counter.
Announce that the answer is the number indicated by the counter.
The instructions numbered 1 through 5 in our sample algorithm are meant to be carried out in the order they are listed.
Unless otherwise specified, we will always assume that the instructions of an algorithm are carried out in the order in which they are given (written down).
Most interesting algorithms do, however, specify some change of order, usually a repeating of some instruction again and again such as in instruction 4 of our sample algorithm.
The word algorithm has a long history.
It derives from the name alKhowarizmi, a ninth-century Persian mathematician and astronomer.
He wrote a famous textbook on the manipulation of numbers and equations.
The book was entitled Kitab al-jabr w'almuqabala, which can be translated as Rules for Reuniting and Reducing.
The similar-sounding word algebra was derived from the Arabic word al-jabr, which appears in the title of the book and which is often translated as reuniting or restoring.
The meanings of the words algebra and algorithm used to be much more intimately related than they are today.
Indeed, until modern times, the word algorithm usually referred only to algebraic rules for solving numerical equations.
Today, the word algorithm can be applied to a wide variety of kinds of instructions for manipulating symbolic as well as numeric data.
The properties that qualify a set of instructions as an algorithm now are determined by the nature of the instructions rather than by the things manipulated by the instructions.
To qualify as an algorithm, a set of instructions must completely and unambiguously specify the steps to be taken and the order in which they are taken.
The person or machine carrying out the algorithm does exactly what the algorithm says, neither more nor less.
Algorithm An algorithm is a sequence of precise instructions that leads to a solution.
There is no complete set of rules, no algorithm to tell you how to write programs.
Program design is a creative process.
Still, there is the outline of a plan to follow.
The outline is given in diagrammatic form in Display 1_0_7.
As indicated there, the entire program design process can be divided into two phases, the problem-solving phase and the implementation phase.
The result of the problem-solving phase is an algorithm, expressed in English, for solving the problem.
To produce a program in a programming language such as Cplus_plus, the algorithm is translated into the programming language.
Producing the final program from the algorithm is called the implementation phase.
The first step is to be certain that the task—what you want your program to do—is completely and precisely specified.
Do not take this step lightly.
If you do not know exactly what you want as the output of your program, you may be surprised at what your program produces.
Be certain that you know what the input to the program will be and exactly what information is supposed to be in the output, as well as what form that information should be in.
For example, if the program is a bank accounting program, you must know not only the interest rate but also whether interest is to be compounded annually, monthly, daily, or whatever.
If the program is supposed to write poetry, you need to determine whether the poems can be in free verse or must be in iambic pentameter or some other meter.
Many novice programmers do not understand the need to design an algorithm before writing a program in a programming language, such as Cplus_plus, and so they try to short-circuit the process by omitting the problemsolving phase entirely, or by reducing it to just the problem-definition part.
Why not "go for the mark" and save time.
The answer is that it does not save time.
Experience has shown that the two-phase process will produce a correctly working program faster.
The two-phase process simplifies the algorithm design phase by isolating it from the detailed rules of a programming language such as Cplus_plus.
The result is that the algorithm design process becomes much less intricate and much less prone to error.
For even a modest-size program, it can represent the difference between a half day of careful work and several frustrating days of looking for mistakes in a poorly understood program.
The implementation phase is not a trivial step.
There are details to be concerned about, and occasionally some of these details can be subtle, but it is much simpler than you might at first think.
Once you become familiar with Cplus_plus or any other programming language, the translation of an algorithm from English into the programming language becomes a routine task.
As indicated in Display 1_0_7, testing takes place in both phases.
Before the program is written, the algorithm is tested, and if the algorithm is found to be deficient, then the algorithm is redesigned.
That desktop testing is performed by mentally going through the algorithm and executing the steps yourself.
Chapter 1 / Introduction to Computers and Cplus_plus Programming Display 1_0_7  Program Design Process Problem-solving phase Start Implementation phase Problem definition Algorithm design Translating to Cplus_plus Desktop testing Testing Working program For large algorithms this will require a pencil and paper.
The Cplus_plus program is tested by compiling it and running it on some sample input data.
The compiler will give error messages for certain kinds of errors.
To find other types of errors, you must somehow check to see whether the output is correct.
The process diagrammed in Display 1_0_7 is an idealized picture of the program design process.
It is the basic picture you should have in mind, but reality is sometimes more complicated.
In reality, mistakes and deficiencies are discovered at unexpected times, and you may have to back up and redo an earlier step.
For example, as shown in Display 1_0_7, testing the algorithm might reveal that the definition of the problem was incomplete.
In such a case you must back up and reformulate the definition.
Occasionally, deficiencies in the definition or algorithm may not be observed until a program is tested.
In that case you must back up and modify the problem definition or algorithm and all that follows them in the design process.
Object-Oriented Programming The program design process that we outlined in the previous section represents a program as an algorithm (set of instructions) for manipulating some data.
That is a correct view, but not always the most productive view.
Modern programs are usually designed using a method known as objectoriented programming, or OOP.
In OOP, a program is viewed as a collection 1_0_2 Programming and Problem-Solving of interacting objects.
The methodology is easiest to understand when the program is a simulation program.
For example, for a program to simulate a highway interchange, the objects might represent the automobiles and the lanes of the highway.
Each object has algorithms that describe how it should behave in different situations.
Programming in the OOP style consists of designing the objects and the algorithms they use.
When programming in the OOP framework, the term Algorithm design in Display 1_0_7 would be replaced with the phrase Designing the objects and their algorithms.
The main characteristics of OOP are encapsulation, inheritance, and polymorphism.
Encapsulation is usually described as a form of information hiding or abstraction.
That description is correct, but perhaps an easierto-understand characterization is to say that encapsulation is a form of simplification of the descriptions of objects.
Inheritance has to do with writing reusable program code.
Polymorphism refers to a way that a single name can have multiple meanings in the context of inheritance.
Having made those statements, we must admit that they hold little meaning for readers who have not heard of OOP before.
However, we will describe all these terms in detail later in this book.
Cplus_plus accommodates OOP by providing classes, a kind of data type combining both data and algorithms.
The Software Life Cycle Designers of large software systems, such as compilers and operating systems, divide the software development process into six phases collectively known as the software life cycle.
The six phases of this life cycle are: 4.
Maintenance and evolution of the system 6.
Obsolescence We did not mention the last two phases in our discussion of  design because they take place after the  is finished and put into service.
However, they should always be kept in mind.
You will not be able to add improvements or corrections to your  unless you design it to be easy to read and easy to change.
Designing programs so that they can be easily modified is an important topic that we will discuss in detail when we have developed a bit more background and a few more programming techniques.
The meaning of obsolescence is obvious, but it is not always easy to accept.
When a  is not working as it should and cannot be fixed with a reasonable amount of effort, it should be discarded and replaced with a completely new.
Chapter 1 / Introduction to Computers and Cplus_plus Programming Se l f-T es t Exe r cise s 12.
An algorithm is approximately the same thing as a recipe, but some kinds of steps that would be allowed in a recipe are not allowed in an algorithm.
Which steps in the following recipe would be allowed in an algorithm.
Place 2 teaspoons of sugar in mixing bowl.
Add 1 egg to mixing bowl.
Add 1 cup of milk to mixing bowl.
Add 1 ounce of rum, if you are not driving.
Add vanilla extract to taste.
Beat until smooth.
Pour into a pretty glass.
Sprinkle with nutmeg.
What is the first step you should take when creating a.
The  design process can be divided into two main phases.
In this section we introduce you to the Cplus_plus programming language, which is the programming language used in this book.
Origins of the Cplus_plus Language The first thing that people notice about the Cplus_plus language is its unusual name.
Are there programming languages named A and B.
The answer to most of these questions is no.
But the general thrust of the questions is on the mark.
There is a B programming language; it was not derived from a language called A, but from a language called BCPL.
The C language was derived from the B language, and Cplus_plus was derived from the C language.
Why are there two pluses in the name Cplus_plus.
As you will see in the next chapter, plus_plus is an operation in the C and Cplus_plus languages, so using plus_plus produces a nice pun.
The languages BCPL and B do not concern us.
They are earlier versions of the C programming language.
We will start our description of the Cplus_plus programming language with a description of the C language.
The C programming language was developed by Dennis Ritchie of AT&T Bell Laboratories in the 1970s.
It was first used for writing and maintaining the 1_0_3 Introduction to Cplus_plus UNIX operating system.
If you wanted to maintain your UNIX system, you needed to use C.
C and UNIX fit together so well that soon not just systems programs, but almost all commercial programs that ran under UNIX were written in the C language.
C became so popular that versions of the language were written for other popular operating systems; its use is not limited to computers that use UNIX.
However, despite its popularity, C is not without its shortcomings.
The C language is peculiar because it is a high-level language with many of the features of a low-level language.
C is somewhere in between the two extremes of a very high level language and a low-level language, and therein lies both its strengths and its weaknesses.
Like (low-level) assembly language, C language programs can directly manipulate the computer's memory.
On the other hand, C has many features of a high-level language, which makes it easier to read and write than assembly language.
This makes C an excellent choice for writing systems programs, but for other programs (and in some sense even for systems programs), C is not as easy to understand as other languages; also, it does not have as many automatic checks as some other high-level languages.
To overcome these and other shortcomings of C, Bjarne Stroustrup of AT&T Bell Laboratories developed Cplus_plus in the early 1980s.
Stroustrup designed Cplus_plus to be a better C.
Most of C is a subset of Cplus_plus, and so most C programs are also Cplus_plus programs.
The Cplus_plus language continues to evolve.
Major new  were added in 2011.
This version is referred to as Cplus_plus11.
Minor  are expected in 2014 and major again in 2017.
A Sample Cplus_plus Program Display 1_0_8 contains a simple Cplus_plus  and the screen display that might be generated when a user runs and interacts with this.
The person who runs a  is called the user.
The output when the  is run is shown in the Sample Dialogue.
The text typed in by the user is shown in color to distinguish it from the text output by the.
On the actual screen both texts would look alike.
The source code for the  is shown in lines 1–22.
The line numbers are shown only for reference.
You would not type in the line numbers when entering the.
Keywords with a predefined meaning in Cplus_plus are shown in color.
These keywords are discussed in Chapter 2.
The person who writes the  is called the programmer.
Do not confuse the roles of the user and the programmer.
The user and the programmer might or might not be the same person.
For example, if you write and then run a , you are both the programmer and the user.
With professionally produced programs, the programmer (or programmers) and the user are usually different persons.
Chapter 1 / Introduction to Computers and Cplus_plus Programming Display 1_0_8 A Sample Cplus_plus Program 1.
Sample Dialogue Press return after entering a number.
Enter the number of pods: 10 Enter the number of peas in a pod: 9 If you have 10 pea pods and 9 peas in each pod, then you have 90 peas in all the pods.
In the next chapter we will explain in detail all the Cplus_plus  you need to write programs like the one in Display 1_0_8, but to give you a feel for how a Cplus_plus program works, we will now provide a brief description of how this particular program works.
If some of the details are a bit unclear, do not worry.
In this section we just want to give you a feel for what a Cplus_plus program is.
The beginning and end of our sample program contain some details that need not concern us yet.
The program begins with the following lines:.
We will briefly describe these lines, starting with the following line: int number_of_pods, peas_per_pod, ; This line is called a variable declaration.
This variable declaration tells the computer that number_of_pods, peas_per_pod, and  will be used as names for three variables.
Variables will be explained more precisely in the next chapter, but it is easy to understand how they are used in this program.
In this program the variables are used to name numbers.
The word that starts this line, int, is an abbreviation for the word integer and it tells the computer that the numbers named by these variables will be integers.
An integer is a whole number, like 1, 2, −1, −7, 0, 205, −103, and so forth.
The remaining lines are all instructions that tell the computer to do something.
These instructions are called statements or executable statements.
In this program each statement fits on exactly one line.
That need not be true, but for very simple programs, statements are usually listed one per line.
Most of the statements begin with either the word cin or.
These statements are input statements and output statements.
The word cin, which is pronounced "see-in," is used for input.
The statements that begin with cin tell the computer what to do when information is entered from the keyboard.
The word , which is pronounced "see-out," is used for output, that is, for sending information from the program to the terminal screen.
The letter c is there because the language is Cplus_plus.
The arrows, written << or >>, tell you the direction that data is moving.
The arrows, << and >>, are called 'insert' and 'extract,' or 'put to' and 'get from,' respectively.
For example, consider the line: << "Press return after entering a number_0_\n"; This line may be read, 'put "Press_0__0__0_number_0_\n" to ' or simply 'output "Press_0__0__0_number_0_\n"'.
If you think of the word  as a name for the screen (the output device), then the arrows tell the computer to send the string in quotes to the screen.
As shown in the sample dialogue, this causes 21.
Chapter 1 / Introduction to Computers and Cplus_plus Programming the text contained in the quotes to be written to the screen.
The \n at the end of the quoted string tells the computer to start a new  after writing out the text.
Similarly, the next  of the program also begins with , and that program  causes the following  of text to be written to the screen: Enter the number of pods: The next program  starts with the word cin, so it is an input statement.
Let's look at that : cin >> number_of_pods; This  may be read, 'get number_of_pods from cin' or simply 'input number_of_pods'.
If you think of the word cin as standing for the keyboard (the input device), then the arrows say that input should be sent from the keyboard to the variable number_of_pods.
Look again at the sample dialogue.
The next shown has a 10 written in bold.
We use bold to indicate something typed in at the keyboard.
If you type in the number 10, then the 10 appears on the screen.
If you then press the Return key (which is also sometimes called the Enter key), that makes the 10 available to the program.
The statement which begins with cin tells the computer to send that input value of 10 to the variable number_of_pods.
From that point on, number_of_pods has the value 10; when we see number_of_pods later in the program, we can think of it as standing for the number 10.
Consider the next two program lines: << "Enter the number of peas in a pod:\n"; cin >> peas_per_pod; These lines are similar to the previous two lines.
The first sends a message to the screen asking for a number.
When you type in a number at the keyboard and press the Return key, that number becomes the value of the variable peas_ per_pod.
In the sample dialogue, we assume that you type in the number 9.
After you type in 9 and press the Return key, the value of the variable peas_ per_pod becomes 9.
The next nonblank program , shown below, does all the computation that is done in this simple program: = number_of_pods * peas_per_pod; The asterisk symbol, *, is used for multiplication in Cplus_plus.
So this statement says to multiply number_of_pods and peas_per_pod.
In this case, 10 is multiplied by 9 to give a result of 90.
The equal sign says that the variable should be made equal to this result of 90.
This is a special use of the equal sign; its meaning here is different than in other mathematical contexts.
It gives the variable on the left-hand side a (possibly ) ; in this case it makes 90 the  of.
These are just three more output statements that work basically the same as the previous statements that begin with.
The only thing that is is the second of these three statements, which says to output the variable number_of_pods.
When a variable is output, it is the  of the variable that is output.
So this statement causes a 10 to be output.
A   is not begun until the special instruction \n is sent as output.
The rest of the program contains nothing ,  if you understand what we have discussed so far, you should be able to understand the rest of the program.
PITFALL Using the Wrong Slash in \n When you use a \n in a  statement be sure that you use the backslash, which is written \.
If you make a mistake  use /n rather than \n, the compiler will not give you an error message.
Your program will run, but the output will look peculiar.
They point in the direction that data moves.
For example, consider the statement: cin >> number_of_pods; In the above statement, data moves from the keyboard to the variable number_.
On the other hand, consider the output statement: << number_of_pods; In this statement the data moves from the variable number_of_pods to the screen, so the arrow points from the variable number_of_pods to.
Chapter 1 / Introduction to Computers  Cplus_plus Programming Layout of a Simple Cplus_plus Program The general form of a simple Cplus_plus program is shown in Display 1_0_9.
As far as the compiler is concerned, the  breaks  spacing need not be as shown there  in our examples.
The compiler will accept any reasonable pattern of  breaks  indentation.
In fact, the compiler will even accept most unreasonable patterns of  breaks  indentation.
However, a program should always be laid out so that it is easy to read.
Placing the opening brace, {, on a  by itself  also placing the closing brace, }, on a  by itself will make these punctuations easy to find.
Indenting each statement  placing each statement on a separate  makes it easy to see what the program instructions are.
Later on, some of our statements will be too long to fit on one   then we will use a slight variant of this pattern for indenting breaks.
You should follow the pattern set by the examples in this book, or follow the pattern specified by your instructor if you are in a class.
In Display 1_0_8, the variable declarations are on the  that begins with the word int.
As we will see in the next chapter, you need not place all your variable declarations at the beginning of your program, but that is a good default location for them.
Unless you have a reason to place them somewhere else, place them at the start of your program as shown in Display 1_0_9  in the sample program in Display 1_0_8.
The statements are the instructions that are followed by the computer.
In Display 1_0_8, the statements are the lines that begin with  or cin  the one  that begins with  followed by an equal sign.
Statements are often called executable statements.
We will use the terms statement  executable statement interchangeably.
Notice that each of the statements we have seen ends with a semicolon.
The semicolon in statements is used in more or less the same way that the period is used in English sentences; it marks the end of a statement.
Display 1_0_9 Layout of a Simple Cplus_plus Program 1 2 3 4 5 6 7 8 9 10 11 12 13 14.
For now you can view the first few lines as a funny way to say "this is the beginning of the program_0_" But we can explain them in a bit more detail.
The first # <iostream> is called an  directive.
It tells the compiler where to find information about certain items that are used in your program.
In this case iostream is the name of a library that contains the definitions of the routines that handle input from the keyboard  output to the screen; iostream is a file that contains some basic information about this library.
The linker program that we discussed earlier in this chapter combines the object code for the library iostream  the object code for the program you write.
For the library iostream this will probably happen automatically on your system.
You will eventually use other libraries as well,  when you use them, they will have to be named in directives at the start of your program.
For other libraries, you may need to do more than just place an  directive in your program, but in order to use any library in your program, you will always need to at least place an  directive for that library in your program.
Directives always begin with the symbol #.
Some compilers require that directives have no spaces around the #, so it is always safest to place the # at the very start of the line  not  any space between the #  the word.
The following line further explains the  directive that we just explained: using namespace std; This line says that the names defined in iostream are to be interpreted in the "standard way" (std is an abbreviation of standard).
We will have more to say about this line a bit later in this book.
The third and fourth nonblank lines, shown next, simply say that the main part of the program starts here: { The correct term is main function, rather than main part, but the reason for that subtlety will not concern us until Chapter 4.
The braces { and } mark the beginning and end of the main part of the program.
They need not be on a line by themselves, but that is the way to make them easy to find and we will therefore always place each of them on a line by itself.
The next-to-last line return 0; says to "end the program when you get to here_0_" This line need not be the last thing in the program, but in a very simple program it makes no sense to place it anywhere else.
Some compilers will allow you to omit this line and will figure out that the program ends when there are no more statements to 25.
Chapter 1 / Introduction to Computers and Cplus_plus Programming execute.
However, other compilers will insist that you  this line, so it is best to get in the habit of including it, even if your compiler is happy without it.
This line is called a return statement and is considered to be an executable statement because it tells the computer to do something; specifically, it tells the computer to end the program.
The number 0 has no intuitive significance to us yet, but must be there; its meaning will become clear as you learn more about Cplus_plus.
Note that even though the return statement says to end the program, you still must add a closing brace, }, at the end of the main part of your program.
PITFALL   Putting a Space Before the  File Name Be certain that you do not have any extra space between the < and the iostream file name (Display 1_0_9) or between the end of the file name and the closing >.
The compiler  directive is not very smart: It will search for a file name that starts or ends with a space.
The file name will not be found, producing an error that is quite difficult to locate.
You should make this error deliberately in a small program, then compile it.
Save the message that your compiler produces so you know what the error message means the next time you get that error message.
But where is that program and how do you make it run.
You write a Cplus_plus program using a text editor in the same way that you write any other document—a term paper, a love letter, a shopping list, or whatever.
The program is kept in a file just like any other document you prepare using a text editor.
There are different text editors, and the details of how to use them will vary from one to another, so we cannot say too much more about your text editor.
You should consult the documentation for your editor.
The way that you compile and run a Cplus_plus program also depends on the particular system you are using, so we will discuss these points in only a very general way.
You need to learn how to give the commands to compile, link, and run a Cplus_plus program on your system.
These commands can be found in the manuals for your system and by asking people who are already using Cplus_plus on your system.
When you give the command to compile your program, this will produce a machine-language translation of your Cplus_plus program.
This translated version is called the object code for your program.
The object code must be linked (that is, combined) with the object code for routines (such as input and output routines) that are already written for you.
It is likely that this linking will be done automatically, so you do not need to worry about linking.
But on some systems, you may be required to make a separate call to the linker.
Again, consult your manuals or a local expert.
Finally, you give the command to run your program; how you give 1_0_3 Introduction to Cplus_plus that command also depends on the system you are using, so check with the manuals or a local expert.
PITFALL   Compiling a Cplus_plus11 Program Cplus_plus11 (formerly known as Cplus_plus0x) is the most recent version of the standard of the Cplus_plus programming.
It was approved on August 12, 2011 by the International Organization for Standardization.
A Cplus_plus11 compiler is able to compile and run programs written for older versions of Cplus_plus.
However, the Cplus_plus11 version includes new  features that are not compatible with older Cplus_plus compilers.
This means that if you have an older Cplus_plus compiler then you may not be able to compile and run Cplus_plus11 programs.
You may also need to specify whether or not to compile against the Cplus_plus11 standard.
For example, gplus_plus 4_0_7 requires the compiler flag of –=cplus_plus11 to be added to the command line; otherwise the compiler will assume that the Cplus_plus program is written to an older standard.
The command line to compile a Cplus_plus11 program named testing_0_cpp would look like: gplus_plus testing_0_cpp -=cplus_plus11 Check the documentation with your compiler to determine if any special steps are needed to compile Cplus_plus11 programs and to determine what Cplus_plus11 features are supported.
Obtain a copy of the program in Display 1_0_10.
It is available for downloading over the Internet.
Do not type in the line numbers.
Compile the program.
If you get an error message, check your typing, fix any typing mistakes, and recompile the file.
Once the program compiles with no error messages, try running the program.
If you get the program to compile and run normally, you are all set.
You do not need to do anything different from the examples shown in the book.
If this program does not compile or does not run normally, then read on.
In what follows we offer some hints for dealing with your Cplus_plus setup.
Once you get this simple program to run normally, you will know what small changes to make to your Cplus_plus program files in order to get them to run on your system.
If your program seems to run, but you do not see the output line Testing 1, 2, 3 then, in all likelihood, the program probably did give that output, but it disappeared before you could see it.
Try adding the following to the end of your program, just before the line return 0; these lines should stop your program to allow you to read the output.
Chapter 1 / Introduction to Computers and Cplus_plus Programming Display 1_0_10 1 2 3 4 5 6 7 8 9.
If the program does not compile or run at all, then try changing # <iostream>.
If your program requires iostream_0_h instead of iostream, then you have an.
If your program still does not compile and run normally, try deleting using namespace ; If your program still does not compile and run, then check the documentation for your version of Cplus_plus to see if any more "directives" are needed for "console" input/output.
If you are not in a course or you are not using the course computer, check the documentation for your Cplus_plus compiler or check with a friend who has a similar computer setup.
The necessary change is undoubtedly very small and, once you find out what it is, very easy.
Se l f-T e st Exer cise s 16.
If the following statement were used in a Cplus_plus program, what would it cause to be written on the screen.
What, if anything, is wrong with the following # directives.
Lewis Carroll, Through the Looking-Glass A mistake in a program is usually called a bug, and the process of eliminating bugs is called debugging.
There is colorful history of how this term came into use.
It occurred in the early days of computers, when computer hardware was 29.
Chapter 1 / Introduction to Computers and Cplus_plus Programming extremely sensitive and occupied an entire room.
Rear Admiral Grace Murray Hopper (1906–1992) was "the third programmer on the world's first largescale digital computer_0_" (Denise W.
Gurer, "Pioneering women in computer science" CACM 38(1):45–54, January 1995_0_) While Hopper was working on the Harvard Mark I computer under the command of Harvard professor Howard H.
Aiken, an unfortunate moth caused a relay to fail.
Hopper and the other programmers taped the deceased moth in the logbook with the note "First actual case of bug being found_0_" The logbook is currently on display at the Naval Museum in Dahlgren, Virginia.
This was the first documented computer bug.
Professor Aiken would come into the facility during a slack time and inquire if any numbers were being computed.
The programmers would reply that they were debugging the computer.
For more information about Admiral Hopper and other persons in computing, see Robert Slater, Portraits in Silicon (MIT Press, 1987).
Today, a bug is a mistake in a program.
In this section we describe the three main kinds of programming mistakes and give some hints on how to correct them.
Kinds of Program Errors The compiler will catch certain kinds of mistakes and will write out an error message when it finds a mistake.
It will detect what are called syntax errors, because they are, by and large, violation of the syntax (that is, the grammar rules) of the programming language, such as omitting a semicolon.
If the compiler discovers that your program contains a syntax error, it will tell you where the error is likely to be and what kind of error it is likely to be.
When the compiler says your program contains a syntax error, you can be confident that it does.
However, the compiler may be incorrect about either the location or the nature of the error.
It does a better job of determining the location of an error, to within a line or two, than it does of determining the source of the error.
This is because the compiler is guessing at what you meant to write down and can easily guess wrong.
After all, the compiler cannot read your mind.
Error messages subsequent to the first one have a higher likelihood of being incorrect with respect to either the location or the nature of the error.
Again, this is because the compiler must guess your meaning.
If the compiler's first guess was incorrect, this will affect its analysis of future mistakes, since the analysis will be based on a false assumption.
If your program contains something that is a direct violation of the syntax rules for your programming language, the compiler will give you an error message.
However, sometimes the compiler will give you only a warning message, which indicates that you have done something that is not, technically speaking, a violation of the programming language syntax rules, but that is unusual enough to indicate a likely mistake.
When you get a warning message, the compiler is saying, "Are you sure you mean this_0_" At this stage of your development, you should treat every warning as if it were an error until your instructor approves ignoring the warning.
Appropriately enough, these are called run-time errors.
Most computer systems will detect certain run-time errors and output an appropriate error message.
Many run-time errors have to do with numeric calculations.
For example, if the computer attempts to divide a number by zero, that is normally a run-time error.
If the compiler approved of your program and the program ran once with no run-time error messages, this does not guarantee that your program is correct.
Remember, the compiler will only tell you if you wrote a syntactically (that is, grammatically) correct Cplus_plus program.
It will not tell you whether the program does what you want it to do.
Mistakes in the underlying algorithm or in translating the algorithm into the Cplus_plus language are called logic errors.
For example, if you were to mistakenly use the addition sign + instead of the multiplication sign * in the  in Display 1_0_8, that would be a logic error.
The  would compile and run normally but would give the wrong answer.
If the compiler approves of your  and there are no runtime errors but the  does not perform properly, then undoubtedly your  contains a logic error.
Logic errors are the hardest kind to diagnose, because the computer gives you no error messages to help find the error.
It cannot reasonably be expected to give any error messages.
For all the computer knows, you may have meant what you wrote.
PITFALL   Assuming Your Program Is Correct In order to test a new  for logic errors, you should run the on several representative data sets and check its performance on those inputs.
If the  passes those tests, you can have more confidence in it, but this is still not an absolute guarantee that the  is correct.
It still may not do what you want it to do when it is run on some other data.
The only way to justify confidence in a  is to  carefully and so avoid most errors.
What are the three main kinds of  errors.
What kinds of errors are discovered by the compiler.
If you omit a punctuation symbol (such as a semicolon) from a , an error is produced.
What kind of error.
Omitting the final brace } from a  produces an error.
What kind of error.
Chapter 1 / Introduction to Computers and Cplus_plus Programming 26_0_	Suppose your  has a situation about which the compiler reports a warning.
Give the text's answer and your local answer if it is different from the text's.
Identify your answers as the text's or as based on your local rules.
What kind of  error is this.
Chapter Summary The collection of programs used by a computer is referred to as the software for that computer.
The actual physical machines that make up a computer installation are referred to as hardware.
Main memory is used only while the  is running.
Secondary memory is used to hold data that will stay in the computer before and/or after the  is run.
The number associated with one of these bytes is called the address of the byte.
Often, several of these bytes are grouped together to form a larger memory location.
In that case, the address of the first byte is used as the address of this larger memory location.
A digit that can only be zero or one is called a bit.
Algorithms can be written in English or in a programming language, like Cplus_plus.
However, the word algorithm is usually used to mean a sequence of instructions written in English (or some other human language, such as Spanish or Arabic).
The computer will usually tell you about errors in the first two categories.
You must discover logic errors yourself.
Answers to Self-Test Exercises ■ The individual instructions in a Cplus_plus  are called statements.
Answers to S e lf-Test Exer cises 1.
The five main components of a computer are the input device(s), the output device(s), the processor (CPU), the main memory, and the secondary memory.
The two numbers to be added.
The grades for each student on each test and each assignment.
A machine-language  is a low-level language consisting of 0s and 1s that the computer can directly execute.
A high-level language is written in a more English-like format and is translated by a compiler into a machinelanguage  that the computer can directly understand and execute.
A compiler translates a high-level language  into a machine-language.
The high-level language  that is input to a compiler is called the source.
The translated machine-language  that is output by the compiler is called the object.
An operating system is a , or several cooperating programs, but is best thought of as the user's chief servant.
An operating system's purpose is to allocate the computer's resources to different tasks the computer must accomplish.
Among the possibilities are the Macintosh operating system Mac OS, Windows, VMS, Solaris, SunOS, UNIX (or perhaps one of the UNIX-like operating systems such as Linux).
The object code for your Cplus_plus program must be combined with the object code for routines (such as input and output routines) that your program uses.
This process of combining object code is called linking.
For simple programs, this linking may be done for you automatically.
Chapter 1 / Introduction to Computers and Cplus_plus Programming 11.
The answer varies, depending on the compiler you use.
Most UNIX and UNIX-like compilers link automatically, as do the compilers in most integrated development environments for Windows and Macintosh operating systems.
The following instructions are too vague for use in an algorithm: Add vanilla extract to taste.
Beat until smooth.
Pour into a pretty glass.
Sprinkle with nutmeg.
The notions of "to taste," "smooth," and "pretty" are not precise.
The instruction "sprinkle" is too vague, since it does not specify how much nutmeg to sprinkle.
The other instructions are reasonable to use in an algorithm.
The first step you should take when creating a program is to be certain that the task to be accomplished by the program is completely and precisely specified.
The problem-solving phase and the implementation phase.
Cplus_plus is easy to understand.
The symbols \n tell the computer to start a new  in the output so that the next item output will be on the next.
This statement tells the computer to read the next number that is typed in at the keyboard and to send that number to the variable named peas_per_pod.
This statement says to multiply the two numbers in the variables number_ of_pods and peas_per_pod, and to place the result in the variable named total_peas.
The #include <iostream> directive tells the compiler to fetch the file and extraction (>>) operators for I/O (input and output).
This enables correct linking of the object code from the iostream library with the I/O statements in the program.
Practice Programs 22.
The three main kinds of program errors are syntax errors, run-time errors, and logic errors.
The compiler detects syntax errors.
There are other errors that are not technically syntax errors that we are lumping with syntax errors.
You will learn about these later.
The text states that you should take warnings as if they had been reported as errors.
You should ask your instructor for the local rules on how to handle warnings.
A logic error.
Practice ProgramS Practice Programs can generally be solved with a short program that directly applies the programming principles presented in this chapter.
Using your text editor, enter (that is, type in) the Cplus_plus program shown in Display 1_0_8.
Be certain to type the first  exactly as shown in Display 1_0_8.
In particular, be sure that the first  begins at the left-hand end of the  with no space before or after the # symbol.
Compile and run the program.
If the compiler gives you an error message, correct the program and recompile the program.
Do this until the compiler gives no error messages.
Then run your program.
Modify the Cplus_plus program you entered in Practice Program 1.
Change the program so that it first writes the word Hello to the screen and then goes on to do the same things that the program in Display 1_0_8 does.
You will only have to add one  to the program to make this happen.
Recompile the changed program and run it.
Then change the program even more.
Add one more  that will make the program write the word Good-bye to the screen at the end of the program.
Be certain to add the symbols \n to the last output statement so that it reads as follows: << "Good-bye\n"; (Some systems require that final \n, and your system may be one of them_0_) Recompile and run the changed program.
Further modify the Cplus_plus program that you already modified in Practice Program 2.
Change the multiplication sign * in your Cplus_plus program to a division sign /.
Recompile the changed program.
Run the program.
Enter a 0 input for "number of peas in a pod_0_" Notice the run-time error message due to division by zero.
Chapter 1 / Introduction to Computers and Cplus_plus Programming 4.
Modify the Cplus_plus program that you entered in Practice Program 1.
Change the multiplication sign * in your Cplus_plus program to an addition sign +.
Recompile and run the changed program.
Notice that the program compiles and runs perfectly fine, but the output is incorrect.
That is because this modification is a logic error.
Modify the Cplus_plus program that you entered in Practice Program 1.
In this version calculate the total length of fence you would need to enclose a rectangular area that is width feet long and height feet tall.
The program should have variables for width and height with values entered by the user.
Create another variable, totalLength, that stores the total length of fence needed (which your program should calculate).
Output the total with an appropriate message.
VideoNote Solution to Practice Program 1_0_6 6.
The purpose of this exercise is to produce a catalog of typical syntax errors and error messages that will be encountered by a beginner and to continue acquainting you with the programming environment.
This exercise should leave you with a knowledge of what error to look for when given any of a number of common error messages.
If not, Y you should use a program from one of the previous Practice Programs.
Keep the catalog of errors and add program errors and messages to it as you continue through this course.
The sequence of suggested errors to introduce is: a.
Put an extra space between the < and the iostream file name.
Omit one of the < or > symbols in the include directive.
Omit the int from int main().
Omit or misspell the word main.
Omit one of the (); then omit both the ().
Omit one or both of the << in the  statement; leave off the ending curly brace }.
Programming Projects Programming Projects require more problem-solving than Practice Programs and can usually be solved many different ways.
Visit www_0_myprogramminglab_0_com to complete many of these Programming Projects online and get instant feedback.
Write a Cplus_plus program that reads in two integers and then outputs both their sum and their product.
One way to proceed is to start with the program in Programming Projects 37 Display 1_0_8 and to then modify that program to produce the program for this project.
Be certain to type the first line of your program exactly the same as the first line in Display 1_0_8.
In particular, be sure that the first line begins at the left-hand end of the line with no space before or after the # symbol.
Also, be certain to add the symbols \n to the last output statement in your program.
For example, the last output statement might be the following: << "This is the end of the program_0_\n"; (Some systems require that final \n, and your system may be one of 2.
Write a program that prints out "C S _0_" in large block letters inside a border of *s followed by two blank lines then the message Computer Science is Cool Stuff.
The output should look as follows: ************************************************* S S S S C C C C C C C C C C C S S S _0_.
S S S S S S S C C C C S S OO S S S S ************************************************* Computer Science is Cool Stuff_0__0_.
Write a program that allows the user to enter a number of quarters, dimes, and nickels and then outputs the monetary value of the coins in cents.
For example, if the user enters 2 for the number of quarters, 3 for the number of dimes, and 1 for the number of nickels, then the program should output that the coins are worth 85 cents.
Write a program that allows the user to enter a time in seconds and then outputs how far an object would drop if it is in freefall for that length of time.
Assume that the object starts at rest, there is no friction or resistance from air, and there is a constant acceleration of 32 feet per second due to gravity.
Use the equation: 2 = acceleration x time 2 You should first compute the product and then divide the result by 2 (The reason for this will be discussed later in the book).
VideoNote Solution to Programming Project 1_0_3 38 Chapter 1 / Introduction to Computers and Cplus_plus Programming 5.
Write a program that inputs a character from the keyboard and then outputs a large block letter "C" composed of that character.
For example, if the user inputs the character "X," then the output should look as follows: X X X X X X X X X X X X X X X Cplus_plus Basics 2 2_0_1 Variables and Assignments   40 Variables   40 Names: Identifiers   42 Variable Declarations   44 Assignment Statements   45 Pitfall: Uninitialized Variables   47 Programming Tip: Use Meaningful Names   49 The Type char  64 The Type bool  66 Introduction to the Class   66 Type Compatibilities   68 Arithmetic Operators and Expressions   69 Pitfall: Whole Numbers in Division   72 More Assignment Statements   74 2_0_2  Input and Output   50 Output Using    50 Include Directives and Namespaces   52 Escape Sequences   53 Programming Tip: End Each Program with a \n or endl  55 Formatting for Numbers with a Decimal Point   55 Input  cin   56 Designing Input and Output   58 Programming Tip: Line Breaks in I/O   58 2_0_4  Simple Flow  Control   74 A Simple Branching Mechanism   75 : Strings  Inequalities   80 :  = in place  ==   81 Compound Statements   82 Simple Loop Mechanisms   84 Increment and Decrement Operators   87 Programming Example: Charge Card Balance   89 : Infinite Loops   90 2_0_3  Data Types and Expressions   60 The Types int and double   60 Other Number Types   62 Cplus_plus11 Types   63 Chapter Summary   98 Answers to Self-Test Exercises   98 2_0_5  Program Style   93 Indenting   93 Comments   93 Naming Constants   95 Practice Programs   103 Programming Projects   105 Don't imagine you know what a computer terminal is.
A computer terminal is not some clunky old television with a typewriter in front  it.
It is an interface where the mind and the body can connect with the universe and move bits  it about.
Introduction In this chapter we explain some additional sample Cplus_plus programs and present enough details  the Cplus_plus language to allow you to write simple Cplus_plus programs.
Prerequisites In Chapter 1 we gave a brief description  one sample Cplus_plus program.
DIjkstra, Notes on Structured Programming Programs manipulate data such as numbers  letters.
Cplus_plus  most other common programming languages use programming constructs known as variables to name  store data.
Variables are at the very heart  a programming language like Cplus_plus, so that is where we start our description  Cplus_plus.
We will use the program in Display 2_0_1 for our discussion  will explain all the items in that program.
While the general idea  that program should be clear, some the details are new  will require some explanation.
Variables A Cplus_plus variable can hold a number or data  other types.
For the moment, we will confine our attention to variables that hold only numbers.
These variables are like small blackboards on which the numbers can be written.
Just as the numbers written on a blackboard can be changed, so too can the number held by a Cplus_plus variable be changed.
Unlike a blackboard that might possibly contain no number at all, a Cplus_plus variable is guaranteed to have some value in it, if only a garbage number left in the computer's memory by some previously run program.
The number or other type  data held in a 40 2_0_1 Variables  Assignments 41 variable is called its value; that is, the value  a variable is the item written on the figurative blackboard.
In the program in Display 2_0_1, number_of_bars, one_weight,  total_weight are variables.
For example, when this program is run with the input shown in the sample dialogue, number_of_bars has its value set equal to the number 11 with the statement cin >> number_of_bars; Later, the value  the variable number_of_bars is changed to 12 when a second copy  the same statement is executed.
We will discuss exactly how this happens a little later in this chapter.
Of course, variables are not blackboards.
In programming languages, variables are implemented as memory locations.
The compiler assigns a memory location ( the kind discussed in Chapter 1) to each variable name in the program.
The value  the variable, in a coded form consisting  0s 1s, is kept in the memory location assigned to that variable.
For example, the three variables in the program shown in Display 2_0_1 might be assigned the memory locations with addresses 1001, 1003,  1007.
The exact numbers will depend on your computer, your compiler,  a number  other factors.
We do not know, or even care, what addresses the compiler will choose for the variables in our program.
We can think as though the memory locations were actually labeled with the variable names.
Sample Dialogue Enter the number of candy bars in a package  the weight in ounces of one candy bar.
Then press return.
Try another brand.
Enter the number of candy bars in a package  the weight in ounces of one candy bar.
Then press return.
Perhaps an apple would be healthier.
Names: Identifiers The first thing you might notice about the names of the variables in our sample programs  that they are longer than the names normally used for variables in mathematics classes.
To make your program easy to understand, you should always use meaningful names for variables.
The name of a variable (or other item you might define in a program)  called an identifier.
If you cannot get your Cplus_plus programs to compile and run, read the That section has tips for dealing with variations in Cplus_plus compilers and Cplus_plus environments.
An identifier must start with either a letter or the underscore symbol, and all the rest of the characters must be letters, digits, or the underscore symbol.
For example, the following are all valid identifiers: x x1 x_1 _abc ABC123z7 sum RATE count data2 Big_Bonus All of the previously mentioned names are legal and would be accepted by the compiler, but the first five are poor choices for identifiers, since they are not descriptive of the identifier's use.
None of the following are legal identifiers and all would be rejected by the compiler: 12 3X %change data-1 myfirst_0_c PROG_0_CPP The first three are not allowed because they do not start with a letter or an underscore.
The remaining three are not identifiers because they contain symbols other than letters, digits, and the underscore symbol.
Cplus_plus  a case-sensitive language; that , it distinguishes between uppercase and lowercase letters in the spelling of identifiers.
Hence the following are three distinct identifiers and could be used to name three distinct variables: rate RATE Rate However, it  not a good idea to use two such variants in the same program, since that might be confusing.
Although it  not required by Cplus_plus, variables are often spelled with all lowercase letters.
The predefined identifiers, such as main, cin, , and so forth, must be spelled in all lowercase letters.
We will see uses for identifiers spelled with uppercase letters later in this chapter.
A Cplus_plus identifier can be of any length, although some compilers will ignore all characters after some specified and typically large number of initial characters.
Identifiers Identifiers are used as names for variables and other items in a Cplus_plus program.
An identifier must start with either a letter or the underscore symbol, and the remaining characters must all be letters, digits, or the underscore symbol.
Chapter 2 / Cplus_plus Basics There  a special class of identifiers, called keywords or reserved words, that have a predefined meaning in Cplus_plus and that you cannot use as names for variables or anything else.
In this book, keywords are written in a different type font like so: int, double.
You may wonder why the other words that we defined as part of the Cplus_plus language are not on the list of keywords.
What about words like cin and The answer  that you are allowed to redefine these words, although it would be confusing to do so.
These predefined words are not keywords; however, they are defined in libraries required by the Cplus_plus language standard.
We will discuss libraries later in this book.
For now, you need not worry about libraries.
Needless to say, using a predefined identifier for anything other than its standard meaning can be confusing and dangerous, and thus should be avoided.
The safest and easiest practice  to treat all predefined identifiers as if they were keywords.
Variable Declarations Every variable in a Cplus_plus program must be declared.
When you declare a variable you are telling the compiler—and, ultimately, the computer—what kind of data you will be storing in the variable.
For example, the following two declarations from the program in Display 2_0_1 declare the three variables used in that program: int ; double , ; When there is more than one variable in a declaration, the variables are separated by commas.
Also, note that each declaration ends with a semicolon.
The word int in the first of these two declarations is an abbreviation of the word integer.
Do not write out the entire word integer_0_) This line declares the identifier to be a variable of type int.
This means that the value of must be a whole number, such as 1, 2, –1, 0, 37, or –288.
The word double in the second of these two lines declares the two identifiers  and  to be variables of type double.
A variable of type double can hold numbers with a fractional part, such as 1_0_75 or –0_0_55.
The kind of data that is held in a variable is called its type and the name for the type, such as int or double, is called a type name.
Every variable in a Cplus_plus program must be declared before the variable can be used.
There are two natural places to declare a variable: either just before it is used or at the start of the main part of your program right after the lines.
The syntax for variable declarations is as follows: Syntax Type_Name Variable_Name_1, Variable_Name_2, _0__0__0_;.
Variable declarations provide information the compiler needs in order to implement the variables.
Recall that the compiler implements variables as memory locations and that the value of a variable is stored in the memory location assigned to that variable.
The value is coded as a string of 0s and 1s.
Different types of variables require different sizes of memory locations and different methods for coding their values as a string of 0s and 1s.
The computer uses one code to encode integers as a string of 0s and 1s.
It uses a different code to encode numbers that have a fractional part.
It uses yet another code to encode letters as strings of 0s and 1s.
The variable declaration tells the compiler—and, ultimately, the computer—what size memory location to use for the variable and which code to use when representing the variable's value as a string of 0s and 1s.
Syntax is the set of grammar rules for that language.
For example, when we talk about the syntax for a variable declaration (as in the box labeled "Variable Declarations"), we are talking about the rules for writing down a wellformed variable declaration.
If you follow all the syntax rules for Cplus_plus, then the compiler will accept your program.
Of course, this only guarantees that what you write is legal.
It guarantees that your program will do something, but it does not guarantee that your program will do what you want it to do.
Assignment Statements The most direct way to change the value of a variable is to use an assignment statement.
An assignment statement is an order to the computer saying, "set 45.
An assignment statement ends with a semicolon.
The expression on the right-hand side of the equal sign may be a variable, a number, or a more complicated expression made up of variables, numbers, and arithmetic operators such as * and +.
An assignment statement instructs the computer to evaluate (that is, to compute the value of) the expression on the right-hand side of the equal sign and to set the value of the variable on the left-hand side equal to the value of that expression.
A few more examples may help to clarify the way these assignment statements work.
You may use any arithmetic operator in place of the multiplication sign.
The following, for example, is also a valid assignment statement: = one_weight + number_of_bars; This statement is just like the assignment statements in our sample program, except that it performs addition rather than multiplication.
This statement changes the value of  to the sum of the values of one_weight and number_of_bars.
Of course, if you made this change in the program in Display 2_0_1, the program would give incorrect output, but it would still run.
In an assignment statement, the expression on the right-hand side of the equal sign can simply be another variable.
The statement = one_weight; changes the value of the variable  so that it is the same as that of the variable one_weight.
If you were to use this in the program in Display 2_0_1, it would give out incorrectly low values for the total weight of a package (assuming there is more than one candy bar in a package), but it might make sense in some other program.
As another example, the following assignment statement changes the value of  to 37: = 37; A number, like the 37 in this example, is called a constant, because unlike a variable, its value cannot change.
Since variables can change value over time and since the assignment operator is one vehicle for changing their values, there is an element of time involved in the meaning of an assignment statement.
First, the expression on the right-hand side of the equal sign is evaluated.
After that, the value of 2_0_1 Variables and Assignments the variable on the left side of the equal sign is changed to the  that was obtained from that expression.
This means that a variable can meaningfully occur on both sides of an assignment operator.
For example, consider the assignment statement =  + 3; This assignment statement may look strange at first.
If you read it as an English sentence, it seems to say "the  is equal to the number_ of_bars plus three_0_" It may seem to say that, but what it really says is "Make the new  of  equal to the old  of plus three_0_" The equal sign in Cplus_plus is not used the same way that it is used in English or in simple mathematics.
Assignment Statements In an assignment statement, first the expression on the right-hand side of the equal sign is evaluated, and then the variable on the left-hand side of the equal sign is set equal to this.
Syntax = Expression;.
Pitfall   Uninitialized Variables A variable has no meaningful  until a program gives it one.
For example, if the variable minimum_number has not been given a  either as the lefthand side of an assignment statement or by some other means (such as being given an input  with a cin statement), then the following is an error: = minimum_number + 10; This is because minimum_number has no meaningful , so the entire expression on the right-hand side of the equal sign has no meaningful.
A variable like minimum_number that has not been given a  is said to be uninitialized.
This situation is, in fact, worse than it would be if minimum_number had no at all.
An uninitialized variable, like minimum_number, will simply have some "garbage _0_" The  of an uninitialized variable is determined by whatever pattern of 0s and 1s was left in its memory location by the last program that used that portion of memory.
Thus if the program is run twice, an uninitialized 47.
Chapter 2 / Cplus_plus Basics variable may receive a different  each time the program is run.
Whenever a program gives different output on exactly the same input data and without any changes in the program itself, you should suspect an uninitialized variable.
One way to avoid an uninitialized variable is to initialize variables at the same time they are declared.
This can be done by adding an equal sign and a , as follows: int  = 3; This both declares  to be a variable of type int and sets the  of the variable  equal to 3.
You can use a more complicated expression involving operations such as addition or multiplication when you initialize a variable inside the declaration in this way.
However, a simple constant is what is most often used.
You can initialize some, all, or none of the variables in a declaration that lists more than one variable.
For example, the following declares three variables and initializes two of them: double  = 0_0_07, time,  = 0_0_0; Cplus_plus allows an alternative notation for initializing variables when they are.
Do whatever makes your program the easiest to understand.
It is much easier to understand a program if the variables have meaningful names.
Contrast the following: = y * z;.
The two statements accomplish the same thing, but the second is easier to understand.
Both variables are of type int and both are to be initialized to zero in the declaration.
Use both initialization alternatives.
The variable length is of type double.
Write a program that contains statements that output the  of five or six variables that have been declared, but not initialized.
Compile and run the program.
Chapter 2 / Cplus_plus Basics 7_0_	Give good variable names for each of the following: a.
A variable to hold the speed of an automobile b.
A variable to hold the pay  for an hourly employee c.
A variable to hold the highest score in an exam 2_0_2 Input and Output Garbage in means garbage out.
Programmers' Saying There are several different ways that a Cplus_plus program can perform input and output.
We will describe what are called streams.
An input stream is simply the stream of input that is being fed into the computer for the program to use.
The word stream suggests that the program processes the input in the same way no matter where the input comes from.
The intuition for the word stream is that the program sees only the stream of input and not the source of the stream, like a mountain stream whose water flows past you but whose source is unknown to you.
In this section we will assume that the input comes from the keyboard.
In Chapter 6 we will discuss how a program can read its input from a file; as you will see there, you can use the same kinds of input statements to read input from a file as those that you use for reading input from the keyboard.
Similarly, an output stream is the stream of output generated by the program.
In this section we will assume the output is going to a terminal screen; in Chapter 6 we will discuss output that goes to a file.
Output Using The values of variables as well as strings of text may be output to the screen using There may be any combination of variables and strings to be output.
For example, consider the following line from the program in Display 2_0_1: <<  << " candy bars\n"; This statement tells the computer to output two items: the value of the variable and the quoted string " candy bars\n".
Notice that you do not need a separate copy of the word  for each item output.
You can simply list all the items to be output preceding each item to be output with the arrow symbols <<.
The above single  statement  equivalent to the following two  statements: << ; << " candy bars\n";.
The symbol <  the same as the "less than" symbol.
The two < symbols should be typed without any space between them.
The arrow notation <<  often called the insertion operator.
The entire  statement ends with a semicolon.
Whenever you have two  statements in a row, you can combine them into a single long  statement.
For example, consider the following lines from Display 2_0_1: <<  << " candy bars\n"; <<  << " ounces each\n";.
A better way to write the previous long  statement You should not break a quoted string across two lines, but otherwise you can start a new  anywhere you can insert a space.
Any reasonable pattern of spaces and  breaks will be acceptable to the computer, but the previous example and the sample programs are good models to follow.
A good policy to use one  for each group of output that  intuitively considered a unit.
Notice that there  just one semicolon for each , even if the statement spans several lines.
Pay particular attention to the quoted strings that are output in the program in Display 2_0_1.
Notice that the strings must be included in double quotes.
The double quote symbol used  a single key on your keyboard; do not type two single quotes.
Also, notice that the same double quote symbol  used at each end of the string; there are not separate left and right quote symbols.
Also, notice the spaces inside the quotes.
The computer does not insert any extra space before or after the items output by a  statement.
That why the quoted strings in the samples often start and/or end with a blank.
The blanks keep the various strings and numbers from running together.
If all you need  a space and there  no quoted string where you want to insert the space, then use a string that contains only a space, as in the following: <<  << " " << second_number; As we noted in Chapter 1, \n tells the computer to start a new  of output.
Unless you tell the computer to go to the next , it will put all the output on the same.
Depending on how your screen  set up, this can 51.
Chapter 2 / Cplus_plus Basics produce anything from arbitrary  breaks to output that runs off the screen.
Notice that the \n goes inside of the quotes.
In Cplus_plus, going to the next considered to be a special character (special symbol) and the way you spell this special character inside a quoted string  \n, with no space between the two symbols in \n.
Although it  typed as two symbols, Cplus_plus considers \n to be a single character that  called the new- character.
Include Directives and Namespaces.
This  the library that includes, among other things, the definitions of cin and.
So if your program uses either cin or , you should have these two lines at the start of the file that contains your program.
The following   known as an  directive.
It "includes" the library iostream in your program so that you have cin and  available: # <iostream> The operators cin and  are defined in a file named iostream and the above  directive  equivalent to copying that named file into your program.
The second   a bit more complicated to explain.
Cplus_plus divides names into namespaces.
A namespace  a collection of names, such as the names cin and.
A statement that specifies a namespace in the way illustrated by the following  called a using directive.
This means that the names you use will have the meaning defined for them in the std namespace.
In this case, the important thing  that when names such as cin and  were defined in iostream, their definitions said they were in the std namespace.
So to use names like cin and , you need to tell the compiler you are using namespace std;.
That  all you need to know (for now) about namespaces, but a brief clarifying remark will remove some of the mystery that might surround the use of namespace.
The reason that Cplus_plus has namespaces at all  because there are so many things to name.
As a result, sometimes two or more items receive the same name; that , a single name can get two different definitions.
To eliminate these ambiguities, Cplus_plus divides items into collections so that no two items in the same collection (the same namespace) have the same name.
Note that a namespace  not simply a collection of names.
It  a body of Cplus_plus code that specifies the meaning of some names, such as some definitions and/or declarations.
The function of namespaces  to divide all the Cplus_plus name 2_0_2 Input and Output specifications into collections (called namespaces) such that each name in a namespace has only one specification (one "definition") in that namespace.
A namespace divides up the names, but it takes a lot of Cplus_plus code along with the names.
What if you want to use two items in two different namespaces such that both items have the same name.
It can be done and  not too complicated, but that  a topic for later in the book.
For now, we do not need to do this.
Some versions of Cplus_plus use the following, older form of the directive (without any using namespace): # <iostream_0_h>.
If your program requires iostream_0_h instead of iostream, then you have an old Cplus_plus compiler and should obtain a more recent compiler.
Escape Sequences The backslash, \, preceding a character tells the compiler that the character following the \ does not have the same meaning as the character appearing by itself.
Such a sequence is called an escape sequence.
The sequence is typed in as two characters with no space between the symbols.
Several escape sequences are defined in Cplus_plus.
If you want to put a \ or a " into a string constant, you must escape the ability of the " to terminate a string constant by using \", or the ability of the \ to escape, by using \\.
The \\ tells the compiler you mean a real backslash, \, not an escape sequence backslash, and \" means a real quote, not a string constant end.
A stray \, say \z, in a string constant will on one compiler simply give back a z; on another it will produce an error.
The ANSI Standard provides that the unspecified escape sequences have undefined behavior.
This means a compiler can do anything its author finds convenient.
The consequence is that code that uses undefined escape sequences is not portable.
You should not use any escape sequences other than those provided.
We list a few here.
Chapter 2 / Cplus_plus Basics Alternately, Cplus_plus11 supports a format called raw string literals, which is convenient if you have many escape characters.
In this format use an R followed by the string in parentheses.
For example, the following  outputs the literal string "c:\files\": << R"(c:\files\)";.
A good rule for deciding whether to use \n or endl is the following: If you can  the \n at the end of a longer string, then use \n as in the following:.
Alternatively, you can start a new  by outputting endl.
An equivalent way to write the above  statement is as follows: << "You have definitely won" << endl << "one of the following :" << endl; 2_0_2 Input and Output ■ Programming Tip   End Each Program with a \n or endl It is a good idea to  a new- instruction at the end of every program.
If the last item to be  is a string, then  a \n at the end of the string; if not,  an endl as the last action in your program.
This serves two purposes.
Some compilers will not  the last  of your program unless you  a new- instruction at the end.
On other systems, your program may work fine without this final new- instruction, but the next program that run will have its first  of  mixed with the last  of the previous program.
Even if neither of these problems occurs on your system, putting a new- instruction at the end will make your programs more portable.
For example, the following simple  statement can produce any of a wide range of outputs: << "The   $" <<  << endl; If  has the value 78_0_5, the  might be The   $78_0_500000 or it might be The   $78_0_5 or it might be  in the following notation (which we will explain in Section 2_0_3): The   $7_0_850000e01 But it  extremely unlikely that the  will be the following, even though this  the format that makes the most sense: The   $78_0_50 To ensure that the   in the form you want, your program should contain some sort of instructions that tell the computer how to  the numbers.
There  a "magic formula" that you can insert in your program to cause numbers that contain a decimal point, such as numbers of type double, to be in everyday notation with the exact  of digits after the decimal point that you specify.
If you want two digits after the decimal point, use the following magic formula:.
You can even use a variable of type int in place of the 2.
We will explain this magic formula in detail in Chapter 6.
For now you should think of this magic formula as one long instruction that tells the computer how you want it to  numbers that contain a decimal point.
If you wish to change the  of digits after the decimal point so that different values in your program are  with different numbers of digits, you can repeat the magic formula with some other  in place of 2.
However, when you repeat the magic formula, you only need to repeat the last of the formula.
If the magic formula has already occurred once in your program, then the following  will change the  of digits after the decimal point to 5 for all subsequent values of type double that are : _0_precision(5); Input Using cin You use cin for input more or less the same way you use  for.
The syntax  similar, except that cin  used in place of  and the arrows point in the opposite direction.
For example, in the program in Display 2_0_1, the variables number_of_bars and one_weight were filled by the following cin statements (shown along with the  statements that tell the user what to do): Outputting Values of Type double If you insert the following "magic formula" in your program, then all numbers of type double (or any other type that allows for digits after the decimal point) will be  in ordinary, everyday notation with two digits after the decimal point:.
You can even use a variable of type int in place of the 2.
When a program reaches a cin statement, it waits for input to be  from the keyboard.
It sets the first variable equal to the first value typed at the keyboard, the second variable equal to the second value typed, and so forth.
However, the program does not read the input until the user presses the Return key.
This allows the user to backspace and correct mistakes when entering a  of input.
Numbers in the input must be separated by one or more spaces or by a break.
If, for instance, you want to enter the two numbers 12 and 5 and instead you enter the numbers without any space between them, then the computer will think you have entered the single number 125.
When you use cin statements, the computer will skip over any number of blanks or  breaks until it finds the next input value.
Thus, it does not matter whether input numbers are separated by one space or several spaces or even a  break.
Syntax cin >> Variable_1 >> Variable_2 >> _0__0_.
Chapter 2 / Cplus_plus Basics Designing Input and Output Input and output, or, as it  often called, I/O,  the part of the program that the user sees, so the user will not be happy with a program unless the program has well-designed I/O.
When the computer executes a cin statement, it expects some data to be typed in at the keyboard.
If none  typed in, the computer simply waits for it.
The program must tell the user when to type in a number (or other data item).
The computer will not automatically ask the user to enter data.
That  why the sample programs contain output statements like the following:.
These output statements prompt the user to enter the input.
Your programs should always prompt for input.
When entering input from a terminal, the input appears on the screen as it  typed in.
Nonetheless, the program should always write out the input values some time before it ends.
This  called echoing the input, and it serves as a check to see that the input was read in correctly.
Just because the input looks good on the screen when it  typed in does not mean that it was read correctly by the computer.
There could be an unnoticed typing mistake or other problem.
Echoing input serves as a test of the integrity of the input data.
If you simply omit a \n or endl at the end of the last prompt line, then the user's input will appear on the same line as the prompt.
For example, suppose you use the following prompt and input statements: << "Enter the cost per person: $"; cin >> cost_per_person;.
Enter the cost per person: $ When the user types in the input, it will appear on the same line, like this: Enter the cost per person: $1_0_25 ■ 2_0_2 Input and Output S el f -T est Exer cis es 8_0_	Give an output statement that will produce the following message on the screen: The answer to the question of Life, the Universe, and Everything  42.
Precede the input statement with a prompt statement asking the user to enter a whole number.
What statements should you include in your program to ensure that, when a number of type double is output, it will be output in ordinary notation with three digits after the decimal point.
Write a complete Cplus_plus program that writes the phrase Hello world to the screen.
Write a complete Cplus_plus program that reads in two whole numbers and outputs their sum.
Be sure to prompt for input, echo input, and label all output.
Write a short program that declares and initializes double variables one, two, three, four, and five to the values 1_0_000, 1_0_414, 1_0_732, 2_0_000, and 2_0_236, respectively.
Then write output statements to generate the following legend and table.
Use the tab escape sequence \t to  up the columns.
If you are unfamiliar with the tab character, you should experiment with it while doing this exercise.
A tab works like a mechanical stop on a typewriter.
A tab causes output to begin in a next column, usually a multiple of eight spaces away.
Many editors and most word processors will have adjustable tab stops.
The output should be: N Square Root.
Chapter 2 / Cplus_plus Basics 2_0_3 Data Types and Expressions They'll never be happy together.
Overheard at a Cocktail Party The Types int and double Conceptually, the numbers 2 and 2_0_0 are the same number.
The whole number 2 is of type int; the number 2_0_0 is of type double, because it contains a fraction part (even though the fraction is 0).
Once again, the mathematics of computer programming is a bit different from what you may have learned in mathematics classes.
Something about the practicalities of computers makes a computer's numbers differ from the abstract definitions of these numbers.
The whole numbers in Cplus_plus behave as you would expect them to.
The type int holds no surprises.
But values of type double are more troublesome.
Because it can store only a limited number of significant digits, the computer stores numbers of type double as approximate values.
Numbers of type int are stored as exact values.
The precision with which double values are stored varies from one computer to another, but you can expect them to be stored with 14 or more digits of accuracy.
For most applications this is likely to be sufficient, though subtle problems can occur even in simple cases.
Thus, if you know that the values in some variable will always be whole numbers in the range allowed by your computer, it is best to declare the variable to be of type int.
Number constants of type double are written differently from those of type int.
Constants of type int must not contain a decimal point.
Constants of type double may be written in either of two forms.
The simple form for double constants is like the everyday way of writing decimal fractions.
Why is the type for numbers with a fraction part called double.
Is there a type called "single" that is half as big.
No, but something like that is true.
Many programming languages traditionally used two types for numbers with a fractional part.
One type used less storage and was very imprecise (that is, it did not allow very many significant digits).
The second type used double the amount of storage and was therefore much more precise; it also allowed numbers that were larger (although programmers tend to care more about precision than about size).
The kind of numbers that used twice as much storage were called 2_0_3 Data Types and Expressions double-precision numbers; those that used less storage were called corresponds to this double-precision type was named double in Cplus_plus.
The type that corresponds to single-precision in Cplus_plus was called float.
Cplus_plus also has a third type for numbers with a fractional part, which is called long double.
These types are described in the subsection entitled "Other Number Types_0_" However, we will rarely use the types float and long double in this book.
There is, however, one thing that constants of type double and constants of type int have in common: No number in Cplus_plus may contain a comma.
The more complicated notation for constants of type double is frequently called scientific notation or floating-point notation and is particularly handy for writing very large numbers and very small fractions.
For instance, 17 3_0_67 × 10 which is the same as 367000000000000000_0_0 is best expressed in Cplus_plus by the constant 3_0_67e17.
The number –6 5_0_89 × 10 which is the same as 0_0_00000589 is best expressed in Cplus_plus by the constant 5_0_89e-6.
The e stands for exponent and 61.
Chapter 2 / Cplus_plus Basics be, and this limit is different for different number types.
The largest allowable number of type double is always much larger than the largest allowable number of type int.
Most current implementations of Cplus_plus will allow values of type int as large as 2,147,483,647 and values of type double up to about 10308.
Other Number Types Cplus_plus has other numeric types besides int and double.
The various number types allow for different size numbers and for more or less precision (that is, more or fewer digits after the decimal point).
In Display 2_0_2, the values given for memory used, size range, and precision are only one sample set of values, intended to give you a general feel for how the types differ.
The values vary from one system to another and may be different on your system.
Although some of these other numeric types are spelled as two words, you declare variables of these other types just as you declare variables of types int and double.
For example, the following declares one variable of type long double: long double big_number;.
Of course, in any one program, you should use only one of the above two declarations for the variable big_total, but it does not matter which one you use.
Also, remember that the type name long by itself means the same thing as long int, not the same thing as long double.
The types for whole numbers, such an int and similar types, are called integer types.
The type for numbers with a decimal point—such as the type double and similar types—are called floating-point types.
They are called floating-point because when the computer stores a number written in the usual way, like 392_0_123, it first converts the number to something like e notation, in this case something like 3_0_92123e2.
When the computer performs this conversion, the decimal point floats (that is, moves) to a new position.
You should be aware that there are other numeric types in Cplus_plus.
However, in this book we will use only the types int, double, and occasionally long.
For most simple applications, you should not need any types except int and double.
However, if you are writing a program that uses very large whole numbers, then you might need to use the type long.
Precision short (also called 2 bytes.
The values for any of these entries may be different on your system.
Precision refers to the number of meaningful digits, including digits in front of the decimal point.
The ranges for the types float, double, and long double are the ranges for positive numbers.
Negative numbers have a similar range, but with a negative sign in front of each number.
Cplus_plus11 Types The size of  data types can vary from one machine to another.
For example, on a 32-bit machine an  might be 4 bytes while on a 64-bit machine an  might be 8 bytes.
Sometimes this is problematic if you need to know exactly what range of values can be stored in an  type.
To address this problem, new  types were added to Cplus_plus11 that specify exactly the size and whether or not the data type is signed or unsigned.
These types are accessible by including <cstdint>.
Display 2_0_3 illustrates some of these number types.
In this text we will primarily use the more ambiguous types of int and long, but consider the Cplus_plus11 types if you want to specify an exact size.
Cplus_plus11 also includes a type named auto that deduces the type of a variable based on an expression on the right side of the equal sign.
For example, the following line of code defines a variable named  whose data type matches whatever is computed from "expression": auto  = expression; This feature doesn't buy us much at this point but will save us some long, messy code when we start to work with longer data types that we define ourselves.
Cplus_plus11 Fixed Width Integer Types This code declares y to be the same type as *3_0_5.
The expression *3_0_5 is a double so y is declared as a double.
The Type char We do not want to give you the impression that computers and Cplus_plus are used only for numeric calculations, so we will introduce some nonnumeric types now, though eventually we will see other more complicated nonnumeric types.
Values of the type char, which is short for character, are single symbols such as a letter, digit, or punctuation mark.
Values of this type are frequently called characters in books and in conversation, but in a Cplus_plus program this type must always be spelled in the abbreviated fashion char.
For example, the variables symbol and letter of type char are declared as follows: char symbol, letter; A variable of type char can hold any single character on the keyboard.
So, for example, the variable symbol could hold an 'A' or a '+' or an 'a'.
Note that uppercase and lowercase versions of a letter are considered different characters.
The text in double quotes that are output using cout are called string values.
For example, the following, which occurs in the program in Display 2_0_1, is a string: 2_0_3 Data Types and Expressions Be sure to notice that string constants are placed inside of double quotes, while constants of type char are placed inside of single quotes.
The two kinds of quotes mean different things.
The fact that the string happens to contain only one character does not make "A" a value of type char.
Also notice that, for both strings and characters, the left and right quotes are the same.
The use of the type char is illustrated in the program shown in Display 2_0_4.
Notice that the user types a space between the first and second initials.
Yet the program skips over the blank and reads the letter B as the second input character.
When you use cin to read input into a variable of type char, the computer skips over all blanks and line breaks until it gets to the first nonblank character and reads that nonblank character into the Display 2_0_4   The Type char 1 2 3 4 5.
Sample Dialogue Enter two initials, without any periods: J B The two initials are: JB Once more with a space: J B That's all.
Chapter 2 / Cplus_plus Basics variable.
It makes no difference whether there are blanks in the input or not.
The program in Display 2_0_4 will give the same output whether the user types in a blank between initials, as shown in the sample dialogue, or the user types in the two initials without a blank, like so: JB The Type bool The next type we discuss here is the type bool.
This type was added to the Cplus_plus language by the ISO/ANSI (International Standards Organization/ American National Standards Organization) committee in 1998.
Expressions of type bool are called Boolean after the English mathematician George Boole (1815–1864), who formulated rules for mathematical logic.
Boolean expressions evaluate to one of the two values, true or false.
Boolean expressions are used in branching and looping statements that we study in Section 2_0_4.
We will say more about Boolean expressions and the type bool in that section.
Introduction to the Class string Although Cplus_plus lacks a native data type to directly manipulate strings, there is a string class that may be used to process strings in a manner similar to the data types we have seen thus far.
The distinction between a class and a native data type is discussed in Chapter 10.
Further details about the string class are discussed in Chapter 8.
To use the string class we must first  the string library: # <string>.
Note that a space is not automatically added between the strings.
If you wanted a space between the two days, then a space must be added explicitly: 1 + " " + 2 Display 2_0_5   The string Class 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20.
Sample Dialogue 1 Enter your middle name and the name of your pet.
Parker Pippen The name of your alter ego is Pippen Parker.
Sample Dialogue 2 Enter your middle name and the name of your pet.
Bojangles The name of your alter ego is Mr.
Chapter 2 / Cplus_plus Basics When you use cin to read input into a string variable, the computer only reads until it encounters a whitespace character.
Whitespace characters are all the characters that are displayed as blank spaces on the screen, including the blank or space character, the tab character, and the new- character '\n'.
This means that you cannot input a string that contains spaces.
This may sometimes cause errors, as indicated in Display 2_0_5, Sample Dialogue 2.
In this case, the user intends to enter "Mr.
Bojangles" as the name of the pet, but the string is only read up to "Mr_0_" since the next character is a space.
The "Bojangles" string is ignored by this program but would be read next if there was another cin statement.
Chapter 8 describes a technique to input a string that may  spaces.
Type Compatibilities As a general rule, you cannot store a value of one type in a variable of another.
The constant 2_0_99 is of type double and the variable  is of type int.
Unfortunately, not all compilers will react the same way to the above assignment statement.
Some will issue an error message, some will give only a warning message, and some compilers will not object at all.
But even if the compiler does allow you to use this assignment, it will probably give  the int value 2, not the value 3.
Since you cannot count on your compiler accepting this assignment, you should not assign a double value to a variable of type int.
The same problem arises if you use a variable of type double instead of the constant 2_0_99.
Most compilers will also object to the following:.
The fact that the value 2_0_00 "comes out even" makes no difference.
The value 2_0_00 is of type double, not of type int.
As you will see shortly, you can replace 2_0_00 with 2 in the preceding assignment to the variable , but even that is not enough to make the assignment acceptable.
The variables and  are of different types, and that is the cause of the problem.
Even if the compiler will allow you to mix types in an assignment statement, in most cases you should not.
Doing so makes your program less portable, and it can be confusing.
For example, if your compiler lets you assign 2_0_99 to a variable of type int, the variable will receive the value 2, 2_0_3 Data Types and Expressions rather than 2_0_99, which can be confusing since the program seems to say the value will be 2_0_99.
There are some special cases where it is permitted to assign a value of one type to a variable of another type.
It is acceptable to assign a value of type int to a variable of type double.
For example, the following is both legal and acceptable style: double ; = 2; The above will set the value of the variable named  equal to 2_0_0.
Although it is usually a bad idea to do so, you can store an int value such as 65 in a variable of type char and you can store a letter such as 'Z' in a variable of type int.
For many purposes, the C language considers the characters to be small integers; and perhaps unfortunately, Cplus_plus inherited this from C.
The reason for allowing this is that variables of type char consume less memory than variables of type int and so doing arithmetic with variables of type char can save some memory.
However, it is clearer to use the type int when you are dealing with integers and to use the type char when you are dealing with characters.
The general rule is that you cannot place a value of one type in a variable of another type—though it may seem that there are more exceptions to the rule than there are cases that follow the rule.
Even if the compiler does not enforce this rule very strictly, it is a good rule to follow.
Placing data of one type in a variable of another type can cause problems, since the value must be changed to a value of the appropriate type and that value may not be what you would expect.
Values of type bool can be assigned to variables of an integer type (short, int, long) and integers can be assigned to variables of type bool.
However, it is poor style to do this and you should not use these features.
For completeness and to help you read other people's code, we do give the details: When assigned to a variable of type bool, any nonzero integer will be stored as the value true.
Zero will be stored as the value false.
When assigning a bool value to an integer variable, true will be stored as 1 and false will be stored as 0.
Arithmetic Operators and Expressions In a Cplus_plus program, you can combine variables and/or numbers using the arithmetic operators + for addition, – for subtraction, * for multiplication, and / for division.
For example, the following assignment statement, which appears in the program in Display 2_0_1, uses the * operator to multiply the = one_weight * number_of_bars;.
Chapter 2 / Cplus_plus Basics All of the arithmetic operators can be used with numbers of type int, numbers of type double, and even with one number of each type.
However, the type of the value produced and the exact value of the result depends on the types of the numbers being combined.
If both operands (that is, both numbers) are of type int, then the result of combining them with an arithmetic operator is of type int.
If one, or both, of the operands is of type double, then the result is of type double.
For example, if the variables base_amount and increase are of type int, then the number produced by the following expression is of type int: base_amount + increase However, if one or both of the two variables is of type double, then the result is of type double.
This is also true if you replace the operator + with any of the operators –, *, or /.
The type of the result can be more significant than you might suspect.
For example, 7_0_0/2 has one operand of type double, namely 7_0_0.
Hence, the result is the type double number 3_0_5.
However, 7/2 has two operands of type int and so it yields the type int, which is the result 3.
Even if the result "comes out even," there is a difference.
For example, 6_0_0/2 has one operand of type double, namely 6_0_0.
Hence, the result is the type double number 3_0_0, which is only an approximate quantity.
However, 6/2 has two operands of type int, so it yields the result 3, which is of type int and so is an exact quantity.
The division operator is the operator that is affected most severely by the type of its arguments.
When used with one or both operands of type double, the division operator, /, behaves as you might expect.
However, when used with two operands of type int, the division operator, /, yields the integer part resulting from division.
In other words, integer division discards the part after the decimal point.
Notice that the number  not rounded; the part after the decimal point  discarded no matter how large it.
The operator % can be used with operands  type int to recover the information lost when you use / to do division with numbers  type int.
When used with values  type int, the two operators/ and % yield the two numbers produced when you perform the long division algorithm you learned in grade school.
For example, 17 divided by 5 yields 3 with a remainder  2.
The / operation yields the number  times one number "goes into" another.
The % operation gives the remainder.
For example, the statements << "17 divided by 5  " << (17/5) << endl; << "with a remainder  " << (17%5) << endl;.
Display 2_0_6   Integer Division 4 12/3 3  12 12 0 12%3 4 3  14 12 2 14/3 14%3 When used with negative values  type int, the result  the operators / and % can be different for different implementations  Cplus_plus.
Thus, you should use / and % with int values only when you know that both values are nonnegative.
Any reasonable spacing will do in arithmetic expressions.
You can insert spaces before and after operations and parentheses, or you can omit them.
Do whatever produces a result that  easy to read.
You can specify the order  operations by inserting parentheses, as illustrated in the following two expressions: (x + y) * z To evaluate the first expression, the computer first adds x and y and then multiplies the result by z.
To evaluate the second expression, it multiplies y and z and then adds the result to x.
Although you may be used to using mathematical formulas that contain square brackets and various other forms parentheses, that  not allowed in Cplus_plus.
Cplus_plus allows only one kind parentheses in arithmetic expressions.
The other varieties are reserved for other purposes.
If you omit parentheses, the computer will follow rules called precedence rules that determine the order in which the operators, such as + and *, are performed.
These precedence rules are similar to rules used in algebra and other mathematics classes.
For example, x + y * z evaluated by first doing the multiplication and then the addition.
Except in some standard cases, such as a string  additions or a simple multiplication embedded inside an addition, it  usually best to include the parentheses, even if the intended order  operations  the one dictated by the precedence rules.
The parentheses make the expression easier to read and less prone to programmer error.
A complete set  Cplus_plus precedence rules  given in Appendix 2.
Display 2_0_7 shows some examples  common kinds  arithmetic expressions and how they are expressed in Cplus_plus.
VideoNote Precedence and Arithmetic Operators 72 Chapter 2 / Cplus_plus Basics Display 2_0_7   Arithmetic Expressions Mathematical Formula Cplus_plus Expression.
Pitfall   Whole Numbers in Division When you use the division operator / on two whole numbers, the result  a whole number.
This can be a problem if you expect a fraction.
Moreover, the problem can easily go unnoticed, resulting in a program that looks fine but  producing incorrect output without your even being aware  the problem.
For example, suppose you are a landscape architect who charges $5,000 per mile to landscape a highway, and suppose you know the length  the highway you are working on in feet.
The price you charge can easily be calculated by the following Cplus_plus statement: = 5000 * (feet/5280_0_0); This works because there are 5,280 feet in a mile.
If the stretch  highway you are landscaping  15,000 feet long, this formula will tell you that the total price Your Cplus_plus program obtains the final value as follows: 15000/5280_0_0 computed as 2_0_84.
Then the program multiplies 5000 by 2_0_84 to produce the value 14200_0_00.
With the aid  your Cplus_plus program, you know that you should charge $14,200 for the project.
Now suppose the variable feet   type int, and you forget to put in the decimal point and the zero, so that the assignment statement in your program reads: = 5000 * (feet/5280); It still looks fine but will cause serious problems.
If you use this second form the assignment statement, you are dividing two values  type int, so the result  the division feet/5280  15000/5280, which  the int value 2 (instead  the value 2_0_84, which you think you are getting).
So the value assigned to total_cost  5000 * 2, or 10000_0_00.
If you forget the decimal point, you will charge $10,000.
However, as we have already seen, the correct value is $14,200.
A missing decimal point has cost you $4,200.
Note that this will be true whether the type of  is int or double; the damage is done before the value is assigned to.
Convert each of the following mathematical formulas to a Cplus_plus expression: 3x 3x + y x + y 7 3x + y z + 2 16.
What is the output of the following program lines when embedded in.
Write  complete Cplus_plus program that reads two whole numbers into two variables of type int and then outputs both the whole- part and the remainder when the first  is divided by the second.
What value is assigned.
Rewrite the code as the programmer intended.
What is the output of the following program lines when embedded in correct program that declares , , , and   be of type string.
Chapter 2 / Cplus_plus Basics More Assignment Statements There is  shorthand notation that combines the assignment  (=) and an arithmetic  so that  given variable can have its value changed by adding, subtracting, multiplying by, or dividing by  specified value.
The general form is = Expression which is equivalent is an  such as +, *, or *.
The Expression can be another variable, constant, or  more complicated arithmetic expression.
Following are examples: Example.
The programs you have seen thus far each consist of  simple list of statements  be executed in the order given.
However,  write more sophisticated programs, you will also need some way  vary the order in which statements are executed.
The order in which statements are executed is often referred  as flow of control.
In this section we will present two simple ways  add some flow of control  your programs.
We will discuss  branching mechanism that lets your program choose between two alternative actions, choosing one or the other depending on the values of variables.
We will also present  looping mechanism that lets your program repeat an action   of times.
For example, suppose you want  design  program compute  week's salary for an hourly employee.
Assume the firm pays an overtime rate of one-and-one-half times the regular rate for all hours after the first 40 hours worked.
As long as the employee works 40 or more hours, the pay is then equal However, if there is  possibility that the employee will work less than 40 hours, this formula will unfairly pay  negative  of overtime.
The poor employee will get  negative paycheck_0_) The correct pay formula for an employee who works less than 40 hours is simply rate * hours If both more than 40 hours and less than 40 hours of work are possible, then the program will need  choose between the two formulas.
In order compute the employee's pay, the program action should be Decide whether or not (hours > 40) is true.
If it is, do the following assignment statement: = rate * 40 + 1_0_5 * rate * (hours - 40);.
There is  Cplus_plus statement that does exactly this kind of branching action.
The if-else statement chooses between two alternative actions.
For example, the wage calculation we have been discussing can be accomplished with the following Cplus_plus statement: = rate * 40 + 1_0_5 * rate * (hours - 40); else = rate * hours; A complete program that uses this statement is given in Display 2_0_8.
Two forms of an if-else statement are described in Display 2_0_9.
The first is the simple form of an if-else statement; the second form will be discussed in the subsection entitled "Compound Statements_0_" In the first form shown, the two statements may be any executable statements.
The Boolean_ Expression is  test that can be checked  see if it is true or false, that is, see if it is satisfied or not.
For example, the Boolean_Expression in the earlier if-else statement is hours > 40 75.
Chapter 2 / Cplus_plus Basics When the program reaches the if-else statement, exactly one of the two embedded statements is executed.
If the Boolean_Expression is true (that is, if it is satisfied), then the Yes_Statement is executed; if the Boolean_Expression is false (that is, if it is not satisfied), then the No_Statement is executed.
Notice that the Boolean_Expression must be enclosed in parentheses.
Sample Dialogue 1 Enter the hourly  of : $20_0_00 Enter the number of  worked, rounded to a whole number of : 30 = 30 Hourly   = $20_0_00 = $600_0_00 2_0_4 Simple Flow of Control Sample Dialogue 2 Enter the hourly  of : $10_0_00 Enter the number of  worked, rounded to a whole number of : 41 = 41 Hourly   = $10_0_00 = $415_0_00 Display 2_0_9   Syntax for an if-else Statement A Single Statement for Each Alternative: 1 2 3 4 Yes_Statement else No_Statement A Sequence of Statements for Each Alternative: 5 6 7 8 9 10 10 12 13 14 15 16 17 18 { Yes_Statement_1 Yes_Statement_2 _0__0_.
No_Statement_Last } A Boolean expression is any expression that is either true or false.
An if-else statement always contains a Boolean_Expression.
The simplest form for a Boolean_Expression consists of two expressions, such as numbers or variables, that are compared with one of the comparison operators shown in Display 2_0_10.
Notice that some of the operators are spelled with two symbols: for , ==, _0_=, <=, >=.
Be sure to notice that you use a double  == for 77.
Chapter 2 / Cplus_plus Basics Display 2_0_10   Comparison Operators Math Symbol English.
Such operators should not have any space between  two.
The part of  compiler that separates  characters into Cplus_plus names and  will see  _0_=, for , and tell  rest of  compiler that  programmer meant to test for INEQUALITY.
When an if-else statement is executed,  two expressions being compared are evaluated and compared using  operator.
If  comparison turns out to be true, then  first statement is performed.
If  comparison fails, then  second statement is executed.
You can combine two comparisons using  "and" operator, which is spelled && in Cplus_plus.
For ,  following Boolean expression is true (that is, is satisfied) provided  is greater than 2 and  is less than 7: When two comparisons are connected using a &&,  entire expression is true, provided both of  comparisons are true (that is, provided both are satisfied); otherwise,  entire expression is false.
You can also combine two comparisons using  "or" operator, which is spelled || in Cplus_plus.
For ,  following is true provided y is less than 0 or y is greater than 12: When two comparisons are connected using a ||,  entire expression is true provided that one or both of  comparisons are true (that is, satisfied); otherwise,  entire expression is false.
Remember that when you use a Boolean expression in an if-else statement,  Boolean expression must be enclosed in parentheses.
Therefore, an if-else statement that uses  && operator and two comparisons is parenthesized as follows:.
You can negate any Boolean expression using.
If you want to negate a Boolean expression, place  expression in parentheses and place.
For ,_0_( < y)means " is The "and" Operator && You can form a more elaborate Boolean expression by combining two simple tests using  "and" operator &&.
If  value of score is greater than 0 and  value of score is also less than 10, then  first  statement will be executed; otherwise, second  statement will be executed.
Since  Boolean expression in an if-else statement must be enclosed in parentheses, you should place a second pair of parentheses around negated expression when it is used in an if-else statement.
For , an if-else statement might begin as follows: _0__0_.
For example, our hypothetical if-else statement can instead begin with  following, which is equivalent and easier to read: _0__0_.
We will not have much call to use.
Chapter 2 / Cplus_plus Basics Sometimes you want one of  two alternatives in an if-else statement to do nothing at all.
In Cplus_plus this can be accomplished by omitting  else part.
These sorts of statements are referred to as if statements to distinguish them from if-else statements.
For example,  first of  following two statements is an if statement: =  + bonus; << " = $" << ; If  value of  is greater than or equal to  value of minimum, assignment statement is executed and then  following  statement is executed.
On  other hand, if  value of  is less than minimum, then embedded assignment statement is not executed, so  if statement causes no change (that is, no bonus is added to  base ), and program proceeds directly to   statement.
The "or" Operator || You can form a more elaborate Boolean expression by combining two simple tests using  "or" operator ||.
Pitfall   Strings of Inequalities Do not use a string of inequalities such as  following in your program: << "z is between  and y_0_";.
We will explain why this happens after we learn more details about  Cplus_plus language.
The same problem will occur with a string  comparisons using any   comparison operators;  problem is not limited to < comparisons.
The correct way to express a string  inequalities is to use  "and" operator && as follows: correct form << "z is between  and y_0_"; ■ = in place  == Unfortunately, you can write many things in Cplus_plus that you would think are incorrectly formed Cplus_plus statements but turn out to have some obscure meaning.
This means that if you mistakenly write something that you would expect to produce an error message, you may find out that the program compiles and runs with no error messages, but gives incorrect output.
Since you may not realize you wrote something incorrectly, this can cause serious problems.
By the time you realize something is wrong, the mistake may be very hard to find.
One common mistake is to  the = when you  ==.
For example, consider an if-else statement that begins as follows: Do_Something else Do_Something_Else Suppose you wanted to test to see if the value   is equal to 12 so that you really meant to  == rather  =.
You might think the compiler will catch your mistake.
The expression = 12 is not something that is satisfied or not.
It is an assignment statement, so surely the compiler will give an error message.
Unfortunately, that is not the case.
In Cplus_plus the expression  = 12 is an expression that returns (or has) a value, just like  + 12 or 2 + 3.
An assignment expression's value is the value transferred to the variable on the left.
For example, the value   = 12 is 12.
We saw in our discussion  Boolean value compatibility that int values may be converted to true or false.
Since 12 is not zero, it is converted to true.
If you   = 12 as the Boolean expression in an if statement, the Boolean expression is always true, so the first branch (Do_Something) is always executed.
This error is very hard to find because it looks correct.
The compiler can find the error without any special instructions if you put the 12 on the left side the comparison, as in VideoNote Common Bugs with =  == 81.
Do_Something_Else; Then,  compiler will give  error message  you mistakenly  = instead  ==.
Remember that dropping one   = in  == is a common error that is not caught by many compilers, is very hard to see,  is almost certainly not what you wanted.
In Cplus_plus, many executable statements can also be used as almost any kind  expression, including as a Boolean expression for -else statement.
If you put  assignment statement where a Boolean expression is expected,  assignment statement will be interpreted as a Boolean expression.
Of course  result   "test" will undoubtedly not be what you intended as  Boolean expression.
The -else statement above looks fine at a quick glance  it will compile  run.
But, in all likelihood, it will produce puzzling results when it is run.
To accomplish this, enclose  statements for each branch between a pair  braces, {  }, as indicated in  second syntax template in Display 2_0_9  illustrated in Display 2_0_11.
A list  statements enclosed in a pair  braces is called a compound statement.
A compound statement is treated as a single statement by Cplus_plus  may be used anywhere that a single statement may be used.
Syntax rules for -else demand that  Yes statement  No statement be exactly one statement.
If more statements are desired for a branch, statements must be enclosed in braces to convert them to one compound statement.
If two or more statements not enclosed by braces are placed between     else, then  compiler will give  error message.
Display 2_0_11   Compound Statements Used With -else 1 2 3 4 5 6 7 8 9 10.
S el f -T est Exer cis es 21.
Write  -else statement that outputs  word High   value variable score is greater  100  Low   value  score is at most 100.
The variable score is  type int.
Suppose savings  expenses are variables  type double that have been given values.
Write  -else statement that outputs  word Solvent, decreases  value  savings by  value  expenses, sets  value  expenses to 0, provided that savings is at least as large as expenses.
If, however, savings is less  expenses,  -else statement simply outputs  word Bankrupt  does not change value  any variables.
Write  -else statement that outputs  word Passed provided value   variable exam is greater  or equal to 60   value variable programs_done is greater  or equal to 10.
Otherwise, -else statement outputs  word Failed.
The variables exam programs_done are both  type int.
Write  -else statement that outputs  word Warning provided that either  value   variable temperature is greater  or equal to 100, or  value   variable pressure is greater  or equal to 200, or both.
Otherwise,  -else statement outputs  word OK.
The variables temperature  pressure are both  type int.
Consider a quadratic expression, say 2 -  - 2 Describing where this quadratic is positive (that is, greater  0), involves describing a set  numbers that are either less than  smaller root (which is -1) or greater than  larger root (which is +2).
Write a Cplus_plus Boolean expression that is true when this formula has positive values.
Consider  quadratic expression 2 - 4 + 3 Describing where this quadratic is negative involves describing a set numbers that are simultaneously greater than  smaller root (+1) less than  larger root (+3).
Write a Cplus_plus Boolean expression that is true when  value  this quadratic is negative.
What is  output   following  statements embedded in these -else statements.
You are to assume that these are embedded in a complete correct program.
Explain your answer.
Simple Loop Mechanisms Most programs include some action that is repeated a number  times.
For example,  program in Display 2_0_8 computes  gross pay for one worker.
If  company employs 100 workers, then a more complete payroll program would repeat this calculation 100 times.
A portion  a program that repeats a statement or group  statements is called a loop.
The Cplus_plus language has a number of ways to create loops.
One of these constructions is called a while statement or while loop.
We will first illustrate its use with a short toy example and then do a more realistic example.
The program in Display 2_0_12 contains a simple while statement shown in color.
The portion between the braces, { and }, is called the body of the while loop; it is the action that is repeated.
The statements inside the braces are executed in order, then they are executed again, then again, and so forth until the while loop ends.
In the first sample dialogue, the body is executed three times before the loop ends, so the program outputs Hello three times.
Each repetition of the loop body is called an iteration of the loop, and so the first sample dialogue shows three iterations of the loop.
The meaning of a while statement is suggested by the English word while.
The loop is repeated while the Boolean expression in the parentheses is satisfied.
In Display 2_0_12 this means that the loop body is repeated as long as the value of the variable count_down is greater than 0.
Let's consider the first sample dialogue and see how the while loop performs.
The user types in 3 so the cin statement sets the value of count_down to 3.
Thus, in this case, when the program reaches the while statement, it is certainly true that count_down is greater than 0, so the statements in the loop body are executed.
Every time the loop body is repeated, the following two statements are executed: 2_0_4 Simple Flow of Control Display 2_0_12   A while Loop 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17.
Sample Dialogue 1 How many greetings do you want.
Sample Dialogue 2 How many greetings do you want.
Sample Dialogue 3 How many greetings do you want.
The loop body is executed.
After the computer repeats the loop body three times, the value of  is decreased to 0 85.
Chapter 2 / Cplus_plus Basics Display 2_0_13   Syntax of the while Statement A Loop Body with Several Statements: 1 2 3 4 5 6 7 { Statement_1 Statement_2 _0__0_.
Statement_Last } Do NOT put a.
So, this while statement ends after repeating the loop body three times.
The syntax for a while statement is given in Display 2_0_13.
The Boolean_ Expressions allowed are exactly the same as the Boolean expressions allowed in an if-else statement.
Just as in if-else statements, the Boolean expression in a while statement must be enclosed in parentheses.
In Display 2_0_13 we have given the syntax templates for two cases: the case when there is more than one statement in the loop body and the case when there is just a single statement in the loop body.
Note that when there is only a single statement in the loop body, you need not  the braces { and }.
Let's go over the actions performed by a while statement in greater detail.
When the while statement is executed, the first thing that happens is that the Boolean expression following the word while is checked.
It is either true or false.
For example, the comparison > 0 is true if the value of  is positive.
If it is false, then no action is taken and the program proceeds to the next statement after the while statement.
If the comparison is true, then the entire body of the loop is executed.
At least one of the expressions being compared typically contains something that might be changed by the loop body, such as the value of in the while statement in Display 2_0_12.
After the body of the loop is executed, the comparison is again checked.
This process is repeated again and again as long as the comparison continues to be true.
After each iteration of the loop body, the comparison is again checked and if it is true, then the entire loop body is executed again.
When the comparison is no longer true, the while statement ends.
If the Boolean expression is not true when the while statement begins, then the loop body is never executed.
That is exactly what happens in Sample Dialogue 3 of Display 2_0_12.
In many programming situations you want the possibility of executing the loop body zero times.
For example, if your while loop is reading a list consisting of all the failing scores on an exam and nobody failed the exam, then you want the loop body to be executed zero times.
As we just noted, a while loop might execute its loop body zero times, which is often what you want.
If, on the other hand, you know that under all circumstances your loop body should be executed at least one time, then you can use a do-while statement.
A do-while statement is similar to a while statement except that the loop body is always executed at least once.
The syntax for a do-while statement is given in Display 2_0_14.
A program with a sample do-while loop is given in Display 2_0_15.
In that do-while loop, as in any do-while loop, the first thing that happens is that the statements in the loop body are executed.
After that first iteration of the loop body, the dowhile statement behaves the same as a while loop.
The Boolean expression is checked.
If the Boolean expression is true, the loop body is executed again; the Boolean expression is checked again, and so forth.
Increment and Decrement Operators We discussed binary operators in the section entitled "Arithmetic Operators and Expressions_0_" Binary operators have two operands.
Unary operators have only one operand.
You already know of two unary operators, + and –, as used in the expressions +7 and –7.
The Cplus_plus language has two other very common unary operators, plus_plus and ––.
The plus_plus operator is called the increment operator Display 2_0_14   Syntax of the do-while Statement A Loop Body with Several Statements: 1 2 3 4 5 6 7 do { Statement_1 Statement_2 _0__0_.
Statement_Last } while (Boolean_Expression); body Do not forget the final semicolon.
A Loop Body with a Single Statement: 8 9 10 do Statement.
Chapter 2 / Cplus_plus Basics Display 2_0_15   A do-while Loop 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16.
Sample Dialogue Hello Do you want another greeting.
Press y for yes, n for no, and then press return: y Hello Do you want another greeting.
Press y for yes, n for no, and then press return: Y Hello Do you want another greeting.
Press y for yes,  for no, and then press return: Good-Bye and the –– operator is called the decrement operator.
If  is a variable of type int, then nplus_plus increases the value of  by one and –– decreases the value of  by one.
So nplus_plus and –– (when followed by a semicolon) are executable statements.
For example, the statements.
For example, we used the following statement in the while loop in Display 2_0_12: =  - 1; However, most experienced Cplus_plus programmers would use the decrement operator rather than the assignment statement, so the entire while loop would read as follows:.
Charge Card Balance Suppose you have a bank charge card with a balance owed of $50 and suppose the bank charges you 2% per month interest.
How many months can you let pass without making any payments before your balance owed will exceed $100.
One way  solve this problem is  simply read each monthly statement and count the number of months that go by until your balance reaches $100 or more.
Better still, you can calculate the monthly balances with a program rather than waiting for the statements  arrive.
In this way you will obtain an answer without having  wait so long (and without endangering your credit rating).
After one month the  would be $50 plus 2% of $50, which is $51.
After two months the  would be $51 plus 2% of $51, which is $52_0_02.
After three months the  would be $52_0_02 plus 2% of $52_0_02, and so on.
In general, each month increases the  by 2%.
The program could keep track of the  by storing it in a  called.
The change in the value of  for one month can be calculated as follows: =  + 0_0_02 *  ; If we repeat this action until the value of  reaches (or exceeds) 100_0_00 and we count the number of repetitions, then we will know the number of months it will take for the   reach 100_0_00.
To do this, we need another   count the number of times the  is changed.
Let us call this new  count.
The final body of our while loop will thus contain the following statements: 89.
In order  make this loop perform correctly, we must give appropriate values the variables  and count before the loop is executed.
In this case, we can initialize the variables when they are declared.
The complete program is shown in Display 2_0_16.
Pitfall   Infinite Loops A while loop or a do-while loop does not terminate as long as the Boolean expression after the word while is true.
This Boolean expression normally contains a  that will be changed by the loop body, and usually the value of this  eventually is changed in a way that makes the Boolean expression false and therefore terminates the loop.
However, if you make a mistake and write your program so that the Boolean expression is always true, then the loop will run forever.
A loop that runs forever is called an infinite loop.
First let's describe a loop that does terminate.
The following Cplus_plus code will write out the positive even numbers less than 12.
That is, it will output the numbers 2, 4, 6, 8, and 10, one per line, and then the loop will end.
The value of  is increased by 2 on each loop iteration until it reaches 12.
At that point, the Boolean expression after the word while is no longer true, so the loop ends.
Now suppose you want  write out the odd numbers less than 12, rather than the even numbers.
You might mistakenly think that all you need do is change the initializing statement = 1; but this mistake will create an infinite loop.
Because the value of  goes from 11  13, the value of  is never equal  12, so the loop will never terminate.
This sort of problem is common when loops are terminated by checking a numeric quantity  ==  _0_=.
When dealing with numbers, it is always safer  test for passing a value.
For example, the following will work fine as the first line of our while loop: With this change,  can be initialized  any number and the loop will still terminate.
Since you can now write programs that contain an infinite loop, it is a good idea  learn how  force a program  terminate.
The method for forcing a program  stop varies from system  system.
The keystrokes Control-C will terminate a program on many systems.
Sample Dialogue This program tells you how long it takes to accumulate a debt of $100, starting with an initial  of $50 owed.
The interest rate is 2% per month.
Chapter 2 / Cplus_plus Basics S el f -T est Exe r cis es 28.
What is the output produced by the following (when embedded in a correct program with  declared to  of type int).
What output would  produced in the previous exercise if the > sign were replaced with <.
What is the output produced by the following (when embedded in a correct program with  declared to  of type int).
What is the most important difference between a while statement and a do-while statement.
What is the output produced by the following (when embedded in a correct program with  declared to  of type int).
Oscar Wilde, The Importance of Being Earnest All the variable names in our sample programs were chosen to suggest their use.
Our sample programs were laid out in a particular format.
For example, the declarations and statements were all indented the same amount.
These and other matters of style are of more than aesthetic interest.
A program that is written with careful attention to style is easier to read, easier to correct, and easier to change.
Indenting A program should  laid out so that elements that are naturally considered a group are made to look like a group.
One way to do this is to skip a line between parts that are logically considered separate.
Indenting can also help to make the structure of the program clearer.
A statement within a statement should  indented.
In particular, if-else statements, while loops, and dowhile loops should  indented either as in our sample programs  in some similar manner.
The braces {} determine a large part of the structure of a program.
Placing each brace on a line by itself, as we have been doing, makes it easy to find the matching pairs.
Notice that we have indented some pairs of braces.
When one pair of braces is embedded in another pair, the embedded braces are indented more than the outer braces.
Look back at the program in Display 2_0_16.
The braces for the body of the while loop are indented more than the braces for the main part of the program.
There are at least two schools of thought on where you should place braces.
The first, which we use in this book, is to reserve a separate line for each brace.
This form is easiest to read.
The second school of thought holds that the opening brace for a pair need not  on a line by itself.
If used with care, this second method can  effective, and it does save space.
The important point is to use a style that shows the structure of the program.
The exact layout is not precisely dictated, but you should  consistent within any one program.
Comments In order to make a program understandable, you should  some explanatory notes at key places in the program.
Such notes are called comments.
Cplus_plus and most other programming languages have provisions for including such comments within the text of a program.
In Cplus_plus the symbols // are used to indicate the start of a comment.
All of the text between the // and the end of the line is a comment.
The compiler simply ignores anything that 93.
Chapter 2 / Cplus_plus Basics follows // on a line.
If you want a comment that covers more than one line, place a // on each line of the comment.
The symbols // are two slashes (without a space between them).
In this book, comments will always  written in italic so that they stand out from the program text.
Some text editors indicate comments by showing them in a different color from the rest of the program text.
There is another way to insert comments in a Cplus_plus program.
Anything between the symbol pair /* and the symbol pair */ is considered a comment and is ignored by the compiler.
Unlike the // comments, which require an additional // on each line, the /* to */ comments can span several lines, like so: /*This is a comment that spans three lines.
Note that there is no comment symbol of any kind on the second line_0_*/ Comments of the /* */ type may  inserted anywhere in a program that a space or line break is allowed.
However, they should not  inserted anywhere except where they are easy to read and do not distract from the layout of the program.
Usually, comments are only placed at the ends of lines or on separate lines by themselves.
There are differing opinions on which kind of comment is best to use.
Either variety (the // kind or the /* */ kind) can  effective if used with care.
We will use the // kind in this book.
It is difficult to say just how many comments a program should contain.
The only correct answer is "just enough," which of course conveys little to the novice programmer.
It will take some experience to get a feel for when it is best to include a comment.
Whenever something is important and not obvious, it merits a comment.
However, too many comments are as bad as too few.
A program that has a comment on each line will be so buried in comments that the structure of the program is hidden in a sea of obvious observations.
Comments like the following contribute nothing to understanding and should not appear in a program: = speed * time; //Computes the  traveled Notice the comment given at the start of the program in Display 2_0_17.
All programs should begin with a comment similar to the one shown there.
It gives all the essential information about the program: what file the program is in, who wrote the program, how to contact the person who wrote the program, what the program does, the date that the program was last modified, and any other particulars that are appropriate, such as the assignment number, if the program is a class assignment.
Exactly what you include in this comment will depend on your particular situation.
We will not include such long comments in the programs in the rest of this book, but you should always begin your programs with a similar comment.
Sample Dialogue Enter your temperature: 98_0_6 You don't have a fever.
Naming Constants There are two problems with numbers in a computer program.
The first is that they carry no mnemonic value.
For example, when the number 10 is encountered in a program, it gives no hint of its significance.
If the program is a banking program, it might be the number of branch offices or the number of teller windows at the main office.
In order to understand the program, 96 Chapter 2 / Cplus_plus Basics you need to know the significance of each constant.
The second problem is that when a program needs to have some numbers changed, the changing tends to introduce errors.
Suppose that 10 occurs twelve times in a banking program, that four of the times it represents the number of  offices, and that eight of the times it represents the number of teller windows at the main office.
When the bank opens a new  and the program needs to be updated, there is a good chance that some of the 10s that should be changed to 11 will not be, or some that should not be changed will be.
The way to avoid these problems is to name each number and use the name instead of the number within your program.
For example, a banking program might have two constants with the names  and.
Both these numbers might have a value of 10, but when the bank opens a new , all you need do in order to update the program is to change the definition of.
How do you name a number in a Cplus_plus program.
One way is to initialize a variable to that number value, as in the following example: int  = 10; int  = 10; There is, however, one problem with this method of naming number constants: You might inadvertently change the value of one of these variables.
Cplus_plus provides a way of marking an initialized variable so that it cannot be changed.
If your program tries to change one of these variables, it produces an error condition.
To mark a variable declaration so that the value of the variable cannot be changed, precede the declaration with the word const (which is an abbreviation of constant).
For example: const int  = 10; const int  = 10;.
The word const is often called a modifier, because it modifies (restricts) the variables being declared.
A variable declared using the const modifier is often called a declared constant.
Writing declared constants in all uppercase letters is not required by the Cplus_plus language, but it is standard practice among Cplus_plus programmers.
Once a number has been named in this way, the name can then be used anywhere the number is allowed, and it will have exactly the same meaning as the number it names.
To change a named constant, you need change only the initializing value in the const variable declaration.
The meaning of all occurrences of , for instance, can be changed from 10 to 11 simply by changing the initializing value of 10 in the declaration of.
It often makes sense to use unnamed number constants for well-known, easily recognizable, and unchangeable quantities, such as 100 for the number of centimeters in a meter.
However, all other numeric constants should be given names in the fashion we just described.
This will make your programs easier to read and easier to change.
Display 2_0_17 contains a simple program that illustrates the use of the declaration modifier const.
Naming Constants with the const Modifier When you initialize a variable inside a declaration, you can mark the variable so that the program is not allowed to change its value.
To do this, place the word const in front of the declaration, as described below: Syntax const   = Constant;.
S el f -T est Exer cis es 35.
The following if-else statement will compile and run without any problems.
However, it is not laid out in a way that is consistent with the other if-else statements we have used in our programs.
Rewrite it so that the layout (indenting and line breaks) matches the style we used in this chapter.
Write a complete Cplus_plus program that asks the user for a number of gallons and then outputs the equivalent number of liters.
There are 3_0_78533 liters in a gallon.
Use a declared constant.
Since this is just an exercise, you need not have any comments in your program.
Chapter 2 / Cplus_plus Basics Chapter Summary ■ Use meaningful names for variables.
This can be done when the variable is declared or with an assignment statement before the variable is first used.
An if statement allows your program to decide whether to perform some one particular action.
This can be done by using the modifier const in a variable declaration.
There is no unique right answer for this one.
Below are possible answers: a.
This makes the value of the entire expression 0 * 3 , which of course  0.
Answers to Self-Test Exercises b_0_	9/5 has int value 1; since numerator and denominator are both int, integer division  done; the fractional part  discarded.
The strings are concatenated with the + operator.
In the section on type compatibility, it  noted that the int value 0 converts to false.
In the section on type compatibility, it  noted that a nonzero int value converts to true.
In the section on type compatibility, it  noted that a nonzero int value converts to true.
There would be no output, since the Boolean expression (x < 0) not satisfied and so the while statement ends without executing the loop body.
The output  exactly the same as it was for Self-Test Exercise 27.
The body of the loop  executed before the Boolean expression  checked, the Boolean expression  false, and so the output -42 32.
With a do-while statement the loop body  always executed at least once.
With a while statement there can be conditions under which the loop body not executed at all.
This  an infinite loop.
The output would begin with the following and conceptually go on forever: 10 13 16 19 (Once the value of x becomes larger than the largest integer allowed on your computer, the program may stop or exhibit other strange behavior, 34.
Practice ProgramS Practice Programs can generally be solved with a short program that directly applies the programming principles presented in this chapter.
A metric ton  35,273_0_92 ounces.
Write a program that will read the weight of a package of breakfast cereal in ounces and output the weight in metric tons as well as the number of boxes needed to yield 1 metric ton of cereal.
Your program should allow the user to repeat this calculation as often as the user wishes.
The Babylonian algorithm to compute the square root of a number  is as follows: 1_0_	Make a  at the answer (you can pick /2 as your initial ).
The more that steps 2 and 3 are repeated, the closer  will become to the square root of.
Write a program that inputs a double for  and iterates through the Babylonian algorithm 100 times.
For a more challenging version, iterate until  is within 1% of the previous , and outputs the answer as a double.
VideoNote Solution to Practice ­Program 2_0_3 3_0_	Many treadmills output the speed of the treadmill in miles per hour (mph) on the console, but most runners think of speed in terms of a pace.
A common pace is the number of minutes and seconds per mile instead of mph.
Write a program that starts with a quantity in mph and converts the quantity into minutes and seconds per mile.
As an example, the proper output for an input of 6_0_5 mph should be 9 minutes and 13_0_8 seconds per mile.
If you need to convert a double to an int, which will discard any value after the decimal point, then you may use = <int>(dblVal); 4.
Write a program that plays the game of Mad Lib.
Your program should prompt the user to enter the following strings: ■ The first or last name of your instructor.
An animal After the strings are input, they should be substituted into the story below and output to the console.
Programming Projects Dear Instructor [Instructor Name], I am sorry that I am unable to turn in my homework at this time.
First, I ate a rotten [Food], which made me turn [Color] and extremely ill.
I came down with a fever of [Number 100-120].
Next, my [Adjective] pet [Animal] must have smelled the remains of the [Food] on my homework, because he ate it.
I am currently rewriting my homework and hope you will accept it late.
Sincerely, [Your Name] 5.
The following is a short program that computes the volume of a given the radius.
It will compile and run, but it does not adhere to the program style recommended in Section 2_0_5.
Rewrite the program using the style described in the chapter for indentation, adding comments, and appropriately named constants.
Programming Projects Programming Projects require more problem-solving than Practice Programs and can usually be solved many different ways.
Visit www_0_myprogramminglab_0_com to complete many of these Programming Projects online and get instant feedback.
A government research lab has concluded that an artificial sweetener commonly used in diet soda pop will cause death in laboratory mice.
A friend of yours  desperate to lose weight but cannot give up soda pop.
Your friend wants to know how much diet soda pop it  possible to drink without dying as a result.
Write a program to supply the answer.
The input to the program  the amount of artificial sweetener needed to kill a mouse (use 5 grams), the mass of the mouse (use 35 grams), and the weight of the dieter (use 45400 grams for a 100 pound person).
Assume that the lethal dose for a mouse  proportional to the lethal dose for the human.
A single can of soda pop has a mass of 350 grams.
To ensure the safety of your friend, be sure the program requests the weight at which the dieter will stop dieting, rather than the dieter's current weight.
Assume that diet 105.
Chapter 2 / Cplus_plus Basics soda contains 1/10th of 1% artificial sweetener.
Use a variable declaration with the modifier const to give a name to this fraction.
You may want to express the percent as the double value 0_0_001.
Your program should allow the calculation to be repeated as often as the user wishes.
Workers at a particular company have won a 7_0_6% pay increase retroactive for 6 months.
Write a program that takes an employee's previous salary as input, and outputs the amount of retroactive pay due the employee, the new  salary, and the new  salary.
Use a variable declaration with the modifier const to express the pay increase.
Your program should allow the calculation to be repeated as often as the user wishes.
The number of months  entered by the user.
Negotiating a consumer loan  not always straightforward.
One form of loan  the discount installment loan, which works as follows.
Suppose a loan has a face value of $1,000, the interest rate  15%, and the duration 18 months.
The interest  computed by multiplying the face value of $1,000 by 0_0_15, to yield $150.
That figure  then multiplied by the loan period of 1_0_5 years to yield $225 as the total interest owed.
That amount immediately deducted from the face value, leaving the consumer with only $775.
Repayment  made in equal  installments based on the face value.
So the  loan payment will be $1,000 divided by 18, which $55_0_56.
This method of calculation may not be too bad if the consumer needs $775 dollars, but the calculation  a bit more complicated if the consumer needs $1,000.
Write a program that will take three inputs: the amount the consumer needs to receive, the interest rate, and the duration of the loan in months.
The program should then calculate the face value required in order for the consumer to receive the amount needed.
It should also calculate the  payment.
Your program should allow the calculations to be repeated as often as the user wishes.
Write a program that determines whether a meeting room  in violation of fire law regulations regarding the maximum room capacity.
The program will read in the maximum room capacity and the number of people attending the meeting.
If the number of people  less than or equal to the maximum room capacity, the program announces that it  legal to hold the meeting and tells how many additional people may legally attend.
If the number of people exceeds the maximum room capacity, the program announces that the meeting cannot be held as planned due to fire regulations and tells how many people must be excluded in order to meet the fire regulations.
For a harder version, write your program so that it allows the calculation to be repeated as often as the user wishes.
If this  a class exercise, ask your instructor whether you should do this harder version.
Programming Projects 6.
An employee  paid at a rate of $16_0_78 per hour for the first 40 hours worked in a week.
Any hours over that are paid at the overtime rate of oneand-one-half times that.
From the worker's gross pay, 6%  withheld for Social Security tax, 14%  withheld for federal income tax, 5%  withheld for state income tax, and $10 per week  withheld for union dues.
If the worker has three or more dependents, then an additional $35  withheld to cover the extra cost of health insurance beyond what the employer pays.
Write a program that will read in the number of hours worked in a week and the number of dependents as input and will then output the worker's gross pay, each withholding amount, and the net take-home pay for the week.
For a harder version, write your program so that it allows the calculation to be repeated as often as the user wishes.
If this  a class exercise, ask your instructor whether you should do this harder version.
It  difficult to make a budget that spans several years, because prices are not stable.
If your company needs 200 pencils per year, you cannot simply use this year's price as the cost of pencils 2 years from now.
Because of inflation the cost  likely to be higher than it  today.
Write a program to gauge the expected cost of an item in a specified number of years.
The program asks for the cost of the item, the number of years from now that the item will be purchased, and the rate of inflation.
The program then outputs the estimated cost of the item after the specified period.
Have the user enter the inflation rate as a percentage, like 5_0_6 (percent).
Your program should then convert the percent to a fraction, like 0_0_056, and should use a loop to estimate the price adjusted for inflation.
You have just purchased a stereo system that cost $1,000 on the following credit plan: no down payment, an interest rate of 18% per year (and hence 1_0_5% per month), and  payments of $50.
The  payment of $50  used to pay the interest and whatever  left  used to pay part of the remaining debt.
Hence, the first month you pay 1_0_5% of $1,000 in interest.
So, the remaining $35  deducted from your debt, which leaves you with a debt of $965_0_00.
The next month you pay interest of 1_0_5% of $965_0_00, which  $14_0_48.
Hence, you can deduct $35_0_52 (which $50 – $14_0_48) from the amount you owe.
Write a program that will tell you how many months it will take you to pay off the loan, as well as the total amount of interest paid over the life of the loan.
Use a loop to calculate the amount of interest and the size of the debt after each month.
You may want to use other variables as well.
The last payment may be less than $50.
Do not forget the interest on the last payment.
Chapter 2 / Cplus_plus Basics payment of $50 will not pay off your debt, although it will come close.
One month's interest on $50 is only 75 cents.
Write a program that reads in ten whole numbers and that outputs the sum of all the numbers greater than zero, the sum of all the numbers less than zero (which will be a negative number or zero), and the sum of all the numbers, whether positive, negative, or zero.
The user enters the ten numbers just once each and the user can enter them in any order.
Your program should not ask the user to enter the positive numbers and the negative numbers separately.
The temperature of the air affects the speed of the molecules, which in turn affects the speed of sound.
The velocity of sound in dry air can be approximated by the formula: velocity ≈ 331_0_3 + 0_0_61 × Tc where Tc is the temperature of the air in degrees Celsius and the velocity is in meters/second.
Write a program that allows the user to input a starting and an ending temperature.
Within this temperature range, the program should output the temperature and the corresponding velocity in 1° increments.
For example, if the user entered 0 as the start temperature and 2 as the end temperature, then the program should output At 0 degrees Celsius the velocity of sound is 331_0_3 m/s At 1 degrees Celsius the velocity of sound is 331_0_9 m/s At 2 degrees Celsius the velocity of sound is 332_0_5 m/s VideoNote Solution to Programming Project 2_0_12 12_0_	Many private water wells produce only 1 or 2 gallons of water per minute.
One way to avoid running out of water with these low-yield wells is to use a holding tank.
A family of four will use about 250 gallons of water per day.
However, there is a "natural" water holding tank in the casing (that is, the hole) of the well itself.
A deeper well stores more water that can be pumped out for household use.
But how much water will be available.
Write a program that allows the user to input the radius of the well casing in inches (a typical well will have a 3-inch radius) and the depth of the well in feet (assume water will fill this entire depth, although in Programming Projects practice that will not be true since the static water level will generally be 50 feet or more below the ground surface).
The program should output the number of gallons stored in the well casing.
For your reference, the volume of a cylinder is p r2h, where r is the radius and h is the height, and 1 cubic  = 7_0_48 gallons of water.
For example, a 300--well full of water with a radius of 3 inches for the casing holds about 441 gallons of water—plenty for a family of four and no need to install a separate holding tank.
The Harris–Benedict equation estimates the number of calories your body needs to maintain your weight if you do no exercise.
This is called your basal metabolic rate, or.
The formula for the calories needed for a woman to maintain her weight is = 655 + (4_0_3 × weight in pounds) + (4_0_7 × height in inches) – The formula for the calories needed for a man to maintain his weight is = 66 + (6_0_3 × weight in pounds) + (12_0_9 × height in inches) – A typical chocolate bar will contain around 230 calories.
Write a program that allows the user to input his or her weight in pounds, height in inches, age in years, and the character M for male and F for female.
The program should then output the number of chocolate bars that should be consumed to maintain one's weight for the appropriate sex of the specified weight, height, and age.
Write a program that calculates the total grade for N classroom exercises as a percentage.
The user should input the value for N followed by each of the N scores and totals.
Calculate the overall percentage (sum of the total points earned divided by the total points possible) and output it as a percentage.
Sample input and output is shown below.
How many exercises to input.
It is important to consider the effect of thermal expansion when building a structure that must withstand changes in temperature.
For example, a metal beam will expand in hot temperatures.
The additional stress could cause the structure to fail.
Similarly, a material will contract in cold temperatures.
The linear change in length of a material if it is allowed to freely expand is described by the following equation: ∆ = 0T∆ Here, 0 is the initial length of the material in meters, ∆ is the displacement in meters, T∆ is the change in temperature in Celsius, and  is a coefficient for linear expansion.
Write a program that inputs , ∆, and T∆, then calculates and outputs the linear displacement.
If the displacement is positive then output that "The material will expand by" the displacement in meters.
If the 2_0_31 1_0_70 8_0_50 1_0_20 × × × × 10-5 10-5 10-6 10-5 More Flow of Control 3_0_1 Using Boolean Expressions 112 Evaluating Boolean Expressions 112 Pitfall: Boolean Expressions Convert to int Values 116 Enumeration Types (Optional) 119 3_0_2 Multiway Branches 120 Nested Statements 120 Programming Tip: Use Braces in Nested Statements 121 Multiway if-else Statements 123 Programming Example: State Income Tax 125 The switch Statement 128 Pitfall: Forgetting a break in a switch Statement 132 Using switch Statements for Menus 133 Blocks 135 Pitfall: Inadvertent Local Variables 138 Chapter Summary 165 Answers to Self-Test Exercises 166 3 3_0_3 More about Cplus_plus Loop Statements 139 The while Statements Reviewed 139 Increment and Decrement Operators Revisited 141 The for Statement 144 Pitfall: Extra Semicolon in a for Statement 149 What Kind of Loop to Use 150 Pitfall: Uninitialized Variables and Infinite Loops 152 The break Statement 153 Pitfall: The break Statement in Nested Loops 154 3_0_4 Designing Loops 155 Loops for Sums and Products 155 Ending a Loop 157 Nested Loops 160 Debugging Loops 162 Practice Programs 172 Programming Projects 174 When you come to a fork in the road, take it.
Attributed to Yogi Berra Introduction The order in which the statements in your program are performed is called flow of control.
The if-else statement, the while statement, and the dowhile statement are three  to specify flow of control.
This chapter explores some new  to use these statements and introduces two new statements called the switch statement and the for statement, which are also used for flow of control.
The actions of an if-else statement, a while statement, or a do-while statement are controlled by Boolean expressions.
We begin by discussing Boolean expressions in more detail.
Prerequisites This chapter uses material from Chapter 2.
Thus far you have used Boolean expressions  the test condition in if-else statements and  the controlling expression in loops, such  a while loop.
However, a Boolean expression has an independent identity apart from any if-else statement or loop statement you might use it in.
The Cplus_plus type bool provides you the ability to declare variables  can carry the values true and false.
A Boolean expression can be evaluated in the same way  an arithmetic expression is evaluated.
The only difference is  an arithmetic expression uses operations such  +, *, and / and produces a number  the final result, whereas a Boolean expression uses relational operations such  == and < and Boolean operations such  &&, ||, and.
First let's review evaluating an arithmetic expression; the same technique will work to evaluate Boolean expressions.
Consider the following arithmetic expression: Assume  the variable x has the value 2.
To evaluate this arithmetic expression, you evaluate the two sums to obtain the numbers 3 and 5, then you combine these two numbers 3 and 5 using the * operator to obtain 15  the final value.
Notice  in performing this evaluation, you do not multiply the expressions (x + 1) and (x + 3).
Instead, you multiply the values of these expressions.
The computer evaluates Boolean expressions the same way.
Subexpressions are evaluated to obtain values, each of which is either true or false.
These individual values of true or false are then combined according to the rules in the tables shown in Display 3_0_1.
For example, consider the Boolean expression which might be the controlling expression for an if-else statement or a while statement.
Suppose the value of  is 8.
In this case, ( < 3) evaluates to false and ( > 7) evaluates to true, so the Boolean expression above is equivalent to Consulting the tables for || (which is labeled OR in Display 3_0_1), the.
Consulting the tables again, the computer sees  _0_(true) evaluates to false, and so it concludes  false is the value of the original Boolean expression.
Almost all the examples we have constructed thus far have been fully parenthesized to show exactly how each &&, ||, and.
Parentheses are not always required.
If you omit parentheses, the default precedence is  follows: perform.
However, it is a good practice to include most parentheses in order to make the expression easier to understand.
One place where parentheses can safely be omitted is a simple string of &&'s or ||'s (but not a mixture of the two).
The following expression is acceptable in terms of both the Cplus_plus compiler and readability: 113.
Chapter 3 / More Flow of Control Display 3_0_1   Truth Tables AND Exp_1 Exp_2.
When parentheses are omitted from an expression, the computer groups items according to rules known  precedence rules.
Some of the precedence rules for Cplus_plus are given in Display 3_0_2.
If one operation is evaluated before another, the operation  is evaluated first is said to have higher precedence.
Binary operations of equal precedence are evaluated in left-to-right order.
Unary operations of equal precedence are evaluated in right-to-left order.
A complete set of precedence rules is given in Appendix 2.
Notice that the precedence rules include both arithmetic operators such as +  * as well as Boolean operators such as &&  ||.
This is because many expressions combine arithmetic  Boolean operations, as in the following simple example: (x + 1) > 2 || (x + 1) < -3 If you check the precedence rules given in Display 3_0_2, you will see that this expression is equivalent to because >  < have higher precedence than ||.
In fact, you could omit all the parentheses in the expression above  it would have the same meaning, 3_0_1 Using  Expressions Display 3_0_2   Precedence Rules The unary operators +, −, plus_plus, ––,.
Highest precedence The binary arithmetic  *, /, % The binary arithmetic  +, − The   <, >, <= , >= The   ==,.
Although we do not advocate omitting all the parentheses, it might be instructive to see how such an expression is interpreted using the precedence rules.
Here is the expression without any parentheses: + 1 > 2 ||  + 1 < -3 The precedence rules say first apply the unary 2, then apply the + signs, then do the >  the <,  finally do the ||, which is exactly what the fully parenthesized version says to do.
The preceding description of how a  expression is evaluated is basically correct, but in Cplus_plus, the computer actually takes an occasional shortcut when evaluating a  expression.
Notice that in many cases you need to evaluate only the first of two subexpressions in a  expression.
For example, consider the following: If  is negative, then ( >= 0) is false,  as you can see in the tables in Display 3_0_1, when one subexpression in an && expression is false, then the whole expression is false, no matter whether the other expression is true or false.
Thus, if we know that the first expression is false, there is no need to evaluate the second expression.
A similar thing happens with || expressions.
If the first of two expressions joined with the || operator is true, then you know the entire expression is true, no matter whether the second expression is true or false.
The Cplus_plus language uses this fact to sometimes save itself the trouble of evaluating the second subexpression in a logical expression connected with an && or an ||.
Cplus_plus first evaluates the leftmost of the two expressions joined by an && or an ||.
If that gives it enough information to determine the final value of the expression (independent of the value of the second expression), then Cplus_plus does not bother to evaluate the second expression.
This method of evaluation is called short-circuit evaluation.
Chapter 3 / More Flow of Control Some languages, other than Cplus_plus, use complete evaluation.
In complete evaluation, when two expressions are joined by an && or an ||, both subexpressions are always evaluated  then the truth tables are used to obtain the value of the final expression.
Both short-circuit evaluation  complete evaluation give the same answer, so why should you care that Cplus_plus uses short-circuit evaluation.
Most of the time you need not care.
As long as both subexpressions joined by the && or the || have a value, the two methods yield the same result.
However, if the second subexpression is undefined, you might be happy to know that Cplus_plus uses short-circuit evaluation.
Let's look at an example that illustrates this point.
Consider the following statement: << "Each child may have two pieces_0_"; If the value of  is not zero, this statement involves no subtleties.
However, suppose the value of  is zero  consider how short-circuit evaluation handles this case.
The expression (_0_= 0) evaluates to false, so there would be no need to evaluate the second expression.
Using short-circuit evaluation, Cplus_plus says that the entire expression is false, without bothering to evaluate the second expression.
This prevents a run-time error, since evaluating the second expression would involve dividing by zero.
Cplus_plus sometimes uses integers as if they were  values.
In particular, Cplus_plus converts the integer 1 to true  converts the integer 0 to false.
The situation is even a bit more complicated than simply using 1 for true  0 for false.
The compiler will treat any nonzero number as if it were the value true will treat 0 as if it were the value false.
As long as you make no mistakes in writing  expressions, this conversion causes no problems  you usually need not even be aware of it.
However, when you are debugging, it might help to know that the compiler is happy to combine integers using the operators &&, ||,  _0_.
Pitfall    Expressions Convert to int Values Suppose you want to use a  expression in an if-else statement, and you want it to be true provided that time has not yet run out (in some game or process).
To phrase it a bit more precisely, suppose you want to use a  expression in an if-else statement and you want it to be true provided the value of a variable time of type int is not greater than the value 3_0_1 Using  Expressions of a variable called limit.
You might write the following (where Something and Something_Else are some Cplus_plus statements): Something else Something_Else Wrong for what we want This looks like nonsense, and intuitively it is nonsense.
If the value of time is, for example, 36, what could possibly be the meaning of (_0_time).
After all, that is equivalent to "not 36_0_" But in Cplus_plus, any nonzero integer converts to true and 0 is converted to false.
Thus, _0_36 is interpreted as "not true" and so it evaluates to false, which is in turn converted back to 0 because we are comparing to an int.
What we want as the value of this Boolean expression and what Cplus_plus gives us are not the same.
If time has a value of 36 and limit has a value of 60, you want the displayed Boolean expression above to evaluate to true (because it is not true that time > limit).
Unfortunately, the Boolean expression instead evaluates as follows: (_0_time) evaluates to false, which is converted to 0, so the entire Boolean expression is equivalent to 0 > limit That in turn is equivalent to 0 > 60, because 60 is the value of limit.
This evaluates to false.
Thus, the above logical expression evaluates to false, when you want it to evaluate to true.
There are two ways to correct this problem.
When using the operator _0_, be sure to include parentheses around the argument.
The correct way to write the preceding Boolean expression is as follows: Something else Something_Else Another way to correct this problem is to completely avoid using the.
For example, the following is also correct and easier to read: Something else Something_Else 117.
They say that just as not in English can make things not undifficult to read, so too can the "not" operator.
There is no need to be obsessive in avoiding the.
If you have an older version of Cplus_plus that does not have the type bool, you should obtain a new.
S elf- T est Exe rc ise s 1_0_	Determine the value, true or false, of each of the following Boolean expressions, assuming that the value of the variable count is 0 and the value of the variable limit is 10.
Give your answer as one of the values true or false.
Name two kinds of statements in Cplus_plus that alter the order in which actions are performed.
Give some examples.
Explain and give the correct Cplus_plus Boolean expression that specifies that  lies between 2 and 3.
An enumeration type is very much like a list of declared constants.
When defining an enumeration type, you can use any int values and can have any number of constants defined in an enumeration type.
For example, the following enumeration type defines a constant for the length of each month: enum MonthLength { JAN_LENGTH = 31,  = = 30,  = = 30,  = = 31 }; = 31, FEB_LENGTH 30,  = 31,  = 31,  = = 28, 31, 31, 30, As this example shows, two or more named constants in an enumeration type can receive the same int value.
If you do not specify any numeric values, the identifiers in an enumerationtype definition are assigned consecutive values beginning with 0.
For example, the type definition enum  {  = 0,  = 1,  = 2,  = 3 };.
The form that does not explicitly list the int values is normally used when.
If you initialize only some enumeration constant to some values, say enum  {  = 17, TWO, ,  = -3, FIVE }; then  takes the value 17, TWO takes the next int value 18,  takes the next value 19,  takes -3, and FIVE takes the next value, -2.
In short, the default for the first enumeration constant is 0.
The rest increase by 1 unless you set one or more of the enumeration constants.
Cplus_plus11 introduced a new  of enumerations called strong enums or enum classes that avoids some problems of conventional enums.
For example, you may not want an enum to act as an integer.
Additionally, enums are global in scope so you can't have the same enum value twice.
To define a strong enum, add the word class after enum.
You can qualify an enum value by providing the enum name followed by two colons followed by the value.
For example: enum class  { Sun, Mon, Tue, Wed };.
It is legal to check if ( == ::Sun).
The if-else statement chooses between two alternatives.
In this section we will discuss methods for choosing from among more than two alternatives.
Nested Statements As you have seen, if-else statements and if statements contain smaller statements within them.
Thus far we have used compound statements and simple statements such as assignment statements as these smaller substatements, but there are other possibilities.
In fact, any statement at all can be used as a subpart of an if-else statement, of an if statement, of a while statement, or of a do-while statement.
This is illustrated in Display 3_0_3.
The statement in that display has three levels of nesting, as indicated by the boxes.
Two  statements are nested within an if-else statement, and that if-else statement is nested within an if statement.
When nesting statements, you normally indent each level of nested substatements.
In Display 3_0_3 there are three levels of nesting, so there are Display 3_0_3   An if-else Statement Within an if Statement 1 2 3 4 5.
Both  statements are indented the same amount because they are both at the same level of nesting.
Later in this chapter, you will see some specific cases where it makes sense to use other indenting patterns, but unless there is some rule to the contrary, you should indent each level of nesting as illustrated in Display 3_0_3.
This part of the program warns the driver when fuel is low but tells the driver to bypass pit stops if the fuel tank is close to full.
In all other situations the program gives no output so as not to distract the driver.
We design the following pseudocode: If the fuel gauge is below 3/4 full, then: Check whether the fuel gauge is below 1/4 full and issue a low fuel warning if it is.
Otherwise (that is, if fuel gauge is over 3/4 full): Output a statement telling the driver not to stop.
If we are not being too careful, we might implement the pseudocode as follows: Read text to see what is wrong with this.
Don't stop now_0_\n"; This implementation looks fine, and it is indeed a correctly formed Cplus_plus statement that the compiler will accept and that will run with no error messages.
However, it does not implement the pseudocode.
Notice that this statement has two occurrences of if and only one else.
The compiler must decide which if gets paired with the one else.
We have nicely indented this nested statement to show that the else should be paired with the first if, but the compiler does not care about indenting.
To the compiler, the preceding nested statement is the same as the following , which differs only in how it is indented: << "Fuel very low.
Don't stop now_0_\n"; Unfortunately for us, the compiler will use the second interpretation and will pair the one else with the second if rather than the first if.
This is sometimes called the dangling else problem; it is illustrated by the program in Display 3_0_4.
The compiler always pairs an else with the nearest previous if that is not already paired with some else.
But, do not try to work within this rule.
Chapter 3 / More Flow of Control Display 3_0_4   The Importance of Braces 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30.
Don't stop now_0_\n"; This indenting is nice,.
Enter fuel gauge reading: 0_0_1 First with braces: Braces make no difference in this case, but see Dialogue 2.
Fuel very low.
Now without braces: Fuel very low.
Sample Dialogue 2 Enter fuel gauge reading: 0_0_5 First with braces: Now without braces: Fuel over 3/4.
There should be no output here, and thanks to braces, there is none.
Incorrect output from the version without braces.
Change the rules.
Always tell the compiler what you want it to do and the compiler will then do what you want.
How do you tell the compiler what you want.
Braces in nested statements are like parentheses in arithmetic expressions.
The braces tell the compiler how to group things, rather than leaving them to be grouped according to default conventions, which may or may not be what you want.
To avoid problems and to make your programs easier to read, place braces, { and }, around substatements in if-else statements, as we have done in the first if-else statement in Display 3_0_4.
For very simple substatements, such as a single assignment statement or a single  statement, you can safely omit the braces.
In Display 3_0_4, the are not needed: << "Fuel over 3/4.
Don't stop now_0_\n"; However, even in these simple cases, the braces can sometimes aid readability.
Some programmers advocate using braces around even the simplest substatements when they occur within if-else statements, which is what we have done in the first if-else statement in Display 3_0_4.
It allows a program to choose one of two possible actions.
Often you will want to have a three- or four-way branch so that your program can choose between more than two alternative actions.
You can implement such multiway branches by nesting if-else statements.
By way of example, suppose you are designing a game-playing program in which the user must  the value of some number.
The number can be in a variable named number, and the  can be in a variable named.
If you wish to give a hint after each , you might design the following pseudocode: Output "Too high_0_" when  > number.
Output "Too low_0_" when  < number.
Output "Correct_0_" when  == number.
Any time a branching action is described as a list of mutually exclusive conditions and corresponding actions, as in this example, it can be implemented by using a nested if-else statement.
For example, this pseudocode translates to the following code: << "Too high_0_";.
If we followed our indenting rules, we would produce something like the following: 123 rule for pairing else's with if's 124.
This is one of those rare cases in which you should not follow our general guidelines for indenting nested statements.
The reason is that by lining up all the else's, you also line up all the condition/action pairs and so make the layout of the program reflect your reasoning.
Another reason is that even for not-too-deeply nested if-else statements, you can quickly run out of space on your page.
Since the conditions are mutually exclusive, the last if in the nested if-else statement above is superfluous and can be omitted, but it is sometimes best to  it in a comment as follows: << "Too high_0_";.
You can use this form of multiple-branch if-else statement even if the conditions are not mutually exclusive.
Whether the conditions are mutually exclusive or not, the computer will evaluate the conditions in the order in which they appear until it finds the first condition that is true and then it will execute the action corresponding to this condition.
If no condition is true, no action is taken.
If the statement ends with a plain else without any if, then the last statement is executed when all the conditions are false.
Multiway if-else Statement Syntax Statement_1 Statement_2.
Statement_n else Statement_For_All_Other_Possibilities 3_0_2 Multiway Branches.
The Boolean expressions are checked in order until the first true Boolean expression is encountered, and then the corresponding statement is executed.
If none of the Boolean expressions is true, then the Statement_For_All_Other_Possibilities is executed.
Programming Example State Income Tax Display 3_0_5 contains a program that uses a multiway if-else statement.
The program takes the taxpayer's net income rounded to a whole number of dollars and computes the state income tax due on this net income.
This state computes tax according to the following rate schedule: 1.
No tax is paid on the first $15,000 of net income.
A tax of 5 percent is assessed on each dollar of net income from $15,001 to $25,000.
A tax of 10 percent is assessed on each dollar of net income over $25,000.
The program defined in Display 3_0_5 uses a multiway if-else statement with one action for each of these three cases.
The condition for the second case is actually more complicated than it needs to be.
The computer will not get to the second condition unless it has already tried the first condition and found it to be false.
Thus, you know that whenever the computer tries the second condition, it will know that  is greater than 15000.
Hence, you can replace the line with the following, and the program will perform exactly the same: 125.
Chapter 3 / More Flow of Control Display 3_0_5   Multiway if-else Statement 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40.
Sample Dialogue Enter net  (rounded to whole dollars) $25100 = $25100_0_00 = $510_0_00 3_0_2 Multiway Branches S elf- T est Exerc ise s 5.
What output will be produced by the following code, when embedded in a complete program.
What would be the output in Self-Test Exercise 9 if the Boolean expression ( > 10) were changed to ( > 100).
What output will be produced by the following code, when embedded in a complete program.
Assume that neither "First Output" nor "Second Output" is output.
So, you know the value of  is output.
Write a multiway if-else statement that classifies the value of an int variable n into one of the following categories and writes out an appropriate message: n < 0 or 0 ≤ n ≤ 100 or n > 100 13_0_	Given the following declaration and output statement, assume that this.
You have seen if-else statements used to construct multiway branches.
The switch statement is another kind of Cplus_plus statement that also implements 3_0_2 Multiway Branches multiway branches.
A sample switch statement is shown in Display 3_0_6.
This particular switch statement has four regular branches and a fifth branch for illegal input.
The variable grade determines which branch is executed.
There is one branch for each of the grades 'A', 'B', and 'C'.
The grades 'D' and 'F' cause the same branch to be taken, rather than having a separate action for each of 'D' and 'F'.
If the value of grade is any character other than 'A', 'B', 'C', 'D', or 'F', then the  statement after the identifier default is executed.
Chapter 3 / More Flow of Control Sample Dialogue 1 Enter your midterm  and press Return: A Excellent.
You need not take the final.
End of program.
Sample Dialogue 2 Enter your midterm  and press Return: B Very good.
Your midterm  is now A.
End of program.
Sample Dialogue 3 Enter your midterm  and press Return: D Not good.
End of program.
Sample Dialogue 4 Enter your midterm  and press Return: That is not a possible.
End of program.
VideoNote switch Statement Example The syntax and preferred indenting pattern for the switch statement are shown in the sample switch statement in Display 3_0_6 and in the box entitled 3_0_2 Multiway Branches Notice that the constant is followed by a colon.
Also note that you cannot have two occurrences of case with the same constant value after them, since that would be an ambiguous instruction.
A break statement consists of the keyword break followed by a semicolon.
When the computer executes the statements after a case label, it continues until it reaches a break statement.
When the computer encounters a break statement, the switch statement ends.
If you omit the break statements, then after executing the code for one case, the computer will go on to execute the code for the next case.
Note that you can have two case labels for the same section of code.
In the switch statement in Display 3_0_6, the same action is taken for the values 'D' and 'F'.
This technique can also be used to allow for both upper- and lowercase letters.
For example, to allow both lowercase 'a' and uppercase 'A' in the program in Display 3_0_6, you can replace case 'A': with the following: case 'A': case 'a': Of course, the same can be done for all the other letters.
If no case label has a constant that matches the value of the controlling expression, then the statements following the default label are executed.
You need not have a default section.
If there is no default section and no match is found for the value of the controlling expression, then nothing happens when the switch statement is executed.
However, it is safest to always have a default section.
If you think your case labels list all possible outcomes, then you can put an error message in the default section.
Chapter 3 / More Flow of Control case Constant_2: Statement_Sequence_2 break;.
Pitfall   Forgetting a break in a switch Statement If you forget a break in a switch statement, the compiler will not issue an error message.
You will have written a syntactically correct switch statement, but it will not do what you intended it to do.
Consider the switch statement in the box entitled "switch Statement_0_" If a break statement were omitted, as indicated by the arrow, then when the variable vehicle_class has the value 1, the case labeled case 1: 3_0_2 Multiway Branches 133 would be executed as desired, but then the computer would go on to also execute the next case.
This would produce a puzzling output that says the vehicle is a passenger car and then later says it is a bus; moreover, the final value of  would be 1_0_50, not 0_0_50 as it should be.
When the computer starts to execute a case, it does not stop until it encounters either a break or the end of the switch statement.
For example, the switch statement is perfect for implementing menus.
Chapter 3 / More Flow of Control 31 32 33 34 35 36 37 38 39 40 41 42 43.
Sample Dialogue Choose 1 to see the next homework assignment.
Choose 2 for your grade on the last assignment.
Choose 3 for assignment hints.
Choose 4 to exit this program.
Enter your  and press Return: 3 Assignment hints: Analyze the problem.
Write an algorithm in pseudocode.
Translate the pseudocode into a Cplus_plus program.
Choose 1 to see the next homework assignment.
Choose 2 for your grade on the last assignment.
The exact output will depend on the code inserted into the switch statement.
Choose 3 for assignment hints.
Choose 4 to exit this program.
Enter your  and press Return: 4 End of Program.
A menu in a restaurant presents a list of alternatives for a customer to choose from.
A menu in a computer program does the same thing: It presents a list of alternatives on the screen for the user to choose from.
Display 3_0_7 shows the outline of a program designed to give students information on homework assignments.
The program uses a menu to let the student choose which information she or he wants.
A more readable way to implement the menu actions is through functions.
Functions are discussed in Chapter 4.
As indicated in the previous Programming Tip, it is often best to make the action of each branch a function call.
That way the subtask for each branch can be designed, written, and tested separately.
On the other hand, sometimes the action of one branch is so simple that you can just make it a compound statement.
Occasionally, you may want to give this compound statement its own local variables.
For example, consider the program in Display 3_0_8.
It calculates the final bill for a specified number of items at a given price.
If the sale is a wholesale transaction, then no sales tax is charged (presumably because the tax will be paid when the items are resold to retail buyers).
If, however, the sale is a retail transaction, then sales tax must be added.
An if-else statement is used to produce different calculations for wholesale and retail purchases.
For the retail purchase, the calculation uses a temporary variable called subtotal, and so that variable is declared within the compound statement for that branch of the if-else statement.
As shown in Display 3_0_8, the variable subtotal is declared within a compound statement.
If we wanted to, we could have used the variable name subtotal for something else outside of the compound statement in which it is declared.
A variable that is declared inside a compound statement is local to the compound statement.
Local variables are created when the compound statement is executed and are destroyed when the compound statement is completed.
In other words, local variables exist only within the compound statement in which they are declared.
Within a compound statement, you can use all the variables declared outside of the compound statement, as well as the local variables declared inside the compound statement.
Chapter 3 / More Flow of Control 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 << "Enter number purchased: ";.
Sample Dialogue Enter : $10_0_00 Enter  purchased: 2 Type  if this is a wholesale purchase.
Type  if this is a retail purchase.
Then press Return.
Local to the block 3_0_2 Multiway Branches A compound statement with declarations is more than a simple compound statement, so it has a special name.
A compound statement that contains variable declarations is usually called a block, and the variables declared within the block are said to be local to the block or to have the block as their scope.
Any code enclosed in braces is In Chapter 4 we will show how to define functions.
The body of a function definition is also a block.
There is no standard name for a block that is not the body of a function.
However, we want to talk about these kinds of blocks, so let us create a name for them.
Let's call a block a statement block when it is not the body of a function (and not the body of the main part of a program).
Statement blocks can be nested within other statement blocks, and basically the same rules about local variable names apply to these nested statement blocks as those we have already discussed, but applying the rules can be tricky when statement blocks are nested.
A better rule is to not nest statement blocks.
Nested statement blocks make a program hard to read.
If you feel the need to nest statement blocks, instead make some of the statement blocks into function definitions and use function calls rather than nested statement blocks.
In fact, statement blocks of any kind should be used sparingly.
In most situations, a function call is preferable to a statement block.
For completeness, we  the scope rule for nested blocks in the accompanying summary box.
Blocks A block is some Cplus_plus code enclosed in braces.
The variables declared in a block are local to the block and so the variable names can be used outside of the block for something else (such as being reused as the name for a different variable).
Scope Rule for Nested Blocks If an identifier is declared as a variable in each of two blocks, one within the other, then these are two different variables with the same name.
One variable exists only within the inner block and cannot be accessed outside of the inner block.
The other variable exists only in the outer block and cannot be accessed in the inner block.
The two variables are distinct, so changes made to one of these variables will have no effect on the other of these two variables.
Chapter 3 / More Flow of Control Pitfall   Inadvertent Local Variables When you declare a variable within a pair of braces, { }, that variable becomes a local variable for the block enclosed in the pair.
This is true whether you wanted the variable to be local or not.
If you want a variable to be available outside of the braces, then you must declare it outside of the braces.
What output will be produced by the following code, when embedded in a complete program.
What output is produced by the following code, when embedded in a.
Though we urge you not to program using this style, we are providing an exercise that uses nested blocks to help you understand the scope rules.
Give the output that this code fragment would produce if embedded in an otherwise complete, correct program.
Vincent Millay, Letter to Arthur Darison Ficke, October 24, 1930 A loop is any program construction that repeats a statement or sequence of statements a  of times.
The simple while loops and do-while loops that we have already seen are examples of loops.
The statement (or group of statements) to be repeated in a loop is called the body of the loop, and each repetition of the loop body is called an iteration of the loop.
The two main design questions when constructing loops are: What should the loop body be.
How many times should the loop body be iterated.
The while Statements Reviewed The syntax for the while statement and its variant, the do-while statement, is reviewed in Display 3_0_9.
The important difference between the two types of loops 139.
Chapter 3 / More Flow of Control involves when the controlling Boolean expression is checked.
When a while statement is executed, the Boolean expression is checked before the loop body is executed.
If the Boolean expression evaluates to false, then the body is not executed at all.
With a do-while statement, the body of the loop is executed first and the Boolean expression is checked after the loop body is executed.
Thus, the do-while statement always executes the loop body at least once.
After this start-up, the while loop and the do-while loop behave very much the same.
After each iteration of the loop body, the Boolean expression is again checked; if it is true, then the loop is iterated again.
If it has changed from true to false, then the loop statement ends.
Display 3_0_9   Syntax of the while Statement and do-while Statement A while Statement with a Single Statement Body Statement Body A while Statement with a Multistatement Body { Statement_1 Statement_2.
Statement_Last } Body A do-while Statement with a Single Statement Body do Statement while (Boolean_Expression); Body.
A do-while Statement with a Multistatement Body do { Statement_1 Statement_2.
Statement_Last } while (Boolean_Expression); 3_0_3 More About Cplus_plus Loop Statements The first thing that happens when a while loop is executed is that the controlling Boolean expression is evaluated.
If the Boolean expression evaluates to false at that point, then the body of the loop is never executed.
It may seem pointless to execute the body of a loop zero times, but that is sometimes the desired action.
For example, a while loop is often used to sum a list of numbers, but the list could be empty.
To be more specific, a checkbook balancing program might use a while loop to sum the values of all the checks you have written in a month—but you might take a month's vacation and write no checks at all.
In that case, there are zero numbers to sum and so the loop is iterated zero times.
Thus far we have always used the increment operator as a statement.
But the increment operator is also an operator, just like the + and.
An expression like numberplus_plus also returns a value, so numberplus_plus can be used in an arithmetic expression such as The expression numberplus_plus first returns the value of the variable , and then the value of  is increased by 1.
For example, consider the following.
When Cplus_plus evaluates this expression, it uses the value that  has before it is incremented, not the value that it has after it is incremented.
Thus, the value produced by the expression numberplus_plus is 2, even though the increment operator changes the value of to 3.
This may seem strange, but sometimes it is just what you want.
And, as you are about to see, if you want an expression that behaves differently, you can have it.
The expression vplus_plus evaluates to the value of the variable v, and then the value of the variable v is incremented by 1.
If you reverse the order and place 141 increment operator in expressions 142 Chapter 3 / More Flow of Control the plus_plus in front of the variable, the order of these two actions is reversed.
The expression plus_plusv first increments the value of the variable v and then returns.
This code is the same as the previous piece of code except that the plus_plus is before the variable, so this code produces the following output: 6 3 Notice that the two increment operators numberplus_plus and plus_plusnumber have the same effect on a variable : They both increase the value of  by 1.
But the two expressions evaluate to different values.
Remember, if the plus_plus is before the variable, then the incrementing is done before the value is returned; if the plus_plus is after the variable, then the incrementing is done after the value is returned.
The program in Display 3_0_10 uses the increment operator in a while loop to count the  of times the loop body is repeated.
One of the main uses of the increment operator is to control the iteration of loops in ways similar to what is done in Display 3_0_10.
Display 3_0_10   The Increment Operator as an Expression 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18.
Sample Dialogue How many items did you eat.
Chapter 3 / More Flow of Control –– returns the value of  and then decrements ; on the other hand, –– first decrements  and then returns the value of.
Expressions such as (x + y)plus_plus, ––(x + y), 5plus_plus, and so forth are all illegal in Cplus_plus.
S elf- T est Exe rc ise s 21.
What is the output of the following (when embedded in a complete program).
What is the output of the following (when embedded in a complete.
What is the output of the following (when embedded in a complete.
The for Statement The while statement and the do-while statement are all the loop mechanisms you absolutely need.
In fact, the while statement alone is enough.
However, there is one sort of loop that is so common that Cplus_plus includes a special statement for this.
In performing numeric calculations, it is common to do a calculation with the  1, then with the  2, then with 3, and so forth, until some last value is reached.
For example, to add 1 through 10, you 3_0_3 More About Cplus_plus Loop Statements want the computer to perform the following statement ten times, with the value of  equal to 1 the first time and with  increased by 1 each subsequent time: =  + ;.
The following for statement will neatly accomplish the same task: = 0; =  + ; Let's look at this for statement piece by piece.
First, notice that the while loop version and the for loop version are made by putting together the same pieces: They both start with an assignment statement that sets the variable  equal to 0.
In both cases, this assignment statement for  is placed before the loop statement itself begins.
The loop statements themselves are both made from the pieces.
The for statement is simply a more compact way of saying the same thing.
Although other things are possible, we will only use for statements to perform loops controlled by one variable.
In our example, that would be the variable.
With the equivalence of the previous two loops to guide us, let's go over the rules for writing a for statement.
A for statement begins with the keyword for followed by three things in parentheses that tell the computer what to do with the controlling variable.
The beginning of a for statement looks like the following: The first expression tells how the variable is initialized, the second gives a Boolean expression that is used to check for when the loop should end, and the last expression tells how the loop control variable is updated after each iteration of the loop body.
For example, the above for loop begins 145.
Chapter 3 / More Flow of Control = 1 says that  is initialized to 1.
Do not succumb to the temptation to place a semicolon after the third expression.
Notice that in a for statement, as in the corresponding while statement, the stopping condition is tested before the first loop iteration.
Thus, it is possible to have a for loop whose body is executed zero times.
Output 100 bottles of beer on the shelf.
Display 3_0_12 shows a sample for statement embedded in a complete (although very simple) program.
So, the declaration of  is inside the for statement.
When a variable is used only within the for statement, this can be the best place to declare the variable.
However, if the variable is also used outside of the for statement, then it is best to declare the variable outside of the for statement.
ANSI Cplus_plus standard requires that a Cplus_plus compiler claiming compliance with the standard treat any declaration in a for loop initializer as if it were local to the body of the loop.
Earlier Cplus_plus compilers did not do this.
You should determine how your compiler treats variables declared in a for loop initializer.
In the interests of portability, you should not write code that depends on this behavior.
ANSI Cplus_plus standard requires that variables declared in the initialization expression of a for loop be local to the block of the for loop.
Our description of a for statement was a bit less general than what is allowed.
However, our for statements will always use only a single variable in these expressions.
In the for statement in Display 3_0_12, the body was the simple assignment statement =  + ; declaring variables within a for statement 148 Chapter 3 / More Flow of Control Display 3_0_12   A for Statement 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15.
Done after each loop body iteration for (int  = 1;  <= 10; nplus_plus) //Note that the variable  is a local =  + ;.
The  of the numbers 1 to 10 is 55 Display 3_0_13   for Loop with a Multistatement Body SYNTAX { Statement_1 Statement_2.
The body may be any statement at all.
In particular, the body may be a compound statement.
This allows us to place several statements in the body of a for loop, as shown in Display 3_0_13.
Thus far, you have seen for loops that increase the loop control variable by 1 after each loop iteration, and you have seen for loops that decrease the loop control variable by 1 after each loop iteration.
There are many more possible kinds of variable updates.
The variable can be incremented or decremented by 2 or 3 or any.
If the variable is of type double, it can be incremented or decremented by a fractional amount.
All of the following are legitimate for loops: int ; << " is now equal  " <<  << endl;.
Moreover, the initialization need not simply set a variable equal  a constant.
You can initialize and change a loop control variable in just about any way you wish.
For example, the following demonstrates one more way  start a for loop: << " is now equal  " <<  << endl; Pitfall   Extra Semicolon in a for Statement.
If you do notice the semicolon, you might expect the compiler  issue an error message.
If you embed this for loop in a complete program, the compiler will not complain.
If you run the program, only one Hello will be output instead of ten Hellos.
To answer that question, we need a little background.
One way  create a statement in Cplus_plus is  put a semicolon after something.
If you put a semicolon after xplus_plus, you change the expression xplus_plus 149 more possible update actions 150.
Thus, the semicolon by itself is a statement, which is called the empty statement or the null statement.
The empty statement performs no action, but it is still a statement.
Therefore, the following is a complete and legitimate for loop, whose body is the empty statement: for (int  = 1;  <= 10; countplus_plus); This for loop is indeed iterated ten times, but since the body is the empty statement, nothing happens when the body is iterated.
This loop does nothing, and it does nothing ten times.
Now let's go back and consider the for loop code labeled Problem semicolon.
Because of the extra semicolon, that code begins with a for loop that has an empty body, and as we just discussed, that for loop accomplishes nothing.
After the for loop is completed, the following  statement is executed and writes Hello  the screen one time: << "Hello\"; You will eventually see some uses for for loops with empty bodies, but at this stage, such a for loop is likely  be just a careless mistake.
First design the loop using pseudocode, then translate the pseudocode into Cplus_plus code.
At that point it will be easy  decide what type of Cplus_plus loop statement  use.
If the loop involves a numeric calculation using a variable that is changed by equal amounts each time through the loop, use a for loop.
In fact, whenever you have a loop for a numeric calculation, you should consider using a for loop.
It will not always be suitable, but it is often the clearest and easiest loop  use for numeric calculations.
In most other cases, you should use a while loop or a do-while loop; it is fairly easy  decide which of these two  use.
If you want  insist that the loop body will be executed at least once, you may use a do-while loop.
If there are circumstances for which the loop body should not be executed at all, then you must use a while loop.
A common situation that demands a while loop is reading input when there is a possibility of no data at all.
For example, if the program reads in a list of exam scores, there may be cases of students who have taken no exams, and hence the input loop may be faced with an empty list.
This calls for a while loop.
What is the output of the following (when embedded in a complete program).
What is the output of the following (when embedded in a complete.
For each of the following situations, tell which type of loop (while, do-while, or for) would work best: a.
Summing a series, such as 1/2 + 1/3 + 1/4 + 1/5 +.
Pitfall   Uninitialized Variables and Infinite Loops When we first introduced simple while and do-while loops in Chapter 2, we warned you of two pitfalls associated with loops.
We said that you should be sure all variables that need to have a value in the loop are initialized (that is, given a value) before the loop is executed.
This seems obvious when stated in the abstract, but in practice it is easy to become so concerned with designing a loop that you forget to initialize variables before the loop.
We also said that you should be careful to avoid infinite loops.
Both of these cautions apply equally well to for loops.
This same break statement can be used to exit a loop.
Sometimes you want to exit a loop before it ends in the normal way.
For example, the loop might contain a check for improper input and if some improper input is encountered, then you may want to simply end the loop.
The code in Display 3_0_14 reads a list of negative numbers and computes their sum as the value of the variable sum.
The loop ends normally provided the user types in ten negative numbers.
If the user forgets a minus sign, the computation is ruined and the loop ends immediately when the break statement is executed.
Sample Dialogue Enter 10 negative numbers: -1 -2 -3 4 -5 -6 -7 -8 -9 -10 ERROR: positive  or zero was entered as the 4th.
Input ends with the 4th.
The break Statement The break statement can be used to exit a loop statement.
When the break statement is executed, the loop statement ends immediately and execution continues with the statement following the loop statement.
The break statement may be used in any form of loop—in a while loop, in a do-while loop, or in a for loop.
Pitfall   The break Statement in Nested Loops A break statement ends only the innermost loop that contains it.
If you have a loop within a loop and a break statement in the inner loop, then the break statement will end only the inner loop.
What is the output of the following (when embedded in a complete program).
What is the output of the following (when embedded in a complete program).
Traditional Carnival Barker's Call When designing a loop, you need to design three things: 1.
The body of the loop 2.
The initializing statements 3.
The conditions for ending the loop We begin with a section on two common loop tasks and show how to design these three elements for each of the two tasks.
Loops for Sums and Products Many common tasks involve reading in a list of numbers and computing their If you know how many numbers there will be, such a task can easily be accomplished by the following pseudocode.
The value of the variable this_ many is the  of numbers to be added.
The  is accumulated in the variable.
In order to determine the correct initializing value for , think about what you want to happen after one loop iteration.
After adding in the first , the value of  should be that That is, the first time through the loop the value of  + next should equal next.
To make this true, the value of  must be initialized to 0.
A for statement can be used to produce a loop that repeats the loop body a predetermined  of times.
Pseudocode Repeat the following this_many times: Loop_Body Equivalent for Statement Loop_Body Example << "Hip, Hip, Hurray\"; You can form the  of a list of numbers in a way that is similar to how we formed the  of a list of numbers.
The technique is illustrated by the following code: int  = 1;.
The variable  must be given an initial value.
Do not assume that all variables should be initialized to zero.
If  were initialized to 0, then it would still be zero after the loop above has finished.
As indicated in the Cplus_plus code shown earlier, the correct initializing value for  is 1.
To see that 1 is the correct initial value, notice that the first time through the loop this will leave  equal to the first  read in, which is what you want.
Ending a Loop There are four commonly used methods for terminating an input loop.
We will discuss them in order.
List headed by size 2.
Ask before iterating 3.
List ended with a sentinel value 4_0_	Running out of input If your program can determine the size of an input list beforehand, either loop to read input exactly  times, where  is the size of the list.
This method is called list headed by size.
The second method for ending an input loop is simply to ask the user, after each loop iteration, whether or not the loop should be iterated again.
However, for reading in a long list, this is very tiresome to the user.
Imagine typing in a list of 100 numbers this way.
The user is likely to progress from happy to sarcastic and then to angry and frustrated.
When reading in a long list, it is preferable to include only one stopping signal, which is the method we discuss next.
Chapter 3 / More Flow of Control Perhaps the nicest way to terminate a loop that reads a list of values from the keyboard is with a sentinel value.
A sentinel value is one that is somehow distinct from all the possible values on the list being read in and so can be used to signal the end of the list.
For example, if the loop reads in a list of positive numbers, then a negative  can be used as a sentinel value to indicate the end of the list.
A loop such as the following can be used to add a list of nonnegative numbers:.
Notice that the last  in the list is read but is not added into.
To add the numbers 1, 2, and 3, the user appends a negative  to the end of the list like so: 1 2 3 -1 The final -1 is read in but not added into the.
To use a sentinel value this way, you must be certain there is at least one value of the data type in question that definitely will not appear on the list of input values and thus can be used as the sentinel value.
If the list consists of integers that might be any value whatsoever, then there is no value left to serve as the sentinel value.
In this situation, you must use some other method to terminate the loop.
When reading input from a file, you can use a sentinel value, but a more common method is to simply check to see if all the input in the file has been read and to end the loop when there is no more input left to be read.
This method of ending an input loop is discussed in Chapter 6 in the Programming Tip section entitled "Checking for the End of a File" and in the section entitled The techniques we gave for ending an input loop are all special cases of more general techniques that can be used to end loops of any kind.
The more general techniques are as follows:.
Ask before iterating.
Exit on a flag condition A -controlled loop is any loop that determines the  of iterations before the loop begins and then iterates the loop body that many times.
The list-headed-by-size technique that we discussed for input loops is loops are -controlled loops.
You can use it for loops other than input loops, but the most common use for this technique is for processing input.
Earlier in this section we discussed input loops that end when a sentinel value is read.
In our example, the program read nonnegative integers into a variable called.
When  received a negative value, that indicated the end of the input; the negative value was the sentinel value.
This is an example of a more general technique known as exit on a flag condition.
A variable that changes value to indicate that some event has taken place is often called a flag.
In our example input loop, the flag was the variable ; when it becomes negative, that indicates that the input list has ended.
Ending a file input loop by running out of input is another example of the exit-on-a-flag technique.
In this case the flag condition is determined by the system.
The system keeps track of whether or not input reading has reached the end of a file.
A flag can also be used to terminate loops other than input loops.
For example, the following sample loop can be used to find a tutor for a student.
Students in the class are numbered starting with 1.
The loop checks each student to see if that student received a high  and stops the loop as soon as a student with a high  is found.
For this example, a  of 90 or more is considered high.
The code compute_grade() is a call to a user-defined function.
In this case, the function will execute some code that will compute a numeric value from 0 to 100 that corresponds to student 's.
The numeric value then is copied into the variable.
Chapter 4 discusses functions in more detail.
In this example, the variable  serves as the flag.
The previous loop indicates a problem that can arise when designing loops.
What happens if no student has a score  90 or better.
The answer depends on the definition for the function compute_grade.
If  is defined for all positive integers, it could be an infinite loop.
Even worse, if  is defined to be, say, 100 for all arguments  that are not students, then it may try to make a tutor out  a nonexistent student.
In any event, something will go wrong.
If there is a danger  a loop turning into an infinite loop or even a danger  it iterating more times than is sensible, then you should include a check to see that the loop is not iterated too many times.
For example, a better condition for our example loop is the following, where the variable number_ of_students has been set equal to the   students in the class: 159.
In the district where this vulture survives, conservationists annually perform a count  the eggs in green-necked vulture nests.
The program in Display 3_0_15 takes the reports  each  the conservationists in the district and calculates the total eggs contained in all the nests they observed.
Each conservationist's report consists  a list  numbers.
Each  is the count  the   eggs observed in one green-necked vulture nest.
The program reads in the report  one conservationist and calculates the total eggs found by this conservationist.
The list  numbers for each conservationist has a negative  added to the end  the list.
This serves as a sentinel value.
The program loops through the   reports and calculates the total eggs found for each report.
The body  a loop may contain any kind  statement, so it is possible to have loops nested within loops (as well as eggs nested within nests).
The program in Display 3_0_15 contains a loop within a loop.
The nested loop in Display 3_0_15 is executed once for each value  count from 1 to number_of_ reports.
For each such iteration  the outer for loop there is one complete execution  the inner while loop.
In Chapter 4 we'll use subroutines to make the program in Display 3_0_15 more readable.
S elf- T est Exercises 36.
Write a loop that will write the word Hello to the screen ten times (when embedded in a complete program).
The list is ended with a sentinel value.
Among other things, you must decide what would be a good sentinel value to use.
Predict the output of the following nested loops: int , ; <<  << " times " << << " = " <<  *  << endl; Debugging Loops.
First, localize the problem No matter how carefully a program is designed, mistakes will still sometimes occur.
In the case of loops, there is a pattern to the kinds of mistakes programmers most often make.
Most loop errors involve the first or last iteration of the loop.
If you find that your loop does not perform as expected, check to see if the loop is iterated one too many or one too few times.
Loops that iterate one too many or one too few times are said to have an off-by-one error; these errors are among the most common loop bugs.
Be sure you are not confusing less-than with less-than-or-equal-to.
Be sure you have initialized the loop correctly.
Remember that a loop may sometimes need to be iterated zero times and check that your loop handles that possibility correctly.
Infinite loops usually result from a mistake in the Boolean expression that controls the stopping of the loop.
Check to see that you have not reversed an inequality, confusing less-than with greater-than.
Another common source of infinite loops is terminating a loop with a test for equality, rather than something involving greater-than or less-than.
With values of type double, testing for equality does not give meaningful answers, since the quantities being compared are only approximate values.
Even for values of type int, equality can be a dangerous test to use for ending a loop, since there is only one way that it can be satisfied.
If you check and recheck your loop and can find no error, but your program still misbehaves, then you will need to do some more sophisticated testing.
First, make sure that the mistake is indeed in the loop.
Just because the program is performing incorrectly does not mean the bug is where you think it is.
If your program is divided into functions, it should be easy to determine the approximate location of the bug or bugs.
Once you have decided that the bug is in a particular loop, you should watch the loop change the value of variables while the program is running.
This way you can see what the loop is doing and thus see what it is doing wrong.
Watching the value of a variable change while the program is running is called tracing the variable.
Many systems have debugging utilities that allow you to easily trace variables without making any changes to your program.
If your system has such a debugging utility, it would be well worth your effort to learn how to use it.
If your system does not have a debugging utility, you can trace a variable by placing a temporary  statement in the loop body; that way the value of the variable will be written to the screen on each loop iteration.
The comment at the end of the loop tells what the loop is supposed to do, but we have tested it and know that it gives the variable  an incorrect value.
We need to find out what is wrong.
To help us debug this loop, we trace the variables  and.
If you have a debugging utility, you could use it.
If you do not have a debugging facility, you can trace the variables by inserting a  statement as follows: int  = 2, { nextplus_plus; =.
When we trace the variables  and , we find that after the first loop iteration, the values of  and  are both 3.
It is then clear to us that we have multiplied only the numbers 3 through 5 and have missed multiplying by 2.
There are at least two good ways to fix this bug.
The easiest fix is to initialize the variable  to 1, rather than 2.
That way, when  is incremented the first time through the loop, it will receive the value 2 rather than 3.
Another way to fix the loop is to place the increment after the multiplication, as follows: int  = 2,  = 1;.
Let's assume we fix the bug by moving the statement nextplus_plus as indicated above.
After we add this fix, we are not yet done.
We must test this revised code.
When we test it, we will see that it still gives an incorrect result.
If we again trace variables, we will discover that the loop stops after multiplying by 4, and never multiplies by 5.
This tells us that the Boolean expression should now use a lessthan-or-equal sign, rather than a less-than sign.
Thus, the correct code is 163.
Never assume that your change will make the program correct.
Just because you found one thing to correct does not mean you have found all the things that need to be corrected.
Also, as illustrated by this example, when you change one part of your program to make it correct, that change may require you to change some other part of the program as well.
Testing a Loop Every loop should be tested with inputs that cause each of the following loop behaviors (or as many as are possible): zero iterations of the loop body, one iteration of the loop body, the maximum number of iterations of the loop body, and one less than the maximum number of iterations of the loop body.
You should The techniques we have developed will help you find the few bugs that may find their way into a well-designed program.
However, no amount of debugging can convert a poorly designed program into a reliable and readable one.
If a program or algorithm is very difficult to understand or performs very poorly, do not try to fix it.
Instead, throw it away and start over.
This will result in a program that is easier to read and that is less likely to contain hidden errors.
What may not be so obvious is that by throwing out the poorly designed code and starting over, you will produce a working program faster than if you try to repair the old code.
It may seem like wasted effort to throw out all the code that you worked so hard on, but that is the most efficient way to proceed.
The work that went into the discarded code is not wasted.
The lessons you learned by writing it will help you to design a better program faster than if you started with no experience.
The bad code itself is unlikely to help at all.
Debugging a Very Bad Program If your program is very bad, do not try to debug it.
Instead, throw it out and start over.
Chapter Summary S elf- T est Exerc ise s 39.
What does it mean to trace a variable.
How do you trace a variable.
What is an off-by-one loop error.
You have a fence that is to be 100 meters long.
Your fence posts are to be placed every 10 feet.
How many fence posts do you need.
Why is the presence of this problem in a programming book not as silly as it might seem.
What problem that programmers have does this question address.
Chapter Summary ■ Boolean expressions are evaluated similarly to the way arithmetic expressions are evaluated.
A call to such a function can be used as a Boolean expression in an if-else statement or anywhere else that a Boolean expression is permitted.
This can be implemented in Cplus_plus as a multiway if-else statement.
The variables declared in a block are local to the block.
Among other uses, blocks can be used for the action in one branch of a multiway branch statement, such as a multiway if-else statement.
Once the algorithm has been designed, the choice of which Cplus_plus loop statement to use is usually clear.
Instead, throw it away and start over.
Answers to Self - Test Exerci ses 1.
Note that expressions (a) and (b) mean exactly the same thing.
Because the  == and < have higher precedence than &&, you easier to read than the expression in (b), even though they mean the same thing.
Since the value of the first subexpression ( == 1) is false, you know that the entire expression is false without bothering to evaluate the second subexpression.
Thus, it does not matter what the values of x and y are.
This is called short-circuit evaluation, which is what Cplus_plus does.
Since the value of the first subexpression ( < 10) is true, you know that the entire expression is true without bothering to evaluate the second subexpression.
Thus, it does not matter what the values of x and y are.
This is called short-circuit evaluation, which is what Cplus_plus does.
This subexpression is evaluated using short-circuit evaluation as we described for (f).
The entire expression in (g) is equivalent to which in turn is equivalent to _0_( true && true ), and that is equivalent to _0_(true), which is equivalent to the final value of false.
Answers to Self-Test Exercises i_0_ true.
Since the value of the first subexpression (limit < 20) is true, you know that the entire expression is true without bothering to evaluate the second subexpression.
Thus, the second subexpression is never evaluated and so the fact that it involves a division by zero is never noticed by the computer.
This is short-circuit evaluation, which is what Cplus_plus does.
Since the value of the first subexpression (limit < 0) is false, you know that the entire expression is false without bothering to evaluate the second subexpression.
Thus, the second subexpression is never evaluated and so the fact that it involves a division by zero is never noticed by the computer.
This is short-circuit evaluation, which is what Cplus_plus does.
The expression has no intuitive meaning, but Cplus_plus converts the int values to bool values and then evaluates the && and.
Thus, Cplus_plus will evaluate this mess.
Recall that in Cplus_plus, any nonzero integer converts to true, and 0 converts to false.
Cplus_plus will evaluate as follows: In the expression (5 && 7), the 5 and 7 convert to true.
In (_0_6), the 6 is converted to true, so _0_(true) evaluates to false, which Cplus_plus converts to 0.
The entire expression thus evaluates to 1 + 0, which is 1.
The final value is thus 1.
Cplus_plus will convert the number 1 to true, but the answer has little intuitive meaning as true; it is perhaps better to just say the answer is 1.
To this point we have studied branching statements, iteration statements, and function call statements.
Examples of branching statements we have studied are if and if-else statements.
Examples of iteration statements are while and do-while statements.
Since (2 < ) is a Boolean , its value is either true or false, which converts to 1 or 0, so that 2 <  < 3 is always true.
The output is "true" regardless of the value of.
The Boolean  j > 0 is false (j was just assigned -1).
The && uses short-circuit evaluation, which does not evaluate the second if the truth value can be determined from the first.
The first  is false, so the entire  evaluates to false without evaluating the second.
So, there is no division by zero.
Start Hello from the second if.
End Start again End again 6.
Start Second Output End 10.
The statements are the same whether the second Boolean  is ( > 10) or ( > 100).
So, the output is the same as in Self-Test Exercise 9.
Start 100 End 12.
Both of the following are correct: <<  << " is less than zero_0_\";.
The constants increment by 1.
Unassigned constants increment the previous value by 1.
Chocolate ice cream Onion ice cream 18.
Hello Hello Hello Hello Hello 27.
A for loop b.
Both require a while loop since the input list might be empty.
A do-while loop can be used since at least one test will be performed.
The second number is the base 2 log of the first number.
The ';' after the for is probably a pitfall error.
This is an infinite loop.
Consider the update expression  =  * 2.
It cannot change  because its initial value is 0, so it leaves  at its initial value, 0.
A break statement is used to exit a loop (a while, do-while, or for statement) or to terminate a case in a switch statement.
A break is not legal anywhere else in a Cplus_plus program.
Note that  the loops are nested, a break statement only terminates one level of the loop.
Answers to Self-Test Exercises.
The output is too long to reproduce here.
The pattern is as follows: 1  10 = 10 1  9 = 9.
Tracing a variable means watching a program variable change value while the program is running.
This can be done with special debugging facilities or by inserting temporary output statements in the program.
Loops that iterate the loop body one too many or one too few  are said to have an off-by-one error.
Typical reasoning from those who do not think carefully is 10  = 100 feet of fence / 10 feet between This, of course, will leave the last 10 feet of fence without a post.
You need 11  to provide 10 between-the-post 10-foot intervals to get 100 feet of fence.
Chapter 3 / More Flow of Control Practice Programs Practice Programs can generally be solved with a short program that directly applies the programming principles presented in this chapter.
Write a program to score the paper-rock-scissor game.
Each of two users types in either P, R, or S.
The program then announces the winner as well as the basis for determining the winner: Paper covers rock, Rock breaks scissors, Scissors cut paper, or Nobody wins.
Be sure to allow the users to use lowercase as well as uppercase letters.
Your program should include a loop that lets the user play again until the user says she or he is done.
Write a program to compute the interest due, total amount due, and the minimum payment for a revolving credit account.
The program accepts the account balance as input, then adds on the interest to get the total amount due.
The rate schedules are the following: The interest is 1_0_5 percent on the first $1,000 and 1 percent on any amount over that.
The minimum payment is the total amount due if that is $10 or less; otherwise, it is $10 or 10 percent of the total amount owed, whichever is larger.
Your program should include a loop that lets the user repeat this calculation until the user says she or he is done.
Write an astrology program.
The user types in a birthday, and the program responds with the sign and horoscope for that birthday.
The month may be entered as a number from 1 to 12.
Then enhance your program so that if the birthday is only one or two days away from an adjacent sign, the program announces that the birthday is on a "cusp" and also outputs the horoscope for that nearest adjacent sign.
This program will have a long multiway branch.
Make up a horoscope for each sign.
Your program should include a loop that lets the user repeat this calculation until the user says she or he is done.
The horoscope signs and dates are: Aries March 21–April 19 Taurus April 20–May 20 Gemini May 21–June 21 Cancer June 22–July 22 Leo July 23–August 22 Virgo August 23–September 22 Libra September 23–October 22 Scorpio 	October 23–November 21 Sagittarius November 22–December 21 Capricorn 	December 22–January 19 Aquarius January 20–February 18 Pisces February 19–March 20 Practice Programs 4.
Horoscope Signs of the same Element are most compatible.
There are 4 Elements in astrology, and 3 Signs in each: FIRE (Aries, Leo, Sagittarius), EARTH (Taurus, Virgo, Capricorn), AIR (Gemini, Libra, Aquarius) , WATER (Cancer, Scorpio, Pisces).
According to some astrologers, you are most comfortable with your own sign and the other two signs in your Element.
For example, Aries would be most comfortable with other Aries and the two other FIRE signs, Leo and Sagittarius.
Modify your program from Practice Program 3 to also display the name of the signs that will be compatible for the birthday.
Write a program that finds and prints all of the prime numbers between 3 and 100.
A prime number is a number such that 1 and itself are the only numbers that evenly divide it (for example, 3, 5, 7, 11, 13, 17, …).
One way to solve this problem is to use a doubly nested loop.
The outer loop can iterate from 3 to 100 while the inner loop checks to see if the counter value for the outer loop is prime.
One way to see if number n is prime is to loop from 2 to n 21 and if any of these numbers evenly divides n, then n cannot be prime.
If none of the values from 2 to n 21 evenly divides n, then n must be prime.
Buoyancy is the ability of an object to float.
Archimedes' principle states that the buoyant force is equal to the weight of the fluid that is displaced by the submerged object.
The buoyant force can be computed by = V × where  is the buoyant force, V is the volume of the submerged object, and  is the specific weight of the fluid.
If  is greater than or equal to the weight of the object, then it will float, otherwise it will sink.
Use = 62_0_4 lb/ft3 as the specific weight of water.
The volume of a sphere is computed by (4/3)πr 3.
Write a program that finds the temperature that is the same in both Celsius and.
The formula to convert from Celsius to  is = + 32 5 Your program should create two integer variables for the temperature in Celsius and.
Initialize the temperature to 100 degrees Celsius.
In a loop, decrement the Celsius value and compute the corresponding temperature in  until the two values are the same.
Chapter 3 / More Flow of Control Since you are working with integer values, the formula may not give an exact result for every possible Celsius temperature.
This will not affect your solution to this particular problem.
Programming Projects Programming Projects require more problem-solving than Practice Programs and can usually be solved many different ways.
Visit www_0_myprogramminglab_0_com to complete many of these Programming Projects online and get instant feedback.
Write a program that computes the cost of a long-distance call.
The cost of the call is determined according to the following rate schedule: a_0_ Any call started between 8:00 am and 6:00 pm, Monday through Friday, is billed at a rate of $0_0_40 per minute.
The input will consist of the day of the week, the time the call started, and the length of the call in minutes.
The output will be the cost of the call.
The time is to be input in 24-hour notation, so the time 1:30 pm is input as 13:30 The day of the week will be read as one of the following pairs of character values, which are stored in two variables of type char: Mo Tu.
Su Be sure to allow the user to use either uppercase or lowercase letters or a combination of the two.
The number of minutes will be input as a value of type int.
The roots of a quadratic equation ax2 + bx +  = 0 (where a is not zero) are given by the formula (–b ± sqrt(b2 – 4ac)) / 2a Programming Projects The value of the discriminant (b2 – 4ac) determines the nature of roots.
If the value of the discriminant is zero, then the equation has a single real root.
If the value of the discriminant is positive then the equation has two real roots.
If the value of the discriminant is negative, then the equation has two complex roots.
The program takes values of a, b, and  as  and outputs the roots.
Be creative in how you output complex roots.
Include a loop that allows the user to repeat this calculation for new  values until the user says she or he wants to end the program.
Write a program that accepts a year written as a four-digit Arabic (ordinary) numeral and outputs the year written in Roman numerals.
Important Roman numerals are V for 5, X for 10, L for 50, C for 100, D for 500, and M for 1,000.
Recall that some numbers are formed by using a kind of subtraction of one Roman "digit"; for example, IV is 4 produced as V minus I, XL is 40, CM is 900, and so on.
A few sample years: MCM is 1900, MCML is 1950, MCMLX is 1960, MCMXL is 1940, MCMLXXXIX is 1989.
Assume the year is between 1000 and 3000.
Your program should include a loop that lets the user repeat this calculation until the user says she or he is done.
Write a program that scores a blackjack hand.
In blackjack, a player receives from two to five cards.
The cards 2 through 10 are scored as 2 through 10 points each.
The face cards—jack, queen, and king—are scored as 10 points.
The goal is to come as close to a score of 21 as possible without going over 21.
Hence, any score over 21 is called "busted_0_" The ace can count as either 1 or 11, whichever is better for the user.
For example, an ace and a 10 can be scored as either 11 or 21.
Since 21 is a better score, this hand is scored as 21.
An ace and two 8s can be scored as either 17 or 27.
Since 27 is a "busted" score, this hand is scored as 17.
The user is asked how many cards she or he has, and the user responds with one of the integers 2, 3, 4, or 5.
The user is then asked for the card values.
Card values are 2 through 10, jack, queen, king, and ace.
A good way to handle is to use the type char so that the card  2, for example, is read as the character '2', rather than as the number 2.
Input the values 2 through 9 as the characters '2' through '9'.
Input the values 10, jack, queen, king, and ace as the characters 't', 'j', 'q', 'k', and 'a'.
After reading in the values, the program should convert them from character values to numeric card scores, taking special care for aces.
The output is either a number between 2 and 21 (inclusive) or the word Busted.
You are likely to have one or more long multiway branches that use a switch statement or nested if-else statement.
Your program should include a loop that lets the user repeat this calculation until the user says she or he is done.
Chapter 3 / More Flow of Control 5_0_	Interest on a loan is paid on a declining balance, and hence a loan with an interest rate of, say, 14 percent can cost significantly less than 14 percent of the balance.
Write a program that takes a loan amount and interest rate as  and then outputs the monthly payments and balance of the loan until the loan is paid off.
Assume that the monthly payments are onetwentieth of the original loan amount, and that any amount in excess of the interest is credited toward decreasing the balance due.
Thus, on a loan of $20,000, the payments would be $1,000 a month.
If the interest rate is 10 percent, then each month the interest is one-twelfth of 10 percent of the remaining balance.
The first month, (10 percent of $20,000)/12, or $166_0_67, would be paid in interest, and the remaining $833_0_33 would decrease the balance to $19,166_0_67.
The following month the interest would be (10 percent of $19,166_0_67)/12, and so forth.
Also have the program output the total interest paid over the life of the loan.
Finally, determine what simple annualized percentage of the original loan balance was paid in interest.
For example, if $1,000 was paid in interest on a $10,000 loan and it took 2 years to pay off, then the annualized interest is $500, which is 5 percent of the $10,000 loan amount.
Your program should allow the user to repeat this calculation as often as desired.
The Fibonacci numbers Fn are defined as follows.
In other words, each number is the sum of the previous two numbers.
The first few Fibonacci numbers are 1, 1, 2, 3, 5, and 8.
One place that these numbers occur is as certain population growth rates.
If a population has no deaths, then the series shows the size of the population after each time period.
It takes an organism two time periods to mature to reproducing age, and then the organism reproduces once every time period.
The formula applies most straightforwardly to asexual reproduction at a rate of one offspring per time period.
Assume that the green crud population grows at this rate and has a time period of 5 days.
Hence, if a green crud population starts out as 10 pounds of crud, then in 5 days there is still 10 pounds of crud; in 10 days there is 20 pounds of crud, in 15 days 30 pounds, in 20 days 50 pounds, and so forth.
Write a program that takes both the initial size of a green crud population (in pounds) and a number of days as , and that outputs the number of pounds of green crud after that many days.
Assume that the population size is the same for 4 days and then increases every fifth day.
Your program should allow the user to repeat this calculation as often as desired.
The value e x can be approximated by the sum 1 + x n.
The program should also output e x calculated using the predefined function exp.
The function exp is a predefined function such that exp(x) returns an approximation to the value ex.
The function exp is in the library with the header file cmath.
Your program should repeat the calculation for new  of x until the user says she or he is through.
Use variables of type double to store the factorials or you are likely to produce integer overflow (or arrange your calculation to avoid any direct calculation of factorials).
Output the 100 output  in a format that will fit all 100  on the screen.
For example, you might output 10 lines with 10  on each line.
An approximate value of  can be calculated using the series given below: = 4 [ 1 – 1/3 + 1/5 – 1/7 + 1/9 _0__0_.
The program takes an  n that determines the number of terms in the approximation of the value of  and outputs the approximation.
Include a loop that allows the user to repeat this calculation for new n until the user says she or he wants to end the program.
The following problem is sometimes called "The Monty Hall Game Show Problem_0_" You are a contestant on a game show and have won a shot at the grand prize.
Before you are three closed doors.
Behind one door is a brand new.
Behind the other two doors are consolation prizes.
The location of the prizes is randomly selected.
The game show host asks you to select a door, and you pick one.
However, before revealing the contents behind your door, the game show host reveals one of the other doors with a consolation prize.
At this point, the game show host asks if you would like to stick with your original choice or switch your choice to the other closed door.
What choice should you make to optimize your chances of winning the.
Does it matter whether you stick with your original choice or switch doors.
Write a simulation program to solve the game show problem.
Your program should make 10,000 simulated runs through the problem, randomly selecting locations for the prize, and then counting the number of times the  was won when sticking with the original choice, and counting the number of times the  was won when switching doors.
Output the estimated probability of winning for both strategies.
Be sure that your program exactly simulates the process of selecting the door, revealing one, and then switching.
Do not make assumptions about the actual solution (for example, simply assuming that there is a 1/3 or 1/2 chance of getting the prize).
Appendix 4 gives library functions for generating random numbers.
A more detailed description is provided in Chapter 4.
VideoNote Solution to Programming Project 3_0_9 178 Chapter 3 / More Flow of Control 10_0_	Repeat Programming Project 13 from Chapter 2 but in addition ask the user if he or she is: a.
Sedentary If the user answers "Sedentary," then increase the calculated  by 20 percent.
If the user answers "Somewhat active," then increase the calculated  by 30 percent.
If the user answers "Active," then increase the VideoNote Solution to Programming Project 3_0_11 11.
The keypad on your oven is used to enter the desired baking temperature and is arranged like the digits on a phone: 1 2.
In other words, the digits 1, 4, and 7 do not work.
If a recipe calls for a temperature that can't be entered, then you would like to substitute a temperature that can be entered.
Write a program that inputs a desired temperature.
The temperature must be between 0 and 999 degrees.
If the desired temperature does not contain 1, 4, or 7, then output the desired temperature.
Otherwise, compute the next largest and the next smallest temperature that does not contain 1, 4, or 7 and output both.
For example, if the desired temperature is 450, then the program should output 399 and 500.
Similarly, if the desired temperature is 375, then the program should output 380 and 369.
The game of "23" is a two-player game that begins with a pile of 23 toothpicks.
Players take turns, withdrawing either 1, 2, or 3 toothpicks at a time.
The player to withdraw the last toothpick loses the game.
Write a human vs.
The human should always move first.
When it is the computer's turn, it should play according to the following rules:.
If there are more than 4 toothpicks left, then the computer should withdraw 4 – X toothpicks, where X is the number of toothpicks the human withdrew on the previous turn.
If there are 2 to 4 toothpicks left, then the computer should withdraw enough toothpicks to leave 1.
If there is 1 toothpick left, then the computer has to take it and loses.
When the human player enters the number of toothpicks to withdraw, the program should perform input validation.
Make sure that the entered number is between 1 and 3 and that the player is not trying to withdraw more toothpicks than exist in the pile.
Holy digits Batman.
The Riddler is planning his next caper somewhere on Pennsylvania Avenue.
In his usual sporting fashion, he has left the address in the form of a puzzle.
The address on Pennsylvania is a four-digit number where:.
All four digits are different The digit in the thousands place is three times the digit in the tens place The number is odd The sum of the digits is 27 Write a program that uses a loop (or loops) to find the address where the Riddler plans to strike.
Jonathan Swift, Gulliver's Travels Introduction A program can be thought of as consisting of subparts, such as obtaining the input data, calculating the output data, and displaying the output data.
Cplus_plus, like most programming languages, has facilities to name and code each of these subparts separately.
In this chapter we present the basic syntax for one of the two main kinds of Cplus_plus functions—namely those designed to compute a single value.
We also discuss how these functions can aid in program design.
We begin with a discussion of a fundamental design principle.
Prerequisites You should read Chapter 2 and at least look through Chapter 1 before reading this chapter.
As we noted in Chapter 1, this set of instructions is called an algorithm.
A good plan of attack for designing the algorithm is to break down the task to be accomplished into a few subtasks, decompose each of these subtasks into smaller subtasks, and so forth.
Eventually, the subtasks become so small that they are trivial to implement in Cplus_plus.
This  is called top-down design.
Preserving this top-down structure in your Cplus_plus program makes the program easier to understand, easier to change if need be, and, as will become apparent, easier to write, test, and debug.
Cplus_plus, like most programming languages, has facilities to include separate subparts inside of a program.
In other programming languages these subparts are called subprograms, procedures, or methods.
Additionally, dividing the task allows different people to work on the different subtasks.
When producing a very large program, such as a compiler or office-management system, this sort of teamwork is needed if the program is to be produced in a reasonable amount of time.
We will begin our discussion of functions by showing you how to use functions that were written by somebody else.
Before we show you how to define functions, we will first show you how to use some functions that are already defined for you.
Using Predefined Functions We will use the sqrt function to illustrate how you use predefined functions.
The sqrt function calculates the square root of a number.
The value the function starts out with is called its argument.
The value it computes is called the value returned.
Some functions may have more than one argument, but no function has more than one value returned.
If you think of the function as being similar to a small program, then the arguments are analogous to the input and the value returned is analogous to the output.
The syntax for using functions in your program is simple.
To set a variable named  equal to the square root of 9_0_0, you can use the following assignment statement: = sqrt(9_0_0); The expression sqrt(9_0_0) is called a function call (or if you want to be fancy you can also call it a function invocation).
An argument in a function call can be a constant, such as 9_0_0, or a variable, or a more complicated expression.
A function call is an expression that can be used like any other expression.
You can use a function call wherever it is legal to use an expression of the type specified for the value returned by the function.
For example, the value returned by sqrt is of type double.
Thus, the following is legal (although perhaps stingy): = sqrt(sales)/10; sales and  are variables that would normally be of type double.
The function call sqrt(sales) is a single item, just as if it were enclosed in parentheses.
Thus, this assignment statement is equivalent to.
The program computes the size of the largest square dog house that can be built for the amount of money the user  willing to spend.
The program asks the user for an amount of money and then determines how many square feet of floor space can be purchased for that amount of money.
That calculation yields an area in square feet for the floor area of the dog house.
The function sqrt yields the length of one side of the dog house floor.
Notice that there  another new  in the program in Display 4_0_1: # <cmath> Function Call A function call  an expression consisting of the function name followed by arguments enclosed in parentheses.
If there  more than one argument, the arguments are separated by commas.
A function call an expression that can be used like any other expression of the type specified for the value returned by the function.
Syntax where the Argument_List  a comma-separated list of arguments:.
As we noted in Chapter 2, such lines are called  directives.
The name inside the angular brackets <>  the name of a file known as a header file.
A header file for a library provides 4_0_2 Predefined Functions Display 4_0_1   A Function Call 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27.
Sample Dialogue Enter the amount budgeted for your dog house: $25_0_00 For a price of $25_0_00 I can build you a luxurious square dog house that  1_0_54 feet on each.
This enables the linker to find object code for the functions in the library so that it can correctly link the library to your program.
For example, the library iostream contains the definitions of cin and , and the header file for the iostream library  called iostream.
The math library contains the definition of the function sqrt and a number of other mathematical functions, and the header file for this library  cmath.
If your program uses a predefined function from some library, then it must contain a directive that names the header file for that library, such as the following: 185.
Be sure to follow the syntax illustrated in our examples.
Do not forget the symbols < and >; they are the same symbols as the less-than and greater-than symbols.
There should be no space between the < and the filename, nor between the filename and the >.
Also, some compilers require that directives have no spaces around the #, so it  always safest to place the # at the very start of the line and not to put any space between the # and the word.
These #   directives are normally placed at the beginning of the file containing your program.
As we noted before, the directive # <iostream>.
This  because the definitions of names like cin and , which are given in iostream, define those names to be part of the std namespace.
If you have an  directive for a standard library such as # <cmath>.
There  no need to use multiple copies of this using directive when you have multiple  directives.
Usually, all you need to do to use a library  to place an  directive and a using directive for that library in the file with your program.
If things work with just the  directive and the using directive, you need not worry about doing anything else.
However, for some libraries on some systems, you may need to give additional instructions to the compiler or to explicitly run a linker program to link in the library.
Early C and Cplus_plus compilers did not automatically search all libraries for linking.
The details vary from one system to another, so you will have to check your manual or a local expert to see exactly what is necessary.
Some people will tell you that  directives are not processed by the compiler, but are processed by a preprocessor.
They're right, but the difference is more of a word game than anything that need concern you.
On almost all compilers the preprocessor is called automatically when you compile your program.
A few predefined functions are described in Display 4_0_2; more predefined functions are described in Appendix 4.
Notice that the absolute value functions abs and labs are in the library with header file cstdlib, so any program that uses either of these functions must contain the following directive: # <cstdlib>.
Also notice that there are three absolute value functions.
If you want to produce the absolute value of a number of type int, you use abs; if you want to produce the absolute value of a number of type long, you use labs; and if you want to produce the absolute value of a number of type double, you use fabs.
To complicate things even more, abs and labs are in the library with header file cstdlib, while fabs is in the library with header file cmath.
Recall that numbers with a fraction after the decimal point, such as numbers of type double, are often called floating-point numbers.
Another example of a predefined function is pow, which is in the library with header file cmath.
The function pow can be used to do exponentiation in Cplus_plus.
For example, if you want to set a variable  equal to xy, you can use the following: = pow(x, y); Display 4_0_2   Some Predefined Functions.
Description Type of Arguments Type of Value Returned Example Value Library Header sqrt.
Chapter 4 / Procedural Abstraction and Functions That Return a Value.
The function pow always returns a value of type double, not of type int.
Also notice that the function pow requires two arguments.
A function can have any number of arguments.
Moreover, every argument position has a specified type and the argument used in a function call should be of that type.
In many cases, if you use an argument of the wrong type, then some automatic type conversion will be done for you by Cplus_plus.
However, the results may not be what you intended.
When you call a function, you should use arguments of the type specified for that function.
One exception to this caution is the automatic conversion of arguments from type int to type double.
In many situations, including calls to the function pow, you can safely use an argument of type int when an argument of type double is specified.
Many implementations of pow have a restriction on what arguments can be used.
In these implementations, if the first argument to pow is negative, then the second argument must be a whole number.
Since you probably have enough other things to worry about when learning to program, it might be easiest and safest to use pow only when the first argument is nonnegative.
Random Number Generation Random and pseudorandom numbers Games and simulation programs often require the generation of random numbers.
Cplus_plus has a predefined function to generate pseudorandom numbers.
A pseudorandom number is one that appears to be random but is really determined by a predictable formula.
For example, here is the formula for a very simple pseudorandom number generator that specifies the ith random number  based on the previously generated random number -1: = (-1 × 7) % 11 VideoNote Random Number Generation Let's set the initial "seed," 0 = 1.
The first time we fetch a "random" number we compute 1 with the formula: 1 = (0 × 7) % 11 = (1 × 7) % 11 = 7 % 11 =7 The second time we fetch a "random" number we compute 2 with: 2 = (1 × 7) % 11 = (7 × 7) % 11 = 49 % 11 = 5 The third time we fetch a "random" number we compute 3 with: 3 = (2 × 7) % 11 = (5 × 7) % 11 = 35 % 11 = 2 and so on.
This is why they are called pseudorandom.
This particular function would not be a very good pseudorandom number generator because it would repeat numbers rather quickly.
The random number generator in Cplus_plus varies depending upon the library implementation but uses the same basic idea as our simple generator with some enhancements to achieve a random uniform distribution.
We can get a different sequence of random numbers if we start with a different seed value.
In the example, the seed always started at 1.
However, if the seed is initialized with a number that changes, such as the time on the computer's clock, then we will likely get a different sequence of random numbers every time we run the program.
To seed Cplus_plus's random number generator use the predefined method srand.
It returns no value and takes as input an unsigned integer that is the initial seed value.
To always seed the random number generator with the value 35, we would use: srand(35); To vary the random number sequence every time the program is executed, we can seed the random number generator with the time of day.
Invoking the predefined function time(0) returns the number of seconds that have elapsed since January 1, 19701 on most systems.
The time function requires you to the ctime library.
We can get a random number by calling the function rand, which will return an integer in the range 0 to RAND_MAX.
RAND_MAX is a constant defined in cstdlib and is guaranteed to be 32767 or higher.
Usually, a number between 0 and RAND_MAX is not what is desired, in which case the random number can be scaled by modulus and addition.
For example, to simulate rolling a sixsided  we could use the following: int  = (rand() % 6) + 1; The random number modulo 6 gives us a number between 0 and 5.
Adding 1 results in a random integer that is in the range from 1 to 6.
It is important to seed the random number generator only once.
A common error is to invoke srand every time a random number is generated.
If both srand and rand are placed in a loop, then the likely  is a sequence of identical numbers, because the computer runs quickly enough that the time value will probably not change for repeated calls to srand.
The number of seconds elapsed since January 1, 1970 is known as Unix time.
Chapter 4 / Procedural Abstraction and Functions That Return a Value Type Casting Division may require the type double Recall that 9/2 is integer division and evaluates to 4, not 4_0_5.
If you want division to produce an answer of type double (that is, including the fractional part after the decimal point), then at least one of the two numbers in the division must be of type double.
For example, 9/2_0_0 evaluates to 4_0_5.
If one of the two numbers is given as a constant, you can simply add a decimal point and a zero to one (or both) numbers, and the division will then produce a value that includes the digits after the decimal point.
But what if both of the operands in a division are variables, as in the following.
It does not matter how the program does this_0_> = total_candy/number_of_people; Unless you convert the value in one of the variables total_candy or number_of_people to a value of type double, then the result of the division will be 4, not 4_0_5 as it should be.
The fact that the variable is of type double does not help.
The value of 4 obtained by division will be converted to a value of type double before it is stored in the variable , but that will be too late.
The 4 will be converted to 4_0_0 and the final value of  will be 4_0_0, not 4_0_5.
If one of the quantities in the division were a constant, you could add a decimal point and a zero to convert the constant to type double, but in this case both quantities are variables.
Fortunately, there is a way to convert from type int to type double that you can use with either a constant or a variable.
In Cplus_plus you can tell the computer to convert a value of type int to a value of type double.
The way that you write "Convert the value 9 to a value of type double" is The notation <double> is a kind of predefined function that converts a value of some other type, such as 9, to a value of type double, in this case 9_0_0.
An expression such as <double>(9) is called a type cast.
You can use a variable or other expression in place of the 9.
You can use other type names besides double to obtain a type cast to some type other than double, but we will postpone that topic until later.
For example, in the following we use a type cast to change the type of 9 from int to double and so the value of  is set to 4_0_5: double ; = <double>(9)/2;.
You can use 9_0_0 instead of <double>(9) when you want to convert 9 to a value of type double.
However, if the division involves only variables, then type casting may be your only sensible alternative.
Using type casting, we can rewrite our earlier example so that the variable  receives the correct value of 4_0_5, instead of 4_0_0; in order to do this, the only change we need is the replacement of total_candy with <double>(total_ candy), as shown in what follows: int total_candy, number_of_people; double ; <The program somehow sets the value of total_candy to 9 and the value of number_of_people to 2.
It does not matter how the program does this_0_> = <double>(total_candy)/number_of_people; Notice the placement of parentheses in the type casting used in the code.
You want to do the type casting before the division so that the division operator is working on a value of type double.
If you wait until after the division is completed, then the digits after the decimal point are already lost.
If you mistakenly use the following for the last line of the previous code, then the value of  will be 4_0_0, not 4_0_5.
A Function to Convert from int to double The notation <double> can be used as a predefined function and will convert a value of some other type to a value of type double.
For example, <double>(2) returns 2_0_0.
This is called type casting.
Chapter 4 / Procedural Abstraction and Functions That Return a Value Older Form of Type Casting double used as a function The use of <double>, as we discussed in the previous section, is the preferred way to perform a type cast.
However, older versions of Cplus_plus used a different notation for type casting.
This older notation simply uses the type name as if it were a function name, so double(9) returns 9_0_0.
Thus, if  is a variable of type double, and if both total_candy and number_of_people are variables of type int, then the following two assignment statements are equivalent: = <double>(total_candy)/number_of_people;.
Pitfall   Integer Division Drops the Fractional Part In integer division, such as computing 11/2, it is easy to forget that 11/2 gives 5,.
The fractional part is not generated.
Observe that the fact that  is of type double does not change the division result.
The variable  receives the value 5_0_0, not 5_0_5.
Convert each of the following mathematical expressions to a Cplus_plus arithmetic expression: √x + y xy + 7 √ time + tide nobody – b + √ b 2 – 4ac 2a √ area + fudge x–y 3.
Write a complete Cplus_plus program to compute and output the square root of PI; PI is approximately 3_0_14159.
The const double PI is predefined in cmath.
You are encouraged to use this predefined constant.
Write and compile short programs to test the following issues: a_0_ Determine whether your compiler will allow the #include <iostream> anywhere on the line, or if the # needs to be flush with the left margin.
My Uncle, The Tailor In the previous section we told you how to use predefined functions.
In this section we tell you how to define your own functions.
Function Definitions You can define your own functions, either in the same file as the main part of your program or in a separate file so that the functions can be used by several different programs.
The definition is the same in either case, but for now, we will assume that the function definition will be in the same file as the main part of your program.
Display 4_0_3 contains a sample function definition in a complete program that demonstrates a call to the function.
The function is called total_cost.
The function takes two arguments—the price for one item and number of items for a purchase.
The function returns the total cost, including sales tax, for that many items at the specified price.
The function is called in the same way a predefined function is called.
The description of the function, which the programmer must write, is a bit more complicated.
The description of the function is given in two parts that are called the function declaration and the function definition.
The function declaration (also known as the function prototype) describes how the function is called.
Cplus_plus requires that either the complete function definition 193.
Chapter 4 / Procedural Abstraction and Functions That Return a Value Display 4_0_3   A Function Definition 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38.
Sample Dialogue Enter the number of items purchased: 2 Enter the price per item: $10_0_10 2 items at $10_0_10 each.
Final , including tax, is $21_0_21 function body function definition 4_0_3 Programmer-Defined Functions or the function declaration appears in the code before the function is called.
The function declaration for the function total_cost is in color at the top of Display 4_0_3 and is reproduced here: double total_cost(int number_par, double price_par); The function declaration tells you everything you need to know in order to write a call to the function.
It tells you the name of the function, in this case total_cost.
It tells you how many arguments the function needs and what type the arguments should be; in this case, the function total_cost takes two arguments, the first one of type int and the second one of type double.
The identifiers number_par and price_par are called formal parameters.
A formal parameter is used as a kind of blank, or place holder, to stand in for the argument.
When you write a function declaration, you do not know what the arguments will be, so you use the formal parameters in place of the arguments.
The names of the formal parameters can be any valid identifiers, but for a while we will end our formal parameter names with _par so that it will be easier for us to distinguish them from other items in a program.
Notice that a function declaration ends with a semicolon.
The first word in a function declaration specifies the type of the value returned by the function.
Thus, for the function total_cost, the type of the value returned is double.
As you can see, the function call in Display 4_0_3 satisfies all the requirements given by its function declaration.
Let's take a look.
The function call is in the following line: = total_cost(number, price); The function call is the expression on the right-hand side of the equal sign.
The function name is total_cost, and there are two arguments: The first argument is of type int, the second argument is of type double, and since the variable is of type double, it looks like the function returns a value of type double (which it does).
All that detail is determined by the function declaration.
The compiler does not care whether there's a comment along with the function declaration, but you should always  a comment that explains what value is returned by the function.
Function Declaration A function declaration tells you all you need to know to write a call to the function.
A function declaration is required to appear in your code prior to a call to a function whose definition has not yet appeared.
Function declarations are normally placed before the main part of your program.
Type_Returned Function_Name(Parameter_List); Function_Declaration_Comment Do not forget this semicolon.
In Display 4_0_3 the function definition is in color at the bottom of the display.
A function definition describes how the function computes the value it returns.
If you think of a function as a small program within your program, then the function definition is like the code for this small program.
In fact, the syntax for the definition of a function is very much like the syntax for the main part of a program.
A function definition consists of a function header followed by a function body.
The function header is written the same way as the function declaration, except that the header does not have a semicolon at the end.
This makes the header a bit repetitious, but that's OK.
Although the function declaration tells you all you need to know to write a function call, it does not tell you what value will be returned.
The value returned is determined by the statements in the function body.
The function body follows the function header and completes the function definition.
The function body consists of declarations and executable statements enclosed within a pair of braces.
Thus, the function body is just like the body of the main part of a program.
When the function is called, the argument values are plugged in for the formal parameters and then the statements in the body are executed.
The value returned by the function is determined when the function executes a return statement.
The function definition in Display 4_0_3 contains the following return statement: return ( +  * ); When this return statement is executed, the value of the following expression is returned as the value of the function call: 4_0_3 Programmer-Defined Functions.
For consistency, some programmers advocate using these parentheses even on simple expressions.
In the function definition in Display 4_0_3, there are no statements after the return statement, but if there were, they would not be executed.
When a return statement is executed, the function call ends.
A Function Is Like a Small Program To understand functions, keep the following three points in mind: ■ A function definition is like a small program and calling the function is the ■ A function uses formal parameters, rather than cin, for input.
The arguments to the function are the input and they are plugged in for the formal parameters.
The function returns a value, which is like the "output" for the function.
The function uses a return statement instead of a cout statement for Let's see exactly what happens when the following function call is executed in the program shown in Display 4_0_3: = total_cost(number, price); First, the values of the arguments number and price are plugged in for the formal parameters; that is, the values of the arguments number and price are substituted in for number_par and price_par.
In the Sample Dialogue, number receives the value 2 and price receives the value 10_0_10.
This substitution process is known as the call-by-value mechanism, and the formal parameters are often referred to as call-by-value formal parameters, or simply as call-by-value parameters.
There are three things that you should note about this substitution process: 1.
It is the values of the arguments that are plugged in for the formal parameters.
If the arguments are variables, the values of the variables, not the variables themselves, are plugged in.
The first argument is plugged in for the first formal parameter in the parameter list, the second argument is plugged in for the second formal parameter in the list, and so forth.
Chapter 4 / Procedural Abstraction and Functions That Return a Value 3.
When an argument is plugged in for a formal parameter (for instance, when 2 is plugged in for number_par), the argument is plugged in for all instances of the formal parameter that occur in the function body (for instance, 2 is plugged in for number_par each time it appears in the function body).
The entire process involved in the function call shown in Display 4_0_3 is described in detail in Display 4_0_4.
Display 4_0_4   Details of a Function Call.
Before the function is called, values of the variables number and price are set to 2 and 10_0_10, by cin statements (as you can see the Sample Dialogue in 2.
The function call executes and the value = total_cost (number, price); of number (which is 2) plugged in for 2 10_0_10 number_par and value of price (which _0_setf (ios::fixed); is 10_0_10) plugged in for price_par.
When the return statement is executed, the value of the expression after return is evaluated and returned by the function.
The value 21_0_21 is returned to where the function was invoked.
The result is that total_cost (number, price) is replaced by the return value of 21_0_21.
The value of  (on the left-hand side of the equal sign) is set equal to 21_0_21 when the statement  = total_cost (number, price); finally ends.
Functions That Return a Boolean Value A function may return a bool value.
Such a function can be used in a Boolean expression to control an if-else statement or to control a loop statement, or it can be used anywhere else that a Boolean expression is allowed.
The returned type for such a function should be the type bool.
A call to a function that returns a Boolean value of true or false can be used anywhere that a Boolean expression is allowed.
This can often make a program easier to read.
By means of a function declaration, you can associate a complex Boolean expression with a meaningful name and use the name as a Boolean expression in an if-else statement or anywhere else that a Boolean expression is allowed.
For example, the statement { _0__0_.
The following two function declarations are equivalent: double total_cost(int number_par, double price_par);.
We will always use the first form so that we can refer to the formal parameters in the comment that accompanies the function declaration.
However, you will often see the second form in manuals that describe functions_0_2 All Cplus_plus needs to link to your program to the library for your function is the function name and sequence of types of the formal parameters.
The formal parameter names are important only to the function definition.
However, programs should communicate to programmers as well as to compilers.
It is frequently very helpful in understanding a function to use the name that the programmer attaches to the function's data.
Chapter 4 / Procedural Abstraction and Functions That Return a Value This alternate form applies only to function declarations.
Function headers must always list the formal parameter names.
Pitfall   Arguments in the Wrong Order When a function is called, the computer substitutes the first argument for the first formal parameter, the second argument for the second formal parameter, and so forth.
It does not check for reasonableness.
If you confuse the order of the arguments in a function call, the program will not do what you want it to do.
In order to see what can go wrong, consider the program in Display 4_0_5.
The programmer who wrote that program carelessly reversed the order of the arguments in the call to the function grade.
The function call should have been = grade(score, need_to_pass); This is the only mistake in the program.
Yet, some poor student has been mistakenly failed in a course because of this careless mistake.
The function grade is so simple that you might expect this mistake to be discovered by the programmer when the program is tested.
However, if grade were a more complicated function, the mistake might easily go unnoticed.
If the type of an argument does not match the formal parameter, then the compiler may give you a warning message.
Unfortunately, not all compilers will give such warning messages.
Moreover, in a situation like the one in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19.
Sample Dialogue Enter your score and the minimum needed to pass: 98 60 You received a score of 98 Minimum to pass  60 Sorry.
F will be entered in your record.
Display 4_0_5, no compiler will complain about the ordering of the arguments, because the function argument types will match the formal parameter types no matter what order the arguments are in.
Display 4_0_6 gives a summary of the syntax for a function declaration and definition.
There actually a bit more freedom than that display indicates.
The declarations and executable statements in the function definition can be intermixed, as VideoNote Programmer-Defined Function Example 201.
Chapter 4 / Procedural Abstraction and Functions That Return a Value Spacing and line breaks long as each variable  declared before it  used.
The rules about intermixing declarations and executable statements in a function definition are the same as they are for the main part of a program.
However, unless you have reason to do otherwise, it  best to place the declarations first, as indicated in Display 4_0_6.
Since a function does not return a value until it executes a return statement, a function must contain one or more return statements in the body of the function.
A function definition may contain more than one return statement.
For example, the body of the code might contain an if-else statement, and each branch of the if-else statement might contain a different return statement, as illustrated in Display 4_0_5.
Any reasonable pattern of spaces and line breaks in a function definition will be accepted by the compiler.
However, you should use the same rules for indenting and laying out a function definition as you use for the main part of a program.
In particular, notice the placement of braces {} in our function definitions and in Display 4_0_6.
The opening and closing braces that mark the ends of the function body are each placed on a line by themselves.
More About Placement of Function Definitions We have discussed where function definitions and function declarations are normally placed.
Under normal circumstances these are the best locations for the function declarations and function definitions.
However, the compiler will accept programs with the function definitions and function declarations in certain other locations.
A more precise statement of the rules  as follows: Display 4_0_6   Syntax for a Function That Returns a Value Function Declaration Type_Returned Function_Name(Parameter_List); Function_Declaration_Comment.
Executable_Statement_Last } 4_0_3 Programmer-Defined Functions Each function call must be preceded by either a function declaration for that function or the definition of the function.
For example, if you place all of your function definitions before the main part of the program, then you need not include any function declarations.
Knowing this more general rule will help you to understand Cplus_plus programs you see in some other books, but you should follow the example of the programs in this book.
The style we are using sets the stage for learning how to build your own libraries of functions, which  the style that most Cplus_plus programmers use.
However, doing so can make the switch statement or if-else statement difficult to read.
Look at the switch statement in Display 3_0_7.
Each of the branches for choices 1, 2, and 3 could be a single function call.
This makes the layout of the switch statement and the overall structure of the program clear.
If we had instead placed all the code for each branch in the switch statement, instead of in the function definitions, then the switch statement would be an incomprehensible sea of Cplus_plus statements.
In fact, the switch statement would not even fit on one screen.
Chapter 4 / Procedural Abstraction and Functions That Return a Value 6.
Write a function declaration and a function definition for a function that takes three arguments, all of type int, and that returns the sum of its three arguments.
Write a function declaration and a function definition for a function that takes one argument of type int and one argument of type double, and that returns a value of type double that is the average of the two arguments.
Write a function declaration and a function definition for a function that takes one argument of type double.
The function returns the character value 'P' if its argument is positive and returns 'N' if its argument is zero or negative.
Carefully describe the call-by-value parameter mechanism.
List the similarities and differences between use of a predefined (that is, library) function and a user-defined function.
Write a function definition for a function called in_order that takes three arguments of type int.
The function returns true if the three arguments are in ascending order; otherwise, it returns false.
For example, in_order(1, 2, 3) and in_order(1, 2, 2) both return true, while in_order(1, 3, 2) returns false.
Write a function definition for a function called even that takes one argument of type int and returns a bool value.
The function returns true if its one argument is an even number; otherwise, it returns false.
Write a function definition for a function is_digit that takes one argument of type char and returns a bool value.
The function returns true if the argument is a decimal digit; otherwise, it returns false.
Write a function definition for a function is_root_of that takes two arguments of type int and returns a bool value.
The function returns true if the first argument is the square root of the second; otherwise, it returns false.
OVID, Metamorphoses iv The Black-Box Analogy A person who uses a program should not need to know the details of how the program is coded.
Imagine how miserable your life would be if you had 4_0_4 Procedural Abstraction to know and remember the code for the compiler you use.
A program has a job to do, such as compile your program or check the spelling of words in your paper.
You need to know what the program's job is so that you can use the program, but you do not (or at least should not) need to know how the program does its job.
A function is like a small program and should be used in a similar way.
A programmer who uses a function in a program needs to know what the function does (such as calculate a square root or convert a temperature from degrees Fahrenheit to degrees Celsius) but should not need to know how the function accomplishes its task.
This is often referred to as treating the function like a black box.
Calling something a black box is a figure of speech intended to convey the image of a physical device that you know how to use but whose method of operation is a , because it is enclosed in a black box and you cannot see inside the box (and cannot pry it open_0_).
If a function is well designed, the programmer can use the function as if it were a black box.
All the programmer needs to know is that if he or she puts appropriate arguments into the black box, then an appropriate returned value will come out of the black box.
Designing a function so that it can be used as a black box is sometimes called information hiding to emphasize that the programmer acts as if the body of the function were hidden from view.
Display 4_0_7 contains the function declaration and two different definitions for a function named new_balance.
As the function declaration comment explains, the function new_balance calculates the new  in a bank account when simple interest is added.
For instance, if an account starts with $100, and 4_0_5 percent interest is posted to the account, then the new is $104_0_50.
Hence, the following code will change the value of from 100_0_00 to 104_0_50: = 100_0_00; = new_balance(, 4_0_5); It does not matter which of the implementations of new_balance shown in Display 4_0_7 that a programmer uses.
The two definitions produce functions that return exactly the same values.
We may as well place a black box over the body of the function definition so that the programmer does not know which implementation is being used.
In order to use the function new_ , all the programmer needs to read is the function declaration and the accompanying comment.
Writing and using functions as if they were black boxes is also called procedural abstraction.
When programming in Cplus_plus it might make more sense to call it functional abstraction.
However, procedure is a more general term 205.
Chapter 4 / Procedural Abstraction and Functions That Return a Value Display 4_0_7   Definitions That Are Black-Box Equivalent Function Declaration 1 2 3 4 5 6.
The three terms mean the same thing.
Whatever you call this principle, the important point is that you should use it when designing and writing your function definitions.
Procedural Abstraction When applied to a function definition, the principle of procedural abstraction means that your function should be written so that it can be used like a black box.
This means that the programmer who uses the function should not need to look at the body of the function definition 4_0_4 Procedural Abstraction to see how the function works.
The function declaration and the accompanying comment should be all the programmer needs to know in order to use the function.
To ensure that your function definitions have this important property, you should strictly adhere to the following rules: How to Write a Black-Box Function Definition (That Returns ■ The function declaration comment should tell the programmer any and all conditions that are required of the arguments to the function and should describe the value that is returned by the function when called with these arguments.
On large programming projects, a different programmer may be assigned to write each function.
The programmer should choose the most meaningful names he or she can find for formal parameters.
The arguments that will be substituted for the formal parameters may well be variables in the main part of the program.
These variables should also be given meaningful names, often chosen by someone other than the programmer who writes the function definition.
This makes it likely that some or all arguments will have the same names as some of the formal parameters.
This is perfectly acceptable.
No matter what names are chosen for the variables that will be used as arguments, these names will not produce any confusion with the names used for formal parameters.
After all, the functions will use only the values of the arguments.
When you use a variable as a function argument, the function takes only the value of the variable and disregards the variable name.
Now that you know you have complete freedom in choosing formal parameter names, we will stop placing a "_par" at the end of each formal parameter name.
For example, in Display 4_0_8 we have rewritten the definition for the function total_cost from Display 4_0_3 so that the formal parameters are named number and price rather than number_par and price_par.
If you replace the function declaration and definition of the function total_cost that appear in Display 4_0_3 with the versions in Display 4_0_8, then the program will perform in exactly the same way, even though there will be formal parameters named number and price and there will be variables in the main part of the program that are also named number and price.
Chapter 4 / Procedural Abstraction and Functions That Return a Value Display 4_0_8   Simpler Formal Parameter Names Function Declaration 1 2 3.
Function Definition 1 2 3 4 5 6 7.
Consider the explicitly nested loops in Display 3_0_15 that computed the total number of green-necked vulture eggs counted by all conservationists.
We can make this code more readable by moving the loops into procedure calls, as shown in Display 4_0_9.
The two versions of our program for totaling green-necked vulture eggs are equivalent.
Both programs produce the same dialogue with the user.
However, most people find the version in Display 4_0_9 easier to understand because the loop body is a function call.
When considering the outer loop, you should think of computing the  for one conservationist's report as a single operation and not think of it as a loop.
This way you can separate the design of the loop body from the design of the rest of the program.
This divides your programming task into two smaller subtasks.
Chapter 4 / Procedural Abstraction and Functions That Return a Value 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63.
Sample Dialogue This program tallies conservationist on the green-necked vulture.
Each conservationist's report consists of a list of numbers.
Each  is the  of the eggs observed in one green-necked vulture nest.
This program then tallies the   of eggs.
Place a negative integer at the end of your list.
Place a negative integer at the end of your list.
This is particularly true when buying pizzas.
Pizza sizes are given as the diameter of the pizza in inches.
However, the quantity of pizza is determined by the area of the pizza, and the area is not proportional to the diameter.
Most people cannot easily estimate the difference in area between a 10-inch pizza and a 12-inch pizza and so cannot easily determine which size is the best buy—that is, which size has the lowest price per square inch.
In this case study we will design a program that compares two sizes of pizza to determine which is the better buy.
Problem Definition The precise specification of the program input and output are as follows: Input The input will consist of the diameter in inches and the price for each of two sizes of pizza.
Output The output will give the cost per square inch for each of the two sizes of pizza and will tell which is the better buy, that is, which has the lowest cost per square inch.
Subtask 2: Compute the price per square inch for the small pizza.
Subtask 3: Compute the price per square inch for the large pizza.
Subtask 4: Determine which is the better buy.
Subtask 5: Output the results.
Notice subtasks 2 and 3.
They have two important properties: Subtasks 2 and 3 211.
Chapter 4 / Procedural Abstraction and Functions That Return a Value 1.
They are exactly the same task.
The only difference is that they use different data to do the computation.
The only things that change between subtask 2 and subtask 3 are the size of the pizza and its price.
The result of subtask 2 and the result of subtask 3 are each a single value: the price per square inch of the pizza.
When to define a function Whenever a subtask takes some values, such as some numbers, and returns a single value, it is natural to implement the subtask as a function.
Whenever two or more such subtasks perform the same computation, they can be implemented as the same function called with different arguments each time it is used.
We therefore decide to use a function called unitprice to compute the price per square inch of a pizza.
The function declaration and explanatory comment for this function will be as follows: double unitprice(int diameter, double price); //Returns the price per square inch of a pizza.
The formal //parameter named diameter is the diameter of the pizza in //inches.
The formal parameter named price is the price of //the pizza.
Subtasks 4 and 5 Subtasks 2 and 3 Subtask 1 is straightforward.
The program will simply ask for the input values and store them in four variables, which we will call diameter_small, diameter_large, price_small, and price_large.
Subtask 4 is routine.
To determine which pizza is the best buy, we just compare the cost per square inch of the two pizzas using the less-than operator.
Subtask 5 is a routine output of the results.
Subtasks 2 and 3 are implemented as calls to the function unitprice.
Next, we design the algorithm for this function.
The hard part of the algorithm is determining the area of the pizza.
Once we know the area, we can easily determine the price per square inch using division, as follows: price/area where area is a variable that holds the area of the pizza.
This expression will be the value returned by the function unitprice.
But we still need to formulate a method for computing the area of the pizza.
A pizza is basically a circle (made up of bread, cheese, sauce, and so forth).
The area of a circle (and hence of a pizza) is πr 2, where r is the radius of the circle and π is the number called "pi," which is approximately equal to 3_0_14159.
The radius is one half of the diameter.
The algorithm for the function unitprice can be outlined as follows: Algorithm Outline for the Function unitprice 1.
Compute the radius of the pizza.
Compute the area of the pizza using the formula πr 2.
Return the value of the expression (price/area).
We will express this more detailed version of our algorithm in pseudocode.
Pseudocode is a mixture of Cplus_plus and ordinary English.
Pseudocode allows us to make our algorithm precise without worrying about the details of Cplus_plus syntax.
We can then easily translate our pseudocode into Cplus_plus code.
In our pseudocode,  and  will be variables for holding the values indicated by their names.
Pseudocode for the Function unitprice.
Coding Coding subtask 1 is routine, so we next consider subtasks 2 and 3.
Our program can implement subtasks 2 and 3 by the following two calls to the.
One of the benefits of a function definition is that you can have multiple calls to the function in your program.
This saves you the trouble of repeating the same (or almost the same) code.
But we still must write the code for the function unitprice.
When we translate our pseudocode into Cplus_plus code, we obtain the following for the body of the function unitprice: {//First draft of the function body for unitprice.
Yet, as written, this line contains a serious mistake.
We want the division to produce the  of the pizza including any fraction.
Chapter 4 / Procedural Abstraction and Functions That Return a Value For example, if we are considering buying the "bad luck special," which is a 13-inch pizza, then the  is 6_0_5 inches.
But the variable diameter is of type int.
Thus, as we saw in Chapter 2, this line would perform integer division and would compute the  13/2 to be 6 instead of the correct value of 6_0_5, and we would have disregarded a half inch of pizza.
In all likelihood, this would go unnoticed, but the result could be that millions of subscribers to the Pizza Consumers Union could be wasting their money by buying the wrong size pizza.
This is not likely to produce a major worldwide recession, but the program would be failing to accomplish its goal of helping consumers find the best buy.
In a more important program, the result of such a simple mistake could be disastrous.
How do we fix this mistake.
We want the division by 2 to be regular division that includes any fractional part in the answer.
That form of division requires that at least one of the arguments to the division operator / must be of type double.
We can use type casting to convert the constant 2 to a value of type double.
Recall that <double>(2), which is called a type casting, converts the int value 2 to a value of type double.
Thus, if we replace 2 by <double>(2), that will change the second argument in the division from type int to type double, and the division will then produce the result we want.
The rewritten assignment statement is = diameter/<double>(2); The complete corrected code for the function definition of unitprice, along with the rest of the program, is shown in Display 4_0_10.
The type cast <double>(2) returns the value 2_0_0, so we could have used the constant 2_0_0 in place of <double>(2).
Either way, the function unitprice will return the same value.
However, by using <double>(2), we make it conspicuously obvious that we want to do the version of division that includes the fractional part in its answer.
If we instead used 2_0_0, then when revising or copying the code, we can easily make the mistake of changing 2_0_0 to 2, and that would produce a subtle problem.
We need to make one more remark about the coding of our program.
As you can see in Display 4_0_10, when we coded tasks 4 and 5, we combined these two tasks into a single section of code consisting of a sequence of cout statements followed by an if-else statement.
When two tasks are very simple and are closely related, it sometimes makes sense to combine them into a single task.
Program Testing Just because a program compiles and produces answers that look right does not mean the program is correct.
In order to increase your confidence in your program, you should test it on some input values for which you know the correct answer by some other means, such as working out the answer with paper and pencil or by using a handheld calculator.
For example, it does not make sense to buy a 2-inch pizza, but it can still be used as 4_0_4 Procedural Abstraction 215 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46.
Chapter 4 / Procedural Abstraction and Functions That Return a Value 47 48 49 50 51 52 53 54 55 56 57 58.
Sample Dialogue Welcome to the Pizza Consumers Union.
Enter diameter of a small pizza (in inches): 10 Enter the price of a small pizza: $7_0_50 Enter diameter of a large pizza (in inches): 13 Enter the price of a large pizza: $14_0_75 Small pizza: = 10 inches = $7_0_50 Per square  = $0_0_10 Large pizza: = 13 inches = $14_0_75 Per square  = $0_0_11 The small one is the better buy.
It is an easy test case because it is easy to compute the answer by hand.
Let's calculate the cost per square of a 2- pizza that sells for $3_0_14.
Since the diameter is 2 inches, the is 1.
If we divide this into the price of $3_0_14, we find that the price per square  is 3_0_14/3_0_14159, which is approximately $1_0_00.
Of course, this is an absurd size for a pizza and an absurd price for such a small pizza, but it is easy to determine the value that the function unitprice should return for these arguments.
Having checked your program on this one case, you can have more confidence in it, but you still cannot be certain your program is correct.
An incorrect program can sometimes give the correct answer, even though it will give incorrect answers on some other inputs.
You may have 4_0_4 Procedural Abstraction tested an incorrect program on one of the cases for which the program happens to give the correct output.
For example, suppose we had not caught the mistake we discovered when coding the function unitprice.
Suppose we mistakenly used 2 instead of <double>(2) in the following line:.
As long as the pizza diameter is an even number, like 2, 8, 10, or 12, the program gives the same answer whether we divide by 2 or by static_ cast<double>(2).
It is unlikely that it would occur to you to be sure to check both even- and odd-size pizzas.
However, if you test your program on several different pizza sizes, then there is a better chance that your test cases will contain samples of the relevant kinds of data.
Pseudocode is a mixture of Cplus_plus (or whatever programming language you are using) and ordinary English (or whatever human language you are using).
Pseudocode allows you to state your algorithm precisely without having to worrying about all the details of Cplus_plus syntax.
When the Cplus_plus code for a step in your algorithm is obvious, there is little point in stating it in English.
When a step is difficult to express in Cplus_plus, the algorithm will be clearer if the step is expressed in English.
You can see an example of pseudocode in the previous case study, where we expressed our algorithm for the function unitprice in pseudocode.
What is the purpose of the comment that accompanies a function declaration.
What is the principle of procedural abstraction as applied to function definitions.
What does it mean when we say the programmer who uses a function should be able to treat the function like a black box.
Carefully describe the process of program testing.
Chapter 4 / Procedural Abstraction and Functions That Return a Value 19.
Consider two possible definitions for the function unitprice.
One is the definition given in Display 4_0_10.
The other definition is the same except that the type cast <double>(2) is replaced with the constant 2_0_0; in other words, the line = diameter/<double>(2);.
Are these two possible function definitions black-box equivalent.
Common Saying In the last section we advocated using functions as if they were black boxes.
In order to define a function so that it can be used as a black box, you often need to give the function variables of its own that do not interfere with the rest of your program.
The variables that "belong to" a function are called local variables.
As we will see, these variables simply conform to the scope rule for nested blocks described in Chapter 3.
In this section we take another look at scoping with an emphasis on local variables and how to use them.
The Small Program Analogy Look back at the program in Display 4_0_1.
It includes a call to the predefined function sqrt.
We did not need to know anything about the details of the function definition for sqrt in order to use this function.
In particular, we did not need to know what variables were declared in the definition of sqrt.
A function that you define is no different.
Variable declarations in function definitions that you write are as separate as those in the function definitions for the predefined functions.
Variable declarations within a function definition are the same as if they were variable declarations in another program.
If you declare a variable in a function definition and then declare another variable of the same name in the main part of your program (or in the body of some other function definition), then these two variables are two different variables, even though they have the same name.
Let's look at a program that does have a variable in a function definition with the same name as another variable in the program.
The program in Display 4_0_11 has two variables named average_pea; one is declared and used in the function definition for the function est_total, and the other is declared and used in the main part of the program.
The variable 4_0_5 Scope and Local Variables 219 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46.
Chapter 4 / Procedural Abstraction and Functions That Return a Value Sample Dialogue Enter minimum and maximum number of peas in a : 4 6 Enter the number of pods: 10 Enter the  of an average pea (in ounces): 0_0_5 Min number of peas per  = 4 Max number of peas per  = 6 = 10 Average pea  = 0_0_500 ounces Estimated average  = 25_0_000 ounces in the function definition for est_total and the variable in the main part of the program are two different variables.
It is the same as if the function est_total were a predefined function.
The two variables named  will not interfere with each other any more than two variables in two completely different programs would.
When the variable  is given a value in the function call to est_total, this does not change the value of the variable in the main part of the program that is also named.
Variables that are defined within the main body of the program are said to be local to the main part of the program or to have the main part of the program as their scope.
There are other kinds of variables that are not local to any function or to the main part of the program, but we will have no use for such variables.
Every variable we will use is either local to a function definition or local to the main part of the program.
When we say that a variable is a local variable without any mention of a function and without any mention of the main part of the program, we mean that the variable is local to some function definition.
Local Variables Variables that are declared within the body of a function definition are said to be local to that function or to have that function as their scope.
Variables that are declared within the main part of the program are said to be local to the main part of the program or to have the main part of the program as their scope.
When we say that a variable is a local variable without any mention of a function and without any mention of the main part of the 4_0_5 Scope and Local Variables program, we mean that the variable is local to some function definition.
If a variable is local to a function, then you can have another variable with the same name that is declared in the main part of the program or in another function definition, and these will be two different variables, even though they have the same name.
Programming Example Experimental Pea Patch The program in Display 4_0_11 gives an estimate for the total  on a small garden plot used to raise an experimental variety of peas.
The function est_total returns an estimate of the total number of peas harvested.
The function est_total takes three arguments.
One argument is the number of pea pods that were harvested.
The other two arguments are used to estimate the average number of peas in a.
Different pea pods contain differing numbers of peas, so the other two arguments to the function are the smallest and the largest number of peas that were found in any one.
The function est_total averages these two numbers and uses this average as an estimate for the average number of peas in a.
Global Constants and Global Variables As we noted in Chapter 2, you can and should name constant values using the const modifier.
For example, in Display 4_0_10 we used the following declaration to give the name  to the constant 3_0_14159: const double  = 3_0_14159;.
This worked out fine because each named constant was used by only one function.
However, it can easily happen that more than one function uses a named constant.
In that case you can place the declaration for naming a constant at the beginning of your program, outside of the body of all the functions and outside the body of the main part of your program.
The named constant is then said to be a global named constant and the named constant can be used in any function definition that follows the constant declaration.
Display 4_0_12 shows a program with an example of a global named constant.
The program asks for a radius and then computes both the area of 221.
Chapter 4 / Procedural Abstraction and Functions That Return a Value 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 //Computes the area of a circle and the volume of a sphere.
The programmer who wrote that program looked up the formulas for computing those quantities and found the following: = π × (radius)2 = (4/3) × π × (radius)3 Both formulas  the constant π, which is approximately equal to 3_0_14159.
The symbol π is the Greek letter called "pi_0_" In previous programs we have used the following declaration to produce a named constant called  to use when we convert such formulas to Cplus_plus code: const double  = 3_0_14159; In the program in Display 4_0_12 we use the same declaration but place it near the beginning of the file so that it defines a global named constant that can be used in all the function bodies.
The compiler allows you wide latitude with regard to where you place the declarations for your global named constants, but to aid readability you should place all your  directives together, all your global named constant declarations together in another group, and all your function declarations together.
We will follow standard practice and place all our global named constant declarations after our  directives and before our function declarations.
Placing all named constant declarations at the start of your program can aid readability even if the named constant is used by only one function.
If the named constant might need to be changed in a future version of your program, it will be easier to find if it is at the beginning of the program.
For example, placing the constant declaration for the sales tax rate at the beginning of an accounting program will make it easy to revise the program should the tax rate increase.
It is possible to declare ordinary variables, without the const modifier, as global variables, which are accessible to all function definitions in the file.
This is done the same way that it is done for global named constants, VideoNote Walkthrough of Functions and Local Variables 224 Chapter 4 / Procedural Abstraction and Functions That Return a Value except that the modifier const is not used in the variable declaration.
However, there is seldom any need to use such global variables.
Moreover, global variables can make a program harder to understand and maintain, so we will not use any global variables.
Once you have had more experience designing programs, you may choose to occasionally use global variables.
Call-by-Value Formal Parameters Are Local Variables Formal parameters are more than just blanks that are filled in with the argument values for the function.
Formal parameters are actually variables that are local to the function definition, so they can be used just like a local variable that is declared in the function definition.
Earlier in this chapter we described the call-by-value mechanism that handles the arguments in a function call.
We can now define this mechanism for "plugging in arguments" in more detail.
When a function is called, the formal parameters for the function (which are local variables) are initialized to the values of the arguments.
This is the precise meaning of the phrase "plugged in for the formal parameters" that we have been using.
Typically, a formal parameter is used only as a kind of blank, or place holder, that is filled in by the value of its corresponding argument; occasionally, however, a formal parameter is used as a variable whose value is changed.
In this section we will give one example of a formal parameter used as a local variable.
The program in Display 4_0_13 is the billing program for the law offices of Dewey, Cheatham, and Howe.
Notice that, unlike other law firms, the firm of Dewey, Cheatham, and Howe does not charge for any time less than a quarter of an hour.
That is why it's called "the law office with a heart_0_" If they work for 1 hour and 14 minutes, they only charge for 4 quarter hours, not 5 quarter hours as other firms do; so you would pay only $600 for the consultation.
Sample Dialogue Welcome to the offices of Dewey, Cheatham, and Howe.
The law office with a heart.
Enter the hours and minutes of your consultation: 2 45 For 2 hours and 45 minutes, your   $1650_0_00 Notice the formal parameter  in the definition of the function fee.
It  used as a variable and has its value changed by the following line, which occurs within the function definition: = hours_worked * 60 + ; Formal parameters are local variables just like the variables you declare within the body of a function.
However, you should not add a variable Do not add a declaration for a formal parameter 226 Chapter 4 / Procedural Abstraction and Functions That Return a Value declaration for the formal parameters.
Listing the formal parameter minutes_ worked in the function declaration also serves as the variable declaration.
The following  the wrong way to start the function definition for fee as it declares twice:.
Block Scope The scope of a local variable refers to the part of a program that can directly access that variable and  sometimes referred to as local scope.
Similarly, global identifiers declared at the beginning of your program, outside of the body of all the functions, are sometimes referred to as having global scope.
Despite their differences, local and global identifiers are really examples of block scope described in Chapter 3.
A block  some Cplus_plus code enclosed in braces, with the exception of the "global block," which  an implied outermost block that encompasses all code.
The scope rule states that identifiers declared within their block are local to that block and accessible only from the point they are defined to the end of their block.
Blocks are commonly nested.
For example, the braces of the main function defines a block and a for loop inside main defines a nested block.
The program outlined in Display 4_0_14 doesn't compute anything interesting but illustrates the scope of identifiers declared in different blocks.
In this example, the constant GLOBAL_CONST has global scope, along with the functions function1 and main, because they are declared outside the body of all functions.
This allows us to access GLOBAL_CONST from both main and function1.
The main function declares the variables x and d that are local to main.
Their scope extends to the end of main's block.
Similarly, the function function1 has a parameter param and a local variable y that have scope extending to the end of function1.
Neither of these variables  directly accessible from outside their scope.
The scope of local variables and parameters really uses the same rule of block scope, but in this case the block refers to the function in which the variables or parameters are declared.
The for loop in Display 4_0_14 illustrates the scope of a nested block.
The variable i  declared inside the for loop and thus only has scope to the end of the loop block.
Attempts to reference i anywhere outside its scope, even if we are still inside main (for example, on line 17) would result in a compiler error.
You can think of variables as being created when their scope begins and destroyed when their scope ends.
For example, the local variable y in Display 4_0_14  created and initialized to GLOBAL_CONST every time function1  called.
If code on line 23 changed the value stored in y, then these changes would be 4_0_5 Scope and Local Variables 227 Display 4_0_14   Local, Global, and Block Scope Block Scope Revisited 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25.
Block scope: Variable  has scope from lines 13-16 Local scope to main: Variable has scope from lines 10-18 and variable  has scope from lines 11-18.
Local  to function1: Variable param has  from lines 20-25 and variable  has from lines 22-25 lost when the function exits and  goes out of  because the variable  is destroyed.
A repeat call to function1 will not recall the previous value of , but rather a new  will be created.
In addition to block  there is also namespace  and class.
Class  is discussed in Chapter 10 and namespace  in Chapter 12.
Cplus_plus also defines function prototype , which refers to the line of for parameters defined in a function prototype.
Finally, Cplus_plus supports function , which is used for labels.
Labels are a remnant from the C language and are used with goto statements.
Their use is generally shunned because they can result in logic that is difficult to follow, whereas the same task can be performed by loops in an understandable fashion.
The constant has  from lines 4-25 and the function function1 has  from lines 6-25 228.
This will allow you to use two different namespaces in two different function definitions, even if the two function definitions are in the same file and even if the two namespaces have some name(s) with different meanings in the two different namespaces.
Placing a using directive inside a function definition is analogous to placing a variable declaration inside a function definition.
If you place a variable definition inside a function definition, the variable is local to the function; that is, the meaning of the variable declaration is confined to the function definition.
If you place a using directive inside a function definition, the using directive is local to the function definition; in other words, the meaning of the using directive is confined to the function definition.
It will be some time before we use any namespace other than std in a using directive, but it will be good practice to start placing these using directives where they should go.
In Display 4_0_15 we have rewritten the program in Display 4_0_12 with the using directives where they should be placed.
The program in Display 4_0_15 will behave exactly the same as the one in Display 4_0_12.
In this particular case, the difference is only one of style, but when you start to use more namespaces, the difference will affect how your programs perform.
S elf-Tes t Exerc ise s 20.
If you use a variable in a function definition, where should you declare the variable.
In the function definition.
In the main part of the program.
Any place that is convenient.
Chapter 4 / Procedural Abstraction and Functions That Return a Value 21.
Suppose a function named Function1 has a variable named sam declared within the definition of Function1, and a function named Function2 also has a variable named sam declared within the definition of Function2.
Will the program compile (assuming everything else is correct).
If the program will compile, will it run (assuming that everything else is correct).
If it runs, will it generate an error message when run (assuming everything else is correct).
If it runs and does not produce an error message when run, will it give the correct output (assuming everything else is correct).
The following function is supposed to take as arguments a length expressed in feet and  and return the total number of  in that many feet and.
For example, total_inches(1,2) is supposed to return 14, because 1 foot and 2  is the same as 14.
Write a function declaration and function definition for a function called read_filter that has no parameters and that returns a value of type double.
The function read_filter prompts the user for a value of type double and reads the value into a local variable.
The function returns the value read provided this value is greater than or equal to zero and returns zero if the value read is negative.
Programming Example The Factorial Function Display 4_0_16 contains the function declaration and definition for a commonly used mathematical function known as the factorial function.
In mathematics texts, the factorial function is usually written.
In traditional mathematical notation, you can define.
Note that the multiplication is performed in the reverse order to what you might expect.
The program multiplies by , then  – 1, then  – 2, and so forth.
Function Definition 1 2 3 4 5 6 7 8 9 10 11.
The function definition for factorial uses two local variables: , which is declared at the start of the function body, and the formal parameter.
Since a formal parameter is a local variable, we can change its value.
In this case we change the value of the formal parameter with the decrement operator ––.
If the function factorial is called with 3 as its argument, then the first time the loop body is executed the value of  is 3, the next time the loop body is executed the value of  is 3 * 2, the next time the value of  is 3 * 2 * 1, and then the while loop ends.
Thus, the following will set the variable  equal to 6 which is 3 * 2 * 1: = factorial(3); Notice that the local variable  is initialized to the value 1 when the variable is declared.
To see that this is the correct initial value for , note that after executing the body of the while loop the first time, we want the value of  to be equal to the (original) value of the formal parameter ; if  is initialized to 1, then this will be what happens.
Formal parameter used as a local variable 232 Chapter 4 / Procedural Abstraction and Functions That Return a Value 4_0_6 Overloading Function Names "_0__0__0_— and that shows that there are three hundred and sixty-four days when "The question is," said Alice, "whether you can make words mean so many Lewis Carroll, Through the Looking-Glass Cplus_plus allows you to give two or more different definitions to the same function name, which means you can reuse names that have strong intuitive appeal across a variety of situations.
For example, you could have three functions called max: one that computes the largest of two numbers, another that computes the largest of three numbers, and yet another that computes the largest of four numbers.
When you give two (or more) function definitions for the same function name, that is called overloading the function name.
Overloading does require some extra care in defining your functions and should not be used unless it will add greatly to your program's readability.
But when it is appropriate, overloading can be very effective.
Introduction to Overloading Suppose you are writing a program that requires you to compute the average.
This will work, and in many programming languages you have no choice but to do something like this.
Fortunately, Cplus_plus allows for a more elegant solution.
In Cplus_plus you can simply use the same  name ave for both functions; you can use the following  definition in place of the  definition ave3:.
Display 4_0_17   Overloading a Function Name 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32.
The average of 2_0_0, 2_0_5, and 3_0_0 is 2_0_50000 The average of 4_0_5 and 5_0_5 is 5_0_00000 three arguments.
Chapter 4 / Procedural Abstraction and Functions That Return a Value Determining which definition applies The    now has two definitions.
This is an example of overloading.
In this case we have overloaded the.
In Display 4_0_17 we have embedded these two  definitions for  into a complete sample program.
Be sure to notice that each  definition has its own  declaration.
Overloading is a great idea.
It makes a program easier to read, and it saves you from going crazy trying to think up a new  for a just because you already used the most natural  in some other  definition.
But how does the compiler know which  definition to use when it encounters a call to a   that has two or more definitions.
The compiler cannot read a programmer's mind.
In order to tell which  definition to use, the compiler checks the number of arguments and the types of the arguments in the  call.
In the program in Display 4_0_17, one of the functions called  has two arguments and the other has three arguments.
To tell which definition to use, the compiler simply counts the number of arguments in the  call.
If there are two arguments, it uses the first definition.
If there are three arguments, it uses the second definition.
Whenever you give two or more definitions to the same  , the various  definitions must have different specifications for their arguments; that is, any two  definitions that have the same must use different numbers of formal parameters or use formal parameters of different types (or both).
Notice that when you overload a , the  declarations for the two different definitions must differ in their formal parameters.
You cannot overload a   by giving two definitions that differ only in the type of the value returned.
Overloading a Function Name If you have two or more  definitions for the same  , that is called overloading.
When you overload a  , the definitions must have different numbers of formal parameters or some formal parameters of different types.
When there is a  call, the compiler uses the  definition whose number of formal parameters and types of formal parameters match the arguments in the  call.
You saw a kind of overloading in Chapter 2 with the division operator /.
If both operands are of type int, as in 13/2, then the value returned is the result of integer division, in this case 6.
On the other hand, if one or both operands are of type double, then the value returned is the result of regular division; for example, 13/2_0_0 returned the value 6_0_5.
There are two definitions for the division operator /, and the two 4_0_6 Overloading Function Names definitions are distinguished not by having different numbers of operands, but rather by requiring operands of different types.
The difference between overloading of / and overloading  names is that the compiler has already done the overloading of / but you program the overloading of the function.
We will see in a later chapter how  overload operators such as +, –, and so on.
Programming Example Revised Pizza-Buying Program The Pizza Consumers Union has been very successful with the program that we wrote for it in Display 4_0_10.
In fact, now everybody always buys the pizza that is the best buy.
One disreputable pizza parlor used  make money by fooling consumers into buying the more expensive pizza, but our program has put an end  their evil practices.
However, the owners wish  continue their despicable behavior and have come up with a new   fool consumers.
They now offer both round pizzas and rectangular pizzas.
They know that the program we wrote cannot deal with rectangularly shaped pizzas, so they hope they can again confuse consumers.
We need  update our program so that we can foil their nefarious scheme.
We want  change the program so that it can compare a round pizza and a rectangular pizza.
The changes we need  make  our pizza evaluation program are clear: We need  change the input and output a bit so that it deals with two different shapes of pizzas.
We also need  add a new  that can compute the cost per square inch of a rectangular pizza.
We could use the following  definition in our program so that we can compute the unit price for a rectangular pizza: double unitprice_rectangular.
However, this is a rather long  for a ; in fact, it's so long that we needed  put the  heading on two lines.
That is legal, but it would be nicer  use the same , unitprice, for both the  that computes the unit price for a round pizza and for the  that computes the unit price for a rectangular pizza.
Since Cplus_plus allows overloading of  names, we can do this.
Having two definitions for the  unitprice will pose no problems  the compiler because the two functions will have different numbers of arguments.
Display 4_0_18 shows the program we obtained when we modified our pizza evaluation program  allow us  compare round pizzas with rectangular pizzas.
Chapter 4 / Procedural Abstraction and Functions That Return a Value 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 //Determines whether a round pizza or a rectangular pizza is the best buy.
The formal parameter named price is the price of the pizza.
Sample Dialogue Welcome to the Pizza Consumers Union.
Enter the diameter in inches of a round pizza: 10 Enter the price of a round pizza: $8_0_50 Enter length and width in inches of a rectangular pizza: 6 4 Enter the price of a rectangular pizza: $7_0_55 Round pizza:  = 10 inches = $8_0_50 Per square  = $0_0_11 Rectangular pizza:  = 6 inches Rectangular pizza:  = 4 inches = $7_0_55 Per square  = $0_0_31 The round one is the better buy.
Chapter 4 / Procedural Abstraction and Functions That Return a Value Automatic Type Conversion Suppose that the following function definition occurs in your program and that you have not overloaded the function name mpg (so this is the only definition of a function called ).
Hence, the following will output 22_0_5 miles per gallon to the screen: << (45, 2) << " miles per gallon"; Interaction of overloading and type conversion Cplus_plus converts the 45 to 45_0_0 and the 2 to 2_0_0, then performs the division 45_0_0/2_0_0 to obtain the value returned, which is 22_0_5.
If a function requires an argument of type double and you give it an argument of type int, Cplus_plus will automatically convert the int argument to a value of type double.
This is so useful and natural that we hardly give it a thought.
However, overloading can interfere with this automatic type conversion.
Let's look at an example.
Now, suppose you had (foolishly) overloaded the function name  so that your program also contained the following definition of  (as well as the previous one):.
If it finds such a function definition, Cplus_plus uses that function definition.
Cplus_plus does not convert an int argument to a value of type double unless that is the only way it can find a matching function definition.
The  example illustrates one more point about overloading.
You should not use the same function name for two unrelated functions.
Such careless use of function names is certain to eventually produce confusion.
Suppose you have two function definitions with the following function.
Suppose you have two function definitions with the function declarations.
Suppose you have two function definitions with the function declarations.
This question has to do with the Programming Example "Revised PizzaBuying Program_0_" Suppose the evil pizza parlor that is always trying to fool customers introduces a square pizza.
Can you overload the function unitprice so that it can compute the price per square  of a square pizza as well as the price per square  of a round pizza.
Look at the program in Display 4_0_18.
The main function contains the using directive: using namespace std;.
Chapter 4 / Procedural Abstraction and Functions That Return a Value Chapter Summary ■ A good plan of attack for designing the algorithm for a program is to break down the task to be accomplished into a few subtasks, then decompose each subtask into smaller subtasks, and so forth until the subtasks are simple enough that they can easily be implemented as Cplus_plus code.
This approach is called top-down design.
The arguments to the function serve as the input to this "small program" and the value returned ■ When a subtask for a program takes some values as input and produces a single value as its only result, then that subtask can be implemented as a function.
The programmer who uses the function should not need to know any details about how the function is coded.
All the programmer should need to know is the function declaration and the accompanying comment that describes the value returned.
This rule is sometimes called the principle of procedural abstraction.
Declarations for global named constants are normally placed at the start of a program after the include directives and before the function declarations.
Occasionally, it is useful to use a formal parameter as a local variable.
When you overload a function name, the function definitions must have different numbers of formal parameters or some formal parameters of different types.
Answers to Self -T est Exerci ses 1.
Suppose the function is defined with arguments, say param1 and param2.
The function is then called with corresponding arguments arg1 and arg2.
The values of the arguments are "plugged in" for the corresponding formal parameters, arg1 into param1, arg2 into param2.
The formal parameters are then used in the function.
Predefined (library) functions usually require that you # a header file.
For a programmer-defined function, the programmer puts the code for the function either into the file with the main part of the program or in another file to be compiled and linked to the main program.
The comment explains what value the function returns and gives any other information that you need to know in order to use the function.
The principle of procedural abstraction says that a function should be written so that it can be used like a black box.
This means that the programmer who uses the function need not look at the body of the function definition to see how the function works.
The function declaration and accompanying comment should be all the programmer needs to know in order to use the function.
When we say that the programmer who uses a function should be able to treat the function like a black box, we mean the programmer should not need to look at the body of the function definition to see how the function works.
The function declaration and accompanying comment should be all the programmer needs to know in order to use the function.
In order to increase your confidence in your program, you should test it on input values for which you know the correct answers.
Perhaps you can calculate the answers by some other means, such as pencil and paper or hand calculator.
Yes, the function would  the same value in either case, so the two definitions are black-box equivalent.
If you use a variable in a function definition, you should declare the variable in the body of the function definition.
Everything will be fine.
The program will compile (assuming everything else is correct).
The program will run (assuming that everything else is correct).
The program will not generate an error message when run (assuming everything else is correct).
The program will give the correct output (assuming everything else is correct).
The function will work fine.
That is the entire answer, but here is some additional information: The formal parameter inches is a call-by-value parameter and, as discussed in the text, it is therefore a local variable.
Thus, the value of the argument will not be changed.
The function call has only one argument, so it would use the function definition that has only one formal parameter.
The function call has two arguments of type double, so it would use the function corresponding to the function declaration with two arguments of type double (that , the first function declaration).
The second argument  of type int and the first argument would be automatically converted to type double by Cplus_plus if needed, so it would use the function corresponding to the function declaration with the first argument of type double and the second argument of type int (that , the second function declaration).
The second argument  of type double and the first argument would be automatically converted to type double by Cplus_plus if needed, so it would use the function corresponding to the function declaration with two arguments of type double (that , the first function declaration).
This cannot be done (at least not in any nice way).
The natural ways to represent a square and a round pizza are the same.
Each  naturally represented as one , which  the diameter for a round pizza and the length of a side for a square pizza.
In either case the function unitprice would need to have one formal parameter of type double for the price and one formal parameter of type int for the size (either radius or side).
Thus, the two function declarations would have the same  and types of formal parameters.
You can still defeat this evil pizza parlor's strategy by defining two functions, but they will need to have different names.
The definition of unitprice does not do any input or output and so does not use the library iostream.
In main we needed the using directive because cin and  are defined in iostream and those definitions place cin and  in the std namespace.
Practice Programs Practice Programs can generally be solved with a short program that directly applies the programming principles presented in this chapter.
A liter  0_0_264179 gallons.
Write a program that will read in the of liters of gasoline consumed by the user's car and the  of miles traveled by the car and will then output the  of miles per gallon the car delivered.
Your program should allow the user to repeat this calculation as often as the user wishes.
Define a function to compute the  of miles per gallon.
Your program should use a globally defined constant for the  of liters per gallon.
Modify your program from Practice Program 1 so that it will take input data for two cars and output the  of miles per gallon delivered by each car.
Your program will also announce which car has the best fuel efficiency (highest  of miles per gallon).
The price of stocks  sometimes given to the nearest eighth of a dollar; for example, 297/8 or 891/2.
Write a program that computes the value of the user's holding of one stock.
The program asks for the  of shares of stock owned, the whole-dollar portion of the price, and the fraction portion.
The fraction portion  to be input as two int values, one for the numerator and one for the denominator.
The program then outputs the value of the user's holdings.
Your program should allow the user to repeat this calculation as often as the user wishes and will include a function definition that has three int arguments consisting of the whole-dollar portion of the price and the two integers that make up the fraction part.
The function returns the price of one share of stock as a single  of type double.
It estimates the inflation rate as the difference in price divided by the year-ago price.
Your program should allow the user to repeat this calculation as often as the user wishes.
Define a function to compute the rate of inflation.
The inflation rate should be a value of type double giving the rate as a percent, for example 5_0_3 for 5_0_3 percent.
Chapter 4 / Procedural Abstraction and Functions That Return a Value 5.
Enhance your program from the previous Practice Program by having it also print out the estimated price of the item in one and in two years from the time of the calculation.
The increase in cost over one year estimated as the inflation rate times the price at the start of the year.
Define a second function to determine the estimated cost of an item in one year, given the current price of the item and the inflation rate as arguments.
Write a function declaration for a function that computes interest on a credit card account balance.
The function takes arguments for the initial balance, the monthly interest rate, and the number of months for which interest must be paid.
The value returned  the interest due.
Do not forget to compound the interest—that , to charge interest on the interest due.
The interest due added into the balance due, and the interest for the next month  computed using this larger balance.
Use a while loop that  similar to (but need not be identical to) the one shown in Display 2_0_14.
Embed the function in a program that reads the values for the interest rate, initial account balance, and number of months, then outputs the interest due.
Embed your function definition in a program that lets the user compute interest due on a credit account balance.
The program should allow the user to repeat the calculation until the user says he or she wants to end the program.
VideoNote Solution to Practice Program 4_0_7 7.
The gravitational attractive force between two bodies with masses m1 and m2 separated by a distance d  given by: = Gm1m2 d2 where  is the universal gravitational constant: = 6_0_673 × 10−8 � cm 3 g × sec2 � Write a function definition that takes arguments for the masses of two bodies and the distance between them and that returns the gravitational force.
Since you will use the preceding formula, the gravitational force will be in dynes.
One dyne equals �g sec× cm� 2 You should use a globally defined constant for the universal gravitational constant.
Embed your function definition in a complete program that computes the gravitational force between two objects given suitable inputs.
Your program should allow the user to repeat this calculation as often as the user wishes.
That we are "blessed" with several absolute value functions is an accident of history.
C libraries were already available when Cplus_plus arrived; they could be easily used, so they were not rewritten using function overloading.
You are to find all the absolute value functions you can and rewrite all of them Programming Projects overloading the abs function name.
At a minimum, you should have the int, long, float, and double types represented.
Write an overloaded function max that takes either two or three parameters of type double and returns the largest of them.
Programming Projects Programming Projects require more problem-solving than Practice Programs and can usually be solved many different ways.
Visit www_0_myprogramminglab_0_com to complete many of these Programming Projects online and get instant feedback.
Write a program that computes the annual after-tax cost of a new  for the first year of ownership.
The cost is computed as the annual mortgage cost minus the tax savings.
The input should be the price of the and the down payment.
The annual mortgage cost can be estimated as 3 percent of the initial loan balance credited toward paying off the loan principal plus 6 percent of the initial loan balance in interest.
The initial loan balance is the price minus the down payment.
Assume a 35 percent marginal tax rate and assume that interest payments are tax deductible.
So, the tax savings is 35 percent of the interest payment.
Your program should use at least two function definitions and should allow the user to repeat this calculation as often as the user wishes.
Write a program that asks for the user's height, weight, and age, and then computes clothing sizes according to the formulas: ■  Hat = weight in pounds divided by height in  and all that multiplied by 2_0_9.
So, there is no ■  Waist in  = weight divided by 5_0_7 and then adjusted by adding 1/10 of an inch for each 2 years over age 28.
So, there is no adjustment for age 29, Use functions for each calculation.
Your program should allow the user to repeat this calculation as often as the user wishes.
Modify your program from Programming Project 2 so that it also calculates the user's jacket and waist sizes after 10 years.
Write a program that outputs the lyrics for the song "Ninety-Nine Bottles of Beer on the Wall_0_" Your program should print the number of bottles in English, not as a number.
Chapter 4 / Procedural Abstraction and Functions That Return a Value Ninety-nine bottles of beer on the wall, Ninety-nine bottles of beer, Take one down, pass it around, Ninety-eight bottles of beer on the wall.
Zero bottles of beer on the wall.
Design your program with a function that takes as an argument an integer between 0 and 99 and returns a string that contains the integer value in English.
Your function should not have 100 different if-else statements.
Instead, use % and / to extract the tens and ones digits to construct the ­English string.
You may need to test specifically for values such as 0, 10–19, etc.
To maintain one's body weight, an adult human needs to consume enough calories daily to (1) meet the basal metabolic rate (energy  to breathe, maintain body temperature, etc_0_), (2) account for physical activity such as exercise, and (3) account for the energy  to digest the food that is being eaten.
For an adult that weighs P pounds, we can estimate these caloric requirements using the following formulas: A.
Basal metabolic rate:   = 70 * (P / 2_0_2)0_0_756 B.
Physical activity:   = 0_0_0385 * Intensity * P * Minutes Here, Minutes is the number of minutes spent during the physical activity, and Intensity is a number that estimates the intensity of the activity.
Here are some sample numbers for the range of values: Activity Intensity.
Energy to digest food: calories  = TotalCaloriesConsumed * 0_0_1 In other words, 10 percent of the calories we consume goes towards digestion.
Write a function that computes the calories  for the basal metabolic rate, taking as input a parameter for the person's weight.
Write another ­function that computes the calories  for physical activity, taking as input parameters for the intensity, weight, and minutes spent exercising.
Programming Projects Use these functions in a program that inputs a person's weight, an estimate for the intensity of physical activity, the number of minutes spent performing the physical activity, and the number of calories in one serving of your favorite food.
The program should then calculate and output how many servings of that food should be eaten per day to maintain the person's current weight at the specified activity level.
The computation should include the energy that is  to digest food.
You can find estimates of the caloric content of many foods on the Web.
For example, a double cheeseburger has approximately 1000 calories.
You have invented a vending machine capable of deep frying twinkies.
Write a program to simulate the vending machine.
It costs $3_0_50 to buy a deep-fried twinkie, and the machine only takes coins in denominations of a dollar, quarter, dime, or nickel.
Write code to simulate a person putting money into the vending machine by repeatedly prompting the user for the next coin to be inserted.
Output the total entered so far when each coin is inserted.
When $3_0_50 or more is added, the program should output "Enjoy your deep-fried twinkie" along with any change that should be returned.
Use top-down design to determine appropriate functions for the program.
Your time machine is capable of going forward in time up to 24 hours.
The machine is configured to jump ahead in minutes.
To enter the proper number of  into your machine, you would like a program that can and calculate the difference in  between the start and future time.
A time is specified in your program with three variables: int , ; bool ;.
Write a program that allows the user to enter a start time and a future time.
Include a function named computeDifference that takes the six variables as parameters that represent the start time and future time.
Your function should return, as an int, the time difference in.
For example, given a start time of 11:59 AM and a future time of 12:01 PM, your program should compute 2  as the time difference.
Given a start time of 11:59 AM and a future time of 11:58 AM, your program should compute 1439  as the time difference (23  and 59 ).
Chapter 4 / Procedural Abstraction and Functions That Return a Value You may need "AM" or "PM" from the user's input by reading in two character values.
For example, if the variable  is of type char, then ( == 'A') is a Boolean expression that evaluates to true if  contains the letter A.
VideoNote Solution to Programming Project 4_0_8 8.
Do Programming Project 11 from Chapter 3 except write a function named containsDigit that determines if a number contains a particular digit.
The header should look like: bool containsDigit(int number, int digit); If number contains digit, then the function should return true.
Otherwise, the function should return false.
Your program should use this function to find the closest numbers that can be entered on the keypad.
Your sports league uses the following lottery system to select draft picks for the four worst teams in the league: ■  The.
To determine the first pick in the draft a ball is selected at random.
The team owning that ball gets the first pick.
The ball is then put back in the urn.
To determine the second pick in the draft a ball is selected at random.
If the ball belongs to the team that got the first pick then it is put back in and the process repeats until a ball is selected that does not belong to the first pick.
To determine subsequent picks in the draft the process repeats until a ball is selected that belongs to a team that has not already been chosen.
Write a function that takes as input which of the four teams have already been granted picks, simulates selecting a ball from the urn according to the lottery rules, and returns the team that belongs to the selected ball.
You get to choose how to design your function to perform these actions.
Write a main function that outputs the draft order (e_0_g_0_, a possible order is: secondto-last picks 1, last place picks 2, third-to-last picks 3, and fourth-to-last picks 4).
If you change the random seed then the order should differ if you run the program multiple times.
For a slightly harder version of the problem, allow the user to input the names of the four teams.
The program should then output the team names in the draft order.
Functions for All Subtasks 5_0_1 void Functions   252 Definitions of void Functions   252 Programming Example: Converting Temperatures   255 return Statements in void Functions   255 5_0_2 Call-By-Reference Parameters   259 A First View of Call-by-Reference   259 Call-by-Reference in Detail   262 Programming Example: The swap_values Function   267 Mixed Parameter Lists   268 Programming Tip: What Kind of Parameter to Use   269 Pitfall: Inadvertent Local Variables   270 Chapter Summary   292 Answers to Self-Test Exercises   293 5 5_0_3 Using Procedural Abstraction   273 Functions Calling Functions   273 Preconditions and Postconditions   275 Case Study: Supermarket Pricing   276 5_0_4 Testing and Debugging Functions   281 Stubs and Drivers   282 5_0_5 General Debugging TeCHniques   287 Keep an Open Mind   287 Check Common Errors   287 Localize the Error   288 The assert Macro   290 Practice Programs   296 Programming Projects   299 Everything is possible.
COMMON MAXIM Introduction The top-down design strategy discussed in Chapter 4 is an effective way to design an algorithm for a program.
You divide the program's task into subtasks and then implement the algorithms for these subtasks as functions.
Thus far, we have seen how to define functions that start with the values of some arguments and return a single value as the result of the function call.
A subtask that computes a single value is a very important kind of subtask, but it is not the only kind.
In this chapter we will complete our description of Cplus_plus functions and present techniques for designing functions that perform other kinds of subtasks.
Prerequisites You should read Chapters 2 through 4 before reading this chapter.
The functions discussed in Chapter 4 always return a single value, but there are other forms of subtasks.
A subtask might produce several values or it might produce no values at all.
In Cplus_plus, a function must either return a single value or return no values at all.
As we will see later in this chapter, a subtask that produces several different values is usually (and perhaps paradoxically) implemented as a function that returns no value.
For the moment, however, let us avoid that complication and focus on subtasks that intuitively produce no values at all, and let us see how these subtasks are implemented.
A function that returns no value is called a void function.
For example, one typical subtask for a program is to output the results of some calculation.
This subtask produces output on the screen, but it produces no values for the rest of the program to use.
This kind of subtask would be implemented as a void function.
Definitions of void Functions In Cplus_plus a void function is defined in almost the same way as a function that returns a value.
For example, the following is a void function that outputs the result of a calculation that converts a temperature expressed in Fahrenheit 252 5_0_1 void Functions degrees to a temperature expressed in Celsius degrees.
The actual calculation would be done elsewhere in the program.
This void function implements only the subtask for outputting the results of the calculation.
For now, we do not need to worry about how the calculation will be performed.
As this function definition illustrates, there are only two differences between a function definition for a void function and the function definitions we discussed in Chapter 4.
One difference is that we use the keyword void where we would normally specify the type of the value to be returned.
This tells the compiler that this function will not return any value.
The name void is used as a way of saying "no value is returned by this function_0_" The second difference is that the return statement does not contain an expression for a value to be returned, because, after all, there is no value returned.
The syntax is summarized in Display 5_0_1.
A void function call is an executable statement.
For example, our function show_results might be called as follows: show_results(32_0_5, 0_0_3); If this statement were executed in a program, it would cause the following to appear on the screen: 32_0_5 degrees Fahrenheit is equivalent to 0_0_3 degrees Celsius.
Notice that the function call ends with a semicolon, which tells the compiler that the function call is an executable statement.
When a void function is called, the arguments are substituted for the formal parameters and the statements in the function body are executed.
For example, a call to the void function show_results, which we gave earlier in this section, will cause some output to be written to the screen.
One way to think of a call to a void function is to imagine that the body of the function definition is copied into the program in place of the function call.
When the function is called, the arguments are substituted for the formal parameters, and then it is just as if the body of the function were lines in the program.
Function definition Function call.
Chapter 5 / Functions for All Subtasks Display 5_0_1   Syntax for a void Function Definition void Function Declaration void Function_Name(Parameter_List); Function_Declaration_Comment void Function Definition body.
Executable_Statement_Last { function header You may intermix the declarations with the executable statements include one or more return statements.
It is perfectly legal, and sometimes useful, to have a function with no arguments.
In that case, there simply are no formal parameters listed in the function declaration and no arguments are used when the function is called.
For example, the void function initialize_screen, defined next, simply sends a new  command to the screen:.
The next programming example shows these two sample void functions in a complete program.
A Fahrenheit temperature F can be converted to an equivalent Celsius temperature  as follows: The function celsius shown in Display 5_0_2 uses this formula to do the temperature conversion.
In the case of a function that returns a value, the return statement specifies the value returned.
In the case of a void function, the return statement simply ends the function call.
As we saw in the previous chapter, every function that returns a value must end by executing a return statement.
However, a void function need not contain a return statement.
If it does not contain a return statement, it will end after executing the code in the function body.
It is as if there were an implicit return statement just before the final closing brace } at the end of the function body.
For example, the functions initialize_screen and show_results in Display 5_0_2 would perform exactly the same if we omitted the return statements from their function definitions.
The fact that there is an implicit return statement before the final closing brace in a function body does not mean that you never need a return statement in a void function.
For example, the function definition in Display 5_0_3 might be used as part of a restaurant management program.
That function outputs instructions for dividing a given amount of ice cream among the people at a table.
If there are no people at the table (that is, if number equals 0), then the return statement within the if statement terminates the function call and avoids a division by zero.
If number is not 0, then the function call ends when the last  statement is executed at the end of the function body.
By now you may have guessed that the main part of a program is actually the definition of a function called main.
When the program is run, the function main is automatically called and it, in turn, may call other functions.
Although it may seem that the return statement in the main part of a program should be optional, officially it is not.
Technically, the main part of a program is a function that returns a value of type int, so it requires a return statement.
However, the function main is used as if it were a void function.
Treating the main part of your program as a function that returns an integer may sound void functions and return statements The main part of a program is a function 256 Chapter 5 / Functions for All Subtasks 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46.
Sample Dialogue I will convert a Fahrenheit temperature to Celsius.
Enter a temperature in Fahrenheit: 32_0_5 32_0_5 degrees Fahrenheit is equivalent to 0_0_3 degrees Celsius.
Display 5_0_3   Use of return in a void Function Function Declaration 1 2 3 4.
Function Definition 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15.
Chapter 5 / Functions for All Subtasks crazy, but that's the tradition.
It might be best to continue to think of the main part of the program as just "the main part of the program" and not worry about this minor detail_0_1 S el f -T est Exe rcis es.
Are you required to have a return statement in a void function definition.
Suppose you omitted the return statement in the function definition for initialize_screen in Display 5_0_2.
What effect would it have on the program.
Would the program compile.
Would the program behave any differently.
What about the return statement in the function The Cplus_plus Standard says that you can omit the return 0 in the main part, but many compilers still require it.
What effect would it have on the program if you omitted the return statement in the definition of show_results.
What about the return statement in the function definition for celsius in that same program.
What effect would it have on the program if you omitted the return statement in the definition of celsius.
Write a definition for a void function that has three arguments of type int and that outputs to the screen the product of these three arguments.
Put the definition in a complete program that reads in three numbers and then calls this function.
Does your compiler allow void main() and int main().
What warnings are issued if you have int main() and do not supply a return 0; statement.
To find out, write several small test programs and perhaps ask your instructor or a local guru.
Is a call to a void function used as a statement or is it used as an expression.
There are different mechanisms used for this substitution process.
The mechanism we used in Chapter 4, and thus far in this chapter, is known as the call-by-value mechanism.
The second main mechanism for substituting arguments is known as the call-by-reference mechanism.
A First View of Call-by-Reference The call-by-value mechanism that we used until now is not sufficient for certain subtasks.
For example, one common subtask is to obtain one or more input values from the user.
Look back at the program in Display 5_0_2.
Its tasks are divided into four subtasks: initialize the screen, obtain the Fahrenheit temperature, compute the corresponding Celsius temperature, and output the results.
Three of these four subtasks are implemented as the functions initialize_screen, celsius, and show_results.
However, the subtask of obtaining the input is implemented as the following four lines of code (rather than as a function call): << "Enter a temperature in Fahrenheit: "; cin >> f_temperature;.
Chapter 5 / Functions for All Subtasks A function for obtaining input should set the values of one or more variables to values typed in at the keyboard, so the function call should have one or more variables as arguments and should change the values of these argument variables.
With the call-by-value formal parameters that we have used until now, an argument in a function call can be a variable, but the function takes only the value of the variable and does not change the variable in any way.
With a callby-value formal parameter only the value of the argument is substituted for the formal parameter.
For an input function, we want the variable (not the value of the variable) to be substituted for the formal parameter.
The call-by-reference mechanism works in just this way.
With a call-by-reference formal parameter (also called simply a reference parameter), the corresponding argument in a function call must be a variable and this argument variable is substituted for the formal parameter.
It is as if the argument variable were literally copied into the body of the function definition in place of the formal parameter.
After the argument is substituted in, the code in the function body is executed and this code can change the value of the argument variable.
A call-by-reference parameter must be marked in some way so that the compiler will know it from a call-by-value parameter.
The way that you indicate a call-by-reference parameter is to attach the ampersand sign, &, to the end of the type name in the formal parameter list in both the function declaration and the header of the function definition.
For example, the following function definition has one formal parameter, f_variable, and that formal parameter is a call-by-reference parameter: { using namespace std;.
However, rather than rewrite an old , let's look at a completely new.
Display 5_0_4 demonstrates call-by-reference parameters.
It just reads in two numbers and writes the same numbers out, but in the reverse order.
The parameters in the functions get_numbers and swap_values are call-by-reference parameters.
The input is performed by the function call get_numbers(first_num, second_num); 5_0_2 Call-By-Reference Parameters Display 5_0_4   Call-by-Reference Parameters 1.
Enter two integers: 5 10 In reverse order the numbers are: 10 5 261.
Chapter 5 / Functions for All Subtasks The values of the variables  and  are set by this function call.
After that, the following function call reverses the values in the two variables  and : swap_values(, ); In the next few subsections we describe the call-by-reference mechanism in more detail and also explain the particular functions used in Display 5_0_4.
Call-by-Reference in Detail In most situations, the call-by-reference mechanism works as if the name of the  given as the function argument were literally substituted for the call-by-reference formal parameter.
However, the process is a bit more subtle than that.
In some situations, this subtlety is important, so we need to examine more details of this call-by-reference substitution process.
Recall that  variables are implemented as memory locations.
The compiler assigns one memory location to each.
For example, when the  in Display 5_0_4 is compiled, the   might be assigned location 1010, and the   might be assigned 1012.
For purposes of this example, consider these variables to be stored at these memory locations.
In other words, after executing the line int  = 0,  = 0; the value 0 will be stored at memory locations 1010 and 1012.
The arrows in the diagram below point to the memory locations referenced by the variables.
Memory Location Value … 1008 1010 0.
Next, consider the following function declaration from Display 5_0_4: void get_numbers(int& input1, int& input2);.
The call-by-reference formal parameters input1 and input2 are place holders.
The corresponding argument in a call to the function should then be a , not a constant or other expression.
When the function is called, the corresponding argument (not its value) will be substituted for the formal parameter.
Any change made to the formal parameter in the function body will be made to the argument  when the function is called.
The exact details of the substitution mechanisms are given in the text of this chapter.
Example (of call-by-reference parameters in a function declaration): void get_data(int& first_in, double& second_in);.
When the function call is executed, the function is not given values stored in  and.
Instead, it is given the memory locations associated with each name.
In this example, the locations are 1010 1012 which are the locations assigned to the argument variables  and , in that order.
It is these memory locations that are associated with the formal parameters.
The first memory location is associated with the first formal parameter, the second memory location is associated with the second formal parameter, and so forth.
In our example input1 is the first parameter, so it gets the same memory location as.
The second parameter is input2 and it gets the same memory location as.
Diagrammatically, the correspondence is Memory Location Value … 1008 input1.
Chapter 5 / Functions for All Subtasks When the function statements are executed, whatever the function body says to do to a formal parameter is actually done to the  in the memory location associated with that formal parameter.
In this case, the instructions in the body of the function get_numbers say that a value should be stored in the formal parameter input1 using a cin statement, and so that value is stored in the  in memory location 1010 (which happens to be where the variable  is stored).
Similarly, the instructions in the body of the function get_numbers say that a value should then be stored in the formal parameter input2 using a cin statement, and so that value is stored in the variable in memory location 1012 (which happens to be where the variable is stored).
Thus, whatever the function instructs the computer to do to input1 and input2 is actually done to the variables  and For example, if the user enters 5 and 10 as in Display 5_0_4, then the result is Memory Location Value … 1008 input1.
This means we can no longer retrieve the data values at 1010 and 1012 through the variables input1 and input2.
However, the data still exists in memory location 1010 and 1012 and is accessible through the variables first_num and second_num within the scope of the main function.
These details of how the call-by-reference mechanism works in this function call to get_numbers are described in Display 5_0_5.
It may seem that there is an extra level of detail, or at least an extra level of verbiage.
If first_num is the variable with memory location 1010, why do we insist on saying "the variable at memory location 1010" instead of simply saying "first_num".
This extra level of detail is needed if the arguments and formal parameters contain some confusing coincidence of names.
For example, the function get_numbers has formal parameters named input1 and input2.
Suppose you want to change the program in Display 5_0_4 so that it uses the function get_numbers with arguments that are also named input1 and input2, and suppose that you want to do something less than obvious.
Suppose you want the first number typed in to be stored in a variable named input2, and the second 5_0_2 Call-By-Reference Parameters 265 Anatomy of a Function Call from Display 5_0_4 Using Call-by-Reference Arguments 0 Assume the variables first_num and second_num have been assigned the following memory address by the compiler: first_num second_num 1010 1012 ( We do not know what addresses are assigned and the results will not depend on the actual 1 In the program in Display 5_0_4, the following function call begins executing:.
The effect is the same as if the function definition were rewritten to the following (which is not legal Cplus_plus code, but does have a clear meaning to us): void get_numbers( int& <the variable at memory location 1010>, {.
The effect is the same as if the following were T executed: 266.
Now, let's suppose that the variables input1 and input2, which are declared in the main part of your program, have been assigned memory locations 1014 and 1016.
The function call could be as follows: int input1, input 2; get_numbers(input2, input1);.
However, if the variable input1 declared in the main part of your program is assigned memory location 1014, the phrase "the variable at memory location 1014" is unambiguous.
Let's go over the details of the substitution mechanisms in this case.
In this call the argument corresponding to the formal parameter input1 is the variable input2, and the argument corresponding to the formal parameter input2 is the variable input1.
This can be confusing to us, but it produces no problem at all for the computer, since the computer never does The computer simply deals with memory locations.
The computer substitutes "the variable at memory location 1016" for the formal parameter input1, and "the variable at memory location 1014" for the formal parameter input2.
The swap_values Function The function swap_values defined in Display 5_0_4 interchanges the values stored in two variables.
The description of the function is given by the.
As shown in Display 5_0_4, the definition of the function swap_values uses a local  called temp.
This local  is needed.
You might be tempted to think the function definition could be simplified to the following:.
The value of  is set equal to the value of , just as it should be.
But then, the value of is set equal to the changed value of , which is now the original value of.
Thus the value of  is not changed at all.
This is what the local  temp in the correct function definition is used for.
That correct definition is the one in Display 5_0_4.
When that correct version is used and 267.
Chapter 5 / Functions for All Subtasks.
Parameters and Arguments All the different terms that have to do with parameters and arguments can be confusing.
However, if you keep a few simple points in mind, you will be able to easily handle these terms.
A formal parameter (of any sort) is a kind of blank or place holder that is filled in with something when the function is called.
When you write down a function call, the arguments are listed in parentheses after the function name.
When the function call is executed, the arguments are "plugged in" for the formal parameters.
In the call-by-value method, only the value of the argument is used.
In this call-by-value mechanism, the formal parameter is a local  that is initialized to the value of the corresponding argument.
In the call-by-reference mechanism, the argument is a  and the entire  is used.
In the call-by-reference mechanism, the argument  is substituted for the formal parameter so that any change that is made to the formal parameter is actually made to the argument.
Mixed Parameter Lists Mixing call-byreference and call-by-value Whether a formal parameter is a call-by-value parameter or a call-by-reference parameter is determined by whether there is an ampersand attached to its type specification.
If the ampersand is present, then the formal parameter is a callby-reference parameter.
If there is no ampersand associated with the formal parameter, then it is a call-by-value parameter.
It is perfectly legitimate to mix call-by-value and call-by-reference formal parameters in the same function.
For example, the first and last of the formal parameters in the following function declaration are call-by-reference formal parameters and the middle one is a call-by-value parameter: void good_stuff(int& par1, int par2, double& par3);.
You can also use them in functions that return a value.
Thus, a function with a call-by-reference parameter could both change the value of a  given as an argument and return a value.
The parameters par1_ value and par2_ref are both assigned a value inside the body of the function definition.
But since they are different kinds of parameters, the effect is different in the two cases.
When the function is called as follows do_stuff(n1, n2); the local  par1_value is initialized to the value of n1.
That is, the local par1_value is initialized to 1 and the  n1 is then ignored by the function.
As you can see from the sample dialogue, the formal parameter par1_value (which is a local ) is set to 111 in the function body and this value is output to the screen.
However, the value of the argument n1 is not changed.
As shown in the sample dialogue, n1 has retained its value of 1.
VideoNote Call by Reference and Call by Value 270 Chapter 5 / Functions for All Subtasks 22 23 24 25 26 27 28.
Sample Dialogue par1 in function  = 111 par2 in function  = 222 1 after function  = 1 2 after function  = 222 On the other hand, par2 is a -by-reference parameter.
When the function is called, the variable argument 2 (not just its value) is substituted for the formal parameter par2.
So that when the following code is executed: par2 = 222;.
Thus, the value of the variable 2 is changed when the function body is executed, so as the dialogue shows, the value of 2 is changed from 2 to 222 by the function.
If you keep in mind the lesson of Display 5_0_6, it is easy to decide which parameter mechanism to use.
If you want a function to change the value of a variable, then the corresponding formal parameter must be a -by-reference formal parameter and must be marked with the ampersand sign, &.
In all other cases, you can use a -by-value formal parameter.
If you carelessly omit the ampersand, the function will have a -by-value parameter where you meant to have a -by-reference parameter, and when the program is run, you will discover that the function  does not change the value of the corresponding argument.
This is because a formal -byvalue parameter is a local variable, so if it has its value changed in the function, then as with any local variable, that change has no effect outside of the function body.
This is a logic error that can be very difficult to see because it looks right.
As a result, the formal parameters variable1 and variable2 are local variables.
The argument variables first_num and second_num are never substituted in for variable1 and variable2; variable1 and variable2 are instead initialized to the values of first_num and second_num.
Then, the values of variable1 and variable2 are interchanged, but the values of first_num and second_num are left unchanged.
The omission of two ampersands has made the program completely wrong, yet it looks almost identical to the correct program and will compile and run without any error messages.
Chapter 5 / Functions for All Subtasks.
What would be the output of the program in Display 5_0_4 if you omit the ampersands, &, from the first parameter in the function declaration and function heading of swap_values.
The ampersand is not removed from the second parameter.
What would be the output of the program in Display 5_0_6 if you change the function declaration for the function do_stuff to the following and you change the function header to match, so that the formal parameter par2 is changed to  -by-value parameter: void do_stuff(int par1, int par2); 10.
Write  void function definition for  function called zero_both that has two reference parameters, both of which are variables of type int, and sets the values of both variables to 0.
Write  void function definition for  function called add_tax.
The function add_tax has two formal parameters: tax_rate, which is the amount of sales tax expressed as  percentage, and cost, which is the cost of an item before tax.
The function changes the value of cost so that it includes sales tax.
Can  function that returns  value have  -by-reference parameter.
May  function have both -by-value and -by-reference parameters.
MIGUEL DE CERVANTES SAAVEDRA, Don Quixote Recall that the principle of procedural abstraction says that functions should be designed so that they can be used as black boxes.
For  programmer to use function effectively, all the programmer should need to know is the function declaration and the accompanying comment that says what the function accomplishes.
The programmer should not need to know any of the details contained in the function body.
In this section we discuss  number of topics that deal with this principle in more detail.
Functions Calling Functions A function body may contain  call to another function.
The situation for these sorts of function calls is exactly the same as it would be if the function call had occurred in the main function of the program; the only restriction is that the function declaration should appear before the function is used.
If you set up your programs as we have been doing, this will happen automatically, since all function declarations come before the main function and all function definitions come after the main function.
Although you may function call within the definition of another function, you cannot place the ­definition of one function within the body of another function definition.
Display 5_0_8 shows an enhanced version of the program shown in Display 5_0_4.
The program in Display 5_0_4 always reversed the values of the variables and second_num.
The program in Display 5_0_8 reverses these variables only some of the time.
The program in Display 5_0_8 uses the function order to reorder the values in these variables so as to ensure that <= second_num If this condition is already true, then nothing is done to the variables and second_num.
If, however,  is greater than second_ num, then the function swap_values is called to interchange the values of these two variables.
This testing for order and exchanging of values all takes place within the body of the function order.
Thus, the function swap_values is called within the body of the function order.
This presents no special problems.
Using the principle of procedural abstraction, we think of the function swap_values as performing an action (namely, interchanging the values of two variables); this action is the same no matter where it occurs.
Chapter 5 / Functions for All Subtasks 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17.
Enter two integers: 10 5 In increasing order the numbers are: 5 10 Preconditions and Postconditions One good way to write a function declaration comment is to break it down into two kinds of information, called a precondition and a postcondition.
The precondition states what is assumed to be true when the function is called.
The function should not be used and cannot be expected to perform correctly unless the precondition holds.
The postcondition describes the effect of the function call; that is, the postcondition tells what will be true after the function is executed in a situation in which the precondition holds.
For a function that returns a value, the postcondition will describe the value returned by the function.
For a function that changes the value of some argument variables, the postcondition will describe all the changes made to the values of the arguments.
For example, the function declaration comment for the function swap_ values shown in Display 5_0_8 can be put into this format as follows:.
When the only postcondition is a description of the value returned, programmers often omit the word postcondition.
A common and acceptable alternative form for the previous function declaration comments is the following: //Precondition: fahrenheit is a temperature expressed //in degrees Fahrenheit.
Another example of preconditions and postconditions is given by the.
You do not need to know the definition of the function post_interest in order to use this function, so we have given only the function declaration and accompanying comment.
Preconditions and postconditions are more than a way to summarize a function's actions.
They should be the first step in designing and writing a function.
When you design a program, you should specify what each function does before you start designing how the function will do it.
In particular, the function declaration comments and the function declaration should be designed and written down before starting to design the function body.
If you later discover that your specification cannot be realized in a reasonable way, you may need to back up and rethink what the function should do, but by clearly specifying what you think the function should do, you will minimize both design errors and wasted time writing code that does not fit the task at hand.
Some programmers prefer not to use the words precondition and postcondition in their function comments.
However, whether you use the words or not, your function comment should always contain the precondition and postcondition information.
Case Study Supermarket Pricing This case study solves a very simple programming task.
It may seem that it contains more detail than is needed for such a simple task.
However, if you see the design elements in the context of a simple task, you can concentrate on learning them without the distraction of any side issues.
Once you learn the 5_0_3 Using Procedural Abstraction techniques that are illustrated in this simple case study, you can apply these same techniques to much more complicated programming tasks.
Problem Definition We have been commissioned by the Quick-Shop supermarket chain to write a program that will determine the retail price of an item given suitable input.
Their pricing policy is that any item that is expected to sell in one week or less is marked up 5 percent, and any item that is expected to stay on the shelf for more than one week is marked up 10 percent over the wholesale price.
Be sure to notice that the low markup of 5 percent is used for up to 7 days and that at 8 days the markup changes to 10 percent.
It is important to be precise about exactly when a program should change from one form of calculation to a different one.
As always, we should be sure we have a clear statement of the input required and the  produced by the program.
Input The input will consist of the wholesale price of an item and the expected number of days until the item is sold.
Output The  will give the retail price of the item.
Analysis of the Problem Like many simple programming tasks, this one breaks down into three main subtasks: 1.
Input the data.
Compute the retail price of the item.
Output the results.
These three subtasks will be implemented by three functions.
The three functions are described by their function declarations and accompanying comments, which are given below.
Note that only those items that are changed by the functions are call-by-reference parameters.
The remaining formal parameters are call-by-value parameters.
The value of turnover has been //set to the expected number of days until the item is sold.
Even though we have not yet written the function bodies and have no idea of how the functions work, we can write the above code that uses the functions.
That is what is meant by the principle of procedural abstraction.
The functions are treated like black boxes.
Algorithm Design The implementations of the functions get_input and give_output are straightforward.
They simply consist of a few cin and cout statements.
The algorithm for the function price is given by the following pseudocode: if turnover ≤ 7 days then return (cost +5% of cost); else.
Coding There are three constants used in this program: a low markup figure of 5 percent, a high markup figure of 10 percent, and an expected shelf stay of 7 days as the threshold above which the high markup is used.
Since these constants might need to be changed to update the program should the company decide to change its pricing policy, we declare global named constants at the start of our program for each of these three numbers.
The declarations with the const modifier are the following:.
The complete program is shown in Display 5_0_9.
The value of  has been //set to the expected number of days until the item is sold.
Chapter 5 / Functions for All Subtasks 36 37 38 39 40 { 41 42 43 44 45 46 47 48 49.
Sample Dialogue This program determines the retail  for an item at a Quick-Shop supermarket store.
Enter the wholesale  of item: $1_0_21 Enter the expected number of days until : 5 = $1_0_21 Expected time until  = 5 days = $1_0_27 5_0_4 Testing and Debugging Functions.
Program Testing An important technique in testing a program is to test all kinds of input.
There is no precise definition of what we mean by a "kind" of input, but in practice, it is often easy to decide what kinds of input data a program deals with.
In the case of our supermarket program, there are two main kinds of input: input that uses the low markup of 5 percent and input that uses the high markup of 10 percent.
Thus, we should test at least one case in which the item is expected to remain on the shelf for less than 7 days and at least one case in which the item is expected to remain on the shelf for more than 7 days.
Another testing strategy is to test boundary values.
Unfortunately, boundary value is another vague concept.
An input (test) value is a boundary value if it is a value at which the program changes behavior.
For example, in our supermarket program, the program's behavior changes at an expected shelf stay of 7 days.
Thus, 7 is a boundary value; the program behaves differently for a number of days that is less than or equal to 7 than it does for a number of days that is greater than 7.
Hence, we should test the program on at least one case in which the item is expected to remain on the shelf for exactly 7 days.
Normally, you should also test input that is one step away from the boundary value as well, since you can easily be off by one in deciding where the boundary is.
Hence, we should test our program on input for an item that is expected to remain on the shelf for 6 days, an item that is expected to remain on the shelf for 7 days, and an item that is expected to remain on the shelf for 8 days.
Can a function definition appear inside the body of another function definition.
Can a function definition contain a call to another function.
Rewrite the function declaration comment for the function order shown in Display 5_0_8 so that it is expressed in terms of preconditions and postconditions.
Give a precondition and a postcondition for the predefined function sqrt, which returns the square root of its argument.
This is the essence of the top-down design strategy.
When you treat each function as a separate unit, you transform one big task into a series of smaller, more manageable tasks.
But how do you test a function outside of the program for which it is intended.
You write a special program to do the testing.
For example, Display 5_0_10 shows a program to test the function get_input, which was used in the program in Display 5_0_9.
The value of turnover has been //set to the expected number of days until the item is sold.
Sample Dialogue Enter the wholesale cost of item: $123_0_45 Enter the expected number of days until sold: 67 Wholesale cost is now $123_0_45 Days until sold is now 67 Test again.
These driver programs are temporary tools and can be quite minimal.
They need not have fancy input routines.
They need not perform all the calculations the final program will perform.
All they need do is obtain reasonable values for the function arguments in as simple a way as possible—typically from the user—then execute the function and show the result.
A loop, as in the program shown in Display 5_0_10, will allow you to retest the function on different arguments without having to rerun the program.
If you test each function separately, you will find most of the mistakes in your program.
Moreover, you will find out which functions contain the mistakes.
If you were to test only the entire program, you would probably find out if there were a mistake but may have no idea where the mistake is.
Even worse, you may think you know where the mistake is but be wrong.
Once you have fully tested a function, you can use it in the driver program for some other function.
Each function should be tested in a program in which it is the only untested function.
However, it's fine to use a fully tested function when testing some other function.
If a bug is found, you know the bug is in the untested function.
For example, after fully testing the function get_input with the driver program in Display 5_0_10, you can use get_input as the input routine in driver programs to test the remaining functions.
Chapter 5 / Functions for All Subtasks It is sometimes impossible or inconvenient to test a function without using some other function that has not yet been written or has not yet been tested.
In this case, you can use a simplified version of the missing or untested function.
These simplified functions are called stubs.
These stubs will not necessarily perform the correct calculation, but they will deliver values that suffice for testing, and they are simple enough that you can have confidence in their performance.
For example, the program in Display 5_0_11 is designed to test the function give_output from Display 5_0_9 as well as the basic layout of the program.
This program uses the function get_input, which we already 1 2 3.
The value of turnover has been //set to the expected number of days until the item is sold.
Enter the wholesale  of item: $1_0_21 Enter the expected number of days until : 5 = $1_0_21 Expected time until  = 5 days = $9_0_99 285.
Chapter 5 / Functions for All Subtasks fully tested using the driver program shown in Display 5_0_10.
This program also includes the function initialize_screen, which we assume has been tested in a driver program of its own, even though we have not bothered to show that simple driver program.
Since we have not yet tested the function , we have used a stub to stand in for it.
Notice that we could use this program before we have even written the function.
This way we can test the basic program layout before we fill in the details of all the function definitions.
Using a program outline with stubs allows you to test and then "flesh out" the basic program outline, rather than write a completely new program to test each function.
For this reason, a program outline with stubs is usually the most efficient method of testing.
A common approach is to use driver programs to test some basic functions, like the input and output functions, and then use a program with stubs to test the remaining functions.
The stubs are replaced by functions one at a time: One stub is replaced by a complete function and tested; once that function is fully tested, another stub is replaced by a full function definition, and so forth until the final program is produced.
The Fundamental Rule for Testing Functions Every function should be tested in a program in which every other function in that program has already been fully tested and debugged.
S el f -T est Exe rcis es 17.
What is the fundamental rule for testing functions.
Why is this a good way to test functions.
What is a driver program.
Write a driver program for the function introduction shown in Display 5_0_11.
Write a driver program for the function add_tax from Self-Test Exercise 11.
Write a stub for the function whose function declaration is given next.
Do not write a whole program, only the stub that would go in a program.
However, examination of the code and the output of test cases may be insufficient to track down many logic errors.
In this case, there are a number of general debugging techniques that you may employ.
Keep an Open Mind Examine the system as a whole and don't assume that the bug occurs in one particular place.
If the program is giving incorrect output values, then you should examine the source code, different test cases for the input and output values, and the logic behind the algorithm itself.
For example, consider the code to determine  for the supermarket example in Display 5_0_9.
If the wrong  is displayed, the error might simply be that the input values were different from those you were expecting in the test case, leading to an apparently incorrect program.
Some novice programmers will "randomly" change portions of the code hoping that it will fix the error.
Avoid this technique at all costs.
Sometimes this approach will work for the first few simple programs that you write.
However, it will almost certainly fail for larger programs and will often introduce new errors to the program.
Make sure that you understand what logical impact a change to the code will make before committing the modification.
Finally, if allowed by your instructor, you could show the program to someone else.
A fresh set  eyes can sometimes quickly pinpoint an error that you have been missing.
Taking a break and returning to the problem a few hours later or the next day can also sometimes help in discovering an error.
Check Common Errors One  the first mistakes you should look for are common errors that are easy to make, as described throughout the textbook in the Pitfall and Programming Tip sections.
Examples  sources for common errors include (1) uninitialized variables, (2) off-by-one errors, (3) exceeding a data boundary, (4) automatic type conversion, and (5)  = instead  ==.
VideoNote Debugging 287.
Chapter 5 / Functions for All Subtasks Localize the Error Determining the precise cause and location  a bug is one  the first steps to fixing the error.
Examining the input and output behavior for different test cases is one way to localize the error.
A related technique is to add cout statements to strategic locations in the program that print out the values for critical variables.
The cout statements also serve to show what code the program is executing.
This is the strategy  tracing variables that was described in Chapter 3 for loops, but it can be used even when there are no loops present in the code.
For example, consider the code in Display 5_0_12 that is intended to convert a temperature from Fahrenheit to Celsius  the formula C5 9 When this program is executed with an input  100 degrees Fahrenheit, the output is "Temperature in Celsius is 0".
This is obviously incorrect, as the correct answer is 37_0_8 degrees Celsius.
To track down the error we can print out the value  critical variables.
In this case, something appears to be wrong with the conversion formula, so and in the second step we compute (5 / 9) and then output both values.
This Display 5_0_12   Temperature Conversion Program with a Bug 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15.
Sample Dialogue Enter temperature in.
We have also commented out the original line code by placing // at the beginning  the line.
This tells the compiler to ignore the original line  code but still leave it in the program for our reference.
If we ever wish to restore the code, we simply remove the // instead having to type the line in again if it was deleted.
By examining the result  the  statements we have now identified the precise location  the bug.
In this case, the conversion factor  not computed correctly.
Since we are setting the conversion factor to 5 / 9, Display 5_0_13   Debugging with  Statements 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27.
Sample Dialogue Enter temperature in.
The simple fix  to perform floating-point division instead of integer division by changing one of the operands to a floating-point type, for example: double  = 5_0_0 / 9; Once the bug has been identified we can now remove or comment out.
However, it can sometimes be tedious to add a large number of  statements to a program.
Moreover, the output of the  statements may be long or difficult to interpret, and the introduction of debugging code might even introduce new.
Many compilers and integrated developing environments a separate program, a debugger, that allows the programmer to stop execution of the program at a specific line of code called a breakpoint and step through the execution of the code one line at a time.
As the debugger steps through the code, the programmer can inspect the contents of variables and even manually change the values stored in those variables.
No  statements are necessary to view the values of critical variables.
The interface, commands, and capabilities of debuggers vary among Cplus_plus compilers, so check your user manual or check with your instructor for help on how to use these features.
The assert Macro In Section 5_0_3 we discussed the concept of preconditions and postconditions for subroutines.
The assert macro  a tool to ensure that the expected conditions are true at the location of the assert statement.
If the condition not met, then the program will display an error message and abort.
To use assert, first  the definition of assert in your program with the following  statement: # <cassert> To use assert, add the following line of code at the location where you.
As an example, consider a subroutine that uses Newton's method to calculate the square root of a number n: 5_0_5 General Debugging Techniques.
A subroutine that implements this algorithm requires that n be a positive number and that the number of iterations we will repeat the calculation  also a positive number.
We can guarantee this condition by adding assert to the subroutine as shown below: // Approximates the square root of n using Newton's // Iteration.
If we try to execute this subroutine with any negative parameters, then the program will abort and display the assertion that failed.
The assert statement can be used in a similar manner for any assertion that you would like to enforce and  an excellent technique for defensive programming.
If you are going to distribute your program, you might not want the executable program to  the assert statements, since users could then get error messages that they might not understand.
If you have added many assert statements to your code, it can be tedious to remove them all.
Fortunately, you can disable all assert macros by adding the following line to the beginning of your program, before the  statement for <cassert> as follows: #define NDEBUG # <cassert> If you later change your program and need to debug it again, you can turn.
Chapter 5 / Functions for All Subtasks S el f -T est Exe rcis es 23.
If computing the statement:  = ( * y / z); how can you use the assert macro to avoid division by zero.
What general techniques can you use to determine the source of an error.
Chapter Summary ■ All subtasks in a program can be implemented as functions, either as functions that return a value or as void functions.
There are two methods of performing this substitution, call-by-value and call-by-reference.
In the call-by-reference substitution mechanism, the argument should be a variable and the entire variable  substituted for the corresponding argument.
An argument corresponding to a call-by-reference parameter can be changed by a function call.
If you want a function to change the value of a variable, then you must use a call-by-reference parameter.
The precondition states what is assumed to be true when the function is called.
The postcondition describes the effect of the function call; that is, the postcondition tells what will be true after the function is executed in a situation in which the precondition holds.
A stub is used in place of a function definition that has not yet been tested (or possibly not even written) so that the rest of the program can be tested.
Answers to Self-Test Exercises Answe rs to Self-T est Exer cises 1.
Hello Goodbye One more time: Hello End of program.
No, a void function definition need not contain a return statement.
A void function definition may contain a return statement, but one is not required.
Omitting the return statement in the function definition for initialize_screen in Display 5_0_2 would have absolutely no effect on how the program behaves.
The program will compile, run, and behave exactly the same.
Similarly, omitting the return statement in the function definition for show_results also will have no effect on how the program behaves.
However, if you omit the return statement in the function definition for celsius, that will be a serious error that will keep the program from running.
The difference is that the functions initialize_screen and show_results are void functions, but celsius is not a void function.
A call to a void function followed by a semicolon  a statement.
A call to a function that returns a value  an expression.
Enter two integers: 5 10 In reverse order the numbers are: 5 5 different 9_0_		par1_value in function  = 111 par2_ref in function  = 222 1 after function  = 1 2 after function  = 2.
The division by 100  to convert a percent to a fraction.
Yes, a function that returns a value can have a -by-reference parameter.
Yes, a function can have a combination of -by-value and -by-reference parameters.
No, a function definition cannot appear inside the body of another function definition.
Yes, a function definition can contain a  to another function.
Answers to Self-Test Exercises 17.
The fundamental rule for testing functions  that every function should be tested in a program in which every other function in that program has already been fully tested and debugged.
This  a good way to test a function because if you follow this rule, then when you find a bug, you will know which function contains the bug.
A driver program  a program written for the sole purpose of testing a function.
A debugger  a tool that allows the programmer to set breakpoints, step through the code line by line, and inspect or modify the value of variables.
Keeping an open mind, adding  statements to narrow down the cause of the error, using a debugger, searching for common errors, and devising a variety of tests are a few techniques that you can use to debug a program.
Practice Programs Practice Programs can generally be solved with a short program that directly applies the programming principles presented in this chapter.
Write a function that computes the average and standard deviation of four scores.
The standard deviation  defined to be the square root of the average of the four values: (si – a)2, where a  average of the four scores s1, s2, s3, and s4.
The function will have six parameters and will  two other Practice Programs functions.
Embed the function in a driver program that allows you to test the function again and again until you tell the program you are finished.
Write a program that reads in a length in feet and inches and outputs the equivalent length in meters and centimeters.
Use at least three functions: one for , one or more for calculating, and one for output.
Include a loop that lets the user repeat this computation for new  values until the user says he or she wants to end the program.
There are 0_0_3048 meters in a foot, 100 centimeters in a meter, and 12 inches in a foot.
Write a program like that of the previous exercise that converts from meters and centimeters into feet and inches.
Use functions for the subtasks.
The program asks the user if he or she wants to convert from feet and inches to meters and centimeters or from meters and centimeters to feet and inches.
The program then performs the desired conversion.
Have the user respond by typing the integer 1 for one type of conversion and 2 for the other conversion.
The program reads the user's answer and then executes an if-else statement.
Each branch of the if-else statement will be a function.
The two functions called in the if-else statement will have function definitions that are very similar to the programs for the previous two Practice Programs.
Thus, they will be function definitions that  other functions in their function bodies.
Include a loop that lets the user repeat this computation for new  values until the user says he or she wants to end the program.
Write a program that reads in a weight in pounds and ounces and outputs the equivalent weight in kilograms and grams.
Use at least three functions: one for , one or more for calculating, and one for output.
Include a loop that lets the user repeat this computation for new values until the user says he or she wants to end the program.
There are 2_0_2046 pounds in a kilogram, 1000 grams in a kilogram, and 16 ounces in a pound.
Write a program like that of the previous exercise that converts from kilograms and grams into pounds and ounces.
Use functions for the subtasks.
The program asks the user if he or she wants to convert from pounds and ounces to kilograms and grams or from kilograms and grams to pounds and ounces.
The program then performs the desired conversion.
Have the user respond by typing the integer 1 for one type of conversion and 2 for the other.
The program reads the user's answer and then executes an if-else statement.
Each branch of the if-else statement VideoNote Solution to Practice Program 5_0_5 297.
Chapter 5 / Functions for All Subtasks will be a function.
The two functions called in the if-else statement will have function definitions that are very similar to the programs for the previous two Practice Programs.
Thus, they will be function definitions that other functions in their function bodies.
Include a loop that lets the user repeat this computation for new  values until the user says he or she wants to end the program.
Write a program that combines the functions of Practice Programs 4 and 7.
The program asks the user if he or she wants to convert lengths or weights.
If the user chooses lengths, then the program asks the user if he or she wants to convert from feet and inches to meters and centimeters or from meters and centimeters to feet and inches.
If the user chooses weights, a similar question about pounds, ounces, kilograms, and grams asked.
The program then performs the desired conversion.
Have the user respond by typing the integer 1 for one type of conversion and 2 for the other.
The program reads the user's answer and then executes an if-else statement.
Each branch of the if-else statement will be a function call.
The two functions called in the if-else statement will have function definitions that are very similar to the programs for Practice Programs 4 and 7.
Thus, these functions will be function definitions that call other functions in their function bodies; however, they will be very easy to write by adapting the programs you wrote for Practice Programs 4 and 7.
Notice that your program will have if-else statements embedded inside of if-else statements, but only in an indirect way.
The outer if-else statement will  two function calls as its two branches.
These two function calls will each in turn  an if-else statement, but you need not think about that.
They are just function calls and the details are in a black box that you create when you define these functions.
If you try to create a four-way branch, you are probably on the wrong track.
You should only need to think about two-way branches (even though the entire program does ultimately branch into four cases).
Include a loop that lets the user repeat this computation for new  values until the user says he or she wants to end the program.
The  of an arbitrary triangle can be computed using the formula where a, b, and c are the lengths of the sides, and   the semiperimeter.
The function should use five parameters—three value parameters that provide the lengths of the edges and two reference parameters that store the computed Programming Projects and perimeter.
Make your function robust.
Note that not all ­combinations of a, b, and c produce a triangle.
Your function should ­produce correct results for legal data and reasonable results for illegal combinations.
Programming Projects Programming Projects require more problem-solving than Practice Programs and can usually be solved many different ways.
Visit www_0_myprogramminglab_0_com to complete many of these Programming Projects online and get instant feedback.
Write a program that converts from 24-hour notation to 12-hour notation.
For example, it should convert 14:25 to 2:25 PM.
The  is given as two integers.
There should be at least three functions, one for , one to do the conversion, and one for output.
Record the AM/PM information as a value of type char, 'A' for AM and 'P' for PM.
Thus, the function for doing the conversions will have a call-by-reference formal parameter of type char to record Include a loop that lets the user repeat this computation for new  values again and again until the user says he or she wants to end the program.
Write a program that requests the current time and a waiting time as two integers for the number of hours and the number of minutes to wait.
The program then outputs what the time will be after the waiting period.
Use 24-hour notation for the times.
Include a loop that lets the user repeat this calculation for additional  values until the user says she or he wants to end the program.
Modify your program for Programming Project 2 so that it uses 12-hour notation, such as 3:45 PM.
Write a program that tells what coins to give out for any amount of change from 1 cent to 99 cents.
For example, if the amount is 86 cents, the output would be something like the following: 86 cents can be given as Use coin denominations of 25 cents (quarters), 10 cents (dimes), and 1 cent.
Chapter 5 / Functions for All Subtasks For example, suppose the value of the variable  is 86.
Then, after the following call, the value of number will be 3 and the value of will be 11 (because if you take 3 quarters from 86 cents, that leaves 11 cents): compute_coins(25, number, ); Include a loop that lets the user repeat this computation for new values until the user says he or she wants to end the program.
In cold weather, meteorologists report an index called the windchill factor, that takes into account the wind speed and the temperature.
The index provides a measure of the chilling effect of wind at a given air temperature.
Windchill may be approximated by the formula: = 13_0_12 + 0_0_6215 *  – 11_0_37 * 0_0_16 + 0_0_3965 *  * 0_0_016 where = wind speed in m/sec = temperature in degrees :  <= 10 Write a function that returns the windchill index.
Your code should ensure that the restriction on the temperature is not violated.
Look up some weather reports in back issues of a newspaper in your university library and compare the windchill index you calculate with the result reported in the newspaper.
VideoNote Solution to Programming Project 5_0_6 6.
In the land of Puzzlevania, Aaron, Bob, and Charlie had an argument over which one of them was the greatest puzzler of all time.
To end the argument once and for all, they agreed on a duel to the death.
Aaron is a poor shooter and only hits his target with a probability of 1/3.
Bob is a bit better and hits his target with a probability of 1/2.
Charlie is an expert marksman and never misses.
A hit means a kill and the person hit drops out of the duel.
To compensate for the inequities in their marksmanship skills, it is decided that the contestants would fire in turns starting with Aaron, followed by Bob, and then by Charlie.
The cycle would repeat until there was one man standing.
And that man would be remembered as the greatest puzzler of all time.
It should use the following declaration: void shoot(bool& targetAlive, double accuracy); This would simulate someone shooting at targetAlive with the given.
Programming Projects number is less than accuracy, then the target is hit and targetAlive should be set to false.
Chapter 4 illustrates how to generate random numbers.
For example, if Bob is shooting at Charlie, this could be invoked as: shoot(charlieAlive, 0_0_5); Here, charlieAlive is a Boolean variable that indicates if Charlie is alive.
Test your function using a driver program before moving on to step b.
Write a second function named startDuel that uses the shoot function to simulate an entire duel using this strategy.
It should loop until only one contestant is left, invoking the shoot function with the proper target and probability of hitting the target according to who is shooting.
The function should return a variable that indicates who won the duel.
Output the probability that each contestant will win when everyone uses the of shooting at the most accurate shooter left alive.
Thereafter, everyone uses the  of shooting at the most accurate shooter left alive.
This  means that Aaron is guaranteed to live past the first round, since Bob and Charlie will fire at each other.
Modify the program to accommodate this new  and output the probability of winning for each contestant.
Write a program that inputs a date (for example, July 4, 2008) and outputs the day of the week that corresponds to that date.
The following algorithm is from http://en_0_wikipedia_0_org/wiki/Calculating_the_day_of_the_week.
The implementation will require several functions.
Here is pseudocode to determine a leap : leap_ = ( divisible by 400) or ( divisible by 4 and int getCenturyValue(int );.
Chapter 5 / Functions for All Subtasks.
First, extract the last two digits  the.
For example, 08 is extracted for 2008.
Next, factor in leap years.
Divide the value from the previous step by 4 and discard the remainder.
Add the two results together and return this value.
For example, from 2008 we extract 08.
A remainder  0 corresponds to Sunday, 1 corresponds to Monday, etc_0_, Programming Projects up to 6, which corresponds to Saturday.
For example, the date July 4, 2008 should be computed as (day  month) + (getMonthValue) + (getYearValue) + () = 4 + 6 + 10 + 6 = 26.
The fifth day  the week corresponds to Friday.
Your program should allow the user to enter any date and output the corresponding day  the week in English.
This program should include a void function named getInput that prompts the user for the date and returns the month, day, and  using pass-by-reference parameters.
You may choose to have the user enter the date's month as either a number (1–12) or a month name.
Complete the previous Programming Project and create a top-level function named dayOfWeek with the header: int dayOfWeek(int month, int day, int ); The function should encapsulate the necessary logic to return the day the week  the specified date as an int ( = 0,  = 1, etc_0_) You should add validation code to the function that tests if any  the inputs are invalid.
If so, the function should return –1 as the day  the week.
In your main function write a test driver that checks if dayOfWeek is returning the correct values.
Your set  test cases should include at least two cases with invalid inputs.
As a leaf is carried by a stream, whether the stream ends in a lake or in the sea, so too is the output of your program carried by a stream not knowing if the stream goes to the screen or to a file.
Introduction I/O refers to program input and output.
Input can be taken from the keyboard or from a file.
Similarly, output can be sent to the screen or to a file.
This chapter explains how you can write your programs to take input from a file and send output to another file.
Input is delivered to your program via a Cplus_plus construct known as a stream, and output from your program is delivered to the output device via a stream.
Streams are our first examples of objects.
An object is a special kind of variable that has its own special-purpose functions that are, in a sense, attached to the variable.
The ability to handle objects is one of the language features that sets Cplus_plus apart from earlier programming languages.
In this chapter we tell you what streams are and explain how to use them for program I/O.
In the process of explaining streams, we will introduce you to the basic ideas about what objects are and about how objects are used in a program.
Prerequisites This chapter uses the material from Chapters 2 through 5.
For more than forty years I have been speaking prose without knowing it.
Molière, Le Bourgeois Gentilhomme You are already using files to store your programs.
You can also use files to store input for a program or to receive output from a program.
The files used for program I/O are the same kind of files you use to store your programs.
Streams, which we discuss next, allow you to write programs that handle file input and keyboard input in a unified way and that handle file output and screen output in a unified way.
A stream is a flow of characters (or other kind of data).
If the flow is into your program, the stream is called an input stream.
If the flow is out of your program, the stream is called an output stream.
If the input 306 6_0_1 Streams and Basic File I/O stream flows from the keyboard, then your program will take input from the keyboard.
If the input stream flows from a file, then your program will take its input from that file.
Similarly, an output stream can go to the screen or to a file.
Although you may not realize it, you have already been using streams in your programs.
The cin that you have already used is an input stream connected to the keyboard, and cout is an output stream connected to the screen.
These two streams are automatically available to your program, as long as it has an include directive that names the header file iostream.
You can define other streams that come from or go to files; once you have defined them, you can use them in your program in the same way you use the streams cin and cout.
For example, suppose your program defines a stream called in_stream that comes from some file.
Similarly, if your program defines an output stream named  that goes to another file, then you can output the value of this variable to this other file.
The following will output the string " " followed by the contents of the variable  to the output file that  connected to the stream : << " " <<  << endl; Once the streams are connected to the desired files, your program can do file I/O the same way it does I/O using the keyboard and screen.
Why Use Files for I/O.
The keyboard input and screen output we have used so far deal with temporary data.
When the program ends, the data typed in at the keyboard and the data left on the screen go away.
Files provide you with a way to store data permanently.
The contents of a file remain until a person or program changes the file.
If your program sends its output to a file, the output file will remain after the program has finished running.
An input file can be used over and over again by many programs without the need to type in the data separately for each program.
The input and output files used by your program are the same kind of files that you read and write with an editor, such as the editor you use to write your programs.
This means you can create an input file for your program or read an output file produced by your program whenever it's convenient for you, as opposed to having to do all your reading and writing while the program running.
When your program takes its input from a large input file, the program receives a lot of data without making the user do a lot of typing.
File I/O A stream  a variable Declaring streams ifstream and ofstream When your program takes input from a file, it  said to be reading from the file; when your program sends output to a file, it  said to be writing to the file.
There are other ways of reading input from a file, but the method we will use reads the file from the beginning to the end ( as far as the program gets before ending).
Using this method, your program  not allowed to back up and read anything in the file a second time.
This  exactly what happens when the program takes input from the keyboard, so this should not seem new  strange.
It  not allowed to back up and change any output that it has previously written to the file.
This exactly what happens when your program sends output to the screen.
You can send more output to the screen, but you cannot back up and change the screen output.
The way that you get input from a file into your program send output from your program into a file  to connect the program to the file by means of a stream.
In Cplus_plus, a stream  a special kind of variable known as an object.
We will discuss objects in the next section, but we will first describe how your program can use stream objects to do simple file I/O.
If you want to use a stream to get input from a file ( give output to a file), you must declare the stream and you must connect the stream to the file.
You can think of the file that a stream  connected to as the value of the stream.
You can disconnect a stream from one file and connect it to another file, so you can change the value of these stream variables.
However, you must use special functions that apply only to streams in order to perform these changes.
You cannot use a stream variable in an assignment statement the way that you can use a variable of type int  char.
Although streams are variables, they are unusual sorts of variables.
The streams cin and cout are already declared for you, but if you want a stream to connect to a file, you must declare it just as you would declare any other variable.
The type for input-file stream variables  named ifstream (for "input-file stream").
The type for output-file stream variables  named ofstream (for "output-file stream").
Thus, you can declare in_stream to be an input stream for a file and  to be an output stream for another file as follows: ifstream in_stream;.
This  called opening the file and  done with a function named open.
For example, suppose you want the input stream in_stream connected to the file named infile_0_dat.
Your program must then contain the following before it reads any input from this file: in_stream_0_open("infile_0_dat"); This may seem like rather strange syntax for a function call.
We will have more to say about this peculiar syntax in the next section.
For now, just notice a couple of details about how this call to open  written.
First, the stream variable name and a dot (that , a period)  placed before the function named open, and the file name  given as an argument to open.
Also notice that the file name  given in quotes.
The file name that given as an argument  the same as the name you would use for the file if you wanted to write in it using the editor.
If the input file  in the same directory as your program, you probably can simply give the name of the file in the manner just described.
In some situations you might also need to specify the directory that contains the file.
The details about specifying directories varies from one system to another.
If you need to specify a directory, ask your instructor  some other local expert to explain the details.
Once you have declared an input stream variable and connected it to a file using the open function, your program can take input from the file using the extraction operator >>.
For example, the following reads two input numbers from the file connected to in_stream and places them in the variables one_ number and another_number: int one_number, another_number; in_stream >> one_number >> another_number;.
If the output file does already exist, the member function open will discard the contents of the file so that the output file is empty after the call to open.
After a file is connected to the stream out_stream with a call to open, the program can send output to that file using the insertion operator <<.
For example, the following writes two strings and the contents of the variables and  to the file that is connected to the stream out_stream (which in this example is the file named outfile_0_dat): out_stream << " = " << << "  = " << ; Notice that when your program is dealing with a file, it is as if the file had two names.
One is the usual name for the file that is used by the operating system.
This name is called the external file name.
In our sample code the external file names were infile_0_dat and outfile_0_dat.
The external file name is in some sense the "real name" for the file.
The conventions for spelling these external file names vary from one system to another; you will need to learn these conventions from your instructor  from some other local expert.
The names infile_0_dat and outfile_0_dat that we used in our examples might  might not look like file names on your system.
You should name your files following whatever conventions your system uses.
Although the external file name is the real name for the file, it is typically used only once in a program.
The external file name is given as an argument to the function open, but after the file is opened, the file is always referred to by naming the stream that is connected to the file.
Thus, within your program, the stream name serves as a second name for the file.
The sample program in Display 6_0_1 reads three numbers from one file and writes their sum, as well as some text, to another file.
A File Has Two Names Every input and every output file used by your program has two names.
The external file name is the real name of the file, but it is used only in the call to the function open, which connects the file to a stream.
After the call to open, you always use the stream name as the name of the file.
Every file should be closed when your program is finished getting input from the file or sending output to the file.
Closing a file disconnects the stream from the file.
A file is closed with a call to the function close.
The following lines from the program in Display 6_0_1 illustrate how to use the function close: in_stream_0_close( );.
Notice that the function close takes no arguments.
If your program ends normally but without closing a file, the system will automatically close the file for you.
However, it is good to get in the habit of closing files for at least two reasons.
First, the system will only close files for you if your program ends in a normal fashion.
If your program ends abnormally due to an error, the file will not be closed and may be left in a corrupted state.
If your program closes files as soon as it is finished with them, file corruption is less likely.
A second reason for closing a file is that you may want your program to send output to a file and later read that output back into the program.
To do this, your program should close the file after it is finished writing to the file, and then your program should connect the file to an input stream using the function Display 6_0_1   Simple File Input/Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 //Reads three numbers from the file infile_0_dat, sums the numbers, //and writes the sum to the file outfile_0_dat.
Chapter 6 / I/O Streams as an Introduction to Objects and Classes open.
An object is a variable that has functions as well as data associated with it.
For example, the streams in_stream and out_stream both have a function named open associated with them.
Two sample calls of these functions, along with the declarations of the objects in_stream and out_stream, are given below:.
There is a reason for this peculiar notation.
The function named open that is associated with the object in_stream is a different function from the function named open that is associated with the object out_stream.
One function opens a file for input, and the other opens a file for output.
Of course, these two functions are similar.
They both "open files_0_" When we give two functions the same name, it is because the two functions have some intuitive similarity.
However, these two functions named open are different functions, even if they may be only slightly different.
When the compiler sees a call to a function named open, it must decide which of these two functions named open you mean.
The compiler determines this by looking at the name of the object that precedes the dot, in this case, either in_stream or out_stream.
A function that is associated with an object is called a member function.
So, for example, open is a member function of the object in_stream, and another function named open is a member of the object out_stream.
As we have just seen, different objects can have different member functions.
These functions may have the same names, as was true of the functions named open, or they may have completely different names.
The type of an object determines which member functions the object has.
If two objects are of the same type, they may have different values, but they will have the same member functions.
For example, suppose you declare the following stream objects: ifstream in_stream, in_stream2; ofstream out_stream, out_stream2; The functions in_stream_0_open and in_stream2_0_open are the same function.
Similarly, out_stream_0_open and out_stream2_0_open are the same function (but they are different from the functions in_stream_0_open and in_stream2_0_open).
A type whose variables are objects—such as ifstream and ofstream— is called a class.
Since the member functions for an object are completely determined by its class (that is, by its type), these functions are called member functions of the class (as well as being called members of the object).
For example, the class ifstream has a member function called open, and the class ofstream 6_0_1 Streams and Basic File I/O has a different member function called open.
The class ofstream also has a member function named precision, but the class ifstream has no member function named precision.
You have already been using the member function precision with the stream cout, but we will discuss it in more detail later.
When you call a member function in a program, you always specify an object, usually by writing the object name and a dot before the function name, as in the following example: in_stream_0_open("infile_0_dat"); One reason for naming the object is that the function can have some effect on the object.
In the preceding example, the call to the function open connects the file infile_0_dat to the stream in_stream, so it needs to know the name of this stream.
In a function call, such as in_stream_0_open("infile_0_dat"); the dot is called the dot operator and the object named before the dot is referred to as the calling object.
In some ways the calling object is like an additional argument to the function—the function can change the calling object as if it were an argument—but the calling object plays an even larger role in the function call.
The calling object determines the meaning of the function name.
The compiler uses the type of the calling object to determine the meaning of the function name.
For example, in the earlier call to open, the type of the object in_stream determines the meaning of the function name open.
Calling a Member Function Syntax.
Classes and Objects An object is a variable that has functions associated with it.
These functions are called member functions.
A class is a type whose variables are objects.
The object's class (that is, the type of the object) determines which member functions the object has.
The classes ifstream and ofstream each have a member function named close.
They both "close files," but they close them in different ways because the files were opened and were manipulated in different ways.
We will be discussing more member functions for the classes ifstream and ofstream later in this chapter.
For example, if you open an input file and there is no file with the external name that you specify, then the call to open will fail.
When this happens, you might not receive an error message and your program might simply proceed to do something unexpected.
Thus, you should always follow a call to open with a test to see whether the call to open was successful and end the program (or take some other appropriate action) if the call to open was unsuccessful.
You can use the member function named fail to test whether a stream operation has failed.
There is a fail member function for each of the classes ifstream and ofstream.
The fail function takes no arguments and returns a bool value.
A call to the function fail for a stream named in_stream would be as follows: This is a Boolean expression that can be used to control a while loop or an if-else statement.
You should place a call to fail immediately after each call to open; if the call to open fails, the function fail will return true (that is, the Boolean expression will be satisfied).
For example, if the following call to open fails, then the program will output an error message and end; if the call succeeds, the fail function returns false, so the program will continue.
Of course, the call to in_stream_0_fail refers only to a call to open of the form in_stream_0_open, and not to any call to the function open made with any other stream as the calling object.
The exit statement causes your program to end immediately.
The exit function returns its argument to the operating system.
To use the exit statement, your program must contain the following  directive: # <cstdlib> When using exit, your program must also contain the following, normally.
By convention, 1 is used as the argument if the call to exit was due to an error, and 0 is used otherwise_0_1 For our purposes, it makes no difference what integer you use, but it pays to follow this convention since it is important in more advanced programming.
The exit Statement The exit statement is written exit(Integer_Value); When the exit statement is executed, the program ends immediately.
Any Integer_Value may be used, but by convention, 1 is used for a call to exit that is caused by an error, and 0 is used in other cases.
The exit statement is a call to the function exit, which is in the library with header file named cstdlib.
Therefore, any program that uses the exit statement must contain the following directives: # <cstdlib> using namespace std;.
They are placed in the same locations as similar directives we have 1 UNIX and Windows use 1 for error and 0 for success, but other operating systems may reverse this convention.
You should ask your instructor what values to use.
Chapter 6 / I/O Streams as an Introduction to Objects and Classes Display 6_0_2 contains the program from Display 6_0_1 rewritten to tests to see if the input and output files were opened successfully.
It processes files in exactly the same way as the program in Display 6_0_1.
In particular, assuming that the file infile_0_dat exists and has the contents shown in Display 6_0_1, the program in Display 6_0_2 will create the file outfile_0_dat that is shown in Display 6_0_1.
However, if there were something wrong and one of the calls to open failed, then the program in Display 6_0_2 would end and send an appropriate error message to the screen.
For example, if there were no file named infile_0_dat, then the call to in_stream_0_open would fail, the program would end, and an error message would be written to the screen.
Notice that we used  to output the error message; this is because we want the error message to go to the screen, as opposed to going to a file.
Since this program uses  to output to the screen (as well as doing file I/O), we have added an  directive for the header file iostream.
However, the programming style for file I/O  different from that for I/O using the screen and keyboard.
When reading input from the keyboard, you should prompt for input and echo the input, like this:.
When your program takes its input from a file, you should not  such prompt lines or echoing of input, because there  nobody there to read and respond to the prompt and echo.
When reading input from a file, you must be certain the data in the file  exactly the kind of data the program expects.
Your program then simply reads the input file assuming that the data it needs will be there when it  requested.
If in_file  a stream variable that  connected to an input file and you wish to replace the previous keyboard/screen I/O shown with input from the file connected to in_file, then you would replace those three lines with the following line: in_file >> the_number; You may have any number of streams opened for input or for output.
Thus, a single program can take input from the keyboard and also take input from one or more files.
The same program could send output to the screen and 6_0_1 Streams and Basic File I/O to one or more files.
Alternatively, a program could take all of its input from the keyboard and send output to both the screen and a file.
Any combination of input and output streams  allowed.
Most of the examples in this book will use cin and  to do I/O using the keyboard and screen, but it  easy to modify these programs so that the program takes its input from a file and/or sends its output to a file.
Display 6_0_2   File I/O with Checks on open 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 //Reads three numbers from the file infile_0_dat, sums the numbers,.
Chapter 6 / I/O Streams as an Introduction to Objects and Classes Summary of File I/O Statements In this sample the input comes from a file with the directory name infile.
For file I/O For For exit Choose a stream name for the input stream (for example, in_stream), and declare it to be a variable of type ifstream.
Choose a stream name for the output.
Connect each stream to a file using the member function open with the external file name as an argument.
Remember to use the member function fail to test that the call to open was successful: in_stream_0_open("infile_0_dat");.
For example: <<  << endl;.
Sel f -T e st Exerc  e s 1.
Suppose you are writing a program that uses a stream called fin that will be connected to an input file, and a stream called fout that will be connected to an output file.
How do you declare fin and fout.
What  directive, if any, do you need to place in your program file.
Suppose you are continuing to write the program discussed in the previous exercise and you want it to take its input from the file stuff1.
What statements do you need to place in your program in order to connect the stream fin to the file stuff1_0_dat and to connect the stream fout to the file stuff2_0_dat.
Be sure to  checks to make sure that the openings were successful.
Suppose that you are still writing the same program that we discussed in the previous two exercises and you reach the point at which you no longer need to get input from the file stuff1_0_dat and no longer need to send output to the file stuff2_0_dat.
How do you close these files.
Suppose you want to change the program in Display 6_0_1 so that it sends its output to the screen instead of the file outfile_0_dat.
What  directive do you need to place in your program file if your program uses the function exit.
Continuing Self-Test Exercise 5, what does exit(1) do with its argument.
Suppose bla is an object, dobedo is a member function of the object bla, and dobedo takes one argument of type int.
How do you write a call to the member function dobedo of the object bla using the argument 7.
What characteristics of files do ordinary program variables share.
What characteristics of files are different from ordinary variables in a program.
A program has read half of the lines in a file.
What must the program do to the file to enable reading the first line a second time.
In the text it says "a file has two names_0_" What are the two names.
Chapter 6 / I/O Streams as an Introduction to Objects and Classes When sending output to a file, your code must first use the member function open to open a file and connect it to a stream of type ofstream.
The way we have done that thus far (with a single argument for the file name) always gives an empty file.
If a file with the specified name already exists, its old contents are lost.
There is an alternative way to open a file so that the output from your program will be appended to the file after any data already in the file.
To append your output to a file named important_0_txt, you would use a two-argument version of open, as illustrated by the following: ofstream outStream; outStream_0_open("important_0_txt", ios::app); If the file important_0_txt does not exist, this will create an empty file with that name to receive your program's output, but if the file already exists, then all the output from your program will be appended to the end of the file so that old data in the file is not lost.
This is illustrated in Display 6_0_3.
Screen Output Opening data_0_txt for appending.
End of appending to file.
The second argument ios::app is a special constant that is defined in iostream and so requires the following  directive: # <iostream>.
We did this by giving the file name as the argument to a call to the function open, as in the following example: in_stream_0_open("infile_0_dat"); This can sometimes be inconvenient.
For example, the program in Display 6_0_2 reads numbers from the file infile_0_dat and outputs their sum to the file outfile_0_dat.
If you want to perform the same calculation on the numbers in another file named infile2_0_dat and write the sum of these numbers to another file named outfile2_0_dat, then you must change the file names in the two calls to the member function open and then recompile your program.
A preferable alternative is to write your program so that it asks the user to type in the names of the input and output files.
This way your program can use different files each time it is run.
Chapter 6 / I/O Streams as an Introduction to Objects and Classes Appending to a File If you want to append data to a file so that it goes after any existing contents of the file, open the file as follows.
A file name is a string and we will not discuss string handling in detail until Chapter 8.
However, it is easy to learn enough about strings so that you can write programs that accept a file name as input.
A string is just a sequence of characters.
We have already used string values in output statements such as the following: << "This is a string_0_"; We have also used string values as arguments to the member function open.
Whenever you write a literal string, as in the  statement shown, you must place the string in double quotes.
In order to read a file name into your program, you need a variable that is capable of holding a string.
We discuss the details of strings in Chapter 8, but for now we will cover just enough to store a file name.
A variable to hold a string value is declared as in the following example: char file_name[16]; This declaration is the same as if you had declared the variable to be of type char, except that the variable name is followed by an integer in square brackets that specifies the maximum number of characters you can have in a string stored in the variable.
This number must be one greater than the maximum number of characters in the string value.
So, in our example, the variable  can contain any string that contains 15 or fewer characters.
The name  can be replaced by any other identifier (that is not a keyword), and the number 16 can be replaced by any other positive integer.
You can input a string value to a string variable the same way that you input values of other types.
For example, consider the following piece of code:.
For example, the following will connect the input- stream in_stream to the  whose name is stored in the variable (and will use the member function fail to check whether the opening was successful): String variables as arguments to.
Note that when you use a string variable as an argument to the member function open, you do not use any quotes.
In Display 6_0_4 we have rewritten the program in Display 6_0_2 so that it takes its input from and sends its output to whatever files the user specifies.
The input and output  names are read into the string variables in_file_ name and out_file_name and then these variables are used as the arguments in calls to the member function open.
Notice the declaration of the string variables.
You must  a number in square brackets after each string variable name, as we did in Display 6_0_4.
String variables are not ordinary variables and cannot be used in all the ways you can use ordinary variables.
In particular, you cannot use an assignment statement to change the value of a string variable.
Richard Brinsley Sheridan, The School for Scandal Formatting Output with Stream Functions The layout of a program's output is called the format of the output.
In Cplus_plus you can control the format with commands that determine such details as the number of spaces between items and the number of digits after the decimal point.
You already used three output formatting instructions when you learned the formula for outputting dollar amounts of money in the usual way (not in Warning.
Chapter 6 / I/O Streams as an Introduction to Objects and Classes 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 //Reads three numbers from the  specified by the user, sums the numbers,.
Enter the input file name (maximum of 15 characters): numbers_0_dat Enter the output file name (maximum of 15 characters): sum_0_dat I will read numbers from the file numbers_0_dat and place the sum in the file sum_0_dat End of Program.
Before outputting amounts.
Now that you've learned about object notation for streams, we can explain this magic formula and a few other formatting commands.
The first thing to note is that you can use these formatting commands on any output stream.
If your program is sending output to a file that is connected to an output stream called out_stream, you can use these same commands to ensure that numbers with a decimal point will be written in the way we normally write amounts of money.
Just insert the following in your program: out_stream_0_setf(ios::fixed);.
To explain this magic formula, we will consider the instructions in reverse order.
Every output stream has a member function named precision.
When your program executes a call to precision such as the previous one for the stream out_stream, then from that point on in your program, any number with a decimal point that is output to that stream will be written with a total of two significant figures, or with two digits after the decimal point, depending on when your compiler was written.
The following is some possible output from a compiler that sets two significant digits: 23.
A call to precision applies only to the stream named in the call.
If your program has another output stream named out_stream_two, then the call to out_stream_0_precision affects the output to the stream out_stream but has no effect on the stream out_stream_two.
Of course, you can also call precision with the stream out_stream_two; you can even specify a different number of digits for the numbers output to the stream out_stream_two, as in the following: out_stream_two_0_precision(3); The other formatting instructions in our magic formula are a bit more complicated than the member function precision.
We now discuss these other instructions.
The following are two calls to the member function setf with the stream out_stream as the calling object: out_stream_0_setf(ios::fixed); out_stream_0_setf(ios::showpoint); setf is an abbreviation for set flags.
A flag is an instruction to do something in one of two possible ways.
If a flag is given as an argument to setf, then the flag tells the computer to write output to that stream in some specific way.
What it causes the stream to do depends on the flag.
In the previous example, there are two calls to the function setf, and these two calls set the two flags ios::fixed and ios::showpoint.
The flag ios::fixed causes the stream to output numbers of type double in what is called fixed-point notation, which is a fancy phrase for the way we normally write numbers.
If the flag ios::fixed is set (by a call to setf), then all floatingpoint numbers (such as numbers of type double) that are output to that stream will be written in ordinary everyday notation, rather than e-notation.
Not set ios::showpoint If this flag is set, a decimal point and trailing zeros are always shown for floating-point numbers.
If it is not set, a number with all zeros after the decimal point might be output without the decimal point and following zeros.
Not set ios::showpos If this flag is set, a plus sign is output before positive integer values.
Not set ios::right If this flag is set and some field-width value is given with a call to the member function width, then the next item output will be at the right end of the space specified by width.
In other words, any extra blanks are placed before the item output.
In other words, any extra blanks are placed after the item output.
So if the number to be output has a value of 2_0_0, then it will be output as 2_0_0 and not simply as 2; that is, the output will include the decimal point even if all the digits after the decimal point are 0.
Some common flags and the actions they cause are described in Display 6_0_5.
Another useful flag is ios::showpos.
If this flag is set for a stream, then positive numbers output to that stream will be written with the plus sign in front of them.
If you want a plus sign to appear before positive numbers, insert the following: cout_0_setf(ios::showpos);.
Chapter 6 / I/O Streams as an Introduction to Objects and Classes.
The width function tells the stream how many spaces to use when giving an item as output.
In this case the item (namely, the number 7) occupies only one space, and width said to use four spaces, so three of the spaces are blank.
If the output requires more space than you specified in the argument to width, then as much additional space as is needed will be used.
The entire item is always output, no matter what argument you give to width.
A call to width applies only to the next item that is output.
If you want to output 12 numbers, using four spaces to output each number, then you must call width 12 times.
If this becomes a nuisance, you may prefer to use the manipulator setw that is described in the next subsection.
Any flag that is set may be unset.
To unset a flag, you use the function unsetf.
For example, the following will cause your program to stop including plus signs on positive integers that are output to the stream : _0_unsetf(ios::showpos); Flag Terminology Why are the arguments to setf, such as ios::showpoint, called flags.
And what is meant by the strange notation ios::.
The word flag is used for something that can be turned on or off.
The origin of the term apparently comes from some phrase similar to "when the flag is up, do it_0_" Or perhaps the term was "when the flag is down, do it_0_" Moreover, apparently nobody can recall what the exact originating phrase was because programmers now say "when the flag is set" and that does not conjure up any picture.
In any event, when the flag ios::showpoint is set (that is, when it is an argument to setf), the stream that called the setf function will behave as described in Display 6_0_5; when any other flag is set (that is, is given as an argument to setf), that signals the stream to behave as Display 6_0_5 specifies for that flag.
The explanation for the notation ios:: is rather mundane for such exotic notation.
The ios indicates that the meaning of terms such as fixed or showpoint is the meaning that they have when used with an input or output stream.
The notation :: means "use the meaning of what follows the :: in the context of what comes before the ::_0_" We will say more about this :: notation later in this book.
In turn, the manipulator function calls a member function.
Manipulators are placed after the insertion operator <<, just as if the manipulator function call were an item to be output.
Like traditional functions, manipulators may or may not have arguments.
We have already seen one manipulator, endl.
In this subsection we will discuss two manipulators called  and setprecision.
The manipulator  and the member function width (which you have already seen) do exactly the same thing.
You call the  manipulator by writing it after the insertion operator <<, as if it were to be sent to the output stream, and this in turn calls the member function width.
For example, the following outputs the numbers 10, 20, and 30, using the field widths specified: << "" << (4) << 10 << (4) << 20 << (6) << 30;.
However, a call to  is written after the insertion operator <<, in a manner similar to how you call the  manipulator.
For example, the following outputs the numbers listed using the number of digits after the decimal point that are indicated by the call to :.
To use either of the manipulators  or , you must the following directive in your program: # <iomanip>.
Chapter 6 / I/O Streams as an Introduction to Objects and Classes Sel f -T es t Exe rc is e s 12.
What output will be produced when the following lines are executed (assuming the lines are embedded in a complete and correct program with the proper  directives).
What output will be sent to the file stuff_0_dat when the following lines.
In formatting output, the following flag constants are used with the stream member function setf.
What changes are necessary to make the output.
Chapter 6 / I/O Streams as an Introduction to Objects and Classes Streams as Arguments to Functions Stream parameters must be call-byreference A stream can be an argument to a function.
The only restriction is that the function formal parameter must be call-by-reference.
A stream parameter cannot be a call-by-value parameter.
For example, the function make_neat in Display 6_0_6 has two stream parameters: one is of type ifstream and is for a stream connected to an input file; another is of type ofstream and is for a stream connected to an output file.
We will discuss the other features of the program in Display 6_0_6 in the next two subsections.
When you write a program that takes its input from a file, you will often want the program to read all the data in the file.
For example, if the file contains numbers, you might want your program to calculate the average of all the numbers in the file.
Since you might run the program with different data files at different times, the program cannot assume it knows how many numbers are in the file.
You would like to write your program so that it keeps reading numbers from the file until there are no more numbers left to be read.
If in_stream is a stream connected to the input file, then the algorithm for computing this average can be stated as follows: double next,  = 0;.
This algorithm is already almost all Cplus_plus code, but we still must express the following test in Cplus_plus: Even though it may not look correct at first, one way to express the aforementioned test is the following: The previous algorithm can thus be rewritten as the following Cplus_plus code (plus one last line in pseudocode that is not the issue here): 6_0_2 Tools for Stream I/O 333 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 //Illustrates output formatting instructions.
Chapter 6 / I/O Streams as an Introduction to Objects and Classes 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 //Uses iostream, fstream, and iomanip:.
Notice that the loop body is not identical to what it was in our pseudocode.
Since in_stream >>  is now in the Boolean expression, it is no longer in the loop body.
This loop may look a bit peculiar, because in_stream >>  is both the way you input a number from the stream in_stream and the controlling Boolean expression for the while loop.
An expression involving the extraction operator >> is simultaneously both an action and a Boolean condition_0_2 It is an instruction to take one input number from the input stream, and it is also a Boolean expression that is either satisfied or not.
If there is another number to be input, then the number is read and the Boolean expression is satisfied, so the body of the loop is executed one more time.
If there are no more numbers to be read in, then nothing is input and the Boolean expression is not satisfied, so the loop ends.
In this example the type of the input variable was double, but this method of checking for the end of the file works the same way for other data types, such as int and char.
This is an admirable goal, but now we have a problem—functions whose parameter type is in a namespace.
In our immediate examples we need the stream type names that are in the namespace std.
Thus, we need a using directive (or something) outside of the function definition body so that Cplus_plus will understand the parameter type names, such as ifstream.
The easiest fix is to simply place one using directive at the start of the file (after the include directives).
Placing a single using directive at the start of a file is the easiest solution to our problem, but many experts would not consider it the best solution, since it would not allow the use of two namespaces that have names in common, and that is the whole purpose of namespaces.
At this point we are Technically, the Boolean condition works this way: The overloading of operator >> for the input stream classes is done with functions associated with the stream.
This function is named operator >>.
The return value of this operator function is an input stream reference (istream& or ifstream&).
A function is provided that automatically converts the stream reference to a bool value.
The resulting value is true if the stream is able to extract data, and false otherwise.
Chapter 6 / I/O Streams as an Introduction to Objects and Classes only using the namespace std,3 so there is no problem.
In Chapter 12, we will teach you another way around this problem with parameters and namespaces.
This other approach will allow you to use any kinds of multiple namespaces.
Many programmers prefer to place using directives at the start of the program file.
For example, consider the following using directive: using namespace std; Many of the programs in this book do not place this using directive at the start of the program file.
Instead, this using directive is placed at the start of each function definition that needs the namespace std (immediately after the opening brace).
An example of this is shown in Display 6_0_3.
An even better example is shown in Display 5_0_11.
All of the programs that have appeared so far in this book, and almost all programs that follow, would behave exactly the same if there were just one using directive for the namespace std and that one using directive were placed immediately after the include directives, as in Display 6_0_6.
For the namespace std, the using directive can safely be placed at the start of the file (in almost all cases).
For some other namespaces, a single using directive will not always suffice, but you will not see any of these cases for some time.
We advocate placing the using directives inside function definitions (or inside some other small units of code) so that it does not interfere with any other possible using directives.
This trains you to use namespaces correctly in preparation for when you write more complicated code later in your programming career.
In the meantime, we sometimes violate this rule ourselves when following the rule becomes too burdensome to the other issues we are discussing.
If you are taking a course, do whatever your instructor requires.
Otherwise, you have some latitude in where you place your using directives.
Programming Example    Cleaning Up a File Format The program in Display 6_0_6 takes its input from the file rawdata_0_dat and writes its output, in a neat format, both to the screen and to the file neat_0_dat.
The program copies numbers from the file rawdata_0_dat to the file neat_0_dat, but it uses formatting instructions to write them in a neat way.
The numbers are written one per line in a field of width 12, which means that each number is preceded by enough blanks so that the blanks plus the number occupy 12 spaces.
The numbers are written in ordinary notation; that is, they are not written in e-notation.
Each number is written with five digits after the decimal We are actually using two namespaces: the namespace std and a namespace called the global namespace, which is a namespace that consists of all names that are not in some other namespace.
But this technical detail is not a big issue to us now.
The output to the screen is the same as the output to the file neat_0_dat, except that the screen output has one extra line that announces that the program is ending.
The program uses a function, named make_neat, that has formal parameters for the input-file stream and the output-file stream.
Sel f -T e st Exerc is e s 19.
What output will be produced when the following lines are executed, assuming the file list_0_dat contains the data shown (and assuming the lines are embedded in a complete and correct program with the proper include directives).
The file list_0_dat contains the following three numbers (and nothing 1 3 2 20.
Write the definition for a void function called to_screen.
The function to_screen has one formal parameter called file_stream, which is of type ifstream.
The precondition and postcondition for the function are as follows: //Precondition: The stream file_stream has been connected //to a file with a call to the member function open.
The //file contains a list of integers (and nothing else).
Hamlet: Words, words, words.
William Shakespeare, Hamlet All data is input and output as character data.
When your program outputs the number 10, it is really the two characters '1' and '0' that are output.
Similarly, when the user wants to type in the number 10, he or she types in the character '1' followed by the character '0'.
Whether the computer interprets this 10 as two characters or as the number 10 depends on how your program is written.
But, however your program is written, the computer hardware is always reading the characters '1' and '0', not the number 10.
This conversion between characters and numbers is usually done automatically so that you need not think about such detail.
Sometimes, however, all this automatic help gets in the way.
Therefore, Cplus_plus provides some low-level facilities for input and output of character data.
These low-level facilities  no automatic conversions.
This allows you to bypass the automatic facilities and do input/ output in absolutely any way you want.
You could even write input and output functions that read and write numbers in Roman numeral notation, if you wanted to be so perverse.
The Member Functions get and put The function get allows your program to read in one character of input and store it in a variable of type char.
Every input stream, whether it is an inputfile stream or the stream cin, has get as a member function.
We will describe get as a member function of the stream cin, but it behaves in exactly the same way for input-file streams as it does for cin, so you can apply all that we say about get to input-file streams as well as to the stream cin.
Before now, we have used cin with the extraction operator >> in order to read a character of input (or any other input, for that matter).
When you use the extraction operator >>, as we have been doing, some things are done for you automatically, such as skipping blanks.
If you want, for example, to skip over blanks using cin_0_get, you must write code to read and discard the blanks.
That argument receives the input character that is read from the input stream.
For example, the following reads in the  input character from the keyboard and stores it in the variable next_symbol: char next_symbol; cin_0_get(next_symbol); It is important to note that your program can read any character in this way.
If the  input character is a blank, this code will not skip over the blank, but will read the blank and set the value of next_symbol equal to the blank character.
If the  character is the new- character '\n', that is, if the program has just reached the end of an input , then the call to cin_0_get shown earlier sets the value of next_symbol equal to '\n'.
Although we write it as two symbols, '\n' is just a single character in Cplus_plus.
With the member function get, the character '\n' can be input and output just like any other character.
For example, suppose your program contains the following code: Reading blanks.
As you would expect, the value of c1 is set to 'A' and the value of c2 is set to 'B'.
When this code is executed on the input we showed, the value of c3 is set to '\n'; that is, the value of c3 is set equal to the - character.
The variable c3 is not set equal to 'C'.
One thing you can do with the member function get is to have your program detect the end of a.
The following loop will read a  of input and stop after passing the - character '\n'.
Then, any subsequent input will be read from the beginning of the.
For this first example, we have simply echoed the input, but the same technique would allow you to do whatever you want with the input: << "Enter a  of input and I will echo it:\n";.
This loop will read any  of input and echo it exactly, including blanks.
The following is a sample dialogue produced by this code: Enter a  of input and I will echo it: Do Be Do 1 2   34 Do Be Do 1 2   34 That's all for this demonstration.
Notice that the - character '\n' is both read and output.
Since '\n' is output, the string that begins with the word "That's" is on a.
The Member Function get Every input stream has a member function named get that can be used to read one character of input.
Unlike the extraction operator >>, get reads the next input character, no matter what that character is.
In particular, get reads a blank or the - character '\n' if either of these is the next input character.
The function get takes one argument, which should be a variable of type char.
When get is called, the next input character is read and the argument variable (called Char_Variable below) has its value set equal to this input character.
If you wish to use get to read from a file, you use an input-file stream in place of the stream cin.
For example, if in_stream is an input stream for a file, then the following reads one character from the input file and places the character in the char variable next_symbol: in_stream_0_get(next_symbol); Before you can use get with an input-file stream such as in_stream, your program must first connect the stream to the input file with a call to open.
On the other hand, "\n" is a string that happens to be made up of exactly one character.
Thus, "\n" is not of type char and cannot be stored in a variable of type char.
The member function put is analogous to the member function get except that it is used for output rather than input.
The member function put takes one argument, which should be an expression of type char, such as a constant or a variable of type char.
The value of the argument is output to the stream when the function is called.
For example, the following outputs the letter 'a' to the screen: _0_put('a'); The function _0_put does not allow you to do anything you could not do by using the methods we discussed previously, but we  it for completeness.
If your program uses cin_0_get or _0_put, then just as with other uses of cin and , your program should  the following directive: # <iostream> Similarly, if your program uses get for an input-file stream or put for an.
When the member function put is called, the value of its argument (called Char_Expression below) is output to the output stream.
If you wish to use put to output to a file, you use an output-file stream in place of the stream.
For example, if out_stream is an output stream for a file, then the following will output the character 'Z' to the file connected to out_stream: out_stream_0_put('Z'); Before you can use put with an output-file stream, such as out_stream, your program must first connect the stream to the output file with a call to the member function open.
When using either of these  directives, your program must also the following: using namespace std; Sometimes your program needs to know the next character in the input stream.
However, after reading the next character, it might turn out that you do not want to process that character and so you would like to simply put it back in the input stream.
For example, if you want your program to read up to but not including the first blank it encounters in an input stream, then your program must read that first blank in order to know when to stop reading—but then that blank is no longer in the stream.
Some other part of your program might need to read and process this blank.
There are a number of ways to deal with this sort of situation, but the easiest is to use the member function putback.
The function putback is a member of every input stream.
It takes one argument of type char and it places the value of that argument back in the input stream.
The argument can be any expression that evaluates to a value of type char.
For example, the following code will read characters from the file connected to the input stream fin and write them to the file connected to the output stream fout.
The code reads characters up to, but not including, the first blank it encounters.
Notice that after this code is executed, the blank that was read is still in the input stream fin, because the code puts it back after reading it.
Notice that putback places a character in an input stream, while put places a character in an output stream.
The character that is put back into the input stream with the member function putback need not be the last character read; it can be any character you wish.
If you put back a character other than the last character read, the text in the input file will not be changed by putback, although your program will behave as if the text in the input file had been changed.
Programming Example   Checking Input If a user enters incorrect input, the entire run of the program can become worthless.
To ensure that your program is not hampered by incorrect input, you should use input functions that allow the user to reenter input until the input is correct.
The function get_int in Display 6_0_7 asks the user whether the input is correct and asks for a new  if the user says the input is incorrect.
The program in Display 6_0_7 is just a driver program to test the function get_ int, but the function, or one very similar to it, can be used in just about any kind of program that takes its input from the keyboard.
Notice the call to the function new_line( ).
The function new_line reads all the characters on the remainder of the current line but does nothing with them.
This amounts to discarding the remainder of the line.
Thus, if the user types in No, then the program reads the first letter, which is N, and then calls the function new_line, which discards the rest of the input line.
This means that if the user types 75 on the  input line, as shown in the sample dialogue, the program will read the number 75 and will not attempt to read the letter o in the word No.
If the program did not  a call to the function new_line, then the  item read would be the o in the line containing No instead of the number 75 on the following line.
Chapter 6 / I/O Streams as an Introduction to Objects and Classes 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48.
Sample Dialogue Enter input number: 57 You entered 57.
If the input is not correct, the user is supposed to type No (or some variant such as no), which will cause one more iteration of the loop.
However, rather than checking to see if the user types a word that starts with 'N', the do-while loop checks to see if the first letter of the user's response is not equal to '' (and not equal to the lowercase version of '').
As long as the user makes no mistakes and responds with some form of Yes or No, but never with anything else, then checking for No or checking for not being Yes are the same thing.
However, since the user might respond  some other way, checking for not being Yes is safer.
To see why this is safer, suppose the user makes a mistake  entering the input number.
The computer echoes the number and asks if it is correct.
The user should type  No, but suppose the user makes a mistake and types  Bo, which is not unlikely since 'B' is right next to 'N' on the keyboard.
Since 'B' is not equal to '', the body of the do-while loop will be executed, and the user will be given a chance to reenter the input.
But, what happens if the correct response is Yes and the user mistakenly enters something that begins with a letter other than '' or 'y'.
In that case, the loop should not iterate, but it does iterate one extra time.
This is a mistake, but not nearly as bad a mistake as the one discussed  the last paragraph.
It means the user must type  the input number one extra time, but it does not waste the entire run of the program.
When checking input, it is better to risk an extra loop iteration than to risk proceeding with incorrect input.
A common problem when using get is forgetting to dispose of the '\n' that ends every input.
If there is a newline character  the input stream that is not read (and usually discarded), then when your program next expects to read a "real"  using the member function get, it will instead read the character '\n'.
To clear the input stream of any leftover '\n' characters, you can use the function new_line, which we defined  Display 6_0_7.
Let's look at a concrete example.
It is legal to mix the different forms of cin.
For example, the following is legal:.
However, if you expect the value of the variable  to be 'A', you will be disappointed.
The value given to  is '\n'.
After reading the number 21, the next character  the input stream is the new- character, '\n', and so that is read next.
Remember, get does not skip over  breaks and spaces.
Once the variable  is filled with the character '\n', the program proceeds to whatever statement is next  the program.
If the next statement sends output to the screen, the screen will be filled with Either of the following rewritings of the previous code will cause the previous dialogue to fill the variable number with 21 and fill the variable  with 'A':.
However, an input-file stream, even if used as an argument of type istream, must still be declared to be of type ifstream (with an f ).
However, an output-file stream, even if used as an argument of type ostream, must still be declared to be of type ofstream.
You cannot open or close a stream parameter of type istream or ostream.
Open these objects before passing them to your function and close them after the call.
PROGRAMMING EXAMPLE  Another new_line Function As another example of how you can make a stream function more versatile, consider the function new_line  Display 6_0_7.
That function works only for input from the keyboard, which is input from the predefined stream cin.
The function new_line  Display 6_0_7 has no arguments.
Below we have rewritten the function new_line so that it has a formal parameter of type istream for the input stream:.
If your program is taking input from an input stream called fin (which is connected to an input file), the following will discard all the input left on the  currently being read from the input file: new_line(fin); On the other hand, if your program is also reading some input from the.
But thanks to overloading, you can have both versions of the function new_line in the same program: the  with Using both versions of new_line 347.
Chapter 6 / I/O Streams as an Introduction to Objects and Classes no arguments that is given in Display 6_0_7 and the  with one argument of type istream that we just defined.
In a program with both definitions of new_line, the following two calls are equivalent: new_line(cin);.
You do not really need two versions of the function new_line.
The with one argument of type istream can serve all your needs.
However, many programmers find it convenient to have a  with no arguments for keyboard input, since keyboard input is used so frequently.
VideoNote Default Arguments An alternative to having two versions of the new_line function is to use default arguments.
In the following code, we have rewritten the new_line function a third time: //Uses iostream:.
This facility is available to us with any argument type and any number of arguments.
If some parameters are provided default arguments and some are not, the formal parameters with default arguments must all be together at the end of the argument list.
If you provide several defaults and several nondefault arguments, the call may provide either as few arguments as there are nondefault arguments or more arguments, up to the number of parameters.
The arguments will be applied to the parameters without default arguments in order, and then will be applied to the parameters with default arguments up to the number of parameters.
The output is 5 6 -3 -4 Next, consider default_args(6, 7, 8); This call supplies the nondefault arguments and the first default argument, and the last argument uses the default.
This call gives the following output: 6 7 8 -4 The call default_args(5, 6, 7, 8); assigns all the arguments from the argument list and gives the following output: 5 6 7 8 Sel f -T e st Exerc is e s 22.
Suppose c is a variable of type char.
What is the difference between the following two statements.
Chapter 6 / I/O Streams as an Introduction to Objects and Classes.
Does the  that is put back have to be the last  input from the stream.
For example, if your program reads an 'a' from the input stream, can it use the putback function to put back a 'b', or can it only put back an 'a'.
Consider the following code (and assume that it is embedded in a complete and correct program and then run):.
Enter a line of input: a b  d e f g 26.
Consider the following code (and assume that it is embedded in a.
Enter a line of input: abcdef gh 6_0_3 Character I/O 27.
Suppose that the program described in Self-Test Exercise 26 is run and the dialogue begins as follows (instead of beginning as shown in Self-Test Exercise 26).
What will be the  line of output.
Enter a line of input: 0 1 2 3 4 5 6 7 8 9 10 11 28.
Consider the following code (and assume that it is embedded in a.
Enter a line of input: 0 1 2 3 4 5 6 7 8 9 10 11 29_0_	Define a function called copy_char that takes one argument that is an input stream.
When called, copy_char will read one character of input from the input stream given as its argument and will write that character to the screen.
You should be able to call your function using either cin or an input-file stream as the argument to your function copy_char.
When called, copy_line reads one line of input from the input stream given as its argument and writes that line to the screen.
You should be able to call your function using either cin or an input-file stream as the argument to your function copy_line.
Chapter 6 / I/O Streams as an Introduction to Objects and Classes is an input-file stream, then the stream is connected to a file before the function is called, so copy_line will not open or close any files_0_) For example, the first of the following two calls to copy_line will copy a line from the file stuff_0_dat to the screen, and the second will copy a line from the keyboard to the screen:.
When called, send_line reads one line of input from the keyboard and outputs the line to the output stream given as its argument.
You should be able to call your function using either  or an outputfile stream as the argument to your function send_line.
This is the second technique we have presented for determining when a program has read everything in a file.
The letters eof stand for end of file, and eof is normally pronounced by saying the three letters e-o-f.
The function eof takes no arguments, so if the input stream is called fin, then a call to the function eof is written This is a Boolean expression that can be used to control a while loop, a dowhile loop, or an if-else statement.
This expression is satisfied (that is, is true) if the program has read past the end of the input file; otherwise, the expression above is not satisfied (that is, is false).
Since we usually want to test that we are not at the end of a file, a call to the member function eof is typically used with a not in front of it.
Recall that in Cplus_plus the symbol.
For example, consider the following statement: eof is usually.
The if-else statement will output the following, if the program has read beyond the end of the file: End of the file.
As another example of using the eof member function, suppose that the input stream in_stream has been connected to an input file with a call to open.
Then the entire contents of the file can be written to the screen with the following while loop: in_stream_0_get();.
Ending an input loop with the eof function 354 Chapter 6 / I/O Streams as an Introduction to Objects and Classes This while loop reads each character from the input file into the char variable using the member function get, and then writes the character to the screen.
After the program has passed the end of the file, the value of in_ stream_0_eof( ) changes from false to true.
So, changes from true to false and the loop ends.
Notice that in_stream_0_eof( ) does not become true until the program attempts to read one character beyond the end of the file.
For example, suppose the file contains the following (without any new- after the c): ab c This is actually the following list of four characters: ab<the new- character '\n'>c Deciding how to test for the end of an input file This loop reads an 'a' and writes it to the screen, then reads a 'b' and writes it to the screen, then reads the new- character '\n' and writes it to the screen, and then reads a 'c' and writes it to the screen.
At that point the loop will have read all the characters in the file.
However, in_stream_0_eof( ) will still be false.
The value of in_stream_0_eof( ) will not change from false to true until the program tries to read one more character.
That is why the while loop ends with in_stream_0_get(next).
The loop needs to read one extra character in order to end the loop.
There is a special end-of-file marker at the end of a file.
The member function eof does not change from false to true until this end-of-file marker is read.
That's why the example while loop could read one character beyond what you think of as the last character in the file.
However, this end-of-file marker is not an ordinary character and should not be manipulated like an ordinary character.
You can read this end-of-file marker but you should not write it out again.
If you write out the end-of-file marker, the result is unpredictable.
The system automatically places this end-of-file marker at the end of each file for you.
The next Programming Example uses the eof member function to determine when the program has read the entire input file.
You now have two methods for detecting the end of a file.
You can use the eof member function or you can use the method we described in the Programming Tip entitled "Checking for the End of a File_0_" In most situations you can use either method, but many programmers use the two different methods in different situations.
If you do not have any other reason to prefer one of these two methods, then use the following general rule: Use the eof member function when you are treating the input as text and reading the input with the get member function; use the other method when you are processing numeric data.
Suppose ins is a file input stream that has been connected to a file with the member function open.
Suppose your program has just read the last character in the file.
At this point, would ins_0_eof( ) evaluate to true or false.
Write the definition for a void function called text_to_screen that has one formal parameter called file_stream that is of type ifstream.
The precondition and postcondition for the function are as follows: //Precondition: The stream file_stream has been connected //to a file with a call to the member function open.
Programming Example   Editing a Text File The program discussed here is a very simple example of text editing applied to files.
It might be used by a software firm to update its advertising literature.
The firm has been marketing compilers for the C programming language and has recently introduced a  of Cplus_plus compilers.
This program can be used to automatically generate Cplus_plus advertising material from the existing C advertising material.
The program takes its input from a  that contains advertising copy that says good things about C and writes similar advertising copy about Cplus_plus in another.
The  that contains the C advertising copy is called cad_0_dat, and the new  that receives the Cplus_plus advertising copy is called cplusad_0_dat.
The program is shown in Display 6_0_8.
The program simply reads every character in the  cad_0_dat and copies the characters to the  cplusad_0_dat.
Every character is copied unchanged, except that when the uppercase letter 'C' is read from the input , the program writes the string "Cplus_plus" to the output.
This program assumes that whenever the letter 'C' occurs in the input , it names the C programming language; thus, this change is exactly what is needed to produce the updated advertising copy.
Notice that the  breaks are preserved when the program reads characters from the input  and writes the characters to the output.
The new- character '\n' is treated just like any other character.
It is read from the input  with the member function get, and it is written to the output using the insertion operator <<.
Chapter 6 / I/O Streams as an Introduction to Objects and Classes read the input.
If we instead use the extraction operator >> to read the input, the program would skip over all the whitespace, which means that none of the blanks and none of the new- characters '\n' would be read from the input , so they would not be copied to the output.
Also notice that the member function eof is used to detect the end of the input  and end the while loop.
Predefined Character Functions In text processing, you often want to convert lowercase letters to uppercase or vice versa.
The predefined function toupper can be used to convert a lowercase letter to an uppercase letter.
For example, toupper('a') returns 'A'.
If the argument to the function toupper is anything other than a lowercase letter, also returns 'A'.
The function tolower is similar except that it converts an uppercase letter to its lowercase version.
The functions toupper and tolower are in the library with the header cctype, so any program that uses these functions, or any other functions in this library, must contain the following  directive: # <cctype> 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 //Program to create a  called cplusad_0_dat that is identical to the //cad_0_dat, except that all occurrences of 'C' are replaced by "Cplus_plus".
There is no language as versatile as C, and C is fun to use.
There is no language as versatile as Cplus_plus, and Cplus_plus is fun to use.
Screen Output Begin editing files.
End of editing files.
Chapter 6 / I/O Streams as an Introduction to Objects and Classes Display 6_0_9 contains descriptions of some of the most commonly used functions in the library cctype.
The function isspace returns true if its argument is a whitespace character.
If the argument to isspace is not a whitespace character, then isspace returns false.
Thus, isspace(") returns true and isspace('a') returns false.
For example, the following code reads a sentence terminated with a period and echoes the string with all whitespace characters replaced with the symbol '-':.
Each character is assigned a number, and when the character is stored in a variable of type char, it is this number that is placed in the computer's memory.
In Cplus_plus you can use a value of type char as a number—for example, by placing it in a variable of type int.
You can also store a number of type int in a variable of type char (provided the number is not too large).
Thus, the type char can be used as the type for characters or as a type for small whole numbers.
Usually you need not be concerned with this detail and can simply think of values of type char as being characters and not worry about their use as numbers.
However, when using the functions in cctype, this detail can be important.
The functions toupper and tolower actually return values of type int rather than values of type char; that is, they return the number corresponding to the character we think of them as returning, rather than the character itself.
Thus, the following will not output the letter 'A', but will instead output the number that is assigned to 'A': << toupper('a');.
Char_Exp is an uppercase letter; otherwise, returns false.
Returns true provided Char_Exp is a lowercase letter; otherwise, returns false.
Char_Exp is a letter of the alphabet; otherwise, returns false.
Returns true provided Char_Exp is one of the digits '0' through '9'; otherwise, returns false.
Returns true provided Char_Exp is a whitespace character, such as the blank or new- symbol; otherwise, returns false.
Chapter 6 / I/O Streams as an Introduction to Objects and Classes In order to get the computer to treat the value returned by toupper or tolower as a value of type char (as opposed to a value of type int), you need to indicate that you want a value of type char.
One way to do this is to place the value returned in a variable of type char.
The following will output the character 'A', which is usually what we want: char  = toupper('a'); << ;.
Consider the following code (and assume that it is embedded in a complete and correct program and then run): << "Enter a  of input:\n";.
Enter a  of input: I'll see you at 10:30 AM.
Write some Cplus_plus code that will read a  of text and echo the  with all uppercase letters deleted.
Chapter Summary ■ A stream of type ifstream can be connected to a file with a call to the member function open.
Your program can then take input from that file.
Answers to Self-Test Exercises ■ An object is a variable that has functions associated with it.
These functions are called member functions.
A class is a type whose variables are objects.
A stream is an example of an object.
The types ifstream and ofstream are examples of classes.
An example with the stream  as the calling object and precision as the.
These output functions work the same for the stream , which is connected to the screen, and for output streams connected to files.
The member function get does not skip over whitespace.
Every output stream also has a member function named put that can be used to write one character to the output stream.
The member function eof works well for text processing.
However, when processing numeric data, you might prefer to test for the end of a file by using the other method we discussed in this chapter.
The type ifstream can be used for an input-file stream, and the type ofstream can be used for an output-file stream.
If you use ostream (spelled without the f) as the type for an output stream parameter, then the argument corresponding to that formal parameter can be either the stream  or an output-file stream of type ofstream (spelled with the f).
Answe rs to S e lf-T est Exer cises.
You need to replace the stream out_stream with the stream.
Note that you do not need to declare , you do not need to call open with , and you do not need to close.
By convention, the operating system uses a 1 as an indication of error status and 0 as an indication of success.
What is actually done is system-dependent.
Both files and program variables store values and can have values retrieved from them.
Program variables exist only while the program runs, whereas files may exist before a program is run and may continue to exist after a program stops.
In short, files may be permanent; variables are not.
Files provide the ability to store large quantities of data, whereas program variables do not provide quite so large a store.
We have seen the open, close, and fail member functions at this point.
The following illustrate their use.
This is the "starting over" the text describes at the beginning of this chapter.
The file must be closed and opened again.
This action puts the read position at the start of the file, ready to be read again.
The two names are the external file name and the stream name.
The external file name is the one used by the operating system.
It is the real name of the file, but it is used only in the call to the function open, which connects the file to a stream.
The stream name is a stream variable (typically of type ifstream or ofstream).
After the call to open, your program always uses the stream name as the name of the file.
Notice that a call to width or call to setw only lasts for one output item.
Each of the other spaces contains exactly two blank characters.
Chapter 6 / I/O Streams as an Introduction to Objects and Classes 15.
The output to the file stuff_0_dat will be exactly the same as the output given in the answer to Exercise 14.
Setting this flag causes floating-point numbers not to be displayed in e-notation, that is, not in scientific notation.
Setting this flag unsets ios::scientific.
Setting this flag causes floating-point numbers to be displayed in e-notation, that is, in scientific notation.
Setting this flag unsets ios::fixed.
Setting this flag causes the decimal point and trailing zeros to be always displayed.
Setting this flag causes a plus sign to be output before positive integer values.
Setting this flag causes subsequent output to be placed at the right end of any field that is set with the width member function.
That is, any extra blanks are put before the output.
Setting this flag unsets ios::left.
Setting this flag causes subsequent output to be placed at the left end of any field that is set with the width member function.
That is, any extra blanks are put after the output.
Setting this flag unsets ios::right.
You need to replace outstream with  and delete the open and close calls for outstream.
You do not need to declare , open , or close The # <fstream> directive has all the iostream members you need for screen I/O, though it does no harm, and may make the program clearer, to # <iostream>.
The two statements are equivalent.
Both of the statements output the value of the variable c.
The character that is "put back" into the input stream with the member function putback need not be the last character read.
If your program reads an 'a' from the input stream, it can use the putback function to put back a 'b'.
The complete dialogue is Enter a line of input: a b c d e f g a b END OF OUTPUT 26.
The complete dialogue is Enter a line of input: abcdef gh ace h Note that the output is simply every other character of the input, and note that the blank is treated just like any other character.
The complete dialogue is Enter a line of input: 0 1 2 3 4 5 6 7 8 9 10 11 01234567891 1 Be sure to note that only the '1' in the input string 10 is output.
This is because cin_0_get is reading characters, not numbers, and so it reads the input 10 as the two characters, '1' and '0'.
Since this code is written to echo only every other character, the '0' is not output.
Since the '0' is not output, the  character, which is a blank, is output, and so there is one blank in the output.
Similarly, only one of the two '1' characters in 11 is output.
If this is unclear, write the input on a sheet of paper and use a small square for the blank character.
Then, cross out every other character; the output shown above is what is left.
Chapter 6 / I/O Streams as an Introduction to Objects and Classes 28.
This code contains an infinite loop and will continue as long as the user continues to give it input.
The Boolean expression ( _0_= '\n') is always true because  is filled via the statement cin >> ; and this statement always skips the new- character '\n' (as well as any blanks).
The code will run and if the user gives no additional input, the dialogue will be as follows: Enter a  of input: 0 1 2 3 4 5 6 7 8 9 10 11 0246811 Notice that the code in Self-Test Exercise 27 used cin_0_get, so it reads every character, whether the character is a blank or not, and then it outputs every other character.
So the code in Self-Test Exercise 27 outputs every other character even if the character is a blank.
On the other hand, the code in this Self-Test Exercise uses cin and >>, so it skips over all blanks and considers only nonblank characters (which in this case are the digits '0' through '9').
Thus, this code outputs every other nonblank character.
The two '1' characters in the output are the first character in the input 10 and the first character in the input 11.
The complete dialogue is as follows: Enter a  of input: I'll see you at 10:30 AM.
I'll see you at 1 <END OF OUTPUT.
Chapter 6 / I/O Streams as an Introduction to Objects and Classes Note that you should use _0_isupper() and not use islower().
This is because islower() is false if  contains a character that is not a letter (such as the blank or comma symbol).
Practice Programs Practice Programs can generally be solved with a short program that directly applies the programming principles presented in this chapter.
Write a program that will search a file of numbers of type int and write the largest and the smallest numbers to the screen.
The file contains nothing but numbers of type int separated by blanks or  breaks.
If this is being done as a class assignment, obtain the file name from your instructor.
Write a program that takes its input from a file of numbers of type double and outputs the average of the numbers in the file to the screen.
The file contains nothing but numbers of type double separated by blanks and/or breaks.
If this is being done as a class assignment, obtain the file name from your instructor.
The median is the number that has the same number of data elements greater than the number as there are less than the number.
For purposes of this problem, you are to assume that the data is sorted (that is, is in increasing order).
The median is the middle element of the file if there are an odd number of elements, or the average of the two middle elements if the file has an even number of elements.
You will need to open the file, count the elements, close the file and calculate the location of the middle of the file, open the file again (recall the "start over" discussion in this chapter), count up to the file entries you need, and calculate the middle.
If your instructor has assigned this problem, ask for a data file to test your program with.
Otherwise, construct several files on your own, including one with an even number of data points, increasing, and one with an odd number, also increasing.
Find the three quartiles for the data file you used for part (a).
You also should recognize that you have done almost all the work toward finding Practice Programs 4.
Write a program that takes its input from a file of numbers of type double.
The program outputs to the screen the average and standard deviation of the numbers in the file.
The file contains nothing but numbers of type double separated by blanks and/or  breaks.
The standard deviation of a list of numbers n1, n2, n3, and so forth is defined as the square root of the average of the following numbers: (n1 – a)2, (n2 – a)2, (n3 – a)2, and so forth The number a is the average of the numbers n1, n2, n3, and so forth.
If this is being done as a class assignment, obtain the file name from your instructor.
Write a program that gives and takes advice on program writing.
The program starts by writing a piece of advice to the screen and asking the user to type in a different piece of advice.
The program then ends.
The  person to run the program receives the advice given by the person who last ran the program.
The advice is kept in a file, and the contents of the file change after each run of the program.
You can use your editor to enter the initial piece of advice in the file so that the first person who runs the program receives some advice.
Allow the user to type in advice of any length so that it can be any number of lines long.
The user is told to end his or her advice by pressing the Return key two times.
Your program can then test to see that it has reached the end of the input by checking to see when it reads two consecutive occurrences of the character '\n'.
Write a program that reads text from one file and writes an edited version of the same text to another file.
The edited version is identical to the unedited version except that every string of two or more consecutive blanks is replaced by a single blank.
Thus, the text is edited to remove any extra blank characters.
Your program should define a function that is called with the input- and output-file streams as arguments.
If this is being done as a class assignment, obtain the file names from your instructor.
Write a program that merges the numbers in two files and writes all the numbers into a third file.
Your program takes input from two different files and writes its output to a third file.
Each input file contains a list of numbers of type int in sorted order from the smallest to the largest.
After the program is run, the output file will contain all the numbers in the two input files in one longer list in sorted order from smallest to largest.
Your program should define a function that is called with the two input-file streams and the output-file stream as three arguments.
If this is being done as a class assignment, obtain the file names from your instructor.
Chapter 6 / I/O Streams as an Introduction to Objects and Classes Programming Projects Programming Projects require more problem-solving than Practice Programs and can usually be solved many different ways.
Visit www_0_myprogramminglab_0_com to complete many of these Programming Projects online and get instant feedback.
Write a program to generate personalized junk mail.
The program takes input both from an input file and from the keyboard.
The input file contains the text of a letter, except that the name of the recipient is indicated by the three characters #N#.
The program asks the user for a name and then writes the letter to a second file but with the three letters #N# replaced by the name.
The three-letter string #N# will occur exactly once in the letter.
When it encounters the three letters #N#, it then sends output to the screen asking for the name from the keyboard.
You should be able to figure out the rest of the details.
Your program should define a function that is called with the input- and output-file Harder version (using material in the optional section "File Names as Input"): Allow the string #N# to occur any number of times in the file.
In this case, the name is stored in two string variables.
For this version, assume that there is a first name and last name but no middle names or initials.
Write a program to compute numeric grades for a course.
The course records are in a file that will serve as the input file.
The input file is in exactly the following format: Each line contains a student's last name, then one space, then the student's first name, then one space, then ten quiz scores all on one line.
The quiz scores are whole numbers and are separated by one space.
Your program will take its input from this file and send its output to a second file.
The data in the output file will be the same as the data in the input file except that there will be one additional number (of type double) at the end of each line.
This number will be the average of the student's ten quiz scores.
If this is being done as a class assignment, obtain the file names from your instructor.
Use at least one function that has file streams as all or some of its arguments.
This amounts to giving the student a 0 for any missed quiz.
Programming Projects b_0_ The output file will contain a line (or lines) at the beginning of the file explaining the output.
Use formatting instructions to make the layout neat and easy to read.
Use at least two functions that have file streams as all or some of their arguments.
If this is being done as a class assignment, obtain the file names from your instructor.
Write a program that will compute the average word length (average number of characters per word) for a file that contains some text.
A word is defined to be any string of symbols that is preceded and followed by one of the following at each end: a blank, a comma, a period, the beginning of a line, or the end of a line.
Your program should define a function that is called with the input-file stream as an argument.
This function should also work with the stream cin as the input stream, although the function will not be called with cin as an argument in this program.
If this is being done as a class assignment, obtain the file names from your instructor.
Write a program that will correct a Cplus_plus program that has errors in which operator, << or >>, it uses with cin and cout.
The program replaces each (incorrect) occurrence of cin << with the corrected version cin >> and each (incorrect) occurrence of cout >> with the corrected version cout << For an easier version, assume that there is always exactly one blank space between any occurrence of cin and a following <<, and similarly assume that there is always exactly one blank space between each occurrence of cout and a following >>.
For a harder version, allow for the possibility that there may be any number of blanks, even zero blanks, between cin and << and between cout and >>.
In this harder case, the replacement corrected version has only one blank between the cin or cout and the following operator.
The program to be corrected is in one file and the corrected version is output 371.
Chapter 6 / I/O Streams as an Introduction to Objects and Classes to a second file.
Your program should define a function that is called with the input- and output-file streams as arguments.
If this is being done as a class assignment, obtain the file names from your instructor and ask your instructor whether you should do the easier version or the harder version.
Write a program that allows the user to type in any one-line question and then answers that question.
The program will not really pay any attention to the question, but will simply read the question line and discard all that it reads.
It always gives one of the following answers: I'm not sure, but I think you will find the answer in Chapter #N.
That question has puzzled philosophers for centuries.
I'm just a machine.
Think about it and the answer will come to you.
I used to know the answer to that question, but I've forgotten it.
The answer can be found in a secret place in the woods.
These answers are stored in a file (one answer per line), and your program simply reads the next answer from the file and writes it out as the answer to the question.
After your program has read the entire file, it simply closes the file, reopens the file, and starts down the list of answers again.
Whenever your program outputs the first answer, it should replace the two symbols #N with a number between 1 and 18 (including the possibility of 1 and 18).
In order to choose a number between 1 and 18, your program should initialize a variable to 18 and decrease the variable's value by 1 each time it outputs a number so that the chapter numbers count backward from 18 to 1.
When the variable reaches the value 0, your program should change its value back to 18.
Give the number 17 the name NUMBER_OF_CHAPTERS with a global named constant declaration using the const modifier.
This project is the same as Programming Project 6, except that in this project your program will use a more sophisticated method for choosing the answer to a question.
When your program reads a question, it counts the number of characters in the question and stores the number in a variable named count.
It then responds with answer number count %.
The first answer in the file is answer number 0, the next is answer number 1, then 2, and so forth.
Assume that the answer listed first in the file will always be the following, even if the answer file is changed: I'm not sure, but I think you will find the answer in Chapter #N.
When replacing the two characters #N with a number, use the number (count % NUMBER_OF_CHAPTERS + 1), where count is the variable discussed above, and NUMBER_OF_CHAPTERS is a global named constant defined to be equal to the number of chapters in this book.
This program numbers the lines found in a text file.
Write a program that reads text from a file and outputs each line to the screen and to another file preceded by a line number.
Print the line number at the start of the line and right-adjusted in a field of three spaces.
Follow the line number with a colon, then one space, then the text of the line.
You should get a character at a time and write code to ignore leading blanks on each line.
You may assume that the lines are short enough to fit within a line on the screen.
Otherwise, allow default printer or screen output behavior if the line is too long (that is, wrap or truncate).
A somewhat harder version determines the number of spaces needed in the field for the line numbers by counting lines before processing the lines of the file.
This version of the program should insert a new line after the last complete word that will fit within a 72-character line.
Write a program that computes all of the following statistics for a file and outputs the statistics to both the screen and to another file: the total number of occurrences of characters in the file, the total number of nonwhitespace characters in the file, and the total number of occurrences of letters in the file.
The text file babynames2012_0_txt, which is included in the source code for this book and is available online from the book's Web site, contains a list of the 1000 most popular boy and girl names in the United States for the year 2012 as compiled by the Social Security Administration.
This is a space-delimited file of 1000 entries in which the rank is listed first, followed by the corresponding boy name and girl name.
The most popular names are listed first and the least popular names are listed last.
For example, the file begins with 1 Jacob Sophia 2 Mason Emma 3 Ethan Isabella 373.
Chapter 6 / I/O Streams as an Introduction to Objects and Classes This indicates that Jacob is the most popular boy name and Sophia is the most popular girl name.
Mason is the second most popular boy name and Emma is the second most popular girl name.
Write a program that allows the user to input a name.
The program should then read from the file and search for a matching name among the girls and boys.
If a match is found, it should output the rank of the name.
The program should also indicate if there is no match.
For example, if the user enters the name "Justice," then the program should output: Justice is ranked 519 in popularity among boys.
Justice is ranked 518 in popularity among girls.
If the user enters the name "Walter," then the program should output: Walter is ranked 376 in popularity among boys.
Walter is not ranked among the top 1000 girl names.
VideoNote Solution to Programming Project 6_0_11 11.
To complete this problem you must have a computer that is capable of viewing Scalable Vector Graphics (SVG) files.
Your Web browser may already be able to view these files.
To test to see if your browser can display SVG files, type in the rectline_0_svg file below and see if you can open it in your Web browser.
If your Web browser cannot view the file, then you can search on the Web and download a free SVG viewer.
The graphics screen to draw an image uses a coordinate system in which (0, 0) is located in the upper-left corner.
The x coordinate increases to the right, and the y coordinate increases to the bottom.
Consequently, coordinate (100, 0) would be located 100 pixels directly toward the right from the upper-left corner, and coordinate (0, 100) would be located 100 pixels directly toward the bottom from the upper-left corner.
This is illustrated in the figure below.
The SVG format defines a graphics image using XML.
The specification for the image is stored in a text file and can be displayed by an SVG viewer.
Here is a sample SVG file that draws two rectangles and a line.
To view it, save it to a text file with the "_0_svg" extension, such as rectline_0_svg, and open it with your SVG viewer.
Programming Projects <_0_xml ="1_0_0" ="no"_0_>.
The lines that begins with <rect ="20"…draw a blue rectangle whose upper-left corner is at coordinate (20, 20) and whose  is 50 pixels and  is 250 pixels.
The lines that begin with <rect ="75"…draw a green rectangle (RGB color value of 0,255,0 is all green) whose upper-left corner is at coordinate (75, 100) and whose  is 150 pixels and  is 50 pixels.
Finally, the <line> tag draws a purple line from (0, 0) to (300, 300) with a  of 2.
Based on this example, write a program that inputs four nonnegative integer values and creates the SVG file that displays a simple bar chart that depicts the integer values.
Your program should scale the values so they are always drawn with a maximum  of 400 pixels.
For example, if your input values to graph were 20, 40, 60, and 120, you might generate a SVG file that would display as follows: 12.
Refer to Programming Project 11 for information about the SVG format.
Shown below is another example that illustrates how to draw circles, ellipses, and multiple lines: 375.
It is filled in with gold and has a border in green.
The <ellipse> tag draws an ellipse centered at (100, 200) with  radius of 30 and  radius of 100.
It is filled using purple with a black border.
The <polyline> tag draws a red line from (10, 10) to (40, 40) to (20, 100) to (120, 140).
The -opacity is set to 0, making the  of the polygon transparent.
Based on these examples and those presented in Project 18, write a program that creates an SVG image that draws a picture of your professor.
It can be somewhat abstract and simple.
If you wish to draw a fancier image, you can research the SVG picture format; there are additional tags that can draw using filters, gradients, and polygons.
Write a program that prompts the user to input the name of a text file and then outputs the number of words in the file.
You can consider a "word" to be any text that is surrounded by whitespace (for example, a space, carriage return, newline) or borders the beginning or end of the file.
The following is an old word puzzle: "Name a common word, besides tremendous, stupendous and horrendous, that ends in dous_0_" If you think about this for a while, it will probably come to you.
However, we can also solve this puzzle by reading a text file of English words and outputting the word if it contains "dous" at the end.
The text file "words_0_txt" contains 87, 314 English words, including the word that completes the puzzle.
This file is available online with the source code for the book.
Write a program that reads each word from the text file and outputs only those containing "dous" at the end to solve the puzzle.
Arrays 7_0_1 Introduction to Arrays 378 Declaring and Referencing Arrays 378 Programming Tip: Use for Loops with Arrays 380 Pitfall: Array Indexes Always Start with Zero 380 Programming Tip: Use a Defined Constant for the Size of an Array 380 Arrays in Memory 382 Pitfall: Array Index Out of Range 383 Initializing Arrays 386 Programming Tip: Cplus_plus11 Range-Based for Statement 386 7_0_2 Arrays in Functions 389 Indexed Variables as Function Arguments 389 Entire Arrays as Function Arguments 391 The const Parameter Modifier 394 Pitfall: Inconsistent Use of const Parameters 397 Functions That Return an Array 397 Case Study: Production Graph 398 Chapter Summary 432 Answers to Self-Test Exercises 433 7 7_0_3 Programming with Arrays 411 Partially Filled Arrays 411 Programming Tip: Do Not Skimp on Formal Parameters 414 Programming Example: Searching an Array 414 Programming Example: Sorting an Array 417 Programming Example: Bubble Sort 421 7_0_4 Multidimensional Arrays 424 Multidimensional Array Basics 425 Multidimensional Array Parameters 425 Programming Example: Two-Dimensional Grading Program 427 Pitfall: Using Commas Between Array Indexes 431 Practice Programs 437 Programming Projects 439 It is a capital mistake to theorize before one has data.
Introduction An array is used to process a collection of data all of which is of the same type, such as a list of temperatures or a list of names.
This chapter introduces the basics of defining and using arrays in Cplus_plus and presents many of the basic techniques used when designing algorithms and programs that use arrays.
Prerequisites This chapter uses material from Chapters 2 through 6.
For instance, the program might compute the highest test score and then output the amount by which each score falls short of the highest.
The highest score is not known until all five scores are read in.
Hence, all five scores must be retained in storage so that after the highest score is computed each score can be compared to it.
To retain the five scores, we will need something equivalent to five variables of type int.
We could use five individual variables of type int, but five variables are hard to keep track of, and we may later want to change our program to handle 100 scores; certainly, 100 variables are impractical.
An array is the perfect solution.
An array behaves like a list of variables with a uniform naming mechanism that can be declared in a single line of simple code.
For example, the names for the five individual variables we need might be score[0], score[1], score[2], score[3], and score[4].
The part that does not change—in this case, score—is the name of the array.
The part that can change is the integer in the square brackets, [ ].
Declaring and Referencing Arrays In Cplus_plus, an array consisting of five variables of type int can be declared as follows: int score[5]; This declaration is like declaring the following five variables to all be of type int: 378 7_0_1 Introduction to Arrays score[0], score[1], score[2], score[3], score[4] The individual variables that together make up the array are referred to in a variety of different ways.
We will call them indexed variables, though they are also sometimes called subscripted variables or elements of the array.
The number in square brackets is called an index or a subscript.
In Cplus_plus, indexes are numbered starting with 0, not with 1 or any other number except 0.
The number of indexed variables in an array is called the declared size of the array, or sometimes simply the size of the array.
When an array is declared, the size of the array is given in square brackets after the array name.
The indexed variables are then numbered (also using square brackets), starting with 0 and ending with the integer that is one less than the size of the array.
In our example, the indexed variables were of type int, but an array can have indexed variables of any type.
For example, to declare an array with indexed variables of type double, simply use the type name double instead of int in the declaration of the array.
All the indexed variables for one array are, however, of the same type.
This type is called the base type of the array.
Thus, in our example of the array score, the base type is int.
You can declare arrays and regular variables together.
For example, the following declares the two int variables next and max in addition to the array score: int next, score[5], max; An indexed variable like score[3] can be used anyplace that an ordinary variable of type int can be used.
Do not confuse the two ways to use the square brackets [ ] with an array name.
When used in a declaration, such as int score[5]; the number enclosed in the square brackets specifies how many indexed variables the array has.
When used anywhere else, the number enclosed in the square brackets tells which indexed variable is meant.
For example, score[0] through score[4] are indexed variables.
The index inside the square brackets need not be given as an integer constant.
You can use any expression in the square brackets as long as the expression evaluates to one of the integers 0 through the integer that is one less than the size of the array.
For example, the following will set the value of score[3] equal to 99: int  = 2; score[ + 1] = 99; Although they may look different, score[+1] and score[3] are the same indexed variable in the code above.
The identity of an indexed variable, such as score[i], is determined by the value of its index, which in this instance is i.
Thus, you can write programs 379.
Chapter 7 / Arrays that say things such as "do such and such to the ith indexed variable," where the value of  is computed by the program.
For example, the program in Display 7_0_1 reads in scores and processes them in the way we described at the start of this chapter.
Array Indexes Always Start with Zero The indexes of an array always start with 0 and end with the integer that is one less than the size of the array.
It only works for classes that have exactly five students.
Most classes do not have exactly five students.
One way to make a program more versatile is to use a defined constant for the size of each array.
For example, the program in Display 7_0_1 could be rewritten to use the following defined constant: const int  = 5;.
Of course, all places that have a 5 for the size of the array should also be changed to have  instead of 5.
If these changes are made to the program (or better still, if the program had been written this way in the first place), then the program can be rewritten to work for any number of students by simply changing the one line that defines the constant.
Note that on many compilers you cannot use a variable for the array size, such as the following:.
Display 7_0_1   Program Using an Array 1 2 3.
Sample Dialogue Enter 5 scores: 5 9 2 10 6 The highest score is 10 The scores and their differences from the highest are: 5 off by 5 9 off by 1 2 off by 8 10 off by 0 6 off by 4 381.
Chapter 7 / Arrays Some but not all compilers will allow you to specify an array size with a variable in this way.
However, for the sake of portability you should not do so, even if your compiler permits it.
A computer's memory consists of a list of numbered locations called bytes_0_1 The number of a byte is known as its address.
A simple variable is implemented as a portion of memory consisting of some number of consecutive bytes.
The number of bytes is determined by the type of the variable.
Thus, a simple variable in memory is described by two pieces of information: an address in memory (giving the location of the first byte for that variable) and the type of the variable, which tells how many bytes of memory the variable requires.
When we speak of the address of a variable, it is this address we are talking about.
When your program stores a value in the variable, what really happens is that the value (coded as 0s and 1s) is placed in those bytes of memory that are assigned to that variable.
Similarly, when a variable is given as a (call-by-reference) argument to a function, it is the address of the variable that is actually given to the calling function.
Now let's move on to discuss how arrays are stored in memory.
Array indexed variables are represented in memory the same way as ordinary variables, but with arrays there is a little more to the story.
The locations of the various array indexed variables are always placed next to one another in memory.
For example, consider the following: int a[6]; When you declare this array, the computer reserves enough memory to hold six variables of type int.
Moreover, the computer always places these variables one after the other in memory.
The computer then remembers the address of indexed variable a[0], but it does not remember the address of any other indexed variable.
When your program needs the address of some other indexed variable, the computer calculates the address for this other indexed variable from the address of a[0].
For example, if you start at the address of a[0] and count past enough memory for three variables of type int, then you will be at the address of a[3].
To obtain the address of a[3], the computer starts with the address of a[0] (which is a number).
The computer then adds the number of bytes needed to hold three variables of type int to the number for the address of a[0].
The result is the address of a[3].
This implementation is diagrammed in Display 7_0_2.
Many of the peculiarities of arrays in Cplus_plus can be understood only in terms of these details about memory.
For example, in the next Pitfall section, we use these details to explain what happens when your program uses an illegal array index.
An array declaration, of the form shown, will define Declared_Size indexed variables, namely, the indexed variables Array_Name[0] through Array_Name[Declared_Size-1].
Each indexed variable is a variable of type Type_Name.
The array a consists of the indexed variables a[0], a[1], and a[2], all of type double.
The array b consists of the indexed variables b[0], b[1], b[2], b[3], and b[4], also all of type double.
You can combine array declarations with the declaration of simple variables such as the variable one_grade shown above.
Pitfall Array Index Out of Range The most common programming error made when using arrays is attempting to reference a nonexistent array index.
For example, consider the following array declaration: int a[6]; When using the array a, every index expression must evaluate to one of the integers 0 through 5.
For example, if your program contains the indexed variable a[], the  must evaluate to one of the six integers 0, 1, 2, 3, 4, or 5.
If  evaluates to anything else, that is an error.
When an index expression evaluates to some value other than those allowed by the array declaration, the index is said to be out of range or simply illegal.
On most systems, the result of an illegal array index is that your program will do something wrong, possibly disastrously wrong, and will do so without giving you any warning.
Attackers have also exploited this type of error to break into software.
An out-of-range programming error could potentially compromise the entire system, so take great care to avoid this error.
In 2011, the Common Weakness Enumeration (CWE)/SANS Institute identified this type of error as the third most dangerous programmer error.
VideoNote Array Walkthrough 383.
There is no indexed variable a[6], but if there were one, it would be here.
For example, suppose your system is typical, the array a is declared as shown, and your program contains the following: a[] = 238; Now, suppose the value of , unfortunately, happens to be 7.
The computer proceeds as if a[7] were a legal indexed variable.
The computer calculates the address where a[7] would be (if only there were an a[7]), and places the value 238 in that location in memory.
However, there is no indexed variable a[7], and the memory that receives this 238 probably belongs to some other variable, maybe a variable named more_stuff.
So the value of more_stuff has been unintentionally changed.
The situation is illustrated in Display 7_0_2.
Array indexes get out of range most commonly at the first or last iteration of a loop that processes the array.
So, it pays to carefully check all array processing loops to be certain that they begin and end with legal array indexes.
In practice it is more difficult, because there are often subtle or unanticipated ways to change an index variable.
For example, consider the following code that inputs some numbers into an array:.
This program suffers from two errors.
First, the loop has an off-by-one error.
By starting at index 0 and continuing up to and including num the loop will input num+1 numbers instead  num numbers.
As long as a value less than ten is entered for num then you might not notice the problem.
The program won't crash because the numbers will all be entered with the addition  one extra  which still fits in the array.
However, if 10 is entered for num then the eleventh  will be stored at index a[10] which is one off the end  the array.
To fix this problem the loop should be written as: Another problem is the lack  input validation.
A malicious or mischievous user could enter 100 as the   values to enter; the loop would then simply execute 100 times and input data well past the end the array (the program may crash before looping 100 times as numbers past the end  the array could cause mischief).
To address this problem we can validate that the user's input is within valid range: << "How many numbers.
For example, on most systems a signed short can only store a  up 385.
Entering a larger value results in overflow which could store 0 or a negative value in.
Although the for loop will not run if  is zero or negative the program would erroneously pass the if statement.
We explore this type  error again in Chapter 8.
When initializing the array, the values for the various indexed variables are enclosed in braces and separated with commas.
For example, int [3] = {2, 12, 1};.
If you list fewer values than there are indexed variables, those values will be used to initialize the first few indexed variables, and the remaining indexed variables will be initialized to a 0  the array base type.
In this situation, indexed variables not provided with initializers are initialized to 0.
However, arrays with no initializers and other variables declared within a function definition, including the main function  a program, are not initialized.
Although array indexed variables (and other variables) may sometimes be automatically initialized to 0, you cannot and should not count on it.
If you initialize an array when it is declared, you can omit the size  the array, and the array will automatically be declared to have the minimum size needed for the initialization values.
For example, the following declaration int [ ] = {5, 12, 11};.
The syntax is shown below: { // varname is successively set to each element in the array.
This will output: 2468 When defining the variable that will iterate through the array we can use the same modifiers that are available when defining a parameter for a function.
The example we used above for variable x is equivalent to pass-by-value.
If we change x inside the loop it doesn't change the array.
We could define x as pass by reference using & and then changes to x will be made to the array.
We could also use const to indicate that the variable can't be changed.
The example below increments every element in the array and then outputs them.
We used the auto datatype in the output loop to automatically determine the   element inside the array.
This will output: 3579.
The range-based for loop is especially convenient when iterating over vectors, which are introduced in Chapter 8, and iterating over containers, which are discussed in Chapter 18.
Describe the difference in the meaning  int a[5] and the meaning a[4].
What is the meaning  the [5] and [4] in each case.
In the array declaration double score[5]; state the following: a.
The array name The base c.
The declared size  the array d.
The range  values that an index for this array can have e_0_ One  the indexed variables (or elements)  this array 387.
Suppose we expect the elements  the array  to be ordered so that [0] ≤ [1] ≤ [2] ≤ _0__0_.
However, to be safe we want our program to test the array and issue  warning in case it turns out that some elements are out  order.
The following code is supposed to output such  warning, but it contains  bug.
Write some Cplus_plus code that will fill an array  with 20 values of  int read in from the keyboard.
You need not write  full program, just the code to do this, but do give the declarations for the array and for all variables.
Suppose you have the following array declaration in your program: int your_array[7]; Also, suppose that in your implementation of Cplus_plus, variables of  int use 2 bytes of memory.
When you run your program, how much memory will this array consume.
Suppose that when you run your program, the system assigns the memory address 1000 to the indexed variable your_array[0].
What will be the address of the indexed variable your_array[3].
We first discuss array indexed variables as arguments to functions.
Indexed Variables as Function Arguments An indexed variable can be an argument to  function in exactly the same way that any variable can be an argument.
For example, suppose  program contains the following declarations: int , n, [10];.
Chapter 7 / Arrays The indexed expression is evaluated in order to determine exactly which indexed variable is given as the argument.
Display 7_0_3 contains an example of indexed variables used as function arguments.
The program shown gives five additional vacation days to each of three employees in  small business.
The program is extremely simple, but it does illustrate how indexed variables are used as arguments to functions.
Notice the function adjust_days.
This function has  formal parameter called old_days that is of  int.
In the main body of the program, this function is called with the argument vacation[number] for various values of number.
Notice that there was nothing special about the formal parameter old_days.
It is just an ordinary formal parameter of  int, which is the base  of the array vacation.
In Display 7_0_3 the indexed variables are call-by-value arguments.
The same remarks apply to call-by-reference arguments.
An indexed variable can be  call-by-value argument or  call-by-reference argument.
However,  formal parameter for an entire array is neither call-by-value parameter nor  call-by-reference parameter; it is  new  of formal parameter referred to as an array parameter.
Let's start with an example.
VideoNote Passing Arrays to Functions 392 Chapter 7 / Arrays The function defined in Display 7_0_4 has one array parameter, , which will be replaced by an entire array when the function is called.
It also has one ordinary call-by-value parameter (size) that is assumed to be an integer value equal to the size of the array.
This function fills its array argument (that is, fills all the array's indexed variables) with values typed in from the keyboard, and then the function outputs  message to the screen telling the index of the last array index used.
The formal parameter int [ ] is an array parameter.
The square brackets, with no index expression inside, are what Cplus_plus uses to indicate an array parameter.
An array parameter is not quite  call-by-reference parameter, but for most practical purposes it behaves very much like  call-by-reference parameter.
Let's go  this example in detail to see how an array argument works in this case.
For example, the following is an acceptable function call: int score[5],  = 5; fill_up(score, ); This call to fill_up will fill the array score with five integers typed in at the keyboard.
Notice that the formal parameter [ ] (which is used in the function declaration and the heading of the function definition) is given with square brackets, but no index expression.
Function Definition 1 2 3 4 5 6 7 8 9 10.
What happens to the array argument score in this function call.
Very loosely speaking, the argument score  plugged in for the formal array parameter  in the body of the function, and then the function body  executed.
The formal parameter    different  of parameter from the ones we have seen before now.
The formal parameter   merely  placeholder for the argument score.
When the function fill_up  called with score as the array argument, the computer behaves as if  were replaced with the corresponding argument score.
When an array  used as an argument in function call, any action that  performed on the array parameter  performed on the array argument, so the values of the indexed variables of the array argument can be changed by the function.
If the formal parameter in the function body  changed (for example, with  cin statement), then the array argument will be changed.
So far it looks like an array parameter  simply  call-by-reference parameter for an array.
That  close to being true, but an array parameter slightly different from  call-by-reference parameter.
To help explain the difference, let's review some details about arrays.
Recall that an array  stored as  contiguous chunk of memory.
For example, consider the following declaration for the array score: int score[5]; When you declare this array, the computer reserves enough memory to hold five variables of type int, which are stored one after the other in the computer's memory.
The computer does not remember the addresses of each of these five indexed variables; it remembers only the address of indexed variable score[0].
For example, when your program needs score[3], the computer calculates the address of score[3]from the address of score[0].
The computer knows that score[3]  located three int variables past score[0].
Thus, to obtain the address of score[3], the computer takes the address of score[0] and adds   that represents the amount of memory used by three int variables; the result  the address of score[3].
Arrays in memory.
Array argument Different array arguments can be plugged in for the same array parameter of the first indexed variable, the base type of the array (which determines how much memory each indexed variable uses), and the  of the array (that , the number of indexed variables).
When an array  used as an array argument to a function, only the first of these three parts  given to the function.
When an array argument  plugged in for its corresponding formal parameter, all that  plugged in  the address of the array's first indexed variable.
The base type of the array argument must match the base type of the formal parameter, so the function also knows the base type of the array.
However, the array argument does not tell the function the  of the array.
When the code in the function body  executed, the computer knows where the array starts in memory and how much memory each indexed variable uses, but(unless you make special provisions) it does not know how many indexed variables the array has.
That  why it  critical that you always have another int argument telling the function the  of the array.
That  also why an array parameter not the same as a call-by-reference parameter.
You can think of an array parameter as a weak form of call-by-reference parameter in which everything about the array  told to the function except for the  of the array_0_2 These array parameters may seem a little strange, but they have at least one very nice property as a direct result of their seemingly strange definition.
This advantage  best illustrated by again looking at our example of the function fill_up given in Display 7_0_4.
That same function can be used to fill an array of any , as long as the base type of the array  int.
For example, suppose you have the following array declarations: int score[5], time[10];.
The const Parameter Modifier When you use an array argument in a function call, the function can change the values stored in the array.
However, in a complicated function definition, you might write code that inadvertently changes one or more of the values stored in an array, even though the array should not be changed at all.
As a precaution, you can tell the compiler that you do not 2 If you have heard of pointers, this will sound like pointers, and indeed an array argument passed by passing a pointer to its first (zeroth) index variable.
We will discuss this in Chapter 9.
If you have not yet learned about pointers, you can safely ignore this footnote.
To tell the compiler that an array argument should not be changed by your function, you insert the modifier const before the array parameter for that argument position.
An array parameter that  modified with a const called a constant array parameter.
For example, the following function outputs the values in an array but does not change the values in the array: //Precondition: size_of_a  the declared  of the array a.
It  a new  of argument known as an array argument.
When an array argument  plugged in for an array parameter, all that given to the function  the address in memory of the first indexed variable of the array argument (the one indexed by 0).
The array argument does not tell the function the size of the array.
Therefore, when you have an array parameter to a function, you normally must also have another formal parameter of type int that gives the size of the array (as in the example below).
An array argument is like a call-by-reference argument in the following way: If the function body changes the array parameter, then when the function is called, that change is actually made to the array argument.
Thus, a function can change the values of an array argument (that is, can change the values of its indexed variables).
Chapter 7 / Arrays The syntax for a function declaration with an array parameter is as follows: syntax Type_Returned Function_Name(_0__0__0_, Base_Type Array_ Name[],_0__0__0_);.
For example, the following is a version of the function show_the_world that contains a mistake that inadvertently changes the value of the array argument.
Fortunately, this version of the function definition includes the modifier const, so that an error message will tell us that the array a is changed.
This error message will help to explain the mistake: //Precondition: size_of_a is the declared size of the array a.
If we had not used the const modifier in this function definition and if we made the mistake shown, the function would compile and run with no error messages.
However, the code would contain an infinite loop that continually increments a[0] and writes its new  to the screen.
The problem with this incorrect version of show_the_world is that the wrong item is incremented in the for loop.
The indexed variable a[] is incremented, but it should be the index  that is incremented.
In this incorrect version, the index  starts with the  0 and that  is never changed.
When the indexed variable a[] is incremented, that changes a  in the array, and since we included the modifier const, the computer will issue a warning message.
That error message should serve as a clue to what is wrong.
You normally have a function declaration in your program in addition to the function definition.
When you use the const modifier in a function definition, you must also use it in the function declaration so that the function heading and the function declaration are consistent.
Pitfall Inconsistent Use of const Parameters The const parameter modifier is an all-or-nothing proposition.
If you use it for one array parameter of a particular type, then you should use it for every other array parameter that has that type and that is not changed by the function.
Consider the definition of the function show_difference, which is given below along with the declaration of a function used in the definition: double compute_average(int a[ ], int number_used); //Returns the  of the elements in the first number_used.
This code will generate an error message or warning message with most compilers.
The function compute_average does not change its parameter a.
However, when the compiler processes the function definition for show_ change the  of its parameter a.
This is because, when it is translating the function definition for show_difference, all the compiler knows about the function compute_average is the function declaration for compute_ , and the function declaration does not contain a const to tell the compiler that the parameter a will not be changed.
Thus, if you use const with the parameter a in the function show_difference, then you should also use the modifier const with the parameter a in the function compute_ The function declaration for compute_average should be as follows: double compute_average(const int a[ ], int number_used); ■ Functions That Return an Array A function may not return an array in the same way that it returns a of type int or double.
There is a way to obtain something more or less 397.
Chapter 7 / Arrays equivalent to a function that returns an array.
The thing to do is to return a pointer to the array.
However, we have not yet covered pointers.
We will discuss returning a pointer to an array when we discuss the interaction of arrays and pointers in Chapter 9.
Until then, you have no way to write a function that returns an array.
Case Study Production Graph In this case study we use arrays in the top-down design of a program.
We use both indexed variables and entire arrays as arguments to the functions for subtasks.
Problem Definition The Apex Plastic Spoon Manufacturing Company has commissioned us to write a program that will display a bar graph showing the productivity of each of its four manufacturing plants for any given week.
Plants keep separate production figures for each department, such as the teaspoon department, soup spoon department, plain cocktail spoon department, colored cocktail spoon department, and so forth.
Moreover, each plant has a different number of departments.
For example, only one plant manufactures colored cocktail spoons.
The input is entered plant-by-plant and consists of a list of giving the production for each department in that plant.
The output will consist of a bar graph in the following form: Plant Plant Plant Plant #1 #2 #3 #4 ********** ************* ******************* ***** Each asterisk represents 1000 units of output.
We decide to read in the input separately for each department in a plant.
Since departments cannot produce a negative number of spoons, we know that the production figure for each department will be nonnegative.
Hence, we can use a negative number as a sentinel  to mark the end of the production  for each plant.
Since output is in units of 1000, it must be scaled by dividing it by 1000.
This presents a problem since the computer must display a whole number of asterisks.
It cannot display 1_0_6 asterisks for 1600 units.
We will thus round to the nearest 1000th.
Thus, 1600 will be the same as 2000 and will produce two asterisks.
A precise statement of the program's input and output is as follows.
Input There are four manufacturing plants numbered 1 through 4.
The following input is given for each of the four plants: a list of  giving the production for each department in that plant.
The list is terminated with a negative number that serves as a sentinel value.
Each asterisk in the bar graph equals 1000 units.
The production of each plant is rounded to the nearest 1000 units.
Analysis of the Problem We will use an array called production, which will hold the total production for each of the four plants.
In Cplus_plus, array indexes always start with 0.
But since the plants are numbered 1 through 4, rather than 0 through 3, we will not use the plant number as the array.
Instead, we will place the total production for plant number n in the indexed variable production[n−1].
The total output for plant number 1 will be held in production[0], the figures for plant 2 will be held in production[1], and so forth.
Since the output is in thousands of units, the program will scale the values of the array elements.
If the total output for plant number 3 is 4040 units, then the value of production[2] will initially be set to 4040.
This value of 4040 will then be scaled to 4 so that the value of production[2] is changed to 4, and four asterisks will be output in the graph to represent the output for plant number 3.
The task for our program can be divided into the following subtasks: ■ input_data: Read the input data for each plant and set the value of the indexed variable production[plant_number-1] equal to the total production for that plant, where plant_number is the number of the plant.
The entire array production will be an argument for the functions that carry out these subtasks.
As is usual with an array parameter, this means we must have an additional formal parameter for the size of the array, which in this case is the same as the number of plants.
We will use a defined constant for the number of plants, and this constant will serve as the size of the array production.
The main part of our program, together with the function declarations for the functions that perform the subtasks and the defined constant for the number of plants, is shown in Display 7_0_5.
Notice that, since there is no reason to change the array parameter to the function graph, we have made that array parameter a constant parameter by adding the const parameter modifier.
The material in Display 7_0_5 is the outline for our program, and if it is in a separate file, that file can be compiled so that we can check for any syntax errors in this outline before we go on to define the functions corresponding to the function declarations shown.
Having compiled the file shown in Display 7_0_5, we are ready to design the implementation of the functions for the three subtasks.
For each of these three functions, we will design an algorithm, write the code for the function, and test the function before we go on to design the next function.
Algorithm Design for input_data The function declaration and descriptive comment for the function input_ data is shown in Display 7_0_5.
As indicated in the body of the main part of our program (also shown in Display 7_0_5), when input_data is called, the formal array parameter a will be replaced with the array production, and since the last plant number is the same as the number of plants, the formal parameter last_plant_number will be replaced by NUMBER_OF_PLANTS.
The algorithm for input_data is straightforward: For plant_number equal to each of 1, 2, through last_plant_number do the following: Read in all the data for plant whose number is.
Sum the numbers.
Set production[ -1] equal to that total.
The code is routine since all the work is done by the function get_total, which we still need to design.
But before we move on to discuss the function get_total, let's observe a few things about the function input_data.
Notice that we store the figures for plant number  in the indexed variable with index -1; this is because arrays always start with index 0, while the plant numbers start with 1.
Also, notice that we use an indexed variable for the argument to the function get_total.
The function get_total really does all the work for the function input_data.
The function get_total does all the input work for one plant.
It reads the production figures for that plant, sums the figures, and stores the total in the indexed variable for that plant.
But get_total does not need to know that its argument is an indexed variable.
To a function such as get_total, an indexed variable is just like any other variable of type int.
Thus, get_total will have an ordinary call-by-reference parameter of type int.
That means that 7_0_2 Arrays in Functions 401 Display 7_0_5   Outline of the Graph Program 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36.
The function get_total reads in a list of numbers ended with a sentinel value, sums the numbers as it reads them in, and sets the value of its argument, which is a variable of type int, equal  this sum.
Display 7_0_6 shows the function definitions for both get_total and input_data.
The functions are embedded in a simple test program.
Testing input_data Every function should be tested in a program in which it is the only untested function.
The function input_data includes a call  the function get_total.
Therefore, we should test get_total in a driver program of its own.
Once get_total has been completely tested, we can use it in a program, like the one in Display 7_0_6,  test the function input_data.
When testing the function input_data, we should  tests with all possible kinds of production figures for a plant.
We should  a plant has no production figures (as we did for plant 4 in Display 7_0_6); we should  a test for a plant with only one production figure (as we did for plant 3 in Display 7_0_6); and we should  a test for a plant with more than one production figure (as we did for plants 1 and 2 in Display 7_0_6).
We should test for both nonzero and zero production figures, which is why we included a 0 in the input list for plant 2 in Display 7_0_6.
Algorithm Design for scale The function scale changes the value of each indexed variable in the array production so  it shows the number of asterisks  print out.
Since there should be one asterisk for every 1000 units of production, the value of each indexed variable must be divided by 1000_0_0.
Then  get a whole number of asterisks, this number is rounded  the nearest integer.
This method can be used  scale the values in any array a of any size, so the function declaration for scale, shown in Display 7_0_5 and repeated here, is stated in terms of an arbitrary array a of some arbitrary size: void scale(int a[ ], int size);.
Coding for scale The algorithm for scale translates into the Cplus_plus code given next, where round is a function we still need  define.
The function round takes one argument of type double and returns a type int   is the integer nearest  its argument; is, the function round will round its argument  the nearest whole number.
Sample Dialogue Enter production data for plant  1 Enter  of units produced by each department.
Append a negative  to the end of the list.
Append a negative  to the end of the list.
Append a negative  to the end of the list.
Append a negative  to the end of the list.
Notice that we divided by 1000_0_0, not by 1000 (without the decimal point).
If we had divided by 1000, we would have performed integer division.
It is true that we want an integer for the final answer after rounding, but we want 2600 divided by 1000 to produce 3, not 2, when it is rounded to a whole.
We now turn to the definition of the function round, which rounds its argument to the nearest integer.
The code for the function round, as well as that for scale, is given in Display 7_0_7.
The code for round may require a bit of explanation.
The function round uses the predefined function floor from the library with the header file cmath.
The function floor returns the whole  just below its argument.
In fact, for any  that is greater than or equal to 2_0_0 and strictly less than 2_0_5, that  plus 0_0_5 will be less than 3_0_0, and so floor applied to that  plus 0_0_5 will return 2_0_0.
Thus, round applied to any  that is greater than or equal to 2_0_0 and strictly less than 2_0_5 will return 2.
Chapter 7 / Arrays Display 7_0_7   The Function scale 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40.
Enter 4 numbers to scale: 2600 999 465 3501 Values scaled to the  of 1000s are: 3 1 0 4 7_0_2 Arrays in Functions 407 which is floor(3_0_1) and  is 3_0_0.
In fact, for any   is greater than or equal to 2_0_5 and less than or equal to 3_0_0,   plus 0_0_5 will be greater than 3_0_0.
Thus, round called with any   is greater than or equal to 2_0_5 and less than or equal to 3_0_0 will return 3.
Thus, round works correctly for all arguments between 2_0_0 and 3_0_0.
Clearly, there is nothing special about arguments between 2_0_0 and 3_0_0.
A similar argument applies to all nonnegative numbers.
So, round works correctly for all nonnegative arguments.
Testing scale Display 7_0_7 contains a demonstration program for the function scale, but the testing programs for the functions round and scale should be more elaborate than this simple program.
In particular, they should allow you to retest the tested function several times rather than just once.
We will not give the complete testing programs, but you should first test round (which is used by scale) in a driver program of its own, and then test scale in a driver program.
The program to test round should test arguments  are 0, arguments round up (like 2_0_6), and arguments  round down like 2_0_3.
The program to test scale should test a similar variety of values for the elements of the array.
The Function graph The complete program for producing the desired bar graph is shown in Display 7_0_8.
We have not taken you step-by-step through the design of the function graph because it is quite straightforward.
Sample Dialogue This program displays a graph showing production for each plant in the company.
Enter production data for plant  1 Enter  of units produced by each department.
Append a negative  to the end of the list.
Append a negative  to the end of the list.
Append a negative  to the end of the list.
Append a negative  to the end of the list.
Chapter 7 / Arrays S el f -T est Exe rc is es 13.
Write a function definition for a function called one_more, which has a formal parameter for an array of integers and increases the value of each array element by one.
Add any other formal parameters that are needed.
Consider the following function definition:.
Write  function named out_of_order that takes as parameters an array of double s and an int parameter named size and returns  value of type int.
This function will test this array for being out of order, meaning that the array violates the following condition: [0] <= [1] <= [2] <= _0__0_.
The function returns −1 if the elements are not out of order; otherwise, it will return the  of the first element of the array that is out of order.
For example, consider the declaration.
If the array were sorted, the function would return −1.
In this section we discuss partially filled arrays and give  brief introduction to sorting and searching of arrays.
This section includes no new  about the Cplus_plus language, but does include more practice with Cplus_plus array parameters.
Partially Filled Arrays Often the exact size needed for an array is not known when  program is written, or the size may vary from one run of the program to another.
One common and easy way to handle this situation is to declare the array to be of the largest size the program could possibly need.
The program is then free to use as much or as little of the array as is needed.
Partially filled arrays require some care.
The program must keep track of how much of the array is used and must not reference any indexed variable that has not been given  value.
The program in Display 7_0_9 illustrates this point.
The program reads in  list of golf scores and shows how much each score differs from the average.
This program will work for lists as short as one score, as long as ten scores, and for any length in between.
The scores are stored in the array score, which has ten indexed variables, but the program uses only as much of the array as it needs.
The variable number_used keeps track of how many elements are stored in the array.
The elements (that is, the scores) are stored in positions score[0] through score[number_used - 1].
The details are very similar to what they would be if number_used were the declared size of the array and the entire array were used.
In particular, the variable number_used usually must be an argument to any function that manipulates the partially filled array.
Since the argument number_used (when used properly) can often ensure that the function will not reference an illegal array , this sometimes (but not always) eliminates the need for an argument that gives the declared size of the array.
For example, the functions show_difference and compute_average use the argument number_used to ensure that only legal array indexes are used.
However, the function fill_ array needs to know the maximum declared size for the array so that it does not overfill the array.
Sample Dialogue This program reads golf  and shows how much each differs from the.
Enter golf : Enter up to 10 nonnegative whole numbers.
Mark the end of the list with a negative number.
Do Not Skimp on Formal Parameters Notice the function fill_array in Display 7_0_9.
When fill_array is called, the declared array size MAX_NUMBER_SCORES is given as one of the arguments, as shown in the following function call from Display 7_0_9: fill_array(score, MAX_NUMBER_SCORES, ); You might protest that MAX_NUMBER_SCORES is a globally defined constant and so could be used in the definition of fill_array without the need to make it an argument.
You would be correct, and if we did not use fill_array in any program other than the one in Display 7_0_9, we could get by without making MAX_NUMBER_SCORES an argument to fill_array.
However, fill_array is a generally useful function that you may want to use in several different programs.
We do in fact also use the function fill_array in the program in Display 7_0_10, discussed in the  subsection.
In the program in Display 7_0_10, the argument for the declared array size is a different named global constant.
If we had written the global constant MAX_NUMBER_SCORES into the body of the function fill_array, we would not have been able to reuse the function in the program in Display 7_0_10.
For example, the array may contain the student numbers for all students in a given course.
To tell whether a particular student is enrolled, the array is searched to see if it contains the student's number.
The program in Display 7_0_10 fills an array and then searches the array for values specified by the user.
A real application program would be much more elaborate, but this shows all the essentials of the sequential search algorithm.
The sequential search algorithm is the most straightforward searching algorithm you could imagine: The program looks at the array elements in the order first to last to see if the target number is equal to any of the array elements.
In Display 7_0_10, the function search is used to search the array.
When searching an array, you often want to know more than simply whether or not the target value is in the array.
If the target value is in the array, you often want to know the  of the indexed variable holding that target value, since the may serve as a guide to some additional information about the target value.
Therefore, we designed the function search to return an  giving the location of the target value in the array, provided the target value is, in fact, in the array.
If the target value is not in the array, search returns -1.
Let's look at the function search in a little more detail.
The function search uses a while loop to check the array elements one after the other to see whether any of them equals the target value.
The variable 7_0_3 Programming with Arrays 415 1 2 3.
Sample Dialogue Enter up to 20 nonnegative whole numbers.
Mark the end of the list with a negative number.
Search again_0_(y/n followed by Return): y Enter a number to search for: 40 40  stored in array position 3.
Search again_0_(y/n followed by Return): y Enter a number to search for: 42 42  not on the list.
Search again_0_(y/n followed by Return): n End of program.
Even if we used fill_array in only one program, it can still be a good idea to make the declared array size an argument to fill_array.
Displaying the declared size of the array as an argument reminds us that the function needs this information in a critically important way.
In this section we describe a function called sort that sorts a partially filled array of numbers so that they are ordered from smallest to largest.
The procedure sort has one array parameter a.
The array a will be partially filled, so there  an additional formal parameter called , which tells how many array positions are used.
Thus, the declaration and precondition for the function sort is void sort(int a[], int ); //:  <= declared size of the array a.
The function sort rearranges the elements in array a so that after the function call is completed the elements are sorted as follows: a[0] ≤ a[1] ≤ a[2] ≤ _0__0_.
It is one of the easiest of the sorting algorithms to understand.
One way to design an algorithm is to rely on the definition of the problem.
In this case the problem is to sort an array a from smallest to largest.
That means rearranging the values so that a[0] is the smallest, a[1] the next smallest, and so forth.
That definition yields an outline for the selection sort algorithm: Place the indexth smallest element in a[] There are many ways to realize this general approach.
The details could be developed using two arrays and copying the elements from one array to the other in sorted order, but one array should be both adequate and economical.
Therefore, the function sort uses only the one array containing the values to be sorted.
The function sort rearranges the values in the array a by interchanging pairs of values.
Let us go through a concrete example so that you can see how the algorithm works.
Consider the array shown in Display 7_0_11.
The algorithm will place the smallest value in a[0].
The smallest value is the value in a[3].
So the algorithm interchanges the values of a[0] and a[3].
The algorithm then looks for the next smallest element.
The value in a[0] is now the smallest element and so the next smallest element is the smallest of the remaining elements a[1], a[2], a[3], …, a[9].
In the example in Display 7_0_11, the next smallest element is in a[5], so the algorithm interchanges the values of a[1] and a[5].
This positioning of the second smallest element is illustrated in the fourth and fifth array pictures in Display 7_0_11.
The algorithm then positions the third smallest element, and so forth.
VideoNote Selection Sort Walkthrough 418 Chapter 7 / Arrays Display 7_0_11   Selection Sort a[0⋅ ] a[1].
The sorted portion of the array grows by adding elements one after the other from the elements in the unsorted end of the array.
Notice that the algorithm need not do anything with the value in the last indexed variable, a[9].
That is because once the other elements are positioned correctly, a[9] must also have the correct value.
After all, the correct value for a[9] is the smallest value left to be moved, and the only value left to be moved is the value that is already in a[9].
The definition of the function sort, included in a demonstration program, is given in Display 7_0_12.
The function swap_values, shown in Display 7_0_12, is used to interchange the values of indexed variables.
For example, the following call will interchange the values of a[0] and a[3]: swap_values(a[0], a[3]);.
Sample Dialogue This program sorts numbers from lowest to highest.
Enter up to 10 nonnegative whole numbers.
Mark the end of the list with  negative number.
In fact, computer scientists have devised scores of sorting algorithms.
Some of these algorithms are more efficient than others and some work only for particular types of data.
Bubble sort is  simple and general sorting algorithm that is similar to selection sort.
If we use bubble sort to sort an array in ascending order, then the largest value is successively "bubbled" toward the end of the array.
For example, if we start with an unsorted array consisting of the following integers: Initial array: {3, 10, 9, 2, 5}.
The remaining number at the beginning of the array doesn't need to be examined since it is the only number left and must be the smallest.
To design  program based on bubble sort note that we are placing the largest item at  length-1, the second largest item at length-2, the next at length-3, etc.
This corresponds to  loop that starts at  length-1 of the array and counts down to  1 of the array.
We don't need to include  0 since that will contain the smallest element.
One way to implement the loop is with the following code, where variable  corresponds to the target : The "bubble" part of bubble sort happens inside each iteration of this loop.
The bubble step consists of another loop that moves the largest number toward the   in the array.
First, the largest number between  0 and 421 VideoNote Bubble Sort Walkthrough 422 Chapter 7 / Arrays will be bubbled up to.
We start the bubbling procedure by comparing the number at  0 with the number at  1.
If the number at  0 is larger than the number at  1 then the values are swapped so we end up with the largest number at  1.
If the number at  0 is less than or equal to the number at  1 then nothing happens.
Starting with the following unsorted array: Initial array: {3, 10, 9, 2, 5}.
The second step will compare the numbers at  1 and 2, which is values 10 and 9.
Since 10 is larger than 9 we swap the numbers resulting in the following: After step 2: {3, 9, 10, 2, 5}.
This ends the first iteration of the bubble sort algorithm.
We have bubbled the largest number to the end of the array.
The next iteration would bubble the second largest number to the second to last position, and so forth, where variable  represents the target  for the bubbled number.
If we use variable  to reference the  of the bubbled item then our loop code looks like this: Inside the loop we must compare the items at   and  +1.
The largest should be moved into  +1.
The completed algorithm is shown below and a complete example in Display 7_0_13.
Display 7_0_13   Bubble Sort Program 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37.
Chapter 7 / Arrays S el f -T est Exe rc is es 17.
Write  program that will read up to ten nonnegative integers into an array called number_array and then write the integers back to the screen.
For this exercise you need not use any functions.
This is just  toy program and can be very minimal.
Write  program that will read up to ten letters into an array and write the letters back to the screen in the reverse order.
For example, if the input is abcd.
Call the array letter_box.
For this exercise you need not use any functions.
This just  toy program and can be very minimal.
Following  the declaration for an alternative version of the function search defined in Display 7_0_12.
In order to use this alternative version of the search function, we would need to rewrite the program slightly, but for this exercise all you need to do  to write the function definition for this alternative version of search.
Found on the wall of  Computer Science department restroom Cplus_plus allows you to declare arrays with more than one index.
In this section we describe these multidimensional arrays.
The following declares an array of characters called page.
The array page has two indexes: The first index ranges from 0 to 29, and the second from 0 to 99.
For example, page[0][0], page[15][32], and page[29][99] are three of the indexed variables for this array.
Note that each index must be enclosed in its own set of square brackets.
As was true of the one-dimensional arrays we have already seen, each indexed variable for  multidimensional array   variable of the base type.
An array may have any number of indexes, but perhaps the most common number of indexes  two.
A two-dimensional array can be visualized as two-dimensional display with the first index giving the row and the second index giving the column.
For example, the array indexed variables of the twodimensional array page can be visualized as follows: page[0][0], page[0][1], _0__0__0_, page[0][99] page[1][0], page[1][1], _0__0__0_, page[1][99] page[2][0], page[2][1], _0__0__0_, page[2][99].
In Cplus_plus,  two-dimensional array, such as page,  actually an array of arrays.
The example array page  actually  one-dimensional array of size 30, whose base type   one-dimensional array of characters of size 100.
Normally, this need not concern you, and you can usually act as if the array page  actually an array with two indexes (rather than an array of arrays, which harder to keep track of).
There , however, at least one situation two-dimensional array looks very much like an array of arrays, namely, when you have  function with an array parameter for  two-dimensional array, which  discussed in the next subsection.
Multidimensional Array Parameters The following declaration of  two-dimensional array  actually declaring one-dimensional array of size 30, whose base type   one-dimensional array of characters of size 100: A multidimensional array  an array of arrays 426 Chapter 7 / Arrays.
An array declaration, of the form shown, defines one indexed variable for each combination of array indexes.
For example, the second of the sample declarations defines the following six indexed variables for the array matrix: matrix[0][0], matrix[0][1], matrix[0][2], matrix[1][0], matrix[1][1], matrix[1][2] char page[30][100]; Viewing  two-dimensional array as an array of arrays will help you to understand how Cplus_plus handles parameters for multidimensional arrays.
For example, the following function takes an array argument, like page, and prints it to the screen: {.
Notice that with a two-dimensional array parameter, the size of the first dimension  not given, so we must include an int parameter to give the size of this first dimension.
However, such a number  only a comment; the compiler ignores any such number_0_) The size of the second dimension (and all other dimensions if there are more than two)  given after the array parameter, as shown for the parameter const char p[ ][100] 7_0_4 Multidimensional Arrays Multidimensional Array Parameters When a multidimensional array parameter  given in a function heading or function declaration, the size of the first dimension  not given, but the remaining dimension sizes must be given in square brackets.
Since the first dimension size  not given, you usually need an additional parameter of type int that gives the size of this first dimension.
Below an example of a function declaration with a two-dimensional array parameter p: void get_page(char p[][100], int size_dimension_1); If you realize that a multidimensional array  an array of arrays, then this rule begins to make sense.
Since the two-dimensional array parameter const char p[ ][100] a parameter for an array of arrays, the first dimension  really the of the array and is treated just like an array  for an ordinary, onedimensional array.
The second dimension is part of the description of the base type, which is an array of characters of size 100.
Programming Example Two-Dimensional Grading Program Display 7_0_14 contains a program that uses a two-dimensional array, named grade, to store and then display the grade records for a small class.
The class has four students and includes three quizzes.
Display 7_0_15 illustrates how the array grade is used to store data.
The first array  is used to designate a student, and the second array  is used to designate a quiz.
Since the students and quizzes are numbered starting with 1 rather than 0, we must subtract 1 from the student number and subtract 1 from the quiz number to obtain the indexed variable that stores a particular quiz score.
For example, the score that student number 4 received on quiz number 1 is recorded in grade[3][0].
Our program also uses two ordinary one-dimensional arrays.
The array st_ave will be used to record the average quiz score for each of the students.
For example, the program will set st_ave[0] equal to the average of the quiz scores received by student 1, st_ave[1] equal to the average of the quiz scores received by student 2, and so forth.
The array quiz_ave will be used to record the average score for each quiz.
For example, the program will set quiz_ave[0] equal to the average of all the student scores for quiz 1, quiz_ave[1] will record the average 427.
Chapter 7 / Arrays 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //Reads quiz scores for each student into the two-dimensional array grade (but //the input code is not shown in this display).
Computes the average score.
Each of the indexed variables grade[st_num − 1, //quiz_num − 1] contains the score for student st_num on quiz quiz_num.
Each //st_ave[st_num − 1] contains the average for student stu_num.
Each //quiz_ave[quiz_num − 1] contains the average for quiz number quiz_num.
Display 7_0_16 illustrates the relationship between the arrays grade, st_ave, and quiz_ave.
In that display, we have shown some sample data for the array grade.
This data, in turn, determines the values that the program stores in st_ave and in quiz_ave.
Display 7_0_16 also shows these values, which the program computes for st_ave and quiz_ave.
The complete program for filling the array grade and then computing and displaying both the student  and the quiz  is shown in Display 7_0_14.
In that program we have declared array dimensions as global named constants.
Since the procedures are particular to this program and could not be reused elsewhere, we have used these globally defined constants in the procedure bodies, rather than having parameters for the size of the array dimensions.
Since it is routine, the display does not show the code that fills the array.
Pitfall Using Commas Between Array Indexes Note that in Display 7_0_14 we wrote an indexed variable for the twodimensional array grade as grade[st_num - 1][quiz_num - 1] with two pairs of square brackets.
In some other programming languages it would be written with one pair of brackets and commas as follows: grade[st_num - 1, quiz_num - 1]; this is incorrect in Cplus_plus.
If you use grade[st_num - 1, quiz_ num - 1] in Cplus_plus you are unlikely to get any error message, but it is incorrect usage and will cause your program to misbehave.
Chapter 7 / Arrays S elf -Tes t Ex er c ise s 20.
What is the output produced by the following code.
Write code that will fill the array a (declared below) with numbers typed in at the keyboard.
The numbers will be input five per line, on four lines (although your solution need not depend on how the input numbers are divided into lines).
Write a function definition for a void function called echo such that the following function call will echo the input described in Self-Test Exercise 21 and will echo it in the same format as we specified for the input (that is, four lines of five numbers per line): echo(a, 4); Chapter Summary ■ An array can be used to store and manipulate a collection of data that is all of the same type.
Always check the first and last iterations of a loop that manipulates an array to make sure it does not use an that is illegally small or illegally large.
An array parameter is similar to a call-by-reference parameter in that any change that is made to the formal parameter in the body of the function will be made to the array argument when the function is called.
Answers to Self-Test Exercises ■ The indexed variables for an array are stored next to each other in the computer's memory so that the array occupies a contiguous portion of memory.
When the array is passed as an argument to a function, only the address of the first indexed variable (the one numbered 0) is given to the calling function.
Therefore, a function with an array parameter usually needs another formal parameter of type int to give the size of the array.
An array parameter that is modified with a const is called a constant array parameter.
Answers to Se lf-Test Exer cises 1.
The statement int a[5]; is a declaration, where 5 is the number of array elements.
The expression a[4] is an access into the array defined by the previous statement.
The access is to the element having  4, which is the fifth (and last) array element.
The array size is 4.
The array size is 4.
The indexed variables of sample_array are sample_array[0] through sample _array[9], but this piece of code tries to fill sample_array[1] through sample_array[10].
When  is equal to 9,  + 1 is equal to 10, so a[ + 1], which is the same as a[10], has an illegal.
The loop should stop with one less iteration.
To correct the code, change the first line of the for loop to.
The array will consume 14 bytes of memory.
The address of the indexed.
The first one has an illegal.
The second has no indexed expression at all.
You cannot use an entire array as an argument to tripler, as in the second call.
The section "Entire Arrays as Function Arguments" discusses a different situation in which you can use an entire array as an argument.
The loop steps through indexed variables [1] through [5], but 5 is an illegal  for the array.
The correct version of the code is: int [5] = {1, 2, 3, 4, 5};.
If that is what is desired, the call is acceptable.
The following function calls are all incorrect: too2(my_array, 55); The first of these is incorrect because the second argument is too large.
The second is incorrect because it is missing a final semicolon (and for other reasons).
The third one is incorrect because it uses an indexed variable for an argument where it should use the entire array.
You cannot make the parameter in drop_odd a constant parameter because it may have the values of some of its indexed variables changed.
Practice Programs Practice Programs can generally be solved with a short program that directly applies the programming principles presented in this chapter.
Write a function named firstLast2 that takes as input an array of integers and an integer that specifies how many entries are in the array.
The function should return true if the array starts or ends with the digit 2.
Otherwise it should return false.
Test your function with arrays of different length and 437.
Chapter 7 / Arrays with the digit 2 at the beginning of the array, end of the array, middle of the array, and missing from the array.
Write a function named countNum2s that takes as input an array of integers and an integer that specifies how many entries are in the array.
The function should return the number of 2's in the array.
Test your function with arrays of different length and with varying number of 2's.
Write a function named swapFrontBack that takes as input an array of integers and an integer that specifies how many entries are in the array.
The function should swap the first element in the array with the last element in the array.
The function should check if the array is empty to prevent errors.
Test your function with arrays of different length and with varying front and back numbers.
The following code creates a small phone book.
An array is used to store a list of  and another array is used to store the phone numbers that go with each name.
For example, Michael Myers' phone number is 3338000 and Ash Williams' phone number is 333-2323.
Write the function lookupName so the code properly looks up and returns the phone number for the input  name.
Programming Projects Programming Projects require more problem-solving than Practice Programs and can usually be solved many different ways.
Visit www_0_myprogramminglab_0_com to complete many of these Programming Projects online and get instant feedback.
Projects 7 through 11 can be written more elegantly using structures or classes.
Projects 12 through 15 are meant to be written using multidimensional arrays and do not require structures or classes.
See Chapters 10 and 11 for information on defining classes and structures.
There are three versions of this project.
Version 1 (all interactive).
Write a program that reads in the average monthly rainfall for a city for each month of the year and then reads in the actual monthly rainfall for each of the previous 12 months.
The program then prints out a nicely formatted table showing the rainfall for each of the previous 12 months as well as how much above or below average the rainfall was for each month.
The average monthly rainfall is given for the months January, February, and so forth, in order.
To obtain the actual rainfall for the previous 12 months, the program first asks what the current month is and then asks for the rainfall figures for the previous 12 months.
The output should correctly label the months.
There are a variety of ways to deal with the month.
One straightforward method is to code the months as integers and then do a conversion before doing the output.
A large switch statement is acceptable in an output function.
The month input can be handled in any manner you wish, as long as it is relatively easy and pleasant for the user.
After you have completed this program, produce an enhanced version that also outputs a graph showing the average rainfall and the actual rainfall for each of the previous 12 months.
The graph should be similar to the one shown in Display 7_0_8, except that there should be two bar graphs for each month and they should be labeled as the average rainfall and the rainfall for the most recent month.
Your program should ask the user whether she or he wants to see the table or the bar graph and then should display whichever format is requested.
Include a loop that allows the user to see either format as often as the user wishes until the user requests that the program end.
Chapter 7 / Arrays Version 2 (combines interactive and file output).
For a more elaborate version, also allow the user to request that the table and graph be output to a file.
The file name is entered by the user.
This program does everything that the Version 1 program does but has this added feature.
To read a file name, you must use material presented in the optional section of Chapter 5 VideoNote Solution to Programming Project 7_0_3 3.
Write a function called delete_repeats that has a partially filled array of characters as a formal parameter and that deletes all repeated letters from the array.
Since  partially filled array requires two arguments, the function will actually have two formal parameters: an array parameter and  formal parameter of type int that gives the number of array positions used.
When  letter is deleted, the remaining letters are moved forward to fill in the gap.
This will create empty positions at the end of the array so that less of the array is used.
Since the formal parameter is  partially filled array,  second formal parameter of type int will tell how many array positions are filled.
This second formal parameter will be  call-by-reference parameter and will be changed to show how much of the array is used after the repeated letters are deleted.
For example, consider the following code:.
Programming Projects is no longer of any concern, since the partially filled array no longer uses You may assume that the partially filled array contains only lowercase letters.
Embed your function in  suitable test program.
The standard deviation of  list of  is  measure of how much the deviate from the average.
If the standard deviation is small, the are clustered close to the average.
If the standard deviation is large, the  are scattered far from the average.
The standard deviation, , of list of N  x is defined as follows: N =.
Define  function that takes  partially filled array of  as its arguments and returns the standard deviation of the  in the partially filled array.
Since partially filled array requires two arguments, the function will actually have two formal parameters: an array parameter and  formal parameter of type int that gives the number of array positions used.
The in the array will be of type double.
Embed your function in  suitable test program.
Write  program that reads in  list of integers into an array with base type int.
Provide the facility to either read this array from the keyboard or from  file, at the user's option.
If the user chooses file input, the program should request  file name.
You may assume that there are fewer than 50 entries in the array.
Your program determines how many entries there are.
The output is to be  two-column list.
The first column is  list of the distinct array elements; the second column is the count of the number of occurrences of each element.
The list should be sorted on entries in the first column, largest to smallest.
For example, for the input -12 3 -12 4 1 1 -12 1 -1 1 2 3 4 2 3 -12 the output should be N 4 3 2 1 -1 -12 Count 2 3 2 4 1 4 441.
The text discusses the selection sort.
We propose  different "sort" routine, the insertion sort.
This routine is in  sense the opposite of the selection sort in that it picks up successive elements from the array and inserts each of these into the correct position in an already sorted subarray (at one end of the array we are sorting).
The array to be sorted is divided into  sorted subarray and to-be-sorted subarray.
Initially, the sorted subarray is empty.
Each element of the to-be-sorted subarray is picked and inserted into its correct position in the sorted subarray.
Write  function and  test program to implement the selection sort.
Thoroughly test your program.
Example and hints: The implementation involves an outside loop that selects successive elements in the to-be-sorted subarray and  nested loop that inserts each element in its proper position in the sorted subarray.
Initially, the sorted subarray is empty, and the to-be-sorted subarray is all of the array: [0] [1].
The inside loop has nothing to do in this first case.
The array and subarrays look like this: sorted to-be-sorted.
Insert this into the sorted subarray in its proper position.
These are out of order, so the inside loop must swap values in position 0 and position 1.
The result is as follows: sorted to-be-sorted.
Programming Projects Note that the sorted subarray has grown by one entry.
Repeat the process for the first to-be-sorted subarray entry, a[2], finding a place where a[2] can be placed so that the subarray remains sorted.
Since a[2] is already in place—that is, it is larger than the largest element in the sorted subarray—the inside loop has nothing to do.
The result is as follows: sorted to-be-sorted.
This time the inside loop has to swap values until the value of a[3] is in its proper position.
This involves some swapping: sorted a[0] a[1].
An array can be used to store large integers one digit at a time.
For example, the integer 1234 could be stored in the array a by setting a[0] to 1, a[1] to 2, a[2] to 3, and a[3] to 4.
However, for this exercise you might find it more useful to store the digits backward, that is, place 4 in a[0], 3 in a[1], 2 in a[2], and 1 in a[3].
In this exercise you will write a program that reads in two positive integers that are 20 or fewer digits in length and then outputs the sum of the two numbers.
Your program will read the digits as values of type char so that the number 1234 is read as the four characters '1', '2', '3', and '4'.
After they are read into the program, the characters are changed to values of type int.
The digits will be read into a partially filled array, and you might find it useful to reverse the order of the elements in the array after the array is filled with data from the keyboard.
It can be done Your program will perform the addition by implementing the usual paper-and-pencil addition algorithm.
The result of the addition is stored in an array of size 20, and the result is then written to the screen.
If the result of the addition is an integer with more than the maximum number of digits (that is, more than 20 digits), then your program should issue a message saying that it has encountered "integer overflow_0_" You should be able to change the maximum length of the integers by changing only one globally defined constant.
Include a loop that allows the user to continue to do more additions until the user says the program should end.
Write a program that will read a line of text and output a list of all the letters that occur in the text together with the number of times each letter occurs in the line.
End the line with a period that serves as a sentinel value.
The letters should be listed in the following order: the most frequently occurring letter, the next most frequently occurring letter, and so forth.
Use two arrays, one to hold integers and one to hold letters.
You may assume that the input uses all lowercase letters.
For example, the input do be do bo.
Programming Projects Your program will need to sort the arrays according to the values in the integer array.
This will require that you modify the function sort given in Display 7_0_12.
You cannot use sort to solve this problem without changing the function.
If this is a class assignment, ask your instructor if input/output should be done with the keyboard and screen or if it should be done with files.
If it is to be done with files, ask your instructor for instructions on file names.
Write a program to score five-card poker hands into one of the following categories: nothing, one pair, two pairs, three of a kind, straight (in order, with no gaps), flush (all the same suit, for example, all spades), full house (one pair and three of a kind), four of a kind, straight flush (both a straight and a flush).
Use two arrays, one to hold the value of the card and one to hold the suit.
Include a loop that allows the user to continue to score more hands until the user says the program should end.
Write a program that will allow two users to play tic-tac-toe.
The program should ask for moves alternately from player X and player O.
The program displays the game positions as follows: 1 2 3 4 5 6 7 8 9 The players enter their moves by entering the position number they wish to mark.
After each move, the program displays the changed board.
A sample board configuration is as follows: X X O 4 5 6 O 8 9 11.
Write a program to assign passengers seats in an airplane.
Assume a small airplane with seat numbering as follows: 1 2 3 4 5 6 7 A A A A A A A B B B B B B B C C C C C C C D D D D D D D The program should display the seat pattern, with an X marking the seats already assigned.
For example, after seats 1A, 2B, and 4C are taken, the display should look like this: 1 X B C D 2 A X C D 3 A B C D 445.
Chapter 7 / Arrays 4 5 6 7 A A A A B B B B X C C C D D D D After displaying the seats available, the program prompts for the seat desired, the user types in a seat, and then the display of available seats is updated.
This continues until all seats are filled or until the user signals that the program should end.
If the user types in a seat that is already assigned, the program should say that that seat is occupied and ask for another choice.
Write a program that accepts input like the program in Display 7_0_8 and that outputs a bar graph like the one in that display except that your program will output the bars vertically rather than horizontally.
A two-dimensional array may be useful.
We define each cell to have eight neighbor cells.
The neighbors of a cell are the cells directly above, below, to the right, to the left, diagonally above to the right and left, and diagonally below to the right and left.
If an occupied  has more than three neighbors, it dies of overcrowding.
A  dying for whatever reason may help cause birth, but a newborn  cannot resurrect a  that is dying, nor will a 's death prevent the death of another, say, by reducing the local population.
Notes: Some configurations grow from relatively small starting configurations.
Others move across the region.
It is recommended that for text output Programming Projects you use a rectangular array of char with 80 columns and 22 rows to store the LIFE world's successive generations.
Use an asterisk * to indicate a living , and use a blank to indicate an empty (or dead).
If you have a screen with more rows than that, by all means make use of the whole screen.
Suggestions: Look for stable configurations.
That is, look for communities that repeat patterns continually.
The number of configurations in the repetition is called the period.
There are configurations that are fixed, which continue without change.
A possible project is to find such configurations.
Hints: Define a void function named generation that takes the array we call world, an 80-column by 22-row array of char, which contains the initial configuration.
The function scans the array and modifies the cells, marking the cells with births and deaths in accord with the rules listed earlier.
This involves examining each  in turn, either killing the , letting it live, or, if the  is empty, deciding whether a should be born.
There should be a function display that accepts the array world and displays the array on the screen.
Some sort of time delay is appropriate between calls to generation and display.
To do this, your program should generate and display the next generation when you press Return.
You are at liberty to automate this, but automation is not necessary for the program.
Your program should first load all boy names and girl names from the file into separate arrays.
Search for the target name from the arrays, not directly from the file.
Your program should not be hard-coded to create a bar chart of exactly four integers, but should be able to graph an array of up to 100 integers.
Scale the graph appropriately in the horizontal and vertical dimensions so the bar chart fits within a 400 by 400 pixel area.
You can impose the constraint that all integers in the array are nonnegative.
Use the sentinel value of −1 to indicate the end of the values to draw in the bar chart.
Chapter 7 / Arrays create the bar chart with values 20, 40, 60, and 120, your program would operate on the array: a[0] a[1] a[2] a[3] a[4] = = = = = 20 40 60 120 -1 Test your program by creating several bar charts with different values and up to 100 entries and view the resulting SVG files to ensure that they are drawn correctly.
A common memory matching game played by young children is to start with a deck of cards that contains identical pairs.
For example, given six cards in the deck, two might be labeled "1," two might be labeled "2," and two might be labeled "3_0_" The cards are shuffled and placed face down on the table.
The player then selects two cards that are face down, turns them face up, and if they match they are left face up.
If the two cards do not match, they are returned to their original position face down.
The game continues in this fashion until all cards are face up.
Write a program that plays the memory matching game.
Use 16 cards that are laid out in a 4 X 4 square and are labeled with pairs of numbers from 1 to 8.
Your program should allow the player to specify the cards that she would like to select through a coordinate system.
For example, suppose the cards are in the following layout: 1 2 3 4 1 2 3 4 minus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minusminus_minus-| 8 * * * | * * * * | * 8 * * | * * * * All of the cards are face down except for the pair 8, which has been located at coordinates (1, 1) and (2, 3).
To hide the cards that have been temporarily placed face up, output a large number of newlines to force the old board off the screen.
Write a function that "shuffles" the cards in the array by repeatedly selecting two cards at random and swapping them.
Random 17_0_	Your swim school has two swimming instructors, Jeff and Anna.
Their current schedules are shown below.
An "X" denotes a 1-hour time slot that is occupied with a lesson.
Programming Projects Jeff 11-12 Monday.
Thursday X X.
X Write a program with array(s) capable of storing the schedules.
Create a main menu that allows the user to mark a time slot as busy or free for either instructor.
Also, add an option to output the schedules to the screen.
Next, add an option to output all time slots available for individual lessons (slots when at least one instructor is free).
Finally, add an option to output all time slots available for group lessons (when both instructors are free).
Modify Programming Project 17 by adding menu options to load and save the schedules from a file.
One way to combat this problem is with a randomized challenge-response system.
In these systems, the user enters different information every time based on a secret in response to a randomly generated challenge.
Consider the following scheme in which the password consists of a five-digit PIN number (00000 to 99999).
Each digit is assigned a random number that is 1, 2, or 3.
The user enters the random numbers that correspond to their PIN instead of their actual PIN numbers.
For example, consider an actual PIN number of 12345.
To authenticate the user would be presented with a screen such as: 449.
Chapter 7 / Arrays PIN: NUM: 0 1 2 3 4 5 6 7 8 9 3 2 3 1 1 3 2 2 1 3 The user would enter 23113 instead of 12345.
This doesn't divulge the password even if an attacker intercepts the entry because 23113 could correspond to other PIN numbers, such as 69440 or 70439.
The next time the user logs in, a different sequence of random numbers would be generated, such as: PIN: NUM: 0 1 2 3 4 5 6 7 8 9 1 1 2 3 1 2 2 3 3 3 Your program should simulate the authentication process.
Store an actual PIN number in your program.
The program should use an array to assign random numbers to the digits from 0 to 9.
Output the random digits to the screen, input the response from the user, and output whether or not the user's response correctly matches the PIN number.
The Social Security Administration maintains an actuarial life table that contains the probability that a person in the United States will die (http:// www_0_ssa_0_gov/OACT/STATS/table4c6_0_html).
The death probabilities from this table for 2009 are stored in the file LifeDeathProbability_0_txt and it is included on the website for the book.
There are three values for each row, the age, death probability for a male, and death probability for a female.
For example, the first five lines are: 0 1 2 3 4 0_0_006990 0_0_000447 0_0_000301 0_0_000233 0_0_000177 0_0_005728 0_0_000373 0_0_000241 0_0_000186 0_0_000150 This says that a 3 year old female has a 0_0_000186 chance of dying.
Write a program that reads the data into arrays from the file.
Next, let the user enter his or her sex and age.
The program should simulate to what age the user will live by starting with the death probability for the user's current age and sex.
Generate a  number between 0-1; if this number is less than or equal to the death probability then predict that the user will live to the current age.
If the  number is greater than the death probability then increase the age by one and repeat the calculation with a new  number for the next probability value.
If the simulation reaches age 120 then stop  predict that the user will live to 120.
This program is merely a simulation  will give different results each time it is run, assuming you change the seed for the number generator.
Strings  Vectors 8_0_1 An Array Type for Strings   453 C-String Values  C-String Variables   453 :  =  == with C Strings   456 Other Functions in <cstring>   458 : Copying past the end of a C- using strcpy   461 C-String Input  Output   464 C-String-to-Number Conversions  Robust Input   466 8_0_2 The Standard     472 Introduction to the Standard     472 I/O with the     475 Programming Tip: More Versions of getline   478 : Mixing cin >> variable; getline   479 Chapter Summary   495 Answers to Self-Test Exercises   495 8 String Processing with the     480 Programming Example: Palindrome Testing   484 Converting between  Objects C Strings   487 Converting Between Strings  Numbers   488 8_0_3 Vectors   489 Vector Basics   489 :  Square Brackets Beyond the Vector Size   492 Programming Tip: Vector Assignment Is Well Behaved   493 Efficiency Issues   493 Practice Programs   497 Programming Projects   498 Polonius: What do you read my lord.
Hamlet: Words, words, words.
William Shakespeare, Hamlet Introduction This chapter discusses two topics that use arrays or are related to arrays: strings  vectors.
Although strings  vectors are very closely related, this relationship is not always obvious,  no one of these topics depends on the other.
The topics of strings  vectors can be covered in either order.
Sections 8_0_1  8_0_2 present two types whose values represent strings of characters, such as "Hello".
One type, discussed in Section 8_0_1, is just an array with base type char that stores strings of characters in the array marks the end of the  with the null character '\0'.
This is the older way of representing strings, which Cplus_plus inherited from the C programming language.
These sorts of strings are called C strings.
Although C strings are an older way of representing strings, it is difficult to do any sort of processing in Cplus_plus without at least passing contact with C strings.
For example, quoted strings, such as "Hello", are implemented as C strings in Cplus_plus.
The ANSI/ISO Cplus_plus standard includes a more modern stringhandling facility in the form of the class.
The class  is the second  type that we will discuss in this chapter  is covered in Section 8_0_2.
Vectors can be thought of as arrays that can grow ( shrink) in length while your program is running.
In Cplus_plus, once your program creates an array, it cannot change the length of the array.
Vectors serve the same purpose as arrays except that they can change length while the program is running.
Prerequisites Sections 8_0_1  8_0_2, which cover strings,  Section 8_0_3 which covers vectors, are independent of each other.
If you wish to cover vectors before strings, that is fine.
Section 8_0_1 on C strings uses material from Chapters 2 through 6, Sections 7_0_1, 7_0_2,  7_0_3 of Chapter 7.
Section 8_0_2 on the  class uses Section 8_0_1  material from Chapters 2 through 6  Sections 7_0_1, 7_0_2, 7_0_3 of Chapter 7.
Section 8_0_3 on vectors uses material from Chapters 2 through 6  Sections 7_0_1, 7_0_2,  7_0_3 of Chapter 7.
In this section we describe one way to represent strings of characters, which Cplus_plus has inherited from the C language.
In Section 8_0_2 we describe a class that is a more modern way to represent strings.
Although the  type described here may be a bit "old-fashioned," it is still widely used  is an integral part of the Cplus_plus language.
C-String Values  C-String Variables One way to represent a  is as an array with base type char.
If the  is "Hello", it is handy to represent it as an array of characters with six indexed variables: five for the five letters in "Hello" plus one for the character '\0', which serves as an end marker.
The character '\0' is called the null character  is used as an end marker because it is distinct from all the "real" characters.
The end marker allows your program to read the array one character at a time  know that it should stop reading when it reads the end marker '\0'.
A  stored in this way (as an array of characters terminated with '\0') is called a C.
We write '\0' with two symbols when we write it in a program, but just like the new- character '\n', the character '\0' is really only a single character value.
Like any other character value, '\0' can be stored in one variable of type char or one indexed variable of an array of characters.
The Null Character, '\0' The null character, '\0', is used to mark the end of a C  that is stored in an array of characters.
When an array of characters is used in this way, the array is often called a C- variable.
Although the null character '\0' is written using two symbols, it is a single character that fits in one variable of type char or one indexed variable of an array of characters.
In Cplus_plus, a literal , such as "Hello", is stored as a C , although you seldom need to be aware of this detail.
A C- variable is just an array of characters.
Thus, the following array declaration provides us with a C- variable capable of storing a C- value with nine or fewer characters: char s[10]; The 10 is for the nine letters in the  plus the null character '\0' to mark.
Chapter 8 / Strings and Vectors A C- variable is a partially filled array of characters.
Like any other partially filled array, a C- variable uses positions starting at indexed variable 0 through as many as are needed.
However, a C- variable does not use an int variable to keep track of how much of the array is currently being used.
Instead, a string variable places the special symbol '\0' in the array immediately after the last character of the C string.
Thus, if s contains the string "Hi Mom"_0_, then the array elements are filled as shown here: C-string variables vs.
The character '\0' is used as a sentinel value to mark the end of the C string.
If you read the characters in the C string starting at indexed variable s[0], proceed to s[1], and then to s[2], and so forth, you know that when you encounter the symbol '\0', you have reached the end of the C string.
Since the symbol '\0' always occupies one element of the array, the length of the longest string that the array can hold is 1 less than the size of the array.
The thing that distinguishes a C-string variable from an ordinary array of characters is that a C-string variable must contain the null character '\0' at the end of the C-string value.
This is a distinction in how the array is used rather than a distinction about what the array is.
A C-string variable is an array of characters, but it is used in a different way.
C-String Variable Declaration A C-string variable is the same thing as an array of characters, but it is used differently.
A C-string variable is declared to be an array of characters in the usual way.
Syntax char Array_Name[Maximum_C_string_Size + 1];.
The + 1 allows for the null character '\0', which terminates any C string stored in the array.
For example, the C-string variable my_c_string in the example can hold a C string that is ten or fewer characters long.
Initializing C-string variables You can initialize a C-string variable when you declare it, as illustrated by the following example:.
When you initialize a C-string variable, you can omit the array size.
Cplus_plus will automatically make the size of the C-string variable 1 more than the length of the quoted string.
The first of these two possible initializations places the null character '\0' in the array after the characters 'a', 'b', and 'c'.
The second one does not put a '\0' anywhere in the array.
Initializing a C-String Variable A C-string variable can be initialized when it is declared, as illustrated by the following example: char [11] = "Do Be Do"; Initializing in this way automatically places the null character, '\0', in the array at the end of the C string specified.
If you omit the number inside the square brackets, [], then the C-string variable will be given a size one character longer than the length of the C string.
For example, the following declares  to have nine and one for the null character '\0'): char [] = "Do Be Do"; A C-string variable is an array, so it has indexed variables that can be.
Chapter 8 / Strings and Vectors the C-string value in  to a C string of the same length consisting of all 'X' characters:.
If the array loses the value '\0', it will no longer behave like a C-string variable.
For example, the following will change the array  so that it no longer contains a C string: char [7] = "DoBeDo"; [6] = 'Z'; After this code is executed, the array  will still contain the six letters in the C-string "DoBeDo", but  will no longer contain the null character '\0' to mark the end of the C string.
Many string-manipulating functions depend critically on the presence of '\0' to mark the end of the C-string value.
As another example, consider the previous while loop that changed characters in the C-string variable.
That while loop changes characters until it encounters a '\0'.
If the loop never encounters a '\0', then it could change a large chunk of memory to some unwanted values, which could make your program do strange things.
As a safety feature, it would be wise to rewrite that while loop as follows, so that if the null character '\0' is lost, the loop will not inadvertently change memory locations beyond the end of the array: int  = 0;.
You cannot  a C-string variable in an assignment statement  =.
If you  == to test C strings for equality, you will not get the result you expect.
The reason for these problems is that C strings  C-string variables are arrays.
Assigning a C-string value Illegal.
Although you can  the equal sign to assign a value to a C-string variable when the variable is declared, you cannot do it anywhere else in your program.
Technically, a  of the equal sign in a declaration, as in char [7] = "DoBeDo"; is an initialization, not an assignment.
If you want to assign a value to a C-string variable, you must do something else.
There are a number of different ways to assign a value to a C-string variable.
The easiest way is to  the predefined function strcpy as shown: strcpy(, "Hello"); This will set the value of  equal to "Hello".
Unfortunately, this version of the function strcpy does not check to make sure the copying does not exceed the size of the string variable that is the first argument.
Many, but not all, versions of Cplus_plus also have a safer version of strcpy.
This safer version is spelled strncpy (with an n).
The function strncpy takes a third argument that gives the maximum number of characters to copy.
For example: char another_string[10]; strncpy(another_string, a_string_variable, 9); will be copied from the C-string variable a_string_variable, no matter how long the string in a_string_variable may be.
You also cannot  the  == in an expression to test whether two C strings are the same.
You can  == with C strings, but it does not test for the C strings being equal.
So if you  == to test two C strings for equality, you are likely to get incorrect results, but no error message_0_) To test whether two C strings are the same, you can  the predefined function strcmp.
For example: << "The strings are NOT the same_0_"; else << "The strings are the same_0_"; Note that the function strcmp works differently than you might guess.
The comparison is true if the strings do not match.
The function strcmp compares the characters in the C-string arguments a character at a time.
If at any point the numeric encoding of the character from c_string1 is less than the numeric encoding of the corresponding character from c_string2, the testing stops, Testing C strings for equality 458 Chapter 8 / Strings  Vectors a negative number is returned.
If the character from c_string1 is greater than the character from c_string2, then a positive number is returned.
The ordering relationship used for comparing characters is called lexicographic order.
The important point to note is that if both strings are all in uppercase or all in lowercase, then lexicographic order is just alphabetic order.
We see that strcmp returns a negative value, a positive value, or zero, depending on whether the C strings compare lexicographically as less, greater, or equal.
If you  strcmp as a Boolean expression in an if or a looping statement to test C strings for equality, then the nonzero value will be converted to true if the strings are different,  the zero will be converted to false.
Be sure that you remember this inverted logic in your testing for C-string equality.
Cplus_plus compilers that are compliant with the standard have a safer version of strcmp that has a third argument that gives the maximum number of characters to compare.
The functions strcpy  strcmp are in the library with the header file <cstring>, so to  them you would insert the following near the top of the file: # <cstring>.
However, when processing C strings, you inevitably will  some of the predefined string functions in the library <cstring>.
So, when  C strings, you will normally give the following directive near the beginning of the file with your code: # <cstring> Other Functions in <cstring> Display 8_0_1 contains a few of the most commonly used functions from the library with the header file <cstring>.
To  them, you insert the following near the top of the file: # <cstring> As you will see in Chapter 12, the definitions of strcpy  strcmp,  all other string functions in <cstring>, are placed in the global namespace, not in the std namespace,  so no  directive is required.
Does not check to make sure Target_String_Var is large enough to hold the value Src_String.
If Limit is chosen carefully, this is safer than the twoargument version of strcpy.
Not implemented in all versions of Cplus_plus.
Does not check to see that Target_String_Var is large enough to hold the result of the concatenation.
Returns an integer equal to the length of Src_String.
Returns a value < 0 if String_1 is less than String_2.
Returns a value > 0 if String_1 is greater If Limit is chosen carefully, this is safer than the twoargument version of strcat.
Not implemented in all versions of Cplus_plus.
If String_1 equals String_2, this function returns 0, which converts to false.
Note that this is the reverse of what you might expect it to return when the strings are equal.
The order is lexicographic.
If Limit is chosen carefully, this is safer than the two-argument version of strcmp.
Not implemented in all versions of Cplus_plus.
The function strlen is easy to understand and use.
For example, strlen("dobedo") returns 6 because there are six characters in "dobedo".
The function strcat is used to concatenate two C strings, that is, to form a longer string by placing the two shorter C strings end-to-end.
The first argument must be a C-string variable.
The second argument can be anything that evaluates to a C-string value, such as a quoted string.
The result is placed in the C-string variable that is the first argument.
For example, consider the following: char [20] = "The rain"; strcat(, "in Spain"); This code will change the value of  to "The rainin Spain".
As this example illustrates, you need to be careful to account for blanks when concatenating C strings.
If you look at the table in Display 8_0_1, you will see that safer, threeargument versions of the functions strcpy, strcat, and strcmp are available in many, but not all, versions of Cplus_plus.
Also, note that these threeargument versions are spelled with an added letter n: strncpy, strncat, and strncmp.
C-String Arguments and Parameters A C-string variable is an array, so a C-string parameter to a function is simply an array parameter.
As with any array parameter, whenever a function changes the value of a C-string parameter, it is safest to include an additional int parameter giving the declared size of the C-string variable.
On the other hand, if a function only uses the value in a C-string argument but does not change that value, then there is no need to include another parameter to give either the declared size of the C-string variable or the amount of the C-string variable array that is filled.
The null character '\0' can be used to detect the end of the C-string value that is stored in the C-string variable.
This is dangerous because the strcpy function doesn't put any bounds on how much data to copy.
It will simply copy everything from the source string to the target string until the null character is encountered.
If the source is larger than the target then data will be copied past the memory allocated for the target string.
Here is a simple example where we could have problems:.
It could even open up your system to attack by malicious users.
This has been such a serious problem that some compilers will not compile code that uses strcpy unless you override the warning.
Assuming your compiler does allow you to use strcpy, one way to fix the problem is to only copy the Cstring if it is less than five characters long.
Consider the following attempt to avoid exceeding the size of the Cstring:.
This may seem reasonable since we are only creating an array of size 5 and a signed char can store values up to +127.
This version will work fine for small source strings.
But what if we input a source string that is 145 characters long.
This causes overflow and results in a negative value copied into.
As a result the program enters the if statement and erroneously copies the source data to the target array.
To avoid this problem we should make  an int (the same size returned by strlen), use strncpy to cap the maximum copy , or use the string class described in the next section.
Chapter 8 / Strings and Vectors Self-Te st Exe r cis e s 1.
Which of the following declarations are equivalent.
Assume that the code is embedded in a complete program and that an include directive for <cstring> is in the program file.
Suppose the function strlen (which returns the  of its string argument) was not already defined for you.
Give a function definition for strlen.
Note that strlen has only one argument, which is a C string.
Do not add additional arguments; they are not needed.
What is the maximum  of a string that can be placed in the string variable declared by the following declaration.
How many characters are in each of the following character and string constants.
Since character strings are just arrays of char, why does the text caution you not to confuse the following declaration and initialization.
For correct C-string variables, the following loop reassigns all positions of  the value 'X', leaving the  the same as before.
Assume this code fragment is embedded in an otherwise complete and correct program.
Answer the questions following this code fragment: int  = 0;.
Chapter 8 / Strings and Vectors C-String Input and Output C strings can be output using the insertion operator <<.
In fact, we have already been doing so with quoted strings.
You can use a C-string variable in the same way; for example, <<  << "Wow_0_\n"; where  is  C-string variable.
It is possible to fill  C-string variable using the input operator >>, but there is one thing to keep in mind.
As for all other types of data, all whitespace (blanks, tabs, and line breaks) are skipped when C strings are read this way.
Moreover, each reading of input stops at the next space or line break.
For example, consider the following code:.
When embedded in  complete program, this code produces  dialogue like the following: Enter some input: Do bedo to you.
Dobedo END OF OUTPUT The C-string variables  and  each receive only one word of the input: receives the C-string value "Do" because the input character following Do is blank;  receives "be" because the input character following be is  blank.
If you want your program to read an entire line of input, you can use the extraction operator >> to read the line one word at  time.
This can be tedious and it still will not read the blanks in the line.
There is an easy way to read an entire line of input and place the resulting C string into  C-string variable: Just use the predefined member function getline, which is  member function of every input stream (such as cin or  file input stream).
The function getline has two arguments.
The first argument is  C-string variable to receive the input and the second is an integer that typically is the declared size of the C-string variable.
The second argument tells the maximum number of array elements in the C-string variable that getline will be allowed to fill with characters.
For example, consider the following code:.
Do be do to you_0_END OF OUTPUT With the function cin_0_getline, the entire line is read.
The reading ends when the line ends, even though the resulting C string may be shorter than the maximum number of characters specified by the second argument.
When getline is executed, the reading stops after the number of characters given by the second argument have been filled in the C-string array, even if the end of the line has not been reached.
For example, consider the following code:.
When embedded in  complete program, this code produces  dialogue like the following: Enter some input: dobedowap dobeEND OF OUTPUT Notice that four, not five, characters are read into the C-string variable short_ string, even though the second argument is 5.
This is because the null character '\0' fills one array position.
Every C string is terminated with the null character when it is stored in  C-string variable, and this always consumes one array position.
The C-string input and output techniques we illustrated for  and cin work the same way for input and output with files.
The input stream cin can be replaced by an input stream that is connected to  file.
The output stream can be replaced by an output stream that is connected to  file.
Syntax cin_0_getline(String_Var, Max_Characters + 1); One line of input is read from the stream Input_Stream, and the resulting C string is placed in String_Var.
If the line is more than Max_ Characters long, then only the first Max_Characters on the line 465.
Chapter 8 / Strings and Vectors are read.
Self-Te st Exe r cis e s 13.
Consider the following code (and assume it is embedded in  complete.
If the dialogue begins as follows, what will be the next line of output.
Enter some input: The time is now.
Consider the following code (and assume it is embedded in  complete.
Enter  line of input: May the hair on your toes grow long and curly.
C-String-to-Number Conversions and Robust Input The C string "1234" and the number 1234 are not the same things.
The first is  sequence of characters; the second is  number.
In everyday life, we 8_0_1 An Array Type for Strings write them the same way and blur this distinction, but in  Cplus_plus program this distinction cannot be ignored.
If you want to do arithmetic, you need 1234, not "1234".
If you want to add  comma to the numeral for one thousand two hundred thirty four, then you want to change the C string "1234" to the C string "1,234".
When designing numeric input, it is often useful to read the input as  string of characters, edit the string, and then convert the string to  number.
For example, if you want your program to read an amount of money, the input may or may not begin with  dollar sign.
If your program is reading percentages, the input may or may not have  percent sign at the end.
If your program reads the input as  string of characters, it can store the string in  C-string variable and remove any unwanted characters, leaving only  C string of digits.
Your program then needs to convert this C string of digits to  number, which can easily be done with the predefined function atoi.
The function atoi takes one argument that is  C string and returns the returns the integer 1234.
If the argument does not correspond to an int value, then atoi returns 0.
For example, atoi("#37") returns 0, because the character '#' is not  digit.
You pronounce atoi as "A to I," which is an C-String-to-Number Functions The functions atoi, atol, and atof can be used to convert  C string of digits to the corresponding numeric value.
The functions atoi and atoll convert C strings to integers.
The only difference between atoi and atol is that atoi returns  value of type int whereas atol returns  value of type long.
The function atof converts  C string to is such that the conversion cannot be made, then the function returns zero.
For example int  = atoi("657");.
Chapter 8 / Strings and Vectors abbreviation of "alphabetic to integer_0_" The function atoi is in the library with header file cstdlib, so any program that uses it must contain the following directive: # <cstdlib> If your numbers are too large to be values of type int, you can convert them from C strings to values of type long.
The function atol performs the same conversion as the function atoi except that atol returns values of type long and thus can accommodate larger integer values (on systems where this is  concern).
Display 8_0_2 contains the definition of  function called read_and_clean that reads  line of input and discards all characters other than the digits '0' through '9'.
The function then uses the function atoi to convert the "cleaned-up" C string of digits to an integer value.
As the demonstration program indicates, you can use this function to read money amounts and it will not matter whether the user included  dollar sign or not.
Similarly, you can read percentages and it will not matter whether the user types in  percent sign or not.
Although the output makes it look as if the function read_and_ clean simply removes some symbols, more than that is happening.
The value produced is  true int value that can be used in  program as  number; it is not  C string of characters.
The function read_and_clean shown in Display 8_0_2 will delete any nondigits from the string typed in, but it cannot check that the remaining digits will yield the number the user has in mind.
The user should be given  chance to look at the final value and see whether it is correct.
If the value is not correct, the user should be given  chance to reenter the input.
In Display 8_0_3 we have used the function read_and_clean in another function called get_int, which will accept anything the user types and will allow the user to reenter the input until she or he is satisfied with the number that is computed from the input string.
It is  very robust input procedure.
Programming Project 3 at the end of this chapter asks you to define  function similar to get_int that reads in  number of type double, as opposed to  number of type int.
To write that function, it would be nice to have  predefined function that converts  string value to  number of type double.
Fortunately, the predefined function atof, which is also in the returns the value 9_0_99 of type double.
If the argument does not correspond to  number of type double, then atof returns 0_0_0.
You pronounce atof as "A to F," which is an abbreviation of "alphabetic to floating point_0_" Recall that numbers with  decimal point are often called floating-point numbers because of the way the computer handles the decimal point when storing these numbers in memory.
Chapter 8 / Strings and Vectors 47 48 49 50 51 52 53 54 55.
Sample Dialogue Enter an  and press Return: $ 100 That string converts to the  100 Again.
Discards all symbols except the digits.
Converts //the C string to an  and sets  equal to the value of this.
Chapter 8 / Strings and Vectors 8_0_2 The Standard string Class I try to catch every sentence, every word you and I say, and quickly lock all these sentences and words away  my literary storehouse because they might come  handy.
Anton Chekhov, The Seagull In Section 8_0_1, we introduced C strings.
These C strings were simply arrays of characters terminated with the null character '\0'.
In order to manipulate these C strings, you needed to worry about all the details of handling arrays.
For example, when you want to add characters to a C string and there is not enough room  the array, you must create another array to hold this longer string of characters.
In short, C strings require the programmer to keep track of all the low-level details of how the C strings are stored  memory.
This is a lot of extra work and a source of programmer errors.
The latest ANSI/ISO standard for Cplus_plus specified that Cplus_plus must now also have a class string that allows the programmer to treat strings as a basic data type without needing to worry about implementation details.
In this section we introduce you to this string type.
Introduction to  Standard Class string The class string is defined   library whose name is also <string>, and definitions are placed   std namespace.
So,  order to use  class string, your code must contain  following (or something more or less equivalent): # <string> using namespace std; + operator does concatenation The class  allows you to treat  values and  expressions very much like values of a simple type.
You can use  = operator to assign a value to a  variable, and you can use  + sign to concatenate two strings.
For example, suppose 1, 2, and 3 are objects of type  and both 1 and 2 have  values.
Then 3 can be set equal to  concatenation of value  1 followed by   value  2 as follows: 3 = 1 + 2; There is no danger of 3 being too small for its new  value.
If  sum of  lengths of 1 and 2 exceeds  capacity of 3, then more space is automatically allocated for 3.
As we noted earlier  this chapter, quoted strings are really C strings and so they are not literally of type.
However, Cplus_plus provides automatic type casting of quoted strings to values of type.
So, you can use quoted strings as if they were literal values of type , and we (and most others) will often refer to quoted strings as if they were values of type.
For example, 3 = "Hello Mom_0_"; sets  value of   variable 3 to a  object with  same.
The class  also has a second constructor that takes one argument that is a standard C  and so can be a quoted.
This second constructor initializes   object to a value that represents same  as its C- argument.
For example, phrase; noun("ants"); The first line declares   variable phrase and initializes it to  empty The second line declares noun to be of type  and initializes it to a  value equivalent to  C  "ants".
Most programmers when talking loosely would say that " is initialized to "ants"," but there really is a type conversion here.
The quoted  "ants" is a C , not a value of type.
The variable  receives a  value that has  same characters as "ants"   same order as "ants", but   value is not terminated with  null character '\0'.
In fact,  theory at least, you do not know or care whether   value of  is even stored  an array, as opposed to some other data structure.
There is an alternate notation for declaring a  variable and invoking a constructor.
The following two lines are exactly equivalent: ("ants"); = "ants";.
Consider  following line from Display 8_0_4: = "I love " + adjective + " " +  + "_0_"; Cplus_plus must do a lot of work to allow you to concatenate strings  this simple and natural fashion.
The  constant "I love" is not an object of type A  constant like "I love" is stored as a C  ( other words, as a null-terminated array of characters).
When Cplus_plus sees "I love" as an argument to +, it finds  definition (or overloading) of + that applies to a value such as "I love".
There are overloadings of  + operator that have a C  on  left and a  on  right, as well as  reverse of this positioning.
There is even a version that has a C  on both sides of  + and produces a  object as  value returned.
Of course, there is also overloading you expect, with  type  for both operands.
Cplus_plus did not really need to provide all those overloading cases for +.
If these overloadings were not provided, Cplus_plus would look for a constructor that could perform a type conversion to convert  C  "I love" to a value for which + did apply.
In this case,  constructor with  one C- parameter would perform just such a conversion.
However,  extra overloadings are presumably more efficient.
The class  is often thought of as a modern replacement for C strings.
However,  Cplus_plus you cannot easily avoid also using C strings when you program with  class.
Converting C- constants to  type 474 Chapter 8 / Strings and Vectors Display 8_0_4   Program Using  Class 1 2 3 4.
I love fried ants.
The Class The class  can be used to represent values that are strings of characters.
The class  provides more versatile  representation than  C strings discussed in Section 8_0_1.
The class  is defined in  library that is also named <>, and its definition is placed in  std namespace.
So, programs that use class  should contain  following (or something more or less equivalent): # <> using namespace std; The class  has a default constructor that initializes the object to the empty  and a constructor that takes a C  as an argument and initializes the  object to a value that represents the given as the argument.
For example: 1, 2("Hello"); 8_0_2 The Standard  Class I/O with the Class string You can use the insertion operator << and cout to output string objects just as you do for data of other types.
This is illustrated in Display 8_0_4.
Input with the class string is a bit more subtle.
The extraction operator >> and cin work the same for string objects as for other data, but remember that the extraction operator ignores initial whitespace and stops reading when it encounters more whitespace.
May the hair on your toes grow long and curly.
The variable s2 receives the string "the".
Using the extraction operator >> and cin, you can only read in words; you cannot read in a line or other string that contains a blank.
Sometimes this is exactly what you want, but sometimes it is not at all what you want.
If you want your program to read an entire  of input into a variable of type string, you can use the function getline.
The syntax for using getline with string objects is a bit different from what we described for C strings in Section 8_0_1.
You do not use cin_0_getline; instead, you make cin the first argument to getline_0_2 (Thus, this version of getline is not a member.
When embedded in a complete program, this code produces a dialogue like the following: Enter some input: Do bedo to you.
Do bedo to you_0_END OF OUTPUT If there were leading or trailing blanks on the , then they too would be part of the string value read by getline.
This version of getline is in the 2 This is a bit ironic, since the class string was designed using more modern objectoriented techniques, and the notation it uses for getline is the old fashioned, less object-oriented notation.
This is an accident of history.
This getline function was defined after the iostream library was already in use, so the designers had little choice but to make this getline a stand-alone function.
Chapter 8 / Strings and Vectors library <>.
You can use a stream object connected to a text file in place of cin to do input from a file using getline.
You cannot use cin and >> to read in a blank character.
If you want to read one character at a time, you can use cin_0_get, which we discussed in Chapter 6.
The function cin_0_get reads values of type char, not of type , but it can be helpful when handling  input.
Display 8_0_5 contains a program that illustrates both getline and cin_0_get used for  input.
Sample Dialogue Enter your first and last name: B'Elanna Torres Your name in our records is: Torres, B'Elanna Our  is Your records are our records.
Please suggest a better (one-) : Our records go where no records dared to go before.
Our new  will be: Our records go where no records dared to go before.
I/O with  Objects You can use the insertion operator << with  to output objects.
You can input a  with the extraction operator >> and cin.
When using >> for input, the code reads in a  delimited with whitespace.
You can use the function getline to input an entire  of text into a  object.
Enter a  of input: A  is a joy forever.
Consider the following code (and assume that it is embedded in a.
Enter a line of input: A  is a joy forever.
This version stops reading when it encounters the end-of-line marker '\n'.
There is a version that allows you to specify a different character to use as a stopping signal.
For example, the following will stop when the first question mark is encountered:.
It makes sense to use getline as if it were a void function, but it actually returns a reference to its first argument, which is cin in the code above.
Thus, the following will read a line of text into 1 and a  of nonwhitespace characters into 2: 1, 2; getline(cin, 1) >> 2;.
The first version of this function reads characters from the istream object given as the first argument (always cin in this chapter), inserting the characters into the  variable str_var until an instance of the delimiter character is encountered.
The delimiter character is removed from the input and discarded.
The second version uses '\n' for the default value of delimiter; otherwise, it works the same.
These getline functions return their first argument (always cin in this chapter), but they are usually used as if they were void functions.
When this code reads the following input, you might expect the value of n to be set to 42 and the value of line to be set to a  value representing "Hello hitchhiker_0_": 42 Hello hitchhiker.
However, while n is indeed set to the value of 42, line is set equal to the empty.
Using cin >> n skips leading whitespace on the input, but leaves the rest of the line, in this case just '\n', for the next input.
A statement like cin >> n; VideoNote Example using cin and getline with the class 480 Chapter 8 / Strings and Vectors always leaves something on the line for a following getline to read (even if it is just the '\n').
In this case, the getline sees the '\n' and stops reading, so getline reads an empty.
If you find your program appearing to mysteriously ignore input data, see if you have mixed these two kinds of input.
You may need to use either the new_line function from Display 8_0_5 or the function ignore from the library iostream.
For example, cin_0_ignore(1000, '\n'); With these arguments, a call to the ignore member function will read and discard the entire rest of the line up to and including the '\n' (or until it discards 1000 characters if it does not find the end of the line after 1000 characters).
There can be other baffling problems with programs that use cin with both >> and getline.
Moreover, these problems can come and go as you move from one Cplus_plus compiler to another.
When all else fails, or if you want to be certain of portability, you can resort to character-by-character input using cin_0_get.
These problems can occur with any of the versions of getline that we discuss in this chapter.
You can access the characters in a string object in the same way that you access array elements, so string objects have all the advantages of arrays of characters plus a number of advantages that arrays do not have, such as automatically increasing their capacity.
If last_name is the name of a string object, then last_name[i] gives access to the ith character in the string represented by last_name.
This use of array square brackets is illustrated in Display 8_0_6.
Display 8_0_6 also illustrates the member function length.
Every string object has a member function named length that takes no arguments and returns the length of the string represented by the string object.
Thus, not only can a string object be used like an array but the length member function makes it behave like a partially filled array that automatically keeps track of how many positions are occupied.
When used with an object of the class string, the array square brackets do not check for illegal indexes.
If you use an illegal index (that is, an index that is greater than or equal to the length of the string in the object), then the results are unpredictable but are bound to be bad.
You may just get strange behavior without any error message that tells you that the problem is an illegal index value.
There is a member function named at that does check for illegal index values.
This member function behaves basically the same as the square brackets, except for two points: You use function notation with at, so instead 8_0_2 The Standard string Class Display 8_0_6   A string Object Can Behave Like an Array 1 2 3 4.
Sample Dialogue Enter your first and last name: John Crichton Your last name is spelled: C r  c h t o n - - - - - - - Good  John of a[], you use a_0_at(); and the at member function checks to see if evaluates to an illegal index.
If the value of  in a_0_at() is an illegal index, then you should get a run-time error message telling you what is wrong.
In the following two example code fragments, the attempted access is out of range, yet the first of these probably will not produce an error message, although it will be accessing a nonexistent indexed variable: string ("Mary");.
Chapter 8 / Strings and Vectors.
You can change a single character in the string by assigning a char value to the indexed variable, such as [].
For example, to change the third character in the string object  to 'X', you can use either of the following code fragments: _0_(2) = 'X';.
As in an ordinary array of characters, character positions for objects of type string are indexed starting with 0, so  third character in a string is in index position 2.
Display 8_0_7 gives a partial list of  member functions of  class string.
In many ways, objects of  class string are better behaved than C strings we introduced in Section 8_0_1.
In particular,  == operator on objects of   class returns a result that corresponds to our intuitive notion of strings being equal—namely, it returns true if  two strings contain  same characters in  same order, and returns false otherwise.
Similarly,  comparison  <, >, < =, > = compare  objects using lexicographic ordering.
If  strings consist of all letters and are both either all uppercase or all lowercase letters, then for this case lexicographic ordering is  same as Example Remarks.
All are lexicographical comparisons.
Returns index of  first occurrence of 1 in.
Palindrome Testing A palindrome is a  that reads  same front to back as it does back to front.
The program in Display 8_0_8 tests an input  to see if it is a palindrome.
Our palindrome test will disregard all spaces and punctuations and will consider upper- and lowercase versions of a letter to be  same when deciding if something is a palindrome.
Some palindrome examples are as follows: Able was I ere I saw Elba.
I Love Me, Vol.
Madam, I'm Adam.
A man, a plan, a canal, Panama.
Rats live on no evil star.
The member function substr extracts a substring of  calling object, given  position and length of  desired substring.
Chapter 8 / Strings  Vectors 66 67 68 69 70 71.
Sample Dialogue Enter a candidate for palindrome test followed by pressing Return.
Madam, I'm Adam.
Sample Dialogue Enter a candidate for palindrome test followed by pressing Return.
Radar "Radar" is a palindrome.
Sample Dialogue Enter a candidate for palindrome test followed by pressing Return.
To do this, a string that is the substring of s, of length 1 at each character position, is extracted.
If this one-character string is not in the punct string, then the onecharacter string is concatenated to the  string that is to be returned.
They do not misbehave as they do with the C strings, as we discussed in Section 8_0_1 Self-Te st E xer cis e.
Enter a line of input: Hello friend.
Converting Between string Objects  C Strings You have already seen that Cplus_plus will perform an automatic type conversion to allow you to store a C string in a variable of type string.
For example, the following will work fine: 487.
To obtain the C string corresponding to a string object, you must perform an explicit conversion.
As we noted earlier in this chapter, the assignment operator does not work with C strings.
So, just in case you thought the following might work, we should point out that it too is illegal.
Use stof, stod, stoi, or stol to convert a string to a float, double, int, or long, respectively.
Use to_string to convert a numeric type to a string.
These functions are illustrated in the following example:.
In Cplus_plus, once your program creates an array, it cannot change the length of the array.
Vectors serve the same purpose as arrays except that they can change length while the program is running.
Vectors are part of a standard Cplus_plus library known as the STL (Standard Template Library), which we cover in more detail in Chapter 18.
You need not read the previous sections of this chapter before covering this section.
Vector Basics Like an array, a  has a base type,  like an array, a  stores a collection of values of its base type.
However, the syntax for a  type a  variable declaration are different from the syntax for arrays.
You declare a variable v for a  with base type int as follows: <int> v; notation  <Base_Type> is a template class, which means you can plug in any type for Base_Type  that will produce a class for vectors with that base type.
You can think of this as specifying the base type for a  in the same sense as you specify a base type for an array.
You can use any type, including class types, as the base type for a.
Vector elements are indexed starting with 0, the same as arrays.
For example, the following changes the value of the ith element v[] = 42; << " answer  " << v[]; There , however, a restriction on this use of the square brackets notation with vectors that  unlike the same notation used with arrays.
You can use v[] to change the value of the ith element.
However, you cannot initialize the ith element using v[]; you can only change an element that has already been given some value.
To add an element to an index position of a  for the first time, you would normally use the member function push_back.
Declaring a variable 490 Chapter 8 / Strings  Vectors You add elements to a  in order of positions, first at position 0, then position 1, then 2,  so forth.
For example, the following gives initial values to elements 0, 1, and 2 of the  :.
The number of elements in a   called the size of the.
The member function size can be used to determine how many elements are in a.
For example, after the previously shown code  executed, _0_size( ) returns 3.
You can write out all the elements currently in the   as follows: << [] << endl; The function size returns a value of type unsigned int, not a value of type int.
If you want to be very safe, you can always apply a type cast to convert the returned unsigned int to an int or, in cases like this for loop, use a loop control variable of type unsigned int as follows: << [] << endl;.
There  a  constructor that takes one integer argument and will initialize the number of positions given as the argument.
For example, if you declare v as follows: <int> v(10); then the first ten elements are initialized to 0, and v_0_size( ) would return 10.
You can then set the value of the ith element using v[] for values of equal to 0 through 9.
In particular, the following could immediately follow the declaration: v[] = ; 8_0_3 Vectors Display 8_0_9   Using a Vector 1 2 3.
Sample Dialogue Enter a list of positive numbers.
Place a negative number at the end.
When you use the constructor with an integer argument, vectors of numbers are initialized to the zero of the number type.
If the  base type a class type, the default constructor  used for initialization.
Chapter 8 / Strings and Vectors The  definition  given in the library , which places it in the std namespace.
Thus, a file that uses vectors would  the following (or.
Using Square Brackets Beyond the Vector Size If v  a  and   greater than or equal to v_0_( ), then the element v[] does not yet exist and needs to be created by using push_back to add.
If it needs more capacity to store another element, its capacity is automatically increased.
Vectors are defined in the library <>, which places them in the std namespace.
Thus, a file that uses vectors would  the following (or something similar): # <> using namespace std;.
Elements are added to a  using the member function push_back, as illustrated below: v_0_push_back(42); Once an element position has received its first element, either with push_back or with a constructor initialization, that element position can then be accessed using square bracket notation, just like an array element.
Vector Assignment Is Well Behaved The assignment operator with vectors does an element-by-element assignment to the  on the left-hand side of the assignment operator (increasing capacity if needed and resetting the  of the  on the left-hand side of the assignment operator).
Thus, provided the assignment operator on the base type makes an independent copy of the element of the base type, then the assignment operator on the  will make an independent copy.
Note that for the assignment operator to produce a totally independent copy of the  on the right-hand side of the assignment operator requires that the assignment operator on the base type make completely independent as the assignment operator on its base type.
Do not confuse the capacity of a  with the  of a.
The  is the number of elements in a , while the capacity is the number of elements for which there is memory allocated.
Typically, the capacity is larger than the , and the capacity is always greater than or equal to the.
Whenever a  runs out of capacity and needs room for an additional member, the capacity is automatically increased.
The exact amount of the increase is implementation-dependent but always allows for more capacity than is immediately needed.
A commonly used implementation scheme is for the capacity to double whenever it needs to increase.
Since increasing capacity is a complex task, this approach of reallocating capacity in large chunks is more efficient than allocating numerous small chunks.
Size and Capacity The  of a  is the number of elements in the.
The capacity of a  is the number of elements for which it currently has memory allocated.
For a  v, the  and capacity can be recovered with the member functions v_0_( ) and v_0_capacity( ).
You can completely ignore the capacity of a  and that will have no effect on what your program does.
However, if efficiency is an issue, you might want to manage capacity yourself and not simply accept the default behavior of doubling capacity whenever more is needed.
You can use the member function reserve to explicitly increase the capacity of a.
Note that you can rely on v_0_reserve to increase the capacity of a , but it does not necessarily decrease the capacity of a  if the argument is smaller than the current capacity.
You can change the  of a  using the member function resize.
For example, the following resizes a  to 24 : v_0_resize(24); If the previous  was less than 24, then the new  are initialized as we described for the constructor with an integer argument.
If the previous was greater than 24, then all but the first 24  are lost.
The capacity is automatically increased if need be.
Using resize and reserve, you can shrink the  and capacity of a  when there is no longer any need for some or some capacity.
Self-Te st Exe r cis e s.
Answers to Self-Test Exercises Chapter Summary ■ A C-string variable is  same thing as an array of characters, but it is used in a slightly different way.
A string variable uses  null character '\0' to mark  end of  string stored in  array.
In particular, you cannot assign a C-string value to a C-string variable using  equal , =, and you cannot compare  values in two C-string variables using == operator.
Instead, you must use special C-string functions to perform these tasks.
In particular, assignment  equal , =  ==, have their intuitive meaning when used with objects of  class string.
Answe rs to S e lf-T est Exerci ses 1.
The following two are equivalent to each other (but not equivalent to any.
Chapter 8 / Strings  Vectors 4.
If strlen were not already defined for you, you could use  following definition: //Precondition: str contains a string value terminated.
The maximum number of characters is five because  sixth position is needed for  null terminator ('\0').
The first of these places  null character '\0' in array after  characters 'a', 'b',  'c'.
The second only assigns successive positions 'a', 'b',  'c' but does not put a '\0' anywhere.
To protect memory beyond  end of  array, change  while condition as shown in (b).
The string "good, I hope_0_" is too long for a_string.
A chunk of memory that doesn't belong to  array a_string will be overwritten.
Practice Programs 13.
Enter some input: The time is now.
The-timeEND OF OUTPUT 14.
The complete dialogue is as follows: Enter a line of input: May  hair on your toes grow long  curly.
May t<END OF OUTPUT 15.
A*string<END OF OUTPUT 16.
A string is a joy forever_0_<END OF OUTPUT 17.
The complete dialogue is Enter a line of input: Hello friend.
Equal Remember, cin stops reading when it reaches a whitespace character such as a blank.
Hello Jello 19.
The program is legal.
The output is 0 1 2 3 4 5 6 7 8 9 Note that changing  does not change.
A true independent  is made with  assignment = ; 20.
The size is  number of elements in a , whereas  capacity is number of elements for which there is memory allocated.
Typically, capacity is larger than  size.
Practice Programs Practice Programs can generally be solved with a short program that directly applies programming principles presented in this chapter.
Create a Cstring variable that contains a name, age,  title.
Each field is separated by a space.
For example,  string might contain "Bob 45 Programmer" or any other name/age/title in  same format.
Assume name, age,  title have no spaces themselves.
Write a program using only functions from cstring (not the class string) that can extract the name, age,  title into separate variables.
Test your program with a variety of names, ages,  titles.
Chapter 8 / Strings  Vectors 2.
Repeat Practice Program 1 except use the class string to extract the fields, not the cstring functions.
Write a program that inputs a first and last name, separated by a space, into a string variable.
Use the string functions to output the first and last initial.
Embed your code into a do-while loop.
At the end of the loop ask the user if he or she would like to repeat the program.
Input the user's choice into a char using cin.
If the character is 'y' then repeat the program, otherwise exit.
Beware of the pitfall with newlines when cin is mixed with getline.
Write a function named firstLast2 that takes as input a vector of integers.
The function should return true if the vector starts or ends with the digit 2.
Otherwise it should return false.
Test your function with vectors of different length and with the digit 2 at the beginning of the vector, end of the vector, middle of the vector, and missing from the vector.
Write a function named swapFrontBack that takes as input a vector of integers.
The function should swap the first element in the vector with the last element in the vector.
The function should check if the vector is empty to prevent errors.
Test your function with vectors of different length and with varying front and back numbers.
Do Practice Program 7_0_4 except change the program to use vectors of strings instead of arrays of strings.
Write a program that inputs two  variables, first and last, each of which the user should enter with his or her name.
First, convert both strings to all lowercase.
Your program should then create a new  that contains the full name in Pig Latin with the first letter capitalized for the first and last name.
The rules to convert a word into Pig Latin are as follows: If the first letter is a consonant, move it to the end and add "ay" to the end.
If the first letter is a vowel, add "way" to the end.
For example, if the user inputs "Erin" for the first name and "Jones" for the last name, then the program should create a new  with the text "Erinway Onesjay" and print it.
Programming Projects Programming Projects require more problem-solving than Practice Programs and can usually be solved many different ways.
Visit www_0_myprogramminglab_0_com to complete many of these Programming Projects online and get instant feedback.
VideoNote Solution to Programming Project 8_0_1 1.
Write a program that reads in a sentence of up to 100 characters and outputs the sentence with spacing corrected and with letters corrected for Programming Projects capitalization.
In other words, in the output sentence, all strings of two or more blanks should be compressed to a single blank.
The sentence should start with an uppercase letter but should contain no other uppercase letters.
Do not worry about proper names; if their first letters are changed to lowercase, that is acceptable.
Treat a line break as if it were a blank, in the sense that a line break and any number of blanks are compressed to a single blank.
Assume that the sentence ends with a period and contains no other periods.
For example, the input the Answer to life, the Universe, and IS 42.
Write a program that will read in a line of text and output the number of words in the line and the number of occurrences of each letter.
Define a word to be any  of letters that is delimited at each end by either whitespace, a period, a comma, or the beginning or end of the line.
You can assume that the input consists entirely of letters, whitespace, commas, and periods.
When outputting the number of letters that occur in a line, be sure to count upper- and lowercase versions of a letter as the same letter.
Output the letters in alphabetical order and list only those letters that do occur in the input line.
For example, the input line I say Hi.
Give the function definition for the function with the following function.
You can assume that the user types in the input in normal everyday notation, such as 23_0_789, and does not use e-notation to type in the number.
Model your definition after the definition of the function get_int given in Display 8_0_3 so that your function reads the input as characters, edits the  of characters, and converts the resulting to a number of type double.
You will need to define a function like 499.
Chapter 8 / Strings and Vectors read_and_clean that is more sophisticated than the one in Display 8_0_2, since it must cope with the decimal point.
This is a fairly easy project.
For a more difficult project, allow the user to enter the number in either the normal everyday notation, as discussed above, or in e-notation.
Your function should decide whether or not the input is in e-notation by reading the input, not by asking the user whether she or he will use e-notation.
Write a program that reads a person's name in the following format: first name, then middle name or initial, and then last name.
The program then outputs the name in the following format: Last_Name, First_Name Middle_Initial.
For example, the input Mary Average User should produce the output: User, Mary A.
The input Mary A.
User should also produce the output: User, Mary A.
Your program should work the same and place a period after the middle initial even if the input did not contain a period.
Your program should allow for users who give no middle name or middle initial.
In that case, the output, of course, contains no middle name or initial.
For example, the input Mary User should produce the output User, Mary If you are using C strings, assume that each name is at most 20 characters long.
Alternatively, use the class.
Write a program that reads in a line of text and replaces all four-letter words with the word "love".
For example, the input string I hate you, you dodo.
Programming Projects should produce the output I love you, you love.
Of course, the output will not always make sense.
For example, the input string John will run home.
If the four-letter word starts with a capital letter, it should be replaced by "Love", not by "love".
You need not check capitalization, except for the first letter of a word.
A word is any string consisting of the letters of the alphabet and delimited at each end by a blank, the end of the line, or any other character that is not a letter.
Your program should repeat this action until the user says to quit.
Write a program that reads in a line of text and outputs the line with all the digits in all integer numbers replaced with 'x'.
For example, Input: My userID is john17 and my 4 digit pin is 1234 which is secret.
Output: My userID is john17 and my x digit pin is xxxx which is secret.
Note that if a digit is part of a word, then the digit is not changed to an 'x'.
For example, note that john17 is NOT changed to johnxx.
Include a loop that allows the user to repeat this calculation again until the user says she or he wants to end the program.
Write a program that can be used to train the user to use less sexist language by suggesting alternative versions of sentences given by the user.
The program will ask for a sentence, read the sentence into a string variable, and replace all occurrences of masculine pronouns with gender-neutral pronouns.
For example, it will replace "he" with "she or he".
Thus, the input sentence See an adviser, talk to him, and listen to him.
Be sure to preserve uppercase letters for the first word of the sentence.
The pronoun "his" can be replaced by "her (s)"; your program need 501.
Chapter 8 / Strings and Vectors not decide between "her" and "hers".
Allow the user to repeat this for more sentences until the user says she or he is done.
This will be a long program that requires a good deal of patience.
Your program should not replace the string "he" when it occurs inside another word, such as "here".
A word is any string consisting of the letters of the alphabet and delimited at each end by a blank, the end of the line, or any other character that is not a letter.
Allow your sentences to be up to 100 characters long.
Write a sorting function that is similar to Display 7_0_12 in Chapter 7 except that it has an argument for a vector of ints rather than an array.
This function will not need a parameter like number_used as in Display 7_0_12, since a vector can determine the number used with the member function size().
This sort function will have only this one parameter, which will be of a vector type.
Use the selection sort algorithm (which was used in Display 7_0_12).
Redo Programming Project 5 from Chapter 7, but this time use vectors instead of arrays.
You should do either Programming Project 8 or 9 before doing this one.
However, you will need to write your own (similar) sorting code for this project rather than using the sorting function from Programming Project 7 or 8 with no changes.
Your country is at war and your enemies are using a secret code to communicate with each other.
You have managed to intercept a message that reads as follows: :mmZ\dxZmx]Zpgy The message is obviously encrypted using the enemy's secret code.
You have just learned that their encryption method is based upon the ASCII code.
Appendix 3 shows the ASCII character set.
Individual characters in a string are encoded using this system.
For example, the letter "A" is encoded using the number 65 and "B" is encoded using the number 66.
Your enemy's secret code takes each letter of the message and encrypts it as follows: If (OriginalChar +  > 126) then Else For example, if the enemy uses  = 10 then the message "Hey" would be encrypted as: Programming Projects Character ASCII code.
The ASCII codes for the unencrypted message are limited to the visible ASCII characters.
You only know that the key used is a number between 1 and 100.
Your program should try to decode the message using all possible keys between 1 and 100.
When you try the valid key, the message will make sense.
For all other keys, the message will appear as gibberish.
Write a program that inputs a time from the console.
The time should be in the format "HH:MM AM" or "HH:MM PM".
Hours may be one or two digits, for example, "1:10 AM" or "11:30 PM".
Your program should include a function that takes a string parameter containing the time.
This function should convert the time into a four-digit military time based on a 24-hour clock.
For example, "1:10 AM" would output "0110 hours", "11:30 PM" would output "2330 hours", and "12:15 AM" would output "0015 hours".
The function may either write the time to the console or return a string to be written to the console by the main function.
The XML (eXtensible Markup Language) is a common format used to structure and store data on the Web.
The following is a small sample XML file that could be used to store names in an address book.
Type it in using a text editor and save it to a file named address_0_xml (or find it at the accompanying website).
Chapter 8 / Strings and Vectors <city>Palmdale</city> <state>CA</state> <zip>93352</zip> </contact> <contact> <name>Paris Hilton</name> <street>200 S.
Elm St_0_</street> <city>Beverly Hills</city> <state>CA</state> <zip>90212</zip> </contact> <contact> <name>Wendy Jones</name> <street>982 Boundary Ave_0_</street> <city>Palmdale</city> <state>CA</state> <zip>93354</zip> </contact> </address_book> The sample file contains four contacts.
The <> tag denotes the start of a field and the </> tag denotes the end of the field.
Write a program that reads in the address_0_xml file and outputs the names and addresses of everyone in Palmdale.
Your program shouldn't output any of the tag information, just the address content.
Write a program that reads in the address.
You may assume that each contact in the address file has the same structure and the same fields.
However, your solution should be able to handle an input file with any number of contacts and should not assume that the fields within each contact are in the same order.
Given the following header: VideoNote Solution to Programming Project 8_0_14 <string> split(string target, string delimiter);.
Programming Projects should return a  with the strings "do", "re", "mi", "fa", "so", "la", "ti", and "do".
Write a function that determines if two strings are anagrams.
The function should not be case sensitive and should disregard any punctuation or spaces.
Two strings are anagrams if the letters can be rearranged to form each other.
For example, "Eleven plus two" is an anagram of "Twelve plus one_0_"Each string contains one "v", three "'s", two "l's", etc.
Test your function with several strings that are anagrams and non-anagrams.
You may use either the string class or a C-style string.
In many races competitors wear an RFID tag on their shoe or bib.
When the racer crosses a sensor a computer logs the racer's number along with the current time.
Sensors can be placed along the course to accurately calculate the racer's finish time or pace and also to verify that the racer crossed key checkpoints.
Consider such a system in use for a half marathon running race, which is 13_0_1 miles.
In this problem there are only three sensors: at the , at the 7 mile point, and at the finish line.
Here is sample data for three racers.
The first line is the gun time in the 24 hour time format (HH MM SS).
The gun time is when the race begins.
Subsequent lines are recorded by sensors and contain the sensor ID (0=, 1=, 2=finish) followed by the racer's number followed by the time stamp.
The  time may be different than the gun time ­because sometimes it takes a racer a little while to get to the starting line when there is a large pack.
Write a program that reads the log data into array(s) or (s).
The program should then allow a user to enter a racer's number and it should output the racer's overall finish place, race split times in minutes/mile for each split (i_0_e.
For a more challenging version modify your program so that it works with an arbitrary number of sensors placed at different locations along the course instead of just 3 locations.
You will need to specify the mile marker for each sensor.
Chapter 8 / Strings and Vectors 17.
Based on the log file described in Programming Project 16 write a program to detect cheating.
A racer misses a sensor, which is a sign that the racer may have taken a shortcut.
A race split is suspiciously fast, which is a sign that the racer may have hopped in a vehicle.
In this case, a race split faster than 4:30 per mile can be considered suspicious.
The output should be a list of suspected cheaters along with the reason for suspicion.
Pointers and Dynamic Arrays 9 9_0_1 Pointers 508 Pointer Variables 509 Basic Memory Management 516 Pitfall: Dangling Pointers 517 Static Variables and Automatic Variables 518 Programming Tip: Define Pointer Types 518 9_0_2 Dynamic Arrays 521 Array Variables and Pointer Variables 521 Creating and Using Dynamic Arrays 522 Pointer Arithmetic (Optional ) 528 Chapter Summary 532 Answers to Self-Test Exercises Practice Programs 533 Programming Projects 534 532 530 Memory is necessary for all the operations of reason.
Blaise Pascal, Pensées Introduction A pointer is a construct that gives you more control of the computer's memory.
This chapter shows how pointers are used with arrays and introduces a new form of array called a dynamic array.
Dynamic arrays are arrays whose size is determined while the program is running, rather than being fixed when the program is written.
Prerequisites Section 9_0_1, which covers the basics of pointers, uses material from Chapters 2 through 6.
It does not require any of the material from Chapters 7 or 8.
Section 9_0_2, which covers dynamic arrays, uses material from Section 9_0_1, and Chapters 2 through 7.
It does not require any of the material from Chapter 8.
Zen saying A pointer is the memory address of a variable.
Recall that the computer's memory is divided into numbered memory locations (called bytes) and that variables are implemented as a sequence of adjacent memory locations.
Recall also that sometimes the Cplus_plus system uses these memory addresses as names for the variables.
If a variable is implemented as, say, three memory locations, then the address of the first of these memory locations is sometimes used as a name for that variable.
For example, when the variable is used as a call-byreference argument, it is this address, not the identifier name of the variable, that is passed to the calling function.
An address that is used to name a variable in this way (by giving the address in memory where the variable starts) is called a pointer because the 9_0_1 Pointers 509 You have already been using pointers in a number of situations.
As we noted in the previous paragraph, when a variable is a call-by-reference argument in a function call, the function is given this argument variable in the form of a pointer to the variable.
This is an important and powerful use for pointers, but it is done automatically for you by the Cplus_plus system.
In this chapter, we show you how to write programs that manipulate pointers in any way you want, rather than relying on the system to manipulate the pointers for you.
Pointer Variables A pointer can be stored in a variable.
However, even though a pointer is a memory address and a memory address is a number, you cannot store a pointer in a variable of type int or double without type casting.
A variable to hold a pointer must be declared to have a pointer type.
For example, the following declares p to be a pointer variable that can hold one pointer that points to a variable of type double: double *p; The variable p can hold pointers to variables of type double, but it cannot normally contain a pointer to a variable of some other type, such as int or char.
Each variable type requires a different pointer type.
In general, to declare a variable that can hold pointers to other variables of a specific type, you declare the pointer variable just as you would declare an ordinary variable of that type, but you place an asterisk in front of the variable name.
For example, the following declares the variables p1 and p2 so that they can hold pointers to variables of type int; it also declares two ordinary variables, v1 and v2, of type int: int *p1, *p2, v1, v2; There must be an asterisk before each of the pointer variables.
If you omit the second asterisk in the previous declaration, then p2 will not be a pointer variable; it will instead be an ordinary variable of type int.
The asterisk is the same symbol you have been using for multiplication, but in this context it has a totally different meaning.
When discussing pointers and pointer variables, we usually speak of pointing rather than of addresses.
When a pointer variable, such as 1, contains the address of a variable, such as v1, the pointer variable is said to point to the variable v1 or to be a pointer to the variable v1.
Pointer variables, like 1 and 2 declared earlier, can contain pointers to variables like v1 and v2.
You can use the operator & to determine the address of a variable, and you can then assign that address to a pointer variable.
For example, the following will set the variable 1 equal to a pointer that points to the variable v1: 1 = &v1; Declaring pointer.
Addresses and Numbers A pointer is an address, and an address is an integer, but a pointer is not an integer.
Cplus_plus insists that you use a pointer as an address and that you not use it as a number.
A pointer is not a value of type int or of any other numeric type.
You normally cannot store a pointer in a variable of type int.
If you try, most Cplus_plus compilers will give you an error message or a warning message.
Also, you cannot perform the normal arithmetic operations on pointers.
This is the same asterisk that we used when we declared 1, but now it has yet another meaning.
When the asterisk is used in this way, it is often called the dereferencing operator, and the pointer variable is said to be dereferenced.
Putting these pieces together can produce some surprising results.
Consider the following code:.
So when you set *1 equal to 42, you are also setting 1 equal to 42.
The symbol & that is used to obtain the address of a variable is the same symbol that you use in function declarations to specify a call-byreference parameter.
Recall that a callby-reference argument is implemented by giving the address of the argument to the calling function.
However, the usages are slightly different and we will consider them to be two different (although very closely related) usages of the symbol &.
The * and & Operators The *operator in front of a pointer variable produces the variable it points to.
When used this way, the *operator is called the dereferencing operator.
The operator & in front of an ordinary variable produces the address of that variable; that is, produces a pointer that points to the variable.
The & operator is called the address-of operator.
For example, consider the declarations double *, ; The following sets the value of  so that  points to the variable : = &; * produces the variable pointed to by , so after the assignment above, * and  refer to the same variable.
For example, the following sets the value of  to 9_0_99, even though the name  is never explicitly used: * = 9_0_99; You can assign the value of one pointer variable to another pointer variable.
This copies an address from one pointer variable to another pointer variable.
For example, if 1 is still pointing to 1, then the following will set 2 so that it also points to 1: 2 = 1;.
When you add the asterisk, you are not dealing with the pointers 1 and 2, but with the variables that the pointers are pointing to.
This is illustrated in Display 9_0_1.
Since a pointer  be used to refer to a , your program manipulate variables even if the variables have no identifiers to name them.
The operator   be used to create variables that have no identifiers to serve as their names.
These  variables are referred to via pointers.
For example, the following creates a   of type  and sets the pointer 1 equal to the address of this   (that is, 1 points to this ,  ): 1 =  ; This ,    be referred to as *1 (that is, as the pointed to by 1).
For example, the following reads a of type  from the keyboard into this  , adds 7 to the , then outputs this  :.
You specify the type for this by writing the type name after the.
Variables that are created using the   are called dynamic variables because they are created and destroyed while the program is running.
The program in Display 9_0_2 demonstrates some simple operations on pointers and dynamic variables.
Display 9_0_3 illustrates the working of the program in Display 9_0_2.
In Display 9_0_3, variables are represented as boxes and the  of the  is written inside the box.
We have not shown the actual numeric addresses in the pointer variables.
The actual numbers are not important.
What is important is that the number is the address of some particular.
So, rather than use the actual number of the address, we have merely indicated the address with an arrow that points to the  with that address.
For example, in illustration (b) in Display 9_0_3, 1 contains the address of a  that has a question mark written in it.
Chapter 9 / Pointers and Dynamic Arrays Sample Dialogue *1 == 42 *2 == 42 *1 == 53 *2 == 53 *1 == 88 *2 == 53 Hope you got the point of this example.
Pointer Variables   = If 1 and 2 are pointer variables, then the statement.
The  Operator The   creates a    of a specified type and returns a pointer that points to this.
For example, the following creates a    of type  and leaves the pointer   pointing to this  : *; =  ;.
It is possible to "catch" the exception or install a  , but these topics are not covered until Chapter 16.
What unfortunate misinterpretation can occur  the following declaration.
Give at least two uses of the *.
Basic Memory Management A special area of memory, called the freestore, is reserved for variables.
Any new   created by a program consumes some of the memory in the freestore_0_2 If your program creates too many variables, it  consume all of the memory in the freestore.
If this happens, any additional calls to new  fail.
The size of the freestore varies by computer and implementation of Cplus_plus.
It is typically large, and a modest program is not likely to use all the memory in the freestore.
However, even on modest programs it is a good practice to recycle any freestore memory that is no longer needed.
The delete  eliminates a   and returns the memory that the   occupied to the freestore so that the memory can be reused.
Suppose that  is a pointer  that is pointing to a.
The following  destroy the pointed to by  and return the memory used by the to the freestore: delete ; After this call to delete, the value of  is undefined and  should be treated like an uninitialized.
The delete Operator The delete  eliminates a   and returns the memory that the   occupied to the freestore.
The memory can then be reused to create new  variables.
For example, the following eliminates the   pointed to by the pointer  : delete ; After a call to delete, the value of the pointer , like  above, is undefined.
At that point, the value of the pointer  is undefined, which means that you do not know where it is pointing, nor what the value is where it is pointing.
Moreover, if some other pointer was pointing to the   that was destroyed, then this other pointer  is also undefined.
These undefined pointer variables are called dangling pointers.
If  is a dangling pointer and your program applies the dereferencing  * to  (to produce the expression *), the result is unpredictable and usually disastrous.
Before you apply the dereferencing operator *to a pointer variable, you should be certain that the pointer variable points to some variable.
Chapter 9 / Pointers and Dynamic Arrays Static Variables and Automatic Variables Variables created with the new  are called  variables, because they are created and destroyed while the program is running.
When compared with these  variables, ordinary variables seem static, but the terminology used by Cplus_plus programmers is a bit more involved than that, and ordinary variables are not called static variables.
The ordinary variables we have been using in previous chapters are not really static.
If a variable is local to a function, then the variable is created by the Cplus_plus system when the function is called and is destroyed when the function call is completed.
Since the main part of a program is really just a function called main, this is even true of the variables declared in the main part of your program.
We  usually call these variables ordinary variables, but other books call them automatic variables.
There is one other category of variables, namely, global variables.
Global variables are variables that are declared outside of any function definition (including being outside of main).
We discussed global variables briefly in Chapter 4.
As it turns out, we have no need for global variables and have not used them.
For example, the following defines a type called IntPtr, which is the type for pointer variables that contain pointers to variables: typedef * IntPtr;.
For example, the following defines the type name Kilometers to mean the same thing as the type name double: typedef double Kilometers;.
Kilometers distance; Renaming existing types this way can occasionally be useful.
However, our main use of typedef  be to define types for pointer variables.
There are two advantages to using defined pointer type names, such as IntPtr defined earlier.
First, it avoids the mistake of omitting an asterisk.
Remember, if you intend 1 and 2 to be pointers, then the following is a mistake: *1, 2; Since the * was omitted from the 2, the variable 2 is just an ordinary int variable, not a pointer variable.
If you get confused and place the * on the int, the problem is the same but is more difficult to notice.
Cplus_plus allows you to place the * on the type name, such as int, so that the following is legal: int* p1, p2; Although this line is legal, it is misleading.
It looks like both p1 and p2 are pointer variables, but in fact only p1 is a pointer variable; p2 is an ordinary int variable.
As far as the Cplus_plus compiler is concerned, the *that is attached to the identifier int may as well be attached to the identifier p1.
One correct way to declare both p1 and p2 to be pointer variables is int *p1, *p2;.
IntPtr p1, p2; The second advantage of using a defined pointer type, such as IntPtr, is seen when you define a function with a call-by-reference parameter for a pointer variable.
Without the defined pointer type name, you would need to include both an * and an & in the function declaration for the function, and the details can get confusing.
If you use a type name for the pointer type, then a call-by-reference parameter for a pointer type involves no complications.
You define a call-by-reference parameter for a defined pointer type just like you define any other call-by-reference parameter.
Here's a sample: void sample_function(IntPtr& pointer_variable);.
Chapter 9 / Pointers and Dynamic Arrays Type Definitions You can assign a name to a type definition and then use the type name to declare variables.
This is done with the keyword typedef.
These type definitions are normally placed outside of the body of the main part of your program (and outside the body of other functions).
We will use type definitions to define names for pointer types, as shown in the example below.
Write a definition for a type called NumberPtr that will be the type for pointer variables that hold pointers to  variables of type int.
Also, write a declaration for a pointer variable called my_point that is of type NumberPtr.
You will also find out how to write programs with  arrays.
A array is an array whose size is not specified when you write the program, but is determined while the program is running.
Array Variables and Pointer Variables In Chapter 7 we described how arrays are kept in memory.
At that point we had not learned about pointers, so we discussed arrays in terms of memory addresses.
But, a memory address is a pointer.
So, in Cplus_plus an array variable is actually a pointer variable that points to the first indexed variable of the array.
Given the following two variable declarations,  and a are the same kind of variable:.
The fact that a and  are the same kind of variable is illustrated in Display 9_0_4.
Since a is a pointer that points to a variable of type int (namely the variable a[0]), the value of a can be assigned to the pointer variable  as follows: = a; After this assignment,  points to the same memory location that a points to.
So, [0], [1], … [9] refer to the indexed variables [0], [1], … [9].
The square bracket notation you have been using for arrays applies to pointer variables as long as the pointer variable points to an array in memory.
After this assignment, you can treat the identifier  as if it were an array identifier.
You can also treat the identifier  as if it were  pointer variable, but there is one important reservation.
You cannot change the pointer value in an array variable, such as.
You might be tempted to think the following is legal, but it is not: IntPtr 2; _0__0__0_//2 is given some pointer value.
You cannot assign  different address to.
Display 9_0_5 illustrates the working of the program in Display 9_0_4.
As in Display 9_0_3, variables are represented as boxes and the value of the variable is written inside the box.
An arrow indicates  pointer or reference to another memory location, in this case, the first element of the array.
Chapter 9 / Pointers and Dynamic Arrays Display 9_0_4   Arrays and Pointer Variables 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30.
Note that changes to the array.
For example, an array might hold  list of student identification numbers, but the size of the class may be different each time the program is run.
With the kinds of arrays you have used thus far, you must estimate the largest possible size you may need 9_0_2 Dynamic Arrays.
IntPtr ; int [10];.
Chapter 9 / Pointers and Dynamic Arrays Creating a dynamic array for the array and hope that size is large enough.
First, you may estimate too low, and then your program will not work in all situations.
Second, since the array might have many unused positions, this can waste computer memory.
Dynamic arrays avoid these problems.
If your program uses a dynamic array for student identification numbers, then the size of the class can be entered as input to the program and the dynamic array can be created to be exactly that size.
Dynamic arrays are created using the new.
The creation and use of dynamic arrays is surprisingly simple.
Since array variables are pointer variables, you can use the new  to create dynamic variables that are arrays and treat these dynamic array variables as if they were ordinary arrays.
For example, the following creates a dynamic array variable with ten array elements of type :.
To obtain a dynamic array of elements of any other type, simply replace with  desired type.
To obtain a dynamic array variable of any other size, simply replace 10 with  desired size.
There are also a number of less obvious things to notice about this example.
First,  pointer type that you use for a pointer to a dynamic array is  same as pointer type you would use for a single element of  array.
For instance, pointer type for an array of elements of type  is  same as  pointer type you would use for a simple variable of type.
The pointer to  array is actually a pointer to  first indexed variable of  array.
In  previous example, an entire array with ten indexed variables is created and  pointer  is left pointing to  first of these ten indexed variables.
Also notice that when you call ,  size of  dynamic array is given in square brackets after  type, which in this example is  type.
This tells  computer how much storage to reserve for  dynamic array.
If you omit  square brackets and  10,  computer will allocate enough storage for only one variable of type , rather than for an array of ten indexed variables of type.
As illustrated in Display 9_0_6, you can use an int variable in place of  constant 10 so that  size of  dynamic array can be read into  program.
The program in Display 9_0_6 sorts a list of numbers.
This program works for lists of any size because it uses a dynamic array to hold  numbers.
The size of  array is determined when  program is run.
The user is asked how many numbers there will be, and then    creates a dynamic array of that size.
The size of  dynamic array is given by  variable array_ size.
Notice  delete statement, which destroys  dynamic array variable a in Display 9_0_6.
Since  program is about to end anyway, we did not really need this delete statement; however, if  program went on to do other 9_0_2 Dynamic Arrays 525 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46.
Chapter 9 / Pointers and Dynamic Arrays 47 48 49 50 51 52 53.
This may or may not require some additional < function definitions.
The implementation need not even know that sort will be called with  dynamic array.
For example, you can use the implementation in Display 7_0_12 (with suitable adjustments to parameter names)_0_> things with dynamic variables, you would want such  delete statement so that the memory used by this dynamic array is returned to the freestore.
The delete statement for  dynamic array is similar to the delete statement you saw earlier, except that with  dynamic array you must  an empty pair of square brackets, like so: delete [] ; The square brackets tell Cplus_plus that  dynamic array variable is being eliminated, so the system checks the  of the array and removes that many indexed variables.
If you omit the square brackets, you would be telling the computer to eliminate only one variable of type.
For example, delete ; is not legal, but the error is not detected by most compilers.
The ANSI Cplus_plus standard says that what happens when you do this is "undefined_0_" That means the author of the compiler can have this do anything that is convenient— convenient for the compiler writer, not for.
Even if it does something useful,  have no guarantee that either the next version of that compiler or any other compiler  compile this code with will do the same thing.
The moral is simple: Always use the delete [] ;.
You create  dynamic array with  call to    pointer, such as the pointer  in Display 9_0_6.
After the call to ,  should not assign any other pointer value to this pointer variable, because that can confuse the system when the memory for the dynamic array is returned to the freestore with  call to delete.
For example, if the dynamic array is an array of double,  might use the following: typedef double* DoubleArrayPtr; ■ Declare  pointer variable: Declare  pointer variable of this defined type.
The pointer variable will point to the dynamic array in memory and will serve as the name of the dynamic array.
The  can be given  an  variable or other  expression.
In the example above, array_size can be  variable of type  whose value is determined while the program is running.
For example, the indexed variables are written in the usual way: [0], [1], and so forth.
The pointer variable should not have any other pointer value assigned to it, but should be used like an array variable.
For example: delete [] ; Dynamic arrays are created     pointer variable.
When your program is finished   dynamic array,  should return the array memory to the freestore with  call to delete.
Other than that,  dynamic array can be used just like any other array.
S elf- T est Exerc ise s 9.
Write  type definition for pointer variables that will be used to point to dynamic arrays.
The array elements are to be of type char.
Call the type CharArray.
Write code to fill this array with ten numbers typed in at the keyboard.
Suppose your program contains code to create   array as in SelfTest Exercise 10,  suppose the pointer variable  has not had its (pointer) value changed.
Write code to destroy this   array return the memory it uses to the freestore.
What is the output of the following code fragment.
The code is assumed to be embedded in  correct  complete program.
What is the output of the following code fragment.
The code is assumed to be embedded in  correct  complete program.
There is  kind of arithmetic  can perform on pointers, but it is an arithmetic of addresses, not an arithmetic of numbers.
For example, suppose your program contains the following code:.
The expression  + 1 evaluates to the address of [1],  + 2 is the address of [2],  so forth.
Notice that although the value of  is an address an address is  number, +1 does not simply add 1 to the number in.
If  variable of type  requires 8 bytes (eight memory locations) contains the address 2001, then +1 evaluates to the memory address 2009.
Of course, the type  can be replaced by any other type  then pointer addition moves in units of variables for that type.
This pointer arithmetic gives  an alternative way to manipulate arrays.
For example, if  is the size of the  array pointed to by , then the following will output the contents of the  array: << *( + )<< " ";.
You may not perform multiplication or division of pointers.
All  can do is add an integer to  pointer, subtract an integer from  pointer, or subtract two pointers of the same type.
When  subtract two pointers, the result is the number of indexed variables between the two addresses.
Remember, for subtraction of two pointer values, these values must point into the same array.
It makes little sense to subtract  pointer that points into one array from another pointer that points into  different array.
You can use the increment decrement operators plus_plus  −−.
For example, dplus_plus will advance the value of  so that it contains the address of the next indexed variable,  −− will change  so that it contains the address of the previous indexed variable.
S elf- T est Exerc ise s These exercises apply to the optional section on pointer arithmetic.
What is the output of the following code fragment.
The code is assumed to be embedded in  correct  complete program.
Dynamic Arrays  Pointer Arithmetic 530 Chapter 9 / Pointers  Dynamic Arrays 15.
What is the output of the following code fragment.
The code is assumed to be embedded in  correct  complete program.
You can have multidimensional  arrays.
You just need to remember that multidimensional arrays are arrays of arrays, or arrays of arrays of arrays, or so forth.
For example, to create  two-dimensional array, you must remember that it is an array of arrays.
To create  twodimensional array of integers, you first create  one-dimensional array of pointers of type *, which is the type for  one-dimensional array of ints.
Then you create   array of ints for each indexed variable of the array of pointers.
A type definition may help to keep things straight.
The following is the variable type for an ordinary one-dimensional  array of ints: typedef * ;.
A simple program to illustrate this is given  Display 9_0_7.
Be sure to notice the use of delete  Display 9_0_7.
Since the array  is an array of arrays, each of the arrays created with new  the for loop must be returned to the freestore manager with  call to delete[];.
There must be one call to delete[] for each call to new  created an array.
Chapter 9 / Pointers and Dynamic Arrays Sample Dialogue Enter the row and column dimensions of the array: 3 4 Enter 3 rows of 4 integers each: 1 2 3 4 5 6 7 8 9 0 1 2 Echoing the two-dimensional array: 1 2 3 4 5 6 7 8 9 0 1 2 Chapter Summary ■ A pointer is  memory address, so  pointer provides  way to indirectly name  variable by naming the address of the variable  the computer's memory.
When a program is finished with a dynamic variable, the memory used by the dynamic variable can be returned to the freestore for reuse; this is done with a delete statement.
A dynamic array is implemented as a dynamic variable of an array type.
Answers to Self - Test Exerci ses 1.
A pointer is the memory address of a variable.
To the unwary, or to the neophyte, this looks like two objects of type pointer to ,  is, *.
Unfortunately, the * binds to the identifier, not to the type ( is, not to the ).
The result is  this declaration declares int_ptr1 to be an  pointer, while int_ptr2 is just an ordinary variable.
The new  takes a type for its argument.
It returns a pointer to  memory ( is, a pointer to  new dynamic variable), provided there is enough available memory in the freestore.
If there is not enough memory available in the freestore, your program ends.
In the C programming language there is no pass-by-reference syntax to pass a variable by reference to a function.
Instead a variable is passed by pointer (just to be confusing, sometimes passing by pointer is referred to as pass by reference).
This Practice Program asks you to do the same thing as C, which in 533.
Complete the function so it adds one to the integer referenced by ptrNum.
Write a main function where an integer variable is defined, give it an initial value, call addOne, and output the variable.
Write a program  asks the user to input an integer named numDoubles.
Create a dynamic array  can store numDoubles doubles and make a loop allows the user to enter a double into each array entry.
Loop through the array, calculate the average, and output it.
Delete the memory allocated to your dynamic array before exiting.
This Practice Program requires  you read the optional section about pointer arithmetic.
Complete the function isPalindrome so  it returns and false if it is not.
The function uses the cstring library.
Programming Projects Programming Projects require more problem-solving than Practice Programs and can usually be solved many different ways.
Visit www_0_myprogramminglab_0_com to complete many of these Programming Projects online and get instant feedback.
Do Programming Project 7 in Chapter 7 using a  array.
In this version of the problem, use  arrays to store the digits in each large Programming Projects integer.
Allow an arbitrary number of digits instead of capping the number of digits at 20.
Do Programming Project 3 in Chapter 7.
In this version of the problem, return a new  array where all repeated letters are deleted instead of modifying the partially filled array.
Don't forget to free the memory allocated for these returned  arrays when the data is no longer needed.
Do Programming Project 11 in Chapter 7 using a  array (or arrays).
In this version, your program will ask the user how many rows the plane has and will handle that many rows (and so not always assume the plane has 7 rows as it did in Programming Project 11 of Chapter 7).
Write a function that takes a C string as an input parameter and reverses the string.
The function should use two pointers,  and rear.
The  pointer should initially reference the first character in the string, and the rear pointer should initially reference the last character in the string.
Reverse the string by swapping the characters referenced by  and rear, then increment to point to the next character and decrement rear to point to the preceding character, and so on, until the entire string is reversed.
Write a main program to test your function on various strings of both even and odd length.
You run four computer labs.
Each lab contains computer stations that are numbered as shown in the table below: Lab Number Computer Station Numbers.
Whenever a user logs on, the user' ID, lab number, and the computer station number are transmitted to your system.
For example, if user 49193 logs onto station 2 in lab 3, then your system receives (49193, 2, 3) as input data.
Similarly, when a user logs off a station, then your system receives the lab number and computer station number.
Write a computer program that could be used to track, by lab, which user is logged onto which computer.
For example, if user 49193 is logged into station 2 in lab 3 and user 99577 is logged into station 1 of lab 4, then your system might display the following: Lab Number Computer Stations 1 1: empty 2: empty 2 1: empty 2: empty 3 1: empty 2: 49193 4 1: 99577 2: empty 3: 3: 3: 3: empty 4: empty 5: empty empty 4: empty 5: empty 6: empty empty 4: empty empty 535.
Chapter 9 / Pointers and Dynamic Arrays Create a menu that allows the administrator to simulate the transmission of information by manually typing in the login or logoff data.
Whenever someone logs in or out, the display should be updated.
Also write a search option so that the administrator can type in a user ID and the system will output what lab and station number that user is logged into, or "None" if the user ID is not logged into any computer station.
You should use a fixed array of length 4 for the labs.
Each array entry points to a  array that stores the user login information for each respective computer station.
The structure is shown in the figure below.
This structure is sometimes called a ragged array since the columns are of unequal length.
Lab Array VideoNote Solution to Programming Project 9_0_6 Dynamic Arrays for Computer Stations 6.
One problem with  arrays is that once the array is created using the new , the size cannot be changed.
For example, you might want to add or delete entries from the array as you can with a vector.
This project asks you to create functions that use  arrays to emulate the behavior of a vector.
First, write a program that creates a   of five strings.
Store five names of your choice into the.
Next, complete the following two functions: string* addEntry( string *dynamicArray, int &size, string newEntry); This function should create a new   one element larger than dynamicArray, copy all elements from dynamicArray into the new , add the new  onto the end of the new , increment size, delete dynamicArray, and return the new.
Programming Projects 537 returned.
If found, create a new   one element smaller than dynamicArray.
Copy all elements except entryToDelete into the new , delete dynamicArray, decrement size, and return the new.
Test your functions by adding and deleting several names to the while outputting the contents of the.
You will have to assign the returned by addEntry or deleteEntry back to the variable in your main function.
What if Cplus_plus had no built-in facility for two-dimensional arrays.
It is possible to emulate them yourself with wrapper functions around a onedimensional.
The basic idea is shown below.
Consider the following two-dimensional : int matrix[2][3]; It can be visualized as a table:.
This creates a one-dimensional   to emulate a twodimensional  and returns a pointer to the one-dimensional.
Return value: a pointer to a one-dimensional   large enough to hold a two-dimensional  of size rows * columns.
Note that int  = create2DArray(2,3); would create an.
This stores val into the emulated two-dimensional  at position desired_row, desired_column.
The function should print an error message and exit if the desired indices are invalid.
The function should print an error message and exit if the desired indices are invalid.
Create a suitable test program that invokes all three functions.
Write a program that outputs a histogram of student grades for an assignment.
The program should input each student's grade as an integer Programming Projects and store the grade in a vector (covered in Chapter 8).
Grades should be entered until the user enters -1 for a grade.
The program should then scan through the vector and compute the histogram.
In computing the histogram, the minimum value of a grade is 0 but your program should determine the maximum value entered by the user.
Use a dynamic array to store the histogram.
Output the histogram to the console.
For example, if the input is: 20 30 4 20 30 30 -1 Then the output should be: Number of 4's: Number of 20's: Number of 30's: 1 2 3 539.
Defining Classes 10_0_1 Structures  542 Structures for Diverse Data 542 Pitfall: Forgetting a Semicolon in a Structure Definition 547 Structures as Function Arguments 548 Programming Tip: Use Hierarchical Structures 549 Initializing Structures 551 10_0_2 Classes  554 Defining Classes and Member Functions 554 Public and Private Members 559 Programming Tip: Make All Member Variables Private 567 Programming Tip: Define Accessor and Mutator Functions 567 Programming Tip: Use the Assignment Operator with Objects 569 Chapter Summary 604 Answers to Self-Test Exercises 605 10 Programming Example: BankAccount Class— 1 570 Summary of Some Properties of Classes 574 Constructors for Initialization 576 Programming Tip: Always Include a Default Constructor 584 Pitfall: Constructors with No Arguments 585 Member Initializers and Constructor Delegation in Cplus_plus11 587 10_0_3 Abstract Data Types  588 Classes to Produce Abstract Data Types 589 Programming Example: Alternative Implementation of a  593 10_0_4 Introduction to Inheritance Derived Classes 599 Defining Derived Classes 600 Practice Programs 611 Programming Projects 612 598 "The time has come," the Walrus said, "To talk of many things: Of shoes—and ships—and sealing wax— Introduction In Chapter 6 you learned how to use classes and objects, but not how to define classes.
In this chapter we will show you how to define your own classes.
You can use the classes you define in the same way you use the predefined data types, such as int, char, and ifstream.
However, unless you define your classes the right way, they will not be as well behaved as the predefined data types.
Thus, we spend a good deal of time explaining what makes for a good class definition and give you some techniques to help you define your classes in a way that is consistent with modern programming practices.
Before we introduce classes, we will first present structures (also known as structs).
When used in the way we present them here, a structure is a kind of simplified class and structures will prove to be a stepping-stone to understanding classes.
Prerequisites This chapter uses material from Chapters 2 through 6.
Thus, the definition of a class should be a data type definition that describes two things: (1) what kinds of values the variables can hold and (2) what the member functions are.
We will approach class definitions in two steps.
We will first tell you how to give a type definition for a structure.
A structure (of the kind discussed here) can be thought of as an object without any member functions.
After you learn about structures, it will be a natural extension to define classes.
Structures for Diverse Data Sometimes it is useful to have a collection of values of different types and to treat the collection as a single item.
For example, consider a bank certificate of deposit, which is often called a CD.
A CD is a bank account that does not allow withdrawals for a specified number of months.
A CD naturally has 542 10_0_1 Structures 543 three pieces of data associated with it: the account balance, the interest rate for the account, and the term, which is the number of months until maturity.
The first two items can be represented as values of type double, and the number of months can be represented as a value of type int.
Display 10_0_1 shows the definition of a structure called CDAccount that can be used for this kind of account.
The definition is embedded in a complete program that demonstrates this structure type definition.
As you can see from the sample dialogue, this particular bank specializes in short-term CDs, so the term will always be 12 or fewer months.
Let's look at how this sample structure is defined and used.
The structure definition is as follows: struct CDAccount.
The keyword struct announces that this is a structure type definition.
The identifier CDAccount is the name of the structure type.
The name of a structure type is called the structure tag.
The tag can be any legal identifier (but not a keyword).
Although this convention is not required by the Cplus_plus language, structure tags are usually spelled with a mix of uppercase and lowercase letters, beginning with an uppercase letter.
The identifiers declared inside the braces, {}, are called member names.
As illustrated in this example, a structure type definition ends with both a brace, }, and a semicolon.
A structure definition is usually placed outside of any function definition (in the same way that globally defined constant declarations are placed outside of all function definitions).
The structure type is then available to all the code that follows the structure definition.
Once a structure type definition has been given, the structure type can be used just like the predefined types int, char, and so forth.
For example, the following will declare two variables, named my_account and your_account, both of type CDAccount: CDAccount my_account, your_account; A structure variable can hold values just like any other variable can hold values.
A structure value is a collection of smaller values called member values.
There is one member value for each member name declared in the structure definition.
For example, a value of the type CDAccount is a collection of three member values: two of type double and one of type int.
The member values that together make up the structure value are stored in member variables, which we discuss next.
Each structure type specifies a list of member names.
In Display 10_0_1 the structure CDAccount has the three member names balance, interest_rate, Where to place a structure definition 544 Chapter 10 / Defining Classes 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 //Program to demonstrate the CDAccount structure type.
Each of these member names can be used to pick out one smaller variable that is a part of the larger structure variable.
These smaller variables are called member variables.
Member variables are specified by giving the name of the structure variable followed by a dot (that is, followed by a period) and then the member name.
For example, if account is a structure variable of type CDAccount (as declared in Display 10_0_1), then the structure variable account has the following three member variables: account.
The first two member variables are of type double, and the last is of type int.
These member variables can be used just like any other variables of those types.
For example, the member variables above can be given values with the following three assignment statements:.
The result of these three statements is diagrammed in Display 10_0_2.
Member variables can be used in all the ways that ordinary variables can be used.
For example, the following line from the program in Display 10_0_1 will add the value contained in the member variable account.
The only difference is that in the case of structures, the members are variables rather than functions.
Chapter 10 / Defining Classes Display 10_0_2   Member Values 1 2 3 4 5 6 7 8 9 10 11 12.
CDAccount account; _0__0_.
Reusing member names.
For example, it is perfectly legal to have the following two type definitions in the same program: struct FertilizerStock.
The dot operator and the structure variable specify which quantity is meant in each instance.
A structure value can be viewed as a collection of member values.
Viewed this way, a structure value is many different values.
A structure value can also be viewed as a single (complex) value (which just happens to be made up of member values).
Since a structure value can be viewed as a single value, structure values and structure variables can be used in the same ways that you use simple values and simple variables of the predefined types such as int.
In particular, you can assign structure values using the equal sign.
For example, if  and oranges are structure variables of the type CropYield defined earlier, then the following is perfectly legal: = oranges;.
Forgetting a Semicolon in a Structure Definition When you add the final brace, }, to a structure definition, it feels like the structure definition is finished, but it is not.
You must also place a semicolon after that final brace.
There is a reason for this, even though the reason is a feature that we will have no occasion to use.
A structure definition is more than a definition.
It can also be used to declare structure variables.
You are allowed to list structure variable names between that final brace and that final semicolon.
For example, the following defines a structure called WeatherData and declares two structure variables, data_point1 and data_point2, both of type WeatherData: struct WeatherData.
However, as we said, we will always separate a structure definition and the declaration of variables of that structure type, so our structure definitions will always have a semicolon immediately after the final brace.
Chapter 10 / Defining Classes The Dot Operator The dot operator is used to specify a member variable of a structure variable.
Structures as Function Arguments Functions can return structures A function can have call-by-value parameters of a structure type and/or callby-reference parameters of a structure type.
The program in Display 10_0_1, for example, includes a function named get_data that has a call-by-reference parameter with the structure type CDAccount.
A structure type can also be the type for the value returned by a function.
For example, the following defines a function that takes three appropriate arguments and returns a value of type CDAccount: CDAccount shrink_wrap(double the_balance,.
Use Hierarchical Structures Sometimes it makes sense to have structures whose members are themselves smaller structures.
For example, a structure type called PersonInfo, which can be used to store a person's height, weight, and birth date, can be defined as follows: struct Date.
If the structure variable person1 has had its value set to record a person's.
Starting at the left end, person1 is a structure variable of type PersonInfo.
To obtain the member variable with the name birthday, use the dot operator as follows: person1_0_birthday This member variable is itself a structure variable of type Date.
Thus, this member variable has member variables itself.
A member variable of the structure variable person1_0_birthday is obtained by adding a dot and the member variable name, such as year, which produces the expression person1_0_birthday_0_year shown previously.
The Structure_Tag is the name of the structure type.
Syntax struct Structure_Tag.
Although we will not use this feature, you can combine member names of the same type into a single list separated by commas.
For example, the following is equivalent to the previous structure definition: struct Automobile.
Automobile my_car, your_car; The member variables are specified using the dot operator.
To give a structure variable a value, you follow it by an equal sign and a list of the member values enclosed in braces.
For example, the following definition of a structure type for a date was given in the previous subsection: struct.
In this example, _0_month receives the first initializing value of 12, _0_day receives the second value of 31, and _0_year receives the third value of 2004.
It is an error if there are more initializers than struct members.
If there are fewer initializer values than struct members, the provided values are used to initialize data members, in order.
Each data member without an initializer is initialized to a zero value of an appropriate type for the variable.
Self- T e st Exerc is e s 1.
Given the following structure and structure variable declaration:.
What is the error in the following structure definition.
What is the message your compiler gives for this error.
State what the error is, in your own words.
Initialize the members of x, member_b and member_c, to the values 1 and 2, respectively.
Here is an initialization of a structure type.
Tell what happens with each initialization.
Note any problems with these initializations.
Write a definition for a structure type for records consisting of a person's wage rate, accrued vacation (which is some whole number of days), and status (which is either hourly or salaried).
Represent the status as one of the two char values 'H' and 'S'.
Call the type EmployeeRecord.
Give a function definition corresponding to the following function void read_shoe_record(ShoeType& new_shoe); //Fills new_shoe with values read from the keyboard.
Give a function definition corresponding to the following function ShoeType discount(ShoeType old_record); //Returns a structure that is the same as its argument, //but with the  reduced by 10%.
Give the structure definition for a type named StockRecord that has two member variables, one named shoe_info of the type ShoeType given in Self-Test Exercise 2 and one named arrival_date of type  given in Self-Test Exercise 5.
Chapter 10 / Defining Classes 10_0_2 Classes I don't care to belong to any club that will accept me as a member.
Groucho Marx, The Groucho Letters Defining Classes and Member Functions A member function A class is a data type whose variables are objects.
In Chapter 6 we described an object as a variable that has member functions as well as the ability to hold data values_0_1 Thus, within a Cplus_plus program, the definition of a class should be a data type definition that describes what kinds of values the variables can hold and also what the member functions are.
A structure definition describes some of these things.
A structure is a defined type that allows you to define values of the structure type by defining member variables.
To obtain a class from a structure, all you need to do is add some member functions.
A sample class definition is given in the program shown in Display 10_0_3.
The type DayOfYear defined there is a class definition for objects whose values are dates, such as January 1 or July 4.
These values can be used to record holidays, birthdays, and other special dates.
In this definition of DayOfYear, the month is recorded as an int value, with 1 standing for January, 2 standing for February, and so forth.
The day of the month is recorded in a second int member variable.
The class DayOfYear has one member function called output, which has no arguments and outputs the month and day values to the screen.
Let's look at the definition for the class DayOfYear in detail.
The definition of the class DayOfYear is shown near the top of Display 10_0_3.
For the moment, ignore the line that contains the keyword public.
This line simply says that the member variables and functions have no restriction on them.
We will explain this line later in this chapter.
The rest of the definition of the class DayOfYear is very much like a structure definition, except that it uses the keyword class instead of struct and it lists the member function output (as well as the member variables month and day).
Notice that the member function output is listed by giving only its function declaration.
The definitions for the member functions are given elsewhere.
The object is actually the value of the variable rather than the variable itself, but since we use the variable to name the value it holds, we can simplify our discussion by ignoring this nicety and talking as if the variable and its value were the same thing.
Chapter 10 / Defining Classes Sample Dialogue Enter today's date: Enter  as a number: 10 Enter the  of the : 15 Enter your birthday: Enter  as a number: 2 Enter the  of the : 21 Today's date is  = 10,  = 15 Your birthday is  = 2,  = 21 Happy Unbirthday.
Calling member functions Member functions for classes that you define are called in the same way as we described in Chapter 6 for predefined classes.
For example, the program in Display 10_0_3 declares two objects of type DayOfYear in the following way: DayOfYear today, birthday;.
Encapsulation Combining a number of items, such as variables and functions, into a single package, such as an object of some class, is called encapsulation.
Defining member functions When a member function is defined, the definition must  the class name because there may be two or more classes that have member functions the same name.
In Display 10_0_3 there is only one class definition, but in other situations you may have many class definitions, and each class may have a member function called output.
The definition for the member function output of the class DayOfYear is shown in Display 10_0_3.
The definition is similar to an ordinary function definition, but there are some differences.
The heading of the function definition for the member function output is as follows: 10_0_2 Classes The operator :: is called the scope resolution operator, and it serves a purpose similar to that of the dot operator.
Both the dot operator and the scope resolution operator are used to tell what a member function is a member of.
However, the scope resolution operator :: is used  a class name, whereas the dot operator is used  objects (that is,  class variables).
The scope resolution operator consists of two colons  no space between them.
The class name that precedes the scope resolution operator is often called a type qualifier, because it specializes ("qualifies") the function name to one particular type.
Look at the definition of the member function DayOfYear::output given in Display 10_0_3.
Notice that in the function definition of DayOfYear::output, we used the member names  and  by themselves without first giving the object and dot operator.
That is not as strange as it may at first appear.
At this point we are simply defining the member function output.
This definition of output will apply to all objects of type DayOfYear, but at this point we do not know the names of the objects of type DayOfYear that we will use, so we cannot give their names.
When the member function is called, as in today_0_output(); all the member names in the function definition are specialized to the name.
Member Function Definition A member function is defined the same way as any other function except that the Class_Name and the scope resolution operator :: are given in the function heading.
The class definition for the example class DayOfYear above is given in Display 10_0_3, where  and  are defined as the names of member variables for the class DayOfYear.
Note that  and  are not preceded by an object name and dot.
The Dot Operator and the Scope Resolution Operator Both the dot operator and the scope resolution operator are used member names to specify what thing they are members of.
For example, suppose you have declared a class called DayOfYear and you declare an object called today as follows: DayOfYear today; You use the dot operator to specify a member of the object today.
For example, output is a member function for the class DayOfYear (defined in Display 10_0_3), and the following function call will output the data values stored in the object today: today_0_output(); You use the scope resolution operator :: to specify the class name when giving the function definition for a member function.
For example, the heading of the function definition for the member function output would be as follows: Remember, the scope resolution operator :: is used  a class name, whereas the dot operator is used  an object of that class.
Below we have redefined the class DayOfYear from Display 10_0_3 so that it now has one additional member function called input.
Write an appropriate definition for the member function input.
Public and Private Members The predefined types such as double are not implemented as Cplus_plus classes, but the people who wrote your Cplus_plus compiler did design some way to represent values of type double in your computer.
It is possible to implement the type double in many different ways.
In fact, different versions of Cplus_plus do implement the type double in slightly different ways, but if you move your Cplus_plus program from one computer to another with a different implementation of the type 2 double, your program should still work correctly.
Classes are types that you define, and the types that you define should behave as well as the predefined types.
You can build a library of your own class type definitions and use your types as if they were predefined types.
For example, you could place each class definition in a separate file and copy it into any program that uses the type.
Sometimes this ideal is not quite realized, but in the ideal world it should be realized, and at least for simple programs, it is realized even in the imperfect world that we live in.
Chapter 10 / Defining Classes Your class definitions should separate the rules for using the class and the details of the class implementation in as strong a way as was done for the predefined types.
If you change the implementation of a class (for example, by changing some details in the definition of a member function in order to make function calls run faster), then you should not need to change any of the other parts of your programs.
In order to realize this ideal, we need to describe one more feature of class definitions.
Look back at the definition of the type DayOfYear given in Display 10_0_3.
The type DayOfYear is designed to hold values that represent dates such as birthdays and holidays.
We chose to represent these dates as two integers, one for the  and one for the  of the.
We might later decide to change the representation of the  from one variable of type int to three variables of type char.
In this changed version, the three characters would be an abbreviation of the 's name.
For example, the three char values 'J', 'a', and 'n' would represent the  January.
However, whether you use a single member variable of type int to record the  or three member variables of type char is an implementation detail that need not concern a programmer who uses the type DayOfYear.
Of course, if you change the way the class DayOfYear represents the , then you must change the implementation of the member function output—but that is all you should need to change.
You should not need to change any other part of a program that uses your class definition for DayOfYear.
Unfortunately, the program in Display 10_0_3 does not meet this ideal.
For example, if you replace the one member variable named  with three member variables of type char, then there will be no member variable named , so you must change those parts of the program that perform input and also change the if-else statement.
With an ideal class definition, you should be able to change the details of how the class is implemented and the only things you should need to change in any program that uses the class are the definitions of the member functions.
In order to realize this ideal, you must have enough member functions so that you never need to access the member variables directly, but access them only through the member functions.
Then, if you change the member variables, you need change only the definitions of the member functions to match your changes to the member variables, and nothing else in your programs need change.
In Display 10_0_4 we have redefined the class DayOfYear so that it has enough member functions to do everything we want our programs to do, and so the program does not need to directly reference any member variables.
If you look carefully at the program in Display 10_0_4, you will see that the only place the member variable names  and  are used is in the definitions of the member functions.
The program in Display 10_0_4 has one new  that is designed to ensure that no programmer who uses the class DayOfYear will ever 10_0_2 Classes 561 1 2 3.
Chapter 10 / Defining Classes 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74.
A better definition of the member function input would ask the user to reenter the date if the user enters an incorrect date.
Sample Dialogue Enter today's date: Enter the  as a number: 3 Enter the  of the : 21 Today's date is  = 3,  = 21 J.
Bach's birthday is  = 3,  = 21 Happy Birthday Johann Sebastian.
Notice the line in the definition of the class DayOfYear that contains the keyword private.
All the member variable names that are listed after this line are private members, which means that they cannot be directly accessed in the program except within the definition of a member function.
If you try to access one of these member variables in the main part of your program or in the definition of some function that is not a member function of this particular class, the compiler will give you an error message.
If you insert the keyword private and a colon in the list of member variables and member functions, all the members that follow the label private: will be private members.
The variables that follow the label private: will be private member variables, and the functions that follow it will be private member functions.
All the member variables for the class DayOfYear defined in Display 10_0_4 are private members.
A private member variable may be used in the of any of the member functions, but nowhere else.
For example,  this changed  of the class DayOfYear, the following two assignments are no longer permitted in the main part of the program:.
Any reference to these private variables is illegal (except in the  of member functions).
Since this new  makes  and  private member variables, the following are also illegal in the main part of any program that declares today to be of type DayOfYear:.
Once you make a member variable a private member variable, there is then no way to change its value (or to reference the member variable in any other way) except by using one of the member functions.
This is a severe restriction, but it is usually a wise restriction to impose.
Programmers find that it usually makes their code easier to understand and easier to update if they make all member variables private.
It may seem that the program in Display 10_0_4 does not really disallow direct access to the private member variables, since they can be changed using the member function DayOfYear::set, and their values can be discovered using the member functions DayOfYear::get_month and DayOfYear::get_ While that is almost true for the program in Display 10_0_4, it might not be so true if we changed the implementation of how we represented the and/or  in our dates.
For example, suppose we change the type of DayOfYear to the following: 563.
For example, the  of the function get_month might start as follows: { if ( == 'J' && third_letter return 1; if ( == 'F' && third_letter return 2; &&  == 'a' &&  == 'e' _0__0_.
This approach would be rather tedious, but not difficult.
Also notice that the member functions DayOfYear::set and DayOfYear::input check to make sure the member variables  and are set to legal values.
If the member variables  and  were public instead of private, then these member variables could be set to any values, including illegal values.
By making the member variables private and manipulating them only via member functions, we can ensure that the member variables are never set to illegal or meaningless values.
Like a private member variable, a private member function can be used in the of any other member function, but nowhere else, such as in the main part of a program that uses the class type.
For example, the member function DayOfYear::check_date in Display 10_0_4 is a private member function.
The normal practice is to make a member function private if you only expect to use that member function as a helping function in the definitions of the member functions.
The keyword public is used to indicate public members the same way that the keyword private is used to indicate private members.
For example, for the class DayOfYear defined in Display 10_0_4, all the member functions except DayOfYear::check_date are public members (and all the member variables are private members).
A public member can be used in the main body of your program or in the  of any function, even a nonmember function.
You can have any number of occurrences of public and private in a class Every time you insert the label public: the list of members changes from private to public.
Every time you insert the label private: the list of members changes back to being private members.
For example, the member function do_something_else and the member variable more_stuff in the following structure  are private members, while the other four members are all public: class SampleClass { public:.
If you list members at the start of your class  and do not insert either public: or private: before these first members, then they will be private members.
However, it is a good idea to always explicitly label each group of members as either public or private.
These objects can have both member variables and member functions.
The syntax for a class is as follows.
Syntax class Class_Name { public: Member_Specification_1 Member_Specification_2.
Make All Member Variables Private When defining a class, the normal practice is to make all member variables private.
This means that the member variables can only be accessed or changed using the member functions.
Much of this chapter is dedicated to explaining how and why you should define classes in this way.
Unfortunately, the predefined  == does not automatically apply to objects.
In Chapter 11 we will show you how you can make the  == apply to the objects of the classes you define.
Until then, you will not be able to use the equality  == with objects (nor can you use it with structures).
This can produce some complications.
When defining a class, the preferred style is to make all member variables private.
Thus, in order to test two objects to see if they represent the same value, you need some way to access the values of the member variables (or something equivalent to the values of the member variables).
This allows you to test for equality by testing the values of each pair of corresponding member variables.
To do this in Display 10_0_4, we used the member functions get_month and get_day in the if-else statement.
Member functions, such as get_month and get_day, that allow you to find out the values of the private member variables are called accessor functions.
Given the techniques you have learned to date, it is important to always include a complete set of accessor functions with each class definition so that you can test objects for equality.
In Chapter 11 we will develop a more elegant method to test two objects for equality, but even after you learn that technique, it will still be handy to have accessor functions.
Member functions, such as set in Display 10_0_4, that allow you to change the values of the private member variables are called mutator functions.
It is important to always include mutator functions with each class definition so that you can change the data stored in an object.
Accessor and Mutator Functions Member functions that allow you to find out the values of the private member variables of a class are called accessor functions.
Although this is not required by the Cplus_plus language, the names of accessor functions normally include the word get.
Chapter 10 / Defining Classes Member functions that allow you to change the values of the private member variables of a class are called mutator functions.
Although this is not required by the Cplus_plus language, the names of mutator functions normally include the word set.
It is important to always include accessor and mutator functions with each class definition so that you can change the data stored in an object.
Redefine the member function DayOfYear::check_date so that it ends the program whenever it finds any illegal date.
Allow February to contain 29 days, so you account for leap years.
Suppose your program contains the following class definition: class Automobile {.
Suppose you change Self-Test Exercise 15 so that the definition of the class Automobile omits the line that contains the keyword private.
How would this change your answer to the question in Self-Test Exercise 15.
In particular, explain why we do not just make everything public: and save difficulty in access.
How many private: sections are required in a class.
For example, suppose the class DayOfYear is defined as shown in Display 10_0_4 so that it has two private member variables named  and , and suppose that the objects  and tomorrow are declared as follows: DayOfYear , tomorrow;.
Moreover, this is true even though the member variables named  and 3 are private members of the class DayOfYear.
Chapter 10 / Defining Classes Programming Example   BankAccount Class— 1 Display 10_0_5 contains a class definition for a bank account that illustrates all of the points about class definitions you have seen thus far.
This type of bank account allows you to withdraw your money at any time, so it has no term as did the type CDAccount that you saw earlier.
A more important difference is that the class BankAccount has member functions for all the operations you would expect to use in a program.
Objects of the class BankAccount have two private member variables: one to record the account balance and one to record the interest rate.
Let's discuss some of features of the class BankAccount.
First, notice that the class BankAccount has a private member function called fraction.
Since fraction is a private member function, it cannot be called in the body of main or in the body of any function that is not a member function of the class BankAccount.
The function fraction can only be called in the definitions of other member functions of the class BankAccount.
The only reason we have this (or any) private member function is to aid us in defining other member functions for the same class.
In our definition of the class BankAccount, we included the member function fraction so that we could use it in the definition of the function update.
The function fraction takes one argument that is a percentage figure, like 10_0_0 for 10_0_0%, and converts it to a fraction, like 0_0_10.
That allows us to compute the amount of interest on the account at the given percentage.
If the account contains $100_0_00 and the interest rate is 10%, then the interest is equal to $100 times 0_0_10, which is $10_0_00.
When you call a public member function, such as update, in the main body of your program, you must include an object name and a dot, as in the following line from Display 10_0_5: account1_0_update(); One member function calling another However, when you call a private member function (or any other member function) within the definition of another member function, you use only the member function name without any calling object or dot.
For example, the following definition of the member function BankAccount::update includes a call to BankAccount::fraction (as shown in Display 10_0_5):.
For example, the meaning of account1_0_update();.
The member function { set is overloaded.
Sample Dialogue Start of Test: 1 initial statement: Account  $123_0_99 Interest  3_0_00% 1 with new : Account  $100_0_00 Interest  5_0_00% 1 after update: Account  $105_0_00 Interest  5_0_00% 2: Account  $105_0_00 Interest  5_0_00%.
Chapter 10 / Defining Classes Input/output stream arguments Like the classes we discussed earlier, the class BankAccount has a member function that outputs the data information stored in the object.
In this program we are sending output to the screen.
However, we want to write this class definition so that it can be copied into other programs and used unchanged in those other programs.
Since some other program may want to send output to a file, we have given the member function output a formal parameter of type ostream so that the function output can be called with an argument that is either the stream  or a file output stream.
In the sample program we want the output to go to the screen, so the first function call to the member function output has the form 1_0_output(); Other calls to output also use  as the argument, so all output is sent to the screen.
If you want the output to go to a file instead, then you must first connect the file to an output stream, as we discussed in Chapter 6.
If the file output stream is called fout and is connected to a file, then the following would write the data information for the object account1 to this file rather than to the screen: account1_0_output(fout); Overloading member functions The value of an object of type BankAccount represents a bank account that has some  and pays some interest.
The  and interest can be set with the member function set.
Notice that we have overloaded the member function named set so that there are two versions of set.
One version has three formal parameters, and the other has only two formal parameters.
Both versions have a formal parameter of type double for the interest , but the two versions of set use different formal parameters to set the account.
One version has two formal parameters to set the , one for the dollars and one for the cents in the account.
The other version has only a single formal parameter, which gives the number of dollars in the account and assumes that the number of cents is zero.
This second version of set is handy, since most people open an account with some "even" amount of money, such as $1,000 and no cents.
Notice that this overloading is nothing.
Summary of Some Properties of Classes Classes have all of the properties that we described for structures plus all the properties associated with member functions.
The following is a list of some points to keep in mind when using classes.
Classes have both member variables and member functions.
Normally, all the member variables of a class are labeled as private members.
The name of a member function for a class may be overloaded just like the name of an ordinary function.
However, in Cplus_plus a structure can have private member variables and both public and private member functions.
Aside from some notational differences, a Cplus_plus structure can do anything Self- T e st Exerc is e s 19.
Give a definition for the function with the following function declaration.
The class BankAccount is defined in Display 10_0_5.
Give a definition for the function with the following function declaration.
The class BankAccount is defined in Display 10_0_5.
Give a definition for the function with the following function declaration.
The class BankAccount is defined in Display 10_0_5.
BankAccount new_account(BankAccount old_account); //Precondition: old_account has previously been given a value //(that is, its member variables have been given values).
For example, after this function is defined, a program could contain the.
Account balance $0_0_00 Interest rate 5_0_50% Constructors for Initialization You often want to initialize some or all the member variables for an object when you declare the object.
As we will see later in this book, there are other initializing actions you might also want to take, but initializing member variables is the most common sort of initialization.
Cplus_plus includes special provisions for such initializations.
When you define a class, you can define a special kind of member function known as a constructor.
You can define a constructor the same way that you define any other member function, except for two points: 1.
For example, if the class is named BankAccount, then any constructor for this class must be named BankAccount.
Moreover, no return type, not even void, can be given at the start of the function declaration or in the function header.
The class definition could be as follows.
Notice that the constructor is named BankAccount, which is the name of the class.
Also notice that the function declaration for the constructor BankAccount does not start with void or with any other type name.
Finally, notice that the constructor is placed in the public section of the class definition.
Normally, you should make your constructors public member functions.
If you were to make all your constructors private members, then you would not be able to declare any objects of that class type, which would make the class completely useless.
With the redefined class BankAccount, two objects of type BankAccount can be declared and initialized as follows: BankAccount 1(10, 50, 2_0_0), 2(500, 0, 4_0_5); Assuming that the definition of the constructor performs the initializing action that we promised, the previous declaration will declare the object 1, set the value of 1_0_balance to 10_0_50, and set the value of 1_0_interest_ rate to 2_0_0.
Thus, the object 1 is initialized so that it represents a bank with a balance of $10_0_50 and an interest rate of 2_0_0%.
Similarly, 2 is initialized so that it represents a bank  with a balance of $500_0_00 and an interest rate of 4_0_5%.
What happens is that the object 1 is declared and then the constructor BankAccount is called with the three arguments 10, 50, and 2_0_0.
Similarly, 2 is declared and then the constructor BankAccount is called with the arguments 500, 0, and 4_0_5.
The result is conceptually equivalent to the following (although you cannot write it this way in Cplus_plus): 577.
As the comments indicate, you cannot place those three lines in your program.
The first line can be made to be acceptable, but the two calls to the constructor BankAccount are illegal.
A constructor cannot be called in the same way as an ordinary member function is called.
Still, it is clear what we want to happen when we write those three lines, and that happens automatically when you declare the objects 1 and 2 as follows: BankAccount 1(10, 50, 2_0_0), 2(500, 0, 4_0_5); The definition of a constructor is given in the same way as any other member function.
For example, if you revise the definition of the class BankAccount by adding the constructor just described, you need to also add the following definition of the constructor:.
Since the class and the constructor function have the same name, the name BankAccount occurs twice in the function heading: The BankAccount before the scope resolution operator :: is the name of the class, and the BankAccount after the scope resolution operator is the name of the constructor function.
Also notice that no return type is specified in the heading of the constructor definition, not even the type void.
Aside from these points, a constructor can be defined in the same way as an ordinary member function.
You can overload a constructor name like BankAccount::BankAccount, just as you can overload any other member function name, such as we did with BankAccount::set in Display 10_0_5.
In fact, constructors usually are overloaded so that objects can be initialized in more than one way.
For example, in Display 10_0_6 we have redefined the class BankAccount so that it has three versions of its constructor.
This redefinition overloads the constructor name BankAccount so that it may have three arguments (as we just discussed), two arguments, or no arguments.
For example, suppose you give only two arguments when you declare an object of type BankAccount, as in the following example: BankAccount 1(100, 2_0_3);.
On the other hand, if no arguments are given, as in the following example, 2; then the  is initialized to represent an  with a  of $0_0_00 and an interest rate of 0_0_0%.
Notice that when the constructor has no arguments, you do not include any parentheses in the  declaration.
The following is incorrect: 2(); //WRONG.
In some cases, you can omit mutator member functions such as set once you have a good set of constructor definitions.
You can use the overloaded constructor  in Display 10_0_6 to create a new the values of your choice.
However, invoking the constructor will create a new , so if you want to change the existing member variables in the , then you should use a mutator function.
Chapter 10 / Defining Classes 24 25 //Postcondition: One year of simple interest has been added //to the account.
Notice that there are no parentheses.
Screen Output 1 initialized as follows: Account  $100_0_00 Interest rate 2_0_30% 2 initialized as follows: Account  $0_0_00 Interest rate 0_0_00% 1 reset to the following: Account  $999_0_99 Interest rate 5_0_50% Constructor A constructor is a member function of a class that has the same name as the class.
A constructor is called automatically when an object of the class is declared.
Constructors are used to initialize objects.
A constructor must have the same name as the class of which it is a member.
The constructor  no parameters in Display 10_0_6 deserves some extra discussion since it contains something we have not seen before.
For reference, we reproduce the defining of the constructor  no parameters: 581.
The new , which is shown on the first line, is the part that starts  a single colon.
This part of the constructor definition is called the initialization section.
As this example shows, the initialization section goes after the parentheses that ends the parameter list and before the opening brace of the function body.
The initialization section consists of a colon followed by a list of some or all the member variables separated by commas.
Each member variable is followed by its initializing value in parentheses.
This constructor definition is completely equivalent to the following way of writing the definition:.
Notice that the initializing values can be given in terms of the constructor parameters.
Constructor Initialization Section Some or all of the member variables in a class can (optionally) be initialized in the constructor initialization section of a constructor definition.
The constructor initialization section goes after the parentheses that end the parameter list and before the opening brace of the function body.
The initialization section consists of a colon followed by a list of some or all the member variables separated by commas.
Each member variable is followed by its initializing value in parentheses.
The example given below uses a constructor initialization section and is equivalent to the threeparameter constructor given in Display 10_0_6.
Calling a Constructor A constructor is called automatically when an object is declared, but you must give the arguments for the constructor when you declare the object.
A constructor can also be called explicitly in order to create a new object for a class variable.
Syntax (for an object declaration when you have Class_Name Object_Name(Arguments_for_Constructor);.
A constructor must have the same name as the class of which it is a member.
Thus, in the syntax descriptions above, Class_Name and Constructor_Name are the same identifier.
Initializers can also be specified if the object is created as a dynamic variable.
Chapter 10 / Defining Classes A constructor is called automatically whenever you declare an object of the class type, but it can also be called again after the object has been declared.
This allows you to conveniently set all the members of an object.
The technical details are as follows.
Calling the constructor creates an anonymous object new.
An anonymous object is an object that is not named (as yet) by any variable.
The anonymous  can be assigned to the named (that is, to the class variable).
For example, the following line of code is a call to the constructor  that creates an anonymous a  of $999_0_99 and interest rate of 5_0_5%.
This anonymous is assigned to  1 so that it too represents an   a of $999_0_99 and an interest rate of 5_0_5%: 1 = (999, 99, 5_0_5); As you might guess from the notation, a constructor behaves like a function that returns an  of its class type.
However, since a call to a constructor always creates a new  and a call to a set member function merely changes the  of existing member variables, a call to set may be a more efficient way to change the  of member variables than a call to a constructor.
Thus, for efficiency reasons or if you need to change the of member variables without creating a new , you may wish to have both the set member functions and the constructors in your class definition.
If you give no constructor, the compiler will generate a default constructor that does nothing.
This constructor will be called if class objects are declared.
On the other hand, if you give at least one constructor definition for a class, then the Cplus_plus compiler will generate no other constructors.
Every time you declare an  of that type, Cplus_plus will look for an appropriate constructor definition to use.
If you declare an  without using arguments for the constructor, Cplus_plus will look for a default constructor, and if you have not defined a default constructor, none will be there for it to find.
For example, suppose you define a class as follows: class SampleClass { Constructor that requires two arguments public:.
SampleClass and call the constructor for that class:.
The compiler interprets this declaration as including a call to a constructor with no arguments, but there is no definition for a constructor with zero arguments.
You must either add two arguments to the declaration of your_ or add a constructor definition for a constructor with no arguments.
A constructor that can be called with no arguments is called a default constructor, since it applies in the default case where you declare an without specifying any arguments.
Since it is likely that you will sometimes want to declare an  without giving any constructor arguments, you should always include a default constructor.
The following redefined version of SampleClass includes a default constructor: class SampleClass { public:.
If you redefine the class SampleClass in this manner, then the previous declaration of your_object would be legal.
If you do not want the default constructor to initialize any member variables, you can simply give it an empty body when you implement it.
The following constructor definition is perfectly legal.
It does nothing when called except make the compiler happy:.
Chapter 10 / Defining Classes.
After all, when you call a function that has no arguments, you include a pair of empty parentheses.
However, this is wrong for a constructor.
Moreover, it may not produce an error message, since it does have an unintended meaning.
The compiler will think that this code is the function declaration for a function called 2 that takes no arguments and returns a value of type.
Do not include parentheses when you declare an  and want Cplus_plus to use the constructor with no arguments.
The correct way to declare 2 using the constructor with no arguments is as follows: 2; However, if you explicitly call a constructor in an assignment statement, you do use the parentheses.
If the definitions and declarations are as in Display 10_0_6, then the following will set the  balance for 1 to $0_0_00 and set the interest rate to 0_0_0%: 1 = (); Constructors with No Arguments When you declare an  and want the constructor with zero arguments to be called, you do not include any parentheses.
For example, to declare an  and pass two arguments to the constructor, you might do the following: 1(100, 2_0_3);.
This feature allows you to set default values for member variables.
When an  is created the member variables are automatically initialized to the specified values.
Consider the following definition and implementation of the Coordinate class: class Coordinate {.
If we create a Coordinate , then member variable  will be set to 1 and member variable  will be set to 2 by default.
These values can be overridden if we invoke a constructor that explicitly sets the variable.
In the snippet below, the default values for  and  are set for c1, but for c2 the default value is only set for  because  is explicitly set to the input argument:.
A related feature supported by Cplus_plus11 is constructor delegation.
Simply put, this allows one constructor to call another constructor.
For example, we could modify the implementation of the default constructor so it invokes the constructor with two parameters: VideoNote Default Initialization of Member Variables 587.
Self- T es t Exe rc is e s 22.
Suppose your program contains the following class definition (along with definitions of the member functions): class YourClass {.
Which of the following are legal.
YourClass YourClass YourClass an_object an_object an_object.
How would you change the definition of the class DayOfYear in Display 10_0_4 so that it has two versions of an (overloaded) constructor.
One version should have two int formal parameters (one for the month and one for the day) and should set the private member variables to represent that month and day.
The other should have no formal parameters and should set the date represented to January 1.
Do this without using a constructor initialization section in either constructor.
Virginia Woolf, Monday or Tuesday 10_0_3 Abstract Data Types A data type, such as the type int, has certain specified values, such as 0, 1, −1, 2, and so forth.
You tend to think of the data type as being these values, but the operations on these values are just as important as the values.
Without the operations, you could do nothing of interest with the values.
The operations for the type int consist of +, −, *, /, %, and a few other operators and predefined library functions.
You should not think of a data type as being simply a collection of values.
A data type consists of a collection of values together with a set of basic operations defined on those values.
A data type is called an abstract data type (abbreviated ADT) if the programmers who use the type do not have access to the details of how the values and operations are implemented.
The predefined types, such as int, are abstract data types (ADTs).
You do not know how the operations, such as + and *, are implemented for the type int.
Even if you did know, you would not use this information in any Cplus_plus program.
Programmer-defined types, such as the structure types and class types, are not automatically ADTs.
Unless they are defined and used with care, programmerdefined types can be used in unintuitive ways that make a program difficult to understand and difficult to modify.
The best way to avoid these problems is to make sure all the data types that you define are ADTs.
The way that you do this in Cplus_plus is to use classes, but not every class is an ADT.
To make it an ADT you must define the class in a certain way, and that is the topic of the next subsection.
Classes to Produce Abstract Data Types A class is a type that you define, as opposed to the types, such as int and char, that are already defined for you.
A value for a class type is the set of values of the member variables.
For example, a value for the type BankAccount in Display 10_0_6 consists of two numbers of type double.
For easy reference, we repeat the class definition (omitting only the comments): class BankAccount {.
Chapter 10 / Defining Classes The programmer who uses the type BankAccount need not know how you implemented the definition of BankAccount::update or any of the other member functions.
The function definition for the member function BankAccount::update that we used is as follows:.
The programmer who uses the class BankAccount need not be concerned with which implementation of update we used, since both implementations have the same effect.
Similarly, the programmer who uses the class BankAccount need not be concerned about how the values of the class are implemented.
We chose to implement the values as two values of type double.
If vacation_savings is an object of type BankAccount, the value of vacation_savings consists of the two values of type double stored in the following two member variables: vacation_savings.
You want to think of the value of vacation_savings as the single entry Account  $135_0_46 Interest rate 4_0_50% That is why our implementation of BankAccount::output writes the class value in this format.
The fact that we chose to implement this BankAccount value as the two double values 1_0_3546e + 2 and 4_0_5 is an implementation detail.
We could instead have implemented this BankAccount value as the two int values 135 and 46 (for the dollars and cents part of the ) and the single value 0_0_045 of type double.
The value 0_0_045 is simply 4_0_5% converted to a fraction, which might be a more useful way to implement a percentage figure.
After all, in order to compute interest on the account we convert a percentage to just such a fraction.
With this alternative implementation of the class BankAccount, the public members would remain unchanged but the private members would change to the following: 10_0_3 Abstract Data Types class BankAccount { public:.
We would need to change the member function definitions to match this change, but that is easy to do.
For example, the function definitions for get_balance and one version of the constructor could be changed to the following:.
Similarly, each of the other member functions could be redefined to accommodate this new  of storing the account  and the interest rate.
Notice that even though the user may think of the account  as a single number, that does not mean the implementation has to be a single number of type double.
You have just seen that it could, for example, be two numbers of type int.
The programmer who uses the type BankAccount need not know any of this detail about how the values of the type BankAccount are implemented.
These comments about the type BankAccount illustrate the basic technique for defining a class so that it will be an abstract data type.
In order to define a class so that it is an abstract data type, you need to separate the specification of how the type is used by a programmer from the details of how the type is implemented.
The separation should be so complete that you can change the implementation of the class without needing to make any changes in any program that uses the class ADT.
One  to ensure this separation is to follow these rules: How to write an ADT 591.
Chapter 10 / Defining Classes 1.
Make all the member variables private members of the class.
Make each of the basic operations that the programmer needs a public member function of the class, and fully specify how to use each such public member function.
Make any helping functions private member functions.
Separate interface and implementation VideoNote Separate Interface and Implementation In Chapters 11 and 12 you will learn some alternative approaches to defining ADTs, but these three rules are one common  to ensure that a class is an abstract data type.
The interface of an ADT tells you how to use the ADT in your program.
When you define an ADT as a Cplus_plus class, the interface consists of the public member functions of the class along with the comments that tell you how to use these public member functions.
The interface of the ADT should be all you need to know in order to use the ADT in your program.
The implementation of the ADT tells how this interface is realized as Cplus_plus code.
The implementation of the ADT consists of the private members of the class and the definitions of both the public and private member functions.
Although you need the implementation in order to run a program that uses the ADT, you should not need to know anything about the implementation in order to write the rest of a program that uses the ADT; that is, you should not need to know anything about the implementation in order to write the main part of the program and to write any nonmember functions used by the main part of the program.
The situation is similar to what we advocated for ordinary function definitions in Chapters 4 and 5.
The implementation of an ADT, like the implementation of an ordinary function, should be thought of as being in a black box that you cannot see inside.
In Chapter 12 you will learn how to place the interface and implementation of an ADT in files separate from each other and separate from the programs that use the ADT.
That  a programmer who uses the ADT literally does not see the implementation.
Until then, we will place all of the details about our ADT classes in the same file as the main part of our program, but we still think of the interface (given in the public section of the class definitions) and the implementation (the private section of the class definition and the member function definitions) as separate parts of the ADT.
We will strive to write our ADTs so that the user of the ADT need only know about the interface of the ADT and need not know anything about the implementation.
To be sure you are defining your ADTs this , simply make sure that if you change the implementation of your ADT, your program will still work without your needing to change any other part of the program.
This is illustrated in the next Programming Example.
The most obvious benefit you derive from making your classes ADTs is that you can change the implementation without needing to change the other parts of your program.
But ADTs provide more benefits than that.
If you make your classes ADTs, you can divide work among different programmers, 10_0_3 Abstract Data Types 593 with one programmer designing and writing the ADT and other programmers using the ADT.
Even if you are the only programmer working on a project, you have divided one larger task into two smaller tasks, which makes your program easier to design and easier to debug.
Programming Example  lternative Implementation A of a Class Display 10_0_7 contains the alternative implementation of the ADT class BankAccount discussed in the previous subsection.
In this version, the data for a bank account is implemented as three member values: one for the dollars part of the account balance, one for the cents part of the account balance, and one for the interest rate.
Notice that, although both the  in Display 10_0_6 and the in Display 10_0_7 each have a member variable called interest_ rate, the value stored is slightly different in the two implementations.
If the account pays interest at a rate of 4_0_7%, then in the  in Display 10_0_6 (which is basically the same as the one in Display 10_0_5), the value of is 4_0_7.
However, in the  in Display 10_0_7, the value of  would be 0_0_047.
This alternative , shown in Display 10_0_7, stores the interest rate as a fraction rather than as a percentage figure.
The basic difference in this new  is that when an interest rate is set, the function fraction is used to immediately convert the interest rate to a fraction.
Hence, in this new  the private member function fraction is used in the definitions of constructors, but it is not needed in the definition of the member function update because the value in the member variable interest_rate has already been converted to a fraction.
In the old  (shown in Display 10_0_5 and Display 10_0_6), the situation was just the reverse.
In the old , the private member function fraction was not used in the definition of constructors, but was used in the definition of update.
Although we have changed the private members of the class BankAccount, we have not changed anything in the public section of the class definition.
The public member functions have the same function declarations and they behave exactly as they did in the old version of the ADT class given in Display 10_0_6.
For example, although this new  stores a percentage such as 4_0_7% as the fraction 0_0_047, the member function get_rate still returns the value 4_0_7, just as it would for the old  in Display 10_0_5.
Similarly, the member function get_balance returns a single value of type double, which gives the balance as a number with a decimal point, just as it did in the old  in Display 10_0_5.
This is true even though the balance is now stored in two member variables of type int, rather than in a single member variable of type double (as in the old versions).
The public interface is not changed 594 Chapter 10 / Defining Classes 1 2 3 4 5 6 7 8 9 10 11 //Demonstrates an alternative  of the class BankAccount.
Notice that the public members of.
BankAccount look and behave //Class  a bank account: exactly the same as in Display 10_0_6 class BankAccount.
Since the body of main is identical to that in Display 10_0_6 , the screen output is also identical to that in Display 10_0_6 48 49 50 51 52 53 54 55 56 57 58 59 60 61.
In this implementation, = cents; fraction is instead used in the definition of.
Chapter 10 / Defining Classes 86 87 88 { 89 90 91 92.
Notice that there is an important difference between how you treat the public member functions and how you treat the private member functions.
If you want to preserve the interface of an ADT class so that any programs that use it need not change (other than changing the  of the class and its member functions), then you must leave the public member function declarations unchanged.
However, you are free to add, delete, or change any of the private member functions.
In this example, we have added one additional private function called percent, which is the inverse of the function fraction.
The function fraction converts a percentage to a fraction, and the function returns 0_0_047, and percent(0_0_047) returns 4_0_7.
Information Hiding We discussed information hiding when we introduced functions in Chapter 3.
We said that information hiding, as applied to functions, means that you should write your functions so that they could be used as black boxes, that is, so that the programmer who uses the function need not know any details about how the function is implemented.
This principle means that all the programmer who uses a function needs to know is the function declaration and the accompanying comment that explains how to use the function.
The use of private member variables and private member functions in the definition of an abstract data type is another way to implement information hiding, but now we apply the principle to data values as well as to functions.
Changing private member functions 598 Chapter 10 / Defining Classes Self- T e st Ex er c is es 25.
When you define an ADT as a Cplus_plus class, should you make the member variables public or private.
Should you make the member functions public or private.
When you define an ADT as a Cplus_plus class, what items are considered part of the interface for the ADT.
What items are considered part of the implementation for the ADT.
Suppose your friend defines an ADT as a Cplus_plus class in the way we described in Section 10_0_3.
You are given the task of writing a program that uses this ADT.
That is, you must write the main part of the program as well as any nonmember functions that are used in the main part of the program.
The ADT is very long and you do not have a lot of time to write this program.
What parts of the ADT do you need to read and what parts can you safely ignore.
The word inheritance is just another name for the topic of derived classes.
When we say that one class was derived from another class, we mean that the derived class was obtained from the other class by adding features.
For example, suppose we define a class for vehicles that has member variables to record the vehicle's number of wheels and maximum number of occupants.
The class also has accessor and mutator functions.
Imagine that we then define a class for automobiles that has member variables and functions just like the ones in the class of vehicles.
In addition, our automobile class would have added member variables for such things as the amount of fuel in the fuel tank and the license plate number and would also have some added member functions.
Instead of repeating the  of the member variables and functions of the class of vehicles within the class of automobiles, we could use Cplus_plus's inheritance mechanism and let the automobile class inherit all the member variables and functions of the class for vehicles.
Inheritance allows you to define a general class and then later define more specialized classes that add some new  to the existing general class.
This saves work because the more specialized, or derived, class inherits all the properties of the general class and you, the programmer, need only program the new.
This section will first introduce the notion of inheritance and a derived class and then we briefly describe how to create your own derived 10_0_4 Introduction to Inheritance classes.
Details of inheritance are left to Chapter 15.
It may take a while before you are completely comfortable with the idea of a derived class, but you easily can learn enough about derived classes to start using them in some simple, and very useful, ways.
Derived Classes Consider the BankAccount class defined in Display 10_0_7.
This class keeps track of an amount and interest rate for a bank account—fairly generic  that apply to any interest-bearing account.
If we would like to implement more specific types of bank accounts, then there is a natural hierarchy for grouping the account types.
Display 10_0_8 depicts a part of this hierarchical arrangement for bank accounts, checking accounts, money market accounts, savings accounts, and Certificate of Deposit (CD) accounts.
In the hierarchy, BankAccount is the most general type of account; more specific types of accounts are shown underneath.
An arrow points from a specific account type to a more general account type.
In addition to representing different types of bank accounts, each box also corresponds to a class that we can implement in Cplus_plus.
For example, a checking account does everything a bank account can do (store an amount and interest rate) but in addition allows customers to make deposits and write checks.
Similarly, a savings account does everything a bank account can do but in addition allows customers to make deposits and withdrawals.
Unlike a checking account, a savings account may not allow customers to write checks.
Since both checking accounts and savings accounts are types of bank accounts they are shown in Display 10_0_8 directly underneath the BankAccount class.
When we say that some class A is a derived class of some other class B, it means that class A has all the  of class B but it also has added.
The convention for indicating this relationship in a diagram is to draw an an unfilled arrow from the specific to the more general class.
For example, in Display 10_0_8 the CheckingAccount and SavingsAccount classes are derived classes of the BankAccount class.
Display 10_0_8   A Class Hierarchy Bank Account Checking Account Savings Account Money Market Account CD Account.
Chapter 10 / Defining Classes In Cplus_plus, some class A can be a derived class of some other class B, which in turn can be a derived class of some other class C, and so on.
For example, a CD account is similar to a savings account except the funds and any accrued interest must not be withdrawn until after a "maturity" date.
If the funds are withdrawn prior to the maturity date, then there is a penalty.
Due to these restrictions, a CD account normally accrues interest at a higher rate than a savings account.
In the hierarchy, this is shown by deriving CDAccount from SavingsAccount.
Similarly, a money market account is a special type of checking account in which the customer normally has a limit on the number of checks that can be written, along with higher minimum balances, but pays a higher interest rate.
In the hierarchy, this is shown by deriving MoneyMarketAccount from CheckingAccount.
Derived classes are often discussed using the metaphor of inheritance and family relationships.
If class B is a derived class of class A, then class B is called a child of class A and class A is called a parent of class B.
The parent class is also referred to as the base class.
The derived class is said to inherit the member functions of its parent class.
For example, every convertible inherits the fact that it has four wheels from the class of all automobiles.
This is why the topic of derived classes is often called inheritance.
Defining Derived Classes If we want to create a class to represent a savings account, we could start by making a copy of the BankAccount class and renaming it to SavingsAccount.
We would need to add new  member functions to deposit and withdraw funds.
While this approach would work, it would be very inefficient, because the SavingsAccount class would duplicate most of the functionality in the BankAccount class.
Not only does this waste memory space, it also becomes more difficult to make modifications.
For example, if we later decide to change the update( ) function to accrue interest daily instead of annually, then we would have two places to make the change: in the SavingsAccount class and also in the BankAccount class.
These problems can be solved by defining the SavingsAccount class as a derived class of the BankAccount class.
The SavingsAccount class then can share member variables and functions defined in the BankAccount class.
We specify this relationship when defining the derived class by adding a colon followed by the keyword  and the name of the parent or base class: The colon separates the class SavingsAccount :  BankAccount derived class, Savings Account, from the parent { class, BankAccount :.
We don't need to redefine all of the variables and functions relating to bank accounts—such as storing the interest rate, dollars, cents, or defining the update( ) function—because those members will be inherited from the BankAccount class and are automatically created when we construct a SavingsAccount object.
For example, if we create a SavingsAccount object, we could invoke the following functions: Invoking a function in.
Invoking a function in the parent class, BankAccount In this example, inheritance allowed us to reuse code defined in the parent class from the context of the derived class.
Moreover, if we later change one of BankAccount's functions—such as update( )—then the new code automatically will be used from the context of its derived classes when the program is recompiled and linked.
An implementation of the SavingsAccount class along with a main function to test the deposit and withdraw functions is given in Display 10_0_9.
For simplicity, we have left verification out of the deposit and withdraw functions, for example, checking for negative amounts, but you should be able to add them easily with some if statements.
Once the SavingsAccount class is defined we can go one step further and derive more specialized classes from the SavingsAccount.
For example, to define the CD account class we need a new  member variable to store the days until maturity and define functions to access this variable: class CDAccount :  SavingsAccount { : CDAccount(int dollars, int cents, double rate, int days_to_maturity); <Other constructors would normally go here>.
Once again, we only defined functions and data that specifically relate to CD accounts, in this case, storing and manipulating the number of days to maturity.
We don't need to redefine all of the variables and functions relating to bank accounts or savings accounts because those members will be inherited from the parent classes.
For example, once the functions in the CDAccount class are implemented, we could invoke the following functions from the CDAccount, SavingsAccount, or BankAccount classes given a CDAccount object: 601.
Chapter 10 / Defining Classes <Everything from Display 10_0_6 should be inserted here except for the main function_0_> 1 2 3 class SavingsAccount :  BankAccount { : 4 5 6 7 The colon indicates that the class SavingsAccount is derived from.
Note the preceding colon.
Screen Output Account  $100_0_50 Interest rate 5_0_50% $10_0_25.
Account  $110_0_75 Interest rate 5_0_50% $11_0_80.
Account  $98_0_95 Interest rate 5_0_50%.
CDAccount Invoking a function in BankAccount This short example has only scratched the surface of what is possible using inheritance.
Additional details are described in Chapter 15.
While it does take some effort to learn how to effectively design classes using inheritance, the effort will pay off in the long run.
You will end up writing less code that is easier to understand and maintain than code that does not use inheritance.
Chapter 10 / Defining Classes Self- T es t Exe rc is e s 29.
How does inheritance support code reuse and make code easier to maintain.
Can a derived class directly access by name a private  variable of the parent class.
Suppose the class SportsCar is a derived class of a class Automobile.
Suppose also that the class Automobile has public  functions named accelerate and addGas.
Will an object of the class SportsCar have  functions named accelerate and addGas.
Chapter Summary ■ A structure can be used to combine data of different types into a single (compound) data value.
If it is public, it can be used outside of the class.
If it is private, it can be used only in the definition of another member function in the class.
A constructor must have the same name as the class of which it is a member.
The child or derived class inherits members from the parent class.
Answers to Self-Test Exercises Answe rs to S e lf-T est Exer cises 1.
Many compilers give poor error messages.
Surprisingly, the error message from gplus_plus is quite informative.
Member variables not provided an initializer are initialized to a zero of appropriate type.
The author of the code provides only two digits for the date initializer.
There should be four digits used for the  because a program using two-digit dates could fail in ways that vary from amusing to disastrous at the turn of the century.
Both the dot operator and the scope resolution operator are used with member names to specify the class or struct of which the member name is a member.
If class DayOfYear is as defined in Display 10_0_3 and today is an object of the class DayOfYear, then the member  may be accessed with the dot operator: today_0_.
When we give the definition of a member function, the scope resolution operator is used to tell the compiler that this function is the one declared in the class whose name is given before the scope resolution operator.
This restricts any change of private variables to functions provided by the class author.
The class author is then in control of these changes to the private data, preventing inadvertent corruption of the class data.
The compiler warns if you have no public: members in a class (or struct for that matter).
Chapter 10 / Defining Classes c.
In a class, such a section is by default a private: section.
In a struct, such a section is by default a public: section.
YourClass YourClass an_object an_object an_object.
If you mean this to be a declaration of an object called yet_another_object, then it is wrong.
It is a correct function declaration for a function called yet_another_object that takes zero arguments and that returns a value of type YourClass, but that is not the intended meaning.
As a practical matter, you can probably consider it illegal.
The correct way to declare an object called Answers to Self-Test Exercises yet_another_object so that it will be initialized with the default.
The modified class definition is as follows:.
Notice that we have omitted the member function set, since the constructors make set unnecessary.
You must also add the following function definitions (and delete the function definition for DayOfYear::set):.
The member variables should all be private.
The member functions that are part of the interface for the ADT (that is, the member functions that are operations for the ADT) should be public.
You may also have auxiliary helping functions that are used only in the definitions of other member functions.
These auxiliary functions should be private.
All the declarations of private member variables are part of the implementation.
All the function declarations for private member functions are part of the implementation.
All member function definitions (whether the function is public or private) are part of the implementation.
You need to read only the interface parts.
That is, you need to read only the function declarations for public members of the class (which are listed in the class definitions) as well as the explanatory comments for these function declarations.
You need not read any of the function declarations of the private member functions, the declarations of the private member variables, the definitions of the public member functions, or the definitions of the private member functions.
BankAccount::BankAccount(int dollars, int cents, double rate) : dollars_part(dollars), cents_part(cents), interest_ .
Functions and data defined for the parent class can be made available in the derived class, eliminating the need to redefine the functions and data again in the derived class.
This enhances maintainability because there is now no duplication of code among multiple classes and hence only a single location in the code that may be subject to change.
Additionally, inheritance provides a clean way to isolate code that is only applicable to a derived class.
Since such code only appears in the definition of the derived class, it is usually easier to read.
No, but a derived class can indirectly access a private member variable of the parent class through a public function.
Yes, the derived class will have access to the same functions.
In Chapter 15 we will discuss how we can make the functions do different things for an object of class SportsCar versus an object of class Automobile.
Practice Programs Practice Programs can generally be solved with a short program that directly applies the programming principles presented in this chapter.
Use the same member variables as in Display 10_0_1 but make them private.
Include member functions for each of the following: one to return the initial balance, one to return the balance at maturity, one to return the interest rate, and one to return the term.
Include a constructor that sets all of the member variables to any specified values, as well as a default constructor.
Embed your class definition in a test program.
The new is in many ways similar to the second  for the class BankAccount given in Display 10_0_7.
Your new  for the class CDAccount will record the balance as two values of type int: one for the dollars and one for the cents.
The member variable for the interest rate will store the interest rate as a fraction rather than as a percentage.
For example, an interest rate of 4_0_3% will be stored as the value 0_0_043 of type double.
Store the term in the same way as in Display 10_0_1.
Define a class for a type called CounterType.
An object of this type is used to count things, so it records a count that is a nonnegative whole number.
Include a default constructor that sets the counter to zero and a constructor VideoNote Solution to Practice Program 10_0_1 611.
Chapter 10 / Defining Classes with one argument that sets the counter to the value specified by its argument.
Include member functions to increase the count by 1 and to decrease the count by 1.
Be sure that no member function allows the value of the counter to become negative.
Also, include a member function that returns the current count value and one that outputs the count to a stream.
The member function for doing output will have one formal parameter of type ostream for the output stream that receives the output.
Embed your class definition in a test program.
Programming Projects Programming Projects require more problem-solving than Practice Programs and can usually be solved many different ways_0_Visit www_0_myprogramminglab_0_com to complete many of these Programming Projects online and get instant feedback.
Write a grading program for a class with the following grading policies: a.
There are two quizzes, each graded on the basis of 10 points.
There is one midterm exam and one final exam, each graded on the basis of 100 points.
The final exam counts for 50 percent of the grade, the midterm counts for 25 percent, and the two quizzes together count for a total of 25 percent.
They should be Any grade of 90 or more is an A, any grade of 80 or more (but less than 90) is a B, any grade of 70 or more (but less than 80) is a C, any grade of 60 or more (but less than 70) is a D, and any grade below 60 is an F.
The program will read in the student's scores and output the student's record, which consists of two quiz and two exam scores as well as the student's average numeric score for the entire course and the final letter grade.
Define and use a structure for the student record.
If this is a class assignment, ask your instructor if input/output should be done with the keyboard and screen or if it should be done with files.
If it is to be done with files, ask your instructor for instructions on file names.
The student record class should have member variables for all the input data described in Programing Project 1 and a member variable for the student's weighted average numeric score for the entire course as well as a member to the function, member functions to retrieve the data from each of the Programming Projects member variables, a void function that calculates the student's weighted average numeric score for the entire course and sets the corresponding member variable, and a void function that calculates the student's final letter grade and sets the corresponding member variable.
Define a class called Month that is an abstract data type for a month.
Your class will have one member variable of type int to represent a month (1 for January, 2 for February, and so forth).
Include all the following member functions: a constructor to set the month using the first three letters in the name of the month as three arguments, a constructor to set the month using an integer as an argument (1 for January, 2 for February, and so forth), a default constructor, an input function that reads the month as an integer, an input function that reads the month as the first three letters in the name of the month, an output function that outputs the month as an integer, an output function that outputs the month as the first three letters in the name of the month, and a member function that returns the next month as a value of type Month.
The input and output functions will each have one formal parameter for the stream.
Embed your class definition in a test program.
This time the month is implemented as three member variables of type char that store the first three letters of the name of the month.
Embed your definition in a test program.
Modify the program so that everything that is output to the screen is also output to a file.
This means that all output statements will occur twice: once with the argument cout and once with an output-stream argument.
If you are in a class, obtain the file name from your instructor.
The input will still come from the keyboard.
Only the output will be sent to a file.
My mother always took a little red counter to the grocery store.
The counter was used to keep a tally of the amount of money she would have spent so far on that visit to the store, if she bought all the items in her basket.
There was a four-digit display, increment buttons for each digit, and a reset button.
There was an overflow indicator that came up red if more money was Write and implement the member functions of a class Counter that simulates and slightly generalizes the behavior of this grocery store 613.
Accounting for any carry when you increment should require no further action than adding an appropriate number to the private data member.
A member function bool overflow(); detects overflow.
Even though the display is an integer, in the simulation, the rightmost (lower-order) two digits are always thought of as cents and tens of cents, the next digit is dollars, and the fourth digit is tens of dollars.
Provide keys for cents, dimes, dollars, and tens of dollars.
Unfortunately, no choice of keys seems particularly mnemonic.
One choice is to use the keys asdfo:  for cents, followed by  digit 1 to 9; s for dimes, followed by digits 1 to 9; d for dollars, followed by  digit 1 to 9; and f for tens of dollars, again followed by  digit 1 to 9.
Each entry (one of asdf followed by 1 to 9) is followed by pressing the Return key.
Any overflow is reported after each operation.
Overflow can be requested by pressing the o key.
Write  rational number class.
This problem will be revisited in Chapter 11, where operator overloading will make the problem much easier.
For now we will use member functions add, sub, mul, div, and less that each carry out the operations +, -, *, /, and <.
For example,  + b will be written _0_add(b), and  < b will be written _0_less(b).
Programming Projects Provide member functions add, sub, mul, and div that return  rational value.
Provide  function less that returns  bool value.
These functions should do the operation suggested by the name.
Provide  member function neg that has no parameters and returns the negative of the calling object.
Provide  main function that thoroughly tests your class implementation.
The following formulas will be useful in defining functions.
Define  class called Odometer that will be used to track fuel and mileage for an automotive vehicle.
Include private member variables to track the miles driven and the fuel efficiency of the vehicle in miles per gallon.
The class should have  constructor that initializes these values to zero.
Include member function to reset the odometer to zero miles,  member function to set the fuel efficiency,  member function that accepts miles driven for trip and adds it to the odometer's total, and  member function that returns the number of gallons of gasoline that the vehicle has consumed since the odometer was last reset.
Use your class with  test program that creates several trips with different fuel efficiencies.
Use private member variables to store the day, month, and year along with an appropriate constructor and member functions to get and set the data.
Create  public function that returns the day of the week.
All helper functions should be declared private.
Embed your class definition in  suitable test program.
The The United States Postal Service printed  bar code on every envelope that represented  five- (or more) digit zip code using  format called POSTNET (this format was deprecated in favor of  new , OneCode, in 2009).
The bar code consists of long and short bars as shown: 615.
Chapter 10 / Defining Classes For this program, we will represent the bar code as  string of digits.
The digit 1 represents  long bar, and the digit 0 represents  short bar.
Therefore, the bar code would be represented in our program as 110100101000101011000010011 The first and last digits of the bar code are always 1.
Removing these leaves 25 digits.
If these 25 digits are split into groups of 5 digits each, we have 10100 10100.
There will always be exactly two 1s in each group of digits.
Each digit stands for  number.
From left to right, the digits encode the values 7, 4, 2, 1, and 0.
Multiply the corresponding value with the digit and compute the sum to get the final encoded digit for the zip code.
The table below shows the encoding for 10100.
Bar Code Digits 1.
Zip   = 7 + 0 + 2 + 0 + 0 = 9 Repeat this for each group of 5 digits and concatenate to get the complete zip code.
There is one special value.
If the sum of a group of 5 digits is 11, then this represents the digit 0 (this is necessary because with two digits per group it is not possible to represent zero).
The zip code for the sample bar code decodes to 99504.
Although the POSTNET scheme may seem unnecessarily complex, its design allows machines to detect if errors have been made in scanning the zip code.
Write a zip code class that encodes and decodes 5-digit bar codes used by the The United States Postal Service on envelopes.
The class should have two constructors.
The first constructor should input the zip code as an integer, and the second constructor should input the zip code as a bar code string consisting of 0s and 1s, as described above.
Although you have two ways to input the zip code, internally, the class should store the zip code using only one format (you may choose to store it as a bar code string or as a zip code number).
The class should also have at least two public member functions, one to return the zip code as an integer, and the other to return the zip code in bar code format as a string.
All helper functions should be Programming Projects declared private.
Embed your class definition in a suitable test program.
Your program should print an error message if an invalid bar code is passed to the constructor.
Consider a class Movie that contains information about a movie.
The class has the following attributes: ■ The movie name.
Implement the class with accessor and mutator functions for the movie name and MPAA rating.
Write a function addRating that takes an integer as an input parameter.
The function should verify that the parameter is a number between 1 and 5, and if so, increment the number of people rating the movie that match the input parameter.
For example, if 3 is the input parameter, then the number of people that rated the movie as a 3 should be incremented by 1.
Write another function, getAverage, that returns the average value for all of the movie ratings.
Finally, add a constructor that allows the programmer to create the object with a specified name and MPAA rating.
The number of people rating the movie should be set to 0 in the constructor.
Test the class by writing a main function that creates at least two movie objects, adds at least five ratings for each movie, and outputs the movie name, MPAA rating, and average rating for each movie object.
Winston Churchill, Radio Broadcast, February 9, 1941 Introduction This chapter teaches you more techniques  defining functions and operators classes, including overloading common operators such as +, *, and / so that they can be used with the classes you define in the same way that they are used with the predefined types such as int and double.
Prerequisites This chapter uses material from Chapters 2 through 10.
Common advice Until now we have implemented class operations, such as input, output, accessor functions, and so forth, as member functions of the class, but some operations, it is more natural to implement the operations as ordinary (nonmember) functions.
In this section, we discuss techniques  defining operations on objects as nonmember functions.
We begin with a simple example.
Programming Example An Equality Function In Chapter 10, we developed a class called DayOfYear that records a date, such as January 1 or July 4, that might be a holiday or birthday or some other annual event.
We gave progressively better versions of the class.
The final version was produced in Self-Test Exercise 23 of Chapter 10.
In Display 11_0_1, we repeat this final version of the class DayOfYear and have enhanced the class one more time by adding a function called equal that can test two objects of type DayOfYear to see if their values represent the same date.
Chapter 11 / Friends, Overloaded Operators, and Arrays in Classes 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 bach_birthday_0_output( );.
Omitted function and constructor definitions are as in Chapter 10, Self-Test Exercises 14 and 24, but those details are not needed for what we are doing here.
Bach's birthday is  = 3,  = 21 Happy Birthday Johann Sebastian.
Suppose today and bach_birthday are two objects of type DayOfYear that have been given values representing some dates.
You can test to see if they represent the same date with the following Boolean expression: This call to the function equal returns true if today and bach_birthday represent the same date.
In Display 11_0_1 this Boolean expression is used to control an if-else statement.
The definition of the function equal is straight forward.
Two dates are equal if they represent the same  and the same  of the.
The definition of equal uses accessor functions  and  to compare the months and the days represented by the two objects.
Notice that we did not make the function equal a member function.
It would be possible to make equal a member function of the class DayOfYear, but equal compares two objects of type DayOfYear.
If you make equal a member function, you must decide whether the calling object should be the first date or the second date.
Rather than arbitrarily choosing one of the two dates as the calling object, we instead treated the two dates in the same way.
We made equal an ordinary (nonmember) function that takes two dates as its arguments.
S el f -T est Exerc ise 1.
Write a function definition for a function called before that takes two arguments of the type DayOfYear, which is defined in Display 11_0_1.
The function returns a bool value and returns true if the first argument represents a date that comes before the date represented by the second argument; otherwise, the function returns false; for example, January 5 comes before February 2.
Chapter 11 / Friends, Overloaded Operators, and Arrays in Classes Friend Functions If your class has a full set of accessor functions, you can use the accessor functions to define a function to test for equality or to do any other kind of computing that depends on the private member variables.
However, although this may give you access to the private member variables, it may not give you efficient access to them.
Look again at the definition of the function equal given in Display 11_0_1.
To read the , it must make a call to the accessor function.
To read the , it must make a call to the accessor function.
This works, but the code would be simpler and more efficient if we could just access the member variables.
A simpler and more efficient definition of the function equal given in Display 11_0_1 would be as follows:.
It's illegal because the member variables  and  are private members of the class DayOfYear.
Private member variables (and private member functions) cannot normally be referenced in the body of a function unless the function is a member function, and equal is not a member function of the class DayOfYear.
But there is a way to give a nonmember function the same access privileges as a member function.
If we make the function equal a friend of the class DayOfYear, then the previous definition of equal will be legal.
A friend function of a class is not a member function of the class, but a friend function has access to the private members of that class just as a member function does.
A friend function can directly read the value of a member variable and can even directly change the value of a member variable, for example, with an assignment statement that has a private member variable on one side of the assignment operator.
To make a function a friend function, you must name it as a friend in the class definition.
For example, in Display 11_0_2 we have rewritten the definition of the class DayOfYear so that the function equal is a friend of the class.
You make a function a friend of a class by listing the function declaration in the definition of the class and placing the keyword friend in front of the function declaration.
A friend function is added to a class definition by listing its function declaration, just as you would list the declaration of a member function, except that you precede the function declaration by the keyword friend.
However, a friend is not a member function; rather, it really is an ordinary function with extraordinary access to the data members of the class.
The friend is defined and called exactly like the ordinary function it is.
In particular, the function definition for equal shown in Display 11_0_2 does 11_0_1 Friend Functions Display 11_0_2   Equality Function as a Friend 1 2 3 4 5 6 7 8 9 10 11 12.
Note that the private member variables and  can be accessed by name.
Chapter 11 / Friends, Overloaded Operators, and Arrays in Classes not  the qualifier DayOfYear:: in the function heading.
Also, the equal function is not called by using the dot operator.
The function equal takes objects of type DayOfYear as arguments the same way that any other nonmember function would take arguments of any other type.
However, a friend function definition can access the private member variables and private member functions of the class by name, so it has the same access privileges as a member function.
After all, friend functions have access to the private member variables and so do not need accessor or mutator functions.
This is not entirely wrong.
It is true that if you made all the functions in the world friends of a class, you would not need accessor or mutator functions.
However, making all functions friends is not practical.
In order to see why you still need accessor functions, consider the example of the class DayOfYear given in Display 11_0_2.
You might use this class in another program, and that other program might very well want to do something with the  part of a DayOfYear object.
For example, the program might want to calculate how many months there  remaining in the year.
Specifically, the main part of the program might contain the following:.
You have just seen that you definitely need to  accessor functions in your class.
Other cases require mutator functions.
You may think that, because you usually need accessor and mutator functions, you do not need friends.
In a sense, that is true.
Notice that you could define the function or not as a friend and use accessor functions (as in Display 11_0_1).
In most situations, the only reason to make a function a friend is to make the definition of the function simpler and more efficient; but sometimes, that is reason enough.
To make a function a friend of a class, you must list the function declaration for the friend function in the class definition.
The function declaration is preceded by the keyword friend.
The function declaration may be placed in either the private section or the public section, but it will be a public function in either case, so it is clearer to list it in the public section.
Member_Function_Declarations private: Private_Member_Declarations }; You need not list the friend functions first.
You can inter mix the order of these function declarations.
Example class FuelTank { public: friend double need_to_fill(FuelTank tank);.
A friend function is defined and called the same way as an ordinary function.
You do not use the dot operator in a call to a friend function and you do not use a type qualifier in the definition of a friend function.
In fact, sometimes it is not clear whether you should make a particular function a friend of your class or a member function of the class.
In most cases, you can make a function either a member function or a friend and have it perform the same task in the same way.
There , however, places where it is better to use a member function and places where it is better to use a friend function (or even a plain old function that isn't a friend, like the version of equal in Display 11_0_1).
A simple rule to help you decide between member functions and nonmember functions is the following: ■ Use a member function if the task being performed by the function involves only one object.
For example, the function equal in Display 11_0_1 (and Display 11_0_2) involves two objects, so we made it a nonmember (friend) function.
Whether you make a nonmember function a friend function or use accessor and mutator functions is a matter of efficiency and personal taste.
As long as you have enough accessor and mutator functions, either approach will work.
The choice of whether to use a member or nonmember function is not always as simple as the above two rules.
With more experience, you will discover situations in which it pays to violate those rules.
A more accurate but harder to understand rule is to use member functions if the task is intimately related to a single object; use a nonmember function when the task involves more than one object and the objects  used symmetrically.
However, this more accurate rule is not clear-cut, and the two simple rules given above will serve as a reliable guide until you become more sophisticated in handling objects.
The value is implemented as a single integer value that represents the amount of money as if it were converted to all pennies.
For example, $9_0_95 would be stored as the value 995.
Since we use an integer to represent the amount of money, the amount is represented as an exact quantity.
We did not use a value of type double because values of type double  stored as approximate values and we want our money amounts to be exact quantities.
This integer for the amount of money (expressed as all cents) is stored in a member variable named all_cents.
We could use int for the type of the 11_0_1 Friend Functions member variable all_cents, but with some compilers that would severely limit the amounts of money we could represent.
In some implementations of Cplus_plus, only 2 bytes are used to store the int type_0_1 The result of the 2-byte implementation is that the largest value of type int is only slightly larger than 32000, but 32000 cents represents only $320, which is a fairly small amount of money.
Since we may want to deal with amounts of money much larger than $320, we have used long for the type of the member variable all_cents.
Cplus_plus compilers that implement the int type in 2 bytes usually implement the type long in 4 bytes.
Values of type long are integers just like the values of the type int, except that the 4-byte long implementation enables the largest allowable value of type long to be much larger than the largest allowable value of type int.
On most systems the largest allowable value of type long is 2 billion or larger.
The two names long The class Money has two operations that are friend functions: equal and add (which are defined in Display 11_0_3).
The function add returns a Money object whose value is the sum of the values of its two arguments.
A function call of the form equal(amount1, amount2) returns true if the two objects amount1 and amount2 have values that represent equal amounts of money.
Notice that the class Money reads and writes amounts of money as we normally write amounts of money, such as $9_0_95 or –$9_0_95.
First, consider the member function input (also defined in Display 11_0_3).
That function first reads a single character, which should be either the dollar sign ('$') or the minus sign ('−').
If this first character is the minus sign, then the function remembers that the amount is negative by setting the value of the variable negative to true.
It then reads an additional character, which should be the dollar sign.
On the other hand, if the first symbol is not '-', then negative is set equal to false.
At this point the negative sign (if any) and the dollar sign have been read.
The function input then reads the number of dollars as a value of type long and places the number of dollars in the local variable named dollars.
After reading the dollars part of the input, the function input reads the remainder of the input as values of type char; it reads in three characters, which should be a decimal point and two digits.
This is not done because of the way that some Cplus_plus compilers treat leading zeros.
As explained in the Pitfall section entitled "Leading Zeros in Number Constants," many compilers still in use do not read numbers with leading zeros as you would like them to, so an amount like $7_0_09 may be read incorrectly if your Cplus_plus code were to read the 09 as a See Chapter 2 for details.
Display 2_0_2 has a description of data types as most recent compilers implement them.
Chapter 11 / Friends, Overloaded Operators, and Arrays in Classes 1 2 3 4 5 6 7 8 9 10 11 12.
If the amount is negative, //then both dollars and cents must be negative.
Money(long dollars); //Initializes the object so its value represents $dollars_0_00.
Money( ); //Initializes the object so its value represents $0_0_00.
An amount of money, including a dollar sign, has been //entered in the input stream ins.
Notation  negative amounts is -$100_0_00.
Chapter 11 / Friends, Overloaded Operators, and Arrays in Classes 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129.
Sample Dialogue Enter an amount of money: $123_0_45 Your amount is $123_0_45 My amount is $10_0_09 One of us is richer.
Chapter 11 / Friends, Overloaded Operators, and Arrays in Classes The following assignment statement converts the two digits that make up the  part of the input amount to a single integer, which is stored in the local variable : = digit_to_int(digit1) * 10 + digit_to_int(digit2); After this assignment statement is executed, the value of  is the number of  in the input amount.
The helping function digit_to_int takes an argument that is a digit, such as '3', and converts it to the corresponding int value, such as 3.
We need this helping function because the member function input reads the two digits for the number of  as two values of type char, which are stored in the local variables digit1 and digit2.
However, once the digits are read into the computer, we want to use them as numbers.
Therefore, we use the function digit_to_int to convert a digit such as '3' to a number such as 3.
The definition of the function digit_to_int is given in Display 11_0_3.
You can simply take it on faith that this definition does what it is supposed to do and treat the function as a black box.
All you need to know is that digit_to_ int('0') returns 0, digit_to_int('1') returns 1, and so forth.
However, it is not too difficult to see how this function works, so you may want to read the optional section that follows this one.
It explains the implementation of digit_to_int.
Once the local variables  and  are set to the number of and the number of  in the input amount, it is easy to set the member variable.
The following assignment statement sets all_ to the correct number of : =  * 100 + ; However, this always sets  to a positive amount.
If the amount of money is , then the value of  must be changed from positive to.
This is done with the following statement: = -; The member function output (Display 11_0_3) calculates the number of and the number of  from the value of the member variable It computes the number of  and the number of  using integer division by 100.
For example, if  has a value of 995 (), then the number of  is 995/100, which is 9, and the number of  is 995%100, which is 95.
Thus, $9_0_95 would be the value output when the value of  is 995 ().
The definition for the member function output needs to make special provisions for outputting  amounts of money.
The result of integer division with  numbers does not have a standard definition and can vary from one implementation to another.
To avoid this problem, we have taken the absolute value of the number in  before performing 11_0_1 Friend Functions division.
To compute the absolute value we use the predefined function labs.
The function labs returns the absolute value of its argument, just like the function abs, but labs takes an argument of type long and returns a value of type long.
The function labs is in the library with header file cstdlib, just like the function abs.
If your implementation of Cplus_plus does not include labs, you can easily define the The definition of the function digit_to_int from Display 11_0_3 is reproduced.
At first glance, the formula for the value returned may seem a bit strange, but the details are not too complicated.
The digit to be converted— for example, '3'—is the parameter c, and the returned value will turn out to be the corresponding int value—in this example, 3.
As we pointed out in Chapters 2 and 6, values of type char are implemented as numbers.
Unfortunately, the number implementing the digit '3', for example, is not the number 3.
The type cast <int>(c) produces the number that implements the character c and converts this number to the type int.
This changes c from the type char to a number of type int but, unfortunately, not to the number we want.
For example, <int>('3') is not 3, but is some other number.
We need to convert <int>(c) to the number corresponding to c (for example, '3' to 3).
So let's see how we must adjust <int>(c) to get the number we want.
We know that the digits are in order.
So <int>('0') + 1 is equal to <int>('1'); <int>('1') + 1 is equal to <int>('2'); <int>('2') + 1 is equal to static_ cast<int>('3'), and so forth.
Knowing that the digits are in this order is all.
Leading Zeros in Number Constants.
However, this will cause problems.
In mathematics, the numerals 9 and 09 represent the same number.
However, some Cplus_plus compilers use a leading zero to signal a different kind of numeral, so in Cplus_plus the constants 9 and 09 are not necessarily the same number.
With some compilers, a leading zero means that the number is written in base 8 rather than base 10.
Since base 8 numerals do not use the digit 9, the constant 09 does not make sense in Cplus_plus.
The constants 00 through 07 should work correctly, since they mean the same thing in base 8 and in base 10, but some systems in some contexts will have trouble even with 00 through 07.
The ANSI Cplus_plus standard provides that input should default to being interpreted as decimal, regardless of the leading 0.
The GNU project Cplus_plus compiler, gplus_plus, and Microsoft's VCplus_plus compiler do comply with the standard, and so they do not have a problem with leading zeros.
Most compiler vendors track the ANSI standard and thus should be compliant with the ANSI Cplus_plus standard, and so this problem with leading zeros should eventually go away.
You should write a small program to test this on your compiler.
What is the difference between a friend function for a class and a member function for the class.
Suppose you wish to add a friend function to the class DayOfYear defined in Display 11_0_2.
This friend function will be named after and will take two arguments of the type DayOfYear.
The function returns true if the first argument represents a date that comes after the date represented by the second argument; otherwise, the function returns false.
For example, February 2 comes after January 5.
What do you need to add to the definition of the class DayOfYear in Display 11_0_2.
Suppose you wish to add a friend function for subtraction to the class Money defined in Display 11_0_3.
What do you need to add to the description of the class Money that we gave in Display 11_0_3.
The subtraction function should take two arguments of type Money and return a value of type Money whose value is the value of the first argument minus the value of the second argument.
In order to write a value of type Money to the screen, you call output with cout as an argument.
For example, if purse is an object of type Money, then to output the amount of money in purse to the screen, you write the following in your program: purse_0_output(cout); It might be nicer not to have to list the stream cout when you send output to the screen.
Rewrite the class definition for the type Money given in Display 11_0_3.
The only change is that this rewritten version overloads the function name output so that there are two versions of output.
One version is just like the one shown in Display 11_0_3; the other version of output takes no arguments and sends its output to the screen.
With this rewritten version of the type Money, the following two calls are equivalent: purse_0_output(cout);.
Note that since there will be two versions of the function output, you can still send output to a file.
If outs is an output file stream that is connected to a file, then the following will output the money in the object purse to the file connected to outs: purse_0_output(outs); 6_0_	Notice the definition of the member function input of the class Money given in Display 11_0_3.
If the user enters certain kinds of incorrect input, the function issues an error message and ends the program.
For example, if the user omits a dollar sign, the function issues an error message.
However, the checks given there do not catch all kinds of incorrect input.
For example, negative amounts of money are supposed to be entered in the form −$9_0_95, but if the user mistakenly enters the amount in the form $−9_0_95, then the input will not issue an error message and the value of the Money object will be set to an incorrect value.
What amount will the member function input read if the user mistakenly enters $−9_0_95.
How might you add additional checks to catch most errors caused by such a misplaced minus sign.
Chapter 11 / Friends, Overloaded Operators, and Arrays in Classes 7.
The Pitfall section entitled "Leading Zeros in Number Constants" suggests that you write a short program to test whether a leading 0 will cause your compiler to interpret input numbers as base-8 numerals.
Write such a program.
The const Parameter Modifier A call-by-reference parameter is more efficient than a call-by-value parameter.
A call-by-value parameter is a local variable that is initialized to the value of its argument, so when the function is called there are two copies of the argument.
With a call-by-reference parameter, the parameter is just a placeholder that is replaced by the argument, so there is only one copy of the argument.
For parameters of simple types, such as int or double, the difference in efficiency is negligible, but for class parameters the difference in efficiency can sometimes be important.
Thus, it can make sense to use a call-by-reference parameter rather than a call-by-value parameter for a class, even if the function does not change the parameter.
If you are using a call-by-reference parameter and your function does not change the value of the parameter, you can mark the parameter so that the compiler knows that the parameter should not be changed.
To do so, place the modifier const before the parameter type.
The parameter is then called a constant parameter.
For example, consider the class Money defined in Display 11_0_3.
The Money parameters for the friend function add can be made into constant parameters as follows: class Money { public: friend Money add(const Money& amount1, const Money& amount2);.
When you use constant parameters, the modifier const must be used in both the function declaration and in the heading of the function definition, so with the change in the class definition above, the function definition for add would begin as follows: { _0__0_.
The remainder of the function definition would be the same as in Display 11_0_3.
Constant parameters are a form of automatic error checking.
If your function definition contains a mistake that causes an inadvertent change to the constant parameter, then the computer will issue an error message.
The parameter modifier const can be used with any kind of parameter; however, it is normally used only for call-by-reference parameters for classes (and occasionally for certain other parameters whose corresponding arguments are large).
When you have a call to a member function, the calling object behaves very much like a call-by-reference parameter.
When you have a call to a member function, that function call can change the value of the calling object.
For example, consider the following, where the class Money is as in Display 11_0_3: const with.
When the object m is declared, the  of the member variable all_cents is initialized to 0.
The call to the member function input changes the  of the member variable all_cents to a new  determined by what the user types in.
Thus, the call m_0_input(cin) changes the  of m, just as if m were a call-by-reference argument.
The modifier const applies to calling objects in the same way that it applies to parameters.
If you have a member function that should not change the  of a calling object, you can mark the function with the const modifier; the computer will then issue an error message if your function code inadvertently changes the  of the calling object.
In the case of a member function, the const goes at the end of the function declaration, just before the final semicolon, as shown here: class Money { public: _0__0_.
The modifier const should be used in both the function declaration and the function definition, so the function definition for output would begin as follows: void Money::output(ostream& outs) const {.
Inconsistent Use of const Use of the const modifier is an all-or-nothing proposition.
If you use const for one parameter of a particular type, then you should use it for every other parameter that has that type and that is not changed by the function call; moreover, if the type is a class type, then you should also use the const modifier for every member function that does not change the  of its calling object.
For example, consider the following definition of the function guarantee: 639 VideoNote const Confusion 640.
The member function  does not change the calling object price.
However, when the compiler processes the function definition for guarantee, it will think that  does (or at least might) change the  of price.
This is because when it is translating the function definition for guarantee, all that the compiler knows about the member function  is the function declaration for ; if the function declaration does not contain a const, which tells the compiler that the calling object will not be changed, then the compiler assumes that the calling object will be changed.
Thus, if you use the modifier const with parameters of type Money, then you should also use const with all Money member functions that do not change the  of their calling object.
In particular, the function declaration for the member function should include a const.
In Display 11_0_4 we have rewritten the definition of the class Money given in Display 11_0_3, but this time we have used the const modifier where appropriate.
The definitions of the member and friend functions would be the same as they are in Display 11_0_3, except that the modifier const must be used in function headings so that the headings match the function declarations shown in Display 11_0_4.
If you make a mistake in your definition of the function so that it does change the constant parameter, then the computer will give an error message.
Parameters of a class type that are not changed by the function ordinarily should be constant call-by-reference parameters, rather than call-by- parameters.
If you make a mistake in your definition of the function so that it does change the calling object and the function is marked with const, then the computer will give an error message.
The const is placed at the end of the function declaration, just before the final semicolon.
The heading of the function definition should also have a const so that it matches the function declaration.
Example class Sample {.
Use of the const modifier is an all-or-nothing proposition.
You should use the const modifier whenever it is appropriate for a class parameter and whenever it is appropriate for a member function of the class.
If you do not use const every time that it is appropriate for a class, then you should never use it for that class.
Chapter 11 / Friends, Overloaded Operators, and Arrays in Classes 13 14 15 //Initializes the object so its value represents an amount with the //dollars and cents given by the arguments.
If the amount is negative, //then both dollars and cents must be negative.
An amount of money, including a dollar sign, has been //entered in the input stream ins.
Notation  negative amounts is -$100_0_00.
Give the complete definition of the member function get_value that you would use with the definition of  given in Display 11_0_4.
Why would it be incorrect to add the modifier const, as shown here, to the function declaration  the member function input of the class given in Display 11_0_4.
What are the differences and the similarities between a call-by-value parameter and a call-by-const-reference parameter.
Function declarations that illustrate these are.
What is the promise in each case.
Earlier in this chapter, we showed you how to make the function add a friend of the class  and use it to add two objects of type  (Display 11_0_3).
The function add is adequate  adding objects, but it would be nicer if you could simply use the usual + operator to add values of type , as in the last line of the following code:.
Recall that an operator, such as +, is really just a function except that the syntax  how it is used is slightly different from that of an ordinary function.
In an ordinary function call, the arguments are placed in parentheses after the function name, as in the following: With a (binary) operator, the arguments are placed on either side of the operator, as shown here: cost + tax 643.
Chapter 11 / Friends, Overloaded Operators, and Arrays in Classes A function can be overloaded to take arguments of different types.
An operator is really a function, so an operator can be overloaded.
The way you overload an operator, such as +, is basically the same as the way you overload a function name.
In this section we show you how to overload operators in Cplus_plus.
Overloading Operators You can overload  operator + (and many other operators) so  it will accept arguments of a class type.
The difference between overloading  + operator and defining  function add (given in Display 11_0_3) involves only a slight change in syntax.
The definition of  overloaded operator + is basically  same as  definition of  function add.
The only differences are  you use  name + instead of  name add and you precede  + with  keyword operator.
In Display 11_0_5 we have rewritten  type to include  overloaded operator + and we have embedded  definition in a small demonstration program.
The class , as defined in Display 11_0_5, also overloads  == so  == can be used to compare two objects of type.
If 1 and 2 are two objects of type Money, we want  expression 1 == 2 to return  same value as  following Boolean expression: 1.
As shown in Display 11_0_5, this is  value returned by  overloaded ==.
You can overload most, but not all, operators.
The  need not be a friend of a class, but you will often want it to be a friend.
Check  box entitled "Rules on Overloading Operators" for some technical details on when and how you can overload an.
Operator Overloading A (binary) , such as +, -, /, %, and so forth, is simply a function is called using a different syntax for listing its arguments.
With an ,  arguments are listed before and after  ; with a function,  arguments are listed in parentheses after  function name.
An   is written similarly to a function , except     includes  reserved word before   name.
The predefined operators, such as + and so forth, can be overloaded by giving them a new  for a class type.
An  may be a friend of a class although this is not required.
An example of overloading  +  as a friend is given in Display 11_0_5.
Some comments from Display 11_0_4 have been omitted to save space in this book, but they should be included in a real program.
Chapter 11 / Friends, Overloaded Operators, and Arrays in Classes 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59.
No other changes are needed in the member function definitions.
The bodies of the member function definitions are identical to those in Display 11_0_3> Output = $1_0_50 = $0_0_15 = $1_0_65 Things seem normal.
S el f -T est Exe rc ise s 12.
What is the difference between a (binary)  and a function.
Suppose you wish to overload the  < so that it applies to the type Money defined in Display 11_0_5.
What do you need to add to the description of Money given in Display 11_0_5.
Suppose you wish to overload the  <= so that it applies to the type Money defined in Display 11_0_5.
What do you need to add to the description of Money given in Display 11_0_5.
Is it possible using  overloading to change the behavior of + on integers.
Rules on Overloading Operators ■	When overloading an , at least one argument of the resulting overloaded  must be of a class type.
For example, you cannot change % from a binary to a unary  when you overload %; you cannot change plus_plus from a unary to a binary  when you overload it.
An overloaded has the same precedence as the ordinary version of the.
For example, x*y+z always means (x*y)+z, even if x, y, and z are objects and the operators + and * have been overloaded  the appropriate classes.
Some other operators, including [] and arrow_operator, also must be overloaded in a way that is different from what is described in this chapter.
The operators [] and arrow_operator are discussed later in this book.
Constructors for Automatic Type Conversion If your class definition contains the appropriate constructors, the system will perform certain type conversions automatically.
For example, if your program contains the definition  the class Money given in Display 11_0_5, you could use the following in your program: 647.
The 25 (in the expression base_amount + 25) is not  the appropriate type.
In Display 11_0_5 we only overloaded the  + so that it could be used with two values  type Money.
We did not overload + so that it could be used with a value  type Money and an integer.
The constant 25 is an integer and is not  type Money.
The constant 25 can be considered to be  type int or  type long, but 25 cannot be used as a value  type Money unless the class definition somehow tells the system how to convert an integer to a value  type Money.
The only way that the system knows that 25 means $25_0_00 is that we included a constructor that takes a single argument  type long.
When the system sees the expression base_amount + 25 it first checks to see if the  + has been overloaded for the combination a value  type Money and an integer.
Since there is no such overloading, the system next looks to see if there is a constructor that takes a single argument that is an integer.
If it finds a constructor that takes a single-integer argument, it uses that constructor to convert the integer 25 to a value  type Money.
The constructor with one argument  type long tells the system how to convert an integer, such as 25, to a value  type Money.
The one-argument constructor says that 25 should be converted to an object  type Money whose member variable  is equal to 2500; in other words, the constructor converts 25 to an object  type Money that represents $25_0_00.
For example, the type Money (Display 11_0_5) has no constructor that takes an argument  type double, so the following is illegal and would produce an error message if you were to put it in a program that declares base_amount and  to be  type Money: = base_amount + 25_0_67; To make this use  + legal, you could change the definition  the class Money by adding another constructor.
The function declaration for the constructor you need to add is the following: class Money { public:.
Writing the definition for this new  is Self-Test Exercise 16.
These automatic type conversions (produced by constructors) seem most common and compelling with overloaded numeric operators such as + and −.
However, these automatic conversions apply in exactly the same way to arguments for ordinary functions, arguments for member functions, and arguments for other overloaded operators.
S el f -T est Exerc ise 16.
Give the definition for the  discussed at the end  the previous section.
The  is to be added to the class Money in Display 11_0_5.
The definition begins as follows: { Unary Operators In addition to the binary operators, such as + in +y, there are also unary operators, such as the  − when it is used to mean negation.
In the following statement, the unary  − is used to set the value  a variable equal to the negative  the value  the variable y: = -y; The increment and decrement operators plus_plus and −− are other examples unary operators.
You can overload unary operators as well as binary operators.
For example, you can redefine the type Money given in Display 11_0_5 so that it has both a unary and a binary  version  the subtraction/negation -.
The redone class definition is given in Display 11_0_6.
Suppose your program contains this class definition and the following code: Money 1(10), 2(6), 3;.
The overloading definition will apply to the  when it is used in prefix position, as in plus_plusx and −−.
The postfix versions  plus_plus and −−, as in xplus_plus and −−, are handled in a different manner, but we will not discuss these postfix versions.
For example, consider the following:.
Overloading << The operator is <<, the first operand is the output stream , and the second operand is the string value "Hello out there_0_\n".
You can change either of these operands.
If fout is an output stream of type ofstream and fout has been connected to a file with a call to open, then you can replace  with fout and the string will instead be written to the file connected to fout.
Of course, you can also replace the string "Hello out there_0_\n" with another string, a variable, or a number.
Since the insertion operator << is an operator, you should be able to overload it just as you overload operators such as + and -.
This is true, but there are a few more details to worry about when you overload the input and output operators >> and <<.
In our previous definitions of the class Money, we used the member function output to output values of type Money (Displays 11_0_3 through 11_0_6).
This is adequate, but it would be nicer if we could simply use the insertion operator << to output values of type Money as in the following: Money (100);.
This is an improved version class Money of the class Money given { in Display 11_0_5.
Chapter 11 / Friends, Overloaded Operators, and Arrays in Classes The two operands in this expression are  and , and evaluating the expression should cause the value of  to be written to the screen.
But if << is an  like + or *, then the expression above should also return some value.
After all, expressions with other operands, such as n1 + n2, return values.
To obtain the answer to that question, we need to look at a more complicated expression involving <<.
Let's consider the following expression, which involves evaluating a chain of expressions using <<: << "I  " <<  << " in my purse_0_\n";.
The first thing evaluated is the subexpression: If things are to work out, then the subexpression had better return  so that the computation can continue as follows: ( << ) << " in my purse_0_\n"; And if things are to continue to work out, ( << ) had better also return  so that the computation can continue as follows: << " in my purse_0_\n"; << returns a stream This is illustrated in Display 11_0_7.
The  << should return its first argument, which is a stream of type ostream.
Thus, the declaration  the overloaded  << (to use with the class Money) should be as follows: class Money { public:.
Once we  overloaded the insertion (output)  <<, we will no longer need the member function output and thus can delete output from 11_0_2 Overloading Operators Display 11_0_7   << as an Operator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32.
Since there are no more << operators, the process ends.
The definition of the overloaded  << is very similar to the member function output.
In outline form, the definition for the overloaded  is as follows: {  This part is the same as the body of Money::output < that is given in Display 11_0_3 (except that is replaced with _0_)_0_> return outs;.
Chapter 11 / Friends, Overloaded Operators, and Arrays in Classes << and >> return a reference Returning a reference There is one thing left to explain in the previous function declaration and definition for the overloaded  <<.
What is the meaning of the & in the returned type ostream&.
The easiest answer is that whenever an  (or a function) returns a stream, you must add an & to the end of the name for the returned type.
That simple rule will allow you to overload the operators << and >>.
However, although that is a good working rule that will allow you to write your class definitions and programs, it is not very satisfying.
You do not need to know what that & really means, but if we explain it, that will remove some of the mystery from the rule that tells you to add an &.
When you add an & to the name of a returned type, you are saying that the (or function) returns a reference.
All the functions and operators we seen thus far return values.
However, if the returned type is a stream, you cannot simply return the value of the stream.
In the case of a stream, the value of the stream is an entire file or the keyboard or the screen, and it may not make sense to return those things.
Thus, you want to return only the stream itself rather than the value of the stream.
When you add an & to the name of a returned type, you are saying that the  (or function) returns a reference, which means that you are returning the object itself, as opposed to the value of the object.
The extraction  >> is overloaded in a way that is analogous to what >>, the second argument will be the object that receives the input value, so the second parameter must be an ordinary call-by-reference parameter.
In outline form, the definition for the overloaded extraction  >> is as follows: {  This part is the same as the body of < Money::input given in Display 11_0_3 (except that all_cents is replaced with _0_all_cents)_0_> return ins; } The complete definitions of the overloaded operators << and >> are given in Display 11_0_8, where we  rewritten the class Money yet again.
This time we  rewritten the class so that the operators << and >> are overloaded to allow us to use these operators with values of type Money.
Overloading >> and << The input and output operators >> and << can be overloaded just like any other operators.
The type for the value returned must  the & symbol added to the end of the type name.
The function declarations and beginnings of the function definitions are as shown on the next page.
See Display 11_0_8 for an example.
DEFINITIONS istream&  >>(istream& Parameter_1, {.
This is an improved version of the class Money that we gave in Display 11_0_6.
Although we have omitted some of the comments from Displays 11_0_5 and 11_0_6, you should  them.
Chapter 11 / Friends, Overloaded Operators, and Arrays in Classes.
Chapter 11 / Friends, Overloaded Operators, and Arrays in Classes 100 101 102 103.
See Displays 11_0_3, 11_0_4, 11_0_5, and 11_0_6 for the definitions_0_> infile_0_dat outfile_0_dat $1_0_11 $2_0_22 $3_0_33 $1_0_11 copied from the file infile_0_dat.
Screen Output $1_0_11 copied from the file infile_0_dat.
Objects of type Pairs can be used in any situation where ordered pairs are needed.
Your task is to write implementations of the overloaded  >> and the overloaded << so that objects of class Pairs are to be input and output in the form (5,6)(5,-4)(-5,4) or (-5,-6).
You need not implement any constructor or other member, and you need not do any input format checking.
Following is the definition for a class called Percent.
Objects of type Percent represent percentages such as 10% or 99%.
Give the definitions of the overloaded operators >> and << so that they can be used for input and output with objects of the class Percent.
Assume that input always consists of an integer followed by the character '%', such as 25%.
All percentages are whole numbers and are stored in the int member variable named value.
You do not need to define the other overloaded operators and do not need to define the constructor.
You only have to define the overloaded operators >> and <<.
Percent& the_object); //Overloads the >>  to input values of type //Percent.
In this section we discuss a few simple examples to give you an idea of the possibilities.
Arrays of Classes The base type of an array may be any type, including types that you define, such as structure and class types.
If you want each indexed variable to contain items of different types, make the array an array of structures.
For example, suppose you want an array to hold ten weather data points, where each data point is a wind velocity and a wind direction (north, south, east, or west).
You might use the following type definition and array declaration: struct WindInfo.
The way to read an expression such as data_point[]_0_velocity is left to right and very carefully.
First, data_point is an array.
So, data_point[] is the ith indexed variable of this array.
An indexed variable of this array is of type WindInfo, which is a structure with two member variables named velocity and direction.
So, data_point[]_0_velocity is the member variable named velocity for the ith array element.
Less formally, data_point[]_0_velocity is the wind velocity for the ith data point.
Similarly, data_point[]_0_direction is the wind direction for the ith data point.
The ten data points in the array data_point can be written to the screen with the following for loop: << data_point[]_0_velocity << "direction " << data_point[]_0_direction << endl; Display 11_0_9 contains the definition for a class called Money.
Objects of the class Money are used to represent amounts of money in The United States currency.
The definitions of the member functions, member operations, and friend functions for this class can be found in Displays 11_0_3 through 11_0_8 and in the answer to Self-Test Exercise 13.
You can have arrays whose base type is the type Money.
A simple example is given in Display 11_0_9.
That program reads in a list of five amounts of money and computes how much each amount differs from the largest of the five amounts.
Notice that an array whose base type is a class is treated basically the same as any other array.
In fact, the program in Display 11_0_9 is very similar to the program in Display 7_0_1, except that in Display 11_0_9 the base type is a class.
When an array of classes is declared, the default constructor is called to initialize the indexed variables, so it is important to have a default constructor for any class that will be the base type of an array.
An array of classes is manipulated just like an array with a simple base type like int or double.
For example, the difference between each amount and the largest amount is stored in an array named difference, as follows: Money difference[5];.
Chapter 11 / Friends, Overloaded Operators, and Arrays in Classes 1 2 3 4 //This is the definition for the class Money.
If the amount //is negative, then both dollars and cents should be negative.
Money(long dollars); //Initializes the object so its value represents $dollars_0_00.
Money( ); //Initializes the object so its value represents $0_0_00.
Precedes each output value of type Money with a dollar sign.
Sample Dialogue Enter 5 amounts of money: $5_0_00 $10_0_00 $19_0_99 $20_0_00 $12_0_79 The highest amount  $20_0_00 The amounts and their differences from the largest are: $5_0_00 off by $15_0_00 $10_0_00 off by $10_0_00 $19_0_99 off by $0_0_01 $20_0_00 off by $0_0_00 $12_0_79 off by $7_0_21 663.
Chapter 11 / Friends, Overloaded Operators, and Arrays in Classes S el f -T est Exe rc ise s 19.
Give a type definition for a structure called Score that has two member variables called home_team and opponent.
Both member variables are of type int.
Declare an array called game that  an array with ten elements of type Score.
The array game might be used to record the scores of each of ten games for a sports team.
Write a program that reads in five amounts of money, doubles each amount, and then writes out the doubled values to the screen.
Use one array with Money as the base type.
For example, suppose you are a speed swimmer and want a program to keep track of your practice times for various distances.
You can use the structure my_best (of the type Data given next) to record a distance (in meters) and the times (in seconds) for each of ten practice tries swimming that distance: struct Data.
The structure my_best, declared above, has two member variables: One, named ,  a variable of type int (to record a ); the other, named time,  an array of ten values of type double (to hold times for ten practice tries at the specified ).
To set the  equal to 20 (meters), you can use the following: my_best.
The expression my_best_0_time[]  read left to right: my_best  a structure; my_best_0_time  the member variable named time.
Since my_best_0_time  an array, it makes sense to add an index.
So, the expression my_best_0_time[] the ith indexed variable of the array my_best_0_time.
If you use a class rather than a structure type, then you can do all your array manipulations with member functions and avoid such confusing expressions.
This  illustrated in the following Programming Example.
You might use an object of type TemperatureList in a program that does weather analysis.
The list of temperatures  kept in the member variable list, which  an array.
Since this array will typically be only partially filled, a second member variable, called size,  used to keep track of how much of the array  used.
The value of size  the number of indexed variables of the array list that are being used to store values.
An  of type TemperatureList  declared like an  of any other type.
For example, the following declares my_data to be an  of type TemperatureList: TemperatureList my_data; This declaration calls the default constructor with the new  my_data, and so the  my_data  initialized so that the member variable size has the value 0, indicating an empty list.
Once you have declared an  such as my_data, you can add an item to the list of temperatures (that , to the member array list) with a call to the member function add_temperature as follows: my_data_0_add_temperature(77); In fact, this  the only way you can add a temperature to the list my_data, since the array list  a private member variable.
Notice that when you add an item with a call to the member function add_temperature, the function call first tests to see if the array list  full and adds the value only if the array  not full.
The class TemperatureList  very specialized.
The only things you can do with an  of the class TemperatureList are to initialize the list so it empty, add items to the list, check if the list  full, and output the list.
To output the temperatures stored in the   (declared previously), the call would be as follows: << ; With the class TemperatureList you cannot delete a temperature from.
You could define a similar class  lists of pressures or lists of distances or lists of any other data expressed as values of type double.
To save yourself the trouble of defining all these different classes, you could define a single class that represents an arbitrary list of values of type double without specifying what the values represent.
Chapter 11 / Friends, Overloaded Operators, and Arrays in Classes 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 //This is a definition  the class //Temperaturelist.
Values of this type are lists of Fahrenheit temperatures.
Temperatures are output one per line.
S el f -T est Exerc ise s 21.
Change the class TemperatureList given in Display 11_0_10 by adding a member function called get_size, which takes no arguments and returns the number of temperatures on the list.
Change the type TemperatureList given in Display 11_0_10 by adding a member function called get_temperature, which takes one int argument that is an integer greater than or equal to 0 and strictly less than.
The function returns a value of type double, which is the temperature in that position on the list.
So,  an argument of 0, get_temperature returns the first temperature;  an argument of 1, it returns the second temperature, and so forth.
Assume that get_ temperature will not be called  an argument that specifies a location on the list that does not currently contain a temperature.
William Shakespeare, King Henry IV, Part III A dynamic array can have a base type that is a class.
A class can have a member variable that is a dynamic array.
You can combine the techniques you 667.
Chapter 11 / Friends, Overloaded Operators, and Arrays in Classes learned about classes and the techniques you learned about dynamic arrays in just about any way.
There are a few more things to worry about when using classes and dynamic arrays, but the basic techniques are the ones that you have already used.
Let's start  an example.
Programming Example   A String Variable Class Constructors Size of string value In Chapter 8 we showed you how to define array variables to hold C strings.
In the previous section you learned how to define dynamic arrays so that the  of the array can be determined when your program is run.
In this example we will define a class called StringVar whose objects are string variables.
An object of the class StringVar will be implemented using a dynamic array whose  is determined when your program is run.
So objects of type StringVar will have all the advantages of dynamic arrays, but they will also have some additional features.
We will define StringVar's member functions so that if you try to assign a string that is too long to an object of type StringVar, you will get an error message.
The version we define here provides only a small collection of operations for manipulating string objects.
In Programming Project 1 you are asked to enhance the class definition by adding more member functions and overloaded operators.
Since you could use the standard class string, as discussed in Chapter 8, you do not really need the class StringVar, but it will be a good exercise to design and code it.
The definition for the type StringVar is given in Display 11_0_11.
One constructor for the class StringVar takes a single argument of type int.
This argument determines the maximum allowable length for a string value stored in the object.
A default constructor creates an object  a maximum allowable length of 100.
Another constructor takes an array argument that contains a C string of the kind discussed in Chapter 8.
Note that this means the argument to this constructor can be a quoted string.
This constructor initializes the object so that it can hold any string whose length is less than or equal to the length of its argument, and it initializes the object's string value to a copy of the value of its argument.
For the moment, ignore the constructor that is labeled Copy constructor.
Also ignore the member function named ~StringVar.
Although it may look like one, ~StringVar is not a constructor.
We will discuss these two new  of member functions in later subsections.
The meanings of the remaining member functions for the class StringVar are straight forward.
A simple demonstration program is given in Display 11_0_11.
Two objects, your_name and our_name, are declared within the definition of the function conversation.
The object your_name can contain any string that is max_name_ or fewer characters long.
The object our_name is initialized to the string value "Borg" and can have its value changed to any other string of length 4 or less.
An object is declared as follows.
Sets the value of the object equal to the empty string.
StringVar( ); //Initializes the object so it can accept string values of length 100 //or less.
Sets the value of the object equal to the empty string.
StringVar(const char a[]); //Precondition: The array a contains characters terminated with '\0'.
If there is not sufficient room, then //only as much as will fit is copied.
Chapter 11 / Friends, Overloaded Operators, and Arrays in Classes 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 private: char *value; //pointer to dynamic array that holds the string value.
Sample Dialogue What is your name.
Kathryn Janeway We  Borg We will meet  Kathryn Janeway End of demonstration 11_0_4 Classes and Dynamic Arrays As we indicated at the beginning of this subsection, the class StringVar is implemented using a dynamic array.
The implementation is shown in Display 11_0_12.
When an object of type StringVar is declared, a constructor is called to initialize the object.
The constructor uses the new  to create a new dynamic array of characters for the member variable value.
The string value is stored in the array value as an ordinary string value, with '\0' used to mark the end of the string.
Notice that the size of this array is not determined until the object is declared, at which point the constructor is called and the argument to the constructor determines the size of the dynamic array.
As illustrated in Display 11_0_11, this argument can be a variable of type int.
Look at the declaration of the object  in the definition of the function conversation.
The argument to the constructor is the call-by-value parameter max_name_size.
Recall that a call-by-value parameter is a local variable, so max_name_size is a variable.
Any int variable may be used as the argument to the constructor in this way.
The implementation of the member functions length, input_line, and the overloaded output  <<  all straightforward.
In the next few subsections we discuss the function ~StringVar and the constructor labeled Copy constructor.
They do not go away unless your program makes a suitable call to delete.
Even if the dynamic variable was created using a local pointer variable and the local pointer variable goes away at the end of a function call, the dynamic variable will remain unless there is a call to delete.
If you do not eliminate dynamic variables with calls to delete, they will continue to occupy memory space, which may cause your program to abort because it used up all the memory in the freestore.
Moreover, if the dynamic variable is embedded in the implementation of a class, the programmer who uses the class does not know about the dynamic variable and cannot be expected to perform the call to delete.
In fact, since the data members  normally private members, the programmer normally cannot access the needed pointer variables and so cannot call delete with these pointer variables.
To handle this problem, Cplus_plus has a special kind of member function called a destructor.
A destructor is a member function that is called automatically when an object of the class passes out of scope.
This means that if your program contains a local variable that is an object with a destructor, then when the function call ends, the destructor is called automatically.
If the destructor is defined correctly, the destructor calls delete to eliminate all the dynamic variables created by the object.
This may be done with a single call to delete or it may require several calls to delete.
You might also want your destructor to perform some other cleanup details as well, but returning memory to the freestore is the main job of the destructor.
VideoNote Arrays of Classes using Dynamic Arrays 672 Chapter 11 / Friends, Overloaded Operators, and Arrays in Classes The member function ~StringVar is the destructor for the class StringVar shown in Display 11_0_11.
Like a constructor, a destructor always has the same name as the class it is a member of, but the destructor has the tilde symbol,~, at the beginning of its name (so you can tell that it is a destructor and not a constructor).
Like a constructor, a destructor has no type for the value returned, not even the type void.
A destructor has no parameters.
Thus, a class can have only one destructor; you cannot overload the destructor for a class.
Otherwise, a destructor is defined just like any other member function.
Notice the definition of the destructor ~StringVar given in Display 11_0_12.
Look  at the function conversation in the sample program shown in Display 11_0_11.
The local variables your_ name and  both create dynamic arrays.
If this class did not have a destructor, then after the call to conversation has ended, these dynamic arrays would still be occupying memory, even though they  useless to the program.
This would not be a problem here because the sample program ends soon after the call to conversation is completed; but if you wrote a program that made repeated calls to functions like conversation, and if the class StringVar did not have a suitable destructor, then the function calls could consume all the memory in the freestore and your program would then end abnormally.
Destructor A destructor is a member function of a class that is called automatically when an object of the class goes out of scope.
Among other things, this means that if an object of the class type is a local variable for a function, then the destructor is automatically called as the last action before the function call ends.
Destructors are used to eliminate any dynamic variables that have been created by the object so that the memory occupied by these dynamic variables is returned to the freestore.
Destructors may perform other cleanup tasks as well.
The name of a destructor must consist of the tilde symbol,~, followed by the name of the class.
Pointers as Call-by-Value Parameters When a call-by- parameter is of a pointer type, its behavior can be subtle and troublesome.
Consider the function call shown in Display 11_0_13.
The parameter temp in the function sneaky is a call-by- parameter, and hence it is a local variable.
When the function is called, the  of temp is set to the  of the argument p and the function body is executed.
Since temp is a local variable, no changes to temp should go outside of the function sneaky.
In particular, the  of the pointer variable p should not be changed.
Yet the sample dialogue makes it look as if the  of the pointer variable p had changed.
Before the call to the function sneaky, the  of *p was 77, and after the call to sneaky the  of *p is 99.
Although the sample dialogue may make it look as if  were changed, the  of  was not changed by the function call to sneaky.
Pointer  has two things associated with it: 's pointer  and the  stored where  points.
Now, the of  is a pointer (that is, a memory address).
After the call to sneaky, the variable  contains the same pointer  (that is, the same memory address).
The call to sneaky has changed the  of the variable pointed to by , but it has not changed the  of  itself.
If the parameter type is a class or structure type that has member variables of a pointer type, the same kind of surprising changes can occur with call-byvalue arguments of the class type.
However, for class types, you can avoid (and control) these surprise changes by defining a copy constructor, as described in the next subsection.
The one parameter must be a call-by-reference parameter, and normally the parameter is preceded by the const parameter modifier, so it is a constant parameter.
In all other respects, a copy constructor is defined in the same way as any other constructor and can be used just like other constructors.
Display 11_0_14   The Function Call sneaky(); 1.
Before call to sneaky: 77 2.
Value of  is plugged in for : 77 3.
After call to sneaky: 99.
Chapter 11 / Friends, Overloaded Operators, and Arrays in Classes Called when an object is declared For example, a program that uses the class StringVar defined in.
The constructor used to initialize each of the three objects of type StringVar is determined by the type of the argument given in parentheses after the object's name.
The object line is initialized with the constructor that has a parameter of type ; the object motto is initialized by the constructor that has a parameter of type const char a[].
Similarly, the object is initialized by the constructor that has one argument of type const StringVar&.
When used in this way, a copy constructor is being used just like any other constructor.
A copy constructor should be defined so that the object being initialized becomes a complete, independent copy of its argument.
So, in the declaration StringVar (line); Call-by-value parameters Why a copy constructor is needed the member variable _0_value is not simply set to the same value as line.
The definition of the copy constructor is shown in Display 11_0_12.
Note that in the definition of the copy constructor, a new  array is created and the contents of one  array are copied to the other  array.
Thus, in the previous declaration,  is initialized so that its string value is equal to the string value of line, but  has a separate  array.
Thus, any change that is made to  has no effect on line.
As you have seen, a copy constructor can be used just like any other constructor.
A copy constructor is also called automatically in certain other situations.
Roughly speaking, whenever Cplus_plus needs to make a copy of an object, it automatically calls the copy constructor.
In particular, the copy constructor is called automatically in three circumstances: (1) when a class when a function returns a value of the class type, and (3) whenever an argument of the class type is "plugged in" for a call-by-value parameter.
In this To see why you need a copy constructor, let's see what would happen if we did not define a copy constructor for the class StringVar.
Suppose we did not include the copy constructor in the definition of the class StringVar and suppose we used a call-by-value parameter in a function definition, for example:.
Assuming there is no copy constructor, things proceed as follows: When the function  is executed, the value of  is copied to the local variable , so _0_value is set equal to _0_value.
But these are pointer variables, so during the function , _0_value and _0_value point to the same  array, as follows: _0_value _0_value When the function  ends, the destructor for StringVar is called to return the memory used by  to the freestore.
The definition of the destructor contains the following statement: delete [] value;.
Thus, _0_value is undefined when the program reaches the statement << "After : " <<  << endl; This  statement is therefore undefined.
The  statement may by chance give you the output you want, but sooner or later the fact that _0_value is undefined will produce problems.
One major problem occurs when the object is a local variable in some function.
In this case the destructor will be called with  when the function  ends.
That destructor  will be equivalent to delete [] _0_value;.
Chapter 11 / Friends, Overloaded Operators, and Arrays in Classes But, as we just saw, the  array pointed to by _0_value has already been deleted once, and now the system is trying to delete it a second time.
Calling delete twice to delete the same  array (or other variable created with )  produce a serious system error that  cause your program to crash.
Fortunately, we included a copy constructor in our definition of the class StringVar, so the copy constructor is called automatically when the following function  is executed: StringVar ("Hello"); show_string();.
If the destructor is called for  and then called for , each  to the destructor deletes a different  array.
When a function returns a value of a class type, the copy constructor is called automatically to copy the value specified by the return statement.
If there is no copy constructor, then problems similar to what we described for value parameters will occur.
If a class definition involves pointers and dynamically allocated memory using the  , then you need to include a copy constructor.
Classes that do not involve pointers or dynamically allocated memory do not need a copy constructor.
Contrary to what you might expect, the copy constructor is not called when you set one  equal to another using the assignment _0_2 However, if you do not like what the default assignment  does, you redefine the assignment  in the way described in the subsection Cplus_plus makes a careful distinction between initialization (the three cases where the copy constructor is called) and assignment.
Initialization uses the copy constructor to create a  ; the assignment  takes an existing  and modifies it so that it is an identical copy (in all but location) of the right-hand side of the assignment.
The one parameter must be a -by-reference parameter.
Normally,  parameter is also a constant parameter, that is, preceded by  const parameter modifier.
The copy constructor for a class is called automatically whenever a function returns a value of  class type.
The copy constructor is also called automatically whenever an argument is "plugged in" for a -byvalue parameter of  class type.
A copy constructor  also be used in same ways as other constructors.
Any class that uses pointers and    should have a copy constructor.
The Big Three The copy constructor,  =, and  destructor are called big three because experts say that if you need to define any of them, then you need to define all three.
If any of these is missing,  compiler will create it, but it may not behave as you want.
So it pays to define them yourself.
The copy constructor and  = that compiler generates for you will work fine if all member variables are of predefined types such as int and double, but they may misbehave on classes that have class or pointer member variables.
For any class that uses pointers and   , it is safest to define your own copy constructor,  =, and destructor.
S el f -T est Exerc ise s 23.
If a class is named MyClass and it has a constructor, what is  constructor named.
If MyClass has a destructor, what is  destructor named.
Suppose you change  definition of  destructor in Display 11_0_12 to following.
How would  sample dialogue in Display 11_0_11 change.
Chapter 11 / Friends, Overloaded Operators, and Arrays in Classes 25.
The following is  first line of  copy constructor definition for class StringVar.
The identifier StringVar occurs three times and means something slightly different each time.
What does it mean in each of three cases.
Answer these questions about destructors.
What is a destructor  what must  name of a destructor be.
When is a destructor called.
What does a destructor actually do.
Assignment Operator Suppose 1  2 are declared as follows: VideoNote =  == for a Class StringVar 1(10), 2(20);.
But this can cause problems with 1 probably even cause problems for 2.
The member variable 1_0_value contains a pointer, assignment statement sets this pointer equal to  same value as 2.
Thus, both 1_0_value  2_0_value point to  same place in memory.
If you change   value in 1, you will therefore also change   value in 2.
If you change   value in 2, you will change   value in 1.
In short,  predefined assignment statement does not do what we would like an assignment statement to do with objects of type StringVar.
Using predefined version of  assignment  with  class StringVar can only cause problems.
The way to fix this is to overload  assignment  = so that it does what we want it to do with objects of  class StringVar.
The assignment  cannot be  in  way we have other operators, such as <<  +.
When you overload assignment , it must be a member of  class; it cannot be a friend of class.
To add an  version of  assignment  to  class StringVar,  definition of StringVar should be changed to  following: 11_0_4 Classes  Dynamic Arrays class StringVar.
Display 11_0_11_0_> The assignment  is then used just as you always use  assignment For example, consider  following: 1 = 2; In this call, 1 is  calling   2 is  argument to.
Notice that  length of   in   on  right side of assignment  is checked.
If it is too long to fit in  object on  left side of  assignment  (which is  calling object), then only as many characters as will fit are copied to  object receiving.
But suppose you do not want to lose any characters in  copying process.
To fit in all  characters, you can create a ,  dynamic array for  object on  left-hand side of  assignment.
You might try to redefine assignment  as follows:.
Chapter 11 / Friends, Overloaded Operators,  Arrays in Classes.
So, the   in  is deleted  the pointer.
The assignment  has corrupted the object , this run of the program is probably ruined.
One way to fix this bug is to first check whether there is sufficient room in the dynamic array member of the object on the left-hand side of the assignment   to delete the array only if extra space is needed.
Our final definition of the  assignment  does just such a check:.
For many classes, the obvious definition  overloading the assignment does not work correctly when the same object is on both sides of the assignment.
You should always check this case  be careful to write your definition of the overloaded assignment  so that it also works in this case.
S el f -T est Exe rc ise 27.
Same as part (a)  a destructor.
Answers to Self-Test Exercises Chapter Summary ■ A friend function of a class is an ordinary function except that it has access to the private members of the class, just like the member functions do.
A structure or class can have an array as a member variable.
A destructor is called automatically when an object of the class passes out of scope.
The main reason  destructors is to return memory to the freestore so the memory can be reused.
If you define a copy constructor, it will be called automatically whenever a function returns a  of the class type  whenever an argument is "plugged in"  a call-by- parameter of the class type.
Any class that uses pointers  the    have a copy constructor.
However, it must be overloaded as a member of the class; it cannot be overloaded as a friend.
Any class that uses pointers the    overload the assignment   use with that class.
Chapter 11 / Friends, Overloaded Operators,  Arrays in Classes The previous Boolean expression says that date1 is before date2, provided the month of date1 is before the month of date2 or that the months are the same  the day of date1 is before the day of date2.
A friend function  a member function are alike in that they both can use any member of the class (either public or private) in their function definition.
However, a friend function is defined  used just like an ordinary function; the dot  is not used when you call a friend function,  no type qualifier is used when you define a friend function.
A member function, on the other hand, is called using an object name the dot.
Also, a member function definition includes a type qualifier consisting of the class name  the scope resolution  ::.
The modified definition of the class DayOfYear is shown below.
The part in color is.
The modified definition of the class Money is shown here.
The part in color is.
Answers to Self-Test Exercises class Money.
And, of course, you can combine this enhancement with the enhancements from previous Self-Test Exercises to produce one highly improved class Money.
If the user enters $−9_0_95 (instead of −$9_0_95), the function input will read the '$' as the value of , the -9 as the value of , the '_0_' as the value of ,  the '9'  '5' as the values of digit1 digit2.
That means it will set  equal to -9   equal Answers to Self-Test Exercises to 95  so set the amount equal to a value that represents −$9_0_00 plus 0_0_95, which is −$8_0_05.
One way to catch this problem is to test if the value of  is negative (since the value of   be an absolute value).
To do this, rewrite the error message portion as follows: if ( _0_= '$' ||  _0_= '_0_' ||  < 0).
This code still will not give an error message for incorrect input with zero as in $-0_0_95.
However, with the material we have learned thus far, a test for this case, while certainly possible, would significantly complicate the code and make it harder to read.
If the compiler interprets input with a leading 0 as a base-8 numeral, then with input data 077, the output  be 63.
The output  be 77 if the compiler does not interpret data with a leading 0 as indicating base 8.
The only change from the version given in Display 11_0_3 is that the modifier const is added to the function heading, so the definition is.
The member function input changes the value of its calling object, and so the compiler will issue an error message if you add the const modifier.
Similarities: Each parameter call protects the caller's argument from change.
Differences: The call-by-value makes a copy of the caller's argument, so it uses more memory than a call-by-constant-reference.
In the const int  = 17; declaration, the const keyword promises the compiler that code written by the author will not change the value of.
Chapter 11 / Friends, Overloaded Operators, and Arrays in Classes In the int f() const; declaration, the const keyword is a promise to the compiler that code written by the author to implement function f will not change anything in the calling object.
In the int g(const A& ); declaration, the const keyword is a promise to the compiler that code written by the class author will not change the argument plugged in for.
In a function call, the arguments are given in parentheses after the function name.
With an , the arguments are given before and after the.
Also, you must use the reserved word  in the declaration and in the definition of an overloaded.
The modified definition of the class Money is shown here.
The part in color is.
The modified definition of the class Money is shown here.
The part in color is have omitted some comments to save space, but all the comments shown in Display 11_0_5 should be included in this definition.
You also must add the following definition of the <= (as well as the definition of the   < given in the previous exercise): bool  <=(const Money& amount1, {.
Actually, this requirement prevents changing the effect of any on any built-in type.
This definition simply discards any amount that is less than one cent.
For example, it converts 12_0_34999 to the integer 1234, which represents the amount $12_0_34.
It is possible to define the constructor to instead do other things with any fraction of a cent.
See answer 22.
This answer combines the answers to this and the previous Self-Test Exercise.
The class definition would change to the following.
The constructor is named MyClass, the same name as the name of the class.
The destructor is named ~MyClass.
The dialogue would change to the following: What is your name.
Kathryn Janeway are Borg will meet again Kathryn Janeway Good-bye cruel world.
The short life of this dynamic array is about to end.
Good-bye cruel world.
The short life of this dynamic array is about to end.
End of demonstration Practice Programs 25.
The StringVar before the :: is the name of the class.
The StringVar right after the :: is the name of the member function.
A destructor's name always begins with a tilde, ~, followed by the class name.
A destructor is called when a class object goes out of scope.
A destructor actually does whatever the class author programs it to do.
Destructors may also do other cleanup tasks.
In the case of the assignment  =  the copy constructor, if there are only built-in types for data, the default copy mechanism is exactly what you want, so the default works fine.
In the case of the destructor, no dynamic memory allocation is done (no pointers), so the default do-nothing action is again what you want.
PrACTICE ProGRAMS Practice Programs can generally be solved with a short program that directly applies the programming principles presented in this chapter.
Modify the definition of the class Money shown in Display 11_0_8 so that all of the following are added: a_0_   <, <=, >,  >= have each been  to apply to b_0_  following member function has been added to the class definition.
Chapter 11 / Friends, Overloaded Operators,  Arrays in Classes 2.
Self-Test Exercise 17 asked you to overload the  >>  the  << for a class Pairs.
Complete  test this exercise.
Implement the default constructor  the constructors with one  two int parameters.
Overload binary + to add pairs according to the rule Overload - analogously.
Overload * on Pairs  int according to the rule Write a program to test all the member functions  overloaded in your class definition.
Self-Test Exercise 18 asked you to overload the  >>  the  << for a class Percent.
Complete  test this exercise.
Implement the default constructor  the constructor with one int parameter.
Overload the +  -  to add  subtract percents.
Also, overload the * to allow multiplication of a percent by an integer.
Write a program to test all the member functions  overloaded in your class definition.
Programming Projects Programming Projects require more problem-solving than Practice Programs can usually be solved many different ways.
Visit www_0_myprogramminglab_0_com to complete many of these Programming Projects online  get instant feedback.
In Chapter 8 we discussed vectors, which are like arrays that can grow in size.
Suppose that vectors were not defined in Cplus_plus.
Define a class called VectorDouble that is like a class for a vector with base type double.
Your class VectorDouble will have a private member variable for a array of doubles.
It will also have two member variables of type int; one called max_count for the size of the  array of doubles;  one called count for the number of array positions currently holding values.
Programming Projects Your class should have all of the following: ■	Three constructors: a default constructor that creates a  array for 50 elements, a constructor with one int argument for the number of elements in the initial  array,  a copy constructor.
To be equal, the values of count  the count array elements must be equal, but the values of max_count need not be equal.
Enforce suitable restrictions on the arguments to value_at change_value_at.
It can be made to work with square brackets, but we have not covered 2.
Define a class for rational numbers.
A rational number is a number that can be represented as the quotient of two integers.
For example, 1/2, 3/4, 64/2,  so forth are all rational numbers.
Call the class Rational.
Include a constructor with two arguments that can be used to set the member variables of an object to any legitimate values.
Also include a constructor that has only a single parameter of type int; call this single parameter whole_number  define the constructor so that the object will be initialized to the rational number whole_number/1.
Also include a default constructor that initializes an object to 0 (that is, to 0/1).
Overload the input  output  >>  <<.
Numbers are to be input  output in the form 1/2, 15/32, 300/401,  so forth.
Note that the numerator, the denominator, or both may contain a minus sign, so -1/2, 15/32, and -300/-401 are also possible inputs.
Overload all of the following operators so that they correctly apply to the type : ==, <, <=, >, >=, +, -, *, and /.
Also write a test program to test your class.
Chapter 11 / Friends, Overloaded Operators, and Arrays in Classes (Hints: Two rational numbers a/b and / are equal if a* equals *b.
If b and  are positive rational numbers, a/b is less than / provided a* is less than *b.
You should include a function to normalize the values stored so that, after normalization, the denominator is positive and the numerator and denominator are as small as possible.
For example, after normalization 4/-8 would be represented the same as -1/2.
You should also write a test program to test 3.
Define a class for complex numbers.
A complex number is a number of the form a+b*i where, for our purposes, a and b are numbers of type double, and i is a number that represents the quantity √ −1.
Represent a complex number as two values of type double.
Name the member variables real and imaginary.
Include a constructor with two parameters of type double that can be used to set the member variables of an object to any values.
Also include a constructor that has only a single parameter of type double; call this parameter real_part and define the constructor so that the object will be initialized to real_part+0*.
Also include a default constructor that initializes an object to 0 (that is, to 0+0*).
Overload all of the following operators so that they correctly apply to the type : ==, +, -, *, >>, and <<.
You should write a test program to test your class.
The product of two complex numbers is given by the following formula: (a + b*)*(c + d*) == (a*c – b*d) + (a*d + b*c)* In the interface file, you should define a constant  as follows:.
Enhance the definition of the class StringVar given in Displays 11_0_11 and.
Also write a suitable test program and thoroughly test your class definition.
Define a class called Text whose objects store lists of words.
The class Text will be just like  class StringVar except that  class Text will use a dynamic array with base type StringVar rather than base type char and will mark  end of  array with a StringVar object consisting of a single blank, rather than using '\0' as  end marker.
Intuitively, an object of class Text represents some text consisting of words separated by blanks.
Enforce  restriction that  array elements of type StringVar contain no blanks (except for  end marker elements of type StringVar).
Your class Text will have member functions corresponding to all member functions of StringVar.
The constructor with an argument of type const char a[] will initialize  Text object in  same way as described below for input_line.
If  C-string argument contains new- symbol '\n', that is considered an error and ends  program with an error message.
The member function input_line will read blank separated strings and store each string in one element of  dynamic array with base type StringVar.
Multiple blank spaces are treated  same as a single blank space.
When outputting an object of  class Text, insert one blank between each value of type StringVar.
You may either assume that no tab symbols are used or you can treat  tab symbols  same as a blank; if this is a class assignment, ask your instructor how you should treat  tab symbol.
Add  enhancements described in Programming Project 6.
The overloaded version of  extraction operator >> will fill only one element of  dynamic array.
Using dynamic arrays, implement a polynomial class with polynomial addition, subtraction, and multiplication.
Discussion: A variable in a polynomial does very little other than act as a placeholder for  coefficients.
Hence,  only interesting thing 697.
Chapter 11 / Friends, Overloaded Operators, and Arrays in Classes about polynomials is  array of coefficients and  corresponding exponent.
Think about  polynomial x*x*x + x + 1 One simple way to implement  polynomial class is to use an array of doubles to store  coefficients.
The index of  array is  exponent of  corresponding term.
Where is  term in x*x in previous example.
If a term is missing, then it simply has a zero coefficient.
There are techniques for representing polynomials of high degree with many missing terms.
These use so-called sparse polynomial techniques.
Unless you already know these techniques, or learn very quickly, don't use them.
Provide a default constructor, a copy constructor, and a parameterized constructor that enable an arbitrary polynomial to be constructed.
Also supply an overloaded  = and a destructor.
Provide these operations: ■ polynomial + polynomial.
Supply a function to evaluate  polynomial at a value of type double.
You should decide whether to implement these functions as members, friends, or stand-alone functions.
Write a checkbook balancing program.
The program will read in  following for all checks that were not cashed as of  last time you balanced your checkbook:  number of each check,  amount of  check, and whether or not it has been cashed.
Use an array with a class base type.
The class should be a class for a check.
There should be three member variables to record check number,  check amount, and whether or not  check was cashed.
The class for a check will have a member variable of type Money (as defined in Display 19) to record  check amount.
So, you will have a class used within Programming Projects a class.
The class for a check should have accessor and mutator functions as well as constructors and functions for both input and output of a check.
In addition to  checks,  program also reads all  deposits, as well as  old and  new.
You may want another array to hold  deposits.
The new   should be  old plus all deposits, minus all checks that have been cashed.
The program outputs the total of the checks cashed, the total of the deposits, what the new  should be, and how much this figure differs from what the bank says the new  is.
It also outputs two lists of checks: the checks cashed since the last time you balanced your checkbook and the checks still not cashed.
Display both lists of checks in sorted order from lowest to highest check number.
If this is a class assignment, ask your instructor if input/output should be done with the keyboard and screen or if it should be done with files.
If it is to be done with files, ask your instructor for instructions on file names.
Define a class called List that can hold a list of values of type double.
Model your class definition after the class TemperatureList given in Display 11_0_10, but your class List will make no reference to temperatures when it outputs values.
The values may represent any sort of data items as long as they are of type double.
Include the additional features specified in Self-Test Exercises 21 and 22.
Change the member function names so that they do not refer to temperature.
Add a member function called get_last that takes no arguments and returns the last item on the list.
The member function get_last does not change the list, and it should not be called if the list is empty.
Add another member function called delete_last that deletes the last element on the list.
The member function delete_last is a void function.
Note that when the last element is deleted, the member variable size must be adjusted.
If delete_last is called with an empty list as the calling object, the function call has no effect.
Design a program to thoroughly test your definition for the class List.
Define a class called StringSet that will be used to store a set of STL strings.
Use an array or a vector to store the strings.
Create a constructor that takes as an input parameter an array of strings for the initial values in the set.
Then write member functions to add a string to the set, remove a string from the set, clear the entire set, return the number of strings in the set, and output all strings in the set.
Overload the +  so that it returns the union of two StringSet objects.
Also overload the *  so that it returns the intersection of two StringSet objects.
Write a program to test all member functions and overloaded operators in your class.
Chapter 11 / Friends, Overloaded Operators, and Arrays in Classes 10.
This programming project requires you to complete Programming Project 9 first.
The field of information retrieval is concerned with finding relevant electronic documents based upon a query.
For example, given a group of and displays them sorted by relevance to the query.
This technology requires a way to compare a document with the query to see which is most relevant to the query.
A simple way to make this comparison is to compute the binary cosine coefficient.
The coefficient is a value between 0 and 1, where 1 indicates that the query is very similar to the document and 0 indicates that the query has no keywords in common with the document.
This approach treats each document as a set of words.
For example, given the following sample document: This document would be parsed into keywords where case is ignored and punctuation discarded and turned into the set containing the words {chocolate, ice, cream, milk, and, bars, are, delicious}.
An identical process is performed on the query to turn it into a set of strings.
Once we have a query Q represented as a set of words and a document D represented as a set of words, the similarity between Q and D is computed by: |Q ∩ D| = √|Q| √|D| Modify the StringSet from Programming Project 12 by adding an additional member function that computes the similarity between the current StringSet and an input parameter of type StringSet.
The sqrt function is in the cmath library.
Create two text files on your disk named Document1_0_txt and Document2.
Write some text content of your choice in each file, but make sure that each file contains different content.
Next, write a program that allows the user to input from the keyboard a set of strings that represents a query.
The program should then compare the query to both text files on the disk and output the similarity to each one using the binary cosine coefficient.
Test your program with different queries to see if the similarity metric is working correctly.
The class should have public member functions addEntry and deleteEntry.
Make the array and size variables private.
This will require Programming Projects 701 a­ dding functions for getting and setting specific items in the array as well as returning the current size of the array.
Add a destructor that frees up the memory allocated to the dynamic array.
Also, add a copy constructor and overload the assignment operator so that the dynamic array is properly copied from the object on the right-hand side of the assignment to the object on the left-hand side.
Embed your class in a suitable test program.
To combat election fraud, your city is instituting a new  procedure.
The ballot has a letter associated with every selection a voter may make.
A sample ballot is shown.
VOTE FOR MAYOR A.
Pincher, Penny B.
Dover, Skip C.
Perman, Sue 2.
PROPOSITION 17 D.
MEASURE 1 F.
MEASURE 2 H.
NO After submitting the ballot, every voter receives a receipt that has a unique ID number and a record of the  selections.
For example, a voter who submits a ballot for Sue Perman, Yes on Proposition 17, No on Measure 1, and Yes on Measure 2 might receive a receipt with ID 4925 : CDGH The next day the city posts all votes on its Web page sorted by ID number.
This allows a voter to confirm their submission and allows anyone to count the vote totals for themselves.
A sample list for the sample ballot is shown.
ADFH VideoNote Solution to Programming Project 11_0_12 702 Chapter 11 / Friends, Overloaded Operators, and Arrays in Classes Write a program that reads the posted  list from a file and outputs the percent of votes cast for each ballot item.
You may assume that the file does not have any header lines.
The first line will contain a voter ID and a string representing votes.
Define a class named Voter that stores an individual's  record.
The class should have a constructor that takes as input a string of votes (for example, "CDGH"), a voter ID, and accessor function(s) that return the person's ID and vote for a specific question.
Store each Voter instance in an array or vector.
Your program should iterate over the array to compute and output the percent of votes cast for each candidate, proposition, and measure.
It should then prompt the user to enter a voter ID, iterate over the list again to find the object with that ID, and print his or her votes.
All changes should be internal to the class so the main function to test the class should run identically with either the old  class or the new  class that uses an array member variable.
Next, modify the main function so that instead of creating separate variables for each  object, an array of at least four  objects is created with sample data.
Loop through the array and output the name, MPAA rating, and average rating for each of the four movies.
Do Programming Project 16 from Chapter 8 except use a Racer class to store information about each race participant.
The class should store the racer's name, bib number, finishing position, and all of his or her split times as recorded by the RFID sensors.
You can choose appropriate structures to store this information.
Include appropriate functions to access or change the racer's information, along with a constructor.
Make an array or vector of Racer objects to store the entire race results.
The racer's name should come from a separate text file.
The information for this file is collected before the race when the participant registers for the event.
Listed below is a sample file: 100,Bill Rodgers 132,Frank Shorter 182,Joan Benoit Separate Compilation and Namespaces 12_0_1 Separate Compilation 704 ADTs Reviewed 705 Case Study: DigitalTime—A Class Compiled Separately 706 Using #ifndef 715 Programming Tip: Defining Other Libraries 718 12_0_2 Namespaces  719 Namespaces and using Directives 719 Creating a Namespace 721 Chapter Summary 733 Answers to Self-Test Exercises 734 12 Qualifying Names 724 A Subtle Point About Namespaces (Optional ) 725 Unnamed Namespaces 726 Programming Tip: Choosing a Name for a Namespace 731 Pitfall: Confusing the Global Namespace and the Unnamed Namespace 732 Practice Programs 736 Programming Projects 738 From mine own library with volumes that I prize above my dukedom.
William Shakespeare, The Tempest Introduction This chapter covers two topics that have to do with how you organize a Cplus_plus program into separate parts.
Section 12_0_1 on separate compilation discusses how a Cplus_plus program can be distributed across a number of files so that when some parts of the program change, only those parts need to be recompiled.
The separate parts can also be more easily reused in other applications.
Section 12_0_2 discusses namespaces, which we introduced briefly in Chapter 2.
Namespaces are a way of allowing you to reuse the names of classes, functions, and other items by qualifying the names to indicate different uses.
Namespaces divide your code into sections so that the different sections may reuse the same names with differing meanings.
Namespaces allow a kind of local meaning for names that is more general than local variables.
Prerequisites This chapter uses material from Chapters 2 through 6 and 10 through 11.
You can place the definition for a class (and its associated function definitions) in files that are separate from the programs that use the class.
That way you can build up a library of classes so that many programs can use the same class.
You can compile the class once and then use it in many different programs, just like you use the predefined libraries (such as those with header files iostream and cstdlib).
Moreover, you can define the class itself in two files so that the specification of what the class does is separate from how the class is implemented.
If your class is defined following the guidelines we have been giving you and you change only the implementation of the class, then you need only recompile the file with the class implementation.
The other files, including the files with the programs that use the class, need not be changed or even recompiled.
In this section, we tell you how to carry out this separate compilation of classes.
All your class definitions should be ADTs.
In order to define a class so that it is an ADT, you need to separate the specification of how the class is used by a programmer from the details of how the class is implemented.
The separation should be so complete that you can change the implementation without needing to change any program that uses the class in any way.
The way to ensure this separation can be summarized in three rules: 1.
Make all the member variables private members of the class.
Make each of the basic operations for the ADT (the class) either a public member function of the class, a friend function, an ordinary function, or an overloaded operator.
Group the class definition and the function and operator declarations together.
This group, along with its accompanying comments, is called the interface for the ADT.
Fully specify how to use each such function or operator in a comment given with the class or with the function or operator declaration.
Make the implementation of the basic operations unavailable to the programmer who uses the abstract data type.
The implementation consists of the function definitions and overloaded operator definitions (along with any helping functions or other additional items these definitions require).
In Cplus_plus, the best way to ensure that you follow these rules is to place the interface and the implementation of the ADT class in separate files.
As you might guess, the file that contains the interface is often called the interface file, and the file that contains the implementation is called the implementation file.
The exact details of how to set up, compile, and use these files will vary slightly from one version of Cplus_plus to another, but the basic scheme is the same in all versions of Cplus_plus.
In particular, the details of what goes into the files are the same in all systems.
The only things that vary are what commands you use to compile and link these files.
The details about what goes into these files are illustrated in the next Case Study.
An ADT class has private member variables.
Private member variables (and private member functions) present a problem to our basic philosophy of placing the interface and the implementation of an ADT in separate files.
The public part of the class definition for an ADT is part of the interface for the ADT, but the private part is part of the implementation.
This is a problem because Cplus_plus will not allow you to split the class definition across two files.
Thus, some sort of compromise is needed.
The only sensible compromise, and the one we use, is to place the entire class definition in the interface file.
Since a programmer who is using the ADT class cannot use any of the private members of the class, the private members will, in effect, still be hidden from the programmer.
Private members are part of the implementation.
All the classes that you define should be ADTs.
An ADT class is a class that is defined following good programming practices that separate the interface and implementation of the class.
DigitalTime is a class whose values are times of day, such as 9:30.
Only the public members of the class are part of the interface.
The private members are part of the implementation, even though they are in the interface file.
The label private: warns you that these private members are not part of the public interface.
Everything that a programmer needs to know in order to use the ADT DigitalTime is explained in the comment at the start of the file and in the comments in the public section of the class definition.
This interface tells the programmer how to use the two versions of the member function named advance, the constructors, and the overloaded  =, >>, and <<.
The member function named advance, the overloaded , and the assignment statement are the only ways that a programmer can manipulate objects and values of this class.
As noted in the comment at the top of the interface file, this ADT class uses 24-hour notation, so, for instance, 1:30 PM is input and output as 13:30.
This and the other details you must know in order to effectively use the class DigitalTime are included in the comments given with the member functions.
We have placed the interface in a file named dtime_0_h_0_The suffix _0_h indicates that this is a header file.
An interface file is always a header file and therefore always ends with the suffix _0_h.
Any program that uses the class DigitalTime must contain an include directive like the following, which names this file: When you write an include directive, you must indicate whether the header file is a predefined header file that is provided for you or is a header file that you wrote.
If the header file is predefined, write the header file name in angular brackets, like <iostream>.
If the header file is one that you wrote, then write the header file name in quotes, like "dtime_0_h".
This distinction tells the compiler where to look for the header file.
If the header file name is 12_0_1 Separate Compilation 707 Display 12_0_1   Interface File for DigitalTime 1 2 3 4 5 6 7 8 9 10 11 //Header file dtime_0_h: This is the INTERFACE for the class DigitalTime.
The values are input and output in.
If the header file name is in quotes, the compiler looks in the current directory or wherever programmer-defined header files are kept on your system.
Any program that uses our DigitalTime class must contain the previous directive that names the header file dtime_0_h.
That is enough to 708 Chapter 12 / Separate Compilation  Namespaces allow you to compile the program but is not enough to allow you to run the program.
In order to run the program, you must write ( compile) the definitions of the member functions  the overloaded.
We have placed these function   definitions in another file, which is called the implementation file.
Although it is not required by most compilers, it is traditional to give the interface file  the implementation file the same name.
The two files do, however, end in different suffixes.
We have placed the interface for our ADT class in the file named dtime_0_h  the implementation for our ADT class in a file named dtime_0_cpp.
The suffix you use for the implementation file depends on your version of Cplus_plus.
Use the same suffix for the implementation file as you normally use for files that contain Cplus_plus programs.
If your program files end in _0_cxx, then you would use _0_cxx in place of _0_cpp.
If your program files end in _0_CPP, then your implementation files will end in _0_CPP instead of _0_cpp.
We are using _0_cpp since most compilers accept _0_cpp as the suffix for a Cplus_plus source code file.
The implementation file for our DigitalTime ADT class is given in Display 12_0_2.
After we explain how the various files for our ADT interact with each other, we will return to Display 12_0_2  discuss the details of the definitions in this implementation file.
In order to use the ADT class DigitalTime in a program, the program must contain the  directive Compiling running the program Notice that both the implementation file  the program file must contain this  directive that names the interface file.
The file that contains the program (that is, the file that contains the main part of the program) is often called the application file or driver file.
Display 12_0_3 contains an application file with a very simple program that uses  demonstrates the DigitalTime ADT class.
The exact details on how you run this complete program, which is contained in three files, depend on what system you are using.
However, the basic details are the same for all systems.
You must compile the implementation file,  you must compile the application file that contains the main part of your program.
You do not compile the interface file, which in this example is the file dtime_0_h given in Display 12_0_1.
You do not need to compile the interface file because the compiler thinks the contents of this interface file are already contained in each of the other two files.
Recall that both the implementation file  the application file contain the directive Compiling your program automatically invokes a preprocessor that reads this  directive  replaces it with the text in the file dtime_0_h.
Thus, the compiler sees the contents of dtime_0_h,  so the file dtime_0_h does not need to be compiled separately.
Chapter 12 / Separate Compilation and Namespaces 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89.
Chapter 12 / Separate Compilation and Namespaces Display 12_0_3   Application File Using DigitalTime 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 //Application file timedemo_0_cpp (your system may require some suffix.
Sample Dialogue Enter the time in 24- notation: 11:15 You  11:15 15 minutes later the time will be 11:30 2 hours and 15 minutes after that the time will be 13:45 only a conceptual copying.
The compiler acts as if the contents of dtime_0_h were copied into each file that has the  directive.
However, if you look in that file after it is compiled, you will only find the  directive; you will not find the contents of the file dtime_0_h.
Once the implementation file and the application file are compiled, you still need to connect these files so that they can work together.
This is called 12_0_1 Separate Compilation linking the files and is done by a separate utility called a linker.
The details for how you call the linker depend on what system you are using.
After the files are linked, you can run your program.
On any system, the details quickly become routine.
Displays 12_0_1, 12_0_2, and 12_0_3 contain one complete program divided into pieces and placed in three different files.
You could instead combine the contents of these three files into one file and then compile and run this one file without all this fuss about  directives and linking separate files.
Why bother with three separate files.
There are several advantages to dividing your program into separate files.
Since you have the definition and the implementation of the class DigitalTime in files separate from the application file, you can use this class in many different programs without needing to rewrite the definition of the class in each of the programs.
Moreover, you need to compile the implementation file only once, no matter how many programs use the class DigitalTime.
Since you have separated the interface from the implementation of your DigitalTime ADT class, you can change the implementation file and will not need to change any program that uses the ADT.
In fact, you will not even need to recompile the program.
If you change the implementation file, you only need to recompile the implementation file and to relink the files.
Saving a bit of recompiling time is nice, but the big advantage is not having to rewrite code.
You can use the ADT class  many programs without writing the class code into each program.
You can change the implementation of the ADT class and you need not rewrite any part of any program that uses the class.
Defining a Class  Separate Files: A Summary You can define a class and place the definition of the class and the implementation of its member functions  separate files.
You can then compile the class separately from any program that uses the class, and you can use this same class  any number of different programs.
The class and the program that uses the class are placed  three files as follows: 1.
Put the definition of the class  a header file called the interface file.
The name of this header file ends  _0_h.
The interface file also contains the declarations for any functions and overloaded operators that define basic operations for the class but that are not listed  the class definition.
Include comments that explain how all these functions and operators are used.
Why separate files.
Chapter 12 / Separate Compilation and Namespaces 2.
The definitions of all the functions and overloaded operators mentioned step 1 (whether they are members or friends or neither) are placed  another file called the implementation file.
This file must contain an  directive that names the interface file described above.
This  directive uses quotes around the file name, as  the following example: The interface file and the implementation file traditionally have the same name, but end  different suffixes.
The interface file ends  _0_h.
The implementation file ends  the same suffix that you use for files that contain a complete Cplus_plus program.
The implementation file is compiled separately before it is used  any program.
When you want to use the class  a program, place the main part of the program (and any additional function definitions, constant declarations, and so on)  another file called an application file.
This file also must contain an directive naming the interface file, as  the following example: The application file is compiled separately from the implementation file.
You can write any number of these application files to use with one pair of interface and implementation files.
To run an entire program, you must first link the object code that is produced by compiling the application file and the object code that is produced by compiling the implementation file.
Most of the implementation details are straightforward, but there are two things that merit comment.
Notice that the member function name advance is overloaded so that it has two function definitions.
Also notice that the definition for the overloaded extraction (input) operator >> uses two "helping functions" called read_hour and read_minute and these two helping functions themselves use a third helping function called digit_ to_int.
Let's discuss these points.
The class DigitalTime (Displays 12_0_1 and 12_0_2) has two member functions called advance.
One version takes a single argument, which is an integer giving the number of minutes to advance the time.
The other version takes two arguments, one for a number of hours and one for a number of minutes, and advances the time by that number of hours plus that number of minutes.
Notice that the definition of the two-argument version of advance includes a call to the one-argument version of advance.
Look at the definition of the two-argument version that is given  Display 12_0_2.
First the time is 12_0_1 Separate Compilation advanced by hours_added hours, and then the single-argument version of advance is used to advance the time by an additional minutes_added minutes.
At first this may seem strange, but it is perfectly legal.
The two functions named advance are two different functions that, as far as the compiler is concerned, coincidentally happen to have the same name.
The situation is no different  this regard than it would be if one of the two versions of the overloaded function advance had been called another_advance.
Now let's discuss the helping functions.
The helping functions read_hour and read_minute read the input one character at a time and then convert the input to integer values that are placed  the member variables hour and minute.
The functions read_hour and read_minute read the hour and minute one digit at a time, so they are reading values of type char.
This is more complicated than reading the input as int values, but it allows us to perform error checking to see whether the input is correctly formed and to issue an error message if the input is not well formed.
These helping functions read_ hour and read_minute use another helping function named digit_to_int, which is the same as the digit_to_int function we used  our definition of the class Money  Displays 11_0_3.
The function digit_to_int converts a digit, such as '3', to a number, such as 3.
Reusable Components An ADT class developed and coded into separate files is a software component that can be used again and again  a number of different programs.
Reusability, such as the reusability of these ADT classes, is an important goal to strive for when designing software components.
A reusable component saves effort because it does not need to be redesigned, recoded, and retested for every application.
A reusable component is also likely to be more reliable than a component that is used only once—for two reasons.
First, you can afford to spend more time and effort on a component if it will be used many times.
Second, if the component is used again and again, it is tested again and again.
Every use of a software component is a test of that component.
Using a software component many times  a variety of contexts is one of the best ways to discover any remaining bugs  the software.
Using #ifndef We have given you a method for placing a program  three files: two for the interface and implementation of a class, and one for the application part of the program.
A program can be kept in more than three files.
For example, a program might use several classes, and each class might be kept in a separate pair of files.
VideoNote Avoiding Multiple Definitions 715.
Chapter 12 / Separate Compilation and Namespaces.
This can easily lead to a situation in which a file, in effect, contains the definitions in dtime_0_h more than once.
Cplus_plus does not allow you to define a class more than once, even if the repeated definitions are identical.
Moreover, if you are using the same header file in many different projects, it becomes close to impossible to keep track of whether you included the class definition more than once.
To avoid this problem, Cplus_plus provides a way of marking a section of code to say "if you have already included this stuff once before, do not include it again_0_" The way this is done is quite intuitive, although the notation may look a bit weird until you get used to it.
We will go through an example, explaining the details as we go.
The following directive "defines" DTIME_H: #define DTIME_H What this means is that the compiler's preprocessor puts DTIME_H on a list to indicate that DTIME_H has been seen.
Defines is perhaps not the best word for this, since DTIME_H is not defined to mean anything but is merely put on a list.
The important point is that you can use another directive to test whether or not DTIME_H has been defined and so test whether or not a section of code has already been processed.
You can use any (nonkeyword) identifier in place of DTIME_H, but you will see that there are standard conventions for which identifier you should use.
The following directive tests to see whether or not DTIME_H has been defined: #ifndef DTIME_H If DTIME_H has already been defined, then everything between this directive and the first occurrence of the following directive is skipped: #endif (An equivalent way to state this, which may clarify the way the directives are spelled, is the following: If DTIME_H is not defined, then the compiler processes everything up to the next #endif.
This may lead you to wonder whether there is a #ifdef directive as well as a #ifndef directive.
There is, and it has the obvious meaning, but we will have no occasion to use #ifdef.
Now consider the following code: #ifndef DTIME_H #define DTIME_H <a class definition> #endif 12_0_1 Separate Compilation 717.
When the include directive is processed this second time, the directive #ifndef DTIME_H says to skip everything up to #endif and so the class is not defined again.
In Display 12_0_4 we have rewritten the header file dtime_0_h shown in Display 12_0_1, but this time we used these directives to prevent multiple definitions.
With the version of dtime_0_h shown in Display 12_0_4, if a file contains the following include directive more than once, the class DigitalTime will still be defined only once: Display 12_0_4   Avoiding Multiple Definitions of a Class 1 2 3 //Header file dtime_0_h: This is the INTERFACE for the class DigitalTime.
The values are input and output in //24-hour notation, as in 9:30 for 9:30 AM and 14:45 for 2:45 PM.
Chapter 12 / Separate Compilation and Namespaces You may use some other identifier in place of DTIME_H, but the normal convention is to use the name of the file written in all uppercase letters with the underscore used in place of the period.
You should follow this convention so that others can more easily read your code and so that you do not have to remember the flag name.
This way the flag name is determined automatically and there is nothing arbitrary to remember.
These same directives can be used to skip over code in files other than header files, but we will not have occasion to use these directives except in header files.
If you have a collection of related functions that you want to make into a library of your own design, you can place the function declarations and accompanying comments in a header file and the function definitions in an implementation file, just as we outlined for ADT classes.
After that, you can use this library in your programs the same way you would use a class that you placed in separate files.
Suppose that you are defining an ADT class and that you then use this class in a program.
You want to separate the class and program parts into separate files as described in this chapter.
Specify whether each of the following should be placed in the interface file, implementation file, or application file: a.
The class definition b_0_	The declaration for a function that is to serve as an ADT operation, but that is neither a member nor a friend of the class c_0_	The declaration for an overloaded operator that is to serve as an ADT operation, but that is neither a member nor a friend of the class d_0_	The definition for a function that is to serve as an ADT operation, but that is neither a member nor a friend of the class e_0_	The definition for a friend function that is to serve as an ADT operation f.
The definition for a member function g_0_	The definition for an overloaded operator that is to serve as an ADT operation, but that is neither a member nor a friend of the class h_0_	The definition for an overloaded operator that is to serve as an ADT operation and that is a friend of the class i.
The main part of your program 12_0_2 Namespaces 2.
Which of the following files has a name that ends in _0_h: the interface file for a class, the implementation file for the class, or the application file that uses the class.
When you define a class in separate files, there is an interface file and an file.
Which of these files needs to be compiled.
Suppose you define a class in separate files and use the class in a program.
Now suppose you change the class  file.
Which of the following files, if any, need to be recompiled: the interface file, the file, or the application file.
Suppose you want to change the  of the class DigitalTime given in Displays 12_0_1 and 12_0_2.
Specifically, you want to change the way the time is recorded.
Instead of using the two private variables hour and minute, you want to use a single (private) int variable, which will be called minutes.
In this new , the private variable minutes will record the time as the number of minutes since the time 0:00 (that is, since midnight).
So 1:30 is recorded as 90 minutes, since it is 90 minutes past midnight.
Describe how you need to change the interface and  files shown in Displays 12_0_1 and 12_0_2.
You need not write out the files in their entirety; just indicate what items you need to change and how, in a very general way, you would change them.
What is the difference between an ADT you define in Cplus_plus and a class you define in Cplus_plus.
That which we call a rose By any other name would smell as sweet.
William Shakespeare, Romeo and Juliet When a program uses different classes and functions written by different programmers, there is a possibility that two programmers will use the same name for two different things.
Namespaces are a way to deal with this problem.
A namespace is a collection of name definitions, such as class definitions and variable declarations.
Namespaces and using Directives We have already been using the namespace that is named std.
The std namespace contains all the names defined in the standard library files (such 719.
Chapter 12 / Separate Compilation and Namespaces.
Your program does not know about names in the std namespace unless you specify that it is using the std namespace.
So far, the only way we know how to specify the std namespace (or any namespace) is with the following sort of using directive: using namespace std; A good way to see why you might want to  this using directive is to think about why you might want to not  it.
If you do not  this using directive for the namespace std, then you can define cin and cout to have some meaning other than their standard meaning.
Every bit of code you write is in some namespace.
If you do not place the code in some specific namespace, then the code is in a namespace known as the global namespace.
So far, we have not placed any code we wrote in any namespace, so all of our code has been in the global namespace.
The global namespace does not have a using directive because you are always using the global namespace.
You could say that there is always an implicit automatic using directive that says you are using the global namespace.
Note that you can be using more than one namespace at the same time.
For example, we are always using the global namespace and we are usually using the std namespace.
What happens if a name is defined in two namespaces and you are using both namespaces.
This results in an error (either a compiler error or a run-time error, depending on the exact details).
You can have the same name defined in two different namespaces, but if that is true, then you can only use one of those namespaces at a time_0_1 However, this does not mean you cannot use the two namespaces in the same program.
You can use them each at different times in the same program.
For example, suppose ns1 and ns2 are two namespaces, and suppose my_function is a void function with no arguments that is defined in both namespaces but defined in different ways in the two namespaces.
The following is then legal: 1 As you will see later in this chapter, there are ways to use two namespaces at the same time even if they contain the same name, but that is a subtle point that does not yet concern us.
The first invocation would use the definition of my_function given in the namespace ns1, and the second invocation would use the definition of my_ function given in the namespace ns2.
Recall that a block is a list of statements, declarations, and possibly other code, enclosed in braces {}.
A using directive at the start of a block applies only to that block.
So the first using directive applies only in the first block, and the second using directive applies only in the second block.
The usual way of phrasing this is to say that the scope of the ns1 namespace is the first block, while the scope of the ns2 namespace is the second block.
Note that because of this scope rule, we are able to use two conflicting namespaces in the same program (such as in a program that contains the two blocks we discussed in the previous paragraph).
When you use a using directive in a block, it is typically the block consisting of the body of a function definition.
If you place a using directive at the start of a file (as we have usually done so far), then the using directive applies to the entire file.
A using directive should normally be placed near the start of a file or the start of a block.
Scope Rule for using Directives The scope of a using directive is the block in which it appears (more precisely, from the location of the using directives to the end of the block).
If the using directive is outside of all blocks, then it applies to all of the file that follows the using directive.
Creating a Namespace In order to place some code in a namespace, you simply place it in a namespace grouping of the following form: namespace Name_Space_Name { Some_Code }.
When you  one of these groupings in your code, you are said to place.
Chapter 12 / Separate Compilation and Namespaces.
If you look again at Display 12_0_5, you see that the definition of the function greeting is also placed in namespace savitch1.
That is done with the following additional namespace grouping: namespace savitch1.
Note that you can have any number of these namespace groupings for a single namespace.
In Display 12_0_5, we used two namespace groupings for namespace savitch1 and two other groupings for namespace savitch2.
Every name defined in a namespace is available inside the namespace grouping, but the names can be also be made available to code outside of the namespace.
That function declaration and function definition in the namespace savitch1 can be made available with the using directive: using namespace savitch1 as illustrated in Display 12_0_5.
Names in this block use definitions in namespaces savitch2, std, and the global namespace.
Names in this block use definitions in namespaces savitch1, std, and the global namespace.
Names out here use only definitions in namespace std and the global namespace.
Sample Dialogue Greetings from namespace savitch2.
Hello from namespace savitch1.
A Big Global Hello.
Chapter 12 / Separate Compilation and Namespaces Sel f -T es t Exe r cis e s 7.
Consider the program shown in Display 12_0_5.
Could we use the name greeting in place of big_greeting.
In Self-Test Exercise 7, we saw that you could not add a definition for the following function (to the global namespace): void greeting( );.
Can a namespace have more than one namespace grouping.
Qualifying Names Suppose you are faced with the following situation: You have two namespaces, ns1 and ns2.
You want to use the function fun1 defined in ns1 and the function fun2 defined in namespace ns2.
The complication is that both ns1 and ns2 define a function my_function.
What you need is a way to say you are using fun1 in namespace ns1 and fun2 in namespace ns2 and nothing else in the namespaces ns1 and ns2.
The following are called using declarations, and they are your answer: using ns1::fun1; using ns2::fun2;.
Note that you have seen the scope resolution operator, ::, before.
For example, in Display 12_0_2 we had the following function definition:.
In this case the :: means that we are defining the function advance for the class DigitalTime, as opposed to any other function named advance in any other class.
Similarly, using ns1::fun1; means we are using the function named fun1 as defined in the namespace ns1, as opposed to any other definition of fun1 in any other namespace.
Now suppose that you intend to use the name fun1 as defined in the namespace ns1, but you intend to use it only one time (or a small number of times).
You can then name the function (or other item) using the name of the namespace and the scope resolution operator as in the following: ns1::fun1( ); This form is often used when specifying a parameter type.
In the function get_number, the parameter input_stream is of type istream, where istream is defined as in the std namespace.
If this use of the type name istream is the only name you need from the std namespace (or if all the names you need are similarly qualified with std::), then you do not need using namespace std;.
The differences are as follows: 1_0_	A using declaration (like using std::;) makes only one name in the namespace available to your code, while a using directive (like using namespace std;) makes all the names in a namespace available.
However, a using directive only potentially introduces the names in the namespace.
Point 1 is pretty obvious.
Point 2 has some subtleties.
For example, suppose the namespaces ns1 and ns2 both provide definitions for my_function but have no other name conflicts.
Then the following will produce no problems: 725.
Sel f -T es t Exe r cis e s 10.
Write the function declaration for a void function named wow.
The function wow has two parameters, the first of type speed as defined in the speedway namespace and the second of type speed as defined in the indy500 namespace.
Consider the following function declarations from the definition of the class Money in Display 11_0_4.
Unnamed Namespaces Our definition of the class DigitalTime in Displays 12_0_1 and 12_0_2 used three helping functions: digit_to_int, read_hour, and read_minute.
These helping functions are part of the implementation for the ADT class DigitalTime, so we placed their definitions in the implementation file (Display 12_0_2).
However, this does not really hide these three functions.
We would like these functions to be local to the implementation file for the class DigitalTime.
In particular, we cannot define another function with the name digit_to_int (or read_hour or read_minute) in an application program that uses the class DigitalTime.
This violates the principle of information hiding.
To truly hide these helping functions and make them local to the implementation file for DigitalTime, we need to place them in a special namespace called the unnamed namespace.
Every compilation unit has an unnamed namespace.
A namespace grouping for the unnamed namespace is written in the same way as any other namespace, but no name is given, as in the following example: namespace {.
For example, Displays 12_0_6 and 12_0_7 show a rewritten (and our final) version of the interface and implementation file for the class DigitalTime.
Note that the helping functions (read_hour, read_ minute, and digit_to_int) are all  the unnamed namespace and therefore are local to the compilation unit.
As illustrated  Display 12_0_8, the names the unnamed namespace can be reused for something else outside the compilation unit.
In Display 12_0_8 the function name read_hour is reused for another different function  the application program.
Display 12_0_6   Placing a Class  a Namespace—Header File 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //Header file dtime_0_h: This is the interface for the class DigitalTime.
The values are input and output //24-hour notation, as  9:30 for 9:30 AM and 14:45 for 2:45 PM.
Another grouping for the namespace dtimesavitch is  the implementation file dtime_0_cpp.
Chapter 12 / Separate Compilation and Namespaces 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 //Implementation file dtime_0_cpp (your system may require some.
If you look again at the implementation file  Display 12_0_8, you will see that the helping functions digit_to_int, read_hour, and read_minute are used outside the unnamed namespace without any namespace qualifier.
Any name defined  the unnamed namespace can be used without qualification anywhere  the compilation unit.
There is one unnamed namespace  each compilation unit.
It is easily possible for compilation units to overlap.
For example, both the implementation file for a class and an application program using the class would normally the header file (interface file) for the class.
Thus, the header file is  two compilation units and hence participates  two unnamed namespaces.
As dangerous as this sounds, it will normally produce no problems as long as each compilation unit's namespace makes sense when considered by itself.
For example, if a name is defined  the unnamed namespace  the header file, it cannot be defined again  the unnamed namespace  either the implementation file or the application file.
So, a name conflict is avoided.
This is a different function read_hour than the one  the implementation file dtime_0_cpp (shown  Display 12_0_7 ).
Let's pretend the hour has just changed.
You may write midnight as either 0 or 24, but I will always write it as 0.
Enter the hour as a number (0 to 24): 11 You  11:00 15 minutes later the time will be 11:15 2 hours and 15 minutes after that the time will be 13:30 ■ Programming Tip Choosing a Name for a Namespace It is a good idea to  your last name or some other unique string  the names of your namespaces so as to reduce the chance that somebody else will use the same namespace name as you do.
With multiple programmers writing code for the same project, it is important that namespaces that are meant to be distinct really do have distinct names.
Otherwise, you can easily have multiple definitions of the same names  the same scope.
That is why we included the name savitch  the namespace dtimesavitch  Display 12_0_7.
Each compilation unit has one unnamed namespace.
All the identifiers defined  the unnamed namespace are local to the compilation unit.
You place a definition  the unnamed namespace by placing it  a namespace grouping with no namespace name, as shown  the following: namespace { Definition_1 Definition_2.
Definition_Last } You can use any name  the unnamed namespace without a qualifier anyplace.
Pitfall  onfusing the Global Namespace and C the Unnamed Namespace Do not confuse the global namespace with the unnamed namespace.
If you do not put a name definition  a namespace grouping, then it is  the global namespace.
To put a name definition  the unnamed namespace, you must put it  a namespace grouping that starts as follows, without a name: namespace { Both names  the global namespace and names  the unnamed namespace may be accessed without a qualifier.
However, names  the global namespace have global scope (all the program files), while names  an unnamed namespace are local to a compilation unit.
This confusion between the global namespace and the unnamed namespace does not arise very much  writing code, since there is a tendency to think of names  the global namespace as being " no namespace," even though that is not technically correct.
However, the confusion can easily arise when discussing code.
Would the program  Display 12_0_8 behave any differently if you replaced the using directive using namespace dtimesavitch;.
In Display 12_0_7 there are two groupings for the unnamed namespace: one for the helping function declarations and one for the helping function definitions.
Can we eliminate the grouping for the helping function declarations.
Chapter Summary ■ In Cplus_plus, abstract data types (ADTs) are implemented as classes with all member variables private and with the operations implemented as public member and nonmember functions and overloaded operators.
You can then compile the ADT class separately from any program that uses it and you can use this same ADT class  any number of different programs.
Chapter 12 / Separate Compilation and Namespaces Answe rs to Self -T est Exer cises 1_0_	Parts (a), (b), and (c) go in the interface file; parts (d) through (h) go in the implementation file.
The name of the interface file ends in _0_h.
Only the implementation file needs to be compiled.
The interface file does not need to be compiled.
Only the implementation file needs to be recompiled.
You do, however, need to relink the files.
You need to delete the private member variables hour and minute from the interface file shown in Display 12_0_1 and replace them with the member variable minutes (with an s).
You do not need to make any other changes in the interface file.
In the implementation file, you need to change the definitions of all the constructors and other member functions, as well as the definitions of the overloaded operators, so that they work for this new way of recording time.
You need not change any application files for programs that use the class.
However, since the interface file is changed (as well as the implementation file), you will need to recompile any application files, and of course you will need to recompile the implementation file.
The short answer is that an ADT is simply a class that you defined following good programming practices of separating the interface from the implementation.
Also, when we describe a class as an ADT, we consider the nonmember basic operations such as overloaded operators to be part of the ADT, even though they are not technically speaking part of the Cplus_plus class.
Answers to Self-Test Exercises 7.
If you replace big_greeting with greeting, then you will have a definition for the name greeting in the global namespace.
There are parts of the program where all the name definitions in the namespace savitch1 and all the name definitions in the global namespace are simultaneously available.
In those parts of the program, there would be two distinct definitions for void greeting( ); 8.
Yes, the additional definition would cause no problems.
This is because overloading is always allowed.
When, for example, the namespaces savitch1 and the global namespace are available, the function name greeting would be overloaded.
The problem in Self-Test Exercise 7 was that there would sometimes be two definitions of the function name greeting with the same parameter lists.
Yes, a namespace can have any number of groupings.
For example, the following are two groupings for the namespace savitch1 that appear in Display 12_0_5: namespace savitch1 {.
The program would behave exactly the same.
Hello from unnamed.
Hello from Sally.
Hello from unnamed.
Yes, you can eliminate the grouping for the helping function declarations, as long as the grouping with the helping function definitions occurs before the helping functions are used.
For example, you could remove the namespace with the helping function declarations and move the grouping with the helping function definitions to just before the namespace grouping for the namespace dtimesavitch.
Chapter 12 / Separate Compilation and Namespaces PrACTICE ProGRAMS Practice Programs can generally be solved with a short program that directly applies the programming principles presented in this chapter.
One of the values of type DigitalTime is the object that calls the member function interval_since, and the other value of type DigitalTime is given as the first argument.
For example, consider the following code: DigitalTime current(5, 45), previous(2, 30); int hours, ; current_0_interval_since(previous, hours, );.
Allow the time given by the first argument to be later in the day than the time of the calling object.
In this case, the time given as the first argument is assumed to be on the previous day.
You should also write a program to test this revised ADT class.
Do Self-Test Exercise 5 in full detail.
Write out the complete ADT class, including interface and implementation files.
Also write a program to test your ADT class.
VideoNote Solution to Practice Program 12_0_3 3_0_	Redo Practice Programs 1 from Chapter 11, but this time define the Money ADT class in separate files for the interface and implementation so that the implementation can be compiled separately from any application ­program.
Practice Programs 5.
This Practice Program explores how the unnamed namespace works.
Listed below are snippets from a program to perform input validation for a username and password.
The code to input and validate the username is in a file separate from the code to input and validate the password.
File user_0_cpp: namespace Authenticate {.
Define the username variable and the isValid() function in the unnamed namespace so the code will compile.
The isValid() function should return true if username contains exactly eight letters.
Generate an appropriate header file for this code.
Repeat the same steps for the file password_0_cpp, placing the password variable and the isValid() function in the unnamed namespace.
In this case, the isValid() function should return true if the input password has at least eight characters including at least one : File password_0_cpp: namespace Authenticate {.
Chapter 12 / Separate Compilation and Namespaces At this point you should have two functions named isValid(), each in different unnamed namespaces.
Place the following main function in an.
Test the program with several invalid usernames and passwords.
Programming Projects Programming Projects require more problem-solving than Practice Programs and can usually be solved many different ways.
Visit www_0_myprogramminglab_0_com to complete many of these Programming Projects online and get instant feedback.
Define your ADT class in separate files so that it can be compiled separately.
Define your ADT class in separate files so that it can be compiled separately.
Define your ADT class in separate files so that it can be compiled separately.
Put the main function in its own file separate from the ADT files.
Pointers and Linked Lists 13 13_0_1 Nodes and Linked Lists 740 Nodes 740 nullptr 745 Linked Lists 746 Inserting a Node at the Head of a List 747 Pitfall: Losing Nodes 750 Searching a Linked List 751 Pointers as Iterators 755 Inserting and Removing Nodes Inside a List 755 Pitfall: Using the Assignment Operator with Dynamic Data Structures 757 Variations on Linked Lists 760 Linked Lists of Classes 762 Chapter Summary 776 Answers to Self-Test Exercises Practice Programs 779 Programming Projects 780 776 13_0_2 Stacks and Queues 765 Stacks 765 Programming Examples: A Stack  766 Queues 771 Programming Examples: A Queue  772 If somebody there chanced to be Who loved me in a manner true My heart would point him out to me And I would point him out to you.
Gilbert and Sullivan, Ruddigore Introduction A linked list  a list constructed using pointers.
A linked list  not fixed in size, but can grow and shrink while your program  running.
This chapter shows you how to define and manipulate linked lists, which will serve to introduce you to a new  of using pointers.
Prerequisites This chapter uses material from Chapters 2 through 12.
You saw that dynamic variables of an array type can be useful.
Dynamic variables of a struct or class type can also be useful, but in a different.
Dynamic variables that are either structs or classes normally have one or more member variables that are pointer variables which connect them to other dynamic variables.
For example, one such structure, which happens to contain a shopping list,  diagrammed in Display 13_0_1.
Nodes A structure like the one shown in Display 13_0_1 consists of items that we have drawn as boxes connected by arrows.
The boxes are called nodes and the arrows represent pointers.
Each of the nodes in Display 13_0_1 contains a string, an integer, and a pointer that can point to other nodes of the same type.
Note that pointers point to the entire node, not to the individual items (such as 10 or "rolls") that are inside the node.
Nodes are implemented in Cplus_plus as structs or classes.
For example, the struct type definitions for a node of the type shown in Display 13_0_1, along with the type definition for a pointer to such nodes, can be as follows: struct ListNode {.
The order of the type definitions  important.
The definition of ListNode must come first, since it  used in the definition of ListNodePtr.
The box labeled head in Display 13_0_1  not a node, but  a pointer variable that can point to a node.
The pointer variable head  declared as follows: ListNodePtr head; Even though we have ordered the type definitions to avoid some illegal forms of circularity, the definition of the struct type ListNode  still blatantly circular.
The definition uses the type name ListNode to define the member variable link.
There  nothing wrong with this particular circularity, and it  allowed in Cplus_plus.
One indication that this definition  not logically inconsistent  the fact that you can draw pictures, like Display 13_0_1, that represent such structures.
We now have pointers inside of structs and have these pointers pointing to structs that contain pointers, and so forth.
In such situations the syntax can sometimes get involved, but in all cases the syntax follows those few rules we have described for pointers and structs.
As an illustration, suppose the declarations are as above, the situation is as 741.
Chapter 13 / Pointers and Linked Lists diagrammed in Display 13_0_1, and you want to change the number in the first node from 10 to 12.
One  to accomplish this is with the following statement: (*head).
The variable head is a pointer variable.
So, the expression containing "rolls" and the integer 10.
This node, referred to by *head, is a struct, and the member variable of this struct, which contains a value of type int, is called , and so (*head).
The parentheses around *head are not optional.
You want the dereferencing operator * to be performed before the dot operator.
However, the dot operator has higher precedence than the dereferencing operator *, and so without the parentheses, the dot operator would be performed first (and that would produce an error).
In the next paragraph, we will describe a shortcut notation that can avoid this worry about parentheses.
Cplus_plus has an operator that can be used with a pointer to simplify the notation for specifying the members of a struct or a class.
The arrow operator arrow_operator combines the actions of a dereferencing operator * and a dot operator to specify a member of a dynamic struct or object that is pointed to by a given pointer.
For example, the assignment statement above for changing the number in the first node can be written more simply as = 12; This assignment statement and the previous one mean the same thing, but this one is the form normally used.
Look at the pointer member in the last node in the lists shown in Display 13_0_2.
This last node has the word NULL written where there should be a pointer.
In Display 13_0_1 we filled this position with the phrase "end marker," but "end marker" is not a Cplus_plus expression.
In Cplus_plus programs we use the constant NULL as an end marker to signal the end of a linked list.
NULL is a special defined constant that is part of the Cplus_plus language (provided as part of the required Cplus_plus libraries).
NULL is typically used for two different (but often coinciding) purposes.
It is used to give a value to a pointer variable that otherwise would not have any value.
This prevents an inadvertent reference to memory, since NULL is not 13_0_1 Nodes and Linked Lists.
NULL the address of any memory location.
The second category of use is that of an end marker.
A program can step through the list of nodes as shown in Display 13_0_2, and when the program reaches the node that contains NULL, it knows that it has come to the end of the list.
The constant NULL is actually the number 0, but we prefer to think of it and spell it as NULL.
That makes it clear that you mean this specialpurpose value that you can assign to pointer variables.
The definition of the identifier NULL is in a number of the standard libraries, such as <iostream> and <cstddef>, so you should use an include directive with either <iostream> or <cstddef> (or other suitable library) when you use NULL.
No using directive is needed in order to make NULL available to your program code.
In particular, it does not require using namespace std;, although other things in your code are likely to require something like using namespace std;_0_1 The details are as follows: The definition of NULL is handled by the Cplus_plus preprocessor, which replaces NULL with 0.
Thus, the compiler never actually sees "NULL" and so there are no namespace issues, and no using directive is needed.
Chapter 13 / Pointers and Linked Lists The Arrow Operator arrow_operator The arrow operator arrow_operator specifies a member of a struct (or a member of a class object) that is pointed to by a pointer variable.
The syntax is as follows: Pointer_Variablearrow_operatorMember_Name The above refers to a member of the struct or object pointed to by the Pointer_Variable.
Which member it refers to is given by the Member_Name.
For example, suppose you have the following definition:.
NULL: double * = NULL; The constant NULL can be assigned to a pointer variable of any pointer type.
NULL NULL is a special constant value that is used to give a value to a pointer variable that would not otherwise have a value.
NULL can be assigned to a pointer variable of any type.
The identifier NULL is defined in a number of libraries, including the library with header file <cstddef> and the library with header file <iostream>.
The constant NULL is actually the number 0, but we prefer to think of it and spell it as NULL.
Since NULL is the number 0, both are equally valid.
Cplus_plus11 resolves this problem by introducing a new , nullptr.
Use nullptr anywhere you would have used NULL for a pointer.
For example, we can write: double * = nullptr; nullptr nullptr is a special  value that is used the same way as NULL, but it can only be assigned to a pointer.
Use nullptr to differentiate between a null pointer and the number 0.
S el f-T est Exerc ise s 1.
Suppose your program contains the following type definitions:.
Chapter 13 / Pointers and Linked Lists 2.
Suppose that your program contains the type definitions and code given in Self-Test Exercise 1.
That code creates a node that contains the string "Sally" and the  18.
What code would you add in order to set the value of the member variable next of this node equal to NULL.
Suppose that your program contains the type definitions and code given in Self-Test Exercise 1.
Assuming that the value of the pointer variable has not been changed, how can you destroy the  variable pointed to by  and return the memory it uses to the freestore so that it can be reused to create new  variables.
Given the following structure definition: struct.
Linked Lists Lists such as those shown in Display 13_0_2 are called linked lists.
A linked list is a list of nodes in which each node has a member variable that is a pointer that points to the next node in the list.
The first node in a linked list is called the , which is why the pointer variable that points to the first node is named.
Note that the pointer named  is not itself the  of the list but only points to the  of the list.
The last node has no special , but it does have a special property.
The last node has NULL as the value of its member pointer variable.
To test to see whether a node is the last node, you need only test to see if the pointer variable in the node is equal to NULL.
Our goal in this section is to write some basic functions for manipulating linked lists.
For variety, and to simplify the notation, we will use a simpler type of node than that used in Display 13_0_2.
These nodes will contain only an integer and a pointer.
The node and pointer type definitions that we will use are as follows: struct Node.
As a warm-up exercise, let's see how we might construct the start of a linked list with nodes of this type.
We first declare a pointer variable, called , that will point  the  of our linked list: NodePtr ;.
Notice that the pointer member of this  is set equal  NULL.
That is because this  is the last  in the list (as well as the first  in the list).
At this stage, our linked list looks like this: 3 NULL Our one- list was built in a purely ad hoc way.
To have a larger linked list, your program must be able  add nodes in a systematic way.
We next describe one simple way  insert nodes in a linked list.
Inserting a  at the Head of a List In this subsection we assume that our linked list already contains one or more nodes, and we develop a function  add another.
The first parameter for the insertion function will be a call-by-reference parameter for a pointer variable that points  the  of the linked list, that is, a pointer variable that points  the first  in the linked list.
The other parameter will give the   be stored in the new.
The function declaration for our insertion function is as follows: void head_insert(NodePtr& , int the_number); Linked Lists as Arguments You should always keep one pointer variable pointing  the  of a linked list.
This pointer variable is a way   the linked list.
When you write a function that takes a linked list as an argument, this pointer (which points  the  of the linked list) can be used as the linked list argument.
Chapter 13 / Pointers and Linked Lists To insert a new  into the linked list, our function will use the new operator  create a new.
The data is then copied into the new , and the new  is inserted at the  of the list.
When we insert nodes this way, the new  will be the first  in the list (that is, the ) rather than the last.
Since  variables have no names, we must use a local pointer variable  point  this.
If we call the local pointer variable temp_ptr, the new  can be referred  as *temp_ptr.
The complete process can be summarized as follows: Pseudocode for head_insert Function 1.
Create a new  variable pointed  by temp_ptr.
Place the data in this new.
Make the link member of this new  point  the   (first ) of the original linked list.
Make the pointer variable named  point  the new.
Display 13_0_3 contains a diagram of this algorithm.
Steps 2 and 3 in the diagram can be expressed by these Cplus_plus assignment statements: = ; = temp_ptr; The complete function definition is given in Display 13_0_4.
NULL Display 13_0_4   Function  Add a  at the Head of a Linked List Function Declaration 1 2 3 4 5 6 7 8 9 10 11 12 13.
Function Definition 1 2 3 4 5 6 7 8 9 10.
Chapter 13 / Pointers and Linked Lists You will want to allow for the possibility that a list contains nothing.
For example, a shopping list might have nothing in it because there is nothing to buy this week.
A list with nothing in it is called an empty list.
A linked list is named by naming a pointer that points to the  of the list, but an empty list has no.
To specify an empty list, you use the pointer NULL.
If the pointer variable  is supposed to point to the   of a linked list and you want to indicate that the list is empty, then you set the value of  as follows: = NULL; Whenever you design a function for manipulating a linked list, you should always check to see if it works on the empty list.
If it does not, you may be able to add a special case for the empty list.
If you cannot design the function to apply to the empty list, then your program must be designed to handle empty lists some other way or to avoid them completely.
Fortunately, the empty list can often be treated just like any other list.
For example, the function head_insert in Display 13_0_4 was designed with nonempty lists as the model, but a check will show that it works for the empty list as well.
Pitfall  Losing Nodes You might be tempted to write the function definition for head_insert (Display 13_0_4) using the pointer variable  to construct the new , instead of using the local pointer variable.
If you were to try, you might start the function as follows: = new ; = the_number; At this point the new  is constructed, contains the correct , and is pointed to by the pointer , all as it is supposed to be.
All that is left to do is to attach the rest of the list to this  by setting the pointer member given below so that it points to what was formerly the first  of the list: headarrow_operatorlink Display 13_0_5 shows the situation when the new  value is 12.
That illustration reveals the problem.
If you were to proceed in this way, there would be nothing pointing to the  containing 15.
Since there is no named pointer pointing to it (or to a chain of pointers ending with that ), there is no way the program can reference this.
A program cannot make a pointer point to either of these nodes, nor can it access the  in these nodes, nor can it do anything else to the nodes.
It simply has no way to refer to the nodes.
Such a situation ties up memory for the duration of the program.
A program that loses nodes is sometimes said to have a "memory leak_0_" A significant memory leak can result in the program running out of memory, causing abnormal termination.
Worse, a memory leak (lost nodes) in an 13_0_1 Nodes and Linked Lists Display 13_0_5   Lost Nodes 12.
To avoid such lost nodes, the program must always keep some pointer pointing to the ■ of the list, usually the pointer in a pointer variable like.
Searching a Linked List Next we will design a function to search a linked list in order to locate a particular.
We will use the same  type, called , that we used in the previous subsections.
The function will return a pointer that points to the first  which contains that integer.
If no contains the integer, the function will return the pointer NULL.
This way, our program can test to see whether the integer is on the list by checking to see if the function returns a pointer value that is not equal to NULL.
The function declaration and header comment for our function is as follows: NodePtr search(NodePtr , int target); //Precondition: The pointer  points to the  of //a linked list.
The pointer variable in the last //is NULL.
If the list is empty, then  is NULL.
If no  contains the target, //the function returns NULL.
We will use a local pointer variable, called here, to move through the list looking for the target.
The only way to move around a linked list, or any other  structure made up of nodes and pointers, is to follow the pointers.
So we will start with here pointing to the first  and move the pointer from  to  following the pointer out of each.
Chapter 13 / Pointers and Linked Lists diagrammed in Display 13_0_6.
Since empty lists present some minor problems that would clutter our discussion, we will at first assume that the linked list contains at least one.
Later we will come back and make sure the algorithm works for the empty list as well.
This search technique yields the following algorithm: Pseudocode for search Function of the linked list.
The next  is the one pointed to by the pointer member of the  currently pointed to by.
The pointer member of the  currently pointed to by  is given by the expression herearrow_operatorlink To move  to the next , we want to change  so that it points to the  that is pointed to by the above-named pointer (member) variable.
Hence, the following will move the pointer  to the next  in the list: = ; Putting these pieces together yields the following refinement of the algorithm pseudocode: Preliminary Version of the Code for the search Function = ; while ( _0_= target &&.
We test to see if  is not pointing to the last  by testing to see if the member variable herearrow_operator link is not equal to NULL.
NULL We still must go back and take care of the empty list.
If we check our code, we find that there is a problem with the empty list.
If the list is empty, then is equal to NULL and hence the following expressions are undefined: 753.
Chapter 13 / Pointers and Linked Lists When  is NULL, it is not pointing to any node, so there is no member named data nor any member named link.
Hence, we make a special case of the empty list.
The complete function definition is given in Display 13_0_7.
Display 13_0_7   Function to Locate a Node in a Linked List Function Declaration 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15.
The pointer variable in the last node //is NULL.
If the list is empty, then head is NULL.
If no node contains the target, //the function returns NULL.
Function Definition 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21.
An iterator can be an object of some iterator class or something simpler, such as an array index or a pointer.
Pointers provide a simple example of an iterator.
In fact, a pointer is the prototypical example of an iterator.
The basic ideas can be easily seen in the context of linked lists.
You can use a pointer as an iterator by moving through the linked list one node at a time starting at the head of the list and cycling through all the nodes in the list.
The general outline is as follows: Node_Type *; Do whatever you want with the node pointed to by ; where head is a pointer to the head node of the linked list and link is the name of the member variable of a node that points to the next node in the list.
For example, to output the data in all the nodes in a linked list of the kind we have been discussing, you could use ; //Equivalent to: Node *;.
The definition of Node and  are given in Display 13_0_7.
Inserting and Removing Nodes Inside a List We next design a function to insert a  at a specified place in a linked list.
If you want the nodes in some particular order, such as numeric order or alphabetical order, you cannot simply insert the  at the beginning or end of the list.
We will therefore design a function to insert a  after a specified in the linked list.
We assume that some other function or program part has correctly placed a pointer called after_me pointing to some  in the linked list.
We want the new  to be placed after the  pointed to by after_me, as illustrated in Display 13_0_8.
The same technique works for nodes with any kind of data, but to be concrete, we are using the same type of nodes as in previous subsections.
The type definitions are given in Display 13_0_7.
The function declaration for the function we want to define is: void insert( after_me, int the_number); //Precondition: after_me points to a  in a linked list.
A new  is set up the same way it was in the function head_insert in Display 13_0_4.
The difference between this function and that one is that we now wish to insert the  not at the head of the list, but after the Inserting in the middle of a list 756 Chapter 13 / Pointers and Linked Lists Display 13_0_8   Inserting in the Middle of a Linked List head after_me 2 3 5 temp_ptr 9 18 pointed to by after_me.
The way to do the insertion is shown in Display 13_0_8 and is expressed as follows in Cplus_plus code: //add a link from the new  to the list: = ; //add a link from the list to the new : = temp_ptr;.
Insertion at the ends Comparison to arrays Removing a The order of these two assignment statements is critical.
In the first assignment we want the pointer value  before it is changed.
The complete function is given in Display 13_0_9.
If you go through the code for the function insert, you will see that it works correctly even if the  pointed to by after_me is the last  in the list.
However, insert will not work for inserting a  at the beginning of a linked list.
The function head_insert given in Display 13_0_4 can be used to insert a  at the beginning of a list.
By using the function insert you can maintain a linked list in numerical order or alphabetical order or other ordering.
You can "squeeze" a new into the correct position by simply adjusting two pointers.
This is true no matter how long the linked list is or where in the list you want the new  to go.
If you instead used an array, much, and in extreme cases all, of the array would have to be copied in order to make room for a new  in the correct spot.
Despite the overhead involved in positioning the pointer after_me, inserting into a linked list is frequently more efficient than inserting into an array.
Removing a  from a linked list is also quite easy.
Display 13_0_10 illustrates the method.
Once the pointers before and discard have 13_0_1 Nodes and Linked Lists Display 13_0_9   Function to Add a Node in the Middle of a Linked List Function Declaration 1 2 3 4 5 6 7 8 9 10 11 12 13.
Function Definition 1 2 3 4 5 6 7 8 9 10.
Chapter 13 / Pointers and Linked Lists Display 13_0_10   Removing a 1.
P  osition the pointer discard so that it points to the  to be deleted, and position the pointer before so that it points to the  before the one to be deleted.
If you change the linked list pointed to by 1, then you will also change the linked list pointed to by 2, because they are the same linked list.
If 1 points to a linked list and you want 2 to point to a second, identical copy of this linked list, the assignment statement above will not work.
Instead, you must copy the entire linked list  by.
Alternatively, you can overload the assignment  = so that it means whatever you want it to mean.
Write type definitions for the nodes and pointers in a linked list.
Call the type NodeType and call the pointer type PointerType.
The linked lists will be lists of letters.
A linked list is normally given by giving a pointer that points to the first in the list, but an empty list has no first.
What pointer  is normally used to represent an empty list.
Suppose your program contains the following type definitions and pointer variable declarations: struct.
Suppose p1 points to a  of this type that is on a linked list.
Write code that will make p1 point to the next  on this linked list.
Suppose your program contains type definitions and pointer variable declarations as in Self-Test Exercise 7.
Suppose further that p2 points to a of type  that is on a linked list and is not the last  on the list.
Write code that will delete the  after the  pointed to by p2.
After this code is executed, the linked list should be the same, except that there will be one less  on the linked list.
Choose an answer and explain it.
For a large array and large list holding the same type objects, inserting a new  at a known location into the middle of a linked list compared with insertion in an array is a.
More efficient b.
Less efficient c.
Dependent on the size of the two lists 759.
Chapter 13 / Pointers and Linked Lists Variations on Linked Lists In this subsection we give you a hint of the many data structures that can be created using nodes and pointers.
We briefly describe two additional data structures, the doubly linked list and the binary tree.
An ordinary linked list allows you to move down the list in only one direction (following the links).
A  in a doubly linked list has two links, one link that points to the next  and one that points to the previous.
Diagrammatically, a doubly linked list looks like the sample list in Display 13_0_11.
The node class for a doubly linked list could be as follows: struct.
Rather than a single pointer to the  node, a doubly linked list normally has a pointer to each of the two end nodes.
You can call these pointers front and back, although the choice of which is front and which is back is arbitrary.
The definitions of constructors and some of the functions in the doubly linked list class will have to change (from the singly linked case) to accommodate the extra link.
A tree is a data structure that is structured as shown in Display 13_0_12.
In particular, in a tree you can reach any node from the top (root) node by some path that follows the links.
Note that there are no cycles in a tree.
If you follow the links, you eventually get to an "end_0_" Note that each node has two links that point Display 13_0_11   A Doubly Linked List front 1 2 back 3 13_0_1 Nodes and Linked Lists Display 13_0_12   A Binary Tree root 40⋅.
NULL to other nodes (or the value NULL).
This sort of tree is called a binary tree, because each node has exactly two links.
There are other kinds of trees with different numbers of links in the nodes, but the binary tree is the most common case.
A tree is not a form of linked list, but does use links (pointers) in ways that are similar to how they are used in linked lists.
The definition of the node type for a binary tree is essentially the same as what it is for a doubly linked list, but the two links are usually named using some form of the words left and right.
The following is a node type that can be used for constructing a binary tree: struct TreeNode.
In Display 13_0_12, the pointer named root points to the root node ("top node").
The root node serves a purpose similar to that of the head node in an ordinary linked list (Display 13_0_10).
Any node in the tree can be reached from the root node by following the links.
The term tree may seem like a misnomer.
The root is at the top of the tree and the branching structure looks more like a root branching structure than a tree branching structure.
The secret to the terminology is to turn the picture (Display 13_0_12) upside down.
The picture then does resemble the branching structure of a tree and the root node is where the tree's root would begin.
Chapter 13 / Pointers and Linked Lists nodes at the ends of the branches with both link instance variables set to NULL are known as leaf nodes, a terminology that may now make some sense.
Although we do not have room to pursue the topic in this book, binary trees can be used to efficiently store and retrieve data.
Linked Lists of Classes VideoNote Walkthrough of Linked Lists of Classes In the preceding examples we created linked lists by using a struct to hold the contents of a node within the list.
It is possible to create the same data structures using a class instead of a struct.
The logic is identical except the syntax of using and defining a class should be substituted in place of that for a struct.
Displays 13_0_13 and 13_0_14 illustrate how to define a Node class.
The data variables are declared private using the principle of information hiding, and public methods have been created to access the data value and next node in the link.
Display 13_0_15 creates a short list of five nodes by inserting new nodes Display 13_0_13   Interface File for a Node Class 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 //This is the header file for Node_0_h.
This is the interface for //a node class that behaves similarly to the struct defined //in Display 13_0_4 namespace linkedlistofclasses {.
Chapter 13 / Pointers and Linked Lists 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49.
The head_insert function is logically identical to the same function defined in Display 13_0_4 except the constructor defined for the  class is used to set the.
Matthew 19:30 Linked lists have many applications.
In this section we give two samples of what they can be used for.
We use linked lists to give implementations of two structures known as a stack and a queue.
In this section we always use regular linked lists and not doubly linked lists.
Stacks A stack is a  structure that retrieves  in the reverse of the order in which the  is stored.
Suppose you place the letters 'A', 'B', and then 'C' in a stack.
When you take these letters out of the stack, they will be removed in the order 'C', 'B', and then 'A'.
This use of a stack is diagrammed in Display 13_0_16.
As shown Display 13_0_16   A Stack A B C C A C B B A A.
Chapter 13 / Pointers and Linked Lists there, you can think of a stack as a hole in the ground.
In order to get something out of the stack, you must first remove the items on top of the one you want.
For this reason a stack is often called a last-in/first-out (LIFO) data structure.
Stacks are used for many language processing tasks.
In Chapter 14 we will discuss how the computer system uses a stack to keep track of Cplus_plus function calls.
However, here we will do only one very simple application.
Our goal in this example is to show you how you can use the linked list techniques to implement specific data structures; a stack is one simple example of the use of linked lists.
You need not read Chapter 14 to understand this example.
Programming Example   A Stack The interface for our Stack class is given in Display 13_0_17.
This particular stack is used to store data of type char.
You can define a similar stack to store data of any other type.
There are two basic operations you can perform on a stack: adding an item to the stack and removing an item from the stack.
Adding an item is called pushing the item onto the stack, and so we called the member function that 1 2 3 4 5 6 7 8 9 10 11 //This is the header file stack_0_h.
This is the interface for the class Stack, //which is a class for a stack of symbols.
Removing an item from a stack is called popping the item off the stack, and so we called the member function that does this pop.
The names push and pop derive from another way of visualizing a stack.
A stack is analogous to a mechanism that is sometimes used to hold plates in a cafeteria.
The mechanism stores plates in a hole in the countertop.
There is a spring underneath the plates with its tension adjusted so that only the top protrudes above the countertop.
If this sort of mechanism were used as a stack data structure, the data would be written on plates (which might violate some health laws, but still makes a good analogy).
To add a  to the stack, you put it on top of the other plates, and the weight of this new  pushes down the spring.
When you remove a , the  below it pops into view.
Display 13_0_18 shows a simple program that illustrates how the Stack class is used.
This program reads a word one letter at a time and places the letters in a stack.
The program then removes the letters one by one and writes them to Application program 1 2 3 4 5 6 7 8.
Chapter 13 / Pointers and Linked Lists 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33.
It discards input remaining on the current input line up to 10,000 characters or until a return is entered.
It also discards the return ('\n') at the end of the line_0_> Sample Dialogue Enter a word: straw Written backward that is: warts Again_0_(y/n): y Enter a word: Cplus_plus Written backward that is: plus_plusC.
Implementation the screen.
Because data is removed from a stack in the reverse of the order in which it enters the stack, the output shows the word written backward.
As shown in Display 13_0_19, our Stack class is implemented as a linked list in which the head of the list serves as the top of the stack.
The member variable top is a pointer that points to the head of the linked list.
Chapter 13 / Pointers and Linked Lists 41 42 43 44 45 46 47 48 49 50 51.
Writing the definition of the member function push is Self-Test Exercise 10.
However, we have already given the algorithm for this task.
The code for the push member function is essentially the same as the function head_insert shown in Display 13_0_4, except that in the member function push we use a pointer named  in place of a pointer named head.
An empty stack is just an empty linked list, so an empty stack is implemented by setting the pointer  equal to NULL.
Once you realize that NULL represents the empty stack, the implementations of the default constructor and of the member function empty are obvious.
The definition of the copy constructor is a bit complicated but does not use any techniques we have not already discussed.
The details are left to SelfTest Exercise 11.
The pop member function first checks to see if the stack is empty.
If the stack is not empty, it proceeds to remove the  character in the stack.
It sets the local variable  equal to the  symbol on the stack.
That is done as follows: char  = toparrow_operatordata; After the symbol in the  node is saved in the variable , the pointer.
The pointer  is moved with the following statement: = toparrow_operatorlink; However, before the pointer  is moved, a temporary pointer, called.
The node can then be removed with the following call to delete: delete ; Each node that is removed from the linked list by the member function pop is destroyed with a call to delete.
Thus, all that the destructor needs to do is remove each item from the stack with a call to pop.
Each node will then have its memory returned to the freestore.
Give the definition of the member function push of the class Stack described in Display 13_0_17.
Give the definition of the copy constructor for the class Stack described in Display 13_0_17.
Queues A stack is a last-in/first-out data structure.
Another common data structure is a queue, which handles data in a first-in/first-out (FIFO) fashion.
A queue behaves exactly the same as a line of people waiting for a bank teller or other service.
The people are served in the order they enter the line (the queue).
The operation of a queue is diagrammed in Display 13_0_20.
A queue can be implemented with a linked list in a manner that is similar to our implementation of the Stack class.
However, a queue needs a pointer at both the head of the list and at the other the end of the linked list, since action takes place in both locations.
It is easier to remove a node from the head of a linked list than from the other end of the linked list.
So, our implementation will remove a node from the head of the list (which we will now call the front of the list) and we will add nodes to the other end of the list, which we will now call the back of the list (or the back of the queue).
Queue A queue is a first-in/first-out data structure; that is, the data items are removed from the queue in the same order that they were added to the queue.
Display 13_0_20   A Queue A B C C A B.
Chapter 13 / Pointers and Linked Lists Programming Example   A Queue The interface for our queue class is given in Display 13_0_21.
This particular queue is used to store data of type char.
You can define a similar queue to store data of any other type.
There are two basic operations you can perform on a queue: adding an item to the end of the queue and removing an item from the front of the queue.
Display 13_0_21   Interface File for a Queue 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 //This is the header file queue_0_h.
This is the interface for the class Queue, //which is a class for a queue of symbols.
Returns false otherwise.
Items are added at this end.
Display 13_0_22 shows a simple program that illustrates how the queue class is used.
This program reads a word one letter at a time and places the letters in a queue.
The program then removes the letters one by one and writes them to the screen.
Because data is removed from a queue in the order in which it enters the queue, the output shows the letters in the word in the same order that the user entered them.
It is good to contrast this application of a queue with a similar application using a stack that we gave in Display 13_0_18.
It discards input remaining on the current input line up to 10,000 characters or until a return is entered.
It also discards the return ( '\n') at the end of the line_0_> 774 Chapter 13 / Pointers and Linked Lists Sample Dialogue Enter a word: straw You entered: straw Again_0_(y/n): y Enter a word: Cplus_plus You entered: Cplus_plus.
Implementation As shown in Displays 13_0_21 and 13_0_23, our queue class is implemented as a linked list in which the head of the list serves as the front of the queue.
The member variable front is a pointer that points to the head of the linked list.
Nodes are removed at the head of the linked list.
The member variable back is a pointer that points to the node at the other end of the linked list.
Nodes are added at this end of the linked list.
An empty queue is just an empty linked list, so an empty queue is implemented by setting the pointers front and back equal to NULL.
The rest of the details of the implementation are similar to things we have seen before.
Chapter 13 / Pointers and Linked Lists 66 67 68 69 70 71 72 73.
S el f-T est Exe rc ise s 12.
Give the definition of the copy constructor for the class Queue described in Display 13_0_21.
Give the definition of the destructor for the class Queue described in Display 13_0_21.
Chapter Summary ■ A node is a struct or class object that has one or more member variables that are pointer variables.
These nodes can be connected by their member pointer variables to produce data structures that can grow and shrink in size while your program is running.
A stack can be implemented using a linked list.
A queue can be implemented using a linked list.
Answers to Self - Test Exerci ses 1.
Sally Sally 18 18 Answers to Self-Test Exercises Note that (*head)_0_name and headarrow_operatorname mean the same thing.
Similarly, (*head)_0_number and headarrow_operatornumber mean the same thing 2.
This is sufficient to delete the node from the linked list.
If you are inserting into a list, you have about five operations, most of which are pointer assignments, regardless of the list size.
If you insert into an array, on the average you have to move about half the array entries to insert a data.
For small lists, the answer is (c), about the same.
Practice Programs Practice Programs can generally be solved with a short program that directly applies the programming principles presented in this chapter.
The following program creates a linked list with three names: # <iostream>.
Add code to the main function that: a.
Outputs in order all names in the list.
Deletes the node with "Joules" then outputs the modified list.
Deletes all  in the list.
Your class should have appropriate member functions to set the name and the link to the  node in the list.
You might also consider adding a constructor that can set the name and link.
Programming Projects Programming Projects require more problem-solving than Practice Programs and can usually be solved many different ways.
Visit www_0_myprogramminglab_0_com to complete many of these Programming Projects online and get instant feedback.
Write a void function that takes a linked list of integers and reverses the order of its.
The function will have one call-by-reference parameter that is a pointer to the head of the list.
After the function is called, this pointer will point to the head of a linked list that has the same  as the original list, but in the reverse of the order they had in the original list.
Note that your function will neither create nor destroy any.
It will simply rearrange.
Place your function in a suitable test program.
Write a function called merge_lists that takes two call-by-reference arguments that are pointer variables that point to the heads of  lists of values of type int.
The two  lists are assumed to be sorted so that the number at the head is the smallest number, the number in the  node is Programming Projects the  smallest, and so forth.
The function returns a pointer to the head of a new  list that contains all of the  in the original two lists.
The  in this longer list are also sorted from smallest to largest values.
Note that your function will neither create nor destroy any.
When the function call ends, the two pointer variable arguments should have the value NULL.
Design and implement a class whose objects represent polynomials.
The polynomial anxn + an−1xn−1 +.
Each node will contain an int value for the power of x and an int value for the corresponding coefficient.
The class operations should  addition, subtraction, multiplication, and evaluation of a polynomial.
Overload the operators +, -, and * for addition, subtraction, and multiplication.
Evaluation of a polynomial is implemented as a member function with one argument of type int.
The evaluation member function returns the value obtained by plugging in its argument for x and performing the indicated operations.
Include four constructors: a default constructor, a copy constructor, a constructor with a single argument of type int that produces the polynomial that has only one constant term that is equal to the constructor argument, and a constructor with two arguments of type int that produces the one-term polynomial whose coefficient and exponent are given by the two arguments.
Include member functions to input and output polynomials.
When the user inputs a polynomial, the user types in the following: anx^n + an-1x^n-1 +.
For example, the polynomial 3x4 + 7x2 + 5 can be input as 3x^4 + 7x^2 + 5 It could also be input as 3x^4 + 0x^3 + 7x^2 + 0x^1 + 5 781.
Chapter 13 / Pointers and Linked Lists If a coefficient is negative, a minus sign is used in place of a plus sign, as in the following examples: 3x^5 - 7x^3 + 2x^1 - 8 -7x^4 + 5x^2 + 9 A minus sign at the  of the polynomial, as in the second of the two examples, applies only to the first coefficient; it does not negate the entire polynomial.
Polynomials are output in the same format.
In the case of output, the terms with zero coefficients are not output.
To simplify input, you can assume that polynomials are always entered one per line and that there will always be a constant term a0.
If there is no constant term, the user enters 0 for the constant term, as in the following: 12x^8 + 3x^2 + 0 4_0_	In this project you will redo Programming Project 8 from Chapter 11 using a  list instead of an array.
As noted there, this is a  list of double items.
This fact may imply changes in some of the member functions.
The members are as follows: a default constructor; a member function named add_item to add a double to the list; a test for a full list that is a Boolean-valued function named full( ); and a friend function overloading the insertion operator <<.
A harder version of Programming Project 4 would be to write a class named List, similar to Project 4, but with all the following member functions: Default constructor, List(); double List::();, which returns the first item in the list ■ double List::();, which returns the last item in the list ■ double List::current();, which returns the "current" item returns ■	void List::reset(); to make current() return the first item in the list ■	void List::insert(double after_me, double insert_me);, which inserts insert_me into the list after after_me and increments the private: variable count.
You will need the following struct (outside the list class) for the list nodes: struct node.
Incremental development is essential to all projects of any size, and this is no exception.
Write the definition for the List class, but do not implement any members yet.
Place this class definition in a file list_0_h.
Then #include "list_0_h" in a file that contains int main(){}_0_Compile your file.
This will find syntax errors and many typographical errors that would cause untold difficulty if you attempted to implement members without this check.
Then you should implement and compile one member at a time, until you have enough to write test code in your main function.
She ­decided on the following procedure to determine which suitor she would marry.
First, all of the suitors would be lined up one after the other and assigned numbers.
The first suitor would be number 1, the second number 2, and so on up to the last suitor, number n.
Starting at the first suitor she would then count three suitors down the line (because of the three letters in her name) and the third suitor would be eliminated from winning her hand and removed from the line.
Eve would then continue, counting three more suitors, and eliminate every third suitor.
When she reached the end of the line she would continue counting from the beginning.
For example, if there were six suitors then the elimination process would proceed as follows: 123456 12456 1245 125 15 1 initial list of suitors, start counting from 1 suitor 3 eliminated, continue counting from 4 suitor 6 eliminated, continue counting from 1 suitor 4 eliminated, continue counting from 5 suitor 2 eliminated, continue counting from 5 suitor 5 eliminated, 1 is the lucky winner Write a program that creates a circular linked list of nodes to determine which position you should stand in to marry the princess if there are n suitors.
A circular linked list is a linked list where the link field of the last node in the list refers to the node that is the head of the list.
Your program should simulate the elimination process by deleting the node that corresponds to the suitor that is eliminated for each step in the process.
Consider the possibility that you may need to delete the "head" node in the list.
VideoNote Solution to Programming Project 13_0_6 784 Chapter 13 / Pointers and Linked Lists 7_0_	Redo (or do for the first time) Programming Project 5 from Chapter 9.
However, instead of a dynamic array to store the list of user IDs for each computer station, use a linked list.
The node for the lists should contain the station number and user ID of the person logged in on that station.
If nobody is logged on to a computer station, then no entry should exist in the linked list for that computer station.
Modify or rewrite the Queue class (Display 13_0_21 through 13_0_23) to simulate  arrivals at the Department of Motor Vehicles (DMV) counter.
As customers arrive, they are given a ticket number starting at 1 and incrementing with each new.
When a  service agent is free, the  with the next ticket number is called.
This system results in a FIFO queue of customers ordered by ticket number.
Write a program that implements the queue and simulates customers entering and leaving the queue.
Input into the queue should be the ticket number and a timestamp when the ticket was entered into the queue.
A ticket and its corresponding timestamp is removed when a  service agent handles the next.
Your program should save the length of time the last three customers spent waiting in the queue.
Every time a ticket is removed from the queue, update these times and output the average of the last three customers as an estimate of how long it will take until the next  is handled.
If nobody is in the queue, output that the line is empty.
Code to compute a timestamp based on the computer's clock is given below.
The time(NULL) function returns the number of January 1, 1970, on most implementations of Cplus_plus: # <ctime>.
Sample execution is shown here: The line is empty.
Enter '1' to simulate a 's arrival, '2' to help the next , or '3' to quit.
Enter '1' to simulate a 's arrival, '2' to help the next , or '3' to quit.
Enter '1' to simulate a 's arrival, '2' to help the next , or '3' to quit.
Enter '1' to simulate a 's arrival, '2' to help the next , or '3' to quit.
The estimated wait  for  2 is 25.
Enter '1' to simulate a 's arrival, '2' to help the next , or '3' to quit.
The estimated wait  for  3 is 26.
Enter '1' to simulate a 's arrival, '2' to help the next , or '3' to quit.
Enter '1' to simulate a 's arrival, '2' to help the next , or '3' to quit.
The estimated wait  for  4 is 32.
The following figure is called a graph.
The circles are called nodes, and the lines are called edges.
An edge connects two nodes.
You can interpret the graph as a maze of rooms and passages.
The nodes can be thought of as rooms, and an edge connects one room to another.
Note that each node has at most four edges in the graph.
North Start A B.
Finish VideoNote Solution to Programming Project 13_0_9 786 Chapter 13 / Pointers and Linked Lists Write a program that implements the maze using nodes and pointers.
Each node in the graph will correspond to a node in your code that is implemented in the form of a class or struct.
The edges correspond to bidirectional links that point from one node to another.
Start the user in node A.
The user's goal is to reach the finish in node L.
The program should output possible moves in the north, south, east, or west direction.
Sample execution is shown here.
You You E You You S You You E are in room A of a maze of twisty little passages, all alike.
In RPN, the operator comes after the operands instead of the normal format in which the operator is between the operands (this is called infix notation).
Starting with an empty stack, a RPN calculator can be implemented with the following rules: ■	If a number is input, push it on the stack.
Use the modified stack to implement a RPN calculator.
Output an appropriate error message if there are not two operands on the stack when given an operator.
Here is a sample input and output that is equivalent to ((10 - (2 + 3)) * 2)/5: 10 2 3 + Programming Projects 2 * 5 / q The top of the stack is: 2 11.
You should complete the Programming Project 10 before attempting this one.
Write a program that converts a fully parenthesized mathematical infix expression into an equivalent postfix expression and then evaluates the postfix expression.
A fully parenthesized expression is one in which parentheses surround every operator and its operands.
Starting with an empty stack of strings to store operators and an empty queue of strings to store the postfix expression, the conversion can be implemented with the following rules: is input, then ignore it.
When the final operator is popped from the stack, the queue contains the equivalent postfix expression.
Use your solution from Programming Project 10 to evaluate it.
You will need to convert a string object to an integer.
Use the c_str() function to convert the string to a C string, and then use the atoi function to convert the C string into an integer.
Refer to Chapter 8 for details.
Sample output is shown below for ((10 - (2 + 3)) * 2),which translates to the postfix expression 10 2 3 + - 2 *: q The expression evaluates to 10 787.
Recursion 14_0_1 Recursive Functions for Tasks 791 Case Study: Vertical Numbers 791 A Closer Look at Recursion 797 Pitfall: Infinite Recursion 799 Stacks for Recursion 800 Pitfall: Stack Overflow 802 Recursion Versus Iteration 802 14 14_0_3 Thinking Recursively 809 Recursive Design Techniques 809 Case Study: Binary Search—An Example of Recursive Thinking 810 Programming Example: A Recursive Member Function 818 14_0_2 Recursive Functions for Values 804 General Form for a Recursive Function That Returns a Value 804 Programming Example: Another Powers Function 804 Chapter Summary 822 Answers to Self-Test Exercises 822 Practice Programs 827 Programming Projects 827 After a lecture on cosmology and the structure of the solar system, William James was accosted by a little old lady.
James, but it's wrong.
I've got a better theory," said the little old lady.
Not wishing to demolish this absurd little theory by bringing to bear the masses of scientific evidence he had at his command, James decided to gently dissuade his opponent by making her see some of the inadequacies of her position.
To this the little old lady crowed triumphantly.
Ross, Constraints on Variables in Syntax Introduction You have encountered a few cases of circular definitions that worked out satisfactorily.
The most prominent examples are the definitions of certain Cplus_plus statements.
For example, the definition of a while statement says that it can contain other (smaller) statements.
Since one of the possibilities for these smaller statements is another while statement, there is a kind of circularity in that definition.
The definition of the while statement, if written out in complete detail, will contain a reference to while statements.
In mathematics, this kind of circular definition is called a recursive definition.
In Cplus_plus, a function may be defined in terms of itself in the same way.
To put it more precisely, a function definition may contain a call to itself.
In such cases, the function is said to be recursive.
This chapter discusses recursion in Cplus_plus and more generally discusses recursion as a programming and problem-solving technique.
Prerequisites Sections 14_0_1 and 14_0_2 use material only from Chapters 2 through 5.
Section 14_0_3 uses material from Chapters 2 through 7 and 10.
Jorge Luis Borges, The Garden of Forking Paths When you are writing a function to solve a task, one basic design technique is to break the task into subtasks.
Sometimes it turns out that at least one of the subtasks is a smaller example of the same task.
For example, if the task is to search an array for a particular value, you might divide this into the subtask of searching the first half of the array and the subtask of searching the second versions of the original task.
Whenever one subtask is a smaller version of the original task to be accomplished, you can solve the original task using a recursive function.
It takes a little training to easily decompose problems this way, but once you learn the technique, it can be one of the quickest ways to design an algorithm, and, ultimately, a Cplus_plus function.
We begin with a simple case study to illustrate this technique.
Recursion In Cplus_plus, a function definition may contain a call to the function being defined.
In such cases, the function is said to be recursive.
Case Study   Vertical Numbers In this case study we design a recursive void function that writes numbers to the screen with the digits written vertically, so that, for example, 1984 would be written as 1 9 8 4 Problem Definition.
Algorithm Design One case is very simple.
If , the number to be written out, is only one digit long, then just write out the number.
As simple as it is, this case is still important, so let's keep track of it.
Simple Case: If  < 10, then write the number  to the screen.
Now let's consider the more typical case in which the number to be written out consists of more than one digit.
Suppose you want to write the number 1234 vertically so that the result is 1 2 3 4 One way to decompose this task into two subtasks is the following: 1_0_	Output all the digits except the last digit like so: 1 2 3 2_0_	Output the last digit, which in this example is 4.
Subtask 1 is a smaller version of the original task, so we can implement this subtask with a recursive call.
Subtask 2 is just the simple case we listed earlier.
Thus, an outline of our algorithm for the function write_vertical with parameter  is given by the following pseudocode: { <<  << endl; Recursive subtask.
In order to convert this pseudocode into the code for a Cplus_plus function, all we need to do is translate the following two pieces of pseudocode into Cplus_plus expressions: the number  with the last digit removed and the last digit of 14_0_1 Recursive Functions for Tasks 793 These expressions can easily be translated into Cplus_plus expressions using the integer division operators / and % as follows: / 10 //the number  with the last digit removed % 10 //the last digit of For example, 1234 / 10 evaluates to 123, and 1234 % 10 evaluates to 4.
Several factors influenced our selection of the two subtasks we used in this algorithm.
One was that we could easily compute the argument for the recursive call to write_vertical (shown in color) that we used in the pseudocode.
The number  with the last digit removed is easily computed as /10.
As an alternative, you might have been tempted to divide the subtasks as follows: 1_0_	Output the first digit of.
This is a perfectly valid decomposition of the task into subtasks, and it can be implemented recursively.
However, it is difficult to calculate the result of removing the first digit from a number, while it is easy to calculate the result of removing the last digit from a number.
Another reason for choosing these sorts of decompositions is that one of the subcases does not involve a recursive call.
A successful definition of a recursive function always includes at least one case that does not involve a recursive call (as well as one or more cases that do involve at least one recursive call).
This aspect of the recursive algorithm is discussed in the subsections that follow this case study.
Coding We can now put all the pieces together to produce the recursive function write_vertical shown in Display 14_0_1.
In the next subsection we will explain more details of how recursion works in this example.
The argument 123 is substituted for the parameter in the function definition, and the body of the function is executed.
After the substitution of 123 for , the code to be executed is as follows: 14_0_1 Recursive Functions for Tasks.
Since 123 is not less than 10, the logical expression in the if-else statement is false, so the else part is executed.
However, the else part begins with the following function call: ( / 10);.
When execution reaches this recursive call, the current function computation is placed in suspended animation and this recursive call is executed.
When this recursive call is finished, the execution of the suspended computation will return to this point, and the suspended computation will continue from this point.
The recursive call (12); is handled just like any other function call.
The argument 12 is substituted for the parameter  and the body of the function is executed.
After substituting 12 for , there are two computations, one suspended and one active, as follows: { (12<<< endl;.
However, as you already saw, the else part begins with a recursive call.
The argument for the recursive call is  / 10, which 795.
At this point there are two suspended computations waiting to resume and the computer begins to execute this new  call, which is handled just like all the previous  calls.
The argument 1 is substituted for the parameter , and the body of the function is executed.
At this point, the computation looks like the following: { if (12 << 123 << endl; { } if (1 << digits endl; long: else // is two<< or12 more { }.
When the body of the function is executed this time, something different happens.
Since 1 is less than 10, the Boolean expression in the if-else statement is true, so the statement before the else is executed.
That statement is simply a statement that writes the argument 1 to the screen, and so the call write_ vertical(1) writes 1 to the screen and ends without any  call.
When the call (1) ends, the suspended computation that is waiting for it to end resumes where that suspended computation left off, as shown by the following: { if (12 << 123 << endl;.
That ends that computation, but there is yet another suspended computation waiting to resume.
When this last suspended computation resumes, the situation is as follows: 797 Output the digit 2.
And, sure enough, the digits 1, 2, and 3 have been written to the screen one per line, in that order.
Output the digit 3 A Closer Look at Recursion The definition of the function write_vertical uses recursion.
Yet we did nothing new  different in evaluating the function call write_ vertical(123).
We treated it just like any of the function calls we saw in previous chapters.
We just substituted the argument 123 for the parameter n and then executed the code in the body of the function definition.
When we reached the  call write_vertical(123 / 10); we simply repeated this process one more time.
The computer keeps track of  calls in the following way.
When a and begins to execute the code.
If it should encounter a  call, then it temporarily stops its computation.
This is because it must know the result of the  call before it can proceed.
It saves all the information it needs to continue the computation later on and proceeds to evaluate the  call.
When the  call is completed, the computer returns to finish the outer computation.
The Cplus_plus language places no restrictions on how  calls are used in function definitions.
However, in order for a  function definition to be useful, it must be designed so that any call of the function must ultimately terminate with some piece of code that does not depend on recursion.
The function may call itself, and that  call may call the function again.
How recursion works How recursion ends 798 Chapter 14 / Recursion The process may be repeated any number of times.
However, the process will not terminate unless eventually one of the  calls does not depend on recursion.
The general outline of a successful recursive function definition is as follows:.
One  more cases in which the function accomplishes its task by using recursive calls to accomplish one  more smaller versions of the task.
One  more cases in which the function accomplishes its task without the use of any recursive calls.
These cases without any recursive calls are called base cases  stopping cases.
Often, an if-else statement determines which of the cases will be executed.
A typical scenario is for the original function call to execute a case that includes a recursive call.
That recursive call may in turn execute a case that requires another recursive call.
For some number of times each recursive call produces another recursive call, but eventually one of the stopping cases should apply.
Every call of the function must eventually lead to a stopping case,  else the function call will never end because of an infinite chain of recursive calls.
This is how we designed the function write_vertical in Display 14_0_1.
When the function write_vertical is called, that call produces a recursive call with a smaller argument.
This continues with each recursive call producing another recursive call until the argument is less than 10.
When the argument is less than 10, the function call ends without producing any more recursive calls and the process works its way back to the original call and then ends.
General Form of a Recursive Function Definition The general outline of a successful recursive function definition is as follows: ■ One  more cases that include one  more recursive calls to the function being defined.
These recursive calls should solve "smaller" versions of the task performed by the function being defined.
These cases without any recursive calls are called base cases  stopping cases.
Infinite Recursion In the example of the function write_vertical discussed in the previous subsections, the series of recursive calls eventually reached a call of the function that did not involve recursion (that is, a stopping case was reached).
If, on the other hand, every recursive call produces another recursive call, then a call to the function will, in theory, run forever.
This is called infinite recursion.
In practice, such a function will typically run until the computer runs out of resources and the program terminates abnormally.
Phrased another way, a recursive definition should not be "recursive all the way down_0_" Otherwise, like the lady's explanation of the universe given at the start of this chapter, a call to the function will never end, except perhaps in frustration.
Examples of infinite recursion are not hard to come by.
The following is a syntactically correct Cplus_plus function definition, which might result from an attempt to define an alternative version of the function write_vertical:.
If you embed this definition in a program that calls this function, the compiler will translate the function definition to machine code and you can execute the machine code.
Moreover, the definition even has a certain reasonableness to it.
It says that to output the argument to new_write_ vertical, first output all but the last digit and then output the last digit.
However, when called, this function will produce an infinite sequence of recursive calls.
If you call new_write_vertical(12), that execution will stop to execute the recursive call new_write_vertical (12/10), which is equivalent to new_write_vertical(1).
The execution of that recursive call will, in turn, stop to execute the recursive call new_write_vertical(1/10);.
Since the definition of new_write_vertical has no stopping case, the process will proceed forever (or until the computer runs out of resources).
Write a recursive void function that has one parameter which is a positive integer and that writes out that number of asterisks '*' to the screen all on one line.
Write a recursive void function that has one parameter, which is a positive integer.
When called, the function writes its argument to the screen backward.
That is, if the argument is 1234, it outputs the following to the screen: 4321 4.
Write a recursive void function that takes a single int argument  and writes the integers 1, 2,.
Write a recursive void function that takes a single int argument  and writes integers , -1,.
A stack is a very specialized kind of memory structure that is analogous to a stack of paper.
In 14_0_1 Recursive Functions for Tasks this analogy there is an inexhaustible supply of extra blank sheets of paper.
To place some information in the stack, it is written on one of these sheets of paper and placed on top of the stack of papers.
To place more information in the stack, a clean  of paper is taken, the information is written on it, and this new  of paper is placed on top of the stack.
In this straightforward way, more and more information may be placed on the stack.
Getting information out of the stack is also accomplished by a very simple procedure.
The top  of paper can be read, and when it is no longer needed, it is thrown away.
There is one complication: Only the top  of paper is accessible.
In order to read, say, the third  from the top, the top two sheets must be thrown away.
Since the last  that is put on the stack is the first  taken off the stack, a stack is often called a last-in/first-out (LIFO) memory structure.
Using a stack, the computer can easily keep track of recursion.
Whenever a function is called, a new  of paper is taken.
The function definition is copied onto this  of paper, and the arguments are plugged in for the function parameters.
Then the computer starts to execute the body of the function definition.
When it encounters a  call, it stops the computation it is doing on that  in order to compute the  call.
But before computing the  call, it saves enough information so that, when it does finally complete the  call, it can continue the stopped computation.
This saved information is written on a  of paper and placed on the stack.
A new  of paper is used for the  call.
The computer writes a second copy of the function definition on this new  of paper, plugs in the arguments for the function parameters, and starts to execute the call.
When it gets to a  call within the recursively called copy, it repeats the process of saving information on the stack and using a new  of paper for the new  call.
This process is illustrated in the earlier subsection entitled "Tracing a Recursive Call_0_" Even though we did not call it a stack in that section, the illustrations of computations placed one on top of the other demonstrate the actions of the stack.
This process continues until some  call to the function completes its computation without producing any more  calls.
When that happens, the computer turns its attention to the top  of paper on the stack.
This  contains the partially completed computation that is waiting for the  computation that just ended.
So, it is possible to proceed with that suspended computation.
When that suspended computation ends, the computer discards that  of paper, and the suspended computation that is below it on the stack becomes the computation on top of the stack.
The computer turns its attention to the suspended computation that is now on the top of the stack, and so forth.
The process continues until the computation on the bottom  is completed.
Depending on how many  calls are made and how the function definition is written, the stack may grow and shrink in any fashion.
Notice that the sheets in the stack can only be accessed in a last-in/first-out fashion, but that is exactly what is needed to keep track of  calls.
Each suspended version is waiting for the completion of the version directly above it on the stack.
This is just an analogy.
The computer uses portions of memory rather than pieces of paper.
The contents of one of these portions of memory ("sheets of paper") is called an activation frame.
These activation frames are handled in the last-in/first-out manner we just discussed.
However, an activation frame contains enough information to allow the computer to act as if the frame contained a Stack A stack is a last-in/first-out memory structure.
The first item referenced or removed from a stack is always the last item entered into the stack.
Stacks are used by computers to keep track of recursion (and for other purposes).
Pitfall Stack Overflow There is always some limit to the size of the stack.
If there is a long chain in which a function makes a  call to itself, and that call results in another  call, and that call produces yet another  call, and so forth, then each  call in this chain will cause another activation frame to be placed on the stack.
If this chain is too long, then the stack will attempt to grow beyond its limit.
This is an error condition known as a stack overflow.
If you receive an error message that says stack overflow, it is likely that some function call has produced an excessively long chain of calls.
One common cause of stack overflow is infinite recursion.
If a function is recursing infinitely, then it will eventually try to make the stack exceed any stack size limit.
Any task that can be accomplished using recursion can also be done in some other way without using recursion.
For example, Display 14_0_2 contains a nonrecursive version of the function given in Display 14_0_1.
The nonrecursive version of a function typically uses a loop (or loops) of some sort in place of recursion.
For that reason, the nonrecursive version is usually referred to as an iterative version.
If the definition of the function write_ vertical given in Display 14_0_1 is replaced by the version given in Display 14_0_2, then the output will be the same.
As is true in this case, a version of a function can sometimes be much simpler than an iterative version.
A recursively written function will usually run slower and use more storage than an equivalent iterative version.
Although the iterative version of write_ vertical given in Display 14_0_2 looks like it uses more storage and does more computing than the recursive version in Display 14_0_1, the two versions of write_vertical actually use comparable storage and do comparable amounts of computing.
In fact, the recursive version may use more storage and run somewhat slower, because the computer must do a good deal of work manipulating the stack in order to keep track of the recursion.
However, since the system does all this for you automatically, using recursion can sometimes make your job as a programmer easier and can sometimes produce code that is easier to understand.
As you will see in the examples in this chapter and in the Self-Test Exercises and Programming Projects, sometimes a recursive definition is simpler and clearer; other times, an iterative definition is simpler and clearer.
S el f -T est Exe r cis es 6.
If your program produces an error message that says stack overflow, what is a likely source of the error.
Write an iterative version of the function cheers defined in Self-Test Exercise 1.
Write an iterative version of the function defined in Self-Test Exercise 2.
Write an iterative version of the function defined in Self-Test Exercise 3.
Trace the recursive solution you made to Self-Test Exercise 4.
Trace the recursive solution you made to Self-Test Exercise 5.
Anonymous General Form for a Recursive Function That Returns a Value The recursive functions you have seen thus far are all void functions, but recursion is not limited to void functions.
A recursive function can return a value of any type.
The technique for designing recursive functions that return a value is basically the same as for void functions.
An outline for a successful recursive function definition that returns a value is as follows.
As was the case with void functions, the arguments for the recursive calls should Programming Example   Another Powers Function In Chapter 4 we introduced the predefined  pow that computes powers.
For example, pow(2_0_0,3_0_0) returns 2_0_03_0_0, so the following sets the variable  equal to 8_0_0: double  = pow(2_0_0, 3_0_0); The  pow takes two arguments of type double and returns a value of type double.
Display 14_0_3 contains a recursive definition for a  that is similar but that works with the type int rather than double.
This new  is called power.
For example, the following will set the value of  equal to 8, since 23 is 8: int  = power(2, 3); 14_0_2 Recursive Functions for Values Display 14_0_3   The Recursive Function power 1 2 3 4.
Sample Dialogue 3 to the power 0  1 3 to the power 1  3 3 to the power 2  9 3 to the power 3  27 Our main reason for defining the  power  to have a simple example of a recursive , but there are situations in which the power would be preferable to the  pow.
The  pow returns values of type double, which are only approximate quantities.
The  power returns values of type int, which are exact quantities.
In some situations, you might need the additional accuracy provided by the  power.
Chapter 14 / Recursion The definition of the  power  based on the following formula: equal to  -1 * should be the same as the value of the expression power(,  - 1) * The definition of the  power given in Display 14_0_3 does return this value for power(, ), provided  > 0.
The case where   equal to 0  the stopping case.
If   0, then power(,) simply returns 1 (since 0  1).
Let's see what happens when the  power  called with some sample values.
First consider the following simple expression: When the   called, the value of   set equal to 2, the value of set equal to 0, and the code in the body of the  definition  executed.
Since the value of   a legal value, the if-else statement  executed.
Since this value of   not greater than 0, the return statement after the else  used, so the  call returns 1.
Thus, the following would set the value of  equal to 1: int  = power(2, 0);.
When the   called, the value of   set equal to 2, the value of set equal to 1, and the code in the body of the  definition  executed.
Since this value of   greater than 0, the following return statement  used to determine the value returned: return ( power(,  - 1) *  );.
At this point the computation of power(2,1)  suspended, a copy of this suspended computation  placed on the stack, and the computer then starts a new  call to compute the value of power(2,0).
As you have already seen, the value of power(2,0)  1.
After determining the value of power(2,0), the computer replaces the expression power(2,0) with its value of 1 and resumes the suspended computation.
The resumed computation determines the final value for power(2,1) from the return statement above as follows: power(2, 0) * 2  1 * 2, which  2.
The value of power(2, 3)  calculated as follows: power(2, power(2, power(2, power(2,.
After calculating the value returned for the stopping case, it resumes the most recently suspended computation to determine the value of power(2,1).
After that, the computer completes each of the other suspended computations, using each value computed as a value to plug into another suspended computation, until it reaches and completes the computation for the original call, power(2,3).
The details of the entire computation are illustrated in Display 14_0_4.
Sequence of recursive calls How the final value  computed 1.
Redefine the  power so that it also works for negative exponents.
In order to do this, you will also have to change the type of the value returned to double.
The  declaration and header comment for the redefined version of power is as follows: double power(int x, int );.
Anonymous Recursive Design Techniques When defining and using recursive functions you do not want to be continually aware of the stack and the suspended computations.
The power of recursion comes from the fact that you can ignore that detail and let the computer do the bookkeeping for you.
Consider the example of the  power in Display 14_0_3.
The way to think of the definition of power is as follows: power(x, ) returns power (x,  - 1) * x Since x  is equal to x –1 * x, this is the correct value to return, provided that the computation will always reach a stopping case and will correctly compute the stopping case.
So, after checking that the recursive part of the definition is correct, all you need check is that the chain of recursive calls will always reach a stopping case and that the stopping case always returns the correct value.
When you design a recursive , you need not trace out the entire sequence of recursive calls for the instances of that  in your program.
If the  returns a value, all that you need do is confirm that the following three properties are satisfied: 1.
There is no infinite recursion.
Each stopping case returns the correct value for that case.
For the cases that involve recursion: If all recursive calls return the correct value, then the final value returned by the function is the correct value.
For example, consider the function power in Display 14_0_3: 1.
There is no infinite recursion: The second argument to power(x,) is decreased by 1 in each recursive call, so any chain of recursive calls must eventually reach the case power(x,0), which is the stopping case.
Thus, there is no infinite recursion.
Criteria for functions that return a value 810 Chapter 14 / Recursion 2.
Each stopping case returns the correct value for that case: The only stopping case is power(x,0).
A call of the form power(x,0) always returns 1, and the correct value for x0 is 1.
So the stopping case returns the correct value.
For the cases that involve recursion—if all recursive calls return the correct value, then the final value returned by the function is the correct value: The only case that involves recursion is when >1.
When >1, power(x,) returns power(x,  – 1) * x.
That's all you need to check in order to be sure that the definition of power is correct.
However, you do not need to We gave you three criteria to use in checking the correctness of a recursive function that returns a value.
Basically, the same rules can be applied to a recursive void function.
If you show that your recursive void function definition satisfies the following three criteria, then you will know that your void function performs correctly: Criteria for void functions 1.
There is no infinite recursion.
Each stopping case performs the correct action for that case.
For each of the cases that involve recursion: If all recursive calls perform their actions correctly, then the entire case performs correctly.
Case Study Binary Search—An Example of Recursive Thinking In this case study we develop  recursive function that searches an array to find out whether it contains  specified value.
For example, the array may contain list of numbers for credit cards that are no longer valid.
A store clerk needs to search the list to see if  customer's card is valid or invalid.
In Chapter 7 (Display 7_0_10) we discussed  simple method for searching an array by simply checking every array element.
In this section we will develop  method that is much faster for searching  sorted array.
The indexes of the array  are the integers 0 through final_index.
In order to make the task of searching the array easier, we assume that the array is sorted.
Hence, we know the following: [0] <= [1] <= [2] <= _0__0_.
For example, if we are searching for  credit card number, then the array index may serve as  record number.
Another array indexed by these same indexes may hold  phone number or other information to use for reporting the suspicious card.
Hence, if the sought-after value is in the array, we will want our function to tell where that value is in the array.
Problem Definition We will design our function to use two call-by-reference parameters to return the outcome of the search.
One parameter, called , will be of type bool.
If the value is , then  will be set to true.
If the value is , then another parameter, called , will be set to the index of the value If we use key to denote the value being searched for, the task to be accomplished can be formulated precisely as follows: Precondition: [0] through [final_index] are sorted in increasing order.
Postcondition: if key is not one of the values [0] through [final_ index], then  == false; otherwise, [] == key and  == true.
Algorithm Design Now let us proceed to produce an algorithm to solve this task.
It will help to visualize the problem in very concrete terms.
Suppose the list of numbers is so long that it takes  book to list them all.
This is in fact how invalid credit card numbers are distributed to stores that do not have access to computers.
If you are  clerk and are handed  credit card, you must check to see if it is on the list and hence invalid.
Open the book to the middle and see if the number is there.
If it is not and it is smaller than the middle number, then work backward toward the beginning of the book.
If the number is larger than the middle number, you work your way toward the end of the book.
This idea produces our first draft of an algorithm: = false; //so far.
Since the searchings of the shorter lists are smaller versions of the very task we are designing the algorithm to perform, this algorithm naturally lends Algorithm—first version 812 Chapter 14 / Recursion itself to the use of recursion.
The smaller lists can be searched with recursive calls to the algorithm itself.
Our pseudocode is  bit too imprecise to be easily translated into Cplus_plus code.
The problem has to do with the recursive calls.
There are two recursive calls shown: search [0] through [ - 1]; and search [ + 1] through [final_index]; More parameters Algorithm—first refinement Stopping case algorithm—final version To implement these recursive calls, we need two more parameters.
A recursive call specifies that  subrange of the array is to be searched.
In one case it is the elements indexed by 0 through -1.
In the other case it is the elements indexed by +1 through final_index.
The two extra parameters will specify the first and last indexes of the search, so we will call them first and last_0_Using these parameters for the lowest and highest indexes, instead of 0 and final_index, we can express the pseudocode more precisely as follows: To search [first] through [last] do the following: = false; //so far.
The recursive calls will use other values for first and last.
For example, the first recursive call would set first equal to 0 and last equal to the calculated value -1.
As with any recursive algorithm, we must ensure that our algorithm ends rather than producing infinite recursion.
If the sought-after number is on the list, then there is no recursive call and the process terminates, but we need some way to detect when the number is not on the list.
On each recursive call, the value of first is increased or the value of last is decreased.
If they ever pass each other and first actually becomes larger than last, then we will know that there are no more indexes left to check and that the number is not in the array.
If we add this test to our pseudocode, we obtain complete solution as shown in Display 14_0_5.
Coding Now we can routinely translate the pseudocode into Cplus_plus code.
The result is shown in Display 14_0_6.
The function search is an implementation of the recursive algorithm given in Display 14_0_5.
A diagram of how the function performs on  sample array is given in Display 14_0_7.
Display 14_0_5   Pseudocode for Binary Search int [Some_Size_Value];.
To locate the value : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15.
Chapter 14 / Recursion <This portion of the program contains some code to fill and sort the array a.
The exact details are irrelevant to this example_0_> 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59.
Display 14_0_7   Execution of the Function search is 63 a[0⋅ ] 15.
Chapter 14 / Recursion Solve  more general problem Notice that the function search solves  more general problem than the original task.
Our goal was to design  function to search an entire.
Yet the function will let us search any interval of the  by specifying the index bounds  and.
This is common when designing recursive functions.
Frequently, it is necessary to solve  more general problem in order to be able to express the recursive algorithm.
In this case, we only wanted the answer in the case where  and  are set equal to 0 and final_index.
However, the recursive calls will set them to values other than 0 and final_index.
Checking the Recursion In the subsection entitled "Recursive Design Techniques," we gave three criteria that you should check to ensure that  recursive void function definition is correct.
Let's check these three things for the function search given in Display 14_0_6.
There is no infinite recursion: On each recursive call, the value of  is increased or the value of  is decreased.
Each stopping case performs the correct action for that case: There are two stopping cases: when  >  and when ==[].
Let's consider each case.
Thus, both stopping cases are correct.
For each of the cases that involve recursion, if all recursive calls perform their actions correctly, then the entire case performs correctly: There are two cases in which there are recursive calls: when  < [] and when  > [].
We need to check each of these two cases.
First suppose  < [].
In this case, since the array is sorted, we know that if  is anywhere in the array, then  is one of the elements [] through [-1].
Thus, the function need only search these elements, which is exactly what the recursive call search(, ,  - 1, , , ); does.
So if the recursive call is correct, then the entire action is correct.
Next, suppose  > [].
In this case, since the array is sorted, we know that if  is anywhere in the array, then  is one of the elements [+1] through [].
Thus, the function need search only these elements, which is exactly what the recursive call 14_0_3 Thinking Recursively.
So if the recursive call is correct, then the entire action is correct.
Thus, in both cases the function performs the correct action (assuming that the recursive calls perform the correct action).
The function search passes all three of our tests, so it is  good recursive function definition.
Efficiency The binary search algorithm is extremely fast compared to an algorithm that simply tries all array elements in order.
In the binary search, you eliminate about half the array from consideration right at the start.
You then eliminate  quarter, then an eighth of the array, and so forth.
These savings add up to  dramatically fast algorithm.
For an array of 100 elements, the binary search will never need to compare more than 7array elements to the.
A simple serial search could compare as many as 100 array elements to the  and on the average will compare about 50 array elements to the.
Moreover, the larger the array is, the more dramatic the savings will be.
On an array with 1000 elements, the binary search will need to compare only about 10 array elements to the  value, as compared to an average of 500 for the simple serial search algorithm.
An iterative version of the function search is given in Display 14_0_8.
On some systems, the iterative version will run more efficiently than the recursive version.
The algorithm for the iterative version was derived by mirroring the recursive version.
In the iterative version, the local variables  and mirror the roles of the parameters in the recursive version, which are also named and.
As this example illustrates, it often makes sense to derive recursive algorithm even if you expect to later convert it to an iterative algorithm.
Iterative version Function Declaration 1 2 3 4 5 6 7.
Function Definition 1 2 3 4 5 void search(const int [], int low_end, int high_end,.
Programming Example   A Recursive Member Function A member function of a class can be recursive.
Member functions can use recursion in the same way that ordinary functions do.
Display 14_0_9 contains an example of a recursive member function.
The class BankAccount used in that display is the same as the class named BankAccount that was defined in Display 10_0_6, except that we have overloaded the member function name update.
The   of update has no arguments and posts one year of simple interest to the bank account balance.
The other ()  of update takes an int argument that is some number of years.
This member function updates the account by posting the interest for that many years.
The of update is recursive;has one parameter, called years; and uses the following algorithm: If the number of years is 1, then //Stopping case: call the other function named update (the one with no arguments).
If the number of years is greater than 1, then //Recursive case: make a recursive call to post years-1 worth of interest, and then call  the other function called update (the one with no arguments) to post one more year's worth of interest.
Two different functions with the same name 28 29 30 31 32 33 34 35 36 void output(ostream& outs); //Precondition: If outs is a file output stream, then outs has already.
There is no infinite recursion: Each recursive call reduces the number of by 1 until the number of  eventually becomes 1, which is the stopping case.
So there is no infinite recursion.
Each stopping case performs the correct action  that case: The one stopping case is when ==1.
This case produces the correct action, since it simply calls the other overloaded member function called update, and we checked the correctness of that function in Chapter 10.
For the cases that involve recursion, if all recursive calls perform correctly, then the entire case performs correctly: The recursive case—that is, >1—works correctly, because if the recursive call correctly posts -1 worth of interest, then all that is needed is to post one additional year's worth of interest and the call to the overloaded zero-argument version of update will correctly post one year's worth of interest.
Thus, if the recursive call performs the correct action, then the entire action for the case of >1 will be correct.
In this example, we have overloaded update so that there are two different functions named update: one that takes no arguments and one that takes a single argument.
Do not confuse the calls to the two functions named update.
These are two different functions that, as far as the compiler is concerned, just coincidentally happen to have the same name.
When the definition of the function update with one argument includes a call to the version of update that takes no arguments, that is not a recursive call.
Only the call to the version of update with the exact same function declaration is a recursive call.
To see what is involved here, note that we could have named the version of update that takes no argument post_one_year(), instead of naming it update(), and then the definition of the recursive version of update would read as follows:.
Recursion and Overloading Do not confuse recursion and overloading.
When you overload a function name, you are giving two different functions the same name.
If the definition of one of these two functions includes a call to the other, that is not recursion.
In a recursive function definition, the definition of the function includes a call to the exact same function with the exact same definition, not to some other function that coincidentally uses the same name.
It is not too serious an error if you confuse overloading and recursion, since they are both legal.
It is simply a question of getting the terminology straight so that you can communicate clearly with other programmers and so that you understand the underlying processes.
Write a recursive function definition for the following function:.
Write an iterative version of the one-argument member function BankAccount::update(int ) that is described in Display 14_0_9.
Chapter Summary ■ If a problem can be reduced to smaller instances of the same problem, then a recursive solution is likely to be easy to find and implement.
This may be required to allow for the proper recursive calls, since the smaller problems may not be exactly the same problem as the given task.
For example, in the binary search problem, the task was to search an entire array, but the recursive solution is an algorithm to search any portion of the array (either all of it or a part of it).
Answers to Self - Test Exerci ses.
An error message that says stack overflow is telling you that the computer has attempted to place more activation frames on the stack than are allowed on your system.
A likely cause of this error message is infinite recursion.
The recursions unwind; the output (obtained while recursion was winding up) is 1 2 3.
Trace for Exercise 5:   = 3, the code to be executed is.
The function is the factorial function, usually written.
Practice Programs Practice Programs can generally be solved with a short program that directly applies the programming principles presented in this chapter.
Write a recursive function definition for a function that has one parameter of type int and that returns the nth Fibonacci number.
See Programming Project 6 in Chapter 3 for the definition of Fibonacci numbers.
Embed the function in a program and test it.
Write a recursive version of the function index_of_smallest that was used in the sorting program in Display 7_0_12 of Chapter 7.
Embed the function in a program and test it.
Write a recursive version of the search function in Display 7_0_10 of Chapter 7.
There are  people in a room, where  is an integer greater than or equal to 2.
Each person shakes hands once with every other person.
What is the total number of handshakes in the room.
Write a recursive function to solve this problem, with the following header: where () returns the total number of handshakes for  people.
You will have to define a suitable stopping condition.
Test your function with several palindromes and nonpalindromes.
Programming Projects Programming Projects require more problem-solving than Practice Programs and can usually be solved many different ways.
Visit www_0_myprogramminglab_0_com to complete many of these Programming Projects online and get instant feedback.
The formula for computing the number of ways of choosing  different things from a set of  things is the following: VideoNote Solution to Practice Program 14_0_4 827.
Chapter 14 / Recursion The factorial function.
Embed the function in  program and test it.
Write  recursive function that has an argument that is an array of characters and two arguments that are bounds on array indexes.
The function should reverse the order of those entries in the array whose indexes are between the two bounds.
For example,  the array is [0] == '' [1] == '' [2] == '' [3] == '' [4] == '' and the bounds are 1 and 4, then after the function is run the array elements should be [0] == '' [1] == '' [2] == '' [3] == '' [4] == '' Embed the function in  program and test it.
After you have fully debugged this function, define another function that takes  single argument which is an array that contains  string value and that reverses the spelling of the string value in the array argument.
This function will   call to the recursive definition you did for the first part of this project.
Embed this second function in  program and test it.
Write an iterative version of the recursive function in Programming Project 1.
Embed it in  program and test it.
VideoNote Solution to Practice Program 14_0_4 4.
Write  recursive function to sort an array of integers into ascending order using the following idea: Place the smallest element in the first position, then sort the rest of the array by  recursive call.
This is  recursive version of the selection sort algorithm discussed in Chapter 7.
The function to do the sorting must 5.
Towers of Hanoi: There is  story about Buddhist monks who are playing this puzzle with 64 stone disks.
The story claims that when the monks finish moving the disks from one post to  second via the third post, time will end.
The task is to move the disks one at  time from the first post to the second.
To do this, any disk can be moved from any post to any other post, subject to the rule that you can never place  larger disk over  smaller disk.
The (spare) third post is provided to make the solution possible.
Your task is to write  recursive function that describes instructions for  solution to Programming Projects this problem.
We don't have graphics available, so you should output sequence of instructions that will solve the problem.
Then by using the same technique (whatever that may be) you can move the −1 disks from the third post to the second post, using the first disk as  spare.
You have the puzzle solved.
You only have to decide what the nonrecursive case is, what the recursive case is, and when to output instructions to 6.
The game of "Jump It" consists of  board with  positive integers in  row, except for the first column, which always contains 0.
These numbers represent the cost to enter each column.
Here is  sample game board where  is 6: 0 3.
The number in each column represents the cost to enter that column.
You always start the game in the first column and have two types  moves.
You can either move to the adjacent column or jump over the adjacent column to land two columns over.
The cost game is the sum  the costs  the columns visited.
In the board shown above, there are several ways to get to the end.
Starting in the first column, our cost so far is 0.
We could jump to 80, then jump to 57, then move to 10 for  total cost  80 + 57 + 10 = 147.
However,  cheaper path would be to move to 3, jump to 6, then jump to 10, for  total cost  3 + 6 + 10 = 19.
Write  recursive solution to this problem that computes the lowest cost the game and outputs this value for an arbitrarily large game board represented as an array.
Your program doesn't have to output the actual sequence  jumps, only the lowest cost  this sequence.
After making sure that your solution works on small arrays, test it on boards  larger and larger values   to get  feel for the scalability and efficiency  your solution.
Suppose we can buy chocolate bars from the vending machine for $1 each.
Inside every chocolate bar is  coupon.
We can redeem 7 coupons for 1 chocolate bar from the machine.
We would like to know how many chocolate bars can be eaten, including those redeemed via coupon, if we have  dollars.
For example, if we have $20, then we can initially buy 20 chocolate bars.
This gives us 20 coupons.
We can redeem 14 coupons for 2 additional chocolate bars.
These two additional chocolate bars have 2 more coupons, 829.
Chapter 14 / Recursion so we now have  total  8 coupons when added to the 6 left over from the original purchase.
This gives us enough to redeem for 1 final chocolate bar.
As  result we now have 23 chocolate bars and 2 leftover coupons.
Write  recursive solution to this problem that inputs from the user the number  dollars to spend on chocolate bars and outputs how many chocolate bars you can collect after spending all your money and redeeming as many coupons as possible.
Your recursive function will be based upon the number  coupons owned.
For  set   items { 1, 2, 3,.
For example, given the set {1, 2, 3} there are six permutations: {3, 2, 1} {2, 3, 1} {2, 1, 3} {3, 1, 2} {1, 3, 2} {1, 2, 3} Write  recursive function that generates all the permutations   set numbers.
The general outline   solution is given here, but the implementation is up to you.
The program will require storing  set permutations  numbers that you can implement in many ways (for example, linked lists  nodes, linked lists  vectors, arrays, etc_0_) Your program should call the recursive function with sets  several different sizes, printing the resulting set  permutations for each.
One solution is to first leave out the n th item in the set.
Recursively find all permutations using the set  (n−1) items.
If we insert the nth item into each position for all  these permutations, then we get a new set  permutations that includes the n th item.
The base case is when there is only one item in the set, in which case the solution is simply the permutation with the single item.
For example, consider finding all permutations  {1, 2, 3}.
We leave the 3 out and recursively find all permutations  the set {1, 2}.
This consists  the permutations:.
Next we insert the 3 into every position for these permutations.
For the first permutation, we insert the 3 in the front, between 1 and 2, and after 2.
For the second permutation, we insert the 3 in the front, between 2 and 1, and after 1:.
Programming Projects 9.
The word ladder game was invented by Lewis Carroll in 1877.
The idea is to begin with a start word and change one letter at a time until arriving at an end word.
Each word along the way must be an English word.
For example, starting from FISH you can make a word ladder to MAST through the following ladder: FISH, WISH, WASH, MASH, MAST Write a program that uses recursion to find the word ladder given a start word and an end word, or determines if no word ladder exists.
Use the file words_0_txt that is available online with the source code for the book as your dictionary  valid words.
This file contains 87314 words.
Your program does not need to find the shortest word ladder between words, any word ladder will do if one exists.
Inheritance 15_0_1 Inheritance Basics   834 Derived Classes   837 Constructors in Derived Classes   845 Pitfall: Use  Private Member Variables from the Base    848 Pitfall: Private Member Functions Are Effectively Not Inherited   850 The protected Qualifier   850 Redefinition  Member Functions   853 Redefining Versus Overloading   856 Access to a Redefined Base Function   858 15_0_3 Polymorphism   862 Late Binding   863 Virtual Functions in Cplus_plus   864 Virtual Functions and Extended Type Compatibility   869 Pitfall: The Slicing Problem   873 Pitfall: Not Using Virtual Member Functions   874 Pitfall: Attempting to Compile  Definitions Without Definitions for Every Virtual Member Function   875 Programming Tip: Make Destructors Virtual   875 15_0_2 Inheritance Details   859 Functions That Are Not Inherited   859 Assignment Operators and Copy Constructors in Derived Classes   860 Destructors in Derived Classes   861 Chapter Summary   877 Answers to Self-Test Exercises   877 15 Practice Programs   881 Programming Projects   884 With all appliances and means to boot.
William Shakespeare, King Henry IV, Part III Introduction Object-oriented programming is a popular and powerful programming technique.
Among other things, it provides for a new  of abstraction known as inheritance.
This means that a very general form of a class can be defined and compiled.
Later, more specialized versions of that class can be defined and can inherit all the properties of the previous class.
Facilities for inheritance are available in all versions of Cplus_plus.
Prerequisites Section 15_0_1 uses material from Chapters 2 to 8 and 10 to 12.
Sections 15_0_2 and 15_0_3 use material from Chapters 9 and 13 in addition to Chapters 2 to 8, 10 to 12, and Section 15_0_1.
Carl Gustav Jung, The Integration of the Personality One of the most powerful features of Cplus_plus is the use of inheritance to derive one  from another.
Inheritance is the process by which a new — known as a derived —is created from another , called the base.
A derived  automatically has all the member variables and functions that the base  has and can have additional member functions and/or additional member variables.
In Chapter 10, we noted that saying that  D is derived from another B means that  D has all the features of  B and some extra, added features as well.
When a  D is derived from a  B, we say that B is the base  and D is the derived.
We also say that D is the child  and B is the parent _0_1 Some authors speak of a subclass D and superclass B instead of derived  D and base B.
However, we have found the terms derived  and base  to be less confusing.
We only mention this in an effort to help you to read other texts.
You would like to control and interrogate the status of these devices (e_0_g_0_, door is open, thermostat set to 80 degrees) from your computer.
This would be much easier to accomplish if there was a consistent interface for these disparate devices.
Inheritance lets us do this while providing a way to organize our code without duplication.
First, consider the general concept of a device in the home automation system.
Every device must have a model and serial number.
Perhaps every device also has a way to query its status.
We could model this with a Device that has variables for the model and serial number, and a function for the status.
The idea is that this  contains functions and properties that are common to every possible device.
Second, consider the garage door.
This is a specific type of device in the automation system.
In addition to having a model, serial number, and way to query its status like every other device, the garage door device also has a specific function to open or close the door.
We can model the garage door with a DoorDevice.
We will need to add an openClose() function to this.
The DoorDevice  is also where we would know how to return the status of the device.
At the level of the generic Device  we don't have the needed information to return the status of a specific device because at that level we don't even know what kind of device we are working with.
While we need to add functions to DoorDevice for the status and to open/ close the door, it would be nice if we didn't have to duplicate the variables and code to manipulate the model and serial number that we wrote for the Device.
Similarly, the thermostat device will also have a model, serial number, and way to query its status in addition to a function to set the temperature.
We can define a ThermostatDevice  with functions to set the temperature and return the status of the device, but it would be nice if we didn't again have to duplicate the variables and code to manipulate the model and serial number that we wrote for the Device.
We can solve this problem with inheritance.
In this case, DoorDevice "IS-A" Device and ThermostatDevice "IS-A" Device.
By defining DoorDevice and ThermostatDevice as derived classes from Device, then these classes (if the programmer specifies it) have access to the model and serial number defined in Device and we don't need to re-write any code in the Device that deals with these variables.
At the same time we can add specific code that is unique to our derived classes.
The relationship between these classes is illustrated in Display 15_0_1.
Once the inheritance relationship is defined, then if we create an object of type DoorDevice or ThermostatDevice we will have access to functions and variables defined in Device.
For example, if thermostat is a variable of type ThermostatDevice then we could access thermostat_0_model if model is a 835.
Display 15_0_1   Example Inheritance Hierarchy for Home Automation ­Devices base or parent Device string model.
IS-A inherits model and serialNumber from Device derived or child ThermostatDevice An object of type DoorDevice or ThermostatDevice includes functions and variables defined in Device, such as model and serialNumber.
The status() function can be overridden.
If a DoorDevice object is treated like a Device object, then calling status() will invoke DoorDevice's status() function, not Device's status() function.
This is necessary when the Device  doesn't know what to return as a status and only the derived classes can return the information.
This saves us the work of redefining the code and variables from the Device.
We can specify the status() function to behave a bit differently.
When we define the same function in both the base and derived classses then we will see later in the chapter that we have two options: redefine the function or override the function.
In this case we want to override the function.
If we had an object thermostat of type ThermostatDevice, but then treat thermostat instead like it is of type Device (for example, by passing thermostat to a function where the parameter is defined to be of type Device), then invoking status() will call the definition associated with ThermostatDevice rather than the definition associated with Device.
This behavior is important in this case because the Device class doesn't know what to return as the status.
This topic is explored in more detail in section 15_0_3.
We discussed how a CD account is a more specialized version of a savings account.
By deriving the class CDAccount from SavingsAccount, we automatically inherit all of the SavingsAccount public functions and variables when we create a CDAccount object.
Cplus_plus uses inheritance in predefined classes as well.
In using streams for file I/O, the predefined class ifstream is derived from the (predefined) class istream by adding member functions such as open and close.
The stream cin belongs to the class of all input streams (that is, the class istream), but it does not belong to the class of input-file streams (that is, does not belong to ifstream), partly because it lacks the member functions open and close of the derived class ifstream.
Derived Classes Suppose we are designing a record-keeping program that has records for salaried employees and hourly employees.
There is a natural hierarchy for grouping these classes.
These are all classes of people who share the property of being employees.
Employees who are paid an hourly wage are one subset of employees.
Another subset consists of employees who are paid a fixed wage each month or each week.
Although the program may not need any type corresponding to the set of all employees, thinking in terms of the more general concept of employees can be useful.
For example, all employees have names and Social Security numbers, and the member functions for setting and changing names and Social Security numbers will be the same for salaried and hourly employees.
Within Cplus_plus you can define a class called Employee that includes all employees, whether salaried or hourly, and then use this class to define classes for hourly employees and salaried employees.
Displays 15_0_2 and 15_0_3 show one possible definition for the class Employee.
You can have an (undifferentiated) Employee object, but our reason for defining the class Employee is so that we can define derived classes for different kinds of employees.
In particular, the function print_check will always have its definition changed in derived classes so that different kinds of employees can have different kinds of checks.
This is reflected in the definition of the function print_check for the class Employee (Display 15_0_3).
It makes little sense to print a check for such an (undifferentiated) Employee.
We know nothing about this employee's salary details.
Consequently, we implemented the function print_check of the class Employee so that the program stops with an error message if print_check is called for a base class Employee object.
As you will see, derived classes will have enough information to redefine the function print_check to produce meaningful employee checks.
A class that is derived from the class Employee will automatically have all the member variables of the class Employee (name, ssn, and net_pay).
A class that is derived from the class Employee will also have all the member functions of the class Employee, such as print_check, get_name, set_name, and the other 837.
Chapter 15 / Inheritance Display 15_0_2   Interface for the Base Class Employee 1 2 3 4 5 6 //This is the header file employee_0_h.
This is usually expressed by saying that the derived class inherits the member variables and member functions.
The interface files with the class definitions of two derived classes of the class Employee are given in Displays 15_0_4 (HourlyEmployee) and 15_0_5 (SalariedEmployee).
We have placed the class Employee and the two derived classes in the same namespace.
Cplus_plus does not require that they be in the same namespace, but since they are related classes, it makes sense to put them there.
We will first discuss the derived class HourlyEmployee given in Display 15_0_4.
Note that the definition of a derived class begins like any other class definition but adds a colon, the reserved word public, and the name of the 15_0_1 Inheritance Basics 839 1 2 3 4 5 6 7 8 9 10 11 12 13 14 //This is the file: employee_0_cpp.
You only list the declaration of an inherited member function if you want to change the definition of the function.
Display 15_0_5   Interface for the Derived Class SalariedEmployee 1 2 3 4 //This is the header file salariedemployee_0_h.
Chapter 15 / Inheritance base class to the first line of the class definition, as in the following (from Display 15_0_4): class  : public { automatically receives all the public member variables and member functions of the base class (such as Employee).
We can also add additional member variables and member functions to the derived class.
The definition of the class  does not mention the member variables name, ssn, and net_pay, but every object of the class has member variables named name, ssn, and net_pay.
These member variables are inherited from the class Employee.
The class  declares two additional member variables named wage_rate and hours.
Thus, every object of the class  has five member variables named name, ssn, net_ pay, wage_rate, and hours.
Note that the definition of a derived class (such as ) only lists the added  variables.
The variables defined in the base class are not mentioned.
Just as it inherits the  variables of the class Employee, the class inherits all the  functions from the class Employee.
So, the class  inherits the  functions get_name, get_ ssn, get_net_pay, set_name, set_ssn, set_net_pay, and print_check from the class Employee.
In addition to the inherited  variables and  functions, a derived class can add new  variables and new  functions.
The new  variables and the declarations for the new  functions are listed in the class definition.
For example, the derived class  adds the two  variables wage_rate and hours, and it adds the new functions named set_rate, get_rate, set_hours, and get_hours.
This is shown in Display 15_0_4.
Note that you do not give the declarations of the inherited functions except for those whose definitions you want to change, which is the reason we list only the  function print_check from the base class Employee.
For now, do not worry about the details of the constructor definition for the derived class.
We will discuss constructors in the next subsection.
In the implementation file for the derived class, such as the implementa­ tion of  in Display 15_0_6, you give the definitions of all the added  functions.
Note that you do not give definitions for the inherited  functions unless the definition of the  function is changed in the derived class, a point we discuss next.
The definition of an inherited  function can be changed in the definition of a derived class so that it has a meaning in the derived class that is different from what it is in the base class.
This is called redefining the inherited function.
For example, the  function print_check( ) is redefined in the definition of the derived class.
To redefine a.
Chapter 15 / Inheritance Display 15_0_6  Implementation for the Derived Class HourlyEmployee 37 38 39 40 41 42 43 44 45 46 47 48 49.
But note that Cplus_plus allows us to drop the const in the function print_check when we redefine it in a derived class.
SalariedEmployee is another example  a derived class  the class Parent and Child Classes When discussing derived classes, it is common to use terminology derived from family relationships.
A base class is often called a parent class.
A derived class is then called a child class.
This makes the language inheritance very smooth.
For example, we can say that a child class inherits member variables and member functions from its parent class.
This analogy is often carried one step further.
A class that is a parent  a iterations) is often called an ancestor class.
If class A is an ancestor class B, then class B is often called a descendant  class A.
These inherited member functions and inherited member variables are, with one exception, not mentioned in the   the derived class, but they are automatically the derived class.
As explained in the text, you do mention an inherited member function in the   the derived class if you want to change the   the inherited member function.
The interface for the class SalariedEmployee is given in Display 15_0_5.
An object declared to be  type SalariedEmployee has all the member functions and member variables  Employee and the new  given in the   the class SalariedEmployee.
This is true even though the class SalariedEmployee lists none  the inherited variables and only lists one function from the class Employee, namely, the function print_ check, which will have its  changed in SalariedEmployee.
The class SalariedEmployee, nonetheless, has the three member variables name, ssn, and net_pay, as well as the member variable salary.
Notice that you do not have to declare the member variables and member functions  the class Employee, such as name and set_name, in order for a SalariedEmployee to have these.
The class SalariedEmployee gets these inherited automatically without the programmer doing anything.
Note that the class Employee has all the code that is common to the two classes HourlyEmployee and SalariedEmployee.
This saves you the trouble writing identical code two times, once for the class HourlyEmployee and once for the class SalariedEmployee.
Inheritance allows you to reuse the code in the class Employee.
Constructors in Derived Classes A constructor in a base class is not inherited in the derived class, but you can invoke a constructor  the base class within the   a derived class constructor, and that is all you need or normally want.
A constructor for a derived class uses a constructor from the base class in a special way.
A constructor for the base class initializes all the data inherited from the base class.
Thus, a constructor for a derived class begins with an invocation  a constructor for the base class.
There is a special syntax for invoking the base class constructor that is 845.
Chapter 15 / Inheritance illustrated by the constructor definitions for the class HourlyEmployee given in Display 15_0_6.
In what follows we have reproduced (with minor changes in the line breaks to make it fit the text column) one  the constructor definitions for the class HourlyEmployee taken from that display: HourlyEmployee::HourlyEmployee(string the_name, string the_number, double the_wage_rate,.
The portion after the colon is the initialization section  the constructor for the constructor HourlyEmployee::HourlyEmployee.
The part Employee(the_name, the_number) is an invocation  the two-argument constructor for the base class Employee.
Note that the syntax for invoking the base class constructor is analogous to the syntax used to set member variables: The entry (the_wage_rate) sets the value  the member variable invokes the base class constructor Employee with the arguments the_name and the_number.
Since all the work is done in the initialization section, the body the constructor  is empty.
Here we reproduce the other constructor for the class HourlyEmployee from Display 15_0_6:.
In this constructor  the default (zero-argument) version  the base class constructor is called to initialize the inherited member variables.
You should always include an invocation  one  the base class constructors in the initialization section  a derived class constructor.
If a constructor  for a derived class does not include an version  the base class constructor will be invoked automatically.
So, the following   the default constructor for the class HourlyEmployee (with Employee( ) omitted) is equivalent to the version we just discussed:.
In Cplus_plus the same sort  thing holds.
Since HourlyEmployee is a derived class  the class Employee, every object  the class HourlyEmployee can be used anywhere an object  the class Employee can be used.
In particular, you can use an argument  type HourlyEmployee when a function requires an argument of type Employee.
You can assign an object of the class HourlyEmployee to a variable of type Employee.
After all, an Employee is not necessarily an HourlyEmployee_0_) Of course, the same remarks apply to any base class and its derived class.
You can use an object of a derived class anywhere that an object of its base class is allowed.
More generally, an object of a class type can be used anywhere that an object of any of its ancestor classes can be used.
If class Child is derived from class Ancestor and class Grandchild is derived from class Child, then an object of class Grandchild can be used anywhere an object of class Child can be used, and the object of class Grandchild can also be used anywhere that an object of class Ancestor can be used.
A derived class object has all the member variables of the base class.
When a derived class constructor is called, these member variables need to be allocated memory and should be initialized.
This allocation of memory for the inherited member variables must be done by a constructor for the base class, and the base class constructor is the most convenient place to initialize these inherited member variables.
That is why you should always include a call to one of the base class constructors when you define a constructor for a derived class.
If you do not include a call to a base class constructor (in the initialization section of the definition of a derived class constructor), then the default (zero-argument) constructor of the base class is called automatically.
Thus, if class B is derived from class A and class C is derived from class B, then when an object of the class C is created, first a constructor for the class A is called, then a constructor for B is called, and finally the remaining actions of the C constructor are taken.
Chapter 15 / Inheritance Constructors in Derived Classes A derived class does not inherit the constructors of its base class.
However, when defining a constructor for the derived class, you can and should include a call to a constructor of the base class (within the initialization section of the constructor definition).
If you do not include a call to a constructor of the base class, then the default (zero-argument) constructor of the base class will automatically be called when the derived class constructor is called.
Pitfall   Use of Private Member Variables from the Base Class An object of the class HourlyEmployee (Displays 15_0_4 and 15_0_6) inherits a member variable called name from the class Employee (Displays 15_0_2 and 15_0_3).
For example, the following code would set the value of the member variable name of the object joe to "Josephine".
But you must be a bit careful about how you manipulate inherited member variables such as name.
The member variable name of the class HourlyEmployee was inherited from the class Employee, but the member variable name is a private member variable in the definition of the class Employee.
That means that name can be directly accessed only within the definition of a member that is private in a base class is not accessible by name in the definition of a member function for any other class, not even in a member function definition of a derived class.
Thus, although the class HourlyEmployee does have a member variable named name (inherited from the base class Employee), it is illegal to directly access the member variable name in the definition  any member function in the class definition  HourlyEmployee.
For example, the following are the first few lines from the body  the member function HourlyEmployee::print_check (taken from Display 15_0_6):.
You might have wondered why we needed to use the member function set_ to set the value  the  member variable.
As the comment indicates, this will not work.
The member variable  is a private member variable in the class Employee, and although a derived class like HourlyEmployee inherits the variable , it cannot access it directly.
It must use some public member function to access the member variable The correct way to accomplish the definition  print_check in the class HourlyEmployee is the way we did it in Display 15_0_6 (and part  which was displayed earlier).
The fact that name and  are inherited variables that are private in the base class also explains why we needed to use the accessor functions and  in the definition  HourlyEmployee::print_ check instead  simply using the variable names name and.
You cannot mention a private inherited member variable by name.
You must instead use public accessor and mutator member functions (such as  and set_name) that were defined in the base class.
Accessor and mutator functions were covered The fact that a private member variable  a base class cannot be accessed in the definition  a member function  a derived class often seems wrong to people.
After all, if you are an hourly employee and you want to change your name, nobody says, "Sorry name is a private member variable  the class Employee_0_" After all, if you are an hourly employee, you are also an employee.
In Java, this is also true; an object  the class HourlyEmployee is also an object  the class Employee.
However, the laws on the use private member variables and member functions must be as we described, or else their privacy would be compromised.
If private member variables a class were accessible in member function definitions  a derived class, then anytime you wanted to access a private member variable, you could simply create a derived class and access it in a member function  that class, which would mean that all private member variables would be accessible to anybody who wanted to put in a little extra effort.
This adversarial scenario illustrates the problem, but the big problem is unintentional errors, not intentional subversion.
If private member variables  a class were accessible in member function definitions  a derived class, then the member variables might be changed by mistake or in inappropriate ways.
Chapter 15 / Inheritance We will discuss one possible way to get around this restriction on private member variables  the base class in the subsection entitled "The protected Qualifier" a bit later in this chapter.
Note that private member functions are just like private variables in terms not being directly available.
But in the case  member functions, the restriction is more dramatic.
A private variable can be accessed indirectly via an accessor or mutator member function.
A private member function is simply not available.
It is just as if the private member function were not inherited.
Private member functions should just be used as helping functions, and so their use should be limited to the class in which they are defined.
If you want a member function to be used as a helping member function in a number  inherited classes, then it is not just a helping function, and you should make the member function public.
There is a classification  member variables and functions that allows them to be accessed by name in a derived class but not anyplace else, such as in some class that is not a derived class.
If you use the qualifier protected, rather than private or public, before a member variable or member function  a class, then for any class or function other than a derived class, the effect is the same as if the member variable were labeled private; however, in a derived class the variable can be accessed by name.
For example, consider the class HourlyEmployee that was derived from the base class Employee.
We were required to use accessor and mutator member functions to manipulate the inherited member variables in the definition HourlyEmployee::print_check.
If all the private member variables in the class Employee were labeled with the keyword protected instead  private, the definition  HourlyEmployee::print_check in the derived class Employee could be simplified to the following:.
In the derived class HourlyEmployee, the inherited member variables , , and  can be accessed by , provided they are marked as protected (as opposed to private) in the base class Employee.
However, in any class that is not derived from the class Employee, these member variables are treated as if they were marked private.
Member variables that are protected in the base class act as though they were also marked protected in any derived class.
For example, suppose you define a derived class PartTimeHourlyEmployee  the class HourlyEmployee.
The class PartTimeHourlyEmployee inherits all the member variables  the class HourlyEmployee, including the member variables that HourlyEmployee inherits from the class Employee.
So, the class PartTimeHourlyEmployee will have the member variables , , and.
If these member variables were marked protected in the class Employee, then they can be used by in the definitions  functions  the class PartTimeHourlyEmployee.
Except for derived classes (and derived classes  derived classes, etc_0_), a member variable that is marked protected is treated the same as if it were marked private.
We include a discussion  protected member variables primarily because you will see them used and should be familiar with them.
Many, but not all, programming authorities say it is bad style to use protected member variables.
They say it compromises the principle  hiding the class implementation and that all member variables should be marked private.
If all member variables are marked private, the inherited member variables cannot be accessed by  in derived class function definitions.
However, this is not as bad as its sounds.
The inherited private member variables can be accessed indirectly by invoking inherited functions that either read or change the private inherited variables.
Since authorities differ, you will have to make your own decision on whether or not to use protected members.
Protected Members If you use the qualifier protected, rather than private or public, before a member variable  a class, then for any class or function other than a derived class (or a derived class  a derived class, etc_0_), the 851.
Chapter 15 / Inheritance situation is the same as if the member variable were labeled private.
However, in the definition  a member function  a derived class, the variable can be accessed by.
Similarly, if you use the qualifier protected before a member function  a class, then for any class or function other than a derived class (or a derived class  a derived class, etc_0_), that is the same as if the member function were labeled private.
However, in the definition  a member function  a derived class the protected function can be used.
Inherited protected members are inherited in the derived class as if they were marked protected in the derived class.
In other words, if a member is marked as protected in a base class, then it can be accessed by in the definitions  all descendant classes, not just in those classes directly derived from the base class.
S elf- T est Exe rc is es 1.
Is the following program legal (assuming appropriate #include and.
This class should have an additional data field, crazy, that is  type bool, one additional member  that takes no arguments and returns a value  type bool, and suitable constructors.
You do not need to give any implementations, just the class definition.
Is the following a legal definition  the member  is_crazy in the derived class SmartBut discussed in Self-Test Exercise 2.
Explain your answer.
Redefinition  Member Functions In the definition  the derived class HourlyEmployee (Display 15_0_4), we gave the declarations for the new  functions set_rate, get_rate, set_hours, and get_hours.
We also gave the  declaration for only one  the  functions inherited from the class Employee.
The inherited functions whose  declarations were not given (such as set_ and set_ssn) are inherited unchanged.
They have the same in the class HourlyEmployee as they do in the base class Employee.
When you define a derived class like HourlyEmployee, you list only the declarations for the inherited  functions whose definitions you want to change to have a different  in the derived class.
If you look at the implementation  the class HourlyEmployee, given in Display 15_0_6, you will see that we have redefined the inherited   print_check.
The class SalariedEmployee also gives a new  to the print_check, as shown in Display 15_0_7.
Moreover, the two classes give different definitions from each other.
Chapter 15 / Inheritance Redefining an Inherited Function A derived class inherits all the  functions (and  variables as well) that belong to the base class.
However, if a derived class requires a different implementation for an inherited  , the may be redefined in the derived class.
When a is redefined, you must list its declaration in the  of the derived class even though the declaration is the same as in the base class.
If you do not wish to redefine a   that is inherited from the base class, then it is not listed in the  of the derived class.
Display 15_0_7   Implementation for the Derived Class SalariedEmployee 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //This is the file salariedemployee_0_cpp.
Display 15_0_8 gives a demonstration program that illustrates the use  the derived classes HourlyEmployee and SalariedEmployee.
The functions set_name, set_ssn, set_rate, set_hours, and  are inherited unchanged from the class Employee.
The function print_check is redefined.
The function  was added to the derived class HourlyEmployee.
Sample Dialogue Check  Mighty Joe  40 hours.
Hours worked: 40 Rate: 20_0_5 Pay: 820 ___ ___ _____________________ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ Check  Mr.
Big Shot ___ ___ _____________________ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ Pay to the order  Mr.
Big Shot The sum  10500_0_5 Dollars ___ ___ _____________________ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ Check Stub NOT NEGOTIABLE Employee : 987-65-4321 Salaried Employee.
Regular Pay: 10500_0_5 ___ ___ _____________________ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ Redefining Versus Overloading Do not confuse redefining a  definition in a derived class with overloading a  name.
When you redefine a  definition, the new  definition given in the derived class has the same number and 15_0_1 Inheritance Basics types  parameters.
On the other hand, if the  in the derived class were to have a different number  parameters or a parameter  a different type from the  in the base class, then the derived class would have both functions.
For example, suppose we added a with the following  declaration to the definition  the class HourlyEmployee: void set_name(string first_name, string last_name);.
This would be overloading the  name set_name.
On the other hand, both the class Employee and the class HourlyEmployee define a  with the following  declaration: void print_check( ); In this case, the class HourlyEmployee has only one  named print_check, but the definition  the  print_check  the class HourlyEmployee is different from its definition  the class Employee.
In this case, the  print_check has been redefined.
If you get redefining and overloading confused, you do have one consolation.
So, it is more important to learn how to use them than it is to learn to distinguish between them.
Nonetheless, you should learn the difference.
Signature A 's signature is the 's name with the sequence  types in the parameter list, not including the const keyword and not including the ampersand (&).
When you overload a  name, the two definitions  the  name must have different signatures using this definition  signature_0_2 If a  has the same name in a derived class as in the base class but has a different signature, that is overloading, not redefinition.
Some compilers may allow overloading on the basis  const versus no const, but you cannot count on this and so should not do it.
For this reason, some definitions ­signature  the const modifier, but this is a cloudy issue that is best avoided until you become an expert.
Chapter 15 / Inheritance Access to a Redefined Base Function VideoNote Inheritance Example Suppose you redefine a  so that it has a different definition in the derived class from what it had in the base class.
The definition that was given in the base class is not completely lost to the derived class objects.
However, if you want to invoke the version of the  given in the base class with an object in the derived class, you need some way to say "use the definition of this  as given in the base class (even though I am an object of the derived class)_0_" The way you say this is to use the scope resolution operator with the name of the base class.
An example should clarify the details.
Consider the base class Employee (Display 15_0_2) and the derived class HourlyEmployee (Display 15_0_4).
But, suppose you want to invoke the version of print_check given in the definition of the base class Employee with the derived class object sally_h as the calling object  print_check.
You do that as follows: sally_h_0_Employee::print_check( ); Of course, you are unlikely to want to use the version of print_check given in the particular class Employee, but with other classes and other functions, you may occasionally want to use a  definition from a base class with a derived class object.
An example is given in Self-Test Exercise 6.
S elf- T est Exe rc is es 4.
The class SalariedEmployee inherits both of the functions and print_check (among other things) from the base class Employee, yet only the  declaration  the  print_check is given in the definition of the class SalariedEmployee.
Why isn't the declaration  the   given in the definition of SalariedEmployee.
Give a definition for a class TitledEmployee that is a derived class of the base class SalariedEmployee given in Display 15_0_5.
The class 15_0_2 Inheritance Details TitledEmployee has one additional member variable of type string called title.
It also has two additional member functions: get_title, which takes no arguments and returns a string; and set_title, which is a void  that takes one argument of type string.
It also redefines the member  set_name.
You do not need to give any implementations, just the class definition.
However, do give all needed #include directives and all using namespace directives.
Place the class TitledEmployee in the namespace employeessavitch.
Give the definitions of the constructors for the class TitledEmployee that you gave as the answer to Self-Test Exercise 5.
Also, give the redefinition of the member  set_name.
The  set_name should insert the title into the name.
Do not bother with #include directives or namespace details.
Common Saying This section presents some of the more subtle details about inheritance.
Most of the topics are relevant only to classes that use dynamic arrays or pointers and other dynamic data.
Functions That Are Not Inherited As a general rule if Derived is a derived class with base class Base, then all "normal" functions in the class Base are inherited members of the class Derived.
However, there are some special functions that are, for all practical purposes, not inherited.
We have already seen that, as a practical matter, constructors are not inherited and that private member functions are not inherited.
Destructors are also effectively not inherited.
In the case of the copy constructor, it is not inherited, but if you do not define a copy constructor in a derived class (or any class for that matter), Cplus_plus will automatically generate a copy constructor for you.
However, this default copy constructor simply copies the contents of member variables and does not work correctly for classes with pointers or dynamic data in their member variables.
Thus, if your class member variables involve pointers, dynamic arrays, or other dynamic data, then you should define a copy constructor for the class.
This applies whether or not the class is a derived class.
The assignment  = is also not inherited.
If the base class Base defines the assignment , but the derived class Derived does not the assignment , then the class Derived will have an assignment , but it will be the default assignment  that Cplus_plus creates 859.
Chapter 15 / Inheritance (when you do not  =); it will not have anything to do with the base class assignment  defined in Base.
It is natural that constructors, destructors, and the assignment are not inherited.
To correctly perform their tasks, they need information that the base class does not possess.
To correctly perform their functions, they need to know about the new  variables introduced in the derived class.
Assignment Operators and Copy Constructors in Derived Classes Overloaded assignment operators and constructors are not inherited.
However, they can be, and in almost all cases must be, used in the definitions of overloaded assignment operators and copy constructors in derived classes.
When overloading the assignment  in a derived class, you normally use the overloaded assignment  from the base class.
We will present an outline of how the code for doing this is written.
To help understand the code outline, remember that an overloaded assignment must be defined as a  function of the class.
If  is a class derived from , then the definition of the overloaded assignment  for the class  would typically begin with something like the following:.
The first line of code in the body of the definition is a call to the overloaded assignment  of the  class.
This takes care of the inherited variables and their data.
The definition of the overloaded assignment would then go on to set the new  variables that were introduced in the definition of the class.
A similar situation holds for defining the copy constructor in a derived class.
If  is a class derived from , then the definition of the copy constructor for the class  would typically use the copy constructor for the class  to set up the inherited  variables and their data.
The code would typically begin with something like the following:.
The invocation of the base class copy constructor () sets up the inherited  variables of the  class  being created.
Note that since  is of type , it is also of type ; therefore, is a legal argument to the copy constructor for the class.
Of course, these techniques do not work unless you have a correctly functioning assignment  and a correctly functioning copy constructor 15_0_2 Inheritance Details for the base class.
This means that the base class definition must include a copy constructor and that either the default automatically created assignment must work correctly for the base class or the base class must have a suitable overloaded definition of the assignment.
Destructors in  Classes If a base class has a correctly functioning destructor, then it is relatively easy to a correctly functioning destructor in a class derived from the base class.
When the destructor for the derived class is invoked, it automatically invokes the destructor of the base class, so there is no need for the explicit writing of a call to the base class destructor; it always happens automatically.
The derived class destructor therefore need only worry about using delete on the  variables (and any data they point to) that are added in the derived class.
It is the job of the base class destructor to invoke delete on the inherited  variables.
If class B is derived from class A and class C is derived from class B, then when an  of the class C goes out of scope, first the destructor for the class C is called, then the destructor for class B is called, and finally the destructor for class A is called.
Note that the order in which destructors are called is the reverse of the order in which constructors are called.
S elf- T est Exerc is es 7.
You know that an overloaded assignment  and a copy constructor are not inherited.
Does this mean that if you do not  an overloaded assignment  or a copy constructor for a derived class, then that derived class will have no assignment  and no copy constructor.
Suppose Child is a class derived from the class Parent, and the class Grandchild is a class derived from the class Child.
This question is concerned with the constructors and destructors for the three classes Parent, Child, and Grandchild.
When a constructor for the class Grandchild is invoked, what constructors are invoked and in what order.
When the destructor for the class Grandchild is invoked, what destructors are invoked and in what order.
Give the definitions for the  function add_value, the copy constructor, the overloaded assignment , and the destructor for the following class.
This class is intended to be a class for a partially filled array.
The  variable number_used contains the number of array positions currently filled.
The other constructor definition is given to help you get started.
We tend to agree.
However, using protected makes for  better practice assignment, and you should have some experience 10.
Define  class called PartFilledArrayWMax that is  derived class of the class PartFilledArray.
The class PartFilledArrayWMax has one additional  variable named max_value that holds the maximum value stored in the array.
Define   accessor function named get_max that returns the maximum value stored in the array.
Redefine the function add_value and  two constructors, one of which has an int argument for the maximum number of entries in the array.
Also   copy constructor, an overloaded assignment , and destructor.
HENRY ADAMS, The Education of Henry Adams Polymorphism refers to the ability to associate multiple meanings to one function name.
As it has come to be used today, polymorphism refers to very particular way of associating multiple meanings to  single function 15_0_3 Polymorphism name.
That is, polymorphism refers to the ability to associate multiple meanings to one function name by means of  special mechanism known as late binding.
Polymorphism is one of the key components of  programming philosophy known as -oriented programming.
Late binding, and therefore polymorphism, is the topic of this section.
Late Binding A virtual function is one that, in some sense, may be used before it is defined.
For example,  graphics program may have several kinds of figures, such as rectangles, circles, ovals, and so forth.
Each figure might be an of  different class.
For example, the Rectangle class might have variables for  height, width, and center point, while the Circle class might have  variables for  center point and  radius.
In  well-designed programming project, all of them would probably be descendants of  single parent class called, for example, Figure.
Now, suppose you want  function to draw  figure on the screen.
To draw  circle, you need different instructions from those you need to draw  rectangle.
So, each class needs to have different function to draw its kind of figure.
However, because the functions belong to the classes, they can all be called draw.
If r is  Rectangle and c is  Circle object, then r_0_draw ( ) and c_0_draw ( ) can be functions implemented with different code.
All this is not news, but now we move on to something :  functions defined in the parent class Figure.
Now, the parent class Figure may have functions that apply to all figures.
For example, it might have  function called center that moves  figure to the center of the screen by erasing it and then redrawing it in the center of the screen.
Figure::center might use the function draw to redraw the figure in the center of the screen.
When you think of using the inherited function center with figures of the classes Rectangle and Circle, you begin to see that there are complications here.
To make the point clear and more dramatic, let's suppose the class Figure is already written and in use and at some later time we add  class for  brandnew kind of figure, say, the class Triangle.
Now, Triangle can be  derived class of the class Figure, and so the function center will be inherited from the class Figure; thus, the function center should apply to (and perform correctly for_0_) all Triangles.
The function center uses draw, and the function draw is different for each type of figure.
The inherited function center (if nothing special is done) will use the definition of the function draw given in the class Figure, and that function draw does not work correctly for Triangles.
We want the inherited function center to use the function Triangle::draw rather than the function Figure::draw.
But the class Triangle, and therefore the function Triangle::draw, was not even written when the function center (defined in the class Figure) was written and compiled.
How can the function center possibly work correctly for Triangles.
The compiler did not know anything about Triangle::draw at 863.
Chapter 15 / Inheritance the time that center was compiled.
The answer is that it can apply provided draw is   function.
When you make  function , you are telling the compiler, "I do not know how this function is implemented.
Wait until it is used in  program, and then get the implementation from the object instance_0_" The technique of waiting until run-time to determine the implementation of  procedure is called late binding or dynamic binding.
Virtual functions are the way Cplus_plus provides late binding.
We need an example to make this come alive (and to teach you how to use  functions in your programs).
In order to explain the details of  functions in Cplus_plus, we will use  simplified example from an application area other than drawing figures.
Virtual Functions in Cplus_plus Suppose you are designing  record-keeping program for an automobile parts store.
You want to make the program versatile, but you are not sure you can account for all possible situations.
For example, you want to keep track of sales, but you cannot anticipate all types of sales.
At first, there will be only regular sales to retail customers who go to the store to buy one particular part.
However, later you may want to add sales with discounts, or mail-order sales with  shipping charge.
All these sales will be for an item with  basic price and ultimately will produce some bill.
For  simple sale, the bill is just the basic price, but if you later add discounts, then some kinds of bills will also depend on the size of the discount.
Your program will need to compute daily gross sales, which intuitively should just be the sum of all the individual sales bills.
You may also want to calculate the largest and smallest sales of the day or the average sale for the day.
All these can be calculated from the individual bills, but the functions for computing the bills will not be added until later, when you decide what types of sales you will be dealing with.
To accommodate this, we make the function for computing the bill   function.
All types of sales will be derived classes of the class Sale.
The class Sale corresponds to simple sales of a single item with no added discounts or charges.
Notice the reserved word  in the function declaration for the function bill (Display 15_0_9).
Notice (Display 15_0_10) that the member function savings and the overloaded operator < both use the function bill.
Since bill is declared to be a  function, we can later define derived classes of the class Sale and define their versions of the function bill, and the definitions of the member function savings and the overloaded operator <, which we gave with the class Sale, will use the version of the function bill that corresponds to the object of the derived class.
For example, Display 15_0_11 shows the derived class.
Notice that the class  requires a different definition for its version of the function.
Nonetheless, when the member function savings and the overloaded  < are used with an object of the class , they will use the version of the function definition for  that was given 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 //This is the interface for the class.
Consider the function call d1_0_savings(d2) for objects d1 and d2 of the class.
The definition of the function savings (even for an object of the class ) is given in the implementation file for the base class , which was compiled before we ever even thought of the class Yet, in the function call d1_0_savings(d2), the line that calls the function  knows enough to use the definition of the function  given for the class.
In order to write Cplus_plus programs, you can just assume it happens by magic, but the real explanation was given in the introduction to this section.
When you label a function virtual, you are telling the Cplus_plus environment, "Wait until this function is used in a program, and then get the Display 15_0_12 gives a sample program that illustrates how the virtual function  and the functions that use  work in a complete program.
Discounted item  cheaper.
Savings  $0_0_10 There are a number of technical details you need to know in order to use virtual functions in Cplus_plus.
We list them here:.
If a function will have a different definition in a derived class than in the base class and you want it to be a virtual function, you add the keyword virtual to the function declaration in the base class.
You do not need to add the reserved word virtual to the function declaration in the derived class.
If a function  virtual in the base class, then it  automatically virtual in the derived class.
The reserved word virtual  added to the function declaration and not to the function definition.
You do not get a virtual function and the benefits of virtual functions unless you use the keyword virtual.
Since virtual functions are so great, why not make all member functions virtual.
Almost the only reason for not always using virtual functions 15_0_3 Polymorphism efficiency.
The compiler and the run-time environment need to do much more work for virtual functions, and so if you label more member functions virtual than you need to, your programs will be less efficient.
Overriding When a virtual function definition  changed in a derived class, programmers often say the function definition  overridden.
In the Cplus_plus literature, a distinction  sometimes made between the terms redefined and overridden.
Both terms refer to changing the definition of the function in a derived class.
If the function  a virtual function, it's called overriding.
If the function  not a virtual function, it's called redefining.
This may seem like a silly distinction to you, the programmer, since you do the same thing in both cases, but the two cases are treated differently by the compiler.
Polymorphism The term polymorphism refers to the ability to associate multiple meanings to one function name by means of late binding.
Thus, polymorphism, late binding, and virtual functions are really all the same topic.
S elf- T est Exerc  e 11.
Suppose you modify the definitions of the class Sale (Display 15_0_9) by deleting the reserved word virtual.
How would that change the output of the program in Display 15_0_12.
Virtual Functions and Extended Type Compatibility We will discuss some of the further consequences of declaring a class member function to be virtual and do one example that uses some of these features.
Cplus_plus  a fairly strongly typed language.
This means that the types of items are always checked and an error message  issued if there  a type mismatch, 869.
Chapter 15 / Inheritance such as a type mismatch between an argument and a formal parameter when there  no conversion that can be automatically invoked.
This also means that normally the value assigned to a variable must match the type of the variable, although in a few well-defined cases Cplus_plus will perform an automatic type cast (called a coercion) so that it appears that you can assign a value of one type to a variable of another type.
For example, Cplus_plus allows you to assign a value of type char or int to a variable of type double.
However, Cplus_plus does not allow you to assign a value of type double or float to a variable of any integer type (char, short, int, long).
However, as important as strong typing , this strong type checking interferes with the very idea of inheritance in object-oriented programming.
Suppose you have defined class A and class B and have defined objects of type class A and class B.
You cannot always assign between objects of these types.
For example, suppose a program or unit contains the following type declarations: class Pet {.
Now concentrate on the data members,  and.
In a real application, they Anything that  a Dog  also a Pet.
It would seem to make sense to allow programs to consider values of type Dog to also be values of type Pet, and hence the following should be allowed:.
Cplus_plus does allow this sort of assignment.
You may assign a value, such as the value of vdog, to a variable of a parent type, such as , but you are not allowed to perform the reverse assignment.
Although the assignment above allowed, the value that  assigned to the variable  loses its 15_0_3 Polymorphism field.
This  called the slicing problem.
The following attempted access will produce an error message: << _0_; //Illegal: class Pet has no member named You can argue that this makes sense, since once a Dog  moved to a variable of type Pet it should be treated like any other Pet and not have properties peculiar to Dogs.
This makes for a lively philosophical debate, but it usually just makes for a nuisance when programming.
The dog named Tiny  still a Great Dane and we would like to refer to its , even if we treated it as a Pet someplace along the line.
Fortunately, Cplus_plus does offer us a way to treat a  as a Pet without throwing away the  of the.
To do this, we use pointers to dynamic object instances.
Suppose we add the following declarations: Pet *; *;.
Sample Dialogue : Tiny : Great Dane : Tiny : Great Dane Pitfall   The Slicing Problem Although it is legal to assign a derived class object to a base class variable, assigning a derived class object to a base class object slices off data.
Any data members in the derived class object that are not also in the base class will be lost in the assignment, and any member functions that are not defined in the base class are similarly unavailable to the resulting base class object.
If we make the following declarations and assignments:.
Chapter 15 / Inheritance Pitfall   Not Using Virtual Member Functions In order to get the benefit of the extended type compatibility we discussed earlier, you must use virtual member functions.
For example, suppose we had not used member functions in the example in Display 15_0_13.
Suppose that in place of ppetarrow_operatorprint();.
The reason for this is that the expression * has its type determined by the pointer type of.
It is a pointer type for the type Pet, and the type Pet has no field named.
But print() was declared virtual by the base class, Pet.
So, when the compiler sees the call ppetarrow_operatorprint();.
Object-oriented programming with dynamic variables is a very different way of viewing programming.
This can all be bewildering at first.
It will help if you keep two simple rules in mind: 1.
If the domain type of the pointer  is a base class for the domain type of the pointer p_descendant, then the following assignment of pointers is allowed: = p_descendant; Moreover, none of the data members or member functions of the dynamic variable being pointed to by p_descendant will be lost.
Although all the extra fields of the dynamic variable are there, you will need virtual member functions to access them.
This means code a little, then test a little, then code a little more, and test a little more, and so forth.
However, if you try to compile classes with virtual member functions but do not implement each member, you may run into some very hard to understand error messages, even if you do not call the undefined member functions.
If any virtual member functions are not implemented before compiling, then the compilation fails with error messages similar to this: "undefined reference to Class_Name virtual table_0_" Even if there is no derived class and there is only one virtual member, this kind of message still occurs if that function does not have a definition.
What makes the error messages very hard to decipher is that without definitions for the functions declared virtual, there may be further error messages complaining about an undefined reference to default constructors, even if these constructors really are already defined.
Consider the following code, where  is a class with a destructor that is not virtual: * = new ;.
Now, let's see what happens when a destructor is marked as virtual.
The easiest way to describe how destructors interact with the virtual function mechanism is that destructors are treated as if all destructors had the same (even though they do not really have the same ).
For example, suppose is a derived class of the class  and suppose the destructor in the class  is marked virtual.
Now consider the following code: * = new ;.
When delete is invoked with , a destructor is called.
Chapter 15 / Inheritance , the destructor for the class  is called (and it in turn calls the destructor for the class ).
If the destructor in the class  had not been declared as virtual, then only the destructor in the class  would be called.
Another point to keep in mind is that when a destructor is marked as virtual, then all destructors of derived classes are automatically virtual (whether or not they are marked virtual).
Again, this behavior is as if all destructors had the same  (even though they do not).
Now we are ready to explain why all destructors should be virtual.
Suppose the class  has a member variable pB of a pointer type, the constructor for the class  creates a dynamic variable pointed to by pB, and the destructor for the class  deletes the dynamic variable pointed to by pB.
And suppose the destructor for the class  is not marked virtual.
Also suppose that the class  (which is derived from ) has a member variable pD of a pointer type, the constructor for the class  creates a dynamic variable pointed to by pD, and the destructor for the class  deletes the dynamic variable pointed to by pD.
Consider the following code: * = new ;.
This will return to the freestore the memory for the dynamic variable pointed to by pB, but the memory for the dynamic variable pointed to by pD will never be returned to the freestore (until the program ends).
On the other hand, if the destructor for the base class  were marked virtual, then when delete is applied to , the destructor for the class would be invoked (since the object pointed to is of type ).
The destructor for the class Derive would delete the dynamic variable pointed to by pD and then automatically invoke the destructor for the base class , and that would delete the dynamic variable pointed to by pB.
So, with the base class destructor marked as virtual, all the memory is returned to the freestore.
To prepare for eventualities such as these, it is best to always mark destructors as virtual.
Why can't we assign a base class object to a derived class variable.
What is the problem with the (legal) assignment of a derived class object to a base class variable.
Suppose the base class and the derived class each have a member function with the same signature.
When you have a pointer to a base class object Answers to Self-Test Exercises and call a function member through the pointer, discuss what determines which function is actually called—the base class member function or the derived-class function.
Chapter Summary ■ Inheritance provides a tool for code reuse by deriving one class from another and by adding features to the derived class.
Virtual functions are what Cplus_plus uses to achieve late binding.
Polymorphism, late binding, and virtual functions are really all the same topic.
You can plug in an object of a derived class for a parameter of the base class type.
An HourlyEmployee is an Employee.
A SalariedEmployee is an Employee.
It is legal because a and b are marked protected in the base class Smart and so they can be accessed by name in a derived class.
If a and b had ­instead been marked private, then this would be illegal.
The declaration for the function get_name is not given in the definition of SalariedEmployee because it is not redefined in the class Salaried­ Employee.
It is inherited unchanged from the base class Employee.
If you do not define an overloaded assignment operator or a copy constructor for a derived class, then a default assignment operator and a default copy constructor will be defined for the derived class.
However, if the class involves pointers, dynamic arrays, or other dynamic data, then it is almost certain that neither the default assignment operator nor the default copy constructor will behave as you want them to.
The constructors are called in the following order: first Parent, then Child, and finally Grandchild.
The destructors are called in the reverse order: first Grandchild, then Child, and finally Parent.
Discounted item is not cheaper.
There would be no member to assign to the derived class's added members.
Although it is legal to assign  derived class object to  base class variable, this discards the parts of the derived class object that are not members of the base class.
This situation is known as the slicing problem.
If the base class function carries the virtual modifier, then the type of the object to which the pointer was initialized determines whose member function is called.
If the base class member function does not have the virtual modifier, then the type of the pointer determines whose member function is called.
Practice Programs Practice Programs can generally be solved with  short program that directly applies the programming principles presented in this chapter.
Write  program that uses the class SalariedEmployee in Display 15_0_5.
Your program is to define  class called Administrator, which is to be derived from the class SalariedEmployee.
You are allowed to change ­private in the base class to protected.
You are to supply the following additional data and function members: A member variable of type string that contains the administrator's title (such as Director or Vice President).
Chapter 15 / Inheritance A member variable of type string that contains the company area of responsibility (such as Production, Accounting, or Personnel).
A member variable of type string that contains the name of this ­ dministrator's immediate supervisor.
A protected: member variable of type  that holds the administrator's annual salary.
It is possible for you to use the existing salary member if you did the change recommended earlier.
A member function called set_supervisor, which changes the supervisor name.
A member function for reading in an administrator's data from the keyboard.
A member function called print, which outputs the object's data to the screen.
An overloading of the member function print_check() with appropriate notations on the check.
Add temporary, administrative, permanent, and other classifications of employee to the hierarchy from Displays 15_0_2, 15_0_4, and 15_0_5.
Implement and test this hierarchy.
A user interface with  menu would be  nice touch for your test program.
VideoNote Solution to Practice Program 15_0_3 3.
Listed below are definitions of two classes that use inheritance, code for their implementation, and  main function.
Put the code into appropriate files with the necessary include statements and preprocessor statements so that the program compiles and runs.
It should output "Circle has radius 2 and area 12_0_5664".
Chapter 15 / Inheritance retrieve the  and , and an appropriately defined  function that calculates the  of the rectangle.
The following code added to main should output "Rectangle has  3 has 4 and  12_0_0".
Programming Projects Programming Projects require more problem-solving than Practice Programs and can usually be solved many different ways.
Visit www_0_myprogramminglab_0_com to complete many of these Programming Projects online and get instant feedback.
VideoNote Solution to Programming Project 15_0_1 1.
Give the definition of  class named Doctor whose objects are records for clinic's doctors.
This class will be  derived class of the class Salaried­ Employee given in Display 15_0_5.
A Doctor record has the doctor's specialty (such as "Pediatrician," "Obstetrician," "General Practitioner," etc_0_, so use type string) and office visit fee (use type ).
Be sure your class has reasonable complement of constructors, accessor, and mutator member functions, an overloaded assignment , and  copy constructor.
Write  driver program to test all your functions.
Create  base class called Vehicle that has the manufacturer's  (type string), number of cylinders in the engine (type int), and owner (type Person, given below).
Then create  class called Truck that is derived from Vehicle and has additional properties: the load capacity in tons (type  since it may contain a fractional part) and towing capacity in pounds (type int).
Be sure your classes have a reasonable complement of constructors, accessor, and mutator member functions, an overloaded assignment , and a copy constructor.
Write a driver program that tests all your member functions.
The definition of the class  follows.
The implementation of the class is part of this Programming Project.
Define a Car class that is derived from the Vehicle class given in Programming Project 2.
Define a class called SportsCar that is derived from Car class.
Be creative in choosing member variables and functions.
Give the definition of two classes, Patient and Billing, whose objects are records for a clinic.
Patient will be derived from the class given in Programming Project 2.
A Patient record has the patient's (­inherited from the class ) and primary physician, of type Doctor defined in Programming Project 2.
A Billing object will contain a Patient object, a Doctor object, and an amount due of type double.
Be sure your classes have a reasonable complement of constructors, accessor, and mutator member functions, an overloaded assignment , and a copy constructor.
First write a driver program to test all your member functions, and then write a test program that creates at least two patients, at least two doctors, and at least two Billing records, then prints out the total income from the Billing records.
Consider a graphics system that has classes for various figures—rectangles, squares, triangles, circles, and so on.
For example, a rectangle might have data members for , , and center point, while a square and circle might have only a center point and an edge length or , respectively.
In a well-designed system, these would be derived from a common class, Figure.
You are to implement such a system.
The class Figure is the base class.
You should add only Rectangle and Triangle classes derived from Figure.
Each class has stubs for member functions erase and draw.
Each of these member functions outputs a message telling what function has been called and what the class of the calling object is.
Since these are just stubs, they do nothing more than output this message.
The member function center calls the erase and draw functions to erase and redraw the figure at the center.
Since you but will call the member functions erase and draw.
Also add an output message in the member function center that announces that center is being called.
The member functions should take no arguments.
There are three parts to this project: a.
Write the class definitions using no virtual functions.
Compile and test.
Compile and test.
Chapter 15 / Inheritance For a real example, you would have to replace the definition of each of these member functions with code to do the actual drawing.
You will be asked to do this in Programming Project 6.
Use the following main function for all testing:.
Flesh out Programming Project 5.
Give new  for the various constructors and the member functions Figure::center, Figure::draw, Figure::erase, Triangle::draw, Triangle::erase, Rectangle::draw, and Rectangle::erase so that the draw functions actually draw figures on the screen by placing the character '*' at suitable locations.
For the erase functions, you can simply clear the screen (by outputting blank lines or by doing something more sophisticated).
There are a lot of details in this problem, and you will have to make decisions about some of them on your own.
Banks have many different types of accounts, often with different rules for fees associated with transactions such as withdrawals.
Customers are allowed to transfer funds between accounts incurring the appropriate fees associated with withdrawal of funds from one account.
Write a program with a base class for a bank account and two derived classes (as described below) representing accounts with different rules for withdrawing funds.
Also write a function that transfers funds from one account (of any type) to another.
A transfer is a withdrawal from one account and a deposit into the other.
Since the transfer can be done at any time with any type of account, the withdraw function in the classes must Programming Projects be virtual.
Write a main program that creates three accounts (one from each class) and tests the transfer function.
For the classes, create a base class called BankAccount that has the name of the owner of the account (a string) and the balance in the account (double) as data members.
Include member functions deposit and withdraw (each with a double for the amount as an argument) and accessor functions getName and getBalance.
Deposit will add the amount to the balance (assuming the amount is nonnegative) and withdraw will subtract the amount from the balance (assuming the amount is nonnegative and less than or equal to the balance).
Also create a class called MoneyMarketAccount that is derived from BankAccount.
In a MoneyMarketAccount the user gets two free withdrawals in a given period of time (don't worry about the time for this problem).
After the free withdrawals have been used, a withdrawal fee of $1_0_50 is deducted from the balance per withdrawal.
Hence, the class must have a data member to keep track of the number of withdrawals.
It also must override the withdraw definition.
Finally, create a CDAccount class (to model a Certificate of Deposit) derived from BankAccount that in addition to having the name and balance also has an interest rate.
CDs incur penalties for early withdrawal of funds.
Assume that a withdrawal of funds (any amount) incurs a penalty of 25% of the annual interest earned on the account.
Assume the amount withdrawn plus the penalty are deducted from the account balance.
Again, the withdraw function must override the one in the base class.
For all three classes, the withdraw function should return an integer indicating the status (either ok or insufficient funds for the withdrawal to take place).
For the purposes of this exercise, do not worry about other functions and properties of these accounts (such as when and how interest is paid).
They behave like wireless barcodes and can wirelessly broadcast an identification number to a receiver.
One application of RFID chips is to use them to aid in the logistics of shipping freight.
Consider a shipping container full of items.
Without RFID chips, a human has to manually inventory all of the items in the container to verify the contents.
With an RFID chip attached to the shipping container, the RFID chip can electronically broadcast to a human the exact contents of the shipping container without human intervention.
To model this application, write a base class called ShippingContainer that has a container ID number as an integer.
Include member functions to set and access the ID number.
Add a virtual function called getManifest that returns an empty string.
The purpose of this function is to return the contents of the shipping container.
Chapter 15 / Inheritance Create a derived  called ManualShippingContainer that represents the manual method of inventorying the container.
In this method, a human simply attaches a textual description of all contents of the container.
For example, the description might be "4 crates of apples.
Add a function called setManifest that sets this string.
Override the getManifest function so that it returns this string.
Create a second derived  called RFIDShippingContainer that represents the RFID method of inventorying the container.
To simulate what the RFID chips would compute, create an add function to simulate adding an item and their quantity using the data structures of your choice.
For example, if the add function were invoked three times as follows: rfidContainer_0_add("crate of pears"); // Add one crate of pears rfidContainer_0_add("crate of apples"); // Add one crate of apples rfidContainer_0_add("crate of pears"); // Add one crate of pears At this point, the data structure should be storing a list of two items: crate of apples and crate of pears.
The quantity of apples is 1and the quantity of pears is 2.
Override the getManifest function so that it returns a string of all items that is built by traversing the list of items.
In the example above, Programming Projects 889 The ants behave according to the following model: ■	Move.
Every time step, randomly try to move up, down, left, or right.
If the neighboring cell in the selected direction is occupied or would move the  off the grid, then the  stays in the current cell.
If an  survives for three time steps, then at the end of the time step (that is; after moving) the  will breed.
This is simulated by creating a new  in an adjacent (up, down, left, or right) cell that is empty.
If there is no empty cell available, then no breeding occurs.
Once an offspring is produced, an  cannot produce an offspring until three more time steps have elapsed.
The doodlebugs behave according to the following model: ■	Move.
Every time step, if there is an adjacent  (up, down, left, or right), then the  will move to that cell and eat the.
Otherwise, the  moves according to the same rules as the.
Note that a  cannot eat other doodlebugs.
If a  survives for eight time steps, then at the end of the time step it will spawn off a new  in the same manner as the.
If a  has not eaten an  within the last three time steps, then at the end of the third time step it will starve and die.
The should then be removed from the grid of cells.
During one turn, all the doodlebugs should move before the ants do.
Write a program to implement this simulation and draw the world using ASCII characters of "o" for an  and "X" for a.
Create a named Organism that encapsulates basic data common to both ants and doodlebugs.
This  should have a virtual function named move that is defined in the derived classes of Ant and Doodlebug.
You may need additional data structures to keep track of which critters have moved.
Initialize the world with 5 doodlebugs and 100 ants.
After each time step, prompt the user to press Enter to move to the next time step.
You should see a cyclical pattern between the population of predators and prey, although random perturbations may lead to the elimination of one or both species.
Listed below is code to play a guessing game.
In the game two players ­attempt to  a number.
Your task is to extend the program with objects function requires you include cstdlib (see Appendix 4):.
Solution to Programming Project 15_0_10 890.
The implementation of Player::getGuess() can simply return 0.
Next, define a named HumanPlayer derived from Player.
The implementation of HumanPlayer::getGuess() should prompt the user to enter a number and return the value entered from the keyboard.
Next, define a named ComputerPlayer derived from Player.
The implementation of ComputerPlayer::getGuess() should randomly select a number between 0 and 99 (see Appendix 4 for information on random number generation).
Finally, construct a main function that invokes play(Player &player1, Player &player2) with two instances of a HumanPlayer (human versus human), an instance of a HumanPlayer and ComputerPlayer (human versus computer), and two instances of ComputerPlayer (computer versus computer).
The computer player in Programming Project 10 does not play very well in the number guessing game, since it only makes random guesses.
Modify the program so that the computer plays a more informed game.
The ­specific strategy is up to you, but you must add function() to the Player and C ­ omputerPlayer classes so that the play(Player& player1, Player Programming Projects &player2) function can send the results of a  back to the computer player.
In other words, the computer must be told if its last  was too or too , and it also must be told if its opponent' last  was too or too.
The computer then can use this information to revise its next.
Also, add any necessary functions to allow the computer player to play multiple consecutive games.
Start with the definition of the Queue class given in Section 13_0_2 and modify it to store integers instead of characters.
A special type of queue is a priority queue.
A priority queue behaves like a regular queue except the remove function always extracts the item with the smallest value (this is the item with the highest priority).
Create a PriorityQueue class that is derived from the Queue class with appropriate constructors.
Redefine the remove function in the PriorityQueue class to extract the item with the smallest value.
Test the PriorityQueue class by adding several numbers to a P ­ riorityQueue object, then remove each one, printing the removed numbers as they are removed from the queue.
The following is an attempt to create a class to represent information about pets: class Pet {.
Rewrite this code using inheritance.
You should have a Pet class with subclasses for Dog, Cat, and Bird.
Variables should be associated with the appropriate classes, defined as private when appropriate, and have appropriate functions to access the variables.
Rewrite the printDescription function as a virtual function.
There should no longer be the need for a switch statement or a type variable.
Write a main function that creates a vector or array of pets that includes at least one bird, one dog, and one cat, and then loops through and outputs a description of each one.
Exception Handling 16 16_0_1 Exception-Handling Basics   895 A Toy Example of Exception Handling   895 Defining Your Own Exception Classes   904 Multiple Throws and Catches   904 Pitfall: Catch the More Specific Exception First   908 Programming Tip: Exception Classes Can Be Trivial   909 Throwing an Exception in a Function   909 Exception Specification   911 Pitfall: Exception Specification in Derived Classes   913 16_0_2 Programming Techniques for Exception Handling   914 When to Throw an Exception   914 Pitfall: Uncaught Exceptions   916 Pitfall: Nested try-catch Blocks   916 Pitfall: Overuse of Exceptions   916 Exception Class    917 Testing for Available Memory   917 Rethrowing an Exception   918 Chapter Summary 918 Answers to Self-Test Exercises 918 Practice Programs 920 Programming Projects 921 It's the exception that proves the rule.
Introduction One way to write a program is to first assume that nothing unusual or incorrect will happen.
For example, if the program takes an entry off a list, you might assume that the list is not empty.
Once you have the program working for the core situation where things always go as planned, you can then add code to take care of the exceptional cases.
In Cplus_plus, there is a way to reflect this approach in your code.
Basically, you write your code as if nothing very unusual happens.
After that, you use the Cplus_plus exception-handling facilities to add code for those unusual cases.
Exception handling is commonly used to handle error situations, but perhaps a better way to view exceptions is as a way to handle "exceptional situations_0_" After all, if your code correctly handles an "error," then it no longer is an error.
Perhaps the most important use of exceptions is to deal with functions that have some special case that is handled differently depending on how the function is used.
Perhaps the function will be used in many programs, some of which will handle the special case in one way and some of which will handle it in some other way.
For example, if there is a division by zero in the function, then it may turn out that for some invocations of the function, the program should end, but for other invocations of the function something else should happen.
You will see that such a function can be defined to throw an exception if the special case occurs, and that exception will allow the special case to be handled outside of the function.
That way, the special case can be handled differently for different invocations of the function.
In Cplus_plus, exception handling proceeds as follows: Either some library software or your code provides a mechanism that signals when something unusual happens.
This is called throwing an exception.
At another place in your program, you place the code that deals with the exceptional case.
This is called handling the exception.
This method of programming makes for cleaner code.
Of course, we still need to explain the details of how you do this in Cplus_plus.
Prerequisites With the exception of one subsection that can be skipped, Section 16_0_1 uses material only from Chapters 2 to 6 and 10 to 11.
The Pitfall subsection of Section 16_0_1 entitled "Exception Specification in Derived Classes" uses material from Chapter 15.
This Pitfall subsection can be skipped without loss of continuity.
The subsection of Section 16_0_2 entitled "Testing for Available Memory" uses material from Chapter 15.
This subsection can be skipped without loss of continuity.
I didn't know it had to work for that case.
Computer Science student, appealing a grade Exception handling is meant to be used sparingly and in situations that are more involved than what is reasonable to include in a simple introductory example.
So, we will teach you the exception-handling details of Cplus_plus by means of simple examples that would not normally use exception handling.
This makes a lot of sense for learning about exception handling, but do not forget that these first examples are toy examples, and in practice, you would not use exception handling for anything that simple.
A Toy Example of Exception Handling For this example, suppose that milk is such an important food in our culture that people almost never run out of it, but still we would like our programs to accommodate the very unlikely situation of running out of milk.
The basic code, which assumes we do not run out of milk, might be as follows:.
To take care of the special situation in which we run out of milk, we can add a test for this unusual situation.
The complete program with this added test for the special situation is shown in Display 16_0_1.
The program in Display 16_0_1 does not use exception handling.
Now, let's see how this program can be rewritten using the Cplus_plus exception-handling facilities.
Chapter 16 / Exception Handling Display 16_0_1   Handling a Special Case Without Exception Handling 1 2 include <iostream> using namespace std; 3 4 5 6 7 8 9 10.
Sample Dialogue Enter number of donuts: 12 Enter number of glasses of : 0 12 donuts, and No Milk.
End of program.
In Display 16_0_2, we have rewritten the program from Display 16_0_1 using an exception.
This is only a toy example, and you would probably not use an exception in this case.
However, it does give us a simple example.
Although the program as a whole is not simpler, at least the part between the words try and catch is cleaner, and this hints at the advantage of using exceptions.
Look 16_0_1 Exception-Handling Basics 897 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33.
Sample Dialogue 1 Enter number of donuts: 12 Enter number of glasses of : 6 12 donuts.
You have 2 donuts for each glass of.
Chapter 16 / Exception Handling Sample Dialogue 2 Enter number of donuts: 12 Enter number of glasses of : 0 12 donuts, and No Milk.
That code is basically the same as the code in Display 16_0_1, but rather than the big if-else statement (shown in color in Display 16_0_1) this new  has the following smaller if statement (plus some simple nonbranching statements): throw donuts; This if statement says that if there is no , then do something exceptional.
That something exceptional is given after the word catch.
The idea is that the normal situation is handled by the code following the word try, and that the code following the word catch is used only in exceptional circumstances.
We have thus separated the normal case from the exceptional case.
In this toy example, this separation does not really buy us too much, but in other situations it will prove to be very helpful.
Let's look at the details.
The basic way of handling exceptions in Cplus_plus consists of the try-throwcatch threesome.
A try block has the syntax try { Some_Code } This try block contains the code for the basic algorithm that tells the computer what to do when everything goes smoothly.
It is called a try block because you are not 100 percent sure that all will go smoothly, but you want to "give Now if something does go wrong, you want to throw an exception, which is a way of indicating that something went wrong.
The basic outline, when we add a throw, is as follows: try { 16_0_1 Exception-Handling Basics Code_To_Try Possibly_Throw_An_Exception More_Code } The following is an example of a try block with a throw statement included.
The value thrown, in this case donuts, is sometimes called an exception, and the execution of a throw statement is called throwing an exception.
You can throw a value of any type.
In this case, an int value is thrown.
If the try block is followed by a suitable catch block, then flow of control is transferred to the catch block.
A throw statement is almost always embedded in a branching statement, such as anif statement.
The value thrown can be of any type.
Example throw donuts;.
Chapter 16 / Exception Handling As the name suggests, when something is "thrown," something goes from one place to another place.
In Cplus_plus, what goes from one place to another is the flow of control (as well as the value thrown).
When an exception is thrown, the code in the surrounding try block stops executing and another portion of code, known as a catch block, begins execution.
This executing of the catch block is called catching the exception or handling the exception.
In Display 16_0_2, the appropriate catch block immediately follows the try block.
We repeat the catch block here:.
This catch block looks very much like a function definition that has a parameter of a type int.
It is not a function definition, but in some ways, a catch block is like a function.
It is a separate piece of code that is executed when your  encounters (and executes) the following (within the preceding try block): throw Some_int; So, this throw statement is similar to a function call, but instead of calling a function, it calls the catch block and says to execute the code in the catch block.
A catch block is often referred to as an exception handler, which is a term that suggests that a catch block has a function-like nature.
What is that identifier e in the following line from a catch block.
That identifier e looks like a parameter and acts very much like a parameter.
So, we will call this e the catch-block parameter.
The catch-block parameter is preceded by a type name that specifies what kind of thrown value the catch block can catch.
The catch-block parameter gives you a name for the thrown value that is caught, so you can write code in the catch block that does things with the thrown value that is caught.
We will discuss these two functions of the catch-block parameter in reverse order.
In this subsection, we will discuss using the catch-block parameter as a name for the value that was thrown and is caught.
In the subsection entitled "Multiple Throws and Catches," later in this chapter, we will discuss which catch block (which exception handler) will process a value that is thrown.
Our 16_0_1 Exception-Handling Basics current example has only one catch block.
A common name for a catch-block parameter is e, but you can use any legal identifier in place of e.
Let's see how the catch block in Display 16_0_2 works.
When a value is thrown, execution of the code in the try block ends and control passes to the catch block (or blocks) that are placed right after the try block.
The catch block from Display 16_0_2 is reproduced here:.
When a value is thrown, the thrown value must be of type int in order for this particular catch block to apply.
In Display 16_0_2, the value thrown is given by the variable donuts, and since donuts is of type int, this catch block can catch the value thrown.
Suppose the value of donuts is 12 and the value of  is 0, as in the second sample dialogue in Display 16_0_2.
Since the value of  is not positive, the throw statement within the if statement is executed.
In that case, the value of the variable donuts is thrown.
When the catch block in Display 16_0_2 catches the value of donuts, the value of donuts is plugged in for the catch-block parameter e and the code in the catch block is executed, producing the following output: 12 donuts, and No Milk.
If the value of donuts is positive, the throw statement is not executed.
In this case, the entire try block is executed.
After the last statement in the try block is executed, the statement after the catch block is executed.
Note that if no exception is thrown, then the catch block is ignored.
This makes it sound like a try-throw-catch setup is equivalent to an ifelse statement.
It almost is equivalent, except for the value thrown.
A trythrow-catch setup is similar to an if-else statement with the added ability to send a message to one of the branches.
This does not sound much different from an if-else statement, but it turns out to be a big difference in practice.
To summarize in a more formal tone, a try block contains some code that we are assuming includes a throw statement.
The throw statement is normally executed only in exceptional circumstances, but when it is executed, it throws a value of some type.
When an exception (a value like donuts in Display 16_0_2) is thrown, that is the end of the try block.
All the rest of the code in the try block is ignored and control passes to a suitable catch block.
A catch block applies only to an immediately preceding try block.
If the exception is thrown, then that exception object is plugged in for the catch-block parameter, and the statements in the catch block are executed.
For example, if you look at the dialogues in Display 16_0_2, you will see that as soon as the user 901.
Chapter 16 / Exception Handling catch -Block Parameter The catch-block parameter is an identifier in the heading of a catch block that serves as a placeholder for an exception (a value) that might be thrown.
When a (suitable) value is thrown in the preceding try block, that value is plugged in for the catch-block parameter.
You can use any legal (nonreserved word) identifier for a catch-block parameter.
For now, we will assume that every try block is followed by an appropriate catch block.
We will later discuss what happens when there is no appropriate catch block.
Next, we summarize what happens when no exception is thrown in a try block.
If no exception (no value) is thrown in the try block, then after the try block is completed, program execution continues with the code after the catch block.
In other words, if no exception is thrown, then the catch block is ignored.
Most of the time when the program is executed, the throw statement will not be executed, and so in most cases, the code in the try block will run to completion and the code in the catch block will be ignored completely.
The throw statement throws the exception (a value).
The catch block catches the exception (the value).
When an exception is thrown, the try block ends and then the code in the catch block is executed.
After the catch block is completed, the code after the catch block(s) is executed (provided the catch block has not ended the program or performed some other special action).
If no exception is thrown in the try block, then after the try block is completed, program execution continues with the code after the catch block(s).
Syntax try { Some_Statements < Either some code with a throw statement or a function invocation that might throw an exception> Some_More_Statements } {.
Se lf- Te st Ex ercis e s 1.
What output is produced by the following code.
In the code given in Self-Test Exercise 1, what is the throw statement.
What happens when a throw statement is executed.
This is a general question.
Tell what happens in general, not simply what happens in the code in Self-Test Question 1 or some other sample code.
In the code given in Self-Test Exercise 1, what is the try.
In the code given in Self-Test Exercise 1, what is the catch.
In the code given in Self-Test Exercise 1, what is the catch- parameter.
Defining Your Own Exception Classes A throw statement can throw a value of any type.
A common thing  do is define a class whose objects can carry the precise kind of information you want thrown  the catch.
An even more important reason for defining a specialized exception class is so that you can have a different type  identify each possible kind of exceptional situation.
An exception class is just a class.
What makes it an exception class is how it's used.
Still, it pays  take some care in choosing an exception class's name and other details.
Display 16_0_3 contains an example of a program with a programmer-defined exception class.
This is just a toy program illustrate some Cplus_plus details about exception handling.
It uses much too much machinery for such a simple task, but it is an otherwise uncluttered example of some Cplus_plus details.
Notice the throw statement, reproduced in what follows: throw NoMilk(donuts); The part NoMilk(donuts) is an invocation of a constructor for the class NoMilk.
The constructor takes one int argument (in this case donuts) and creates an Multiple Throws and Catches A try  can potentially throw any number of exception values, and they can be of differing types.
In any one execution of the try , only one exception will be thrown (since a thrown exception ends the execution of the try ), but different types of exception values can be thrown on different occasions when the try  is executed.
Each catch  can only catch values of one type, but you can catch exception values of differing types by placing more than one catch  after a try.
For example, the program in Display 16_0_4 has two catch blocks after its try.
Note that there is no parameter in the catch  for DivideByZero.
If you do not need a parameter, you can simply list the type with no parameter.
Do not take it as an example of good typical use of exception handling.
Although not done here, exception classes can have their own interface and implementation files and can be put in a namespace.
This is another toy example.
Sample Dialogue 1 Enter number of JemHadar warriors: 1000 How many Klingon warriors do you have.
End of program Sample Dialogue 2 Enter number of JemHadar warriors: –10 Cannot have a negative number of JemHadar End of program.
Sample Dialogue 3 Enter number of JemHadar warriors: 1000 How many Klingon warriors do you have.
End of program.
Chapter 16 / Exception Handling This case is discussed a bit more in the Programming Tip section entitled Pitfall Catch the More Specific Exception First When catching multiple exceptions, the order of the catch blocks can be important.
When an exception value is thrown in a try block, the following catch blocks are tried in order, and the first one that matches the type of the exception thrown is the one that is executed.
For example, the following is a special kind of catch block that will catch a thrown value of any type:.
The three dots do not stand for something omitted.
You actually type in those three dots in your program.
This makes a good default catch block to place after all other catch blocks.
For example, we could add it to the catch blocks in Display 16_0_4 as follows:.
With this second ordering, an exception (a thrown value) of type NegativeNumber will be caught by the NegativeNumber catch block, as it should be.
However, if a value of type DivideByZero were thrown, it would be caught by the block that starts catch(_0__0__0_).
So, the DivideByZero catch block could never be reached.
Fortunately, most compilers tell you if you make this sort of mistake.
It has nothing but its name, but that is useful enough.
Throwing an object of the class DivideByZero can activate the appropriate catch block, as it does in Display 16_0_4.
When using a trivial exception class, you normally do not have anything you can do with the exception (the thrown value) once it gets to the catch block.
The exception is just being used to get you to the catch block.
Thus, you can omit the catch-block parameter.
For example, you might have a function with code that throws an exception if there is an attempt to divide by zero, but you may not want to catch the exception in that function.
Perhaps some programs that use that function should simply end if the exception is thrown, and other programs that use the function should do something else.
So you would not know what to do with the exception if you caught it inside the function.
In these cases, it makes sense to not catch the exception in the function definition, but instead to have any program (or other code) that uses the function place the function invocation in a try block and catch the exception in a catch block that follows that try block.
Look at the program in Display 16_0_5.
It has a try block, but there is no throw statement visible in the try block.
The statement that does the throwing in that program is throw DivideByZero();.
Sample Dialogue 2 Enter numerator: 5 Enter denominator: 0 Error: Division by zero.
This statement is not visible in the try block.
However, it is in the try block in terms of program execution, because it is in the definition of the function safe_divide and there is an invocation of safe_divide in the try block.
Exception Specification If a function does not catch an exception, it should at least warn programmers that any invocation of the function might possibly throw an exception.
If there are exceptions that might be thrown, but not caught, in the function definition, then those exception types should be listed in an exception specification, which is illustrated by the following function declaration from Display 16_0_5: double safe_divide(int top, int ) throw (DivideByZero); As illustrated in Display 16_0_5, the exception specification should appear in both the function declaration and the function definition.
If a function has more than one function declaration, then all the function declarations must have identical exception specifications.
The exception specification for a function is also sometimes called the throw list.
If there is more than one possible exception that can be thrown in the function definition, then the exception types are separated by commas, as illustrated here: void some_function( ) throw (DivideByZero, OtherException);.
Chapter 16 / Exception Handling All exception types listed in the exception specification are treated normally.
When we say the exception is treated normally, we mean it is treated as we have described before this subsection.
In particular, you can place the function invocation in a try block followed by a catch block to catch that type of exception, and if the function throws the exception (and does not catch it inside the function), then the catch block following the try block will catch the exception.
If there is no exception specification (no throw list) at all (not even an empty one), then it is the same as if all possible exception types were listed in the exception specification; that is, any exception that is thrown is treated normally.
What happens when an exception is thrown in a function but is not listed in the exception specification (and not caught inside the function).
In that case, the program ends.
In particular, notice that if an exception is thrown in a function but is not listed in the exception specification (and not caught inside the function), then it will not be caught by any catch block, but instead your program will end.
Remember, if there is no specification list at all, not even an empty one, then it is the same as if all exceptions were listed in the specification list, and so throwing an exception will not end the program in the way described in this paragraph.
Keep in mind that the exception specification is for exceptions that "get outside" the function.
If they do not get outside the function, they do not belong in the exception specification.
If they get outside the function, they belong in the exception specification no matter where they originate.
If an exception is thrown in a try block that is inside a function definition and is caught in a catch block inside the function definition, then its type need not be listed in the exception specification.
If a function definition includes an invocation of another function and that other function can throw an exception that is not caught, then the type of the exception should be placed in the exception specification.
To say that a function should not throw any exceptions that are not caught inside the function, you use an empty exception specification like so: void some_function( ) throw ( ); By way of summary: void some_function( ) throw (DivideByZero, OtherException); //Exceptions of type DivideByZero or OtherException are //treated normally.
All other exceptions end the program //if not caught in the function body.
So, if D is a derived class of class B and B is in the exception specification, then a thrown object of class D will be treated normally, since it is an object of class B and B is in the exception specification.
If double is in the exception specification, that does not account for throwing an int value.
You would need to  both int and double in the exception specification.
One final warning: Not all compilers treat the exception specification as they are supposed to.
Some compilers essentially treat the exception specification as a comment, and so with those compilers, the exception specification has no effect on your code.
This is another reason to place all exceptions that might be thrown by your functions in the exception specification.
This way all compilers will treat your exceptions the same way.
Of course, you could get the same compiler consistency by not having any exception specification at all, but then your program would not be as well documented and you would not get the extra error checking provided by compilers that do use the ­exception specification.
With a compiler that does process the exception specification, your program will terminate as soon as it throws an exception that you did not anticipate.
Put another way, when you redefine or override a function definition, you cannot add any exceptions to the exception specification (but you can delete some exceptions if you want).
This makes sense, since an object of the derived class can be used anyplace an object of the base class can be used, and so a redefined or overwritten function must fit any code written for an object of the base class.
Warren Peace, The Lieutenant's Tools So far, we have shown you lots of code that explains how exception handling works in Cplus_plus, but we have not yet shown even one example of a program that makes good and realistic use of exception handling.
However, now that you know the mechanics of exception handling, this section can go on to explain exception-handling techniques.
When to Throw an Exception We have given some very simple code in order to illustrate the basic concepts of exception handling.
However, our examples were unrealistically simple.
A more complicated but better guideline is to separate throwing an exception 16_0_2 Programming Techniques for Exception Handling and catching the exception into separate functions.
In most cases, you should any throw statement within a function definition, list the exception in the exception specification for that function, and place the catch clause in a different function.
Thus, the preferred use of the try-throw-catch triad is as illustrated here: void.
If you can easily handle a problem in some other way, do not throw an exception.
Reserve throw statements for situations in which the way the exceptional condition is handled depends on how and where the function is used.
If the way that the exceptional condition is handled depends on how and where the function is invoked, then the 915.
Chapter 16 / Exception Handling When to Throw an Exception For the most part, throw statements should be used within functions and listed in an exception specification for the function.
Moreover, they should be reserved for situations in which the way the exceptional condition is handled depends on how and where the function is used.
If the way that the exceptional condition is handled depends on how and where the function is invoked, then the best thing to do is to let the programmer who invokes the function handle the exception.
In all other situations, it is almost always preferable to avoid throwing an exception.
In all other situations, it is almost always preferable to avoid throwing exceptions.
Pitfall Uncaught Exceptions Every exception that is thrown by your code should be caught someplace in your code.
If an exception is thrown but not caught anywhere, your program will end.
In rare cases, this may be useful, but if you are tempted to do this, you should suspect that there is a nicer way to organize your program.
It is almost always better to place the inner try-catch blocks inside a function definition and place an invocation of the function in the outer try or catch block (or maybe just eliminate one or more try blocks completely).
If you place a try block and following catch blocks inside a larger try block, and an exception is thrown in the inner try block but not caught in the inner try-catch blocks, then the exception is thrown to the outer try block for processing and might be caught there.
Throwing an exception allows you to transfer flow of control 16_0_2 Programming Techniques for Exception Handling 917 from anyplace in your program to almost anyplace else in your program.
In the early days of programming, this sort of unrestricted flow of control was allowed via a construct known as a goto.
Programming experts now agree that such unrestricted flow of control is very poor programming style.
Exceptions allow you to revert to these bad old days of unrestricted flow of control.
Exceptions should be used sparingly and only in certain ways.
A good rule is the following: If you are tempted to include a throw statement, then think about how you might write your program or class definition without this throw statement.
If you think of an alternative that produces reasonable code, then you probably do not want to include the throw statement.
For example, you might have an ArithmeticError exception class and then define an exception class DivideByZeroError that is a derived class of ArithmeticError.
Since a DivideByZeroError is an ArithmeticError, every catch block for an ArithmeticError will catch a DivideByZeroError.
If you list ArithmeticError in an exception specification, then you have, in effect, also added DivideByZeroError to the exception specification, whether or not you list DivideByZeroError by name in the exception specification.
Testing for Available Memory In Chapter 13, we created new  variables with code such as the following: struct.
This works fine as long as there is sufficient memory available to create the new.
But, what happens if there is not sufficient memory.
If there is not sufficient memory to create the , then a bad_alloc exception is thrown.
The type bad_alloc is part of the Cplus_plus language.
You do not need to define it.
Since new  throw a bad_alloc exception when there is not enough memory to create the , you can check for running out of memory as follows: try.
Rethrowing an Exception It is legal to throw an exception within a catch block.
In rare cases, you may want to catch an exception and then, depending on the details, decide to throw the same or a different exception for handling farther up the chain of exception-handling blocks.
Se lf- Te s t Ex e rc ise s 10.
What happens when an exception is never caught.
Can you nest a try block inside another try block.
Chapter Summary ■ Exception handling allows you to design and code the normal case for your program separately from the code that handles exceptional situations.
Alternatively, an exception can be thrown in a function definition that does not include a try block (or does not include a catch block to catch that type of exception).
In this case, an invocation of the function can be placed in a try block.
In this case, always list the catch block for a more specific exception class before the catch block for a more general exception class.
Answers to Self - Test Exer cises 1.
Try block entered.
Exception thrown with wait_time equal to 46 After catch block.
Answers to Self-Test Exercises 2.
Try block entered.
Leaving try block.
After catch block.
When a throw statement is executed, that is the end of the enclosing try block.
No other statements in the try block are executed, and control passes to the following catch block(s).
When we say control passes to the following catch block, we mean that the value thrown is plugged in for the catchblock parameter (if any), and the code in the catch block is executed.
End of program.
Trying after call.
End of program.
If an exception is not caught anywhere, then your program ends.
Yes, you can have a try block and corresponding catch blocks inside another larger try block.
However, it would probably be better  place the inner try and catch blocks in a function definition and place an invocation of the function in the larger try block.
Chapter 16 / Exception Handling Practice Programs Practice Programs can generally be solved with a short program that directly applies the programming principles presented in this chapter.
VideoNote Solution  Practice Program 16_0_1 1.
A function that returns a special error code is often better implemented by throwing an exception instead.
This way, the error code cannot be ignored or mistaken for valid data.
The following class maintains an account.
Write test code that attempts  withdraw and deposit invalid amounts and catches the exceptions that are thrown.
Programming Projects 2.
The Standard Template Library includes a class named exception that is the parent class for any exception thrown by an STL function.
Therefore, any exception can be caught by this class.
The following code sets up a try-catch block for STL exceptions:.
Modify the code so that an exception is  in the try block.
You could try accessing an invalid index in a string using the at member function.
Programming Projects Programming Projects require more problem-solving than Practice Programs and can usually be solved many different ways.
Visit www_0_myprogramminglab_0_com complete many of these Programming Projects online and get instant feedback.
Write a program that converts 24-hour time  12-hour time.
The following is a sample dialogue: Enter time in 24-hour notation: 13:07 That is the same as 1:07 PM y Enter time in 24-hour notation: 10:15 That is the same as 10:15 AM y.
Chapter 16 / Exception Handling Enter time in 24-hour notation: 10:65 There is no such time as 10:65 Try again: Enter time in 24-hour notation: 16:05 That is the same as 4:05 PM n End of program You will define an exception class called TimeFormatMistake.
If the user enters an illegal time, like 10:65 or even gibberish like 8&*68, then your program will throw and catch a TimeFormatMistake.
Write a program that converts dates from numerical month/day format alphabetic month/day (for example, 1/31 or 01/31 corresponds  January 31).
The dialogue should be similar  that in Programming Project 1.
You will define two exception classes, one called MonthError and another called DayError.
If the user enters anything other than a legal month number (integers from 1  12), then your program will throw and catch a MonthError.
Similarly, if the user enters anything other than a valid day number (integers from 1  either 29, 30, or 31, depending on the month), then your program will throw and catch a DayError.
To keep things simple, always allow 29 days for February.
VideoNote Solution  Programming Project 16_0_3 3.
Write a program that inputs numeric values from 1 through 10 and outputs a textual histogram of the values using *'  count the number of occurrences of each value.
The program should first ask the user how many numbers enter.
If the user enters a value that does not consist of all digits or a number outside the range 1  10, then an exception should be caught.
If not, throw an exception.
To convert a string str  an integer, use the following code: atoi(str_0_c_str()); The atoi function is described in Chapter 8_0_) Here is a sample dialogue: How many numbers  enter.
Enter number 1: 9 Enter number 2: Try again.
Programming Projects 3 Enter number 3: 3 Enter number 4: 33 The number must be between 1-10.
Enter number 4: 3 Enter number 5: 7 Try again.
Here is the histogram of values: 1 : 2 : 3 : *** 4 : 5 : 6 : 7 : * 8 : 9 : * 10: 4.
Define a class named CheckedArray.
The objects of this class are like regular arrays but have range checking.
If a is an object of the class CheckedArray and i is an illegal index, then use of a[i] will cause your program to throw an exception (an object) of the class ArrayOutOfRangeError.
Defining the class ArrayOutOfRangeError is part of this project.
Note that, among other things, your CheckedArray class must have a suitable overloading of the[] operators, as discussed in Appendix 6.
Stacks were introduced in Chapters 13 and 14.
Define a stack class for storing a stack of elements of type char.
A stack object should be of fixed size; the size is a parameter to the constructor that creates the stack object.
When used in a program, an object of the stack class will throw exceptions in the following situations: ■	Throw a StackOverflowException if the application program tries to push data onto a stack that is already full ■	Throw a StackEmptyException if the application program tries to pop data off an empty stack Defining the classes StackOverflowException and StackEmptyException is part of this project.
Write a suitable test program.
Give each function an argument that specifies the level 923.
Chapter 16 / Exception Handling at which it is to throw an exception.
The main function prompts for and receives input that specifies the calling depth (level) at which an exception will be thrown.
The main function then calls the first function.
The main function catches the exception and displays the level at which the exception was thrown.
Don't forget the case where the depth is 0, where main must both throw and catch the exception.
Rather, for compact code, use a main function that calls another function that calls itself recursively.
Suppose you do this; is the restriction on the calling depth necessary.
Programming Project 7 in Chapter 9 described a technique to emulate a two-dimensional array with wrapper functions around a one-dimensional array.
If the indices of a desired entry in the two-dimensional array were to instead throw an ArrayOutOfRangeError exception if either the row or column indices are invalid.
Your program should define the ArrayOutOfRangeError exception class.
Templates 17 17_0_1 Templates for Algorithm Abstraction   926 for Functions   927 Pitfall: Compiler Complications   931 Programming Example: A Generic Sorting Function   933 Programming Tip: How to Define    937 Pitfall: Using a Template with an Inappropriate Type   938 17_0_2  for Data Abstraction   939 Syntax for     939 Programming Example: An Array    942 Chapter Summary   949 Answers to Self-Test Exercises   949 Practice Programs   953 Programming Projects   953 All men are mortal.
Aristotle is a man.
Therefore, Aristotle is mortal.
All cats are mischievous.
Garfield is a cat.
Therefore, Garfield is mischievous.
A Short Lesson on Syllogisms Introduction This chapter discusses Cplus_plus templates.
This will allow you to design functions that can be used with arguments of different types and to define classes that are much more general than those you have seen before this chapter.
Prerequisites Section 17_0_1 uses material from Chapters 2 through 5 and Sections 7_0_1, 7_0_2, and 7_0_3 of Chapter 7.
It does not use any material on classes.
Section 17_0_2 uses material from Chapters 2 through 7 and 10 through 12.
For example, consider the function swap_values, which we first discussed in Chapter 5.
For reference, we now repeat the function definition:.
Notice that the function swap_values applies only to variables of type int.
Yet the algorithm given in the function body could just as well be used to swap the values in two variables of type char.
If we want to also use the function 926 17_0_1  for Algorithm Abstraction swap_values with variables of type char, we can overload the function name.
But there is something inefficient and unsatisfying about these two definitions of the swap_values function: They are almost identical.
The only difference is that one definition uses the type int in three places and the other uses the type char in the same three places.
Proceeding in this way, if we wanted to have the function swap_values apply to pairs of variables of type double, we would have to write a third almost identical function definition.
If we wanted to apply swap_values to still more types, the number of almost identical function definitions would be even larger.
This would require a good deal of typing and would clutter up our code with lots of definitions that look identical.
We should be able to say that the following function definition applies to variables of any type: void swap_values(Type_Of_The_Variables& 1,.
That syntax is described in the next subsection.
This function template allows you to swap the values of any two variables, of any type, as long as the two variables have the same type.
The definition and the function declaration begin with the line template<class T> This is often called the template prefix, and it tells the compiler that the definition or function declaration that follows is a template and that T is a 927.
Chapter 17 / type parameter.
In this context, the word class actually means type_0_1 As we will see, the type parameter T can be replaced by any type, whether the type is a class or not.
Within the body of the function definition, the type parameter T is used just like any other type.
The function template definition is, in effect, a large collection of function definitions.
For the function template for swap_values shown in Display 17_0_1, there is, in effect, one function definition for each possible type name.
Each of these definitions is obtained by replacing the type parameter T with a type name.
For example, the function definition that follows is obtained by replacing T with the type name double:.
Yet another definition is obtained by replacing the type parameter T with char.
The one function template shown in Display 17_0_1 overloads the function name swap_values so that there is a slightly different function definition for every possible type.
The compiler will not literally produce definitions for every possible type for the function name swap_values, but it will behave exactly as if it had produced all those function definitions.
A separate definition will be produced for each different type for which you use the template, but not for any types you do not use.
Only one definition is generated for a single type regardless of the number of times you use the template for that type.
Notice that the function swap_values is called twice in Display 17_0_1: One time the arguments are of type int and the other time the arguments are of type char.
Consider the following function call from Display 17_0_1: swap_values(integer1, integer2); When the Cplus_plus compiler gets to this function call, it notices the types of the arguments—in this case int—and then it uses the template to produce a function definition with the type parameter T replaced with the type name int.
Similarly, when the compiler sees the function call swap_values(symbol1, symbol2); In fact, the ANSI standard provides that you may use the keyword typename instead of class in the template prefix.
Although we agree that using typename makes more sense than using class, the use of class is a firmly established tradition, and so we use class 1 for the sake of consistency with most other programmers and authors.
Output Original  values are 1 2 Swapped  values are 2 1 Original character values are  B Swapped character values are B it notices the types of the arguments—in this case char—and then it uses the template to produce a function definition with the type parameter T replaced with the type name char.
Notice that you need not do anything special when you call a function that is defined with a function template; you call it just as you would any Calling a function template 929.
Chapter 17 / Templates other function.
The compiler does all the work of producing the function definition from the function template.
Notice that in Display 17_0_1 we placed the function template ­definition before the main part of the program, and we used no template function ­declaration.
You may (or may not) be able to place the function declaration and definition for a function template in the same locations that you place function declarations and definitions for ordinary functions.
However, many compilers do not support template function declarations and do not support separate compilation of template functions.
When these are supported, the details can be messy and can vary from one compiler to another.
Your safest strategy is to not use template function declarations and to be sure the function template definition appears in the same file in which it is used and appears before the function template is used.
We said that a function template definition should appear in the same file as the file that uses the template function (that is, the same file as the file that has an invocation of the template function).
However, the function template definition can appear via a # directive.
You can give the function template definition in one file and then # that file in a file that uses the template function.
That is the cleanest and safest general strategy.
However, even that may not work on some compilers.
If it does not work, consult a local expert.
Although we will not be using template function declarations in our code, we will describe them and give examples of them for the benefit of readers whose compilers support the use of these function declarations.
In the function template in Display 17_0_1, we used the letter T as the parameter for the type.
This is traditional but is not required by the Cplus_plus language.
The type parameter can be any identifier (other than a keyword).
T is a good name for the type parameter, but sometimes other names may work better.
For example, the function template for swap_values given in Display 17_0_1 is equivalent to the following: template<class VariableType> void swap_values(VariableType& 1,.
For example, a function template with two type parameters named T1 and T2 would begin as follows: template<class T1, class T2> 17_0_1 Templates for Algorithm Abstraction 931 However, most function templates require only one type parameter.
You cannot have unused template parameters; that is, each template parameter must be used in your template function.
Pitfall Compiler Complications Many compilers do not allow separate compilation of templates, so you may need to include your template definition with your code that uses it.
As usual, at least the function declaration must precede any use of the template function.
Your safest strategy is not to use template function declarations and to be sure the function template definition appears in the same file in which it is used and appears before the function template is called.
However, the function template definition can appear via a #include directive.
You can give the function template definition in one file and then #include that file in a file that uses the template function.
Another common technique is to put your definition and implementation, all in the header file.
If you use this technique, then you would only have a header (_0_h) file and no implementation (_0_cpp) file.
Finally, an alternate approach is to include the implementation (_0_cpp) file for your template class instead of the header file (_0_h).
Some Cplus_plus compilers have additional special requirements for using templates.
If you have trouble compiling your templates, check your manuals or check with a local expert.
You may need to set special options or rearrange the way you order the template definitions and the other items in your files.
For example, the following is a function declaration for a function template: template<class T> void show_stuff(int stuff1, T stuff2, T stuff3);.
VideoNote Issues Compiling Programs with Templates 932.
The type name is substituted for the type parameter (which is T in the example above).
For instance, consider the following function call: show_stuff(2, 3_0_3, 4_0_4); When this function call is executed, the compiler uses the function definition obtained by replacing T with the type name double.
A separate definition will be produced for each different type for which you use the template but not for any types you do not use.
Only one definition is generated for a specific type regardless of the number of times you use the template.
S elf-Tes t Exe rc ise s 1.
Write a function template named maximum.
The function takes two values of the same type as its arguments and returns the larger of the two arguments (or either value if they are equal).
Give both the function declaration and the function definition for the template.
You will use the operator < in your definition.
Therefore, this function template will apply only to types for which < is defined.
Write a comment for the function declaration that explains this restriction.
We have used three kinds of absolute value function: abs, labs, and fabs.
These functions differ only in the type of their argument.
It might be better to have a function template for the absolute value function.
Give a function template for an absolute value function called absolute.
The template will apply only to types for which < is defined, for which the unary negation operator is defined, and for which the constant 0 can be used in a comparison with a value of that type.
Thus, the function absolute can be called with any of the number types, such as int, long, and double.
Give both the function declaration and the function definition for the template.
Define or characterize the template facility for Cplus_plus.
In the template prefix template<class T> what kind of  is the parameter T.
T can be only types built into the Cplus_plus language.
Algorithm Abstraction As we saw in our discussion of the swap_values function, there is a very general algorithm for interchanging the value of two variables, and this more general algorithm applies to variables of any type.
Using a function template, we were able to express this more general algorithm in Cplus_plus.
This is a very simple example of algorithm abstraction.
When we say we are using algorithm abstraction, we mean that we are expressing our algorithms in a very general way so that we can ignore incidental detail and concentrate on the substantive part of the algorithm.
Function templates are one feature of Cplus_plus that supports algorithm abstraction.
Programming Example   A Generic Sorting Function In Chapter 7 we gave a simple sorting algorithm to sort an array of values of type int.
The algorithm was realized in Cplus_plus code as the function sort, which we gave in Display 7_0_12.
Here we repeat the definition of this function sort:.
If you study this definition of the function sort, you will see that the base type of the array is never used in any significant way.
If we replace the base type of the array in the function header with the type double, then we would obtain  sorting function that applies to arrays of values of type double.
Helping functions course, we also must adjust the helping functions so they apply to arrays of elements of type double.
So let's consider the helping functions that are called inside the body of the function sort.
The two helping functions are swap_ values and index_of_smallest.
We already saw that swap_values can apply to variables of any type, provided we define it as  function template (as in Display 17_0_1).
Let's see if index_of_smallest depends in any significant way on the base type of the array being sorted.
The definition of index_of_smallest is repeated next so you can study its details.
The function index_of_smallest also does not depend in any significant way on the base type of the array.
If we replaced the two highlighted instances of the type int with the type double, then we will have changed the function index_of_smallest so that it applies to arrays whose base type is double.
To change the function sort so that it can be used to sort arrays with the base type double, we only needed to replace  few instances of the type name int with the type name double.
Moreover, there is nothing special about the type double.
We can do  similar replacement for many other types.
The only thing we need to know about the type is that the operator < is defined for that type.
This is the perfect situation for function templates.
If we replace few instances of the type name int (in the functions sort and index_of_ smallest) with  type parameter, then the function sort can sort an array of values of any type provided that the values of that type can be compared using the < operator.
In Display 17_0_2 we have written just such  function template.
Notice that the function template sort shown in Display 17_0_2 can be used with arrays of values that are not numbers.
In the demonstration program in Display 17_0_3, the function template sort is called to sort an array of characters.
Characters can be compared using the < operator.
Although the exact meaning of the < operator applied to character values may vary somewhat from one 17_0_1 Templates for Algorithm Abstraction.
When applied to two uppercase letters, the operator < tests to see if the first comes before the second in alphabetic order.
Also, when applied to two lowercase letters, the operator < tests to see if the first comes before the second in alphabetic order.
When you mix uppercase and lowercase letters, the situation is not so well behaved, but the program shown in Display 17_0_3 deals only with uppercase letters.
In that program, an array of 936 Chapter 17 / Templates 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27.
Output Unsorted integers: 9 8 7 6 5 1 2 3 0 4 In sorted order the integers are: 0 1 2 3 4 5 6 7 8 9 Unsorted doubles: 5_0_5 4_0_4 1_0_1 3_0_3 2_0_2 In sorted order the doubles are: 1_0_1 2_0_2 3_0_3 4_0_4 5_0_5 Unsorted characters: G E N E R I C In sorted order the characters are: C E E G I N R uppercase letters is sorted into alphabetical order with  call to the function sort.
We then created by replacing the base type of the array with the type parameter T.
This is  good general strategy for writing templates.
If you want to write  function , first write  version that is not   at all but is just an ordinary function.
Completely debug the ordinary function and then convert the ordinary 937.
Chapter 17 / Templates function to   by replacing some type names with  type parameter.
There are two advantages to this method.
First, when you are defining the ordinary function you are dealing with  much more concrete case, which makes the problem easier to visualize.
Second, you have fewer details to check at each stage; when worrying about the algorithm itself, you need not concern yourself with  syntax rules.
However, all the code in the function must make sense and must behave in an appropriate way.
For example, you cannot use the swap_values  (Display 17_0_1) with the type parameter replaced by  type for which the assignment operator does not.
Display 7_0_10 shows  function called search, which searches an array for  specified integer.
Give  function  version of search that can be used to search an array of elements of any type.
Give both the function declaration and the function definition for the.
In Practice Program 8 of Chapter 4 you were asked to overload the abs function so that the name abs would work with several of the built-in types that had been studied at the time.
Compare and contrast function overloading of the abs function with the use of templates for this purpose in Self-Test Exercise 2.
The example in this Pitfall section uses arrays.
If you have not yet covered arrays (Chapter 7), you should skip this Pitfall section and return after covering arrays.
Edward Bellamy, Looking Backward: 2000–1887 As you saw in the previous section, function definitions can be made more general by using templates.
In this section, you will see that templates can also make class definitions more general.
Syntax for Class Templates The syntax for class templates is basically the same as that for function templates.
The following is placed before the template definition: template<class T> The type parameter T is used in the class definition just like any other type.
As with function templates, the type parameter T represents a type that can be any type at all; the type parameter does not have to be replaced with a class type.
As with function templates, you may use any (nonkeyword) identifier instead of T.
For example, the following is a class template.
An object of this class contains a pair of values of type T; if T is int, the object values are pairs of integers, if T is char, the object values are pairs of characters, and so on.
Type parameter //Class  a pair of values of type T: template<class T> class Pair {.
The only difference is that the member function definitions are themselves templates.
For example, the following are appropriate definitions  the member function set_element and  the constructor with two arguments: //Uses iostream and cstdlib: template<class T>.
Notice that the class name before the scope resolution operator is <T>, not simply.
The name of a class template may be used as the type  a function parameter.
For example, the following is a possible declaration  a function with a parameter  a pair of integers: int add_up(const <int>& the_pair); //Returns the sum of the two integers in the_pair.
For example, the following is the beginning of a class template definition: template<class T> class {.
Member functions and overloaded operators are then defined as function templates.
For example, the definition of a function definition the sample class template above could begin as follows: template<class T> {.
Note that we specified the type, in this case int, that is to be filled in  the type parameter T.
You can even use a class template within a function template.
For example, rather than defining the specialized function add_up given above, you could instead define a function template as follows so that the function applies to all kinds of numbers: template<class T> T add_up(const <T>& the_pair); //Precondition: The operator + is defined  values of type T.
Chapter 17 / Templates Type Definitions You can specialize a  template by giving a type argument to the name, as in the following example: <int> The specialized  name, like <int>, can then be used just like any name.
It can be used to declare objects or to specify the type of a formal parameter.
You can define a new  type name that has the same meaning as a specialized  template name, such as <int>.
The syntax  such a defined  type name is as follows: typedef <Type_Argument> New_Type_Name;.
PairOfInt pair1, pair2; The type name PairOfInt can also be used to specify the type of a.
Programming Example An Array Class Display 17_0_4 contains the interface  a  template whose objects are lists.
Since this  definition is a  template, the lists can be lists of items of any type whatsoever.
You can have objects that are lists of values of type int, or lists of values of type double, or lists of objects of type string, or lists of items of any other type.
Display 17_0_5 contains a demonstration program that uses this template.
Although this program does not really do anything much, it does illustrate how the  template is used.
Once you understand the syntax details, you can use the  template in any program that needs a list of values.
Display 17_0_6 gives the implementation of the template.
To do this, we made the operator << a friend of the.
In order to have a parameter that is of the same type as the , we used the expression GenericList<ItemType> for the parameter type.
When the type parameter is replaced by, for example, the type int, this list parameter will be of type GenericList<int>.
Also note that that the implementation of the overloaded insertion operator << has been placed in the header file rather than the implementation file.
This may seem unusual, but it is quite common when using friend functions or operators within a template.
Although we are defining << like it is a member of GenericList, recall that friend functions really exist outside the  and are part of the namespace.
The compiler will have an easy time finding the implementation of << this way when the  is included from other files.
Objects of type  can be a list of items //of any type for which the operators <<  = are defined.
A list that //can hold up to max items all of type Type_Name is declared as follows: //<Type_Name> the_object(max); #ifndef GENERICLIST_H #define GENERICLIST_H.
Chapter 17 / Templates 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 bool full( ) const; //Returns true if the list is full.
This is commonly done with overloaded friend templates.
Output = 1 2 = A B C Display 17_0_6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18.
A safe solution to the compilation of this code is to # the template class definition and the template function definitions before use, as we did.
In that case, only the file in Display 17_0_5 needs to be compiled.
Be sure that you use the #ifndef #define #endif mechanism to prevent multiple file inclusion of all the files you are going to #.
Also note that that the implementation of the overloaded insertion operator << has been placed in the header file rather than the implementation file.
This may seem unusual, but it is quite common when using friend functions or operators within a template.
Although we are defining << like it is a member of , recall that friend functions really exist outside the class and are part of the namespace.
The compiler will have an easy time finding the implementation of << this way when the class is included from other files.
If you want to separate the implementation of the overloaded friend insertion operator << from the header, then it requires a little bit of extra work.
We must make a forward declaration of the << operator which in turn requires a forward declaration of the  class.
Display 17_0_7 illustrates the required changes to genericlist_0_h while Display 17_0_8 illustrates the changes to genericlist_0_cpp, which simply has the additional implementation.
Display 17_0_7 Interface for the Class   Without 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //This version moves the implementation of the overloaded << //to the _0_cpp file, but requires adding some forward declarations.
These must be defined here since << is not //a member of the class.
Chapter 17 / Templates Display 17_0_7 Interface for the Class   Without 22 23 24 25 26 27 28 29 30 31 32 33 34 35  class { The rest of this class is identical to Display 17_0_4 except  overloaded  below has no implementation code and an additional <>.
Display 17_0_8 Implementation of  with Overloaded Operator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 //This is  implementation file: genericlist_0_cpp //This is  implementation of  class template named.
Answers to Self-Test Exercises S elf-Tes t Exerc ise s 7_0_	Give  definition for  member function get_element for  class 8_0_	Give  definition for  constructor with zero arguments for  class 9_0_	Give  definition of a template class called HeterogeneousPair that is like except that with HeterogeneousPair  first and second positions may store values of different types.
Use two type parameters T1 and T2; all items in first position will be of type T1, and all items in  second position will be of type T2.
The single mutator function set_element in  template class Pair should be replaced by two mutator functions called set_first and set_second in  template class HeterogeneousPair.
Similarly,  single accessor function get_element in  template class Pair should be replaced by two accessor functions called get_first and get_second in  template class HeterogeneousPair.
Is  following true or false.
Friends are used exactly  same for template and nontemplate classes.
Chapter Summary ■ Using function templates, you can define functions that have a parameter for a type.
Answers to S elf-Test Exerci ses 1.
Function Declaration: template<class T> T maximum(T first, T second); //Precondition: The  < is defined for  type T.
Definition: template<class T>.
Any type, whether a primitive type (provided by Cplus_plus) or a type defined by  user (a class or struct type, an enum type, or a defined array type, or int, float, double, etc_0_).
The function declaration and function definition are given here.
They are basically identical to those for  versions given in Display 7_0_10 except that two instances of int are changed to BaseType in  parameter list.
Function Declaration: template<class BaseType> int search(const BaseType a[], int number_used, BaseType target);.
Definition: template<class BaseType> int search(const BaseType a[], int number_used, Answers to Self-Test Exercises {.
Function overloading only works for types for which an overloading  provided.
Overloading may work for types that automatically convert to some type for which an overloading  provided but may not do what you expect.
The template solution will work for any type that  defined at the time of invocation, provided that the requirements for a definition of < are satisfied.
There are no natural candidates  the default initialization values, so this objects without giving any constructor arguments.
Practice Programs Practice Programs can generally be solved with a short program that directly applies the programming principles presented in this chapter.
Write a function template  a function that has parameters  a partially filled array and  a value of the base type of the array.
If the value  in the partially filled array, then the function returns the  of the indexed variable that contains the value.
If the value  not in the array, the function returns −1.
The base type of the array  a type parameter.
Notice that you need two parameters to give the partially filled array: one the array and one  the number of indexed variables used.
Also, write a suitable test program to test this function template.
Write a template version of the iterative binary search from Display 14_0_8.
Specify and discuss the requirements on the template parameter type.
Write a template version of the recursive binary search from Display 14_0_6.
Specify and discuss the requirements on the template parameter type.
Programming Projects Programming Projects require more problem-solving than Practice Programs and can usually be solved many different ways.
Visit www_0_myprogramminglab_0_com to complete many of these Programming Projects online and get instant feedback.
This more general version has the added feature that you can step through the items on the list in order.
One item  always the current item.
You can ask  the current item, change the current item to the next item, change the current item to the previous item, start at the beginning of the list by making the  item on the list the current item, and ask  the nth item on the list.
To do this, you will add the following members: an additional member variable that records the  on the list of the current item, a member function that returns the current item as a value, a member function that makes the next item the current item, a member function that makes the previous item the current item, a member function that makes the  item on the 953.
Chapter 17 / Templates list the current item, and a member function that returns the nth item on the list given n as an argument.
For example, an empty list has no  item, and there  no item after the last item in any list.
Be sure to test  the empty list and handle it appropriately.
Be sure to test  the beginning and end of the list and handle these cases appropriately.
Write a suitable test program to test this class template.
Write a template  a function that has parameters  a list of items and a possible item on the list.
If the item  on the list, then the function returns the  of the  occurrence of that item.
If the item not on the list, the function returns −1.
The   on the list 0, the next   1, and so forth.
The type of the items on the list  a type parameter.
Use the class template GenericList that you defined in Project 1.
Write a suitable program to test this function template.
It would help if you  did the nontemplate version; in other words, it would help if you  did Programming Project 3 in Chapter 7, if you have not already done it.
Display 17_0_3 gives a template function  sorting an array using the selection sort algorithm.
Write a similar template function  sorting an array, but this time use the insertion sort algorithm as described in Programming Project 6 of Chapter 7.
If you have not already done it, it would be a good idea to  do the nontemplate version; in other words, it would be a good idea to  do Programming Project 6 from Chapter 7.
Stacks are covered in Chapter 14; dynamic arrays are covered Write a template version of a stack class.
Use a type parameter  the type of data that is stored in the stack.
Use dynamic arrays to allow the stack to grow to hold any number of items.
Write a template version of a class that implements a priority queue.
Queues are discussed in Chapter 13 and priority queues are discussed in Chapter 18.
To summarize, a priority queue is essentially a list of items Programming Projects 955 that is always ordered by priority.
Each item that is added to the list requires an associated priority value.
For this problem, make the priority an integer where 0 is the highest priority and larger values are lower in priority.
Removing an item from the queue removes the item with the highest priority.
The add function of the priority queue should take a generic type and then an integer priority.
In the following example, the generic type is a char and we have added three items to the queue:.
Test your queue on data with priorities in various orders (for example, ascending, descending, mixed).
You can implement the priority queue by storing the items using a list(s) of your choice (for example, vector, array, linked list, or GenericList described in this chapter) and then performing a linear search for the  with the lowest integer value in the remove function.
In future courses you may study a data structure called a heap that affords a more efficient way to implement a priority queue.
Write a template-based class that implements a set of items.
A set is a collection of items in which no  occurs more than once.
Internally, you may represent the set using the data structure of your choice (for example, list, vector, arrays, etc_0_).
However, the class should externally support the following functions: a_0_ Add a new  to  set.
If   is already in  set then nothing happens.
Determine if an  is a member of  set.
The caller of this function is responsible for deallocating  memory.
Test your class by creating different sets of different data types (for example, strings, integers, or other classes).
If you add objects to your set, then you may need to overload  ==  _0_= operators for  object's class so your template-based set class can properly determine membership.
VideoNote Solution to Programming Project 17_0_7 956 Chapter 17 / Templates 8.
This project requires that you complete Programming Project 7 from this chapter  Programming Project 8 from Chapter 14.
Programming Project 8 asked you to write a program to find all permutations of a set.
Modify program so that it generates permutations given an instance of template-based set class defined in Programming Project 7.
You may wish to also use your template-based set class to help simplify  implementation of  permutation algorithm itself.
The algorithm requires that you store a set of lists.
Cplus_plus allows you to create a set of lists with your template-based set class.
For example, myset<vector<T> > will define a set containing a vector of type T.
Be careful to place a space between  last two >'s, or  compiler may get confused.
The code myset<vector<T>> without a space will likely produce a compiler error unless you are using Cplus_plus11 or higher.
Your program should print all permutations of sets of several different sizes  comprised of several different types of data (for example, a set of three integers, a set of four strings, or a set of five doubles).
In this chapter we used only a single template class type parameter.
Cplus_plus allows you to specify multiple type parameters.
For example,  following code specifies that  class accepts two type parameters: template<class T, class V> class { _0__0_.
The data type for  keys values should be specified separately using type parameters.
The map forms  basis for a simple database.
For example, to map from employee ID numbers to employee names, we might use integers for data type of  keys  strings for  data type of  names.
The class should have functions to: 1.
Add a new / pair to  map 2.
Set an existing / pair to a new  given 3.
Delete a / pair from  map given 4.
Check if a / pair exists in  map given 5_0_ Retrieve   for a / pair given Use any data type you wish to implement  map.
Write a main function that tests  class by exercising all of  functions with sample data.
Standard Template Library 18_0_1 Iterators 959 using Declarations 959 Iterator Basics 960 Programming Tip: Use auto to Simplify Variable Declarationss 964 Pitfall: Compiler Problems 964 Kinds of Iterators 966 Constant  Mutable Iterators 970 Reverse Iterators 971 Other Kinds of Iterators 972 18_0_2 Containers 973 Sequential Containers 974 Pitfall: Iterators  Removing Elements Programming Tip: Type Definitions in Containers 979 Chapter Summary 1005 Answers to Self-Test Exercises 1005 18 Container Adapters stack  queue 979 Associative Containers set  map 983 Programming Tip: Use Initialization, Ranged for, auto with Containers 990 Efficiency 990 18_0_3 Generic Algorithms 991 Running Times  Big-O Notation 992 Container Access Running Times 995 Nonmodifying Sequence Algorithms 997 Container Modifying Algorithms 1001 Set Algorithms 1003 Sorting Algorithms 1004 978 Practice Programs 1007 Programming Projects 1008 Libraries are not made; they grow.
Augustine Birrell Introduction There is a large collection of standard data structures for holding data.
Since they are so standard it makes sense to have standard portable implementations for them.
The Standard Template Library (STL) includes libraries for such data structures.
Included in  STL are implementations of  stack, queue, many other standard data structures.
When discussed in  context of  STL, these data structures are usually called container classes because they are used to hold collections of data.
In Chapter 8 we presented a preview of the STL by describing the vector template class, which is one of the container classes in the STL.
In this chapter we will present an overview of some of the basic classes included in the STL.
We do not have room to give a comprehensive treatment of the STL here, but we will present enough to get you started using some basic STL container classes.
The STL was developed by Alexander Stepanov and Meng Lee at HewlettPackard and was based on research by Stepanov, Lee, and David Musser.
It is a collection of libraries written in the Cplus_plus language.
Although the STL is not part of the core Cplus_plus language, it is part of the Cplus_plus standard and so any implementation of Cplus_plus that conforms to the standard would include the STL.
As a practical matter, you can consider the STL to be part of the Cplus_plus language.
As its name suggest, the classes in the STL are template classes.
A typical container class in the STL has a type parameter for the type of data to be stored in the container class.
The STL container classes make extensive use of iterators, which are objects that facilitate cycling through the data in a container.
An introduction to the concept of an iterator was given in Section 13_0_1, where we discussed pointers used as iterators.
You will find it helpful to read that section before reading this chapter.
If you have not already done so, you should also read Section 8_0_3, which covers the vector template class of the STL.
The STL also includes implementations of many important generic algorithms, such as searching and sorting algorithms.
The algorithms are implemented as template functions.
After discussing the container classes, we will describe some of these algorithm implementations.
The STL differs from other Cplus_plus libraries, such as <iostream> for example, in that the classes and algorithms are generic, which is another way of saying they are template classes and template functions.
Iterators are a generalization of pointers.
Other container template classes, which we introduce in Section 18_0_2, use iterators in the same way.
So, all you learn about iterators in this section will apply across a wide range of containers and does not apply solely to vectors.
This reflects one of the basic tenets of the STL philosophy: The semantics, naming, and syntax for iterator usage should be (and are) uniform across different container types.
We begin with a review and discussion of the using declarations, which we will use extensively when discussing iterators and the STL.
Suppose my_function is a function defined in the namespace my_space.
The following using declaration allows you to use the identifier my_function and have it mean the versions of my_function defined in the namespace my_space: using my_space::my_function; Within the scope of this using declaration an expression such as my_function(1,2) means the same thing as my_space::my_function(1,2); that is, within the scope of this using declaration the identifier my_function always indicates the version of my_function defined in my_space, as opposed to any definition of my_function defined in any other namespace.
When discussing iterators we will often apply the :: operator to another level.
You will often see expressions such as the following: using std::<int>::iterator;.
Chapter 18 / Standard Template Library.
What is the type iterator.
It is defined in the definition of the class <int>.
Which class <int>.
The one defined in the namespace std.
At this point we are concerned only with explaining using You may object that this is all a big to-do about nothing.
There is no class <int> defined in any namespace other than the namespace std.
That may or may not be true, but there could be a class named <int> defined in some other namespace either now or in the future.
You may object further that you never heard of defining a type within a class.
We have not covered such definitions, but they are possible and they are common in the STL.
So, you must know how to use such types, even if you do not define such types.
In summary, consider the using directive using std::<int>::iterator; Within the scope of this using directive the identifier iterator means the type named iterator that is defined in the class <int>, which in turn is defined in the std namespace.
Iterator Basics An iterator is a generalization of a pointer, and in fact is typically even implemented using a pointer, but the abstraction of an iterator is designed to spare you the details of the implementation and give you a uniform interface to iterators that is the same across different container classes.
Each container class has its own iterator types, just like each data type has its own pointer type.
But just as all pointer types behave essentially the same for dynamic variables of their particular data type, so too does each iterator type behave the same, but each iterator is used only with its own container class.
An iterator is not a pointer, but you will not go far wrong if you think of it  use it as if it were a pointer.
Like a pointer variable, an iterator variable is located at ("points to") one data entry in the container.
You manipulate iterators using the following overloaded  that apply to iterator objects:.
Prefix  postfix increment , plus_plus, for advancing the iterator to the next data item.
Prefix  postfix decrement , −−, for moving the iterator to the previous data item.
Equal  unequal , ==  _0_=, to test whether two iterators point to the same data location.
A dereferencing operator, *, so that if p is an  variable, then *p gives access to the data located at ("pointed to by") p.
This access may be read-only, write-only, or allow both reading  changing of the data, depending on the particular container class.
However, the  template class is an example of a container whose iterators have all these   more.
A container class has member functions that get the  process started.
After all, a new  variable is not located at ("pointing to") any data in the container.
Many container classes, including the  template class, have the following member functions that return  objects ( values) that point to special data elements in the data structure: data item in the container c.
The  c_0_end() is completely analogous to NULL used to test when a pointer has passed the last node in a linked list of the kind discussed in Chapter 13.
The c_0_end() is thus an  that is located at no data item, but that is a kind of end marker or sentinel.
For many container classes, these tools allow you to write for loops that cycle through all the elements in a container object c, as follows: // is an  variable of the type for the container object c.
That's the big picture.
Now let's look at the details in the concrete setting of the  template container class.
Display 18_0_1 illustrates the use of iterators with the  template class.
Keep in mind that each container type in the STL has its own  types, although they are all used in the same basic ways.
The iterators we want for a of ints are of type std::<int>:: Another container class is the list template class.
Iterators for lists of ints are of type std::list<int>:: In the program in Display 18_0_1, we specialize the type name  so that it applies to iterators for vectors of ints.
The type name  that we want in Display 18_0_1 is defined in the template class   so if we specialize the template class  to ints  want the  type for <int>, we want the type std::<int>::;.
Chapter 18 / Standard Template Library Display 18_0_1   Iterators Used with a Vector 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26.
Sample Dialogue Here is what is in the container: 1 2 3 4 Setting entries to 0: Container now contains: 0 0 0 0 Since the  definition places the name  in the std namespace, the entire using declaration is using std::<int>::;.
Recall that container is of type <int>.
A  v can be thought of as a linear arrangement of its data elements.
There is a first data element v[0], a second data element v[1],  so forth.
An   is an object that can be located at one of these elements.
If  is located at, say, v[7], then pplus_plus moves  so it is located at v[8].
This allows an  to move through the from the first element to the last element, but it needs to find the first element and needs to know when it has seen the last element.
You can tell if an  is at the same location as another  using the ==.
Thus, if you have an  pointing to the first, last, or other element, you could test another  to see if it is located at the first, last, or other element.
If 1 and 2 are two iterators, then the comparison 1 == 2 is true when and only when 1 and 2 are located at the same element.
If 1 and 2 were pointers, this would be true if they pointed to the same thing_0_)  , _0_= is just the negation  == and so 1 _0_= 2 is true when 1 and 2 are not located at the same element.
The member function begin() is used to position an iterator at the first element in a container.
For vectors, and many other container classes, the member function begin() returns an iterator located at the first element.
The member function end() returns a sentinel value that can be checked.
The value v_0_end() is a special value that serves as a sentinel value.
It is not an ordinary iterator, but you can compare v_0_end() to an iterator  == _0_=.
The value v_0_end() is analogous to the value NULL used to mark the end  a linked list  the kind discussed in Chapter 13.
The following for loop from Display 18_0_1 uses this exact technique with the  named container:.
The dereferencing  * is overloaded for STL container iterators so that * produces the element at location.
In particular, for a  container, * produces the element located at the iterator.
So, the  statement above outputs the element located at the iterator   the entire for loop outputs all the elements in the  container.
The dereferencing  * always produces the element located at the iterator.
In some situations, * produces read-only access, which does not allow you to change the element.
In other situations, it gives you access to the element will let you change the element.
For vectors, * will allow you to change the element located at , as illustrated by the following for loop from Display 18_0_1: * = 0;.
Declaring an iterator can be really verbose: <int>::iterator  = v_0_begin();.
Compiler Problems Some compilers have problems with iterator declarations.
You can declare an iterator in different ways.
For example, we have been  the following:.
An iterator is a generalization  the notion a pointer,  the  ==, _0_=, plus_plus,  −− behave the same for iterators as they do for pointers.
The basic outline  how an iterator can cycle through all the elements in a container is <type>::iterator ; Process_Element_At_Location ; type is the data type  the item to be stored.
The member function begin() returns an iterator located at the first element.
The member function end() returns a value that serves as a sentinel value one location past the last element in the container.
Alternatively, if your code only uses a single type  iterator, you could use the following:.
Your compiler should accept any  these alternatives.
However, we have found that some compilers will accept only certain them.
If one form does not work with your compiler, try another.
For some STL container classes, * produces read-only access, which does not allow you to change the element.
For other STL container classes, it gives you access to the element  will let you change the element.
S elf- T est Exe r cis es 1.
If  is an iterator for a  object v, what is *.
Suppose v is a   ints.
Write a for loop that outputs all the elements  v, except for the first element.
Kinds  Iterators Different containers have different kinds  iterators.
Iterators are classified according to the kinds  operations that work on them.
Vector iterators are  the most general form; that is, all the operations work with  iterators.
So, we will again use the  container to illustrate iterators.
In this case we use a  to illustrate the iterator   decrement  random access.
Display 18_0_2 shows another program  a  object named container  an iterator.
Sample Dialogue [0] == A [1] == B [2] == C [3] == D The third entry  C The third entry  C The third entry  C Back to [0].
As you would expect, −− moves the iterator  to the previous location.
The decrement operator −−  the same as the increment operator plus_plus, but it moves the iterator in the opposite direction.
The increment and decrement operators can be used in either prefix (plus_plusp) or postfix (pplus_plus) notation.
In addition to changing , they also return a.
The details of the  returned are completely analogous to what happens with the increment and decrement operators on int variables.
In prefix notation, first the variable  changed and the changed   returned.
In postfix notation, the   returned before the variable  changed.
We prefer not to use the increment and decrement operators as expressions that return a  and use them only to change the variable.
Chapter 18 / Standard Template Library The following lines from Display 18_0_2 illustrate that with  iterators you have random access to the elements of a , such as : <char>::iterator << "The third entry << "The third entry << "The third entry.
Random access means you can go in one step directly to any particular element.
We have already used [2] as a form of random access to a.
It simply the square bracket operator that  standard with arrays and vectors.
What new  that you can use this same square bracket notation with an iterator.
The expression [2]  a way to obtain access to the element indexed by 2.
The expressions [2] and *( + 2) are completely equivalent.
By analogy to pointer arithmetic (see Chapter 9), ( + 2) names the location two places at the third (index 2) location.
The expression ( + 2) returns an iterator.
The expression *( + 2) dereferences that iterator.
Of course, you can replace 2 with a different nonnegative integer to obtain a pointer pointing to a different element.
Be sure to note that neither [2] nor ( + 2) changes the  of the iterator in the iterator variable.
The expression ( + 2) returns another iterator at another location, but it leaves  where it was.
Also note that the meaning of [2] and ( + 2) depends on the location of the iterator in.
For example, ( + 2) means two locations beyond the location of , wherever that may be.
For example, suppose the previously discussed code from Display 18_0_2 were replaced with the following (note the added pplus_plus): <char>::iterator pplus_plus; << "The third entry << "The third entry.
The output of these three couts would no longer be The third entry  C The third entry  C The third entry  C but would instead be The third entry  C The third entry  D The third entry  D The pplus_plus moves  from location 0 to location 1 and so ( + 2)  now an iterator at location 3, not location 2.
The following are the main kinds of iterators: Forward iterators: plus_plus works on the iterator.
Bidirectional iterators: both plus_plus and −− work on the iterator.
Random access iterators: plus_plus, −−, and random access all work with the iterator.
We now know enough about iterators to make sense of how iterators are classified.
The main kinds of iterators are Forward iterators: plus_plus works on the iterator.
Bidirectional iterators: both plus_plus and −− work on the iterator.
Random access iterators: plus_plus, −−, and random access all work with the iterator.
Note that these are increasingly strong categories: Every random access iterator also a bidirectional iterator, and every bidirectional iterator  also a forward iterator.
As we will see, different template  classes have different kinds of iterators.
The iterators for the  template class are random access iterators.
Note that the names forward iterator, bidirectional iterator, and random access iterator refer to kinds of iterators, not type names.
The actual type names will be something like std::<int>::iterator, which in this case happens to be a random access iterator.
SELF -TEST Exer cis e 4.
Suppose the  v contains the letters 'A', 'B', 'C', and 'D' in that.
Chapter 18 / Standard Template Library Constant and Mutable Iterators The categories forward iterator, bidirectional iterator, and random access iterator each subdivide into two categories: constant and mutable, depending on how the dereferencing operator behaves with the iterator.
With a constant iterator the dereferencing operator produces a read-only version of the element.
With a constant iterator , you can use *, for example, to assign it to a variable or output it to the screen, but you cannot change the element in the  by, for example, assigning it to *.
With a mutable iterator , * can be assigned a value and that will change the corresponding element in the The  iterators are mutable, as shown by the following lines from Display 18_0_1:.
If a  has only constant iterators, you cannot obtain a mutable iterator for the.
However, if a  has mutable iterators and you want a constant iterator for the , you can have it.
You might want a constant iterator as a kind of error checking if you intend that your code not change the elements in the.
For example, the following will produce a constant iterator for a   named : std::<char>::const_iterator  = _0_begin();.
However, every iterator of a type named const_ iterator will be a constant iterator.
Reverse Iterators Sometimes you want to cycle through the elements in a  in reverse order.
Fortunately, there  an easy way to do what you want.
The member function rbegin() returns an iterator located at the last element.
The member function rend() returns a sentinel that marks the "end" of the elements in the reverse order.
Note that for an iterator of type reverse_ iterator, the increment operator plus_plus moves backward through the elements.
In other words, the meanings of −− and plus_plus are interchanged.
The program in Display 18_0_3 demonstrates a reverse iterator.
Reverse Iterators A reverse iterator can be used to cycle through all elements of a , provided that the  has bidirectional iterators.
The general scheme  as follows:.
Chapter 18 / Standard Template Library Display 18_0_3   Reverse Iterator 1 2 3 4 5 6 //Program to demonstrate a reverse iterator.
Sample Dialogue Forward: A B C Reverse: C B A The reverse_iterator type also has a constant version, which is named const_reverse_iterator.
Other Kinds of Iterators There are other kinds of iterators that we will not cover in this book.
Briefly, two kinds of iterators you may encounter are an input iterator, which is essentially a forward iterator that can be used with input streams, and an 18_0_2 Containers output iterator, which is essentially a forward iterator that can be used with output streams.
For more details, you will need to consult a more advanced reference.
S elf- T est Exer cis es 5.
Suppose the  v contains the letters 'A', 'B', 'C', and 'D' in that.
Mark Twain, Pudd'n head Wilson The container classes of the STL are different kinds of data structures for holding data, such as lists, queues, and stacks.
Each is a template class with a parameter for the particular type of data to be stored.
So, for example, you can specify a list to be a list of ints, or doubles, or strings, or any class or struct type you wish.
Each container template class may have its own specialized accessor and mutator functions for adding data and removing data from the container.
Different container classes may have different kinds of iterators.
For example, one container class may have bidirectional iterators while another container class may have only forward iterators.
However, whenever they are have the same meaning for all STL container classes.
Chapter 18 / Standard Template Library Display 18_0_4   Two Kinds of Lists slist: a singly linked list.
Sequential Containers A sequential container arranges its data items into a list so that there is a first element, a next element, and so forth up to a last element.
The linked lists we discussed in Chapter 13 are examples of a kind of list.
The lists we discussed in Chapter 13 are sometimes called singly linked lists because there is only one link from one location to another.
The STL has no container corresponding to such singly linked lists, although some implementations do offer an implementation of them, typically under the name slist.
The simplest list that is part of the STL is the doubly linked list, which is the template class named list.
The difference between these two kinds of lists is illustrated in Display 18_0_4.
The lists in Display 18_0_4 contain the three integer values 1, 2, and 3 in that order.
The types for the two lists are slist<int> and list<int>.
That display also indicates the location of the iterators begin() and end().
We have not yet told you how you can enter the integers into the lists.
In Display 18_0_4 we have drawn our singly and doubly linked lists as nodes and pointers of the form discussed in Chapter 14.
The STL class list and the nonstandard class slist might (or might not) be implemented in this way.
So, you simply think in terms of locations for the data (which may or may not be nodes) and iterators (not pointers).
You can think of the arrows in Display 18_0_4 as indicating the directions for plus_plus (which is down) and −− (which is up in Display 18_0_4).
We wanted to present the template class slist to help give a context for the sequential containers.
It corresponds to what we discussed most in Chapter 13, and it is the first thing that comes to the mind of most programmers when you mention linked lists.
However, since the template class slist is not standard, we will discuss it no more.
If your implementation offers the template class slist and you want to use it, the details are similar to those we will describe for list, except that the decrement operators −− (prefix and postfix) are not defined for slist.
A simple program using the STL template class list is given in Display 18_0_5.
The function push_back adds an element to the end of the list.
Notice that for the list template class, the dereferencing operator gives you access to the data for reading and for changing the data.
Also notice that with the list template class and all the template classes and iterators of the STL, all definitions are placed in the std namespace.
Chapter 18 / Standard Template Library 22 23 24 25 26 27 28 29 30 31.
Sample Dialogue List contains: 1 2 3 Setting all entries to 0: List now contains: 0 0 0 Note that Display 18_0_5 would compile and run exactly the same if we replace  and <int> with vector and vector<int>, respectively.
This uniformity of usage is a key  of the STL syntax.
There are, however, differences between a vector and a  container.
One of the main differences is that a vector container has random access iterators while a  has only bidirectional iterators.
For example, if you start with Display 18_0_2, which uses random access, and replace all occurrences of vector and vector<char> with  and <char>, respectively, and then compile the program, you will get a compiler error.
A sample of some member functions is given in Display 18_0_7.
Other containers, such as stacks and queues, can be obtained from these using techniques discussed in the subsection entitled "Container Adapters stack and queue_0_" All these sequence template classes have a destructor that returns storage for recycling.
Deque, pronounced "d-queue" or "deck," stands for "doubly ended queue_0_" A deque is a kind of super queue.
With a queue you add data at one end of the data sequence and remove data from the other end.
With a deque 18_0_2 Containers 977 Display 18_0_6   STL Basic Sequential Containers Template	Iterator Type Names Kind of Iterators	Library Header File slist slist<T>::iterator.
Depends on implementation and may not be available.
Not a member of slist.
Not a member of slist.
Not a member of slist.
Not a member of vector.
Each also has a destructor that returns all storage for recycling and a well-behaved assignment operator_0_> you can add data at either end and remove data from either end.
The template class deque is a template class for a deque with a parameter for the type of data stored.
Sequential Containers A sequential container arranges its data items into a list so that there is a first element, a next element, and so forth up to a last element.
The sequential container template classes that we have discussed are slist, list, vector, and deque.
Pitfall Iterators and Removing Elements When you add or remove an element to or from a container, that can affect other iterators.
In general, there is no guarantee that the iterators will be located at the same element after an addition or deletion.
Some containers do, however, guarantee that the iterators will not be moved by additions or deletions, except of course if the iterator is located at an element that is removed.
The template classes vector and deque make no such guarantee.
We have already seen that STL container classes may contain the type names iterator, const_iterator, reverse_iterator, and const_reverse_iterator (and hence must contain their type definitions behind the scenes).
There are typically other type definitions as well.
All the template classes we have discussed so far have the defined types value_type and size_type.
The type value_type is the type of the elements stored in the container.
For example, list<int>::value_type is another name for int.
Another defined type is size_type, which is an unsigned integer type that is the return type for the member function.
As we noted in Chapter 8, the size_type for the vector template class is unsigned int, although most compilers will be happy if you think of the type as just plain int.
What is a major difference between a vector and a list.
Which of the template classes slist, list, vector, and deque have the member function push_back.
Which of the template classes slist, list, vector, and deque have random access iterators.
Which of the template classes slist, list, vector, and deque can have mutable iterators.
Container Adapters stack and queue Container adapters are template classes that are implemented on top of other classes.
For example, the stack template class is by default implemented on top of the deque template class, which means that buried in the implementation of the stack is a deque, which is where all the data resides.
However, you are shielded from this implementation detail and see a stack as a simple last-in/ first-out data structure.
Warning Other container adapter classes are the queue and priority_queue template classes.
Stacks and queues were discussed in Chapter 13.
A priority queue is like a queue with the additional property that each entry is given a priority when it is added to the queue.
If all entries have the same priority, then entries are removed from a priority queue in the same manner as they are removed from a queue.
If items have different priorities, the higher-priority items are removed before lower-priority items.
We will not be discussing priority queues in any detail, but mention it for those who may be familiar with the concept.
Although an adapter template class has a default container class on top of which it is built, you may choose to specify a different underlying container, for efficiency or other reasons depending on your application.
For example, any sequential container may serve as the underlying container for a stack and any sequential container other than vector may serve as the underlying container for a queue.
The default underlying data structure is the deque for both the stack and the queue.
For a priority_ queue, the default underlying container is a vector.
If you are happy with the default underlying container type, then a container adapter looks like any other template container class to you.
For example, the type name for the stack template class using the default underlying container is stack<int> for a stack of ints.
If you wish to specify that the underlying container is instead the vector template class, you would use stack<int, vector<int>> as the type name.
We will always use the default underlying container.
If you do specify an underlying container, be warned that Cplus_plus compilers prior to Cplus_plus11 cannot compile code with two > symbols in the type expression without a space in between them.
Use stack<int, vector<int>   >, with a space between the last two >'s.
Do not use stack<int, vector<int>>.
Cplus_plus11 compilers do not need a space between the two > symbols.
The member functions and other details about the stack template class are given in Display 18_0_8.
For the queue template class these details are given in Display 18_0_9.
A simple example of using the stack template class is given in Display 18_0_10.
Stack Adapter Template  Details Type name stack<T> or stack<T, Underlying_Container> for a stack of elements of type T.
Library header: <stack>, which places the definition in the std namespace.
Defined types: value_type, size_type.
Note that pop is a void function.
It does not return the element removed.
The stack template class also has a default constructor, a copy constructor, as well as a constructor that takes an object of any sequential container class and initializes the stack to the elements in the sequence.
It also has a destructor that returns all storage for recycling and a well-behaved assignment operator.
Queue Adapter Template  Details Type name queue<T> or queue<T, Underlying_Container> for a queue of elements of type T.
For efficiency reasons, the Underlying_Container cannot be a vector type.
Library header: <queue> which places the definition in the std namespace.
Defined types: value_type, size_type.
Sample Member Functions Member Function.
Note that pop is a void function.
It does not return the element removed.
The queue template class also has a default constructor, a copy constructor, as well as a constructor that takes an object of any sequential container class and initializes the stack to the elements in the sequence.
It also has a destructor that returns all storage for recycling and a well-behaved assignment operator.
The member function pop removes one element, but does not return that element.
So, we needed to use top to read the element we remove.
Sample Dialogue Enter a line of text: straw Written backward that is: warts S elf- T est Exer cises 11.
What kind of iterators (forward, bidirectional, or random access) does the template adapter class have.
What kind of iterators (forward, bidirectional, or random access) does the queue template adapter class have.
If  is a <char>, what is the type of the returned value of _0_pop().
Associative Containers set and map Associative containers are basically very simple databases.
They store data, such as structs or any other type of data.
Each data item has an associated value known as its key.
For example, if the data is a struct with an employee' record, the key might be the employee' Social Security number.
Items are retrieved on the basis of the key.
The key type and the type for data to be stored need not have any relationship to one another, although they often are related.
A very simple case is when the each data item is its own key.
For example, in a set every element is its own key.
The set template class is, in some sense, the simplest container you can imagine.
It stores elements without repetition.
The first insertion places an element in the set.
Additional insertions after the first have no effect, so no element appears more than once.
Each element is its own key; basically, you 983.
Chapter 18 / Standard Template Library just add or delete elements and ask if an element is in the  or not.
Like all STL classes, the  template class was written with efficiency as a goal.
In order to work efficiently, a  object stores its values in sorted order.
You can specify the order used for storing elements as follows: <T, Ordering> s; Ordering should be a well-behaved ordering relation that takes two arguments of type T and returns a bool value_0_1 T is the type of elements stored.
If no ordering is specified, then the ordering is assumed to be the < relational operator.
Some basic details about the  template class are given in Display 18_0_11.
A simple example that shows how to use some of the member functions of the template class  is given in Display 18_0_12.
A  is essentially  function given as   of ordered pairs.
For each value first that appears in  pair, there is at most one value second such that the pair (first, second) is in the.
The template class  implements objects in the STL.
For example, if you want to assign  unique number to each string name, you could declare   object as follows: <string, int> number_map; For string values known as keys, the number_map object can associate  unique int value.
An alternate way to think of   is as an associative array.
A traditional array maps from  numerical index to  value.
For example, [10] = 5 would store the number 5 at index 10.
An associative array allows you to define your own indices using the data type of your choice.
For example, numberMap[""] = 5 would associate the integer 5 with the string "".
For convenience, the [] square bracket operator is defined to allow you to use an array-like notation to access  , although you also can use the insert or find methods if you want.
Like   object,   object stores its elements in sorted order by its key values.
You can specify the ordering on keys as  third entry in the angular brackets <>.
If you do not specify an ordering,  default ordering is used.
The restrictions on orderings you can use is the same as those on the orderings allowed for the  template class.
Note that the ordering is on key values only.
The second type can be any type and need not have anything to do with any ordering.
As with the  object, the sorting of the stored entries in object is done for reasons of efficiency.
The ordering must be  strict weak ordering.
Most typical orderings used to implement the < operator is strict weak ordering.
For those who want the details: A strict.
The Ordering is used to sort elements for storage.
If no Ordering is given, the ordering used is the binary operator <.
Library header: <>, which places the definition in the std namespace.
Defined types : value_type, size_type.
Iterators: iterator, const_iterator, reverse_iterator, and const_reverse_iterator.
All iterators are bidirectional and those not including const_ are mutable.
Adding or deleting elements does not affect iterators, except for an iterator located at the element removed.
Sample Member Functions Member Function Meaning s_0_insert(Element)	Inserts  copy of Element in the.
If Element is already in the , this has no effect.
If Element is not in the , this has no effect.
If Element is not in the , s_0_end() is returned.
The  template class also has  default constructor,  copy constructor, as well as other specialized constructors not mentioned here.
It also has destructor that returns all storage for recycling and  well-behaved assignment operator.
Chapter 18 / Standard Template Library Display 18_0_12   Program Using the  Template Class 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31.
Sample Dialogue The  contains: A B C D Removing C.
A B D The easiest way to add and retrieve data from a map is to use the [] operator.
Given a map object m, the expression m[] will return a reference to the data element associated with.
If no  exists in the map for , then a new  will be created with the default value for the data element.
For objects of type string, the default value is an empty string.
The [] operator can be used to add a new  to the map or to replace an existing.
For example, the statement m[] = newData; will create a new association between  and newData.
Note that care must be taken to ensure that map entries are not created by mistake.
For example, if you execute the statement  = m[]; with the intention of retrieving the value associated with  but mistakenly enter a value for  that is not already in the map, then a new  will be made for  with the default value and assigned into.
Some basic details about the map template class are given in Display 18_0_13.
In order to understand these details, you first need to know something about the pair template class.
The STL template class pair<T1,T2> has objects that are pairs of values such that the first element is of type T1 and the second is of type T2.
If aPair is an object of type pair<T1,T2>, then aPair_0_first is the first element, which is of type T1, and aPair_0_second is the second element, which is of type T2.
The member variables first and second are public member variables, so no accessor or mutator functions are needed.
The header file for the pair template is <utility>.
So, to use the pair template class, you need the following, or something like it, in your file: # <utility> using std::;.
In either case, when we access this  using an iterator, iteratorarrow_operatorfirst will refer to the  "" while iteratorarrow_operatorsecond will refer to the data value 10.
A simple example that shows how to use some of the member functions of the template class  is given in Display 18_0_14.
We will mention two other associative containers, although we will not give any details about them.
The template classes multiset and multimap are essentially the same as  and , respectively, except that a multiset allows repetition of elements and a multimap allows multiple values to be associated with each  value.
Chapter 18 / Standard Template Library Display 18_0_13    Template Class Template Class Details Type name <KeyType, T> or <KeyType, T, Ordering> for a  that associates ("maps") elements of type KeyType to elements of type T.
The Ordering is used to sort elements by  value for efficient storage.
If no Ordering is given, the ordering used is the binary operator <.
Library header: <> places the definition in the std namespace.
Defined types : key_type for the type of the  values, mapped_type for the type of the values mapped to, and size_type.
All iterators are bidirectional.
Those iterators not including const_ are neither constant nor mutable, but something in between.
For example, if  is of type iterator, then you change the  value but not the value of type T.
Perhaps it is best, at least at first, to treat all iterators as if they were constant.
Adding or deleting elements does not affect iterators, except for an iterator located at the element removed.
Sample Member Functions Member Function Meaning m_0_insert(Element)	Inserts Element in the.
Element is of type <KeyType, T>.
Returns a value of type <iterator, bool>.
Removes the element with the  Target_Key.
Returns m_0_end() if there is no such element.
If the  does not already contain such an object, then a default object of type T is inserted and returned.
The  template class also has a default constructor, a copy constructor, as well as other specialized constructors not mentioned here.
It also has a destructor that returns all storage for recycling and a well-behaved assignment operator.
Sample Dialogue Entry for  - Hot planet is in the.
The iterator will output the  in order sorted by the key.
In this case the output will be listed alphabetically by planet.
Iterating through all : - Home.
Chapter 18 / Standard Template Library - Largest planet in our solar system - The Red Planet - Hot planet - 1500 mile-per-hour winds - Dwarf planet - Has rings - Tilts on its side - Atmosphere of sulfuric acid ■ Programming Tip Use Initialization, Ranged for, and auto VideoNote Cplus_plus11 and Containers with Containers Several features introduced in Cplus_plus11 make it easier to work with collections.
In particular, you can initialize your container objects using the uniform initializer list format, which consists of initial data in curly braces.
You can also use auto and the ranged for loop to easily iterate through a container.
Consider the following two initialized collection objects:.
We can iterate through each container conveniently using a ranged for loop and auto: for (auto for (auto.
In fact, the STL implementations strive to be optimally efficient.
For example, the and  elements are stored in sorted order so that algorithms that search for the elements can be more efficient.
Each of the member functions for each of the template classes has a ­guaranteed maximum running time.
These maximum running times are ­expressed using what is called big-O notation, which we discuss in Section 18_0_3.
These are in the subsection entitled "Container Access Running Times_0_") When using more advanced references or even later in this chapter, you will be told the guaranteed maximum running times for certain functions.
S elf- T est Exer cis es 14.
How many elements will be in the   after the following code is.
What value is returned if 'A' is not in s.
We cannot give you a comprehensive description of them all here, but will present a large enough sample to give you a good feel for what is contained in the STL and to give you sufficient detail to start using these template functions.
These template functions are sometimes called generic algorithms.
The term algorithm is used for a reason.
Recall that an algorithm is just a  of instructions for performing a task.
An algorithm can be presented in any language, including a programming language like Cplus_plus.
But when using the word algorithm, programmers typically have in mind a less formal presentation given in English or pseudocode.
As such, it is often thought of as an abstraction of the code defining a function.
It gives the important details but not the fine details of the coding.
The STL specifies certain details about the algorithms underlying the STL template functions and that is why they are sometimes called generic algorithms.
These STL function templates do more than just deliver a value in any way that the implementers wish.
The function templates in the STL come with minimum requirements that must be satisfied by their implementations if they are to satisfy the standard.
In most cases, they must be implemented with a guaranteed running time.
This adds an entirely new  to the idea of a function interface.
In the STL, the interface not only tells a programmer what the function does and how to use the functions; the interface also tells how rapidly the task will be done.
In some cases, the standard even specifies the 991.
Chapter 18 / Standard Template Library particular algorithm that is used, although not the exact detail of the coding.
Moreover, when it does specify the particular algorithm, it does so because of the known efficiency of the algorithm.
The key new  is a specification of an efficiency guarantee for the code.
In this chapter we will use the terms generic algorithm, generic function, and STL function template to all mean the same thing.
In order to have some terminology to discuss the efficiency of these template functions or generic algorithms, we  present some background on how the efficiency of algorithms is usually measured.
Running Times and Big-O Notation If you ask a programmer how fast his or her program is, you might expect an answer like "two seconds_0_" However, the speed of a program cannot be given by a single number.
A program will typically take a longer amount of time on larger inputs than it will on smaller inputs.
You would expect that a program to sort numbers would take less time to sort ten numbers than it would to sort one thousand numbers.
Perhaps it takes two seconds to sort ten numbers, but ten seconds to sort one thousand numbers.
How, then, should Running Time 2 seconds 100 numbers.
That need not be true.
Perhaps it takes much less time if the list is already sorted or almost sorted.
In that case, T(N) is defined to be the time taken by the "hardest" list, that is, the time taken on that list of N numbers which makes the program run the longest.
This is called the worst-case running time.
In this chapter we will always mean worst-case running time when we give a running time for an algorithm or for some code.
The time taken by a program or algorithm is often given by a formula, such as 4N + 3, 5N + 4, or N2.
If the running time T(N) is 5N + 5, then on inputs of size N the program will run for 5N + 5 time units.
Following is some code for searching an array a with N elements to determine whether a particular value target is in the array: int  = 0; bool  = false;.
We would like an estimate that does not depend on which computer we use, either because we do not know which computer we will use or because we might use several different computers to run the program at different times.
One possibility is to count the number of "steps," but it is not easy to decide what a step is.
In this situation the normal thing to do is to count the number of operations.
The term operations is almost as vague as the term step, but there is at least some agreement in practice about what qualifies as an.
Let us say that, for this Cplus_plus code, each application of any of the following will count as an : =, <, &&, _0_, [], ==, and plus_plus.
The computer must do other things besides carry out these operations, but these seem to be the main things that it is doing and we will assume that they account for the bulk of the time needed to run this code.
In fact, our analysis of time will assume that everything else takes no time at all and that the total time for our program to run is equal to the time needed to perform these operations.
Although this is an idealization that clearly is not completely true, it turns out that this simplifying assumption works well in practice and so is often made when analyzing a program or algorithm.
Even with our simplifying assumption, we still must consider two cases: Either the value target is in the array or it is not.
Let us first consider the case when target is not in the array.
Since we are assuming that target is not in the array, the loop will be executed N times, one for each element of the array.
Each time the loop is executed, the following operations are : <, &&, _0_, [], ==, and plus_plus This adds six operators for each of N loop iterations.
Finally, after N iterations, the Boolean expression is again checked and  to be false.
This adds a final 993.
Chapter 18 / Standard Template Library three operations (<, &&, _0_)_0_2 If we tally all these operations, we get a total of 6 + 5 operations when the target is not in the array.
We will leave it as an exercise for you to confirm that if the target is in the array, then the number of operations will be 6 + 5 or less.
Thus, the worst-case running time is () = 6 + 5 operations for any array of  elements and any value of target.
We just determined that the worst-case running time for our search code is 6 + 5 operations.
But operations is not a traditional unit of time, like nanoseconds, seconds, or minutes.
If we want to know how long the algorithm will take on some particular computer, we must know how long it takes that computer to perform one.
If an  can be  in 1 nanosecond, then the time will be 6 + 5 nanoseconds.
If an  can be  in 1 second, the time will be 6 + 5 seconds.
If we use a slow computer that takes 10 seconds to perform an , the time will be 60 + 50 seconds.
In general, if it takes the computer c nanoseconds to perform one , then the actual running time will be approximately c(6 + 5) nanoseconds.
To get the running time expressed in nanoseconds, you must multiply by some constant that depends on the particular computer you are using.
Our estimate of 6 + 5 is only accurate to "within a constant multiple_0_" There is a standard notation for these sorts of estimates and we discuss this notation next.
Estimates on running time, such as the one we just went through, are normally expressed in something called big-O notation.
Under these circumstances, we say the code (or program or algorithm) runs in time O(6 + 5).
This is usually read as "big-O of 6 + 5_0_" We need not know what the constant c will be.
In fact, it will undoubtedly be different for different computers, but we must know that there is one such c for any reasonable computer system.
If the computer is very fast, then the c might be less than 1—say, 0_0_001.
If the computer is very slow, the c might be very large—say, 1000.
Moreover, since changing the units, say from nanosecond to second, only involves a constant multiple, there is no need to give any units of time.
Be sure to notice that a big-O estimate is an upper-bound estimate.
We always approximate by taking numbers on the high side, rather than the low side, of the true count.
Also notice that when performing a big-O estimate, we need not determine a very exact count of the number of operations.
We only need an estimate that is correct "up to a constant multiple_0_" If our estimate is twice as large as the true number, that is good enough.
Because of short circuit evaluation, _0_() is not evaluated, so we actually get two, not three operations.
However, the important thing is to obtain a good upper bound.
If we add in one extra  that is not significant.
In our sample case, this parameter  was the number of array elements to be searched.
Not surprisingly, it takes longer to search a larger number of array elements than it does to search a smaller number of array elements.
BigO running time estimates are always expressed as a function of the size of the problem.
In this chapter all our algorithms will involve a range of values in some container.
In all cases  will be the number of elements in that range.
For example, all of the following are O(2): 2 + 2 + 1, 32 + 7, 1002 + All of the following are O(3): 3 + 52 +  + 1, 83 + 7, 1003 + 4 + 1 Big-O running-time estimates are admittedly crude, but they do contain some information.
They will not distinguish between a running time of 5 + 5 and a running time of 100, but they do let us distinguish between some running times and so determine that some algorithms are faster than others.
Look at the graphs in Display 18_0_16; notice that all the graphs for functions that are O() eventually fall below the graph for the function 0_0_52 algorithm could be faster than an O() algorithm for the problem size you are handling, programmers have found that in practice O() algorithms perform better than O(2) algorithms for most practical applications that are intuitively "large_0_" Similar remarks apply to any other two different big-O running times.
Some terminology will help with our descriptions of generic algorithm running times.
Linear running time means a running time of () = aN + b.
A linear running time is always an O() running time.
Quadratic running time means a running time with highest term 2.
A quadratic running time is always an O(2) running time.
We will also occasionally have logarithms in running-time formulas.
Those normally are given without any base, since changing the base is just a constant multiple.
If you see log , think log base 2 of , but it would not be wrong to think log base 10 of.
Logarithms are very slow-growing functions.
So, a O(log ) running time is very fast.
Sometimes log2  is written as lg.
Container Access Running Times Now that we know about big-O notation, we can express the efficiency of some of the accessing functions for container classes that we discussed in Section 18_0_2 "Containers_0_" Insertions at the back of a vector (push_back), 995 Chapter 18 / Standard Template Library 1.
For a set or map, finding (find) is O(log ), where is the number of elements in the container.
S elf-  est Exe r cis es 17.
Show that a running time () = aN + b is an O() running time.
Show that for any two bases a and b for logarithms, if a and b are both greater than 1, then there is a constant c such that loga  ≤ c(logb ).
Thus, there is no need to specify a base in O(log ).
A good simple and typical example is the generic find function.
The generic find function is similar to the find member function of the set template class but is a different find function; in particular, the generic find function takes more arguments than the find function we discussed when we presented the set template class.
The generic find function searches a container to locate a particular element, but the generic find can be used with any of the STL sequential container classes.
Display 18_0_17 shows a sample use of the generic find function used with the class vector<char>.
The function in Display 18_0_17 would behave exactly the same if we replaced vector<char> with list<char> throughout, or if we replaced vector<char> with any other sequential container class.
That is one of the reasons why the functions are called generic.
One definition of the find function works for a wide selection of containers.
If the find function does not find the element it is looking for, it returns its second iterator argument, which need not be equal to some end() as it is in Display 18_0_17.
Sample Dialogue 2 shows the situation when find does not find what it is looking for.
Chapter 18 / Standard Template Library 21 22 23.
Sample Dialogue 1 Enter a line of text A line of text.
You entered the following before you entered your first e: A lin You entered the following after that: e of text.
End of demonstration.
Sample Dialogue 2 Enter a line of text I will not.
You entered the following before you entered your first e: I will not.
You entered the following after that: If find does not find what it is looking for, it.
End of demonstration.
Does find work with absolutely any container classes.
To start with, it takes iterators as arguments, and some containers, such as stack, do not have iterators.
To use the find function, the container must have iterators, the elements must be stored in a linear sequence so that the 18_0_3 Generic Algorithms plus_plus operator moves iterators through the container, and the elements must be comparable  ==.
In other words, the container must have forward iterators (or some stronger kind of iterators, such as bidirectional iterators).
When presenting generic function templates, we will describe the iterator type parameter by  the name of the required kind of iterator as the type parameter name.
So ForwardIterator should be replaced by a type that is a type for some kind of forward iterator, such as the iterator type in a list, , or other container template class.
Remember, a bidirectional iterator is also a forward iterator, and a random access iterator is also a bidirectional iterator.
So the type name ForwardIterator can be used with any iterator type that is a bidirectional or random access iterator type as well as a plain old forward iterator type.
In some cases, when we specify ForwardIterator you can use an even simpler iterator kind; namely, an input iterator or output iterator, but since we have not discussed input and output iterators, we do not mention them in our function template declarations.
Remember the names forward iterator, bidirectional iterator, and random access iterator refer to kinds of iterators, not type names.
The actual type names will be something like std::<int>::iterator, which in this case happens to be a random access iterator.
Display 18_0_18 gives a sample of some nonmodifying generic functions in the STL.
The display uses a notation that is common when discussing container iterators.
The iterator locations encountered in moving from an iterator first to, but not equal to, an iterator last is called the range [first, last).
For example, the following for loop outputs all the elements in the range [first, last): << * << endl; Note that when two ranges are given they need not be in the same container or even in the same type of container.
For example, for the search function, the ranges [first1, last1) and [first2, last2) may be in the same or different containers.
The movement from some iterator first, often container_0_begin(), up to but not including some location last, often container_0_end(), is so common it has come to have a special name, range [first, last).
For example, the following outputs all elements in the range [c_0_begin(),c.
Chapter 18 / Standard Template Library Display 18_0_18   Some Nonmodifying Generic Functions These all work for forward iterators, which means they also work for bidirectional and random access iterators.
Returns second if target is not found.
Otherwise, returns false.
ForwardIterator1 search(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2); //Checks to see if [first2, last2) is a subrange of [first1, last1).
Returns last1 if a match is not found.
The actual return type is an integer type that we have not discussed, but the returned value should be assignable to a variable of type int.
The function search searches for a subsequence, while the find and binary_search functions search for a single value.
How do you decide whether to use find or binary_search when searching for a single element.
One returns an iterator and the other returns just a Boolean value, but that is not the biggest difference.
The binary_search function requires that the range being searched be sorted (into ascending order using <) and run in time O(log N); the find function does not require that the range be sorted but it guarantees only linear time.
If you have or can have the elements in sorted order, you can search for them much more quickly by using binary_search.
Note that with the binary_search function you are guaranteed that the implementation will use the binary search algorithm, which was discussed in Chapter 14.
The importance of using the binary search algorithm is that it guarantees a very fast running time, O(log N).
If you have not read Chapter 14 and have not otherwise heard of binary search, just think of it as a very efficient search algorithm that requires that the elements be sorted.
Those are the only two points about binary search that are relevant to the material in this chapter.
S elf- T est Exer cis es 19_0_	Replace all occurrences of the identifier vector with the identifier list in Display 18_0_17.
Compile and run the program.
Suppose v is an object of the class vector<int>.
Use the search generic function (Display 18_0_18) to write some code to determine whether or not v contains the number 42 immediately followed by 43.
You need not give a complete program, but do give all necessary include and using Container Modifying Algorithms Display 18_0_19 contains descriptions of some of the generic functions in the STL which change the contents of a container in some way.
Remember that when you add or remove an element to or from a container, that can affect any of the other iterators.
There is no guarantee that the iterators will be located at the same element after an addition or deletion unless the container template class makes such a guarantee.
Of the template classes we have seen, list and slist guarantee that their iterators will not be moved by additions or deletions, except of course if the iterator is located at an element that is removed.
The template classes vector and deque make no such guarantee.
Some of the function templates in Display 18_0_19 guarantee the values of some specific iterators and those guarantees you can, of course, count on, no matter what the container is.
Chapter 18 / Standard Template Library Display 18_0_19   Some Modifying Generic Functions 1 2 3.
The name of the iterator type parameter tells the kind of iterator for which the function works.
Remember that these are minimum iterator requirements.
For example, ForwardIterator works for forward iterators, bidirectional iterators, and random access iterators.
There is then an iterator i in this //range such that //all the values not equal to target are in [first, i).
S elf- T est Exe r cis es 21.
Can you use the random_shuffle template function with a list container.
Can you use the copy template function with vector containers, even though copy requires forward iterators and vector has random access iterators.
Algorithms Display 18_0_20 shows a sample of the generic set operation functions defined in the STL.
Note that these generic algorithms assume the containers store their elements in sorted order.
The containers set, map, multiset, and multimap do store their elements in sorted order, so all the functions in Display 18_0_20 apply to these four template class containers.
Other containers, such as vector, do not store their elements in sorted order and these functions should not be used with such containers.
The reason for requiring that the elements be sorted is so that the algorithms can be more efficient.
These operations work for sets, maps, multisets, multimaps (and other containers) but do not work for all containers.
For example, they do not work for vectors, lists, or deques unless their contents are sorted.
For these containers to work, the elements in the container must be stored in sorted order.
These operators all work for forward iterators, which means they also work for bidirectional and random access iterators.
Otherwise, returns false.
Chapter 18 / Standard Template Library 28 29 30 31 32 33 34 35 36 void set_difference(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2, ForwardIterator3 result); //Creates a sorted set difference of the two ranges [first1, last1) and //[first2, last2).
S elf- T est Exe r cis e 23.
The mathematics course version of a set does not keep its elements in sorted order and it has a union operator.
Why does the set_union template function require that the containers keep their elements in sorted order.
Sorting Algorithms Display 18_0_21 gives the declarations and documentation for two template functions, one to sort a range of elements and one to merge two sorted ranges of elements.
Note that the sorting function sort guarantees a run time of O(N log N).
Although it is beyond the scope of this book, it can be shown that you cannot write a comparisonbased sorting algorithm that is faster than O(N log N).
So this guarantees that the sorting algorithm is as fast as is possible, up to a constant multiple.
Display 18_0_21   Some Generic Sorting Algorithms 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template<class RandomAccessIterator> void sort(RandomAccessIterator first, RandomAccessIterator ); //Sorts the elements in the range [first, ) into ascending order.
Sorting uses the < operator, and so the < operator must be defined.
Answers to Self-Test Exercises Chapter Summary ■ An iterator is a generalization of a pointer.
Iterators are used to move through the elements in some range of a container.
The operations plus_plus, −−, and dereferencing * are usually defined for an iterator.
The main kinds of iterators are Forward iterators: plus_plus works on the iterator.
Bidirectional iterators: both plus_plus and −− work on the iterator.
Random access iterators: plus_plus, −−, and random access all work with the iterator.
With a mutable iterator , * can be assigned a value.
A stack is a -in/first-out container.
A queue is a first-in/first-out container.
A set is a simple collection of elements.
A map allows storing and retrieving by key values.
The multiset class allows repetitions of entries.
The multimap class allows a single key to be associated with multiple data items.
Answers to S elf-Test Exerci ses 1.
A major difference is that a  container has random access iterators whereas a list has only bidirectional iterators.
They all can have mutable iterators.
The stack template adapter class has no iterators.
The queue template adapter class has no iterators.
One is a mapping from 5 to "cplus_plus" and the other is a mapping from 4 to the default string, which is blank.
Yes they can be of any type, although there is only one type for each set object.
The type parameter in the template class is the type of elements stored.
If 'A' is in s, then s_0_find('A') returns an iterator located at the element 'A'.
Just note that aN + b ≤ (a + b), as long as 1 ≤.
This is mathematics, not ,  = will mean equals not assignment.
First note that loga  = (loga b)(logb ).
To see this first identity, just note that if you raise a to the power loga , you get , and if you raise a to the power (loga b)(logb ), you also get.
If you set  = (loga b), you get loga  = (logb ).
The programs should run exactly the same.
Yes, a random access iterator is also a forward iterator.
The set_union template function requires that the containers keep their elements in sorted order to allow the function template to be implemented in a more efficient way.
Practice Programs Practice Programs can generally be solved with a short program that directly applies the programming principles presented in this chapter.
Write a program in which you declare a deque to store values of type double, read in ten double numbers, and store them in the deque.
Then call the generic sort function to sort the numbers in the deque and display the results.
Write a program that uses the map template class to compute a histogram of positive numbers entered by the user.
The map's key should be the number that is entered, and the value should be a counter of the number of times the key has been entered  far.
Use −1 as a sentinel value to signal the end of user input.
For example, if the user inputs: 5 12 3 5 5 3 21 -1 then the program should output the following (not necessarily in this order): The The The The number number number number 3 occurs 2 times.
VideoNote Solution to Practice Program 18_0_2 1008 Chapter 18 / Standard Template Library 3_0_	Given a variable of type string set to arbitrary text, write a program that uses the stack template class of type char to reverse the string.
You have a list of student ID's followed by the course number (separated by a space) that the student is enrolled in.
The listing is in no particular order.
For example, if student 1 is in CS100 and CS200 while student 2 is in CS105 and MATH210 then the list might look like this: 1 2 2 1 CS100 MATH210 CS105 CS200 Write a program that reads data in this format from the console.
If the ID is -1 then stop inputting data.
Use the map template class to map from an integer (the student ID) to a  of type string that holds each class that the student is enrolled in.
After all data is input, iterate through the map and output the student ID and all classes stored in the  for that student.
The  should be a list of classes organized by student ID.
If you aren't using 11 or higher then don't forget that you need a space between the >> characters when defining the map of vectors.
Programming Projects Programming Projects require more problem-solving than Practice Programs and can usually be solved many different ways.
Visit www_0_myprogramminglab_0_com to complete many of these Programming Projects online and get instant feedback.
Write a program that allows the user to enter any number of student names and their scores.
The program should then display the student names and scores according to the ascending order of scores.
Use the template class  and the generic sort function from the STL.
Note that you will need to define a structure or class type for data consisting of one student name and score.
You will also need to overload the < operator for this structure or class.
A prime number is an integer greater than 1 and divisible only by itself and 1.
An integer  is divisible by an integer y if there is another integer z such that = y * z.
The Greek mathematician Eratosthenes (pronounced: Er-ahtos-thin-eeze) gave an algorithm, called the Sieve of Eratosthenes, for finding all prime numbers less than some integer.
The algorithm works like this: Begin with a list of integers 2 through.
The number 2 is the first prime.
We cross these off the list.
Then the first number after 2 that was not crossed off is the next prime.
The multiples Programming Projects of 3 are not primes.
Cross the multiples of 3 off the list.
Note that 6 is already gone, cross off 9, 12 is already gone, cross off 15, etc.
The first number not crossed off is the next prime.
The algorithm continues on in this fashion until we reach.
All the numbers not crossed off the list are primes.
Use a  container for the integers.
Use an array of bool initially set to all true to keep track of crossed-off integers.
Change the entry to false for integers that are crossed off the list.
We can improve our solution in several ways: c_0_	The program does not need to go all the way to.
Try this and test your program.
Argue that to get all the primes between 1 and  the minimum limit is the square root of.
Suppose you have a collection of student records.
The records are structures of the following type: struct StudentInfo.
The records are maintained in a vector<StudentInfo>.
Write a program that prompts for and fetches data and builds a vector of student records, then sorts the vector by name, calculates the maximum and minimum grades and the class average, then prints this summarizing data along with a class roll with grades.
Continuing Programming Project 3, write a function that separates the students in the vector of StudentInfo records into two vectors, one containing records of passing students and one containing records of failing You are asked to do this in two ways, and to give some run-time estimates.
You could generate a second vector of passing students and a third vector of failing students.
This keeps duplicate records for at least some of the time, so don't do it that way.
You could create a vector of failing students and a test-for-failing function.
Then you push_back failing student records, then erase 1009.
Chapter 18 / Standard Template Library (which is a member function) the failing student records from the original vector.
Write the program this way.
You are potentially erasing O() members from the middle of a vector.
You have to move a lot operation.
Give a big-O estimate of the running time for this program.
Consider how the time efficiency of erase for a list affects the run-time for the program.
Rewrite this program using a list instead of a vector.
Remember that a list provides neither indexing nor random access and its iterators are only bidirectional, not random access.
Use the generic set_intersection function to compute the intersection of Q and D.
Here is an example of set_intersection to intersect  A with B and store the result in C, where all sets are sets of strings: # <iterator>.
VideoNote Solution to Programming Project 18_0_6 6.
In this project you are to create a database of books that are stored using a vector.
Keep track of the author, title, and publication date of each book.
Your program should have a main menu that allows the user to select from the following: (1) Add a book's author, title, and date; (2) Print an alphabetical list of the books sorted by author; and (3) Quit.
You must use a class to hold the data for each book.
This class must hold three string fields: one to hold the author's name, one for the publication date, and another to hold the book's title.
Store the entire database of books in a vector in which each vector element is a book class object.
To sort the data, use the generic sort function from the <algorithm> library.
Note that this requires you to define the < operator to compare two objects of type Book so that the author field from the two books are compared.
Programming Projects A sample of the input/output behavior might look as follows.
Your I/O need not look identical, this is just to give you an idea of the functionality.
Select from the following choices: 1.
Add new book 2.
Print listing sorted by author 3.
Quit 1 Enter title: More Than Human Enter author: Sturgeon, Theodore Enter date: 1953 Select from the following choices: 1.
Add new book 2.
Print listing sorted by author 3.
Quit 1 Enter title: Problem Solving with Cplus_plus Enter author: Savitch, Walter Enter date: 2015 Select from the following choices: 1.
Add new book 2.
Print listing sorted by author 3.
Quit 2 The books entered so far, sorted alphabetically by author are: Savitch, Walter.
Problem Solving with Cplus_plus.
Select from the following choices: 1.
Add new book 2.
Print listing sorted by author 3.
Quit 1 Enter title: At Home in the Universe Enter author: Kauffman Enter date: 1996 1011.
Chapter 18 / Standard Template Library Select from the following choices: 1.
Add new book 2.
Print listing sorted by author 3.
Quit 2 The books entered so far, sorted alphabetically by artist are: Kauffman, At Home in the Universe, 1996 Savitch, Walter.
Problem Solving with Cplus_plus.
When creating a  containing lists, make sure to place a space between the last two >'s if you are using a compiler earlier than Cplus_plus11.
For example, <list<int>> defines a  where elements are linked lists containing elements of type int.
The code <list<int> > without a space will produce a ­compiler 8.
You have collected a file of movie ratings where each movie is rated from 1 (bad) to 5 (excellent).
The first line of the file is a number that identifies how many ratings are in the file.
Each rating then consists of two lines: the name of the movie followed by the numeric rating from 1 to 5.
Here is a sample rating file with four unique movies and seven ratings: 7 Harry Potter and the Order of the Phoenix 4 Harry Potter and the Order of the Phoenix 5 The Bourne Ultimatum 3 Harry Potter and the Order of the Phoenix 4 The Bourne Ultimatum 4 Wall-E 4 Glitter 1 Write a program that reads a file in this format, calculates the average rating for each movie, and outputs the average along with the number of reviews.
Here is the desired output for the sample data: Glitter: 1 review, average of 1 / 5 Harry Potter and the Order of the Phoenix: 3 reviews, average of 4_0_3 / 5 Programming Projects The Bourne Ultimatum: 2 reviews, average of 3_0_5 / 5 Wall-E: 1 review, average of 4 / 5 Use a map or multiple maps to calculate the output.
Your map(s) should index from a string representing each movie's name to integers that store the number of reviews for the movie and the sum of the ratings for the movie.
Consider a text file of names, with one name per line, that has been compiled from several different sources.
A sample follows: Brooke Trout Dinah Soars Jed Dye Brooke Trout Jed Dye Paige Turner There are duplicate names in the file.
We would like to generate an invitation list but don't want to send multiple invitations to the same person.
Write a program that eliminates the duplicate names by using the set template class.
Read each name from the file, add it to the set, and then output all names in the set to generate the invitation list without duplicates.
Do Programming Project 16 from Chapter 8 except use a Racer class to store information about each race participant.
The class should store the racer's name, bib number, finishing position, and all of his or her split times as recorded by the RFID sensors.
You can choose appropriate structures to store this information.
Include appropriate functions to access or change the racer's information, along with a constructor.
Use a map to store the race data.
The map should use the bib number as the key and the value should be the Racer object that corresponds to the bib number.
With the map you won't need to search for a bib number anymore, you can directly access the splits and final position based on the bib number.
If you aren't using Cplus_plus11 or higher then don't forget that you need a space between the >> characters when defining the map of vectors.
Cplus_plus Keywords The following keywords should not be used for anything other than their predefined purposes in the Cplus_plus language.
In particular, do not use them for variable names or for programmer-defined functions.
In addition to the following keywords listed, identifiers containing a double underscore (__) are reserved for use by Cplus_plus implementations and standard libraries and should not be used in your programs.
Precedence of Operators All the operators in a given box have the same precedence.
Operators in higher boxes have higher precedence than operators in lower boxes.
Unary operators and the assignment operator are executed right to left when operators have the same precedence.
For example,  =  = z means  = ( = z).
Other operators that have the same precedences are executed left to right.
For example,  +  + z means ( + ) + z.
The ASCII Character Set Only the printable characters are shown.
Character number 32 is the blank.
The function declaration gives the number and types of arguments as well as the type of the value returned.
In most cases, the function declarations give only the type of the parameter and do not give a Arithmetic Functions Function Declaration Description.
Appendix 4 Input and Output Member Functions Form of a Function Call Description.
The External_File_Name is a string fstream.
Stream_Var_0_fail( ); Returns true if the previous operation (such as open) on the stream Stream_Var has failed.
Stream_Var_0_eof( ); Returns true if the program has attempted to read beyond the last character in the file connected to the input stream Stream_Var.
Otherwise, it returns false.
Stream_Var_0_get (Char_Variable); Reads one character from the input stream Stream_Var and sets the Char_Variable equal to this character.
Does not skip over whitespace.
If the line is more than Max_ Characters long, only the first Max_Characters are read.
The declared size of the String_Var should be Max_Characters +1 fstream or iostream.
Stream_Var_0_peek( ); Reads one character from the input stream Stream_Var and returns that character.
But the character read is not removed from the input stream; the next read will read the same character.
Writes the value of the Char_Exp to the output stream Stream_Var.
Stream_Var_0_putback (Char_Exp); Places the value of Char_Exp in the input stream Stream_Var so that that value is the next input value read from the stream.
The file connected to the stream is not changed.
Stream_Var_0_precision (Int_Exp); Specifies the number of digits output after the decimal point for floating-point values sent to the output stream Stream_Var.
Sets the field width for the next value output to the stream Stream_Var.
See Display 6_0_5 for the list of possible flags.
See Display 6_0_5 for the list of possible flags.
If the value returned is a value of type int, you must perform an explicit or implicit typecast to obtain a char.
Function Declaration Description.
Returns true if its argument is an upper- or lowercase letter.
It may also return true for other arguments.
The details are implementation dependent.
Otherwise, returns false.
Returns true if its argument is a printable character that does not satisfy isalnum and is not whitespace.
Appends the value of the String_Expression to.
Changes the value of the String_Variable to.
Returns the NULL pointer if the Pattern is not found.
Returns the NULL pointer if Character is not found.
Returns the NULL pointer if Character is not found.
Returns an integer that is less than zero, zero, or greater than zero according to whether String_Exp1 is less than, equal to, or greater than String_Exp2, respectively.
The ordering is lexicographic ordering.
RAND_MAX is a predefined integer constant that is ­defined in cstdlib.
The value of RAND_MAX is ­implementation dependent but will be at least 32767.
Reinitializes the random number generator.
The argument is the seed.
Calling srand multiple times with the same argument will cause rand or random (whichever you use) to produce the same sequence of pseudorandom numbers.
If rand or random is called without any previous call to srand, the sequence of numbers produced is the same as if there had been a call to srand with an argument of 1.
You can think of the argument type as int with the restriction that it must Appendix 4 Trigonometric Functions These functions use radians, not degrees.
Function Declaration Description.
Inline Functions When a member function definition is short, you can give the function definition within the definition of the class.
You simply replace the member function declaration with the member function definition; however, since the definition is within the class definition, you do not include the class name and scope resolution operator.
For example, the class Pair defined below has inline function definitions for its two constructors and for the member function get_first: class Pair {.
Note that there is no semicolon needed after the closing brace in an inline function definition, though it is not incorrect to have a semicolon there.
Inline function definitions are treated differently by the compiler and so they usually run more efficiently, although they consume more storage.
With an inline function, each function call in your program is replaced by a compiled version of the function definition, so calls to inline functions do not have the overhead of a normal function call.
If you want to use [] in an expression on the left-hand side of an assignment , then the  must be defined to return a reference, which is indicated by adding & to the returned type.
Appendix 6 Objects are declared and used as follows: Pair [1] [2].
The this Pointer When defining member functions for  class, you sometimes want to refer to the calling object.
The this pointer is  predefined pointer that points to the calling object.
For example, consider  class like the following: class Sample { public: _0__0_.
Notice that this is not the name of the calling object, but is the name of pointer that points to the calling object.
The this pointer cannot have its value changed; it always points to the calling object.
As the comment before the previous sample use of this indicates, you normally have no need for the pointer this.
However, in  few situations it is handy.
One place where the this pointer is commonly used is in  the assignment  =.
For example, consider the following class: Overloading the assignment 1029 1030 Appendix 7 class { public: _0__0_.
The definition of  overloaded assignment  uses  this pointer.
The definition above does have  problem in one case: If  same object occurs on both sides of  assignment  (like =;), then  array member will be deleted.
To avoid  problem, you can use   pointer to test  special case as follows: //Final version with bug fixed:.
In  section of Chapter 11 entitled "Overloading  Assignment Operator," we overloaded  assignment  for  string class called StringVar.
In that section, we did not need   pointer because we had  member variable called max_length that we could use to test whether or not  same object was used on both sides of  assignment =.
With  class  discussed above, we have no such alternative because there is only one member variable.
In  case, we have essentially no alternative but to use   pointer.
For example, in Display 11_0_5 of Chapter 11 we overloaded +  as  friend.
We did  by labeling    friend inside class definition, as follows: //Class  amounts of money in The United States currency.
We then defined  overloaded  + outside  class definition (as shown in Display 11_0_5).
It is also possible to overload   + (and other operators) as member operators.
To overload  +  as  member , class definition would instead begin as follows: //Class  amounts of money in The United States currency.
Money cost(1, 50), tax(0, 15), ; = cost + tax;.
The first argument to + is an unqualified , and so it is  member variable  of  calling object.
Overloading an  as  member variable can seem strange at first, but it is easy to get used to  new.
Many experts advocate always overloading operators as member operators rather than as friends.
That is more in  spirit of object-oriented programming.
However, there is  big disadvantage to overloading  binary  as  member.
When you overload  binary  as  member ,  two arguments are This is because Money has  constructor with one argument of type long, and so  value 25 will be considered  long value that is automatically converted to  value of type Money.
However, if you overload + as  member , then you cannot reverse  two arguments to +.
The following is illegal: = 25 + base_amount; This is because 25 cannot be  calling object.
Conversion of long values to type Money works  arguments but not  calling objects.
On  other hand, if you overload + as  friend, then  following is perfectly legal: = 25 + base_amount;.
Index SYMBOLS +, addition , 69–72 \, alert escape sequence, 53–54 &, ampersand symbol, 260–261, 263, 268, 270–271, 511, 519–520 address-of , 511 call-by-reference parameters, 260–261, 263, 268, 270–271, 519–520 memory locations and, pointers, 511, 519–520 arrow_operator, arrow , 742, 744 =, assignment , 69, 74, 81–82, 493, 511–512, 514, 569, 757–758, 860–861 arithmetic operators and, 69, 74 dynamic data structures and, 757–758 inheritance and, 860–861 objects used with, 569 overloading, 680–682 pointers and, 511–512, 514, 757–758 variables and, 69, 511–512 vectors, 493 *, asterisk symbol, 22, 509–512, 961, 964–965 dereferencing operator, 510–511, 961, 964–965 multiplication operator, 22, 70 pointer variable declaration, 509–512 \, backslash, 23 1034 \, backslash escape sequence, 53 &&, Boolean and operator, >=, comparison greater than or 78–79, 112–116 _0_, Boolean not operator, 79, 113, 118 ||, Boolean or operator, 78, 80, 112–116 { }, braces, 24–25, 82, 84–86, 121–123, 137–138, 543, 547 Cplus_plus programming layout, 24–25 conditional statements and, 82 local variable declaration, 137–138 loop body execution, 84–86 nested statements and, 121–123, 137–138 structure member names, 543, 547 :, colon symbol, 557–558, 600–601 derived class separation, 600–601 inheritance and, 600–601 scope resolution operator, 557–558 ,, comma for separation in declarations, 44, 431 //, comment symbols, 93–94, ==, comparison equal to ­operator, 78, 81–82, 456–457, 487 >, comparison greater than operator, 78 <, comparison less than equal to operator, 78, 80 ­operator, 78 <=, comparison less than or equal to operator, 78 _0_=, comparison not equal to operator, 78–79 ––, decrement operators, 87–91, 143–144, 960–961, 967–969 <> >>, direction arrows, 21 #, directive notation, 25 /, division operator, 70–72 _0_, dot (calling) operator, 313, 545, 550 \", double quote escape ­sequence, 53 " ", double quotes for string characters, 64–65 =, equal sign, 22, 456–457 >>, extraction operator, 309, 316–318, 464, 650–658 n_0_, factorial function, 230–231 plus_plus, increment operators, 87–91, 141–144, 960–961, 967–969, 971 <<, insertion operator, 310, 316–318, 329, 464, 650–658 \n, new  instruction, 23, 338–360, 345–346 \n, new– instruction, 53, 58 \0, null character, 453–454, 456 ( ), parentheses, 71, 78–79, 84–86, 130, 184, 191, 197 arguments, 184 Index arithmetic order, 71 Boolean expressions, 78–79, 84–86 controlling expressions, 130 predefined functions and, 184, 191, 197 return statements, 197 type casting and, 191 < >, predefined function header files, 184–186 \\, real backslash escape ­sequence, 53 %, remainder operator, 70–71 ;, semicolons, 24, 44, 131, 146, 149–150, 547 end of declarations, 24, 44, 131 for statements, 146, 149–150 structure definitions, 547 ' ', single quotes for constant characters, 65 [ ], square brackets, 378–379, 392–393, 427, 431, 489, 492 arrays using, 378–379, 392–393 multidimensional arrays and, 427, 431 variable declaration and, 378–379, 489 vectors using, 489, 492 +, string concatenation, 66–67.
See also Procedural ­abstraction Blocks, 135–137, 226–227 branching statements as, 137 functions and, 226–227 local variables and, 135–137, 226–227 nested, 137 scope, 137, 226–227 statement, 137 bool values, 66, 116, 199 data type, 66 Index int, converting to, 116–118 programmer–defined functions returning, 199 Boolean expressions, 66, 77–79, 84–87, 112–119 and (&&)  used in, 78–79, 112–116 arithmetic operations ­compared to, 112–115 branching mechanisms ­using, 77–79, 112–119 complete evaluation, 116 data values, 66 evaluating, 112–116 int value conversion, 116–118 looping mechanisms using, 84–87, 112–119 not (_0_) , 79, 113, 118 or (||) , 78, 80, 112–116 parentheses ( ) for, 78–79, 84–86 precedence rules, 114–115 short–circuit evaluation, 115 subexpressions, 115 true/false values, 66, 116 truth tables, 112–114 Braces { }, 24–25, 82, 84–86, 121–123, 137–138, 543, 547 Branching mechanisms, 75–82, 112–139, 203 and  (&&) for, 78–79 blocks, 135–137 Boolean expressions, 77–79, 112–120 braces { } used for, 82, 121–123, 137–138 break statements, 131–133 Cplus_plus flow of control using, 75–82 comparison operators for, 77–82 compound statements, 82 controlling expression, 130–132 flow of control using, 75–82, 112–139 if-else statements, 75–82, 120–128 indenting, 120–121, 123–125 local variables, 135–137 menus, 133–134 multiway, 120–139 nested statements, 120–123, 137 or operator (||) for, 78, 80 programmer–defined function calls in, 203 string of inequalities from, 80–81 switch statements, 128–135 break statements, 131–133, 153–154 branching mechanisms, 131–133 flow of control using, 131–133, 153–154 loop mechanisms, 153–154 looping mechanisms, 153–154 nested loops using, 154 switch statements, 131–133 Bubble sort, 421–423 Bug, 29.
See also Debugging Bytes, 4–5, 32 C Cplus_plus programming, 39–110 arithmetic operators, 69–74 assignment statements, 45–49 asterisk symbol (*), 22 backslash (\) use, 23 braces { }, 24–25, 82, 84–86 branching mechanisms, 75–82 cin (input) statements, 21–23, 56–57 comments, 93–95 compilers and, 24–25 compiling, 26–28 1037 compound statements, 82 constants, 95–97 cout (output) statements, 21–23, 50–52 data types, 44–45, 60–74 debugging, 29–31 declaration of variables, 21–23, 44–45 direction arrows (<> >>) , 21 directives #, 25, 52–53 expressions, 69–74 flow of control, 74–92 increment and decrement operators, 87–91 indentation, 93 input, 21–23, 56–59 input/output (I/O), 50–59 instructions, 19–23 language, 18–19 line breaks, 24 loop mechanisms, 84–91, 98 main() function, 25 names and, 49, 95–97 object code, 26–27 output, 21–23, 50–56 programmer role, 19 return statement, 25–26 running, 26–28 spacing, 24, 26 statements, 21–26, 40–50, 82 user role, 19 variables, 21–23, 40–50, 60–69 Cplus_plus11 programming, 27, 63–64 auto, 63 constructor delegation in, 587–588 conversion between strings and numbers, 488 data values, 63–64 decltype, 64 member initialization in, 587 nullptr in, 745 range-based, 386–387 1038 Index C strings, 453–472, 484–488 <cstring> library, 458–459 arguments, 459–460 arrays, 453–472 declaration of, 453–454 equality  =  == used for, 456–457 extraction (>>) operator used for, 464 functions, 457–460, 467–468 getline function, 465–466 initializing, 454–455 input/output (I/O), 464–466 insertion (<<) operator used for, 464 null (\0) character , 453–454, 456 number conversions, 466–470 parameters, 460 predefined functions, 457–460, 467–468 robust input, 468, 470–471 strcat function, 459–460 strcmp function, 457–460 strcpy function, 457–460 string object conversion, 487–488 values, 456–458 variables, 453–460 Call-by-reference parameters, 259–266, 519–520 for, 260–261, 263, 268, 270–271, 519–520 arguments, 265–268 call-by-value combined with, 268–271 function calls, 259–260 memory locations , 260–261 pointers, 519–520 Call-by-value parameters, 197–198, 224–226, 268–271, 674–675 arguments for, 197–198 call-by-reference combined with, 268–271 classes , 674–675 dynamic arrays , 674–675 local variables as, 224–226, 270–271 Calls (invocations), 183–188, 196–198, 208–211, 259–260, 265–268, 583–584 absolute value functions, 186–187 arguments , 183–184, 197–198, 265–268 call–by–reference parameters, 259–260 call–by–value parameters, 197–198 constructors, 583–584 functions, 183–188, 196–198, 208–211, 259–260, 265–268 header files (< >) , 184–186 #include directives, 184–186 loop body as, 208 nested loops , 208–211 predefined functions, 183–188 procedural abstraction , 208–211 programmer–defined functions, 196–198 return statements , 196–197 capacity( ) function, 493–494 catch block, 900–901, 901–902, 908–909 catch–block parameter, 900–902 Central processing unit (CPU), 3, 6–7 char data type, 64–66 Characters, 64–65, 68, 338–360, 1022 blank spaces , 338–339 data values, 64–65 default arguments, 348–349 editing text files, 355–357 eof function for, 353–354 functions, 348–349, 1022 get function for, 338–341 input/output (I/O), 338–349 isspace function, 358–359 member functions, 338–354 new- (/n), 338–360, 345–346 new_line( ) function for, 343–345, 347–348 predefined functions, 356, 358–360 put function for, 341–342 putback function for, 342–343 stream parameters and, 346–347 toupper and tolower ­functions for, 358–360 values returned, 358–360 whitespace, 68, 358 Child class, 600, 834, 844 Chips, computer processors and, 6 cin (input) statements, 21–23, 56–57 Classes, 17, 66–68, 312–315, 472–488, 541–617, 619–682, 762–765, 833–892, 904–905, 973–990 abstract data types (ADT), 588–597 adapter, 979–983 ancestor, 844 arrays and, 660–682 base, 834, 836–837, 848–850, 858 Cplus_plus programming and, 17 call-by-value parameters and, 674–675 child, 600, 834, 844 constructors for, 576–588, 661, 668–671 containers, 973–990 copy constructors for, 675–679 Index defining, 600–603 derived, 598–603, 834–836, 837–845, 854–856, 860–861 destructors for, 671–673 dot operator (_0_) for, 557–558 dynamic arrays and, 667–682 encapsulation, 556 exceptions, 904–905 file I/O and, 312–315 friend functions, 620–642 hierarchies, 599–600 inheritance and, 598–603, 833–892 linked lists of, 762–765 member functions of, 312–314, 554–558, 570–574, 576–588 member variables, 664–667 object–oriented programming (OOP) and, 17 objects and, 312–315, 554, 566, 569, 576–588 overloading operators, 643–660 parent, 600–601, 834, 844 private members used in, 559–568 public members used in, 559–568 redefining functions, 853–856 scope resolution operator (::) for, 557–558 streams and, 312–315 string, 66–68, 472–488 stringvar, 668–671 structures compared to, 542–550, 575 templates for, 973–990 close function, 310–311, 318 Coding, 213–214, 278–280, 400–407, 793–794, 812–816 array programs, 400–407 procedural abstraction and, 213–214, 278–280 recursion programs, 793–794, 812–816 Colon (:), 557–558, 600–601 Comma (,) separation in declarations, 44 Comments, Cplus_plus programming and, 93–95 Compact discs (CDs), 6 Comparison operators, 77–82, 482, 487 and operator (&&) for, 78–79 equal  (==), 78, 81–82 greater than (>), 78 greater than or equal  (>=), 78, 80 less than (<), 78 less than or equal  (<=), 78 not equal  (_0_=), 78–79 or operator (||) for, 78, 80 string class and, 482, 487 string of inequalities from, 80–81 Compiler programs, 9–11, 24–32, 704–718 interface for, 705–715 Cplus_plus programming, 24–28, 32 compiling process, 26–28 error messages, 30–31 #ifndef directive, 25, 26, 716–718 #include directive, 25, 26, 716 language translation using, 9–11 line breaks, 24 linking code, 9–11 object code, 9–11, 26–27 separate compilation, 704–718 spacing, 24, 26 syntax error, 30 testing, 27–29 1039 Complete evaluation, 116 Compound statements, 82 Computer systems, 2–12 compilers, 9–11 hardware, 2–7 input/output devices, 3 languages for, 8–11 linkers, 9–11 mainframe, 2 memory, 3–6 network, 2 operating systems, 7 personal (PC), 2 processor (CPU), 3, 6–7 programs, 2, 7–11 software, 2, 7–8 Concatenation (+), strings, 66–67 const modifier, 96–97, 376–382, 394–397, 638–642 array declaration using, 376–382 array parameters, 394–397 Cplus_plus programming using, 96–97 friend functions and, 638–642 inconsistent use of, 397 Constant array parameters, 395 Constant iterators, 970–971 Constant parameters, 638–642 Constants, 60–62, 65, 95–97, 119–120, 221–223, 473, 636 data types, 60–62 declared, 96 enumerated types, 119–120 friend functions and, 636 functions and, 221–223 global named, 221–223 naming, 95–97 numbers, leading zeros in, 636 single quotes (' ') for ­characters, 65 string class conversion, 473 1040 Index Constructors, 473–474, 492, 576–588, 661, 668–671, 675–679, 845–848, 860–861 arrays and, 661, 668–671, 675–679 calling (invoking), 583–584, 661 classes and, 576–588, 668–671, 675–679 copy, 675–679, 860–861 default, 473–474, 584–585, 661 dynamic arrays, 668–671, 675–679 inheritance and, 845–848, 860–861 initialization of objects ­using, 576–583 member functions as, 576–588 no arguments and, 585–586 overloaded, 578 size of arrays and, 668–671 string class and, 473–474 vectors and, 492 Container modifying algorithms, 1001–1002 Containers, 973–990, 995–996 access running times, 995–996 adapter classes, 979–983 associative, 983–990 auto, using with, 990 deque, 976 doubly linked lists, 974 efficiency of, 990–991 initializing, 990 map class, 983–990 priority_queue class, 979–983 queue class, 979–983 ranged for, using with, 990 sequential, 974–979 set class, 983–990 singly linked lists, 974 stack class, 979–983 templates for, 973–990 type definitions in, 979 Controlling expression, 130–132 Copy constructors, 675–679, 860–861 Count–controlled loops, 158 cout (output) statements, 21–23, 50–52, 289–290 debugging with, 289–290 direction arrows (<> >>), 21 program output using, 21–23, 50–52 streams, as variable declaration and, 21–23 D Dangling pointers, 517, 522–523 Data, computer programs and, 7–8 Data abstractions, templates for, 939–948 Data types, 44–45, 60–74, 95–97, 119–120, 942 arithmetic operators and, 69–74 bool, 66 Boolean, 66 Cplus_plus11, 63–64 char, 64–66 character, 64–65 compatibility of, 68–69 constants as, 60–62, 65, 95–97, 119–120 double, 44, 60–64 enumerated, 119–120 expressions and, 69–74 float, 63 floating–point notation, 61–63 int, 44, 60–62, 63, 70–72 integer, 60–62 long, 62–63 names for declaration, 44–45 numeric, 44, 60–64 Op shorthand notation, 74 short, 63 string class and, 66–68 templates for, 942 variables as, 44–45, 60–74 Debugging, 29–31, 162–164, 281–287, 287–291 assert macro for, 290–291 bugs, 29 code, 290 common errors, 287 cout statement for, 289–290 error messages, 30–31 functions, 281–287, 287–291 localizing errors, 288–290 logic errors, 30–31 loops, 162–164 off-by-one error, 162 retesting changes, 164 run–time errors, 30 second opinions and, 287 syntax errors, 30 testing programs for, 29–31, 281–287 tracing variables, 162–163, 288 warning messages, 30 Decimal (_0_) notation, 55–56, 61 Declaration, 21–23, 44–45, 48–49, 193, 195–196, 199–201, 275–281, 308–309, 378–384, 426–427, 453–454, 489–490 arrays, 378–384, 426–427 cin (input) statements for, 21–23 comma (,) for separation in, 44, 431 const modifier and, 376–382 cout (output) statements for, 21–23 C–string variables, 453–454 double variable type, 44 Index functions, 193, 195–196, 199–201, 275–281 illegal ranges, 383–384 indexed variables, 379–384 initializing in, 48–49 int variable type, 21, 44, 378–380 memory and, 382–383 multidimensional arrays, 426–427 postconditions, 275–281 preconditions, 275–281 programmer–defined functions, 193, 195–196, 199–200 semicolon (;) for end of, 44 square brackets [ ] used for, 378–379, 489 streams, 308–309 type names and, 44–45 variables, 21–23, 44–45, 48–49, 64, 378–382, 453–454, 489–490 vectors, 489–490 Declared size, 379 decltype, 64 Decrement operators (minus_minus), 87–91, 143–144, 967–969 Default arguments, 348–349 Default constructors, 473–474, 584–585, 661 delete operator, 517–518, 524–527, 530–531 Deque, 976 Dereferencing (*) operator, 510–511, 961, 964–965 Derived classes, 598–603, 834– 836, 837–845, 854–856, 860–861, 913 (=) operators used for, 860–861 colon (:) for separation of, 600–601 constructors used in, 845–848 copy constructors used in, 860–861 defining, 600–603 destructors used in, 861 exception specification in, 913 implementation of, 834–836 inheritance and, 598–603, 834–836, 837–845, 854–856, 860–861 redefining functions, 853–856 Descendants, 844 Destructors, 671–673, 861, 875–876 dynamic arrays, 671–673 inheritance and, 860–861 polymorphism and, 875–876 virtual, 875–876 Digital video discs (DVDs), 6 digit_to_int function implementation, 635–636 Direction arrows (<> >>), 21 Directives (#), 25, 52–53 Diskettes (floppy disks), 6 Division operator (/), 70–72 do-while loop statements, 87–91, 139–140, 154 break statement for, 154 execution of, 87, 139–140 infinite, 87–91 syntax of, 87–88, 139–140 Dot (_0_) operator, 313, 545, 550 double, 44, 55–56, 60–64, 70 arithmetic operators and, 70 decimal (_0_) notation for, 61 exponent (e) notation for, 61 floating–point notation of, 61–62 numeric data type, 44, 60–64 output values from, 55–56 scientific notation of, 61–62 variable type, 44 Double quotes (" ") for string characters, 64–65 Double–precision numbers, 60–61 1041 Doubly linked lists, 760–761, 974 Drivers, function testing using, 282–284 Dynamic arrays, 521–527, 530–532, 667–682, 740, 757–758 array variables and, 521–523 (=) and, 757–758 call-by-value parameters and, 674–675 classes and, 667–682 constructors for, 668–671 copy constructors for, 675–679 creating and using, 522–527 delete , 524–527, 530–531 destructors for, 671–673 linked lists and, 740, 757–758 multidimensional, 530–532 new , 524–527 pointer arithmetic and, 528–529 pointer variables and, 521–523, 527, 740, 757–758 size of, 668–671 square brackets [ ] used for, 524–527, 526–527 stringvar class, 668–671 variables, 521–523, 527, 740, 757–758 E Echoing input, 58 Empty statements, 150 Encapsulation, 17 #endif directive, 716–717 endl instruction, 54–55 eof function, 353–354 equal function, 620–626 Equal to comparison (==), 78, 81–82, 456–457 1042 Index Errors, 29–31, 287–290, 316, 383–384, 431, 638–642, 874–875 arrays and, 383–384, 431 bugs, 29 commas between index variables, 431 common, 287 compiler, 30–31, 875 constant parameters for, 638–639 debugging, 287–290 file I/O, 316 index variables out of range, 383 localizing, 288–290 logic, 30–31 messages, 30–31, 316 polymorphism and, 874–875 run–time, 31 syntax, 30 testing for, 30–31 tracing variables, 162–163, 288 virtual member functions and, 874–875 warning messages compared to, 30 Escape sequences, 53–55 Exceptions, 893–924 catch-block parameter, 900–902 catch block used for, 900–901, 901–902, 908–909 class hierarchies, 917 classes defined for, 904–905 derived classes and, 913 functions, throwing in, 909–911 handler, 900 handling, 893–924 memory, testing for, 917–918 multiple, 904, 906–909 nested try-catch blocks, 916 overuse of, 916–917 programming techniques for, 914–918 rethrowing, 918 specification, 911–913 throw list, 911–913 throw statement used for, 898–900, 909–911 throwing exceptions, 909–911, 914–916 trivial, 909 try block used for, 898–899, 901 try-throw-catch mechanism in, 898, 901–903 uncaught, 916 Executable statements.
See ­Statements Executing programs, 8 exit function, 315, 318 Exit–on–flag loop termination, 159 Exponent (e) notation, 61 Expressions, 69–74.
See also Arithmetic operators; ­Boolean expressions External file name, 310 Extraction operator (>>), 309, 316–318, 464, 650–658 F fabs function, 187 factorial (n_0_) function, 230–231 fail function, 314 Files, 6, 306–323, 332–337, 353–358, 588–597, 705–715 abstract data types (ADT), 588–597, 705–715 appending, 320–322 application, 714 character I/O and, 353–358 close function used for, 310–311, 318 computer memory and, 6 end of, 332–335, 353–354 eof function used for, 353–354 error messages, 316 exit function used for, 315, 318 external name, 310 extraction operator (>>) for, 309, 316–318 fail function used for, 314 implementation, 592–597, 708–715 include directives used for, 309, 318, 329 input/output (I/O), 306–323, 332–337 insertion operator (<<) for, 316–318, 329 interface, 592–593, 705–707, 713 member functions, 312–314 memory storage and, 6 names and, 308–310, 318 namespaces and, 335–336 open function used for, 309–310, 318 opening successfully, 309–310, 315 permanent storage, as, 307–308 reading, 308 separate compilation of, 705–715 streams and, 306–338 text editing, 355–357 writing, 308–310 First–in/first–out (FIFO) data structure, 771 Fixed–point notation, 326 Flags, 159, 325–327 Flash drives, 6 float data type, 63 Floating–point notation, 61–63 Flow of control, 74–92, 111–164 Boolean expressions for, 77–79, 112–120 branching mechanisms, 75–82, 112–139 Index Cplus_plus programming and, 74–92 comparison operators for, 77–82 compound statements, 82 enumerated types, 119–120 increment and decrement operators, 87–91, 141–144 loop mechanisms, 84–91, 98, 112–120, 139–155 for statements, 144–150, 154, 380 arrays using, 380 empty (null) statements, 150 multistatement body, 148–149 numeric calculations using, 143–146 semicolons (;) and, 146, 149–150 variables and, 145–146 Formal parameters.
See ­Parameters Forward iterators, 969 Freestore, 516–517 friend functions, 620–642 accessor functions and, 626 const parameter modifier, 638–642 constant parameters, 638–639 digit_to_int implementation, 635–636 equal, 620–626 leading zeros in number constants, 636 Money class, example for, 628–635 nonmember functions, as, 624–628 private members, access to, 624 syntax, 627 Function body, 196 Function declaration, 193, 195–196, 199–201 Function definition, 193–194, 196–197, 201–203, 791, 798, 937–938 Function headers, 196, 200 Functions,181–250, 251–303, 312–314, 323–338, 338–349, 389–398, 414, 457–460, 467–468, 567–568, 620–642, 791–807, 850, 853–856, 864–876, 909–911, 1019–1026.
See also arguments and, 183–184, 197–198, 265–268, 389–394, 414 arithmetic, 1019 array size and, 414 arrays as arguments, 391–394, 414 arrays in, 389–398 Cplus_plus library, 1019–1025 C string, 457–460, 467–468 call-by-reference, 259–266 call–by–value parameters, 197–198, 268–271 calls (invocations), 183–188, 196–198, 208–211, 259–260, 265–268 case study: Production Graph, 398–409 character, 348–349, 1022 const parameter modifier, 394–397, 638–642 debugging, 281–287, 287–291 declaration, 193, 195–196, 199–201, 275–281 default arguments, 348–349 definition, 193–194, 196–197, 201–203, 791, 798 digit_to_int implementation, 635–636 driver programs for, 282–284 equal, 620–626 factorial (n_0_), 230–231 flags and, 325–327 1043 formatting output using, 323–338 friend, 620–642 graph, 407 indexed variables as ­arguments, 389–391 inheritance and, 850, 853–856 inline, 1026 input/output (I/O), 323–349, 338–349, 1020–1021 local variables and, 218–229, 270–271 manipulators, 329 member, 312–314, 338–349 member functions accessor, 551–552 mutator, 567–568 names, 221–224, 232–238 nonmember, 624–628 not inherited, 850, 859–860 overloading names, 232–238 overriding, 869 parameters, 197–201, 207–208, 224–226, 259–266, 391–397 polymorphism and, 864–876 predefined, 183–192, 457–460, 467–468 procedural abstraction and, 204–217, 273–281 programmer–defined, 193–203 random number generator, 188–189, 1024 recursive, 791–807 redefining functions, 853–856 return statements, 196–197, 202, 255–259 returning an array, 397–398 scale, 402–407 signature, 857 stream I/O, 323–338 string, 1023 1044 Index stub, 284–286 subtasks, 251–303, 399–400 tasks, recursion for, 791–803 testing, 214–217, 281–287 throwing exceptions in, 909–911 top–down design for, 182–183, 398–409 trigonometric, 1025 type casting, 190–192 value returned, 181–250, 804–807 virtual, 864–876 void, 252–259 G Generic algorithms, 991–1004 big-O notation, 994–995 container access running times, 995–996 container modifying, 1001–1002 nonmodifying sequence, 997–1001 running times, 991–996 set, 1003–1004 sorting, 1004 templates for, 991–1004 get function, 338–341 getline function, 465–466, 475–476, 478–479 Global named constants, 221–224 Global scope, 226–227 Global variables, 223–224, 518 graph function, 407 Greater than comparison ­ (>), 78 Greater than or equal to comparison  (>=), 78, 80 H Handling exceptions, 894 Hard disks, 6 Hardware computer systems and, 2–7, 32 input/output devices, 3 main memory, 3–5 processor (CPU), 3, 6–7 secondary memory, 6 Header files (< >), predefined functions, 184–186 Hierarchy of structures, 549 High–level languages, 8–9 I Identifiers, variables, 42–44 if-else statements, 75–82, 120–128 Boolean expressions for, 77–79 braces { } used with, 82, 121–123 branching mechanisms, 75–82, 120–128 comparison operators for, 77–82 compound statements and, 82 dangling else problem, 121–123 indenting, 120–121, 123–125 multiway branches, 123–128 nested, 120–123 #ifndef directive, 716–718 ifstream, 308–309, 318 Implementation files, ADT, 592–597, 708–715, 718–719 Implementation phase, 15 #include directive, 21, 25–26, 52–53, 184–186, 309, 318, 716–718 Cplus_plus programming and, 21, 25–26 directive notation (#) for, 25 file I/O, 309, 318, 329 header files and, 184–186 #ifndef directive and, 716–718 manipulator functions and, 329 output and, 52–53 predefined functions and, 186–187 preprocessors for, 186 separate compilation and, 716–718 Increment operators (plus_plus), 87–91, 141–144, 960–961, 967–969, 971 Indentation, Cplus_plus programming and, 93 Indenting branching ­statements, 120–121, 123–125 Index (subscript) of arrays, 379, 383–384 Indexed variables, 379–386, 389–391, 426, 431 arguments to functions, as, 389–391 arrays and, 379–386 commas (,) between, 431 declaration of, 379–384 functions and, 389–391 illegal range of, 383–384 initializing, 386 multidimensional arrays, 426, 431 square brackets [ ] used for, 378–379, 431 Infinite loop statements, 87–91, 152 Infinite recursion, 799 Information hiding, 205, 597.
See also Procedural ­abstraction Inheritance, 17, 598–603, 833–892 ancestor class, 844 (=) operators used for, 860–861 base class, 834, 836–837, 848–850, 858 child class, 600, 834, 844 class hierarchy, 599–600 colon (:) used for, 600–601 constructors used in, 845–848 Index copy constructors used in, 860–861 derived classes and, 598–603, 834–836, 837–845, 854–856, 860–861 descendants, 844 destructors and, 860–861 function signature, 857 functions not inherited, 850, 859–860 member functions, 845, 850–852, 853–856 parent class, 600–601, 834, 844 polymorphism and, 862–876 private members and, 848–850 protected qualifier, 850–852 redefining functions, 853–856 Initialization, 48–49, 145–146, 386, 454–455, 551, 576–583 arrays, 386, 454–455 C strings, 454–455 constructors for, 576–583 declaration and, 48–49 objects, 576–583 structures, 551 variables, 48–49, 145–146, 386, 454–455 Inline functions, 1026 Input, 3, 21–23, 50, 56–58, 157–160, 306–312, 343–349 character data, 343–349 cin statements for, 21–23, 56–57 computer hardware devices, 3 echoing, 58 for, 309 get function, 338–341 loops, design for ending, 157–160 member functions for, 343–348 new_line( ), 343–345, 347–348 new– character (\n) and, 345–346 put function, 341–342 putback function, 342–343 reading files, 308–309 streams, 50, 306–312 Input iterators, 972 Input/output (I/O), 50–59, 305–376, 464–466, 475–477, 1020–1021 arguments (parameters) and, 332, 348–349 Cplus_plus programming and, 50–59 C strings, 464–466 character, 338–360 cin (input) statements, 56–57 cout (output) statements, 50–52 decimal points for formatting numbers, 55–56 designing, 58 double statements, 55–56 end of files (eof), 332–335, 353–354 escape sequences, 53–55 files, 306–323, 332–337 flags, 325–327 formatting, 323–338 functions, 323–349, 353–354, 1020–1021 getline function, 475–476 #include directive, 52–53 manipulators, 329 namespaces, 52–53, 335–336 new_line function, 343–344, 346–348 new– instruction (\n), 54–55, 58, 340–341, 345–346 predefined character functions, 356–360 1045 streams, 50, 305–376 string class for, 475–477 using directive, 52, 335–336 Insertion operator (<<), 310, 316–318, 329, 464, 650–658 in_stream, 307, 308–309, 312–314, 318 int, 21, 44, 60–61, 63, 70–72, 116–118, 378–382, 489–491 arithmetic operators and, 70–72 array declaration using, 378–382 Boolean expressions and, 116–118 enumerated types, 119–120 numeric data type, 44, 60–61, 63 unsigned type, 490–491 value conversion, 116–118 variable declaration ­using, 21, 44, 378–382, 489–491 vector declaration using, 489–491 Integers, 21, 60–62, 190–192 data values, 60–62 type casting by division, 190–192 variables, 21 Interface files, ADT, 592–593, 705–707, 713, 723, 724 ios::fixed flag, 325–327 ios::left flag, 327 ios::right flag, 327 ios::showpoint flag, 325–327 ios::showpos flag, 327 iostream library, 25 isalpha function, 359 isdigit function, 359 islower function, 359 isspace function, 358–359 isupper function, 359 1046 Index Iterators, 84–87, 157, 159, 755, 802–803, 817–818, 959–973 auto, variable declaration using, 964 bidirectional, 966–969 compiler problems, 964–965 constant, 970–971 for, 967–969 dereferencing (*) operator for, 964–965 forward, 969 for, 960–961, 967–969, 971 input, 972 loop mechanisms and, 84–87, 157, 159 mutable, 970 operators for, 960–961 output, 973 pointers as, 755 random access, 966–969 recursion compared to, 802–803 recursive program version, 817–818 reverse, 971–972 templates for, 959–973 types of, 966–971 using directives for, 959–960 vectors and, 961–965 L Languages, 8–11, 18–19 assembly, 8 Cplus_plus programming, 18–19 compilers for translation of, 9–11 computer programs and, 8–9 high–level, 8–9 linker programs for, 9–11 low–level, 8 machine, 8–9 program translation of, 8–11 Last-in/first-out (LIFO) data structure, 766, 801–802 Late (dynamic) binding, 863–869 Leaf nodes, 762 length function, 480–481 Less than comparison (<), 78 Less than or equal to comparison  (<=), 78 Lexicographic order, 482 Line breaks, Cplus_plus programming, 24, 26, 202 Linear running time, 995 Linked lists, 739–787, 974.
See also Containers arguments, as, 747 (=) operators used with, 757–758 classes and, 762–765 data structures, as, 739–742 doubly, 760–761, 974 dynamic data structures in, 740, 757–758 head of, 746–750 inserting nodes in, 747–749, 755–757 losing nodes, 750–751 middle, 755–757 Node class, 762–765 nodes and, 740–742, 747–750, 755–757 pointers and, 739–787 queues and, 771–776 removing nodes from, 755–757 searching, 751–754 singly, 974 stacks, 765–766 Linker programs, 9–11 List headed–by–size loop ­termination, 157 Local variables, 135–137, 218–229, 270–271 block scope, 135–137, 226–227 call–by–value parameters as, 224–226, 270–271 functions and, 218–229, 270–271 global constants and, 221–223 global scope, 226–227 global variables and, 223–224 inadvertent, 270–271 namespaces and, 227–229 scope of, 220–221, 226–227 Logic errors, 30–31 long data type, 62–63 Loop mechanisms, 84–91, 98, 112–120, 139–155, 208–211 ask–before–iterating technique for, 157, 159 body, 84–86 Boolean expressions for, 84–87, 112–120 braces { } for execution of, 84–86 break statement for, 153–154 count–controlled, 158 debugging, 162–164 decrement operators (minus_minus), 87–91, 143–144 design choices, 150 do-while statements, 87–91, 139–140, 154 ending input loops, 157–160 exit-on-flag termination, 159 flags, 159 flow of control using, 84–91, 98, 139–155 for statements, 144–150, 154 increment operators (plus_plus), 87–91, 141–144 infinite, 87–91, 152 iteration, 84–87, 157, 159 list headed–by–size termination, 157 nested, 154, 160–161, 208–211 procedural abstraction and, 208–211 Index products obtained using, 156–157 semicolons (;) and, 149–150 sentinel value, 158 sums obtained using, 155–156 uninitialized variables and, 152 while statements, 84–91, 139–144, 153–154 zero times body execution, 87, 141 Low-level language, 8 M Machine language, 8–9 main() function, 25 Main memory, 3–5 Mainframe computer systems, 2 Manipulator functions, 329 map class, 983–990 Member functions, 312–314, 338–354, 465–466, 480–483, 554–558, 570–574, 576–588, 818–821, 845, 848–856 at, 480–481 accessor functions and, 567–568 BankAccount class examples of, 570–574 blank spaces and, 338–339 C strings, 465–466 character I/O and, 338–354 classes and, 312–314, 554–558, 570–574, 576–588 constructors, 576–588 definition of, 554–558 dot (_0_) operator used for, 313, 557–558 eof, 353–354 exit, 315 fail, 314 get, 338–341 getline, 465–466 inheritance and, 845, 850–852 length, 480–481 mutator functions and, 567–568 new_line( ), 343–345, 347–348 new– character (\n) and, 338–360, 345–346 objects and, 312–314 private, 559–568, 848–850 protected, 850–852 public, 559–568 put, 341–342 putback function, 342–343 recursion and, 818–821 redefinition of, 853–856 scope resolution (::) operator used for, 557–558 stream I/O using, 312–314 string class use of, 480–483 Member names, structures, 543, 545–546 Member values, structures, 543, 546 Member variables, structures, 543, 545–547, 550 Memory, 3–6, 40–42, 262–264, 382–383, 393–394, 516–518 addresses, 4–5 array declaration and, 382–383 array parameters, 393–394 bits (binary digits), 4 bytes, 4–5 call-by-reference parameters and, 262–264 computer hardware components, 3–6 delete operator for, 517–518 dynamic variables, 516–518 files, 6 freestore, 516–517 locations, 4–5, 41–42, 262–264 main, 3–5 1047 management, 516–518 pointers for, 516–518 random access (RAM), 6 secondary (auxiliary), 3, 6–7 sequential access of, 6 storage as, 6 variables and, 40–42 Menus, 133–134 program choices using, 133–134 switch statements for, 133–134 Messages, errors, 30–31 Monitor, computer output device, 3 Multidimensional arrays, 425–431, 530–532 commas (,) between indexes, 431 declarations for, 426–427 delete [ ] operator and, 530–531 dynamic, 530–532 indexed variables and, 426, 431 parameters, 426–427 size of, 426–427 square brackets [ ] used for, 427, 431 two–dimensional example of, 427, 531–532 Multiplication operator (*), 70 Mutable iterators, 970 Mutator functions, 567–568 N Names, 42–45, 49, 95–97, 207–208, 221–224, 232–238, 308–310, 318, 518–520 constants, 95–97, 221–224 data types, 44–45 external file, 310 files, 308–310, 318 formal parameters, 207–208 functions and, 221–224, 232–238 1048 Index global constants, 221–224 identifiers, 42–44 overloading functions, 232–238 pointer types, 518–520 procedural abstractions, 207–208 streams, 308–310, 318 typedef function, 518–520 variables, 42–45, 49, 308 Namespaces, 52–53, 186, 227–229, 335–336, 719–732 classes and, 719–732 creating, 721–723 file I/O and, 335–336 global, 732 local variables and, 227–229 names for, 724–726, 731 output and, 52–53 qualifying names, 724–726 stream I/O and, 335–336 unnamed, 726–732 using directives for, 52–53, 186, 228–229, 335–336, 719–721, 724–726 Nesting, 120–123, 137, 154, 160–161, 208–211, 916 blocks, 137, 916 braces { } used for, 121–123, 137–138 break statement in, 154 dangling else problem, 121–122 function calls and, 208 if-else statements, 120–123 indenting statements, 120–121 loops, 154, 160–161, 208–211 multiway branches, 120–123, 137 procedural abstraction and, 208–211 scope of the block for, 137 statements, 120–123 try-catch blocks, 916 Network computer systems, 2 new , 513–515, 524–527 dynamic arrays and, 524–527 pointers using, 513–515 new_line( ) function, 343–345, 347–348 New–line instruction (\n), 23, 53, 54–55, 58, 338–360, 345–346 Cplus_plus programming and, 23 endl used in place of, 54–55 input and, 345–346 member functions and, 338–360 output and, 54–55 Node class, 762–765 Nodes, 740–742, 747–750, 755–765 arrow (arrow_operator)  used with, 742, 744 binary trees and, 761–762 doubly linked lists, 760–761 head (front) of lists, inserting at, 747–749 inserting to lists, 747–749, 755–757 leaf, 762 linked lists and, 740–742, 747–750, 755–757 lost, 750–751 middle of lists, inserting and removing, 755–757 NULL constant used in, 742–744 pointer variables and, 741–742 removing from lists, 755–757 root, 762 searching linked lists using, 751–754 structures, 740–742 trees and, 761–762 Nonmember functions, 624–628 Nonmodifying sequence algorithms, 997–1001 Not equal to comparison  (_0_=), 78–79 Not  (_0_), 79, 113, 118 Null (/0) character, 453–454, 456 NULL constant, 742–744 Null statements, 150 nullptr, in Cplus_plus 11 programming, 745 Number formatting, decimal points for, 55–56 Number–to–C string conversions, 466–470 Numeric calculations, 143–146, 155–157.
See also Arithmetic operators for loop statements for, 143–146 loop design for, 155–157 products, 156–157 sums, 155–156 Numeric data values, 44, 60–64 O Object code, 9–11, 26–27 Object-oriented programming (OOP), 16–17 classes, 17 encapsulation, 17 inheritance, 17 polymorphism, 17 program design using, 16–17 Objects, 312–315, 554, 566, 569, 576–588 used with, 569 classes and, 312–315, 554, 566 constructors for, 576–588 file I/O and, 312–315 initialization of, 576–583 member functions, 312, 576–588 public and private ­specification, 566 streams and, 312–315 Index Off–by–one error, 162 ofstream, 308–309, 318 Op , 74 open function, 309–310, 318 Operating systems, computer software for, 7 Operators, 69–74, 77–82, 87–91, 112–120, 309, 316–318, 464, 643–658, 1016–1017, 1032–1033 arithmetic, 69–74, 112–116 Boolean expressions, 77–79, 112–120 comparison, 77–82 decrement (minus_minus), 87–91 extraction (>>), 309, 316–318, 464, 650–658 increment (plus_plus), 87–91 insertion (<<), 310, 316–318, 329, 464, 650–658 overloading, 643–658, 1032–1033 precedence, 114–115, 1016–1017 unary, 87, 649–650 Or  (||), 78, 80, 112–116 Output, 3, 21–23, 50–56, 58, 306–312, 323–338 computer hardware devices, 3 cout statements, 21–23, 50–52 decimal points for formatting numbers, 55–56 double statements, 55–56 escape sequences, 53–55 flags, 325–327 formatting functions, 323–338 insertion  (<<) for, 310 manipulators, 329 for, 54–55, 58 streams, 50, 306–312, 323–338 writing files, 308–310 Output iterators, 973 out_stream, 307, 308–310, 312–314, 318, 325–326 Overloading, 232–238, 578, 643–658, 821, 1027–1028, 1032–1033 array index, 1027–1028 constructors, 578 extraction  (>>), 650–658 function names, 232–238 insertion  (<<), 650–658 operators, 643–658, 1032–1033 recursion compared to, 821 type conversion and, 238, 647–649 unary operators, 649–650 Overriding functions, 869 P Parameters, 197–201, 207–208, 224–226, 259–266, 346–349, 391–397, 414, 426–427, 460, 519–520, 638–642 arguments and, 197–198, 200–201, 265–268, 348–349, 460 array, 391–396 arrays and, 391–397, 414, 426–427, 460 C string, 460 call–by–reference, 259–266, 519–520 call–by–value, 197–198, 224–226 character I/O, 346–349 const modifier, 394–397, 638–642 constant, 638–639 constant array, 395 formal, 197–201, 207–208, 224–226, 414 friend functions and, 638–642 1049 function arguments and, 414 function calls using, 197–198, 259–260 function declarations using, 199–201 function subtasks using, 259–266 local variables and, 224–226, 270–271 memory locations, 262–264, 393–394 mixed lists, 268–271 multidimensional arrays, 426–427 names, 207–208, 262 pointers, 519–520 procedural abstraction and, 207–208 programmer–defined functions, 197–201 size of arrays and, 394, 414 stream versatility, 346–347 Parent class, 600–601, 834, 844 Parentheses ( ), 71, 78–79, 84–86, 130 Partially filled arrays, 411–413 Personal computer (PC), 2 Pointer variables, 521–523, 527 Pointers, 507–540, 674–675, 739–787, 1029–1031 addresses, 509–511 ampersand (&) symbol and, 511 arithmetic performed on, 528–529 arrow (arrow_operator)  used with, 742, 744 assignment  (=) and, 511–512, 514, 757–758 asterisk (*) used for, 509–512 automatic variables, 518 call–by–reference parameters for, 519–520 call–by–value parameters, 674–675 dangling, 522–523 1050 Index declaration of, 509–510 delete , 517–518, 524–527, 530–531 dereferencing (*) for, 510–511 destructors and, 674–675 dynamic arrays and, 521–527, 530–532, 674–675 dynamic variables and, 513, 516–518, 740, 757–758 freestore, 516–517 iterators, used as, 755 linked lists and, 739–787 memory management for, 516–518 names, 518–520 new , 513–515 nodes, 740–742, 747–750, 755–757 NULL constant assigned to, 742–744 queues and, 771–776 stacks and, 765–766 static variables, 518 structures containing, 741–742 this, 1029–1031 trees and, 761–762 typedef function, 518–520, 530 variables and, 508–520, 521–523, 527, 741–742 Polymorphism, 17, 862–876 destructors made virtual for, 875–876 errors, 874–875 late (dynamic) binding, 863–869 overriding functions, 869 virtual functions and, 864–876 pop function, 770 Postconditions, 275–281 pow function, 187–188 Precedence rules, 114–115 Preconditions, 275–281 Predefined functions, 183–192, 356, 358–360, 457–460, 467–468 abs, 186–187 absolute values, 186–187 arguments, 183–184, 459–460 C string, 457–460, 467–468 calls (invocations), 183–188 character I/O data, 356, 358–360 fabs, 187 header files (< >) and, 184–186 #include directives, 184–186 isspace, 358–359 parentheses ( ) and, 184, 191 pow, 187–188 random number generation using, 188–189 sqrt, 183–185, 187 srand, 187, 189 strcmp, 457–460 string–to–number conversions, 467–468 strncpy, 457–460 toupper and tolower, 358–360 type casting using, 190–193 using directive, 186 value returned, 183, 358–360 priority_queue class, 979–983 private members, 559–568, 593, 597, 624, 848–850 and, 593 accessor functions and, 567–568 classes using, 559–568 friend function access to, 624 inheritance and, 848–850 mutator functions and, 567–568 public members and, 559–568 Problem–solving phase, 15, 211–212, 277–278, 398–399 Procedural abstraction, 204–217, 273–281 algorithm design for, 212–213, 278 black box analogy, 204–207 case study: Buying Pizza, 211–217 case study: Supermarket Pricing, 276–281 coding, 213–214, 278–280 functions calling functions, 273–275 functions returning values, 204–217 information hiding, 205–206 nested loops and, 208–211 parameter names and, 207–208 postconditions, 275–281 preconditions, 275–281 problem analysis, 211–212, 277–278 program testing, 214–217, 281 pseudocode for, 213, 217 subfunctions using, 273–281 Processor (CPU), computer component, 3 Programmer role, 19 Programmer–defined functions, 193–203 arguments and, 197–198, 200–201 body, 196 bool values, returning, 199 branching statements and, 203 call–by–value parameters, 197–198 calls, 196–198, 203 declaration, 193, 195–196, 199–201 Index definitions, 193–194, 196–197, 201–203 headers, 196, 200 parameters, 197–201 return statements, 196–197, 202 spacing and line breaks in, 202 syntax of, 201–202 value returned, 196, 199 Programming, 12–17, 588–597.
See also Cplus_plus programming; Cplus_plus11 programming abstract data types (ADT), 588–597 algorithms, 12–16 implementation phase, 15 object–oriented (OOP), 16–17 problem–solving phase, 15 program design for, 15–17 software life cycle, 17 Programs, 2, 7–11, 13–16, 27–31 algorithms for, 13–16 compiler, 9–11, 27–30 computer software as, 2, 7–8 debugging, 29–31 design of, for programming, 15–17 executing, 8 high-level languages for, 8–9 implementation design phase, 15 language translation and, 8–11 linker, 9–11 logic errors, 30–31 object code problem–solving design phase, 15 run-time errors, 30 running, 8–11 source code, 9 syntax error, 30 testing, 27–31 protected members, 850–852 Pseudocode, 213, 217 public members, 559–568 accessor functions and, 567–568 classes using, 559–568 mutator functions and, 567–568 put function, 341–342 putback function, 342–343 Q Quadratic running time, 995 queue class, 979–983 Queues, 771–776 R Random access iterators, 966–969 Random access memory (RAM), 6 Random number generation, 188–189, 1024 Ranged for, using with containers, 990 Reading files, 308–309 Recursion, 789–831 base (stopping) cases, 798 case study: Binary Search, 810–818 case study: Vertical Numbers, 791–797 checking program for, 816–817 design techniques, 809–810 efficiency of, 817 ending, 797–798 function definition, 791 functions, 791–807 infinite, 799 iteration compared to, 802–803 iterative version of, 817–818 last–in/first–out (LIFO) data structure, 801–802 member functions as, 818–821 overloading compared to, 821 returning values, 804–807 1051 stacks for, 800–802 tasks, functions for, 791–803 tracing recursive calls, 794–797 values, functions for, 804–807 void functions and, 810 Remainder operator (%), 70–71 reserve function, 494 resize function, 494 Rethrowing exceptions, 918 return statements, 21, 196–197, 202, 255–259 Cplus_plus programming and, 21 functions and, 196–197 parentheses ( ) for, 197 programmer–defined functions, 196–197 void functions using, 255–259 Returning values, see Value returned Reverse iterators, 971–972 Robust input, C strings, 468, 470–471 Root node, 762 Running programs, 8–11, 26–28 Running times, 991–996 Run–time errors, 30 S scale function, 402–407 Scientific notation, 61–62 Scope, 137, 220–221, 226–227 block, 137, 226–227 global, 226–227 local, 220–221, 226–227 variables, 220–221, 226–227 Scope resolution operator (::), 557–558 Searching arrays, 414–416 Searching linked lists, 751–754 Secondary (auxiliary) memory, 3, 6–7 Selection sort, 417–418 Semicolons (;), 24, 146, 149–150, 547 1052 Index Sentinel value, loop design and, 158 Sequential access, memory and, 6 Sequential containers, 974–979 set algorithms, 1003 set class, 983–990 setf function, 325–327 setprecision manipulator, 329 setw manipulator, 329 short data type, 63 Short–circuit evaluation, 115 Single quotes (' ') for constant characters, 65 Single–precision numbers, 61 Size (number of elements), 379–382, 394, 411–414, 426–427, 493–494, 668–671 array parameters, 394 arrays, 379–382, 394, 411–414, 426–427 capacity compared to, 492 const modifier for, 376–382 constructors and, 668–671 declared, 379 dynamic arrays, 668–671 function arguments and, 414 multidimensional arrays, 426–427 partially filled arrays, 411–413 resize function, 494 vectors, 493–494 Software, 2, 7–8, 17, 715 abstract data types (ADT), 715 computer operating systems, 7–8 life cycle, 17 programs, 2 reusable components, 715 Sorting algorithms, 1004 Sorting arrays, 417–423 Source code, 9 Spacing, 24, 26, 202, 338–339 Cplus_plus programming, 24 character I/O and, 338–339 function definition and, 202 sqrt function, 183–185, 187 Square brackets [ ], 378–379, 392–393, 427, 431, 492 srand function, 187, 189 Stack class, 766–770, 979–983 Stacks, 765–766, 800–802, 801–802 empty, 770 implementation of, 768–770 last-in/first-out (LIFO) data structure, 766 linked lists as, 765–766 overflow, 802 pointers and, 765–766 pop function, 770 recursion and, 800–802 Standard Template Library (STL), 963–1013.
See also Templates Statements, 21–26, 33 Cplus_plus programming instructions, 21–26, 33 cin (input), 21–23 cout (output), 21–23 direction arrows (<< >>), 21 directives #, 25 executable, 21–26 #include directive, 21, 25, 26 new  (\n), 23 return, 25–26 semicolon (;), 24 Static variables, 518 static_cast<double>, 190–192 std namespace, 335–336 Stepwise refinement, 182–183 Storage, memory as, 6 strcat function, 459–460 strcmp function, 457–460 strcpy function, 457–461 Streams, 50, 305–376 appending to a file, 320–322 arguments to functions, as, 332 character I/O and, 338–360 cin as, 307 classes and, 312–315 cout as, 307 declaring, 308–310 default arguments, 348–349 fail function, 314 file names and, 308–310, 318 files and, 306–338 flags and, 325–327 formatting functions, 323–328 ifstream, 308–309, 318 input/output (I/O), 50 in_stream, 307, 308–309, 312–314, 318 manipulator functions for, 329 member functions and, 312–314, 338–349 namespaces and, 335–336 objects and, 312–315 ofstream, 308–309, 318 output, formatting using, 323–338 out_stream, 307, 308–310, 312–314, 318, 325–326 parameters, 346–349 using directives and, 335–336 variables as, 308 string class, 66–68, 472–488 <string> library, 472, 474 characters, 66–68 comparison operators and, 482, 487 concatenation (+), 66–67, 472 constants converted to, 473 data types and, 66–68 default constructor for, 473–474 double quotes (" ") for characters, 64–65 getline function, 475–476, 478–479 input/output (I/O) using, 475–477 Index lexicographic ordering of, 482 member functions, 480–483 object–to–C string conversion, 487–488 palindrome testing program example, 484–487 variable declaration, 66–68 whitespace characters and, 68 String functions, 1023 String values, 456–458, 668–671 C strings, 456–458 dynamic arrays, 668–671 implementation, 671–673 size of, 668 String variables, 322–323 stringvar class, 668–671 strlen function, 459 strncat function, 459 strncmp function, 459 strncpy function, 457, 459 Structures, 542–550, 575, 740–742 braces { } for, 543, 547 classes compared to, 542–550, 575 diverse data of, 542–547 dot operator (_0_) for, 545, 550 functional arguments, as, 548–549 hierarchy of, 549 initializing, 551 linked lists and, 740–742 member names, 543, 545–546 member values, 543, 546 member variables, 543, 545–547, 550 nodes as, 740–742 pointer variables for, 741–742 semicolons (;) for, 547 value, 543 Stubs, function testing using, 284–286 Subexpressions, 115 Subtasks, 251–303 assert macro, 290–291 call-by-reference parameters, 259–266 debugging functions, 282–287 functions for, 251–303 procedural abstraction, 273–281 testing functions, 282–287 void functions, 252–259 Subtraction operator (-), 70 switch statements, 128–135 break statements, 131–133 menus, 133–134 multiway branching, 128–135 Syntax, 30, 45, 939–941 class templates for, 939–941 errors, 30 variable declaration and, 45 T Tasks, recursive functions for, 791–803 Templates, 925–956, 963–1013 algorithm abstraction, 926–938 class syntax, 939–941 containers, 973–990 data abstractions, 939–948 function definition, 937–938 generic algorithms, 991–1004 iterators, 959–973 Standard Template Library (STL), 963–1013 type definitions, 942 Terminal, computer output device, 3 Testing programs, 27–31, 214–217, 281–287, 407 boundary values, 281 compiling and running programs, 27–29 debugging and, 29–31 drivers, 282–284 error messages, 30–31 functions, 214–217, 281 input, 281 logic errors, 30–31 1053 procedural abstraction and, 214–217, 281 program testing, 214–217, 281 run-time errors, 30 scale function, 407 stubs, 284–286 syntax errors, 30 warning messages, 30 Text files, editing, 355–357 this pointer, 1029–1031 Throw list, 911–913 throw statement, 898–900, 909–911 Throwing exceptions, 894, 909–911, 914–916 Top-down design, 182–183, 398–409 toupper and tolower functions, 358–360 Tracing recursive calls, 794–797 Tracing variables, 162–163, 288 Trees, data structures as, 761–762 Trigonometric functions, 1025 Trivial exceptions, 909 true/false values, 66, 116.
See also Boolean ­expressions Truth tables, 112–114 try-catch blocks, 916 try-throw-catch mechanism, 898, 901–903 Two–dimensional arrays, 427, 531–532 Type casting, 190–192 Type name, variables, 44–45 typedef function, 518–520, 530 U Unary operators, 87, 649–650 Uninitialized variables, 47–49, 152 unsigned int type, 490–491 User role, 19 using directive, 52, 186, 228–229, 335–336, 719–721, 724–726, 959–960 1054 Index V Value returned, 183, 196–197, 199, 202, 358–360, 804–807, 809–810 bool statements, 199 character data, 358–360 predefined functions, 183 programmer–defined functions, 196–197 recursion, 804–807 return statements, 196–197, 202 toupper and tolower, functions for, 358–360 Values, recursive functions for, 804–807 Variables, 21–23, 40–50, 60–74, 135–137, 143–144, 147–149, 152, 162–163, 218–229, 288, 308, 378–386, 389–391, 426, 431, 453–460, 489–492, 508–520, 521–523, 527, 664–667, 668–671 arithmetic operators for, 69–72 arrays and, 378–386, 389–391, 453–460, 521–523, 527, 664–667, 668–671 assignment statements, 45–49, 69, 511–512 asterisk (*) used for, 509–512 automatic, 518 blocks and, 135–137 C strings, 453–460 cin (input) statements, 21–23 class members, 664–667 cout (output) statements, 21–23 data types, 44–45, 60–74 declaration of, 21–23, 44–45, 48–49, 64, 66–68, 147, 378–382, 453–454 dereferencing (*) operator for, 510–511 dynamic, 513, 516–518 dynamic arrays and, 521–523, 527, 668–671 equal  (=) for, 22 for statements for, 147–149 function and, 218–229 global, 223–224, 226–227, 518 identifiers, 42–44 increment/decrement operators for, 143–144 indexed, 379–386, 389–391, 426, 431, 489 initializing, 48–49, 145–146, 386, 454–455 integers as, 21, 44–45 local, 135–137, 218–229 loop mechanisms and, 135–137, 143–144, 147–149, 152, 162–163 memory locations, 41–42, 382–383 naming, 42–45, 49 new  for, 513–515 null (/0) character and, 453–454, 456 pointers, 508–520, 521–523, 527 scope, 220–221, 226–227 square brackets [ ] used for, 378–380, 492 static, 518 streams as, 308 string, 66–68, 668–671 syntax for, 45 tracing, 162–163, 288 type name, 44–45 uninitialized, 47–49, 152 values, 22, 45–48, 162–163, 489–492 vectors, 489–492 Vectors, 489–494, 961–965 assignment  (=) for, 493 capacity( ) function, 493–494 capacity of, 493–494 constructor, 492 declaring variables, 489–490 efficiency of, 493–494 indexed variables, 489 iterators for, 961–965 reserve function, 494 size of, 493 square brackets [ ] used for, 492 unsigned int type, 490–491 variable values, 489–492 Virtual functions, polymorphism and, 864–876 void functions, 252–259, 810 Cplus_plus definition, 252–254 calls, 253–254 recursion and, 810 return statements in, 255–259 syntax, 253 W Warning messages, 30 while loop statements, 84–91, 139–144, 153–154 braces { } for execution of, 84–86 break statement for, 153–154 increment and decrement operators, 87–91, 141–144 infinite, 87–91 nested, 154 syntax of, 86, 140 zero times body execution, 87, 141 Whitespace characters, 68, 358 width function, 328 Workstation, 2 Writing abstract data types (ADT), 591–592 Writing files, 308–310 Z Zero times loop body execution, 87, 141 Zeros leading in number ­constants, 636 Credits Cover, © 145 / Corbis Figure 1_0_1a, © Alamy Figure 1_0_2b, © Alamy Figure 1_0_3c, © Alamy Chapter 1, pg.
As soon as an Analytical Engine exists, it Chapter 1, pg.
It can do whatever we know how to order it to perform.
It can follow ­analysis; but it has no power of anticipating any analytical relations or truths.
Its province is to assist us in making available what we are already acquainted with_0_" Ada Augusta, Chapter 1, pg.
A computer terminal is not some clunky old television with a typewriter in front of it.
It is an interface where the mind and the body can connect with the universe and move bits of it about_0_" © Douglas Adams, Mostly Harmless (the fifth volume in The Hitchhiker's Chapter 2, pg.
Dijkstra, Notes on Structured Programming Chapter 2, pg.
He's not her type_0_" Overheard at a cocktail party Chapter 2, pg.
That's logic_0_" © Lewis Carroll, Through the Looking-Glass 1055.
CREDITs "That depends a good deal on where you want to get to," said the Cat_0_" © Lewis Carroll, Alice in Wonderland Chapter 3, pg.
Vincent Millay, Letter to Arthur Darison Ficke, October 24, 1930 Traditional Carnival Barker's Call Chapter 4, pg.
There's glory for you_0_" "I don't know what you mean by 'glory,' " Alice said.
Humpty Dumpty smiled contemptuously, "Of course you don't — till I tell you.
I mean 'there's a nice knock-down argument for you_0_' " "But 'glory' doesn't mean 'a nice knock-down argument,' " Alice objected.
Hamlet: Words, words, words_0_" William Shakespeare, Hamlet Chapter 8, pg.
That which we call a rose By any other name would smell as sweet_0_" William Shakespeare, Romeo and Juliet Chapter 13, pg.
James, but it's wrong.
I've got a better theory," said the little old lady.
CREDITs the inadequacies of her position.
James, and that's a very good question," replied the little old lady, "but I have an answer to it.
And it is this: the first turtle stands on the back of a second, far larger, turtle, who stands directly under him_0_" "But what does this second turtle stand on_0_" persisted James patiently.
To this the little old lady crowed triumphantly.
James—it's turtles all the way down_0_" © J.
Ross, Constraints on Variables in Syntax begins to relate word for word the story of the Thousand and One Nights, establishing the risk of coming once again to the night when she must repeat it, and thus to infinity_0_" © Jorge Luis Borges, The Garden of Forking Paths Chapter 14, pg.
I didn't know it had to work for that case_0_" Computer Science Student, Appealing a Grade Chapter 16, pg.
Aristotle is a man.
Therefore, Aristotle is mortal.
All cats are mischievous.
Garfield is a cat.
Therefore, Garfield is mischievous_0_" A Short Lesson on Syllogisms Chapter 17, pg.
Chapter 4 Random Number Generation, p.