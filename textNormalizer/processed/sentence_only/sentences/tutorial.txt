All rights reserved This document and its content is copyright of cplusplus_0_com    © cplusplus_0_com, 2008.
All rights reserved.
Any redistribution or reproduction of part or all of the content in any form is prohibited other than to print a personal copy of the entire document or download it to a local hard disk, without modifying its content in any way (including, but not limited to, this copyright notice).
You may not, except with express written permission from cplusplus_0_com, distribute the content of this document.
Nor may you transmit it or store it in any other website or other form of electronic retrieval system.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 3 © cplusplus_0_com 2008.
All rights reserved Table of contents Table of contents _0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0_3 Introduction _0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0_5 Instructions for use _0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0_.
All rights reserved Preprocessor directives _0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0__0_.
All rights reserved Introduction Instructions for use To whom is this tutorial directed.
This tutorial is for those people who want to learn programming in Cplus_plus and do not necessarily have any previous knowledge of other programming languages.
Of course any knowledge of other programming languages or any general computer skill can be useful to better understand this tutorial, although it is not essential.
It is also suitable for those who need a little update on the new  the language has acquired from the latest standards.
If you are familiar with the C language, you can take the first 3 parts of this tutorial as a review of concepts, since they mainly explain the C part of Cplus_plus.
There are slight differences in the Cplus_plus syntax for some C , so I recommend you its reading anyway.
The 4th part describes object-oriented programming.
The 5th part mostly describes the new  introduced by ANSI-Cplus_plus standard.
Structure of this tutorial The tutorial is divided in 6 parts and each part is divided on its turn into different sections covering a topic each one.
You can access any section directly from the section index available on the left side bar, or begin the tutorial from any point and follow the links at the bottom of each section.
Many sections include examples that describe the use of the newly acquired knowledge in the chapter.
It is recommended to read these examples and to be able to understand each of the code lines that constitute it before passing to the next chapter.
A good way to gain experience with a programming language is by modifying and adding new  on your own to the example programs that you fully understand.
Don't be scared to modify the examples provided with this tutorial, that's the way to learn.
Compatibility Notes The ANSI-Cplus_plus standard acceptation as an international standard is relatively recent.
It was first published in November 1997, and revised in 2003.
Nevertheless, the Cplus_plus language exists from a long time before (1980s).
Therefore there are many compilers which do not support all the new  included in ANSI-Cplus_plus, especially those released prior to the publication of the standard.
This tutorial is thought to be followed with modern compilers that support -at least on some degree- ANSI-Cplus_plus specifications.
I encourage you to get one if yours is not adapted.
There are many options, both commercial and free.
Compilers The examples included in this tutorial are all console programs.
That means they use text to communicate with the user and to show their results.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 6 © cplusplus_0_com 2008.
All rights reserved All Cplus_plus compilers support the compilation of console programs.
Check the user's manual of your compiler for more info on how to compile them.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 7 © cplusplus_0_com 2008.
All rights reserved Basics of Cplus_plus Structure of a program Probably the best way to start learning a programming language is by writing a program.
Therefore, here is our first program: // my first program in Cplus_plus.
The first panel shows the source code for our first program.
The second one shows the result of the program once compiled and executed.
The way to edit and compile a program depends on the compiler you are using.
Depending on whether it has a Development Interface or not and on its version.
Consult the compilers section and the manual or help included with your compiler if you have doubts on how to compile a Cplus_plus console program.
The previous program is the typical program that programmer apprentices write for the first time, and its result is the printing on screen of the "Hello World_0_" sentence.
It is one of the simplest programs that can be written in Cplus_plus, but it already contains the fundamental components that every Cplus_plus program has.
We are going to look line by line at the code we have just written: // my first program in Cplus_plus This is a comment line.
All lines beginning with two slash signs (//) are considered comments and do not have any effect on the behavior of the program.
The programmer can use them to  short explanations or observations within the source code itself.
In this case, the line is a brief description of what our program is.
They are not regular code lines with expressions but indications for the compiler's preprocessor.
In this case the directive # <iostream> tells the preprocessor to  the iostream standard file.
This specific file (iostream) includes the declarations of the basic standard input-output library in Cplus_plus, and it is included because its functionality is going to be used later in the program.
So in order to access its functionality we declare with this expression that we will be using these entities.
This line is very frequent in Cplus_plus programs that use the standard library, and in fact it will be included in most of the source codes included in these tutorials.
The main function is the point by where all Cplus_plus programs start their execution, independently of its location within the source code.
It does not matter whether there are other functions with other names defined before or after it - the instructions contained within this function's definition will always be the first ones to be executed in any Cplus_plus program.
For that same reason, it is essential that all Cplus_plus programs have a main function.
The word main is followed in the code by a pair of parentheses (()).
That is because it is a function declaration: In Cplus_plus, what differentiates a function declaration from other types of expressions are these parentheses that follow its name.
Optionally, these parentheses may enclose a list of parameters within them.
Right after these parentheses we can find the body of the main function enclosed in braces ({}).
What is contained within these braces is what the function does when it is executed.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 8 © cplusplus_0_com 2008.
All rights reserved cout << "Hello World_0_"; This line is a Cplus_plus statement.
A statement is a simple or compound expression that can actually produce some effect.
In fact, this statement performs the only action that generates a visible effect in our first program.
Notice that the statement ends with a semicolon character (;).
This character is used to mark the end of the statement and in fact it must be included at the end of all expression statements in all Cplus_plus programs (one of the most common syntax errors is indeed to forget to  some semicolon after a statement).
A return code of 0 for the main function is generally interpreted as the program worked as expected without any errors during its execution.
This is the most usual way to end a Cplus_plus console program.
You may have noticed that not all the lines of this program perform actions when the code is executed.
There were lines containing only comments (those beginning by //).
There were lines with directives for the compiler's preprocessor (those beginning by #).
Then there were lines that began the declaration of a function (in this case, the main function) and, finally lines with statements (like the insertion into ), which were all included within the block delimited by the braces ({}) of the main function.
The program has been structured in different lines in order to be more readable, but in Cplus_plus, we do not have strict rules on how to separate instructions in different lines.
For example, instead of int main () { << " Hello World_0_";.
In Cplus_plus, the separation between statements is specified with an ending semicolon (;) at the end of each one, so the separation in different code lines does not matter at all for this purpose.
We can write many statements per line or write a single statement that takes many code lines.
The division of code in different lines serves only to make it more legible and schematic for the humans that may read it.
Let us add an additional instruction to our first program: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 9 © cplusplus_0_com 2008.
All rights reserved // my second program in Cplus_plus.
I'm a Cplus_plus program In this case, we performed two insertions into  in two different statements.
Once again, the separation in different lines of code has been done just to give greater readability to the program, since main could have been perfectly valid defined this way: int main () {  << " Hello World.
Preprocessor directives (those that begin by #) are out of this general rule since they are not statements.
They are lines read and processed by the preprocessor and do not produce any code by themselves.
Preprocessor directives must be specified in their own line and do not have to end with a semicolon (;).
Comments Comments are parts of the source code disregarded by the compiler.
Their purpose is only to allow the programmer to insert notes or descriptions embedded within the source code.
Cplus_plus supports two ways to insert comments: // line comment /* block comment */ The first of them, known as line comment, discards everything from where the pair of slash signs (//) is found up to the end of that same line.
The second one, known as block comment, discards everything between the /* characters and the first appearance of the */ characters, with the possibility of including more than one line.
We are going to add comments to our second program: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 10 © cplusplus_0_com 2008.
All rights reserved /* my second program in Cplus_plus with more comments */ # <iostream>.
Cplus_plus program return 0; } Hello World.
I'm a Cplus_plus program If you  comments within the source code of your programs without using the comment characters combinations //, /* or */, the compiler will take them as if they were Cplus_plus expressions, most likely causing one or several error messages when you compile it.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 11 © cplusplus_0_com 2008.
All rights reserved Variables.
The usefulness of the "Hello World" programs shown in the previous section is quite questionable.
We had to write several lines of code, compile them, and then execute the resulting program just to obtain a simple sentence written on the screen as result.
It certainly would have been much faster to type the output sentence by ourselves.
However, programming is not limited only to printing simple texts on the screen.
In order to go  little further on and to become able to write programs that perform useful tasks that really save us work we need to introduce the concept of variable.
Let us think that I ask you to retain the number 5 in your mental memory, and then I ask you to memorize also the number 2 at the same time.
You have just stored two different values in your memory.
Now, if I ask you to add 1 to the first number I said, you should be retaining the numbers 6 (that is 5+1) and 2 in your memory.
Values that we could now for example subtract and obtain 4 as.
The whole process that you have just done with your mental memory is  simile of what  computer can do with two variables.
The same process can be expressed in Cplus_plus with the following instruction set: = 5; = 2; =  + 1; =  - ; Obviously, this is  very simple example since we have only used two small integer values, but consider that your computer can store millions of numbers like these at the same time and conduct sophisticated mathematical operations with them.
Therefore, we can define  variable as  portion of memory to store  determined value.
Each variable needs an identifier that distinguishes it from the others, for example, in the previous code the variable identifiers were ,  and , but we could have called the variables any names we wanted to invent, as long as they were valid identifiers.
Identifiers A valid identifier is  sequence of one or more letters, digits or underscore characters (_).
Neither spaces nor punctuation marks or symbols can be part of an identifier.
Only letters, digits and single underscore characters are valid.
In addition, variable identifiers always have to begin with  letter.
They can also begin with an underline character (_ ), but in some cases these may be reserved for compiler specific keywords or external identifiers, as well as identifiers containing two successive underscore characters anywhere.
In no case they can begin with digit.
Another rule that you have to consider when inventing your own identifiers is that they cannot match any keyword of the Cplus_plus language nor your compiler's specific ones, which are reserved keywords.
The standard reserved keywords are: asm, auto, bool, break, case, catch, char, class, const, const_cast, continue, default, delete, do, double, dynamic_cast, else, enum, explicit, export, extern, false, float, for, friend, goto, if, inline, int, long, mutable, namespace, , , private, protected, public, register, reinterpret_cast, return, short, signed, sizeof, static, static_cast, struct, switch, template, this, throw, true, try, typedef, typeid, typename, union, unsigned, using, virtual, void, volatile, wchar_t, while Additionally, alternative representations for some operators cannot be used as identifiers since they are reserved words under some circumstances: and, and_eq, bitand, bitor, compl, not, not_eq, or, or_eq, xor, xor_eq TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 12 © cplusplus_0_com 2008.
All rights reserved Your compiler may also  some additional specific reserved keywords.
Very important: The Cplus_plus language is  "case sensitive" language.
That means that an identifier written in capital letters is not equivalent to another one with the same name but written in small letters.
Thus, for example, the RESULT variable is not the same as the  variable or the Result variable.
These are three different variable identifiers.
Fundamental data types When programming, we store the variables in our computer's memory, but the computer has to know what kind of data we want to store in them, since it is not going to occupy the same amount of memory to store  simple number than to store  single letter or  large number, and they are not going to be interpreted the same way.
The memory in our computers is organized in bytes.
A byte is the minimum amount of memory that we can manage in Cplus_plus.
A byte can store  relatively small amount of data: one single character or  small integer (generally an integer between 0 and 255).
In addition, the computer can manipulate more complex data types that come from grouping several bytes, such as long numbers or non-integer numbers.
Next you have  summary of the basic fundamental data types in Cplus_plus, as well as the range of values that can be represented with each one: Name Description Size* Range* char Character or small integer.
It can take one of two values: true or false.
The values shown above are those found on most 32-bit systems.
But for other systems, the general specification is that int has the natural size suggested by the system architecture (one "word") and the four integer types char, short, int and long must each one be at least as large as the one preceding it, with char being always 1 byte in size.
The same applies to the floating point types float, double and long double, where each one must provide at least as much precision as the preceding one.
Declaration of variables In order to use a  in Cplus_plus, we must first declare it specifying which data type we want it to be.
The syntax to declare a   is to write the specifier of the desired data type (like int, bool, float_0__0__0_) followed by a valid identifier.
For example: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 13 © cplusplus_0_com 2008.
All rights reserved int a; float mynumber; These are two valid declarations of variables.
The first one declares a  of type int with the identifier a.
The second one declares a  of type float with the identifier mynumber.
Once declared, the variables a and mynumber can be used within the rest of their scope in the program.
If you are going to declare more than one  of the same type, you can declare all of them in a single statement by separating their identifiers with commas.
For example: int a, b, c; This declares three variables (a, b and c), all of them of type int, and has exactly the same meaning as: int a; int b; int c; The integer data types char, short, long and int can be either signed or unsigned depending on the range of numbers needed to be represented.
Signed types can represent both positive and negative values, whereas unsigned types can only represent positive values (and zero).
This can be specified by using either the specifier signed or the specifier unsigned before the type name.
For example: unsigned short int NumberOfSisters; signed int MyAccountBalance; By default, if we do not specify either signed or unsigned most compiler settings will assume the type to be signed, therefore instead of the second declaration above we could have written: int MyAccountBalance; with exactly the same meaning (with or without the keyword signed) An exception to this general rule is the char type, which exists by itself and is considered a different fundamental data type from signed char and unsigned char, thought to store characters.
You should use either signed or unsigned if you intend to store numerical values in a char-sized.
In this case, they refer to their respective integer fundamental types: short is equivalent to short int and long is equivalent to long int.
The following two declarations are equivalent: short Year; short int Year; Finally, signed and unsigned may also be used as standalone type specifiers, meaning the same as signed int and unsigned int respectively.
The following two declarations are equivalent: unsigned NextYear; unsigned int NextYear; To see what  declarations look like in action within a program, we are going to see the Cplus_plus code of the example about your mental memory proposed at the beginning of this section: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 14 © cplusplus_0_com 2008.
All rights reserved // operating with variables.
You will see the rest in detail in coming sections.
Scope of variables All the variables that we intend to use in  program must have been declared with its type specifier in an earlier point in the code, like we did in the previous code at the beginning of the body of the function main when we declared that , , and  were of type int.
A  can be either of global or local scope.
A global  is   declared in the main body of the source code, outside all functions, while  local  is one declared within the body of  function or  block.
Global variables can be referred from anywhere in the code, even inside functions, whenever it is after its declaration.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 15 © cplusplus_0_com 2008.
All rights reserved The scope of local variables is limited to the block enclosed in braces ({}) where they are declared.
For example, if they are declared at the beginning of the body of  function (like in function main) their scope is between its declaration point and the end of that function.
In the example above, this means that if another function existed in addition to main, the local variables declared in main could not be accessed from the other function and vice versa.
Initialization of variables When declaring  regular local variable, its value is by default undetermined.
But you may want  variable to store concrete value at the same moment that it is declared.
In order to do that, you can initialize the variable.
There are two ways to do this in Cplus_plus: The first one, known as c-like, is done by appending an equal sign followed by the value to which the variable will be initialized: type  = initial_value ; For example, if we want to declare an int variable called  initialized with  value of 0 at the moment in which it is declared, we could write: int  = 0; The other way to initialize variables, known as constructor initialization, is done by enclosing the initial value between parentheses (()): type  (initial_value) ; For example: int  (0); Both ways of initializing variables are valid and equivalent in Cplus_plus.
The Cplus_plus language library provides support for strings through the standard string class.
This is not fundamental type, but it behaves in  similar way as fundamental types do in its most basic usage.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 16 © cplusplus_0_com 2008.
All rights reserved A first difference with fundamental data types is that in order to declare and use objects (variables) of this type we need to  an additional header file in our source code: <string> and have access to the std namespace (which we already had in all our previous programs thanks to the using namespace statement).
Both initialization formats are valid with strings: string  = "This is  string"; string  ("This is  string"); Strings can also perform all the other basic operations that fundamental data types can, like being declared without an initial  and being assigned values during execution:.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 17 © cplusplus_0_com 2008.
All rights reserved Constants Constants are expressions with  fixed.
Literals Literals are used to express particular values within the source code of  program.
We have already used these previously to give concrete values to variables or to express messages we wanted our programs to print out, for example, when we wrote: = 5; the 5 in this piece of code was  literal constant.
Literal constants can be divided in Integer Numerals, Floating-Point Numerals, Characters, Strings and Boolean Values.
Integer Numerals 1776 707 -273 They are numerical constants that identify integer decimal values.
Notice that to express  numerical constant we do not have to write quotes (") nor any special character.
There is no doubt that it is  constant: whenever we write 1776 in  program, we will be referring to the  1776.
In addition to decimal numbers (those that all of us are used to use every day) Cplus_plus allows the use as literal constants of octal numbers (base 8) and hexadecimal numbers (base 16).
If we want to express an octal number we have to precede it with  0 (zero character).
And in order to express  hexadecimal number we have to precede it with the characters 0x (zero, x).
For example, the following literal constants are all equivalent to each other: 75         // decimal 0113       // octal 0x4b       // hexadecimal All of these represent the same number: 75 (seventy-five) expressed as  base-10 numeral, octal numeral and hexadecimal numeral, respectively.
Literal constants, like variables, are considered to have  specific data type.
By default, integer literals are of type int.
However, we can force them to either be unsigned by appending the u character to it, or long by appending l:.
In both cases, the suffix can be specified using either upper or lowercase letters.
Floating Point Numbers They express numbers with decimals and/or exponents.
They can  either  decimal point, an e character (that expresses "by ten at the Xth height", where X is an integer  that follows the e character), or both decimal point and an e character: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 18 © cplusplus_0_com 2008.
All rights reserved.
These are four valid numbers with decimals expressed in Cplus_plus.
The first number is PI, the second one is the number of Avogadro, the third is the electric charge of an electron (an extremely small number) -all of them approximated- and the last one is the number three expressed as  floating-point numeric literal.
The default type for floating point literals is double.
If you explicitly want to express  float or long double numerical literal, you can use the f or l suffixes respectively: 3_0_14159L   // long double 6_0_02e23f   // float Any of the letters that can be part of  floating-point numerical constant (e, f, l) can be written using either lower or uppercase letters without any difference in their meanings.
Character and string literals There also exist non-numerical constants, like: 'z' 'p' "Hello world" "How do you do_0_" The first two expressions represent single character constants, and the following two represent string literals composed of several characters.
Notice that to represent  single character we enclose it between single quotes (') and to express  string (which generally consists of more than one character) we enclose it between double quotes (").
When writing both single character and string literals, it is necessary to put the quotation marks surrounding them to distinguish them from possible variable identifiers or reserved keywords.
Notice the difference between these two expressions: x 'x' x alone would refer to  variable whose identifier is x, whereas 'x' (enclosed within single quotation marks) would refer to the character constant 'x'.
Character and string literals have certain peculiarities, like the escape codes.
These are special characters that are difficult or impossible to express otherwise in the source code of  program, like newline (\n) or tab (\t).
All of them are preceded by  backslash (\).
Here you have  list of some of such escape codes: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 19 © cplusplus_0_com 2008.
All rights reserved \n newline \r carriage return \t tab \v vertical tab \b backspace \f form feed (page feed) \ alert (beep) \' single quote (') \" double quote (") \.
In the first case (octal) the digits must immediately follow the backslash (for example \23 or \40), in the second case (hexadecimal), an x character must be written before the digits themselves (for example \x20 or \x4A).
String literals can extend to more than  single line of code by putting  backslash sign (\) at the end of each unfinished line.
Boolean literals There are only two valid Boolean values: true and false.
These can be expressed in Cplus_plus as values of type bool by using the Boolean literals true and false.
Defined constants (#define) You can define your own names for constants that you use very often without having to resort to memoryconsuming variables, simply by using the #define preprocessor directive.
Its format is: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 20 © cplusplus_0_com 2008.
All rights reserved #define identifier value For example: #define PI 3_0_14159 #define NEWLINE '\n' This defines two new : PI and NEWLINE.
Once they are defined, you can use them in the rest of the code as if they were any other regular constant, for example: // defined : calculate circumference # <iostream> using namespace std; #define PI 3_0_14159 #define NEWLINE '\n' int main () { double =5_0_0;               // radius double ; = 2 * PI * ; cout << ; cout << NEWLINE; return 0; } 31_0_4159 In fact the only thing that the compiler preprocessor does when it encounters #define directives is to literally replace any occurrence of their identifier (in the previous example, these were PI and NEWLINE) by the code to which they have been defined (3_0_14159 and '\n' respectively).
The #define directive is not a Cplus_plus statement but a directive for the preprocessor; therefore it assumes the entire line as the directive and does not require a semicolon (;) at its end.
If you append a semicolon character (;) at the end, it will also be appended in all occurrences within the body of the program that the preprocessor replaces.
Declared  (const) With the const prefix you can declare  with a specific type in the same way as you would do with a variable: const int  = 100; const char  = '\t'; Here,  and  are two typed.
They are treated just like regular variables except that their values cannot be modified after their definition.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 21 © cplusplus_0_com 2008.
All rights reserved Operators Once we know of the existence of variables and , we can begin to operate with them.
For that purpose, Cplus_plus integrates operators.
Unlike other languages whose operators are mainly keywords, operators in Cplus_plus are mostly made of signs that are not part of the alphabet but are available in all keyboards.
This makes Cplus_plus code shorter and more international, since it relies less on English words, but requires  little of learning effort in the beginning.
You do not have to memorize all the content of this page.
Most details are only provided to serve as  later reference in case you need it.
The part at the left of the assignment  (=) is known as the lvalue (left ) and the right one as the rvalue (right ).
The lvalue has to be  variable whereas the rvalue can be either  constant,  variable, the result of an operation or any combination of these.
The most important rule when assigning is the right-to-left rule: The assignment operation always takes place from right to left, and never the other way: = b; This statement assigns to variable  (the lvalue) the  contained in variable b (the rvalue).
The  that was stored until this moment in  is not considered at all in this operation, and in fact that  is lost.
Consider also that we are only assigning the  of b to  at the moment of the assignment operation.
Therefore later change of b will not affect the new  of.
For example, let us have  look at the following code - I have included the evolution of the content stored in the variables as comments: // assignment.
Notice how  was not affected by the final modification of , even though we declared  =  earlier (that is because of the right-toleft rule).
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 22 © cplusplus_0_com 2008.
All rights reserved A property that Cplus_plus has over other programming languages is that the assignment operation can be used as the rvalue (or part of an rvalue) for another assignment operation.
For example: = 2 + ( = 5); is equivalent to: = 5; = 2 + ; that means: first assign 5 to variable  and then assign to  the  2 plus the result of the previous assignment of  (i_0_e.
The following expression is also valid in Cplus_plus: =  =  = 5; It assigns 5 to the all the three variables: ,  and.
Arithmetic operators ( +, -, *, /, % ) The five arithmetical operations supported by the Cplus_plus language are: + addition - subtraction * multiplication / division % modulo Operations of addition, subtraction, multiplication and division literally correspond with their respective mathematical operators.
The only one that you might not be so used to see is modulo; whose  is the percentage sign (%).
Modulo is the operation that gives the remainder of  division of two values.
For example, if we write: = 11 % 3; the variable  will contain the  2, since 2 is the remainder from dividing 11 between 3.
For example: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 23 © cplusplus_0_com 2008.
All rights reserved // compound  operators.
Thus: cplus_plus; +=1; =+1; are all equivalent in its functionality: the three of them increase by one the  of.
In the early C compilers, the three previous expressions probably produced different executable code depending on which one was used.
Nowadays, this type of code optimization is generally done automatically by the compiler, thus the three expressions should produce exactly the same executable code.
A characteristic of this operator is that it can be used both as  prefix and as  suffix.
That means that it can be written either before the variable identifier (plus_plusa) or after it (aplus_plus).
Although in simple expressions like aplus_plus or plus_plusa both have exactly the same meaning, in other expressions in which the result of the increase or decrease operation is evaluated as   in an outer expression they may have an important difference in their meaning: In the case that the increase operator is used as  prefix (plus_plusa) the  is increased before the result of the expression is evaluated and therefore the increased  is considered in the outer expression; in case that it is used as  suffix (aplus_plus) the  stored in  is increased after being evaluated and therefore the  stored before the increase operation is evaluated in the outer expression.
Notice the difference: Example 1 Example 2 =3; =plus_plusB; //  contains 4,  contains 4 =3; =Bplus_plus; //  contains 3,  contains 4 In Example 1,  is increased before its  is copied.
While in Example 2, the  of  is copied   and then  is increased.
Relational and equality  ( ==, _0_=, >, <, >=, <= ) In order  evaluate  comparison between two expressions we can use the relational and equality.
The result of  relational operation is  Boolean  that can only be true or false, according  its Boolean result.
We may want  compare two expressions, for example,  know if they are equal or if one is greater than the other is.
Here is  list of the relational and equality  that can be used in Cplus_plus: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 24 © cplusplus_0_com 2008.
All rights reserved == Equal _0_= Not equal > Greater than < Less than >= Greater than or equal <= Less than or equal Here there are some examples:.
Thus, in the last expression ((=2) == ), we first assigned the  2   and then we compared it  , that also stores the 2, so the result of the operation is true.
Logical  ( _0_, &&, || ) Operator.
Basically, it returns the opposite Boolean  of evaluating its operand.
For example: _0_(5 == 5)    // evaluates  false  the expression at its  (5 == 5) is true.
This operation results true if both its two operands are true, and false otherwise.
This operation results true if either  of its two operands is true, thus being false only when both operands are false themselves.
Here are the possible results of || : TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 25 © cplusplus_0_com 2008.
All rights reserved || OPERATOR || true true true true false true false true true false false false For example: ( (5 == 5) && (3 > 6) )  // evaluates  false ( true && false ).
Its format is: condition.
Comma  ( , ) comma  (,) is used to separate two or more expressions that are included where only  expression is expected.
When the set of expressions has to be evaluated for  value, only the rightmost expression is considered.
For example, the following code: = (=3, +2); TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 26 © cplusplus_0_com 2008.
All rights reserved Would first assign the value 3 to , and then assign +2 to variable.
So, at the end, variable  would contain the value 5 while variable  would contain value 3.
Bitwise Operators ( &, |, ^, ~, <<, >> ) Bitwise operators modify variables considering the bit patterns that represent the values they store.
The simplest one, which has been inherited from the C language, is to precede the expression to be converted by the new  enclosed between parentheses (()): int ; float  = 3_0_14; = (int) ; The previous code converts the float number 3_0_14 to an integer value (3), the remainder is lost.
Here, the typecasting operator was (int).
Another way to do the same thing in Cplus_plus is using the functional notation: preceding the expression to be converted by the  and enclosing the expression between parentheses: = int (  ); Both ways of  casting are valid in Cplus_plus.
The value returned by sizeof is  constant, so it is always determined before program execution.
Other operators Later in these tutorials, we will see  few more operators, like the ones referring to pointers or the specifics for object-oriented programming.
Each one is treated in its respective section.
Precedence of operators When writing complex expressions with several operands, we may have some doubts about which operand is evaluated first and which later.
For example, in this expression: = 5 + 7 % 2 TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 27 © cplusplus_0_com 2008.
All rights reserved we may doubt if it really means: = 5 + (7 % 2)    // with  result of 6, or = (5 + 7) % 2    // with  result of 0 The correct answer is the first of the two expressions, with  result of 6.
There is an established order with the priority of each operator, and not only the arithmetic ones (those whose preference come from mathematics) but for all the operators which can appear in Cplus_plus.
From greatest to lowest priority, the priority order is as follows: Level Operator Description Grouping 1 :: scope Left-toright 2 () [].
All these precedence levels for operators can be manipulated or become more legible by removing possible ambiguities using parentheses signs ( and ), as in this example: = 5 + 7 % 2; TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 28 © cplusplus_0_com 2008.
All rights reserved might be written either as: = 5 + (7 % 2); or = (5 + 7) % 2; depending on the operation that we want to perform.
So if you want to write complicated expressions and you are not completely sure of the precedence levels, always include parentheses.
It will also become  code easier to read.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 29 © cplusplus_0_com 2008.
All rights reserved Basic Input/Output Until now, the example programs of previous sections provided very little interaction with the user, if any at all.
Using the standard input and output library, we will be able to interact with the user by printing messages on the screen and getting the user's input from the keyboard.
Cplus_plus uses  convenient abstraction called streams to perform input and output operations in sequential media such as the screen or the keyboard.
A stream is an object where  program can either insert or extract characters to/from it.
We do not really need to care about many specifications about the physical media associated with the stream - we only need to know it will accept or provide characters sequentially.
The standard Cplus_plus library includes the header file iostream, where the standard input and output stream objects are declared.
Standard Output () By default, the standard output of  program is the screen, and the Cplus_plus stream object defined to access it is.
In the examples above it inserted the constant string Output sentence, the numerical constant 120 and variable x into the standard output stream.
Notice that the sentence in the first instruction is enclosed between double quotes (") because it is  constant string of characters.
Whenever we want to use constant strings of characters we must enclose them between double quotes (") so that they can be clearly distinguished from variable names.
For example, these two sentences have very different results: << "Hello";  // prints Hello << Hello;    // prints the content of Hello variable The insertion operator (<<) may be used more than once in  single statement: << "Hello, " << "I am " << " Cplus_plus statement"; This last statement would print the message Hello, I am  Cplus_plus statement on the screen.
The utility of repeating the insertion operator (<<) is demonstrated when we want to print out  combination of variables and constants or more than one variable: << "Hello, I am " << age << " years old and my zipcode is " << zipcode; If we assume the age variable to contain the value 24 and the zipcode variable to contain 90064 the output of the previous statement would be: Hello, I am 24 years old and my zipcode is 90064 It is important to notice that  does not add  line break after its output unless we explicitly indicate it, therefore, the following statements: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 30 © cplusplus_0_com 2008.
All rights reserved << "This is  sentence_0_"; << "This is another sentence_0_"; will be shown on the screen one following the other without any  break between them: This is  sentence_0_This is another sentence.
In order to perform   break on the output we must explicitly insert  new- character into.
In Cplus_plus  new- character can be specified as \n (backslash, n): << "First sentence_0_\n "; << "Second sentence_0_\nThird sentence_0_"; This produces the following output: First sentence.
Additionally, to add  new-, you may also use the endl manipulator.
For example: << "First sentence_0_" << endl; << "Second sentence_0_" << endl; would print out: First sentence.
The endl manipulator produces  newline character, exactly as the insertion of '\n' does, but it also has an additional behavior when it is used with buffered streams: the buffer is flushed.
Anyway,  will be an unbuffered stream in most cases, so you can generally use both the \n escape character and the endl manipulator in order to specify  new  without any difference in its behavior.
Standard Input (cin).
The standard input device is usually the keyboard.
Handling the standard input in Cplus_plus is done by applying the overloaded operator of extraction (>>) on the cin stream.
The operator must be followed by the variable that will store the data that is going to be extracted from the stream.
For example: int age; cin >> age; The first statement declares  variable of type int called age, and the second one waits for an input from cin (the keyboard) in order to store it in this integer variable.
Therefore, even if you request  single character, the extraction from cin will not process the input until the user presses RETURN after the character has been introduced.
You must always consider the type of the variable that you are using as  container with cin extractions.
If you request an integer you will get an integer, if you request  character you will get  character and if you request string of characters you will get  string of characters.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 31 © cplusplus_0_com 2008.
All rights reserved // i/o example.
The user of a program may be one of the factors that generate errors even in the simplest programs that use cin (like the one we have just seen).
Since if you request an integer value and the user introduces a name (which generally is a string of characters), the result may cause your program to misoperate since it is not what we were expecting from the user.
So when you use the data input provided by cin extractions you will have to trust that the user of your program will be cooperative and that he/she will not introduce his/her name or something similar when an integer value is requested.
A little ahead, when we see the stringstream class we will see a possible solution for the errors that can be caused by this type of user input.
You can also use cin to request more than one datum input from the user: cin >> a >> b; is equivalent to: cin >> a; cin >> b; In both cases the user must give two data, one for variable a and another one for variable b that may be separated by any valid blank separator: a space, a tab character or a newline.
This behavior may or may not be what we want; for example if we want to get a sentence from the user, this extraction operation would not be useful.
In order to get entire lines, we can use the function getline, which is the more recommendable way to get user input with cin: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 32 © cplusplus_0_com 2008.
All rights reserved.
Juan SouliÃ‾Â¿Â½ Hello Juan SouliÃ‾Â¿Â½.
What is your favorite team.
The Isotopes I like The Isotopes too.
Notice how in both calls to getline we used the same string identifier (mystr).
What the program does in the second call is simply to replace the previous content by the new  that is introduced.
This way we can perform extraction or insertion operations from/to strings, which is especially useful to convert strings to numerical values and vice versa.
For example, if we want to extract an integer from a string we can write: string mystr ("1204"); int myint; stringstream(mystr) >> myint; This declares a string object with a value of "1204", and an int object.
Then we use stringstream's constructor to construct an object of this type from the string object.
Because we can use stringstream objects as if they were streams, we can extract an integer from it as we would have done on cin by applying the extractor operator (>>) on it followed by a variable of type int.
After this piece of code, the variable myint will contain the numerical value 1204.
Instead of extracting numeric values directly from the standard input, we get lines from the standard input (cin) into a string object (mystr), and then we extract the integer values from this string into a variable of type int ().
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 33 © cplusplus_0_com 2008.
All rights reserved Using this method, instead of direct extractions of integer values, we have more control over what happens with the input of numeric values from the user, since we are separating the process of obtaining input from the user (we now simply ask for lines) with the interpretation of that input.
Therefore, this method is usually preferred to get numerical values from the user in all programs that are intensive in user input.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 34 © cplusplus_0_com 2008.
All rights reserved Control Structures Control Structures A program is usually not limited to a linear sequence of instructions.
During its process it may bifurcate, repeat code or take decisions.
For that purpose, Cplus_plus provides control structures that serve to specify what has to be done by our program, when and under which circumstances.
With the introduction of control structures we are going to have to introduce a new : the compoundstatement or block.
A block is a group of statements which are separated by semicolons (;) like all Cplus_plus statements, but grouped together in a block enclosed in braces: { }: { statement1; statement2; statement3; } Most of the control structures that we will see in this section require a generic statement as part of its syntax.
A statement can be either a simple statement (a simple instruction ending with a semicolon) or a compound statement (several instructions grouped in a block), like the  just described.
In the case that we want the statement to be a simple statement, we do not need to enclose it in braces ({}).
But in the case that we want the statement to be a compound statement it must be enclosed between braces ({}), forming a block.
Conditional structure: if and else The if keyword is used to execute a statement or block only if a condition is fulfilled.
Its form is: if (condition) statement Where condition is the expression that is being evaluated.
If this condition is true, statement is executed.
If it is false, statement is ignored (not executed) and the program continues right after this conditional structure.
For example, the following code fragment prints  is 100 only if the value stored in the  variable is indeed 100: if ( == 100) cout << " is 100"; If we want more than a single statement to be executed in case that the condition is true we can specify a block using braces { }: if ( == 100) { cout << " is "; cout << ; } We can additionally specify what we want to happen if the condition is not fulfilled by using the keyword else.
Its form used in conjunction with if is: if (condition) statement1 else statement2 For example: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 35 © cplusplus_0_com 2008.
All rights reserved if ( == 100) cout << " is 100"; else cout << " is not 100"; prints on the screen  is 100 if indeed  has a value of 100, but if it has not -and only if not- it prints out  is not 100.
The if + else structures can be concatenated with the intention of verifying a range of values.
The following example shows its use telling if the value currently stored in  is positive, negative or none of them (i_0_e.
Iteration structures (loops) Loops have as purpose to repeat a statement a certain number of times or while a condition is fulfilled.
The while loop Its format is: while (expression) statement and its functionality is simply to repeat statement while the condition set in expression is true.
For example, we are going to make a program to countdown using a while-loop: // custom countdown using while.
When the program starts the user is prompted to insert a starting number for the countdown.
Then the while loop begins, if the value entered by the user fulfills the condition n>0 (that n is greater than zero) the block that follows the condition will be executed and repeated while the condition (n>0) remains being true.
The whole process of the previous program can be interpreted according to the following script (beginning in main): TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 36 © cplusplus_0_com 2008.
All rights reserved 1.
User assigns a value to n 2.
The while condition is checked (n>0).
At this point there are two posibilities: * condition is true: statement is executed (to step 3) * condition is false: ignore statement and continue after it (to step 5) 3.
Execute statement: cout << n << ", "; minus_minusn; (prints the value of n on the screen and decreases n by 1) 4.
End of block.
Return automatically to step 2 5.
Continue the program right after the block: print FIRE.
When creating a while-loop, we must always consider that it has to end at some point, therefore we must provide within the block some method to force the condition to become false at some point, otherwise the loop will continue looping forever.
In this case we have included minus_minusn; that decreases the value of the variable that is being evaluated in the condition (n) by one - this will eventually make the condition (n>0) to become false after a certain number of loop iterations: to be more specific, when n becomes 0, that is where our while-loop and our countdown end.
Of course this is such a simple action for our computer that the whole countdown is performed instantly without any practical delay between numbers.
The do-while loop Its format is: do statement while (condition); Its functionality is exactly the same as the while loop, except that condition in the do-while loop is evaluated after the execution of statement instead of before, granting at least one execution of statement even if condition is never fulfilled.
For example, the following example program echoes any number you enter until you enter 0.
In fact if you never enter the value 0 in the previous example you can be prompted for more numbers forever.
The for loop Its format is: for (initialization; condition; increase) statement; TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 37 © cplusplus_0_com 2008.
All rights reserved and its main function is to repeat statement while condition remains true, like the while loop.
But in addition, the for loop provides specific locations to contain an initialization statement and an increase statement.
So this loop is specially designed to perform a repetitive action with a counter which is initialized and increased on each iteration.
It works in the following way: 1.
Generally it is an initial value setting for a counter variable.
This is executed only once.
If it is true the loop continues, otherwise the loop ends and statement is skipped (not executed).
As usual, it can be either a single statement or a block enclosed in braces { }.
Here is an example of countdown using a for loop: // countdown using a for loop.
The initialization and increase fields are optional.
They can remain empty, but in all cases the semicolon signs between them must be written.
For example we could write: for (;<10;) if we wanted to specify no initialization and no increase; or for (;<10;nplus_plus) if we wanted to  an increase field but no initialization (maybe because the variable was already initialized before).
Optionally, using the comma operator (,) we can specify more than one expression in any of the fields included in a for loop, like in initialization, for example.
The comma operator (,) is an expression separator, it serves to separate more than one expression where only one is generally expected.
For example, suppose that we wanted to initialize more than one variable in our loop: for ( =0, =100 ; _0_= ; nplus_plus, iminus_minus ) { // whatever here_0__0_.
Because  is increased by one and  decreased by one, the loop's condition will become false after the 50th loop, when both  and  will be equal to 50.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 38 © cplusplus_0_com 2008.
All rights reserved Jump statements.
The break statement Using break we can leave a loop even if the condition for its end is not fulfilled.
It can be used to end an infinite loop, or to force it to end before its natural end.
For example, we are going to stop the count down before its natural end (maybe because of an engine check failure_0_): // break loop example.
The continue statement The continue statement causes the program to skip the rest of the loop in the current iteration as if the end of the statement block had been reached, causing it to jump to the start of the following iteration.
For example, we are going to skip the number 5 in our countdown: // continue loop example.
The goto statement goto allows to make an absolute jump to another point in the program.
You should use this feature with caution since its execution causes an unconditional jump ignoring any type of nesting limitations.
The destination point is identified by a label, which is then used as an argument for the goto statement.
A label is made of a valid identifier followed by a colon (:).
Generally speaking, this instruction has no concrete use in structured or object oriented programming aside from those that low-level programming fans may find for it.
For example, here is our countdown loop using goto: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 39 © cplusplus_0_com 2008.
All rights reserved // goto loop example.
The exit function exit is a function defined in the cstdlib library.
The purpose of exit is to terminate the current program with a specific exit code.
Its prototype is: void exit (int exitcode); The exitcode is used by some operating systems and may be used by calling programs.
By convention, an exit code of 0 means that the program finished normally and any other value means that some error or unexpected results happened.
The selective structure: switch.
The syntax of the switch statement is a bit peculiar.
Its objective is to check several possible constant values for an expression.
Something similar to what we did at the beginning of this section with the concatenation of several if and else if instructions.
Its form is the following: switch (expression) { case constant1: group of statements 1; break; case constant2: group of statements 2; break;.
When it finds this break statement the program jumps to the end of the switch selective structure.
If expression was not equal to constant1 it will be checked against constant2.
If it is equal to this, it will execute group of statements 2 until a break keyword is found, and then will jump to the end of the switch selective structure.
Finally, if the value of expression did not match any of the previously specified constants (you can  as many case labels as values you want to check), the program will execute the statements included after the default: label, if it exists (since it is optional).
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 40 © cplusplus_0_com 2008.
All rights reserved Both of the following code fragments have the same behavior: switch example if-else equivalent switch () { case 1: cout << " is 1"; break; case 2: cout << " is 2"; break; default: cout << "value of  unknown"; }.
This forces us to put break statements after the group of statements that we want to be executed for a specific condition.
Otherwise the remainder statements -including those corresponding to other labels- will also be executed until the end of the switch selective block or a break statement is reached.
For example, if we did not  a break statement after the first group for case one, the program will not automatically jump to the end of the switch selective block and it would continue executing the rest of statements until it reaches either a break instruction or the end of the switch selective block.
This makes unnecessary to braces { } surrounding the statements for each of the cases, and it can also be useful to execute the same block of instructions for different possible values for the expression being evaluated.
For example: switch () { case 1: case 2: case 3: cout << " is 1, 2 or 3"; break; default: cout << " is not 1, 2 nor 3"; } Notice that switch can only be used to compare an expression against constants.
Therefore we cannot put variables as labels (for example case : where  is a variable) or ranges (case (1_0__0_3):) because they are not valid Cplus_plus constants.
If you need to check ranges or values that are not constants, use a concatenation of if and else if statements.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 41 © cplusplus_0_com 2008.
All rights reserved Functions (I) Using functions we can structure our programs in a more modular way, accessing all the potential that structured programming can offer to us in Cplus_plus.
A function is a group of statements that is executed when it is called from some point of the program.
The following is its format: type name ( parameter1, parameter2, _0__0__0_) { statements } where:.
They allow to pass arguments to the function when it is called.
The different parameters are separated by commas.
It is a block of statements surrounded by braces { }.
Here you have the first function example: // function example # <iostream>.
So we will begin there.
We can see how the main function begins by declaring the variable  of type int.
Right after that, we see a call to a function called addition.
Paying attention we will be able to see the similarity between the structure of the call to the function and the declaration of the function itself some code lines above: The parameters and arguments have a clear correspondence.
Within the main function we called to addition passing two values: 5 and 3, that correspond to the int a and int b parameters declared for function addition.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 42 © cplusplus_0_com 2008.
All rights reserved At the point at which the function is called from within main, the control is lost by main and passed to function addition.
The value of both arguments passed in the call (5 and 3) are copied to the local variables int a and int b within the function.
Function addition declares another local variable (int ), and by means of the expression =a+b, it assigns to the result of a plus b.
Because the actual parameters passed for a and b are 5 and 3 respectively, the result is 8.
The following line of code: return (); finalizes function addition, and returns the control back to the function that called it in the first place (in this case, main).
At this moment the program follows it regular course from the same point at which it was interrupted by the call to addition.
But additionally, because the return statement in function addition specified a value: the content of variable  (return ();), which at that moment had a value of 8.
This value becomes the value of evaluating the function call.
So being the value returned by a function the value given to the function call itself when it is evaluated, the variable  will be set to the value returned by addition (5, 3), that is 8.
To explain it another way, you can imagine that the call to a function (addition (5,3)) is literally replaced by the value it returns (8).
The following line of code in main is: cout << "The result is " << ; That, as you may already expect, produces the printing of the result on the screen.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 43 © cplusplus_0_com 2008.
All rights reserved Scope of variables The scope of variables declared within a function or any other inner block is only their own function or their own block and cannot be used outside of them.
For example, in the previous example it would have been impossible to use the variables a, b or  directly in function main since they were variables local to function addition.
Also, it would have been impossible to use the variable  directly within function addition, since this was a variable local to the function main.
Therefore, the scope of local variables is limited to the same block level in which they are declared.
Nevertheless, we also have the possibility to declare global variables; These are visible from any point of the code, inside and outside all functions.
In order to declare global variables you simply have to declare the variable outside any function or block; that means, directly in the body of the program.
And here is another example about functions: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 44 © cplusplus_0_com 2008.
All rights reserved // function example # <iostream>.
The only thing that this function does is to subtract both passed parameters and to return the result.
Nevertheless, if we examine function main we will see that we have made several calls to function subtraction.
We have used some different calling methods so that you see other ways or moments when a function can be called.
In order to fully understand these examples you must consider once again that a call to a function could be replaced by the value that the function call itself is going to return.
For example, the first case (that you should already know because it is the same pattern that we have used in previous examples): = subtraction (7,2); cout << "The first result is " << ; If we replace the function call by the value it returns (i_0_e_0_, 5), we would have: = 5; cout << "The first result is " << ; As well as cout << "The second result is " << subtraction (7,2); has the same result as the previous call, but in this case we made the call to subtraction directly as an insertion parameter for cout.
Simply consider that the result is the same as if we had written: cout << "The second result is " << 5; since 5 is the value returned by subtraction (7,2).
In the case of: cout << "The third result is " << subtraction (,); TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 45 © cplusplus_0_com 2008.
All rights reserved The only new  that we introduced is that the parameters of subtraction are variables instead of constants.
That is perfectly valid.
In this case the values passed to function subtraction are the values of  and , that are 5 and 3 respectively, giving 2 as result.
The fourth case is more of the same.
Simply note that instead of: = 4 + subtraction (,); we could have written: = subtraction (,) + 4; with exactly the same result.
I have switched places so you can see that the semicolon sign (;) goes at the end of the whole statement.
It does not necessarily have to go right after the function call.
The explanation might be once again that you imagine that a function can be replaced by its returned value: = 4 + 2; = 2 + 4; Functions with no type.
If you remember the syntax of a function declaration: type name ( argument1, argument2 _0__0__0_) statement you will see that the declaration begins with a type, that is the type of the function itself (i_0_e_0_, the type of the datum that will be returned by the function with the return statement).
But what if we want to return no value.
Imagine that we want to make a function just to show a message on the screen.
We do not need it to return any value.
In this case we should use the void type specifier for the function.
This is a special specifier that indicates absence of type.
For example, function printmessage could have been declared as: void printmessage (void) { cout << "I'm a function_0_"; } Although it is optional to specify void in the parameter list.
In Cplus_plus, a parameter list can simply be left blank if we want a function with no parameters.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 46 © cplusplus_0_com 2008.
All rights reserved What you must always remember is that the format for calling a function includes specifying its name and enclosing its parameters between parentheses.
The non-existence of parameters does not exempt us from the obligation to write the parentheses.
For that reason the call to printmessage is: printmessage (); The parentheses clearly indicate that this is a call to a function and not the name of a variable or some other Cplus_plus statement.
The following call would have been incorrect: printmessage; TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 47 © cplusplus_0_com 2008.
All rights reserved Functions (II) Arguments passed by value and by reference.
Until now, in all the functions we have seen, the arguments passed to the functions have been passed by value.
This means that when calling a function with parameters, what we have passed to the function were copies of their values but never the variables themselves.
For example, suppose that we called our first function addition using the following code: int =5, =3, ; = addition (  ,  ); What we did in this case was to call to function addition passing the values of  and , i_0_e.
This way, when the function addition is called, the value of its local variables a and b become 5 and 3 respectively, but any modification to either a or b within the function addition will not have any effect in the values of  and outside it, because variables  and  were not themselves passed to the function, but only copies of their values at the moment the function was called.
But there might be some cases where you need to manipulate from inside  function the value of an external variable.
For that purpose we can use arguments passed by reference, as in the function duplicate of the following example: // passing parameters by reference # <iostream>.
This ampersand is what specifies that their corresponding arguments are to be passed by reference instead of by value.
When  variable is passed by reference we are not passing  copy of its value, but we are somehow passing the variable itself to the function and any modification that we do to the local variables will have an effect in their counterpart variables passed as arguments in the call to the function.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 48 © cplusplus_0_com 2008.
All rights reserved To explain it in another way, we associate ,  and  with the arguments passed on the function call (,  and ) and any change that we do on  within the function will affect the value of  outside it.
Any change that we do on will affect , and the same with  and.
That is why our program's output, that shows the values stored in ,  and  after the call to duplicate, shows the values of all the three variables of main doubled.
If when declaring the following function: void duplicate (int& , int& , int& ) we had declared it this way: void duplicate (int , int , int ) i_0_e_0_, without the ampersand signs (&), we would have not passed the variables by reference, but  copy of their values instead, and therefore, the output on screen of our program would have been the values of ,  and without having been modified.
Passing by reference is also an effective way to allow  function to return more than one value.
For example, here is  function that returns the previous and  numbers of the first parameter passed.
When declaring  function we can specify  default value for each of the last parameters.
This value will be used if the corresponding argument is left blank when calling to the function.
To do that, we simply have to use the assignment operator and  value for the arguments in the function declaration.
If  value for that parameter is not passed when the function is called, the default value is used, but if  value is specified this default value is ignored and the passed value is used instead.
For example: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 49 © cplusplus_0_com 2008.
All rights reserved // default values in functions # <iostream>.
In the first one: divide (12) we have only specified one argument, but the function divide allows up to two.
So the function divide has assumed that the second parameter is 2 since that is what we have specified to happen if this parameter was not passed (notice the function declaration, which finishes with int =2, not just int ).
In the second call: divide (20,4) there are two parameters, so the default value for  (int =2) is ignored and  takes the value passed as argument, that is 4, making the result returned equal to 5 (20/4).
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 50 © cplusplus_0_com 2008.
All rights reserved Overloaded functions.
In Cplus_plus two different functions can have the same name if their parameter types or number are different.
That means that you can give the same name to more than one function if they have either  different number of parameters or different types in their parameters.
For example: // overloaded function # <iostream>.
The compiler knows which one to call in each case by examining the types passed as arguments when the function is called.
If it is called with two ints as its arguments it calls to the function that has two int parameters in its prototype and if it is called with two floats it will call to the one which has two float parameters in its prototype.
In the first call to operate the two arguments passed are of type int, therefore, the function with the first prototype is called; This function returns the result of multiplying both parameters.
While the second call passes two arguments of type float, so the function with the second prototype is called.
This one has a different behavior: it divides one parameter by the other.
So the behavior of a call to operate depends on the type of the arguments passed because the function has been overloaded.
Notice that a function cannot be overloaded only by its return type.
At least one of its parameters must have a different type.
The inline specifier indicates the compiler that inline substitution is preferred to the usual function call mechanism for a specific function.
This does not change the behavior of a function itself, but is used to suggest to the compiler that the code generated by the function body is inserted at each point the function is called, instead of being inserted only once and perform a regular call to it, which generally involves some additional overhead in running time.
The format for its declaration is: inline type name ( arguments _0__0_.
You do not have to  the inline keyword when calling the function, only in its declaration.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 51 © cplusplus_0_com 2008.
All rights reserved Most compilers already optimize code to generate inline functions when it is more convenient.
This specifier only indicates the compiler that inline is preferred for this function.
Recursivity is the property that functions have to be called by themselves.
It is useful for many tasks, like sorting or calculate the factorial of numbers.
For example, to obtain the factorial of a number (_0_) the mathematical formula would be: =  * (-1) * (-2) * (-3) _0__0_.
This function has a limitation because of the data type we used in its design (long) for more simplicity.
The results given will not be valid for values much greater than 10.
Until now, we have defined all of the functions before the first appearance of calls to them in the source code.
These calls were generally in function main which we have always left at the end of the source code.
If you try to repeat some of the examples of functions described so far, but placing the function main before any of the other functions that were called from within it, you will most likely obtain compiling errors.
The reason is that to be able to call a function it must have been declared in some earlier point of the code, like we have done in all our examples.
But there is an alternative way to avoid writing the whole code of a function before it can be used in main or in some other function.
This can be achieved by declaring just a prototype of the function before it is used, instead of the entire definition.
This declaration is shorter than the entire definition, but significant enough for the compiler to determine its return type and the types of its parameters.
Its form is: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 52 © cplusplus_0_com 2008.
All rights reserved type name ( argument_type1, argument_type2, _0__0__0_); It is identical to a function definition, except that it does not  the body of the function itself (i_0_e_0_, the function statements that in normal definitions are enclosed in braces { }) and instead of that we end the prototype declaration with a mandatory semicolon (;).
The parameter enumeration does not need to  the identifiers, but only the type specifiers.
The inclusion of a name for each parameter as in the function definition is optional in the prototype declaration.
For example, we can declare a function called protofunction with two int parameters with any of the following declarations: int protofunction (int first, int second); int protofunction (int, int); Anyway, including a name for each variable makes the prototype more legible.
Type   (0 to exit): 6 Number is even.
Type   (0 to exit): 1030 Number is even.
Type   (0 to exit): 0 Number is even.
This example is indeed not an example of efficiency.
I am sure that at this point you can already make  program with the same result, but using only half of the code lines that have been used in this example.
Anyway this example illustrates how prototyping works.
Moreover, in this concrete example the prototyping of at least one of the two functions is necessary in order to compile the code without errors.
The first things that we see are the declaration of functions odd and even: void odd (int ); void even (int ); This allows these functions to be used before they are defined, for example, in main, which now is located where some people find it to be  more logical place for the start of  program: the beginning of the source code.
Anyway, the reason why this program needs at least one of the functions to be declared before it is defined is because in odd there is  call to even and in even there is  call to odd.
If none of the two functions had been TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 53 © cplusplus_0_com 2008.
All rights reserved previously declared,  compilation error would happen, since either odd would not not be visible from even (because it has still not been declared), or even would not be visible from odd (for the same reason).
Having the prototype of all functions together in the same place within the source code is found practical by some programmers, and this can be easily achieved by declaring all functions prototypes at the beginning of  program.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 54 © cplusplus_0_com 2008.
All rights reserved Compound data types Arrays An array is  series of elements of the same type placed in contiguous memory locations that can be individually referenced by adding an index to  unique identifier.
That means that, for example, we can store 5 values of type int in an array without having to declare 5 different variables, each one with  different identifier.
Instead of that, using an array we can store 5 different values of the same type, int for example, with  unique identifier.
For example, an array to contain 5 integer values of type int called billy could be represented like this: where each blank panel represents an element of the array, that in this case are integer values of type int.
These elements are numbered from 0 to 4 since in arrays the first index is always 0, independently of its length.
Like  regular variable, an array must be declared before it is used.
A typical declaration for an array in Cplus_plus is: type name [elements]; where type is  valid type (like int, float_0__0__0_), name is  valid identifier and the elements field (which is always enclosed in square brackets []), specifies how many of these elements the array has to contain.
Therefore, in order to declare an array called billy as the one shown in the above diagram it is as simple as: int billy [5]; NOTE: The elements field within brackets [] which represents the number of elements the array is going to hold, must be  constant value, since arrays are blocks of non-dynamic memory whose size must be determined before execution.
In order to create arrays with  variable length dynamic memory is needed, which is explained later in these tutorials.
When declaring  regular array of local scope (within  function, for example), if we do not specify otherwise, its elements will not be initialized to any value by default, so their content will be undetermined until we store some value in them.
The elements of global and static arrays, on the other hand, are automatically initialized with their default values, which for all fundamental types this means they are filled with zeros.
In both cases, local and global, when we declare an array, we have the possibility to assign initial values to each one of its elements by enclosing the values in braces { }.
For example: int  [5] = { 16, 2, 77, 40, 12071 }; This declaration would have created an array like this: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 55 © cplusplus_0_com 2008.
All rights reserved The amount of values between braces { } must not be larger than the number of elements that we declare for the array between square brackets [ ].
For example, in the example of array  we have declared that it has 5 elements and in the list of initial values within braces { } we have specified 5 values, one for each element.
When an initialization of values is provided for an array, Cplus_plus allows the possibility of leaving the square brackets empty [ ].
In this case, the compiler will assume  size for the array that matches the number of values included between braces { }: int  [] = { 16, 2, 77, 40, 12071 }; After this declaration, array  would be 5 ints long, since we have provided 5 initialization values.
Accessing the values of an array.
In any point of  program in which an array is visible, we can access the value of any of its elements individually as if it was  normal variable, thus being able to both read and modify its value.
The format is as simple as: name[index] Following the previous examples in which  had 5 elements and each of those elements was of type int, the name which we can use to refer to each element is the following: For example, to store the value 75 in the third element of , we could write the following statement: [2] = 75; and, for example, to pass the value of the third element of  to  variable called , we could write: = [2]; Therefore, the expression [2] is for all purposes like  variable of type int.
Notice that the third element of  is specified [2], since the first one is [0], the second one is [1], and therefore, the third one is [2].
By this same reason, its last element is [4].
Therefore, if we write [5], we would be accessing the sixth element of  and therefore exceeding the size of the array.
In Cplus_plus it is syntactically correct to exceed the valid range of indices for an array.
This can create problems, since accessing out-of-range elements do not cause compilation errors but can cause runtime errors.
The reason why this is allowed will be seen further ahead when we begin to use pointers.
At this point it is important to be able to clearly distinguish between the two uses that brackets [ ] have related to arrays.
They perform two different tasks: one is to specify the size of arrays when they are declared; and the second one is to specify indices for concrete  elements.
Do not confuse these two possible uses of brackets [ ] with arrays.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 56 © cplusplus_0_com 2008.
All rights reserved int [5];         // declaration of  new [2] = 75;        // access to an element of the.
If you read carefully, you will see that  type specifier always precedes  variable or  declaration, while it never precedes an access.
Some other valid operations with arrays: [0] = ; [] = 75; =  [+2]; [[]] = [2] + 5; // arrays example.
For example,  bidimensional  can be imagined as  bidimensional table made of elements, all of them of  same uniform data type.
The way to declare this  in Cplus_plus would be: int jimmy [3][5]; and, for example, the way to reference the second element vertically and fourth horizontally in an expression would be: jimmy[1][3] TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 57 © cplusplus_0_com 2008.
All rights reserved (remember that  indices always begin by zero).
Multidimensional arrays are not limited to two indices (i_0_e_0_, two dimensions).
They can contain as many indices as needed.
The amount of memory needed for an  rapidly increases with each dimension.
For example: char century [100][365][24][60][60]; declares an  with  char element for each second in  century, that is more than 3 billion chars.
So this declaration would consume more than 3 gigabytes of memory.
Multidimensional arrays are just an abstraction for programmers, since we can obtain the same results with simple  just by putting  factor between its indices: int  [3][5];   // is equivalent to int  [15];     // (3 * 5 = 15) With the only difference that with multidimensional arrays the compiler remembers the depth of each imaginary dimension for us.
Take as example these two pieces of code, with both exactly the same.
One uses bidimensional  and the other one uses  simple : multidimensional pseudo-multidimensional #define WIDTH 5 #define HEIGHT 3 int  [HEIGHT][WIDTH]; int ,; int main () {.
All rights reserved We have used "defined constants" (#define) to simplify possible future modifications of the program.
For example, in case that we decided to enlarge the  to  height of 4 instead of 3 it could be done simply by changing the line: #define HEIGHT 3 to: #define HEIGHT 4 with no need to make any other modifications to the program.
Arrays as parameters At some moment we may need to pass an  to  function as  parameter.
In Cplus_plus it is not possible to pass complete block of memory by value as  parameter to  function, but we are allowed to pass its address.
In practice this has almost the same effect and it is  much faster and more efficient operation.
In order to accept arrays as parameters the only thing that we have to do when declaring the function is to specify in its parameters the element type of the array, an identifier and  pair of void brackets [].
For example, the following function: void procedure (int arg[]) accepts  parameter of type "array of int" called arg.
In order to pass to this function an array declared as: int myarray [40]; it would be enough to write  call like this: procedure (myarray); Here you have  complete example: // arrays as parameters.
For that reason we have included a second parameter that tells the function the length of each array that TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 59 © cplusplus_0_com 2008.
All rights reserved we pass to it as its first parameter.
This allows the for loop that prints out the array to know the range to iterate in the passed array without going out of range.
In a function declaration it is also possible to  multidimensional arrays.
The format for a tridimensional array parameter is: base_type[][depth][depth] for example, a function with a multidimensional array as argument could be: void procedure (int myarray[][3][4]) Notice that the first brackets [] are left blank while the following ones are not.
This is so because the compiler must be able to determine within the function which is the depth of each additional dimension.
Arrays, both simple or multidimensional, passed as function parameters are a quite common source of errors for novice programmers.
I recommend the reading of the chapter about Pointers for a better understanding on how arrays operate.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 60 © cplusplus_0_com 2008.
All rights reserved Character Sequences As you may already know, the Cplus_plus Standard Library implements a powerful string class, which is very useful to handle and manipulate strings of characters.
However, because strings are in fact sequences of characters, we can represent them also as plain arrays of char elements.
For example, the following array: char jenny [20]; is an array that can store up to 20 elements of type char.
It can be represented as: Therefore, in this array, in theory, we can store sequences of characters up to 20 characters long.
But we can also store shorter sequences.
For example, jenny could store at some point in a program either the sequence "Hello" or the sequence "Merry christmas", since both are shorter than 20 characters.
Therefore, since the array of characters can store shorter sequences than its total length, a special character is used to signal the end of the valid sequence: the null character, whose literal constant can be written as '\0' (backslash, zero).
Our array of 20 elements of type char, called jenny, can be represented storing the characters sequences "Hello" and "Merry Christmas" as: Notice how after the valid content a null character ('\0') has been included in order to indicate the end of the sequence.
The panels in gray color represent char elements with undetermined values.
Initialization of null-terminated character sequences Because arrays of characters are ordinary arrays they follow all their same rules.
For example, if we want to initialize an array of characters with some predetermined sequence of characters we can do it just like any other array: char [] = { 'H', 'e', 'l', 'l', 'o', '\0' }; In this case we would have declared an array of 6 elements of type char initialized with the characters that form the word "Hello" plus a null character '\0' at the end.
But arrays of char elements have an additional method to initialize their values: using string literals.
In the expressions we have used in some examples in previous chapters, constants that represent entire strings of characters have already showed up several times.
These are specified enclosing the text to become a string literal between double quotes (").
For example: "the result is: " TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 61 © cplusplus_0_com 2008.
All rights reserved is a constant string literal that we have probably used already.
Double quoted strings (") are literal constants whose type is in fact a null-terminated array of characters.
So string literals enclosed between double quotes always have a null character ('\0') automatically appended at the end.
Therefore we can initialize the array of char elements called  with a null-terminated sequence of characters by either one of these two methods: char  [] = { 'H', 'e', 'l', 'l', 'o', '\0' }; char  [] = "Hello"; In both cases the array of characters  is declared with a size of 6 elements of type char: the 5 characters that compose the word "Hello" plus a final null character ('\0') which specifies the end of the sequence and that, in the second case, when using double quotes (") it is appended automatically.
Please notice that we are talking about initializing an array of characters in the moment it is being declared, and not about assigning values to them once they have already been declared.
In fact because this type of nullterminated arrays of characters are regular arrays we have the same restrictions that we have with any other array, so we are not able to copy blocks of data with an assignment operation.
Assuming  is a char[] variable, expressions within a source code like: = "Hello"; [] = "Hello"; would not be valid, like neither would be: = { 'H', 'e', 'l', 'l', 'o', '\0' }; The reason for this may become more comprehensible once you know a bit more about pointers, since then it will be clarified that an array is in fact a constant pointer pointing to a block of memory.
Using null-terminated sequences of characters Null-terminated sequences of characters are the natural way of treating strings in Cplus_plus, so they can be used as such in many procedures.
In fact, regular string literals have this type (char[]) and can also be used in most cases.
For example, cin and cout support null-terminated sequences as valid containers for sequences of characters, so they can be used directly to extract strings of characters from cin or to insert them into cout.
For example: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 62 © cplusplus_0_com 2008.
All rights reserved // null-terminated sequences of characters.
As you can see, we have declared three arrays of char elements.
The first two were initialized with string literal constants, while the third one was left uninitialized.
In any case, we have to speficify the size of the array: in the first two ( and ) the size was implicitly defined by the length of the literal constant they were initialized to.
While for yourname we have explicitly specified that it has a size of 80 chars.
Finally, sequences of characters stored in char arrays can easily be converted into string objects just by using the assignment operator: string ; char []="some text"; = ; TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 63 © cplusplus_0_com 2008.
All rights reserved Pointers We have already seen how variables are seen as memory cells that can be accessed using their identifiers.
This way we did not have to care about the physical location of our data within memory, we simply used its identifier whenever we wanted to refer to our variable.
The memory of your computer can be imagined as a succession of memory cells, each one of the minimal size that computers manage (one byte).
These single-byte memory cells are numbered in a consecutive way, so as, within any block of memory, every cell has the same number as the previous one plus one.
This way, each cell can be easily located in the memory because it has a unique address and all the memory cells follow a successive pattern.
For example, if we are looking for cell 1776 we know that it is going to be right between cells 1775 and 1777, exactly one thousand cells after 776 and exactly one thousand cells before cell 2776.
Reference operator (&) As soon as we declare a variable, the amount of memory needed is assigned for it at a specific location in memory (its memory address).
We generally do not actively decide the exact location of the variable within the panel of cells that we have imagined the memory to be - Fortunately, that is a task automatically performed by the operating system during runtime.
However, in some cases we may be interested in knowing the address where our variable is being stored during runtime in order to operate with relative positions to it.
The address that locates a variable within memory is what we call a reference to that variable.
This reference to a variable can be obtained by preceding the identifier of a variable with an ampersand sign (&), known as reference operator, and which can be literally translated as "address of".
For example: = &; This would assign to  the address of variable , since when preceding the name of the variable  with the reference operator (&) we are no longer talking about the content of the variable itself, but about its reference (i_0_e_0_, its address in memory).
From now on we are going to assume that  is placed during runtime in the memory address 1776.
This number (1776) is just an arbitrary assumption we are inventing right now in order to help clarify some concepts in this tutorial, but in reality, we cannot know before runtime the real value the address of a variable will have in memory.
Consider the following code fragment: = 25; = ; = &; The values contained in each variable after the execution of this, are shown in the following diagram: First, we have assigned the value 25 to  (a variable whose address in memory we have assumed to be 1776).
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 64 © cplusplus_0_com 2008.
All rights reserved The second statement copied to  the content of variable  (which is 25).
This is a standard assignment operation, as we have done so many times before.
Finally, the third statement copies to  not the value contained in  but a reference to it (i_0_e_0_, its address, which we have assumed to be 1776).
The reason is that in this third assignment operation we have preceded the identifier  with the reference operator (&), so we were no longer referring to the value of  but to its reference (its address in memory).
The variable that stores the reference to another variable (like  in the previous example) is what we call a pointer.
Pointers are a very powerful feature of the Cplus_plus language that has many uses in advanced programming.
Farther ahead, we will see how this type of variable is used and declared.
Dereference operator (*) We have just seen that a variable which stores a reference to another variable is called a pointer.
Pointers are said to "point to" the variable whose reference they store.
Using a pointer we can directly access the value stored in the variable which it points to.
To do this, we simply have to precede the pointer's identifier with an asterisk (*), which acts as dereference operator and that can be literally translated to "value pointed by".
Therefore, following with the values of the previous example, if we write: = *; (that we could read as: " equal to value pointed by ")  would take the value 25, since  is 1776, and the value pointed by 1776 is 25.
You must clearly differentiate that the expression  refers to the value 1776, while * (with an asterisk * preceding the identifier) refers to the value stored at address 1776, which in this case is 25.
Notice the difference of including or not including the dereference operator (I have included an explanatory commentary of how each of these two expressions could be read): = ;   //  equal to  ( 1776 ) = *;  //  equal to value pointed by  ( 25 ) Notice the difference between the reference and dereference operators:.
All rights reserved Thus, they have complementary (or opposite) meanings.
A variable referenced with & can be dereferenced with *.
Earlier we performed the following two assignment operations: = 25; = &; Right after these two statements, all of the following expressions would give true as result: == 25 & == 1776 == 1776 * == 25 The first expression is quite clear considering that the assignment operation performed on  was =25.
The second one uses the reference operator (&), which returns the address of variable , which we assumed it to have a value of 1776.
The third one is somewhat obvious since the second expression was true and the assignment operation performed on  was =&.
The fourth expression uses the dereference operator (*) that, as we have just seen, can be read as "value pointed by", and the value pointed by  is indeed 25.
So, after all that, you may also infer that for as long as the address pointed by  remains unchanged the following expression will also be true: * == Declaring variables of pointer types Due to the ability of a pointer to directly refer to the value that it points to, it becomes necessary to specify in its declaration which data type a pointer is going to point to.
It is not the same thing to point to a char as to point to an int or a float.
The declaration of pointers follows this format: type * name; where type is the data type of the value that the pointer is intended to point to.
This type is not the type of the pointer itself.
For example: int * number; char * character; float * greatnumber; These are three declarations of pointers.
Each one is intended to point to a different data type, but in fact all of them are pointers and all of them will occupy the same amount of space in memory (the size in memory of a pointer depends on the platform where the code is going to run).
Nevertheless, the data to which they point to do not occupy the same amount of space nor are of the same type: the first one points to an int, the second one to a char and the last one to a float.
Therefore, although these three example variables are all of them pointers which occupy the same size in memory, they are said to have different types: int*, char* and float* respectively, depending on the type they point to.
I want to emphasize that the asterisk sign (*) that we use when declaring a pointer only means that it is a pointer (it is part of its type compound specifier), and should not be confused with the dereference operator that we have seen a bit earlier, but which is also written with an asterisk (*).
They are simply two different things represented with the same sign.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 66 © cplusplus_0_com 2008.
All rights reserved Now have a look at this code: // my first pointer.
This is the procedure: First, we have assigned as value of  a reference to firstvalue using the reference operator (&).
And then we have assigned the value 10 to the memory location pointed by , that because at this moment is pointing to the memory location of , this in fact modifies the value of.
In order to demonstrate that a pointer may take several different values during the same program I have repeated the process with  and that same pointer,.
Here is an example a little bit more elaborated: // more pointers.
Notice that there are expressions with pointers 1 and 2, both with and without dereference operator (*).
The meaning of an expression using the dereference operator (*) is very different from one that does not: When this operator precedes the pointer name, the expression refers to the value being pointed, while when a pointer name appears without this operator, it refers to the value of the pointer itself (i_0_e.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 67 © cplusplus_0_com 2008.
All rights reserved Another thing that may call your attention is the line: int * 1, * 2; This declares the two pointers used in the previous example.
But notice that there is an asterisk (*) for each pointer, in order for both to have type int* (pointer to int).
Otherwise, the type for the second variable declared in that line would have been int (and not int*) because of precedence relationships.
If we had written: int * 1, 2; 1 would indeed have int* type, but 2 would have type int (spaces do not matter at all for this purpose).
This is due to operator precedence rules.
But anyway, simply remembering that you have to put one asterisk per pointer is enough for most pointer users.
Pointers and arrays The concept of array is very much bound to the one of pointer.
In fact, the identifier of an array is equivalent to the address of its first element, as a pointer is equivalent to the address of the first element that it points to, so in fact they are the same concept.
For example, supposing these two declarations: int  [20]; int * ; The following assignment operation would be valid: = ; After that,  and  would be equivalent and would have the same properties.
The only difference is that we could change the value of pointer  by another one, whereas  will always point to the first of the 20 elements of type int with which it was defined.
Therefore, unlike , which is an ordinary pointer,  is an array, and an array can be considered a constant pointer.
Therefore, the following allocation would not be valid: = ; Because  is an array, so it operates as a constant pointer, and we cannot assign values to constants.
Due to the characteristics of variables, all expressions that  pointers in the following example are perfectly valid: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 68 © cplusplus_0_com 2008.
All rights reserved // more pointers.
Well, these bracket sign operators [] are also  dereference operator known as offset operator.
They dereference the variable they follow just as * does, but they also add the number between brackets to the address being dereferenced.
For example: [5] = 0;       //  [offset  5] = 0 *(+5) = 0;     // pointed by (+5) = 0 These two expressions are equivalent and valid both if  is  pointer or if  is an array.
Pointer initialization When declaring pointers we may want to explicitly specify which variable we want them to point to: int number; int * = &number; The behavior  this code is equivalent to: int number; int *; = &number; When  pointer initialization takes place we are always assigning the reference value to where the pointer points (), never the value being pointed (*).
You must consider that at the moment  declaring  pointer, the asterisk (*) indicates only that it is  pointer, it is not the dereference operator (although both use the same sign: *).
Remember, they are two different functions  one sign.
Thus, we must take care not to confuse the previous code with: int number; int *; * = &number; that is incorrect, and anyway would not have much sense in this case if you think about it.
As in the case  arrays, the compiler allows the special case that we want to initialize the content at which the pointer points with constants at the same moment the pointer is declared: char *  = "hello"; TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 69 © cplusplus_0_com 2008.
All rights reserved In this case, memory space is reserved to contain "hello" and then  pointer to the first character  this memory block is assigned to.
If we imagine that "hello" is stored at the memory locations that start at addresses 1702, we can represent the previous declaration as: It is important to indicate that  contains the value 1702, and not 'h' nor "hello", although 1702 indeed is the address  both  these.
The pointer  points to  sequence  characters and can be read as if it was an array (remember that an array is just like  constant pointer).
For example, we can access the fifth element  the array with any  these two expression: *(+4) [4] Both expressions have  value  'o' (the fifth element  the array).
Pointer arithmetics To conduct arithmetical operations on pointers is  little different than to conduct them on regular integer data types.
To begin with, only addition and subtraction operations are allowed to be conducted with them, the others make no sense in the world  pointers.
But both addition and subtraction have  different behavior with pointers according to the size  the data type to which they point.
When we saw the different fundamental data types, we saw that some occupy more or less space than others in the memory.
For example, let's assume that in  given compiler for  specific machine, char takes 1 byte, short takes 2 bytes and long takes 4.
Suppose that we define three pointers in this compiler: char *mychar; short *myshort; long *mylong; and that we know that they point to memory locations 1000, 2000 and 3000 respectively.
So if we write: mycharplus_plus; myshortplus_plus; mylongplus_plus; mychar, as you may expect, would contain the value 1001.
But not so obviously, myshort would contain the value 2002, and mylong would contain 3004, even though they have each been increased only once.
The reason is that when adding one to  pointer we are making it to point to the following element  the same type with which it has been defined, and therefore the size in bytes  the type pointed is added to the pointer.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 70 © cplusplus_0_com 2008.
All rights reserved This is applicable both when adding and subtracting any number to  pointer.
It would happen exactly the same if we write: =  + 1; =  + 1; =  + 1; Both the increase (plus_plus) and decrease (minus_minus) operators have greater operator precedence than the dereference operator (*), but both have  special behavior when used as suffix (the expression is evaluated with the value it had before being increased).
Therefore, the following expression may lead to confusion: * Because plus_plus has greater precedence than *, this expression is equivalent to *().
Therefore, what it does is to increase the value   (so it now points to the next element), but because plus_plus is used as postfix the whole expression is evaluated as the value pointed by the original reference (the address the pointer pointed to before being increased).
Notice the difference with: (*)plus_plus Here, the expression would have been evaluated as the value pointed by  increased by one.
The value   (the pointer itself) would not be modified (what is being modified is what it is being pointed to by this pointer).
If we write: * = *qplus_plus; Because plus_plus has  higher precedence than *, both  and q are increased, but because both increase operators (plus_plus) are used as postfix and not prefix, the value assigned to * is *q before both  and q are increased.
It would be roughly equivalent to: * = *q; plus_plusp; plus_plusq; Like always, I recommend you to use parentheses () in order to avoid unexpected results and to give more legibility to the code.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 71 © cplusplus_0_com 2008.
All rights reserved Pointers to pointers Cplus_plus allows the use of pointers that point to pointers, that these, in its turn, point to data (or even to other pointers).
In order to do that, we only need to add an asterisk (*) for each level of reference in their declarations: char ; char * ; char ** ; = 'z'; = &; = &; This, supposing the randomly chosen memory locations for each variable of 7230, 8092 and 10502, could be represented as: The value of each variable is written inside each cell; under the cells are their respective addresses in memory.
The new  in this example is variable , which can be used in three different levels of indirection, each one of them would correspond to  different value:.
In Cplus_plus, void represents the absence of type, so void pointers are pointers that point to  value that has no type (and thus also an undetermined length and undetermined dereference properties).
This allows void pointers to point to any data type, from an integer value or  float to  string of characters.
But in exchange they have  great limitation: the data pointed by them cannot be directly dereferenced (which is logical, since we have no type to dereference to), and for that reason we will always have to cast the address in the void pointer to some other pointer type that points to  concrete data type before dereferencing it.
One of its uses may be to pass generic parameters to  function: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 72 © cplusplus_0_com 2008.
All rights reserved // increaser # <iostream>.
For nondynamic data types this value is  constant.
Therefore, for example, sizeof(char) is 1, because char type is one byte long.
Null pointer A null pointer is  regular pointer of any pointer type which has  special value that indicates that it is not pointing to any valid reference or memory address.
This value is the result of type-casting the integer value zero to any pointer type.
A null pointer is  value that any pointer may take to represent that it is pointing to "nowhere", while  void pointer is  special type of pointer that can point to somewhere without  specific type.
One refers to the value stored in the pointer itself and the other to the type of data it points to.
Pointers to functions Cplus_plus allows operations with pointers to functions.
The typical use of this is for passing  function as an argument to another function, since these cannot be passed dereferenced.
In order to declare  pointer to  function we have to declare it like the prototype of the function except that the name of the function is enclosed between parentheses () and an asterisk (*) is inserted before the name: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 73 © cplusplus_0_com 2008.
All rights reserved // pointer to functions # <iostream>.
It is immediately assigned to point to the function subtraction, all in  single line: (* minus)(,) = subtraction; TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 74 © cplusplus_0_com 2008.
All rights reserved Dynamic Memory Until now, in all our programs, we have only had as much memory available as we declared for our variables, having the size of all of them to be determined in the source code, before the execution of the program.
But, what if we need  variable amount of memory that can only be determined during runtime.
For example, in the case that we need some user input to determine the necessary amount of memory space.
The answer  dynamic memory, for which Cplus_plus integrates the operators   delete.
Operators   [] In order to request dynamic memory we use the operator.
It returns   to the beginning of the   of memory allocated.
Its form : = =   [number_of_elements] The first expression  used to allocate memory to contain one single element of.
The second one  used to assign   (an array) of elements of  , where number_of_elements  an integer value representing the amount of these.
For example: * ; =   [5]; In this case, the system dynamically assigns space for five elements of    returns   to the first element of the sequence, which  assigned to.
Therefore, now,  points to  valid  of memory with space for five elements of.
The first element pointed by  can be accessed either with the expression [0] or the expression *.
Both are equivalent as has been explained in the section about pointers.
The second element can be accessed either with [1] or *(+1)  so on_0__0_.
You could be wondering the difference between declaring  normal array  assigning dynamic memory to , as we have just done.
The most important difference  that the size of an array has to be  constant value, which limits its size to what we decide at the moment of designing the program, before its execution, whereas the dynamic memory allocation allows us to assign memory during the execution of the program (runtime) using any variable or constant value as its size.
The dynamic memory requested by our program  allocated by the system from the memory heap.
However, computer memory   limited resource,  it can be exhausted.
Therefore, it  important to have some mechanism to check if our request to allocate memory was successful or not.
Cplus_plus provides two standard methods to check if the allocation was successful: One  by handling exceptions.
Using this method an exception of  bad_alloc  thrown when the allocation fails.
Exceptions are  powerful Cplus_plus feature explained later in these tutorials.
But for now you should know that if this exception  thrown  it  not handled by  specific handler, the program execution  terminated.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 75 © cplusplus_0_com 2008.
All rights reserved This exception method  the default method used by ,   the one used in a declaration like: =   [5];  // if it fails an exception  thrown The other method  known  ,  what happens when it  used  that when a memory allocation fails, instead of throwing a bad_alloc exception or terminating the program, the  returned by   a null ,  the program continues its execution.
This method can be specified by using a special object called , declared in header <>,  argument for : =  ()  [5]; In this case, if the allocation of this  of memory failed, the failure could be detected by checking if  took a null  value: * ; =  ()  [5]; if ( == 0) { // error assigning memory.
Anyway this method can become tedious for larger projects, where the exception method  generally preferred.
The exception method will be explained in detail later in this tutorial.
Operators delete  delete[] Since the necessity of dynamic memory  usually limited to specific moments within a program, once it  no longer needed it should be freed so that the memory becomes available again for other requests of dynamic memory.
This  the purpose of the operator delete, whose format : delete ; delete [] ; The first expression should be used to delete memory allocated for a single element,  the second one for memory allocated for arrays of elements.
The value passed  argument to delete must be either a  to a memory  previously allocated with , or a null  (in the case of a null , delete produces no effect).
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 76 © cplusplus_0_com 2008.
All rights reserved.
For example, when I tried to give a value of 1 billion to the "How many numbers" question, my system could not allocate that much memory for the program  I got the text message we prepared for this case (Error: memory could not be allocated).
Remember that in the case that we tried to allocate the memory without specifying the  parameter in the , an exception would be thrown, which if it's not handled terminates the program.
It  a good practice to always check if a dynamic memory block was successfully allocated.
Therefore, if you use the  method, you should always check the value of the pointer returned.
Otherwise, use the exception method, even if you do not handle the exception.
This way, the program will terminate at that point without causing the unexpected results of continuing executing a code that assumes a block of memory to have been allocated when in fact it has not.
Dynamic memory in ANSI-C Operators   delete are exclusive of Cplus_plus.
But using pure C language  its library, dynamic memory can also be used through the functions malloc, calloc, realloc  free, which are also available in Cplus_plus including the <cstdlib> header file (see cstdlib for more info).
The memory blocks allocated by these functions are not necessarily compatible with those returned by , each one should be manipulated with its own set of functions or operators.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 77 © cplusplus_0_com 2008.
All rights reserved Data structures We have already learned how groups of sequential data can be used in Cplus_plus.
But this  somewhat restrictive, since in many occasions what we want to store are not mere sequences of elements all of the same data type, but sets of different elements with different data types.
Data structures A data structure  a group of data elements grouped together under one name.
These data elements, known members, can have different types  different lengths.
Data structures are declared in Cplus_plus using the following syntax: struct structure_name { member_type1 member_name1; member_type2 member_name2; member_type3 member_name3;.
Within braces { } there is a list with the data members, each one is specified with a   a valid identifier as its name.
The first thing we have to know is that a data structure creates a  : Once a data structure is declared, a with the identifier specified as structure_name is created  can be used in the rest of the program as if it was any other.
For example: struct product { int weight; float price; } ; product apple; product banana, melon; We have first declared a structure  called product with two members: weight  price, each of a different fundamental.
We have then used this name of the structure  (product) to declare three objects of that : apple, banana  melon as we would have done with any fundamental data.
Once declared, product has become a    name like the fundamental ones int, char or short from that point on we are able to declare objects (variables) of this compound  , like we have done with apple, banana  melon.
Right at the end of the struct declaration,  before the ending semicolon, we can use the optional field object_name to directly declare objects of the structure.
For example, we can also declare the structure objects apple, banana  melon at the moment we define the data structure  this way: struct product { int weight; float price; } apple, banana, melon; It is important to clearly differentiate between what is the structure  name,  what is an object (variable) that has this structure.
We can instantiate many objects (i_0_e.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 78 © cplusplus_0_com 2008.
All rights reserved Once we have declared our three objects of a determined structure  (apple, banana  melon) we can operate directly with their members.
To do that we use a dot (_0_) inserted between the object name  the member name.
For example, we could operate with any of these elements as if they were standard variables of their respective types: apple_0_weight apple_0_price banana_0_weight banana_0_price melon_0_weight melon_0_price Each one of these has the data  corresponding to the member they refer to: apple_0_weight, banana_0_weight melon_0_weight are of  int, while apple_0_price, banana_0_price  melon_0_price are of  float.
Let's see a real example where you can see how a structure  can be used in the same way as fundamental types:.
For example, the member yours.
The objects mine and yours can also be treated as  variables of  movies_t, for example we have passed them to the function printmovie as we would have done with regular variables.
Therefore, one of the most important advantages of data structures is that we can either refer to their members individually or to the entire structure as a block with only one identifier.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 79 © cplusplus_0_com 2008.
All rights reserved Data structures are a feature that can be used to represent databases, especially if we consider the possibility of building arrays of them:.
So, the following code would also be valid: = &amovie; The value of the pointer  would be assigned to a reference to the object amovie (its memory address).
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 80 © cplusplus_0_com 2008.
All rights reserved We will now go with another example that includes pointers, which will serve to introduce a new : the arrow  (arrow_operator):.
This is a dereference  that is used exclusively with pointers to objects with members.
This  serves to access a member of an object to which we have a reference.
In the example we used: pmoviearrow_operatortitle Which is for all purposes equivalent to: (*)_0_title Both expressions pmoviearrow_operatortitle and (*)_0_title are valid and both mean that we are evaluating the member title of the data structure pointed by a pointer called.
It must be clearly differentiated from: *_0_title which is equivalent to: *(_0_title) And that would access the value pointed by a hypothetical pointer member called title of the structure object (which in this case would not be a pointer).
The following panel summarizes possible combinations of pointers and structure members: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 81 © cplusplus_0_com 2008.
All rights reserved Expression What is evaluated Equivalent a_0_b Member b of object a aarrow_operatorb Member b of object pointed by a (*a)_0_b *a_0_b Value pointed by member b of object a *(a_0_b) Nesting structures Structures can also be nested so that a valid element of a structure can also be in its turn another structure.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 82 © cplusplus_0_com 2008.
All rights reserved Other Data Types Defined data types (typedef) Cplus_plus allows the definition of our own types based on other existing data types.
We can do this using the keyword typedef, whose format is: typedef existing_type new_type_name ; where existing_type is a Cplus_plus fundamental or compound  and new_type_name is the name for the new we are defining.
For example: typedef char C; typedef unsigned int WORD; typedef char * pChar; typedef char field [50]; In this case we have defined four data types: C, WORD, pChar and field as char, unsigned int, char* and char[50] respectively, that we could perfectly use in declarations later as any other valid : C mychar, anotherchar, *ptc1; WORD myword; pChar ptc2; field name; typedef does not create different types.
It only creates synonyms of existing types.
That means that the  of myword can be considered to be either WORD or unsigned int, since both are in fact the same.
It is also useful to define types when it is possible that we will need to change the  in later versions of our program, or if a you want to use has a name that is too long or confusing.
Unions Unions allow one same portion of memory to be accessed as different data types, since all of them are in fact the same location in memory.
Its declaration and use is similar to the one of structures but its functionality is totally different: union union_name { member_type1 member_name1; member_type2 member_name2; member_type3 member_name3;.
Its size is the one of the greatest element of the declaration.
For example: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 83 © cplusplus_0_com 2008.
All rights reserved union mytypes_t { char c; int i; float f; } mytypes; defines three elements: mytypes_0_c mytypes_0_i mytypes_0_f each one with a different data.
Since all of them are referring to the same location in memory, the modification of one of the elements will affect the value of all of them.
We cannot store different values in them independent of each other.
One of the uses a union may have is to unite an elementary  with an array or structures of smaller elements.
For example: union mix_t { long l; struct { short hi; short lo; } s; char c[4]; } mix; defines three names that allow us to access the same group of 4 bytes: mix_0_l, mix_0_s and mix_0_c and which we can use according to how we want to access these bytes, as if they were a single long- data, as if they were two short elements or as an array of char elements, respectively.
I have mixed types, arrays and structures in the union so that you can see the different ways that we can access the data.
For a little-endian system (most PC platforms), this union could be represented as: The exact alignment and order of the members of a union in memory is platform dependant.
Therefore be aware of possible portability issues with this  of use.
Anonymous unions In Cplus_plus we have the option to declare anonymous unions.
If we declare a union without any name, the union will be anonymous and we will be able to access its members directly by their member names.
For example, look at the difference between these two structure declarations: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 84 © cplusplus_0_com 2008.
All rights reserved structure with regular union structure with anonymous union struct { char title[50]; char author[50]; union { float dollars;.
The difference is seen when we access the members dollars and yens of an object of this.
For an object of the first , it would be: book_0_price_0_dollars book_0_price_0_yens whereas for an object of the second , it would be: book_0_dollars book_0_yens Once again I remind you that because it is a union and not a struct, the members dollars and yens occupy the same physical space in the memory so they cannot be used to store two different values simultaneously.
You can set a value for price in dollars or in yens, but not in both.
Enumerations (enum) Enumerations create new  types to contain something different that is not limited to the values fundamental types may take.
Its form is the following: enum enumeration_name { value1, value2, value3,.
To say it somehow, we have created a whole new   from scratch without basing it on any other existing.
The possible values that variables of this new  color_t may take are the new  values included within braces.
For example, once the colors_t enumeration is declared the following expressions will be valid: colors_t ; = blue; if ( == green)  = red; Enumerations are  compatible with numeric variables, so their constants are always assigned an integer numerical value internally.
If it is not specified, the integer value equivalent to the first possible value is equivalent to 0 and the following ones follow a +1 progression.
Thus, in our   colors_t that we have defined above, black would be equivalent to 0, blue would be equivalent to 1, green to 2, and so on.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 85 © cplusplus_0_com 2008.
All rights reserved We can explicitly specify an integer value for any of the  values that our enumerated  can take.
If the value that follows it is not given an integer value, it is automatically assumed the same value as the previous one plus one.
For example: enum months_t { =1, february, march, april, may, june, july, august, september, october, november, december} y2k; In this case, variable y2k of enumerated  months_t can contain any of the 12 possible values that go from to december and that are equivalent to values between 1 and 12 (not between 0 and 11, since we have made  equal to 1).
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 86 © cplusplus_0_com 2008.
All rights reserved Object Oriented Programming Classes (I) A class is an expanded concept of a  structure: instead of holding only , it can hold both  and functions.
An object is an instantiation of a class.
In terms of variables, a class would be the , and an object would be the variable.
Classes are generally declared using the keyword class, with the following format: class class_name { access_specifier_1: member1; access_specifier_2: member2; _0__0_.
The body of the declaration can contain members, that can be either  or function declarations, and optionally access specifiers.
All is very similar to the declaration on  structures, except that we can now include also functions and members, but also this new  called access specifier.
An access specifier is one of the following three keywords: private, public or protected.
These specifiers modify the access rights that the members following them acquire:.
Finally, public members are accessible from anywhere where the object is visible.
By default, all members of a class declared with the class keyword have private access for all its members.
Therefore, any member that is declared before one other class specifier automatically has private access.
For example: class CRectangle { int x, y; public: void set_values (int,int); int area (void); } rect; Declares a class (i_0_e_0_, a ) called CRectangle and an object (i_0_e_0_, a variable) of this class called rect.
This class contains four members: two  members of  int (member x and member y) with private access (because private is the default access level) and two member functions with public access: set_values() and area(), of which for now we have only included their declaration, not their definition.
Notice the difference between the class name and the object name: In the previous example, CRectangle was the class name (i_0_e_0_, the ), whereas rect was an object of  CRectangle.
It is the same relationship int and a have in the following declaration: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 87 © cplusplus_0_com 2008.
All rights reserved int a; where int is the  name (the class) and a is the variable name (the object).
After the previous declarations of CRectangle and rect, we can refer within the body of the program to any of the public members of the object rect as if they were normal functions or normal variables, just by putting the object's name followed by a dot (_0_) and then the name of the member.
All very similar to what we did with plain structures before.
For example: rect_0_set_values (3,4); = rect_0_area(); The only members of rect that we cannot access from the body of our program outside the class are x and y, since they have private access and they can only be referred from within other members of that same class.
It is used to define a member of a class from outside the class definition itself.
You may notice that the definition of the member function () has been included directly within the definition of the CRectangle class given its extreme simplicity, whereas set_values() has only its prototype declared within the class, but its definition is outside it.
In this outside declaration, we must use the operator of scope (::) to specify that we are defining a function that is a member of the class CRectangle and not a regular global function.
The scope operator (::) specifies the class to which the member being declared belongs, granting exactly the same scope properties as if this function definition was directly included within the class definition.
For example, in the function set_values() of the previous code, we have been able to use the variables  and , which are private members of class CRectangle, which means they are only accessible from other members of their class.
The only difference between defining a class member function completely within its class or to  only the prototype and later its definition, is that in the first case the function will automatically be considered an inline member function by the compiler, while in the second it will be a normal (not-inline) class member function, which in fact supposes no difference in behavior.
Members  and  have private access (remember that if nothing else is said, all members of a class defined with keyword class have private access).
By declaring them private we deny access to them from anywhere outside the TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 88 © cplusplus_0_com 2008.
All rights reserved class.
This makes sense, since we have already defined a member function to set values for those members within the object: the member function set_values().
Therefore, the rest of the program does not need to have direct access to them.
Perhaps in a so simple example as this, it is difficult to see an utility in protecting those two variables, but in greater projects it may be very important that values cannot be modified in an unexpected way (unexpected from the point of view of the object).
One of the greater advantages of a class is that, as any other type, we can declare several objects of it.
For example, following with the previous example of class CRectangle, we could have declared the object rectb in addition to the object rect: // example: one class, two objects.
Each one of them has its own member variables and member functions.
Notice that the call to rect_0_() does not give the same result as the call to rectb_0_().
This is because each object of class CRectangle has its own variables  and , as they, in some way, have also their own function members set_value() and () that each uses its object's own variables to operate.
That is the basic concept of object-oriented programming: Data and functions are both members of the object.
We no longer use sets of global variables that we pass from one function to another as parameters, but instead we handle objects that have their own data and functions embedded as members.
Notice that we have not had to give any parameters in any of the calls to rect.
Those member functions directly used the data members of their respective objects rect and rectb.
Constructors and destructors Objects generally need to initialize variables or assign dynamic memory during their process of creation to become operative and to avoid returning unexpected values during their execution.
For example, what would happen if in the previous example we called the member function () before having called function set_values().
Probably we would have gotten an undetermined result since the members  and  would have never been assigned a value.
In order to avoid that, a class can  a special function called constructor, which is automatically called whenever a new  of this class is created.
This constructor function must have the same name as the class, and cannot have any return type; not even void.
We are going to implement CRectangle including a constructor: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 89 © cplusplus_0_com 2008.
All rights reserved // example: class constructor.
CRectangle rectb (5,6);.
But now we have removed the member function set_values(), and have included instead a constructor that performs a similar action: it initializes the values of  and  with the parameters that are passed to it.
Notice how these arguments are passed to the constructor at the moment at which the objects of this class are created: CRectangle rect (3,4); CRectangle rectb (5,6); Constructors cannot be called explicitly as if they were regular member functions.
They are only executed when a new  of that class is created.
You can also see how neither the constructor prototype declaration (within the class) nor the latter constructor definition  a return value; not even void.
The destructor fulfills the opposite functionality.
It is automatically called when an  is destroyed, either because its scope of existence has finished (for example, if it was defined as a local  within a function and the function ends) or because it is an  dynamically assigned and it is released using the operator delete.
The destructor must have the same name as the class, but preceded with a tilde sign (~) and it must also return no value.
The use of destructors is especially suitable when an  assigns dynamic memory during its lifetime and at the moment of being destroyed we want to release the memory that the  was allocated.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 90 © cplusplus_0_com 2008.
All rights reserved // example on constructors and destructors # <iostream> using namespace std; class CRectangle { *, *; public:.
CRectangle::CRectangle ( a,  b) { = new ; = new ; * = a; * = b; } CRectangle::~CRectangle () { delete ; delete ; }.
Remember that for overloaded functions the compiler will call the one whose parameters match the arguments used in the function call.
In the case of constructors, which are automatically called when an  is created, the one executed is the one that matches the arguments passed on the  declaration: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 91 © cplusplus_0_com 2008.
All rights reserved // overloading class constructors.
Important: Notice how if we declare  new  and we want to use its default constructor (the one without parameters), we do not  parentheses (): CRectangle rectb;   // right CRectangle rectb(); // wrong.
Default constructor If you do not declare any constructors in  class definition, the compiler assumes the class to have  default constructor with no arguments.
Therefore, after declaring  class like this one: class CExample { public: ,,; void multiply ( n,  m) { =n; =m; =*; }; }; The compiler assumes that CExample has  default constructor, so you can declare objects of this class by simply declaring them without any arguments: CExample ex; But as soon as you declare your own constructor for  class, the compiler no longer provides an implicit default constructor.
So you have to declare all objects of that class according to the constructor prototypes you defined for the class: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 92 © cplusplus_0_com 2008.
All rights reserved class CExample { public:.
Therefore the following declaration would be correct: CExample ex (2,3); But, CExample ex; Would not be correct, since we have declared the class to have an explicit constructor, thus replacing the default constructor.
But the compiler not only creates  default constructor for you if you do not specify your own.
It provides three special member functions in total that are implicitly declared if you do not declare your own.
These are the copy constructor, the copy assignment operator, and the default destructor.
The copy constructor and the copy assignment operator copy all the data contained in another  to the data members of the current.
For CExample, the copy constructor implicitly declared by the compiler would be something similar to: CExample::CExample (const CExample& rv) { =rv_0_;  =rv_0_;  =rv_0_; } Therefore, the two following  declarations would be correct: CExample ex (2,3); CExample ex2 (ex);   // copy constructor (data copied from ex) Pointers to classes It is perfectly valid to create pointers that point to classes.
We simply have to consider that once declared,  class becomes  valid type, so we can use the class name as the type for the pointer.
For example: CRectangle * prect; is  pointer to an  of class CRectangle.
As it happened with data structures, in order to refer directly to  member of an  pointed by  pointer we can use the arrow operator (arrow_operator) of indirection.
Here is an example with some possible combinations: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 93 © cplusplus_0_com 2008.
All rights reserved // pointer to classes example.
If you have doubts, read again this section and/or consult the previous sections about pointers and data structures.
Classes defined with struct and union Classes can be defined not only with keyword class, but also with keywords struct and union.
The concepts of class and data structure are so similar that both keywords (struct and class) can be used in Cplus_plus to declare classes (i_0_e.
The only difference between both is that members of classes declared with the keyword struct have public access by default, while members of classes declared with the keyword class have private access.
For all other purposes both keywords are equivalent.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 94 © cplusplus_0_com 2008.
All rights reserved The concept of unions is different from that of classes declared with struct and class, since unions only store one data member at  time, but nevertheless they are also classes and can thus also hold function members.
The default access in union classes is public.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 95 © cplusplus_0_com 2008.
All rights reserved Classes (II) Overloading operators Cplus_plus incorporates the option to use standard operators to perform operations with classes in addition to with fundamental types.
For example: int , , ; =  + ; This is obviously valid code in Cplus_plus, since the different variables of the addition are all fundamental types.
Nevertheless, it is not so obvious that we could perform an operation similar to the following one: struct { string product; float price; } , , ; =  + ; In fact, this will cause  compilation error, since we have not defined the behavior our class should have with addition operations.
However, thanks to the Cplus_plus feature to overload operators, we can design classes able to perform operations using standard operators.
Here is  list of all the operators that can be overloaded: Overloadable operators +    -    *    /    =    <    >    +=   -=   *=   /=   <<   >> <<=  >>=  ==   _0_=   <=   >=   plus_plus   minus_minus   %    &    ^.
The format is: type operator sign (parameters) { /*_0__0__0_*/ } Here you have an example that overloads the addition operator (+).
We are going to create  class to store bidimensional vectors and then we are going to add two of them: (3,1) and (1,2).
The addition of two bidimensional vectors is an operation as simple as adding the two x coordinates to obtain the resulting x coordinate and adding the two y coordinates to obtain the resulting y.
In this case the result will  (3+1,1+2) = (4,3).
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 96 © cplusplus_0_com 2008.
All rights reserved // vectors: overloading operators example.
But, consider that some of them refer to the class name (type) CVector and some others are functions with that name (constructors must have the same name as the class).
Do not confuse them: CVector (int, int);            // function name CVector (constructor) CVector operator+ (CVector);   // function returns  CVector The function operator+ of class CVector is the one that is in charge of overloading the addition operator (+).
This function can  called either implicitly using the operator, or explicitly using the function name: =  + b; = _0_operator+ (b); Both expressions are equivalent.
Notice also that we have included the empty constructor (without parameters) and we have defined it with an empty block: CVector () { }; This is necessary, since we have explicitly declared another constructor: CVector (int, int); And when we explicitly declare any constructor, with any number of parameters, the default constructor with no parameters that the compiler can declare automatically is not declared, so we need to declare it ourselves in order to  able to construct objects of this type without parameters.
Otherwise, the declaration: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 97 © cplusplus_0_com 2008.
All rights reserved ; included in main() would not have been valid.
Anyway, I have to warn you that an empty block is  bad implementation for  constructor, since it does not fulfill the minimum functionality that is generally expected from  constructor, which is the initialization of all the member variables in its class.
In our case this constructor leaves the variables  and  undefined.
Therefore, more advisable definition would have been something similar to this: () { =0; =0; }; which in order to simplify and show only the point of the code I have not included in the example.
As well as  class includes  default constructor and  copy constructor even if they are not declared, it also includes  default definition for the assignment  (=) with the class itself as parameter.
The behavior which is defined by default is to copy the whole content of the data members of the object passed as argument (the one at the right side of the sign) to the one at the left side: d (2,3); ; = d;           // copy assignment The copy assignment  function is the only  member function implemented by default.
Of course, you can redefine it to any other functionality that you want, like for example, copy only certain class members or perform additional initialization procedures.
The overload of operators does not force its operation to bear  relation to the mathematical or usual meaning of the , although it is recommended.
For example, the code may not  very intuitive if you use  + to subtract two classes or == to fill with zeros  class, although it is perfectly possible to do so.
Although the prototype of  function + can seem obvious since it takes what is at the right side of the as the parameter for the  member function of the object at its left side, other operators may not so obvious.
Here you have  table with  summary on how the different  functions have to  declared (replace @ by the  in each case): Expression Operator Member function Global function @ + - * &.
You can see in this panel that there are two ways to overload some class operators: as a member function and as a global function.
Its use is indistinct, nevertheless I remind you that functions that are not members of a class cannot access the private or protected members of that class unless the global function is its friend (friendship is explained later).
The keyword this The keyword this represents a pointer to the object whose member function is being executed.
It is a pointer to the object itself.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 98 © cplusplus_0_com 2008.
All rights reserved One of its uses can be to check if a parameter passed to a member function is the object itself.
Following with the vector's examples seen before we could have written an = function similar to this one: & ::= (const & ) { =_0_; =_0_; return *this; } In fact this function is very similar to the code that the compiler generates implicitly for this class if we do not an = member function to copy objects of this class.
Static members A class can contain static members, either data or functions.
Static data members of a class are also known as "class variables", because there is only one unique value for all the objects of that same class.
Their content is not different from one object of this class to another.
For example, it may be used for a variable within a class that can contain a counter with the number of objects of that class that are currently allocated, as in the following example: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 99 © cplusplus_0_com 2008.
All rights reserved // static members in classes.
For that reason, and to avoid them to be declared several times, we can only  the prototype (its declaration) in the class declaration but not its definition (its initialization).
In order to initialize a static data-member we must  a formal definition outside the class, in the global scope, as in the previous example: int ::=0; Because it is a unique variable value for all the objects of the same class, it can be referred to as a member of any object of that class or even directly by the class name (of course this is only valid for static members): cout << a_0_; cout << ::; These two calls included in the previous example are referring to the same variable: the static variable  within class  shared by all objects of this class.
Once again, I remind you that in fact it is a global variable.
The only difference is its name and possible access restrictions outside its class.
Just as we may  static data within a class, we can also  static functions.
They represent the same: they are global functions that are called as if they were object members of a given class.
They can only refer to static data, in no case to non-static members of the class, as well as they do not allow the use of the keyword this, since it makes reference to an object pointer and these functions in fact are not members of any object but direct members of the class.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 100 © cplusplus_0_com 2008.
All rights reserved Friendship and inheritance Friend functions In principle, private and protected members of a class cannot be accessed from outside the same class in which they are declared.
However, this rule does not affect friends.
Friends are functions or classes declared as such.
If we want to declare an external function as friend of a class, thus allowing this function to have access to the private and protected members of this class, we do it by declaring a prototype of this external function within the class, and preceding it with the keyword friend: // friend functions.
From within that function we have been able to access the members  and  of different objects of type CRectangle, which are private members.
Notice that neither in the declaration of duplicate() nor in its later use in main() have we considered duplicate a member of class CRectangle.
It simply has access to its private and protected members without being a member.
The friend functions can serve, for example, to conduct operations between two different classes.
Generally, the use of friend functions is out of an object-oriented programming methodology, so whenever possible it is better to use members of the same class to perform operations with them.
Such as in the previous example, it would have been shorter to integrate duplicate() within the class CRectangle.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 101 © cplusplus_0_com 2008.
All rights reserved Friend classes Just as we have the possibility to define a friend function, we can also define a class as friend of another one, granting that first class access to the protected and private members of the second one.
You may also see something new  the beginning of the program: an empty declaration of class CSquare.
This is necessary because within the declaration of CRectangle we refer to CSquare (as a parameter in convert()).
The definition of CSquare is included later, so if we did not  a previous empty declaration for CSquare this class would not be visible from within the definition of CRectangle.
Consider that friendships are not corresponded if we do not explicitly specify so.
In our example, CRectangle is considered as a friend class by CSquare, but CRectangle does not consider CSquare to be a friend, so CRectangle can access the protected and private members of CSquare but not the reverse way.
Of course, we could have declared also CSquare as friend of CRectangle if we wanted to.
Another property of friendships is that they are not transitive: The friend of a friend is not considered to be a friend unless explicitly specified.
Inheritance between classes A key feature of Cplus_plus classes is inheritance.
Inheritance allows to create classes which are derived from other classes, so that they automatically  some of its "parent's" members, plus its own.
For example, we are going TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 102 © cplusplus_0_com 2008.
All rights reserved to suppose that we want to declare a series of classes that describe polygons like our CRectangle, or like CTriangle.
They have certain common properties, such as both can be described by means of only two sides: and base.
This could be represented in the world of classes with a class CPolygon from which we would derive the two other ones: CRectangle and CTriangle.
The class CPolygon would contain members that are common for both types of polygon.
In our case:  and And CRectangle and CTriangle would be its derived classes, with specific features that are different from one type of polygon to the other.
Classes that are derived from others inherit all the accessible members of the base class.
That means that if a base class includes a member A and we derive it to another class with another member called B, the derived class will contain both members A and B.
In order to derive a class from another, we use a colon (:) in the declaration of the derived class using the following format: class derived_class_name: public base_class_name { /*_0__0__0_*/ }; Where derived_class_name is the name of the derived class and base_class_name is the name of the class on which it is based.
The public access specifier may be replaced by any one of the other access specifiers protected and private.
This access specifier describes the minimum access level for the members that are inherited from the base class.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 103 © cplusplus_0_com 2008.
All rights reserved // derived classes.
The protected access specifier is similar to private.
Its only difference occurs in fact with inheritance.
When a class inherits from another one, the members of the derived class can access the protected members inherited from the base class, but not its private members.
Since we wanted  and  to be accessible from members of the derived classes CRectangle and CTriangle and not only by members of CPolygon, we have used protected access instead of private.
We can summarize the different access types according to who can access them in the following way: Access public protected private members of the same class yes yes yes members of derived classes yes yes no not members yes no no Where "not members" represent any access from outside the class, such as from main(), from another class or from a function.
In our example, the members inherited by CRectangle and CTriangle have the same access permissions as they had in their base class CPolygon: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 104 © cplusplus_0_com 2008.
All rights reserved CPolygon::           // protected access.
This is because we have used the public keyword to define the inheritance relationship on each of the derived classes: class CRectangle: public CPolygon { _0__0_.
Since public is the most accessible level, by specifying this keyword the derived class will inherit all the members with the same levels they had in the base class.
If we specify a more restrictive access level like protected, all public members of the base class are inherited as protected in the derived class.
Whereas if we specify the most restricting of all access levels: private, all the base class members are inherited as private.
For example, if daughter was a class derived from mother that we defined as: class daughter: protected mother; This would set protected as the maximum access level for the members of daughter that it inherited from mother.
That is, all members that were public in mother would become protected in daughter.
Of course, this would not restrict daughter to declare its own public members.
That maximum access level is only set for the members inherited from mother.
If we do not explicitly specify any access level for the inheritance, the compiler assumes private for classes declared with class keyword and public for those declared with struct.
In principle, a derived class inherits every member of a base class except:.
If the base class has no default constructor or you want that an overloaded constructor is called when a new derived  is created, you can specify it in each constructor definition of the derived class: derived_constructor_name (parameters) : base_constructor_name (parameters) {_0__0__0_} For example: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 105 © cplusplus_0_com 2008.
All rights reserved // constructors and derived classes.
The difference is because the constructor declaration of  and son: (int a)          // nothing specified: call default son (int a) : mother (a)  // constructor specified: call this Multiple inheritance In Cplus_plus it is perfectly possible that a class inherits members from more than one class.
This is done by simply separating the different base classes with commas in the derived class declaration.
For example, if we had a specific class to print on screen (COutput) and we wanted our classes CRectangle and CTriangle to also inherit its members in addition to those of CPolygon we could write: class CRectangle: public CPolygon, public COutput; class CTriangle: public CPolygon, public COutput; here is the complete example: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 106 © cplusplus_0_com 2008.
All rights reserved // multiple inheritance.
All rights reserved Polymorphism Before getting into this section, it is recommended that you have a proper understanding of pointers and class inheritance.
If any of the following statements seem strange to you, you should review the indicated sections: Statement: Explained in: int a::b(c) {}; Classes aarrow_operatorb Data Structures class a: public b; Friendship and inheritance Pointers to base class One of the key features of derived classes is that a pointer to a derived class is type-compatible with a pointer to its base class.
Polymorphism is the art of taking advantage of this simple but powerful and versatile feature, that brings Object Oriented Methodologies to its full potential.
We are going to start by rewriting our program about the rectangle and the triangle of the previous section taking into consideration this pointer compatibility property: // pointers to base class.
Then we assign references to rect and trgl to these pointers, and because both are objects of classes derived from , both are valid assignment operations.
The only limitation in using *1 and *2 instead of rect and trgl is that both *1 and *2 are of type * and therefore we can only use these pointers to refer to the members that CRectangle and TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 108 © cplusplus_0_com 2008.
All rights reserved CTriangle inherit from.
For that reason when we call the () members at the end of the program we have had to use directly the objects rect and trgl instead of the pointers *1 and *2.
In order to use () with the pointers to class , this member should also have been declared in the class , and not only in its derived classes, but the problem is that CRectangle and CTriangle implement different versions of , therefore we cannot implement it in the base class.
This is when virtual members become handy: Virtual members A member of a class that can be redefined in its derived classes is known as a virtual member.
In order to declare a member of a class as virtual, we must precede its declaration with the keyword virtual: // virtual members.
The member function () has been declared as virtual in the base class because it is later redefined in each derived class.
You can verify if you want that if you remove this virtual keyword from the declaration of () within , and then you run the program the result will be 0 for the three polygons instead of 20, 10 and 0.
That is because instead of calling the corresponding () function for each object (CRectangle::(), CTriangle::() and ::(), respectively), ::() will be called in all cases since the calls are via a pointer whose type is *.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 109 © cplusplus_0_com 2008.
All rights reserved Therefore, what the virtual keyword does is to allow a member of a derived class with the same name as one in the base class to be appropriately called from a pointer, and more precisely when the type of the pointer is a pointer to the base class but is pointing to an object of the derived class, as in the above example.
A class that declares or inherits a virtual function is called a polymorphic class.
Note that despite of its virtuality, we have also been able to declare an object of type  and to call its own () function, which always returns 0.
Abstract base classes Abstract base classes are something very similar to our  class of our previous example.
The only difference is that in our previous example we have defined a valid () function with a minimal functionality for objects that were of class  (like the object poly), whereas in an abstract base classes we could leave that () member function without implementation at all.
This is done by  =0 (equal to zero) to the function declaration.
An abstract base  class could look like this: // abstract class class  { protected: int , ; public: void set_values (int a, int b) { =a; =b; } virtual int  () =0; }; Notice how we  =0 to virtual int  () instead of specifying an implementation for the function.
This type of function is called a pure virtual function, and all classes that contain at least one pure virtual function are abstract base classes.
The main difference between an abstract base class and a regular polymorphic class is that because in abstract base classes at least one of its members lacks implementation we cannot create instances (objects) of it.
But a class that cannot instantiate objects is not totally useless.
We can create pointers to it and take advantage of all its polymorphic abilities.
Therefore a declaration like: poly; would not be valid for the abstract base class we have just declared, because tries to instantiate an object.
Nevertheless, the following pointers: * 1; * 2; would be perfectly valid.
This is so for as long as  includes a pure virtual function and therefore it's an abstract base class.
However, pointers to this abstract base class can be used to point to objects of derived classes.
Here you have the complete example: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 110 © cplusplus_0_com 2008.
All rights reserved // abstract base class.
This can be tremendously useful.
For example, now we can create a function member of the abstract base class  that is able to print on screen the result of the () function even though itself has no implementation for this function: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 111 © cplusplus_0_com 2008.
All rights reserved // pure virtual members can be called // from the abstract base class # <iostream> using namespace std; class  { protected: int , ; public: set_values (int a, int b) { =a; =b; } virtual int  () =0; printarea ().
Of course, we have seen very simple uses of these features, but these features can be applied to arrays of objects or dynamically allocated objects.
Let's end with the same example again, but this time with objects that are dynamically allocated: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 112 © cplusplus_0_com 2008.
All rights reserved // dynamic allocation and polymorphism.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 113 © cplusplus_0_com 2008.
All rights reserved Advanced concepts Templates Function templates Function templates are special functions that can operate with generic types.
This allows us to create a function template whose functionality can be adapted to more than one type or class without repeating the entire code for each type.
In Cplus_plus this can be achieved using template parameters.
A template parameter is a special kind of parameter that can be used to pass a type as argument: just like regular function parameters can be used to pass values to a function, template parameters allow to pass also types to a function.
These function templates can use these parameters as if they were any other regular type.
The format for declaring function templates with type parameters is: template <class identifier> function_declaration; template <typename identifier> function_declaration; The only difference between both prototypes is the use of either the keyword class or the keyword typename.
Its use is indistinct, since both expressions have exactly the same meaning and behave exactly the same way.
For example, to create a template function that returns the greater one of two objects we could use: template <class myType> myType GetMax (myType a, myType b) { return (a>b_0_a:b); } Here we have created a template function with myType as its template parameter.
This template parameter represents a type that has not yet been specified, but that can be used in the template function as if it were a regular type.
As you can see, the function template GetMax returns the greater of two parameters of this stillundefined type.
To use this function template we use the following format for the function call: function_name <type> (parameters); For example, to call GetMax to compare two integer values of type int we can write: int x,y; GetMax <int> (x,y); When the compiler encounters this call to a template function, it uses the template to automatically generate a function replacing each appearance of myType by the type passed as the actual template parameter (int in this case) and then calls it.
This process is automatically performed by the compiler and is invisible to the programmer.
Here is the entire example: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 114 © cplusplus_0_com 2008.
All rights reserved // function template # <iostream>.
But you can use any identifier you like.
In the example above we used the function template () twice.
The first time with arguments of type int and the second one with arguments of type long.
The compiler has instantiated and then called each time the appropriate version of the function.
As you can see, the type T is used within the () template function even to declare new  of that type: T ; Therefore,  will be an object of the same type as the parameters a and b when the function template is instantiated with a specific type.
In this specific case where the generic type T is used as a parameter for  the compiler can find out automatically which data type has to instantiate without having to explicitly specify it within angle brackets (like we have done before specifying <int> and <long>).
So we could have written instead: int ,; (,); Since both  and  are of type int, and the compiler can automatically find out that the template parameter can only be int.
This implicit method produces exactly the same : TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 115 © cplusplus_0_com 2008.
All rights reserved // function template II # <iostream>.
T  (T a, T b) { return (a>b_0_a:b); } int main () {.
The compiler automatically determines what type is needed on each call.
Because our template function includes only one template parameter (class T) and the function template itself accepts two parameters, both of this T type, we cannot call our function template with two  of different types as arguments: int ; long ; =  (,); This would not be correct, since our  function template expects two arguments of the same type, and in this call to it we use  of two different types.
We can also define function templates that accept more than one type parameter, simply by specifying more template parameters between the angle brackets.
For example: template <class T, class U> T GetMin (T a, U b) { return (a<b_0_a:b); } In this case, our function template GetMin() accepts two parameters of different types and returns an object of the same type as the first parameter (T) that is passed.
For example, after that declaration we could call GetMin() with: int ,; long ; = GetMin<int,long> (,); or simply: = GetMin (,); even though  and  have different types, since the compiler can determine the appropriate instantiation anyway.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 116 © cplusplus_0_com 2008.
All rights reserved Class We also have the possibility to write class , so that a class can have members that use template parameters as types.
For example: template <class T> class mypair { T  [2]; public: mypair (T first, T second) { [0]=first; [1]=second; } }; The class that we have just defined serves to store two elements of any valid type.
For example, if we wanted to declare an object of this class to store two integer  of type int with the  115 and 36 we would write: mypair<int> myobject (115, 36); this same class would also be used to create an object to store any other type: mypair<double> myfloats (3_0_0, 2_0_18); The only member function in the previous class template has been defined inline within the class declaration itself.
In case that we define a function member outside the declaration of the class template, we must always precede that definition with the template <_0__0__0_> prefix: // class # <iostream>.
All rights reserved template <class T> T <T>::getmax () Confused by so many T's.
There are three T's in this declaration: The first one is the template parameter.
The second T refers to the type returned by the function.
And the third T (the one between angle brackets) is also requirement: It specifies that this function's template parameter is also the class template parameter.
Template specialization If we want to define  different implementation for  template when  specific type is passed as template parameter, we can declare  specialization of that template.
For example, let's suppose that we have  very simple class called mycontainer that can store one element of any type and that it has just one member function called increase, which increases its value.
But we find that when it stores an element of type char it would be more convenient to have  completely different implementation with function member uppercase, so we decide to declare  class template specialization for that type: // template specialization.
This is to explicitly declare it as   specialization.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 118 © cplusplus_0_com 2008.
All rights reserved But more important than this prefix, is the <char> specialization parameter after the class  name.
This specialization parameter itself identifies the type for which we are going to declare   class specialization (char).
Notice the differences between the generic class  and the specialization: <class T> class  { _0__0_.
When we declare specializations for   class, we must also define all its members, even those exactly equal to the generic  class, because there is no "inheritance" of members from the generic  to the specialization.
Non-type parameters for Besides the  arguments that are preceded by the class or typename keywords , which represent types, can also have regular typed parameters, similar to those found in functions.
As an example, have  look at this class  that is used to contain sequences of elements: // sequence # <iostream>.
For example, if the previous class definition had been: <class =char, int =10> class  {_0__0_}; We could create objects using the default  parameters by declaring: <> myseq; Which would be equivalent to: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 119 © cplusplus_0_com 2008.
All rights reserved <char,10> myseq; Templates and multiple-file projects From the point of view of the compiler, templates are not normal functions or classes.
They are compiled on demand, meaning that the code of a  function is not compiled until an instantiation with specific arguments is required.
At that moment, when an instantiation is required, the compiler generates a function specifically for those arguments from the.
When projects grow it is usual to split the code of a program in different source code files.
In these cases, the interface and implementation are generally separated.
Taking a library of functions as example, the interface generally consists of declarations of the prototypes of all the functions that can be called.
These are generally declared in a "header file" with a _0_h extension, and the implementation (the definition of these functions) is in an independent file with cplus_plus code.
Because templates are compiled when required, this forces a restriction for multi-file projects: the implementation (definition) of a  class or function must be in the same file as its declaration.
That means that we cannot separate the interface in a separate header file, and that we must  both interface and implementation in any file that uses the templates.
Since no code is generated until a  is instantiated when required, compilers are prepared to allow the inclusion more than once of the same  file with both declarations and definitions in a project without generating linkage errors.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 120 © cplusplus_0_com 2008.
All rights reserved Namespaces Namespaces allow to group entities like classes, objects and functions under a name.
This way the global scope can be divided in "sub-scopes", each one with its own name.
The format of namespaces is: namespace identifier { entities } Where identifier is any valid identifier and entities is the set of classes, objects and functions that are included within the namespace.
For example: namespace myNamespace { int a, b; } In this case, the variables a and b are normal variables declared within a namespace called myNamespace.
In order to access these variables from outside the myNamespace namespace we have to use the scope operator ::.
For example, to access the previous variables from outside myNamespace we can write: myNamespace::a myNamespace::b The functionality of namespaces is especially useful in the case that there is a possibility that a global object or function uses the same identifier as another one, causing redefinition errors.
For example: // namespaces # <iostream>.
One is defined within the namespace first and the other one in second.
No redefinition errors happen thanks to namespaces.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 121 © cplusplus_0_com 2008.
All rights reserved using The keyword using is used to introduce a name from a namespace into the current declarative region.
For example: // using # <iostream>.
We still have access to first:: and second:: using their fully qualified names.
The keyword using can also be used as a directive to introduce an entire namespace: // using # <iostream>.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 122 © cplusplus_0_com 2008.
All rights reserved using and using namespace have validity only in the same block in which they are stated or in the entire code if they are used directly in the global scope.
For example, if we had the intention to first use the objects of one namespace and then those of another one, we could do something like: // using namespace example # <iostream>.
That is why we have generally included the using namespace std; statement in all programs that used any entity defined in iostream.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 123 © cplusplus_0_com 2008.
All rights reserved Exceptions Exceptions provide a way to react to exceptional circumstances (like runtime errors) in our program by transferring control to special functions called handlers.
To catch exceptions we must place a portion of code under exception inspection.
This is done by enclosing that portion of code in a try block.
When an exceptional circumstance arises within that block, an exception is thrown that transfers the control to the exception handler.
If no exception is thrown, the code continues normally and all handlers are ignored.
A exception is thrown by using the throw keyword from inside the try block.
Exception handlers are declared with the keyword catch, which must be placed immediately after the try block: // exceptions.
In this example this code simply throws an exception: throw 20; A throw expression accepts one parameter (in this case the integer value 20), which is passed as an argument to the exception handler.
The exception handler is declared with the catch keyword.
As you can see, it follows immediately the closing brace of the try block.
The catch format is similar to a regular function that always has at least one parameter.
The type of this parameter is very important, since the type of the argument passed by the throw expression is checked against it, and only in the case they match, the exception is caught.
We can chain multiple handlers (catch expressions), each one with a different parameter type.
Only the handler that matches its type with the argument specified in the throw statement is executed.
If we use an ellipsis (_0__0__0_) as the parameter of catch, that handler will catch any exception no matter what the type of the throw exception is.
This can be used as a default handler that catches all exceptions not caught by other handlers if it is specified at last: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 124 © cplusplus_0_com 2008.
All rights reserved.
In this case the last handler would catch any exception thrown with any parameter that is neither an int nor a char.
After an exception has been handled the program execution resumes after the try-catch block, not after the throw statement_0_.
It is also possible to nest try-catch blocks within more external try blocks.
In these cases, we have the possibility that an internal catch block forwards the exception to its external level.
This is done with the expression throw; with no arguments.
The only exception that this function might throw is an exception of type int.
If it throws an exception with a different type, either directly or indirectly, it cannot be caught by a regular int-type handler.
If this throw specifier is left empty with no type, this means the function is not allowed to throw exceptions.
Functions with no throw specifier (regular functions) are allowed to throw exceptions with any type: int myfunction (int param) throw(); // no exceptions allowed int myfunction (int param);         // all exceptions allowed Standard exceptions The Cplus_plus Standard library provides a base class specifically designed to declare objects to be thrown as exceptions.
It is called exception and is defined in the <exception> header file under the namespace std.
This class has the usual default and copy constructors, operators and destructors, plus an additional virtual member function called what that returns a null-terminated character sequence (char *) and that can be overwritten in derived classes to contain some sort of description of the exception.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 125 © cplusplus_0_com 2008.
All rights reserved.
We have placed a handler that catches exception objects by reference (notice the ampersand & after the type), therefore this catches also classes derived from exception, like our myex object of class myexception.
All exceptions thrown by components of the Cplus_plus Standard library throw exceptions derived from this std::exception class.
These are: exception description bad_alloc thrown by new  allocation failure bad_cast thrown by dynamic_cast when fails with a referenced type bad_exception thrown when an exception type doesn't match any catch bad_typeid thrown by typeid ios_base::failure thrown by functions in the iostream library For example, if we use the operator new  the memory cannot be allocated, an exception of type bad_alloc is thrown: try { * = new [1000]; }.
If you want to force a bad_alloc exception to see it in action, you can try to allocate a huge array; On my system, trying to allocate 1 billion ints threw a bad_alloc exception.
Because bad_alloc is derived from the standard base class exception, we can handle that same exception by catching references to the exception class: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 126 © cplusplus_0_com 2008.
All rights reserved.
All rights reserved Type Casting Converting an expression of  given type into another type is known as type-casting.
We have already seen some ways to type cast: Implicit conversion Implicit conversions do not require any operator.
They are automatically performed when  value is copied to compatible type.
For example: short =2000; ; =; Here, the value of  has been promoted from short to   we have not had to specify any type-casting operator.
This is known as  standard conversion.
Standard conversions affect fundamental data types,  allow conversions such as the conversions between numerical types (short to ,  to float, double to _0__0__0_), to or from bool,  some pointer conversions.
Some of these conversions may imply  loss of precision, which the compiler can signal with  warning.
This can be avoided with an explicit conversion.
Implicit conversions also  constructor or operator conversions, which affect classes that  specific constructors or operator functions to perform conversions.
For example: class A {}; class  { public:  (A ) {} }; A ; =; Here,  implicit conversion happened between objects of class A  class , because  has  constructor that takes an object of class A as parameter.
Therefore implicit conversions from A to  are allowed.
Explicit conversion Cplus_plus is  strong-typed language.
Many conversions, specially those that imply  different interpretation of the value, require an explicit conversion.
We have already seen two notations for explicit type conversion: functional c-like casting: short =2000; ; = () ;    // c-like cast notation =  ();    // functional notation The functionality of these explicit conversion operators is enough for most needs with fundamental data types.
However, these operators can be applied indiscriminately  classes  pointers to classes, which can lead to code that while being syntactically correct can cause runtime errors.
For example, the following code is syntactically correct: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 128 © cplusplus_0_com 2008.
All rights reserved // class type-casting.
The subsequent call to member result will produce either  run-time error or  unexpected result.
In order to control these types of conversions between classes, we have four specific casting operators: dynamic_cast, reinterpret_cast, static_cast and const_cast.
Their format is to follow the new  enclosed between angle-brackets (<>) and immediately after, the expression to be converted between parentheses.
Its purpose is to ensure that the result of the  conversion is  valid complete object of the requested class.
Therefore, dynamic_cast is always successful when we cast  class to one of its base classes: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 129 © cplusplus_0_com 2008.
All rights reserved class CBase { }; class CDerived: public CBase { }; CBase ; CBase* ; CDerived d; CDerived* ; = <CBase*>(&d);     // ok: derived-to-base = <CDerived*>(&);  // wrong: base-to-derived The second conversion in this piece of code would produce  compilation error since base-to-derived conversions are not allowed with  unless the base class is polymorphic.
When  class is polymorphic,  performs  special checking during runtime to ensure that the expression yields  valid complete object of the requested class:.
Some compilers support this feature as an option which is disabled by default.
This must be enabled for runtime  checking using  to work properly.
The code tries to perform two dynamic casts from pointer objects of  * ( and ) to  pointer object of  *, but only the first one is successful.
Notice their respective initializations: *  = new ; *  = new ; Even though both are pointers of  *,  points to an object of  , while  points to an object of.
Thus, when their respective -castings are performed using ,  is pointing to  full object of class , whereas  is pointing to an object of class , which is an incomplete object of class.
When  cannot cast  pointer because it is not  complete object of the required class -as in the second conversion in the previous example- it returns a null pointer to indicate the failure.
If  is used to convert to a reference  and the conversion is not possible, an exception of  bad_cast is thrown instead.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 130 © cplusplus_0_com 2008.
All rights reserved can perform conversions between pointers to related classes, not only from the derived class to its base, but also from  base class to its derived.
This ensures that at least the classes are compatible if the proper object is converted, but no safety check is performed during runtime to check if the object being converted is in fact  full object of the destination.
Therefore, it is up to the programmer to ensure that the conversion is safe.
On the other side, the overhead of the -safety checks of  is avoided.
The operation result is  simple binary copy of the value from one pointer to the other.
All pointer conversions are allowed: neither the content pointed nor the pointer  itself is checked.
It can also cast pointers to or from integer types.
The format in which this integer value represents  pointer is platform-specific.
The only guarantee is that  pointer cast to an integer  large enough to fully contain it, is granted to be able to be cast back to  valid pointer.
The conversions that can be performed by  but not by  have no specific uses in Cplus_plus are low-level operations, whose interpretation results in code which is generally system-specific, and thus non-portable.
For example: class  {}; class  {}; *  = new ; *  = <*>(); This is valid Cplus_plus code, although it does not make much sense, since now we have  pointer that points to an object of an incompatible class, and thus dereferencing it is unsafe.
For example, in order to pass  const argument to  function that expects  non-constant parameter: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 131 © cplusplus_0_com 2008.
All rights reserved // const_cast # <iostream>.
This returned value can be compared with another one using  ==  _0_= or can serve to obtain  null-terminated character sequence representing the data type or class name by using its name() member.
When typeid applied to an expression whose type   polymorphic class, the result  the type of the most derived complete object: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 132 © cplusplus_0_com 2008.
All rights reserved.
However, when typeid  applied to objects (like *  *) typeid yields their dynamic type (_0_e.
If the type typeid evaluates   pointer preceded by the dereference operator (*),  this pointer has  null value, typeid throws  bad_typeid exception.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 133 © cplusplus_0_com 2008.
All rights reserved Preprocessor directives Preprocessor directives are lines included in the code of our programs that are not program statements but directives for the preprocessor.
These lines are always preceded by  hash sign (#).
The preprocessor  executed before the actual compilation of code begins, therefore the preprocessor digests all these directives before any code  generated by the statements.
These preprocessor directives extend only across  single line of code.
As soon as  newline character  found, the preprocessor directive  considered to end.
No semicolon (;)  expected at the end of  preprocessor directive.
The only way  preprocessor directive can extend through more than one line  by preceding the newline character at the end of the line by  backslash (\).
Its format : #define identifier replacement When the preprocessor encounters this directive, it replaces any occurrence of identifier in the rest of the code by replacement.
This replacement can be an expression,  statement,  block or simply anything.
The preprocessor does not understand Cplus_plus, it simply replaces any occurrence of identifier by replacement.
A macro lasts until it  undefined with the #undef preprocessor directive: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 134 © cplusplus_0_com 2008.
All rights reserved #define TABLE_SIZE 100 int table1[TABLE_SIZE]; #undef TABLE_SIZE #define TABLE_SIZE 200 int table2[TABLE_SIZE]; This would generate the same code as: int table1[100]; int table2[200]; Function macro definitions accept two special operators (# and ##) in the replacement sequence: If the operator #  used before  parameter  used in the replacement sequence, that parameter  replaced by string literal (as if it were enclosed between double quotes) #define str() # << str(test); This would be translated into:.
The operator ## concatenates two arguments leaving no blank spaces between them: #define glue(,)  ## glue(c,) << "test"; This would also be translated into: << "test"; Because preprocessor replacements happen before any Cplus_plus syntax check, macro definitions can be  tricky feature, but be careful: code that relies heavily on complicated macros may result obscure to other programmers, since the syntax they expect  on many occasions different from the regular expressions programmers expect in Cplus_plus.
Conditional inclusions (#ifdef, #ifndef, #if, #endif, #else and #elif) These directives allow to  or discard part of the code of  program if  certain condition  met.
For example: #ifdef TABLE_SIZE int table[TABLE_SIZE]; #endif In this case, the line of code int table[TABLE_SIZE];  only compiled if TABLE_SIZE was previously defined with #define, independently of its value.
If it was not defined, that line will not be included in the program compilation.
For example: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 135 © cplusplus_0_com 2008.
All rights reserved #ifndef TABLE_SIZE #define TABLE_SIZE 100 #endif int table[TABLE_SIZE]; In this case, if when arriving at this piece of code, the TABLE_SIZE macro has not been defined yet, it would be defined to a value of 100.
If it already existed it would keep its previous value since the #define directive would not be executed.
The #if, #else and #elif (i_0_e_0_, "else if") directives serve to specify some condition to be met in order for the portion of code they surround to be compiled.
The condition that follows #if or #elif can only evaluate constant expressions, including macro expressions.
For example: #if TABLE_SIZE>200 #undef TABLE_SIZE #define TABLE_SIZE 200 #elif TABLE_SIZE<50 #undef TABLE_SIZE #define TABLE_SIZE 50 #else #undef TABLE_SIZE #define TABLE_SIZE 100 #endif int table[TABLE_SIZE]; Notice how the whole structure of #if, #elif and #else chained directives ends with #endif.
The behavior of #ifdef and #ifndef can also be achieved by using the special operators defined and _0_defined respectively in any #if or #elif directive: #if _0_defined TABLE_SIZE #define TABLE_SIZE 100 #elif defined ARRAY_SIZE #define TABLE_SIZE ARRAY_SIZE int table[TABLE_SIZE]; Line control (#) When we compile a program and some error happen during the compiling process, the compiler shows an error message with references to the name of the file where the error happened and a  number, so it is easier to find the code generating the error.
The # directive allows us to control both things, the  numbers within the code files as well as the file name that we want that appears when an error takes place.
Its format is: # number "filename" Where number is the new  number that will be assigned to the next code.
The  numbers of successive lines will be increased one by one from this point on.
For example: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 136 © cplusplus_0_com 2008.
All rights reserved # 20 "assigning variable" int a_0_; This code will generate an error that will be shown as error in file "assigning variable",  20.
Error directive (#error) This directive aborts the compilation process when it is found, generating a compilation the error that can be specified as its parameter: #ifndef __cplusplus #error A Cplus_plus compiler is required.
Source file inclusion (#) This directive has also been used assiduously in other sections of this tutorial.
When the preprocessor finds an # directive it replaces it by the entire content of the specified file.
There are two ways to specify a file to be included: # "file" # <file> The only difference between both expressions is the places (directories) where the compiler is going to look for the file.
In the first case where the file name is specified between double-quotes, the file is searched first in the same directory that includes the file containing the directive.
In case that it is not there, the compiler searches the file in the default directories where it is configured to look for the standard header files.
If the file name is enclosed between angle-brackets <> the file is searched directly where the compiler is configured to look for the standard header files.
Therefore, standard header files are usually included in angle-brackets, while other specific header files are included using quotes.
Pragma directive (#pragma) This directive is used to specify diverse options to the compiler.
These options are specific for the platform and the compiler you use.
Consult the manual or the reference of your compiler for more information on the possible parameters that you can define with #pragma.
If the compiler does not support a specific argument for #pragma, it is ignored - no error is generated.
Predefined macro names The following macro names are defined at any time: macro value __LINE__ Integer value representing the current  in the source code file being compiled.
All Cplus_plus compilers have this constant defined to some value.
If the compiler is fully compliant with the Cplus_plus standard its value is equal or greater than 199711L depending on the version of the standard they comply.
For example: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 137 © cplusplus_0_com 2008.
All rights reserved // standard macro names.
Its compilation began Nov  1 2005 at 10:12:29.
The compiler gives a __cplusplus value of 1 TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 138 © cplusplus_0_com 2008.
All rights reserved Cplus_plus Standard Library Input/Output with files Cplus_plus provides the following classes to perform output and input of characters to/from files:.
These classes are derived directly or indirectly from the classes istream, and ostream.
We have already used objects whose types were these classes: cin is an object of class istream and cout is an object of class ostream.
Therfore, we have already been using classes that are related to our file streams.
And in fact, we can use our file streams the same way we are already used to use cin and cout, with the only difference that we have to associate these streams with physical files.
Let's see an example:.
But let's go step by step: Open a file The first operation generally performed on an object of one of these classes is to associate it to a real file.
This procedure is known as to open a file.
An open file is represented within a program by a stream object (an instantiation of one of these classes, in the previous example this was myfile) and any input or output operation performed on this stream object will be applied to the physical file associated to it.
In order to open a file with a stream object we use its member function open(): open (filename, mode); Where filename is a null-terminated character sequence of type const char * (the same type that string literals have) representing the name of the file to be opened, and mode is an optional parameter with a combination of the following flags: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 139 © cplusplus_0_com 2008.
All rights reserved ios::in Open for input operations.
If this flag is not set to any value, the initial position is the beginning of the file.
This flag can only be used in streams open for output-only operations.
All these flags can be combined using the bitwise operator OR (|).
For example, if we want to open the file example_0_bin in binary mode to add data we could do it by the following call to member function open(): ofstream myfile; myfile_0_open ("example_0_bin", ios::out | ios::app | ios::binary); Each  of the open() member functions of the classes ofstream, ifstream and fstream has a default mode that is used if the file is opened without a second argument: class default mode parameter ofstream ios::out ifstream ios::in fstream ios::in | ios::out For ifstream and ofstream classes, ios::in and ios::out are automatically and respectively assumed, even if a mode that does not  them is passed as second argument to the open() member function.
The default value is only applied if the function is called without specifying any value for the mode parameter.
If the function is called with any value in that parameter the default mode is overridden, not combined.
File streams opened in binary mode perform input and output operations independently of any format considerations.
Non-binary files are known as text files, and some translations may occur due to formatting of some special characters (like newline and carriage return characters).
Since the first task that is performed on a file stream object is generally to open a file, these three classes a constructor that automatically calls the open() member function and has the exact same parameters as this member.
Therefore, we could also have declared the previous myfile object and conducted the same opening operation in our previous example by writing: ofstream myfile ("example_0_bin", ios::out | ios::app | ios::binary); Combining object construction and stream opening in a single statement.
Both forms to open a file are valid and equivalent.
To check if a file stream was successful opening a file, you can do it by calling to member is_open() with no arguments.
This member function returns a bool value of true in the case that indeed the stream object is associated with an open file, or false otherwise: if (myfile_0_is_open()) { /* ok, proceed with output */ } TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 140 © cplusplus_0_com 2008.
All rights reserved Closing a file When we are finished with our input and output operations on a file we shall close it so that its resources become available again.
In order to do that we have to call the stream's member function close().
This member function takes no parameters, and what it does is to flush the associated buffers and close the file: myfile_0_close(); Once this member function is called, the stream object can be used to open another file, and the file is available again to be opened by other processes.
In case that an object is destructed while still associated with an open file, the destructor automatically calls the member function close().
Text files Text file streams are those where we do not  the ios::binary flag in their opening mode.
These files are designed to store text and thus all values that we input or output from/to them can suffer some formatting transformations, which do not necessarily correspond to their literal binary value.
Data output operations on text files are performed in the same way we operated with cout: // writing on a text file # <iostream>.
Data input from a file can also be performed in the same way that we did with cin: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 141 © cplusplus_0_com 2008.
All rights reserved.
This last example reads a text file and prints out its content on the screen.
Notice how we have used a new member function, called eof() that returns true in the case that the end of the file has been reached.
We have created a while loop that finishes when indeed myfile_0_eof() becomes true (i_0_e_0_, the end of the file has been reached).
Checking state flags In addition to eof(), which checks if the end of file has been reached, other member functions exist to check the state of a stream (all of them return a bool value): bad() Returns true if a reading or writing operation fails.
For example in the case that we try to write to a file that is not open for writing or if the device where we try to write has no space left.
In order to reset the state flags checked by any of these member functions we have just seen we can use the member function clear(), which takes no parameters.
TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 142 © cplusplus_0_com 2008.
All rights reserved ofstream, like ostream, has a pointer known as the put pointer that points to the location where the next element has to be written.
Finally, fstream, inherits both, the get and the put pointers, from iostream (which is itself derived from both istream and ostream).
These internal stream pointers that point to the reading or writing locations within a stream can be manipulated using the following member functions: tellg() and tellp() These two member functions have no parameters and return a value of the member type pos_type, which is an integer data type representing the current position of the get stream pointer (in the case of tellg) or the put stream pointer (in the case of tellp).
Both functions are overloaded with two different prototypes.
The first prototype is: seekg ( position ); seekp ( position ); Using this prototype the stream pointer is changed to the absolute position position (counting from the beginning of the file).
The type for this parameter is the same as the one returned by functions tellg and tellp: the member type pos_type, which is an integer value.
The other prototype for these functions is: seekg ( offset, direction ); seekp ( offset, direction ); Using this prototype, the position of the get or put pointer is set to an offset value relative to some specific point determined by the parameter direction.
And direction is of type seekdir, which is an enumerated type (enum) that determines the point from where offset is counted from, and that can take any of the following values: ios::beg offset counted from the beginning of the stream ios::cur offset counted from the current position of the stream pointer ios::end offset counted from the end of the stream The following example uses the member functions we have just seen to obtain the size of a file: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 143 © cplusplus_0_com 2008.
All rights reserved.
Binary files In binary files, to input and output data with the extraction and insertion operators (<< and >>) and functions like getline is not efficient, since we do not need to format any data, and data may not use the separation codes used by text files to separate elements (like space, newline, etc_0__0__0_).
File streams  two member functions specifically designed to input and output binary data sequentially: write and read.
The first one (write) is a member function of ostream inherited by ofstream.
And read is a member function of istream that is inherited by ifstream.
Objects of class fstream have both members.
Their prototypes are: write ( memory_block, size ); read ( memory_block, size ); Where memory_block is of type "pointer to char" (char*), and represents the address of an array of bytes where the read data elements are stored or from where the data elements to be written are taken.
The size parameter is an integer value that specifies the number of characters to be read or written from/to the memory block.
Let's examine how this is done: TThhee  CCplus_plusplus_plus  LLaanngguuaaggee  TTuuttoorriiaall 144 © cplusplus_0_com 2008.
All rights reserved First, the file is open with the ios::ate flag, which means that the get pointer will be positioned at the  of the file.
This way, when we call to member tellg(), we will directly obtain the  of the file.
Notice the type we have used to declare variable : ifstream::pos_type ; ifstream::pos_type is a specific type used for buffer and file positioning and is the type returned by file_0_tellg().
This type is defined as an integer type, therefore we can conduct on it the same operations we conduct on any other integer value, and can safely be converted to another integer type large enough to contain the  of the file.
For a file with a  under 2GB we could use int: int ; = (int) file_0_tellg(); Once we have obtained the  of the file, we request the allocation of a memory block large enough to hold the entire file: = new []; Right after that, we proceed to set the get pointer at the beginning of the file (remember that we opened the file with this pointer at the ), then read the entire file, and finally close it: file_0_seekg (0, ios::beg); file_0_read (, ); file_0_close(); At this point we could operate with the data obtained from the file.
Our program simply announces that the content of the file is in memory and then terminates.
Buffers and Synchronization When we operate with file streams, these are associated to an internal buffer of type streambuf.
This buffer is a memory block that acts as an intermediary between the stream and the physical file.
For example, with an ofstream, each time the member function put (which writes a single character) is called, the character is not written directly to the physical file with which the stream is associated.
Instead of that, the character is inserted in that stream's intermediate buffer.
When the buffer is flushed, all the data contained in it is written to the physical medium (if it is an output stream) or simply freed (if it is an input stream).
This process is called synchronization and takes place under any of the following circumstances:.
When the file is closed: before closing a file all buffers that have not yet been flushed are synchronized and all pending data is written or read to the physical medium.
When the buffer is full: Buffers have a certain.
When the buffer is full it is automatically synchronized.
Explicitly, with manipulators: When certain manipulators are used on streams, an explicit synchronization takes place.
These manipulators are: flush and endl.
Explicitly, with member function sync(): Calling stream's member function sync(), which takes no parameters, causes an immediate synchronization.
This function returns an int value equal to -1 if the stream has no associated buffer or in case of failure.
Otherwise (if the stream buffer was successfully synchronized) it returns 0.