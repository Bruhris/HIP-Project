Southern Adventist University.
Legal Notices and Information.
Permission is hereby granted to make hardcopies and freely distribute the material herein under the following conditions:.
The copyright and this legal notice must appear in any copies of this document made in whole or in part.
None of material herein can be sold or otherwise distributed for commercial purposes without written permission of the copyright holder.
Instructors at any educational institution may freely use this document in their classes as a primary or optional textbook under the conditions specified above.
A local electronic copy of this document may be made under the terms specified for hard copies:.
The copyright and these terms of use must appear in any electronic representation of this document made in whole or in part.
None of material herein can be sold or otherwise distributed in an electronic form for commercial purposes without written permission of the copyright holder.
Instructors at any educational institution may freely store this document in electronic form on a local server as a primary or optional textbook under the conditions specified above.
Additionally, a hardcopy or a local electronic copy must contain the uniform resource locator (URL).
Simply send a message to halterman@southern.
A computer program, from one perspective, is a sequence of instructions that dictate the flow of electri¬ cal impulses within a computer system.
These impulses affect the computer's memory and interact with the display screen, keyboard, mouse, and perhaps even other computers across a network in such a way as to produce the "magic" that permits humans to perform useful tasks, solve high-level problems, and play games.
One program allows a computer to assume the role of a financial calculator, while another transforms the machine into a worthy chess opponent.
Note the two extremes here:.
So well is the higher-level illusion achieved that most computer users are oblivious to the lower-level activity (the machinery under the hood, so to speak).
Surprisingly, perhaps, most programmers today write software at this higher, more abstract level also.
An accomplished computer programmer can develop sophisticated software with little or no interest or knowledge of the actual computer system upon which it runs.
Powerful software construction tools hide the lower-level details from programmers, allowing them to solve problems in higher-level terms.
The concepts of computer programming are logical and mathematical in nature.
In theory, computer programs can be developed without the use of a computer.
Programmers can discuss the viability of a program and reason about its correctness and efficiency by examining abstract symbols that correspond to the features of real-world programming languages but appear in no real-world programming language.
While such exercises can be very valuable, in practice computer programmers are not isolated from their machines.
Software is written to be used on real computer systems.
Computing professionals known as software engineers develop software to drive particular systems.
These systems are defined by their underlying hardware and operating system.
Developers use concrete tools like compilers, debuggers, and profilers.
This chapter examines the context of software development, including computer systems and tools.
Software makes a computer a truly universal machine transforming it into the proper tool for the task at hand.
One can refer to a program as a piece of software as if it were a tangible object, but software is actually quite intangible.
It is stored on a medium.
A hard drive, a CD, a DVD, and a USB pen drive are all examples of media upon which software can reside.
The CD is not the software; the software is a pattern on the CD.
In order to be used, software must be stored in the computer's memory.
Typically computer programs are loaded into memory from a medium like the computer's hard disk.
An electromagnetic pattern representing the program is stored on the computer's hard drive.
This pattern of electronic symbols must be transferred to the computer's memory before the program can be executed.
The program may have been installed on the hard disk from a CD or from the Internet.
In any case, the essence that was transferred from medium to medium was a pattern of electronic symbols that direct the work of the computer system.
These patterns of electronic symbols are best represented as a sequence of zeroes and ones, digits from the binary (base 2) number system.
An example of a binary program sequence is 10001011011000010001000001001110 To the underlying computer hardware, specifically the processor, a zero here and three ones there might mean that certain electrical signals should be sent to the graphics device so that it makes a certain part of the display screen red.
Unfortunately, only a minuscule number of people in the world would be able to produce, by hand, the complete sequence of zeroes and ones that represent the program Microsoft Word for an Intel-based computer running the Windows 8 operating system.
Further, almost none of those who could produce the binary sequence would claim to enjoy the task.
The Word program for older Mac OS X computers using a PowerPC processor works similarly to the Windows version and indeed is produced by the same company, but the program is expressed in a com¬ pletely different sequence of zeroes and ones.
The Intel Core i7 processor in the Windows machine accepts a completely different binary language than the PowerPC processor in the Mac.
We say the processors have their own machine language.
If very few humans can (or want) to speak the machine language of the computers' processors and software is expressed in this language, how has so much software been developed over the years.
Software can be represented by printed words and symbols that are easier for humans to manage than binary sequences.
Tools exist that automatically convert a higher-level description of what is to be done into the required lower-level code.
Higher-level programming languages like Cplus_plus allow programmers to express solutions to programming problems in terms that are much closer to a natural language like English.
Some examples of the more popular of the hundreds of higher-level programming languages that have been devised over the past 60 years include FORTRAN, COBOL, Lisp, Haskell, C, Perl, Python, Java, and C#.
Most programmers today, especially those concerned with high-level applications, usually do not worry about the details of underlying hardware platform and its machine language.
One might think that ideally such a conversion tool would accept a description in a natural language, such as English, and produce the desired executable code.
This is not possible today because natural languages are quite complex compared to computer programming languages.
Programs called compilers that translate one computer language into another have been around for over 60 years, but natural language.
Natural languages, as they are used by most humans, are inherently ambiguous.
To understand properly all but a very limited subset of a natural language, a human (or artificially intelligent computer system) requires a vast amount of background knowledge that is beyond the capabilities of today's software.
Fortunately, programming languages provide a relatively simple structure with very strict rules for forming statements that can express a solution to any problem that can be solved by a computer.
Consider the following program fragment written in the Cplus_plus programming language:.
The statements in this program fragment look similar to expressions in algebra.
We see no sequence of bi¬ nary digits.
Three words, , , and , called variables, are used to hold information.
Mathematicians have used variables for hundreds of years before the first digital computer was built.
In programming, a variable represents a value stored in the computer's memory.
Since this program is expressed in the Cplus_plus language, not  language, it cannot be executed directly on any processor.
A Cplus_plus compiler is used to translate the Cplus_plus code into  code.
The higher-level language code is called source code.
The compiled  language code is called the target code.
The compiler translates the source code into the target  language.
The beauty of higher-level languages is this: the same Cplus_plus source code can be compiled to different target platforms.
The target  must have a Cplus_plus compiler available.
Minor changes in the source code may be required because of architectural differences in the platforms, but the work to move the program from one  to another is far less than would be necessary if the program for the new  had to be rewritten by hand in the new  language.
Just as importantly, when writing the program the human programmer is free to think about writing the solution to the problem in Cplus_plus, not in a specific language.
Programmers have a variety of tools available to enhance the software development process.
Some common tools include:.
An editor allows the user to enter the program source code and save it to files.
Most pro¬ gramming editors increase programmer productivity by using colors to highlight language features.
The syntax of a language refers to the way pieces of the language are arranged to make well-formed sentences.
To illustrate, the sentence The tall boy runs quickly to the door.
Boy the tall runs door to quickly the.
It uses the same words as the original sentence, but their arrangement does not follow the rules of English.
Similarly, programmers must follow strict syntax rules to create well-formed computer programs.
Only well-formed programs are acceptable and can be compiled and executed.
Some syntax-aware editors can use colors or other special annotations to alert programmers of syntax errors before the program is compiled.
A compiler translates the source code to target code.
The target code may be the language for a particular  or embedded device.
The target code could be another source language; for example, the earliest Cplus_plus compiler translated Cplus_plus into C, another higher-level language.
The resulting C code was then processed by a C compiler to produce an executable program.
Cplus_plus compilers today translate Cplus_plus directly into  language.
The complete set of build tools for Cplus_plus includes a preprocessor, compiler, and linker: - Preprocessor —adds to or modifies the contents of the source file before the compiler begins processing the code.
We use the services of the preprocessor mainly to #i nclude information about library routines our programs use.
Most compiled Cplus_plus code is incapable of running by itself and needs some additional  code to make a complete executable program.
The missing  code has been precompiled and stored in a repository of code called a library.
A program called a linker combines the programmer's compiled code and the library code to make a complete program.
We generally do not think about the preprocessor, compiler, and linker working as three separate programs (although they do); the tools we use make it appear as only one process is taking place: translating our source code to an executable program.
A debugger allows a programmer to more easily trace a program's execution in order to locate and correct errors in the program's implementation.
With a debugger, a developer can simultaneously run a program and see which line in the source code is responsible for the program's current actions.
The programmer can watch the values of variables and other program elements to see if their values change as expected.
Debuggers are valuable for locating errors (also called bags ) and repairing programs that contain errors.
A profiler collects statistics about a program's execution allowing developers to tune ap¬ propriate parts of the program to improve its overall performance.
A profiler indicates how many times a portion of a program is executed during a particular run, and how long that portion takes to execute.
Profilers also can be used for testing purposes to ensure all the code in a program is actually being used somewhere during testing.
This is known as coverage.
It is common for software to fail after its release because users exercise some part of the program that was not executed anytime during testing.
The main purpose of profiling is to find the parts of a program that can be improved to make the program run faster.
The programming components of the development process are illustrated in Figure j 1,11 Many developers use integrated development environments (IDEs).
An IDE includes editors, debug¬ gers, and other programming aids in one comprehensive program.
Examples of IDEs for Cplus_plus include Microsoft's Visual Studio 2015, the Eclipse Foundation's Eclipse CDT, and Apple's XCode.
Despite the plethora of tools (and tool vendors' claims), the programming process for all but trivial programs is not automatic.
Good tools are valuable and certainly increase the productivity of developers, but they cannot write software.
There are no substitutes for sound logical thinking, creativity, common sense, and, of course, programming experience.
Cplus_plus is an extension of the programming language C, a product of AT&T Bell Labs from the early 1970s.
C was developed to write the Unix operating system, and C is widely used for systems-level software and embedded systems development.
Cplus_plus initially provided object-oriented programming features (see Chapter jT3] and Chapter [T_0_) and later added generic programming capabilities.
Cplus_plus's close relationship to C allows Cplus_plus programs to utilize a large collection of code developed in C.
Cplus_plus is widely used in industry for commercial software development.
It is an industrial strength pro¬ gramming language used for developing complex systems in business, science, and engineering.
Examples of software written in Cplus_plus include Microsoft Windows 8, Microsoft Office, macOS, and Adobe Creative Suite.
In order to meet the needs of commercial software development and accomplish all that it does, Cplus_plus itself is complex.
While experienced programmers can accomplish great things with Cplus_plus, beginners some¬ times have a difficult time with it.
Professional software developers enjoy the flexible design options that Cplus_plus permits, but beginners need more structure and fewer options so they can master simpler concepts before moving on to more complex ones.
This book does not attempt to cover all the facets of the Cplus_plus programming language.
Experienced programmers should look elsewhere for books that cover Cplus_plus in much more detail.
The focus here is on introducing programming techniques and developing good habits.
To that end, our approach avoids some of the more esoteric features of Cplus_plus and concentrates on the programming basics that transfer directly to other imperative programming languages such as Java, C#, and Python.
We stick with the basics and explore more advanced features of Cplus_plus only when necessary to handle the problem at hand.
List several advantages developing software in a higher-level language has over developing software in machine language.
How can an IDE improve a programmer's productivity.
Properly written Cplus_plus programs have a particular structure.
The syntax must be correct, or the compiler will generate error messages and not produce executable machine language.
This chapter introduces Cplus_plus by providing some simple example programs and associated fundamental concepts.
Most of the concepts presented in this chapter are valid in many other programming languages as well.
While other languages may implement the concepts using slightly different syntax, the ideas are directly transferable to other languages like C, Java, C#, and Ada.
The actual name of the file is irrelevant, but the name "simple" accurately describes the nature of this program.
The extension _0_cpp is a common extension used for Cplus_plus source code.
After creating this file with a text editor and compiling it, you can run the program.
The program prints the message.
This one directs the preprocessor to add some predefined source code to our existing.
This process is done automatically and is invisible to us.
Here we want to use an object from the i ostream library, a collection precompiled Cplus_plus code that Cplus_plus programs (like ours) can use.
The iostream library contains elements that handle input and output (I/O)—printing to the display, getting user input from the keyboard, and dealing with files.
One of the items used in Listing 2_0_1 (simple_0_cpp), std : : cout, is not part of the Cplus_plus language itself.
This item, along with other things related to input and output, were developed in Cplus_plus, compiled, and stored in the i ostream library.
The compiler needs to be aware of these i ostream items so it can compile our program.
The #i nclude directive specifies a file, called a header , that contains the specifications for the library code.
The compiler checks how we use std : : cout within our code against its specification in the <iostream> header to ensure that we are using the library code correctly.
Most of the programs we write use this #i nclude <iostream> directive, and some programs.
Here we are declaring a function named main.
All Cplus_plus programs must contain this function to be executable.
Details about the meaning of i nt and the parentheses will appear in later chapters.
More general information about functions appear in Chapter Sjand Chapter 9' The opening curly brace at the end of the line marks the beginning of the body of a function.
The body of a function contains the statements the function is to execute.
This statement directs the executing program to print the message This is a simple C+ + program.
A statement is the fundamental unit of execution in a Cplus_plus program.
Functions contain statements that the compiler translates into executable machine language instructions.
Cplus_plus has a variety of different kinds of statements, and the chapters that follow explore these various kinds of statements.
All statements in Cplus_plus end with a semicolon (;).
A more detailed explanation of this statement appears below.
Note which lines in the program end with a semicolon (;) and which do not.
Do not put a semicolon after the #include preprocessor directive.
Do not put a semicolon on the line containing mai n, and do not put semicolons after the curly braces.
One option involves a commandline environment with a collection of independent tools.
The other option is to use an IDE (see Section [172) which combines all the tools into a convenient package.
Visual Studio is the dominant IDE on the Microsoft.
Windows platform, and Apple Mac developers often use the XCode IDE.
AppendixJA provides an overview of how to use the Visual Studio 2015 IDE to develop a simple Cplus_plus program.
The myriad of features and configuration options in these powerful IDEs can be bewildering to those learning how to program.
In a command-line environment the programmer needs only type a few simple commands into a console window to edit, compile, and execute programs.
Some developers prefer the simplicity and flexibility of command-line build environments, especially for less complex projects.
One prominent command-line build system is the GNU Compiler Collection (http : //gcc.
The GCC Cplus_plus compiler, called gplus_plus, is one of most Cplus_plus standards conforming compilers available.
The GCC Cplus_plus compiler toolset is available for the Microsoft Windows, Apple Mac, and Linux platforms, and it is a free, open-source software project with a world-wide development team.
Appendix [Bjprovides an overview of how to use the GCC Cplus_plus compiler.
Visual Studio and XCode offer command line development options as well.
Appendix [Bjprovides an overview of the Visual Studio command line development process.
We can omit the std : : prefix and use the shorter name, cout.
This directive is optional, but if we omit it, we must use the longer name.
The name std stands for "standard," and the std prefix indicates that cout is part of a collection of names called the standard namespace.
The std namespace holds names for all the standard Cplus_plus types and functions that must be available to all standards-conforming Cplus_plus development environments.
Components outside the standard library provided by third-party develop¬ ers reside in their own separately-named namespaces.
These include open-source projects and commercial libraries.
This approach offers some advantages for smaller programs, such as examples in books and online tutorials.
This blanket usi ng directive allows programmers to use shorter names as in the more more focused using directives, and it also can use fewer lines of code than the more focused usi ng directives, especially when the program uses multiple elements from the std namespace.
Our choice of usi ng directives (or not) makes no difference in our final product, the executable pro¬ gram.
The compiler generates the same machine language code for all three versions—no using, focused usi ng, and blanket usi ng.
We thus must select an approach that enhances our ability to write and manage our software projects.
It is important to note that while this blanket usi ng approach has its place, its use generally is dis¬ couraged for more complex software projects.
At this point we cannot fully appreciate the rationale for avoiding the usi ng namespace std directive, but later, in Section 20_0_6 we will have enough experi¬ ence to understand the disadvantages of the blanket usi ng namespace std directive.
We will strive for best practices from the start and avoid the blanket usi ng statement.
We generally will use the full names of the elements in the std namespace and use the more focused using directives in our code when it makes sense to do so.
The statement in the mai n function in any of the three versions of our program uses the services of an object called std : : cout.
The std : : cout object prints text on the computer's screen.
The text of the message as it appears in the Cplus_plus source code is called a string, for string of characters.
Strings are enclosed within quotation marks (").
The symbols << make up the insertion operator.
You can think of the message to be printed as being "inserted" into the cout object.
The cout object represents the output stream; that is, text that the program prints to the console window.
The end of the message contains the symbol sequence \n.
This known as a character escape sequence, and this combination of backslash and the letter n represents the newline character.
It indicates that the printing on that line is complete, and any subsequent printing should occur on the next line.
This newline character effectively causes the cursor to move down to the next line.
If you read the statement from left to right, the cout object, which is responsible for displaying text on the screen, receives the text to print terminated with the newline character to move to the next line.
For simplicity, we'll refer to this type of statement as a print statement, even though the word print does not appear anywhere in the statement.
With minor exceptions, any statement in Cplus_plus must appear within a function definition.
Our single print statement appears within the function named main.
Any function, including mai n, may contain multiple statements.
In Listing 2_0_4 (arrow_0_cpp), six print statements draw an arrow on the screen:.
The body consists of all the statements between the open curly brace ({) and close curly brace (}).
We say that the curly braces delimit the body of the function.
The word delimit means to determine the boundaries or limits of something.
The { symbol determines the beginning of the function's body, and the } symbol specifies the end of the function's body.
Listing pL4] (arrow_0_cpp) and Listing |2T5| (arrow2_0_cpp) may appear to be identical, but upon closer inspection of this new  we see that std : : cout appears only once within mai n, and only one semicolon (;) appears within mai n.
Since semicolons in Cplus_plus terminate statements, there really is only one statement.
Notice that a single statement can be spread out over several lines.
The statement within mai n appearing as.
Read this second version.
Since Listing |X6| (empty_0_cpp) does not use the std : : cout object and so does not need the #i nclude and usi ng directives.
While it is legal and sometimes even useful in Cplus_plus to write functions with empty bodies, such functions will do nothing when they execute.
Listing 2_0_6 (empty_0_cpp) with its empty mai n function is, therefore, truly the simplest executable Cplus_plus  we can write, but it does nothing when we runs it.
In general, a Cplus_plus  may contain multiple functions, but we defer such generality until Chapter|9j For now, we will restrict our attention to programs with only amain function.
For our immediate purposes all the programs we write will have the form shown in Figure [271 [ Our programs generally will print something, so we need the #  directive that brings the std : : cout definition from <i ostream> into our.
Depending on what we need our to do, we may need additional #i nclude directives.
The mai n function definition is required for an executable , and we will fill its body with statements that make our  do as we wish.
Later, our programs will become more sophisticated, and we will need to augment this simple template.
What preprocessor directive is necessary to use statements with the std: :cout printing stream object.
What  allows the short name cout to be used instead of std : : cout.
Write a Cplus_plus program that prints your name in the console window.
Write a Cplus_plus program that prints your first and last name in the console window.
Your first name should appear on one line, and your last name appear on the next line.
What other files must you distribute with your executable file so that your program will run on a Windows PC without Visual Studio installed.
Can a single  in Cplus_plus span multiple lines in the source code.
In this chapter we explore some building blocks that are used to develop Cplus_plus programs.
Integers are whole numbers, which means they have no fractional parts, and an integer can be positive, negative, or zero.
Examples of integers include 4, —19, 0, and —1005.
In contrast, 4_0_5 is not an integer, since it is not a whole number.
Cplus_plus supports a number of numeric and non-numeric values.
In particular, Cplus_plus programs can use integer.
Notice that unlike the programs we saw earlier.
Listing |3T| (number4_0_cpp) does not use quotation marks (").
The number 4 appears unadorned with no quotes.
The expression ' \ n ' represents a single newline character.
Multiple characters comprising a string appear in double quotes ("), but, in Cplus_plus, a single character represents a distinct type of data and is enclosed within single quotes (').
Both programs behave identically, but Listing |3T| (number4_0_cpp) prints the value of the number four, while Listing|3_0_2|(number4-alt_0_cpp) prints a message containing the digit four.
The distinction here seems unim¬ portant, but we will see in Section [372] that the presence or absence of the quotes can make a big difference in the output.
The std : : endl expression does involve a newline character, but it also performs some additional work that normally is not necessary.
Programs that do significant printing may execute faster if they terminate their output lines with ' \ n ' instead of std: :endl.
The difference in speed is neg¬ ligible when printing to the console, but the different can be great when printing to hies or other output streams.
For most of the programs we consider, the differ¬ ence in program execution speed between the two is imperceptible; nonetheless, we will prefer ' \ n ' for printing newlines because it is a good habit to form (and it requires five fewer keystrokes when editing code).
The three major modern computing platforms are Microsoft Windows, Apple macOS, and Linux.
Windows handles newlines differently from macOS and Linux.
Historically, the character ' \ n' represents a  , usually known as a feed or LF for short, and the character 1 \ r ' means carriage return, or CR for short.
The terminology comes from old-fashioned typewriters which feed a piece of paper into a roller on a carriage that moves to the left as the user types (so the imprinted symbols form left to right).
At the end of a , the user must advance the roller so as to move the paper up by one  (LF) and move the carriage back all the way to its left (CR).
Windows uses the character sequence CR LF for ¬ lines, while macOS and Linux use LF.
This can be an issue when attempting to edit text hies written with an editor on one platform with an editor on a different platform.
The good news is that the Cplus_plus standard guarantees that the std : : cout output stream translates the ' \ n' character as it appears in Cplus_plus source code into the correct character sequence for the target platform.
This means you can print ' \ n 1 via std : : cout, and it will behave identically on all the major platforms.
In Cplus_plus source code, integers may not contain commas.
This means we must write the number two thousand, four hundred sixty-eight as 2468, not 2,468.
Modern Cplus_plus does support single quotes ( ' ) as digit separators, as in 2 ' 468.
Using digit separators can improve the human comprehension reading large numbers in Cplus_plus source code.
In mathematics, integers are unbounded; said another way, the set of mathematical integers is infinite.
In Cplus_plus the range of integers is limited because all computers have a finite amount of memory.
The exact range of integers supported depends on the computer system and particular Cplus_plus compiler.
Cplus_plus on most 32-bit computer systems can represent integers in the range —2,147,483,648 to +2,147,483,647.
The number printed was not even negative.
Most Cplus_plus compilers will issue a warning about this statement.
Section |4~6| explores errors vs.
If the compiler finds an error in the source, it will not generate the executable code.
A warning indicates a potential problem and does not stop the compiler from producing an executable program.
Here we see that the programmer should heed this warning because the program's execution produces meaningless output.
This limited range of values is common among programming languages since each number is stored in a fixed amount of memory.
Larger numbers require more storage in memory.
In order to model the infinite set of mathematical integers an infinite amount of memory would be needed.
As we will see later, Cplus_plus supports an integer type with a greater range.
Section 4,8_0_1 ' provides some details about the implementation of Cplus_plus integers.
The same is true in Cplus_plus, except Cplus_plus variables also can represent values other than numbers.
Listing |T4] (variable_0_cpp) uses a variable to store an integer value and.
All variables in a Cplus_plus program must be declared.
A declaration specifies the type of a variable.
The word i nt indicates that the variable is an integer.
The name of the integer variable is x.
We say that variable x has type i nt.
Cplus_plus supports types other than integers, and some types require more or less space in the computer's memory.
The compiler uses the declaration to reserve the proper amount of memory to store the variable's value.
The declaration enables the compiler to verify the programmer is using the variable properly within the program; for example, we will see that integers can be added together just like in mathematics.
For some other data types, however, addition is not possible and so is not allowed.
The compiler can ensure that a variable involved in an addition operation is compatible with addition.
It can report an error if it is not.
The compiler will issue an error if a programmer attempts to use an undeclared variable.
The com¬ piler cannot deduce the storage requirements and cannot verify the variable's proper usage if it not declared.
Once declared, a particular variable cannot be redeclared in the same context.
A variable may not change its type during its lifetime.
An assignment statement associates a value with a variable.
The key to an assignment statement is the  = which is known as the assignment operator.
Here the value 10 is being assigned to the variable.
This means the value 10 will be stored in the memory location the compiler has reserved for the variable named.
We need not be concerned about where the variable is stored in memory; the compiler takes care of that detail.
After we declare a variable we may assign and reassign it as often as necessary.
The meaning of the assignment  (=) is different from equality in mathematics.
It is best to read  = 5 as " is assigned the value 5," or " gets the value 5_0_" This distinction is important since in mathematics equality is symmetric: if  = 5, we  5 =.
Such a statement will produce a compiler error: error 2106: '= ': left operand must be l-value.
Observe the each print statement in Listing [33| (multipleassignment_0_cpp) is identical, but when the program.
We introduce objects in Chapter[13]and Chapter|T4| Multiple variables of the same type can be declared and, if desired, initialized in a single statement.
The following statements declare three variables in one declaration statement: int , y, ; The following statement declares three integer variables and initializes two of them: int  = 0, y,  = 5; Here y's value is undefined.
The declarations may be split up into multiple declaration statements: int  = 0; int y; int  = 5; the case of multiple declaration statements the type name (here i nt) must appear in each statement.
The compiler maps  variable to  location in the computer's memory.
We can visualize  variable and its corresponding memory location as  box as shown in Figure |3_0_1| We name the box with the variable's name.
Figure [3_0_2[ shows how the following sequence of  code affects memory.
After this statement  and  still refer to separate boxes (memory locations).
It simply means the value stored in 's box (memory location) has been copied to 's box (memory location),  and  remain distinct boxes (memory locations).
The original value found in 's box is overwritten when the contents of 's box are copied into.
After the assignment of  to , the reassignment of  to 4 does not affect.
Names such as alti tude, sum, and user_name are much better than the equally permissible , s, and u.
A variable's name should be related to its purpose within the program.
Good variable names make programs more readable by humans.
Since programs often contain many variables, well-chosen variable names can render an otherwise obscure collection of symbols more understandable.
A variable name is one example of an identifier.
An identifier is  word used to name things.
One of the things an identifier can name is  variable.
We will see in later chapters that identifiers name other things such as functions and classes.
Identifiers have the following form:.
The remaining characters (if any) may be alphabetic characters (upper or lower case), the underscore, or  digit ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghij klmnopqrstuvwxyz_0123456789.
Here are some examples of valid and invalid identifiers:.
All of the following words are valid identifiers and so qualify as variable names: , 2, total, port_22, and FLAG.
None of the following words are valid identifiers: sub-total (dash is not  legal symbol in an identifier), first entry (space is not  legal symbol in an identifier), 4all (begins with  digit), #2 (pound sign is not  legal symbol in an identifier), and class (class is  reserved word).
Cplus_plus reserves  number of words for special use that could otherwise be used as identifiers.
Called reserved words or keywords , these words are special and are used to define the structure of Cplus_plus programs and statements.
Table 13_0_1 [ lists all the Cplus_plus reserved words.
The purposes of many of these reserved words are revealed throughout this book.
You may not use any of the reserved words in Table [3711| as identifiers.
Fortunately, if you accidentally attempt to use one of the reserved words in  program as  variable name, the compiler will issue an error (see Section |4_0_6| for more on compiler errors).
In Listing 2_0_1 (simple_0_cpp) we used several reserved words: usi ng, namespace, and i nt.
Notice that i nclude, cout, and mai n are not reserved words.
Some programming languages do not require programmers to declare variables before they are used; the type of  variable is determined by how the variable is used.
Some languages allow the same variable.
Such languages are known as dynamically-typed languages.
Cplus_plus is a statically-typed language.
In a statically-typed language, the type of a variable must be explicitly specified before it is used by statements in a program.
While the requirement to declare all variables may initially seem like a minor annoyance, it offers several advantages:.
When variables must be declared, the compiler can catch typographical errors that dynamically-typed languages cannot detect.
For example, consider the following section of code: int ; = 1; The identifier in the first line ends with a capital "Oh_0_" In the second line, the identifier ends with the digit zero.
The distinction may be difficult or impossible to see in a particular editor or printout of the code.
A Cplus_plus compiler would immediately detect the typo in the second statement, since (last letter a zero) has not been declared.
A dynamically-typed language would create two variables: and.
When variables must be declared, the compiler can catch invalid operations.
For example, a variable may be declared to be of type i nt, but the programmer may accidentally assign a non-numeric value to the variable.
In a dynamically-typed language, the variable would silently change its type introducing an error into the program.
In Cplus_plus, the compiler would report the improper assignment as error, since once declared a Cplus_plus variable cannot change its type.
Ideally, requiring the programmer to declare variables forces the programmer to plan ahead and think more carefully about the variables a program might require.
The purpose of a variable is tied to its type, so the programmer must have a clear notion of the variable's purpose before declaring it.
The programmer need not do the simple double check of the variable's purpose that writing the variable's declaration requires.
While declaring the type of a variable specifies its purpose in only a very limited way, any opportunity to catch such errors is beneficial.
Statically-typed languages are generally more efficient than dynamically-typed languages.
The com¬ piler knows how much storage a variable requires based on its type.
The space for that variable's value will not change over the life of the variable, since its type cannot change.
In a dynamically typed language that allows a variable to change its type, if a variable's type changes during program execution, the storage it requires may change also, so memory for that variable must be allocated elsewhere to hold the different type.
This memory reallocation at run time slows down the program's execution.
Cplus_plus is a case-sensitive language.
This means that capitalization matters, i f is a reserved word, but none of If, IF, or i F are reserved words.
Identifiers are case sensitive also; the variable called Name is different from the variable called name.
Since it can be confusing to human readers, you should not distinguish variables merely by names that differ in capitalization.
For the same reason, it is considered poor practice to give a variable the same name as a reserved word with one or more of its letters capitalized.
The type short i nt, which may be written as just short, represents integers that may occupy fewer bytes of memory than the i nt type.
If the short type occupies less memory, it necessarily must represent a smaller range of integer values than the i nt type.
The Cplus_plus standard does not require the short type to be smaller than the i nt type; in fact, they may represent the same set of integer values.
The Tong i nt type, which may be written as just long, may occupy more storage than the i nt type and thus be able to represent a larger range of values.
Again, the standard does not require the long type to be bigger then the i nt type.
Finally, the long long int type, or just long long, may be larger than a long.
The Cplus_plus standard guarantees the following relative ranges of values hold: short int < int < long int < long long int On a small embedded device, for example, all of these types may occupy the exact same amount of memory and, thus, there would be no advantage of using one type over another.
On most systems, however, there will some differences in the ranges.
Cplus_plus provides integer-like types that exclude negative numbers.
These types include the word unsigned in their names, meaning they do not allow a negative sign.
The unsigned types come in various potential sizes in the same manner as the signed types.
The Cplus_plus standard guarantees the following relative ranges of unsigned values: unsigned short < unsigned < unsigned long < unsigned long long Table |3_0_2| lists the differences among the signed and unsigned integer types in Visual Cplus_plus.
Notice that the corresponding signed and unsigned integer times occupy the same amount of memory.
As a result, the unsigned types provide twice the range of positive values available to their signed counterparts.
For applications that do not require negative numbers, the unsigned type may be a more appropriate option.
Within the source code, any unadorned numerical literal without a decimal point is interpreted as an.
In order to represent 4456 as an long, append an L, as in long  = 4456L; Cplus_plus also permits the lower-case l ( elle ), as in long  = 44561; but you should avoid it since on many display and printer fonts it looks too much like the digit 1 (one).
Use the LL suffix for long long literals.
The suffixes for the unsigned integers are u (unsi gned), us (unsigned short), uL (unsigned long), and uLL (unsi gned long long).
The capitalization is unimportant, although capital Ls are preferred.
Many computational tasks require numbers that have fractional parts.
For example, the formula from math¬ ematics to compute the area of a circle given the circle's radius, involves the value 7t, which is approximately 3_0_14159.
Cplus_plus supports such non-integer numbers, and they are called floating-point numbers.
The name comes from the fact that during mathematical calculations the decimal point can move or "float" to vari¬ ous positions within the number to maintain the proper number of significant digits.
The types float and double represent different types of floating-point numbers.
The type double is used more often, since it stands for "double-precision floating-point," and it can represent a wider range of values with more digits of.
The first line in Listing 3_0_8 (-print_0_cpp) declares a variable named  and assigns it a value.
The second line in Listing 3_0_8 (-print_0_cpp) prints the value of the variable , and the third line prints a literal value.
Any literal numeric value with a decimal point in a Cplus_plus program automatically has the type double, so 3_0_14 has type double.
To make a literal floating-point value a float, you must append an f or F to the number, as in 3_0_14f.
Floating-point numbers are an approximation of mathematical real numbers.
As in the case of the i nt data type, the range of floating-point numbers is limited, since each value requires a fixed amount of memory.
In some ways, though, i nts are very different from doubles.
Any integer within the range of the i nt data type can be represented exactly.
This is not true for the floating-point types.
Consider the real number K.
Since 7t contains an infinite number of digits, a floating-point number with finite precision can only approximate its value.
Since the number of digits available is limited, even numbers with a finite number of digits have no exact representation; for example, the number 23_0_3123400654033989 contains too many digits for the double type and must be approximated as 23_0_3023498654034.
Section 4_0_8_0_2 contains more information about the consequences of the inexact nature of floating-point numbers.
We can express floating-point numbers in scientific notation.
Since most programming editors do not.
The number to the left of the e (we can use capital E as well) is.
In Listing |3_0_9| (scientificnotation_0_cpp), Avogadro's  and the speed of  are scientific constants; that is, to the degree of precision to which they have been measured and/or calculated, they do not vary.
Cplus_plus supports named constants.
Constants are declared like variables with the addition of the const keyword: const double  = 3_0_14159; Once declared and initialized, a constant can be used like a variable in all but one way—a constant may not be reassigned.
It is illegal for a constant to appear on the left side of the assignment  (=) outside its declaration statement.
A subsequent statement like = 2_0_5;.
By convention, Cplus_plus programmers generally express constant names in all capital letters; in this way, within the source code a human reader can distinguish a constant quickly from a variable.
Cplus_plus supports several other numeric data types:.
It is guaranteed to provide a range of integer values at least as large as the i nt type.
An integer literal with a L suffix, as in 19L, has type long.
A lower case elle (1) is allowed as a suffix as well, but you should not use it because it is difficult for human readers to distinguish between 1 (lower case elle) and 1 (digit one).
Attempting to do so would change the name of the variable_0_).
It is guaranteed that the range of i nts is at least as big as the range of shorts.
While the unsigned type is limited in nonnegative values, it can represent twice as many positive values as the i nt type.
While the Cplus_plus language standard specifies minimum ranges and precision for all the numeric data types, a particular Cplus_plus compiler may exceed the specified minimums.
Cplus_plus provides such a variety of numeric types for specialized purposes usually related to building highly efficient programs.
We will have little need to use many of these types.
Our examples will use mainly the numeric types i nt for integers, double for an approximation of real numbers, and, less frequently, unsi gned when nonnegative integral values are needed.
The char data type is used to represent single characters: letters of the alphabet (both upper and lower case), digits, punctuation, and control characters (like newline and tab characters).
Most systems support the American Standard Code for Information Interchange (ASCII) character set.
Standard ASCII can represent 128 different characters.
Table 13_0_41 lists the ASCII codes for various characters.
In Cplus_plus source code, characters are enclosed by single quotes ( ' ), as in.
Standard (double) quotes (") are reserved for strings, which are composed of characters, but strings and.
The value 65 is the ASCII code for the character A.
If  is printed, as in = 65; std::cout << ; the corresponding character.
A, would be printed because 's declared type is char, not i nt or some other numeric type.
A, A, A The first A is printed because the statement = 65;.
The second A is printed because the statement.
The third A is printed because the literal character ' A' is sent directly to the output stream.
Integers and characters can be freely assigned to each other, but the range of chars is much smaller than the range of i nts, so care must be taken when assigning an i nt value to a cha r variable.
Some characters are non-printable characters.
The ASCII chart lists several common non-printable characters: 1 \ n ' —the newline character 1 \ r ' —the carriage return character 1 \ b ' —the backspace character 1 \ a ' —the "alert" character (causes a "beep" sound or other tone on some systems) 1 \ t' —the tab character 1 \ f' —the formfeed character.
These special non-printable characters begin with a backslash (\) symbol.
The backslash is called an escape symbol, and it signifies that the symbol that follows has a special meaning and should not be interpreted literally.
This means the literal backslash character must be represented as two backslashes: 'W.
These special non-printable character codes can be embedded within strings.
To embed a backslash within a string, you must escape it; for example, the statement.
The following two statements behave identically: std::cout << "End of line" << '\n' ; std::cout << "End of line\n"; On the Microsoft Windows platform, the character sequence "\r\n" (carriage return, line feed) appears at the end of lines in text files.
Under Unix and Linux, lines in text files end with ' \ n ' (line feed).
On Apple Macintosh systems, text file lines end with the ' \ r ' (carriage return) character.
The compilers that adhere to the Cplus_plus standard will ensure that the ' \ n ' character in a Cplus_plus program when sent to the output stream will produce the correct end-of-line character sequence for the given platform.
Such a  is called an enumerated  , or an enumeration.
The enum keyword introduces an enumerated.
The values listed with the curly braces constitute all the values that a variable of the enumerated can attain.
The name of each value of an enumerated  must be a valid Cplus_plus identifier (see Section [|3_0_3|.
Given the Color  defined as above, we can declare and use variables of the enum  as shown by the following code fragment: Color ; = Orange; Here the variable  has our custom  Color, and its value is Orange.
When declaring enumerated types in this manner it is illegal to reuse an enumerated value name within another enumerated  within the same program.
In the following code, the enumerated value Light.
This style of enumerated  definition is known as an unscoped enumeration.
Cplus_plus inherits this un¬ scoped enumeration style from the C programming language.
The Cplus_plus standards committee introduced relatively recently an enhanced way of defining enumerated types known as scoped enumerations, also known as enumeration classes.
Scoped enumerations solve the problem of duplicate enumeration values in different types.
The following definitions are legal within the same program:.
Prefixing the  name to the value with the : : operator enables the compiler to distinguish between the two different values.
Scoped enumerations require the  name prefix even if the program contains no other enumerated types.
In modern Cplus_plus development, scoped enumerations are preferable to unscoped enumerations.
You should be familiar with unscoped enumerations, though, as a lot of published Cplus_plus code and older Cplus_plus books use unscoped enumerations.
Whether scoped or unscoped, the value names within an enum  must be unique.
The convention in Cplus_plus is to captialize the first letter of an enum  and its associated values, although the language does not enforce this convention.
An enum  is handy for representing a small number of discrete, non-numeric options.
For example, consider a program that controls the movements made by a small robot.
The allowed orientations are forward, backward, left, right, up, and down.
The program could encode these movements as integers, where 0 means left, 1 means backward, etc.
While that implementation will work, it is not ideal.
Integers may assume many more values than just the six values expected.
The compiler cannot ensure that an integer variable representing a robot move will stay in the range 0_0__0__0_5.
What if the programmer makes a mistake and under certain rare circumstances assigns a value outside of the range 0_0__0__0_5.
The program then will contain an error that may result in erratic behavior by the robot.
With enum types, if the programmer uses only the named values of the enum , the compiler will ensure that such a mistake cannot happen.
A particular enumerated  necessarily has far fewer values than a  such as i nt.
Imagine making an integer enum  and having to list all of its values.
Cplus_plus requires that a variable be declared before it is used.
Ordinarily this means specifying the variable's , as in int ; char ; double ; A variable may be initialized when it is declared: int  = 0; char  = 'Z ' ; double  = 100_0_0; Each of the values has a : 0 is an i nt, ' Z ' is a char, and 0_0_0 is a double.
The auto keyword allows the compiler to automatically deduce the  of a variable if it is initialized when it is declared: auto  = 0; auto  = 'Z' ; auto  = 100_0_0; The auto keyword may not be used without an accompanying initialization; for example, the following declaration is illegal:.
Automatic  deduction with auto is not useful to beginning Cplus_plus programmers.
It is just as easy to specify the variable's.
The value of auto will become clearer when we consider some of the more advanced features of Cplus_plus (see Section f20T2|.
Will the following lines of code print the same thing.
Will the following lines of code print the same thing.
What is the largest i nt available on your system.
What can you do if a variable name you would like to use is the same as a reserved word.
Why does Cplus_plus require programmers to declare a variable before using it.
What are the advantages of declaring variables.
What is the difference between float and double.
What is printed by the following code fragment.
This chapter uses the Cplus_plus numeric types introduced in Chapter [3] to build expressions and perform arith¬.
We can use operators to combine values and variables and form more complex expressions.
As we examine the rest of the program we will see that it would be superfluous to assign values to the variables here.
This statement is our usual print state¬ ment, but it is not terminated with the end-of-line marker ' \ n '.
This is because we want the cursor to remain at the end of the printed line so when the user types in values they appear on the same line as the message prompting for the values.
When the user presses the enter key to complete the input, the cursor will automatically move down to the next line.
The first number entered will be assigned to valuel, and the second number entered will be assigned to value2.
Once the user presses the enter key, the value entered is assigned to the variable.
The user may choose to type one number, press enter, type the second num¬ ber, and press enter again.
Instead, the user may enter both numbers separated by one of more spaces and then press enter only once.
The program will not proceed until the user enters two numbers.
The std : : ci n input stream object can assign values to multiple variables in one.
The compiler will not generate an error message, because it is legal Cplus_plus code.
The statement, however, will not assign the three variables from user input as desired.
The comma operator in Cplus_plus has different meanings in different contexts, and here it is treated like  statement separator; thus, the variables num2 and num3 are not involved with the std : : ci n input stream object.
We will have no need to use the comma operator in this way, but you should be aware of this potential pitfall.
The >> —as used here in the context of the std : : ci n object—is known as the extraction.
Notice that it is "back¬ wards" from the <<  used with the std : : cout object.
The std : : ci n object represents the input stream—information flowing into the program from user input from the keyboard.
The > > extracts the data from the input stream std : : ci n and assigns the pieces of the data, in order, to the various variables on its right.
The variable appears to the left of the assignment , so  will receive  value when this statement exe¬ cutes.
To the right of the assignment  is an arithmetic expression involving two variables and the addition.
The expression is evaluated by adding together the  of the two variables.
Once the expression's value has been determined, that value can be assigned to the  variable.
All expressions have  value.
The process of determining the expression's value is called evaluation.
Evaluating simple expressions is easy.
The literal value 54 evaluates to 54.
The value of  variable named is the value stored in the memory location reserved for.
The value of  more complex expression is found by evaluating the smaller expressions that make it up and combining them with operators to form potentially new.
The two operands of the +  are  and z.
Two of the operators above, + and serve also as unary operators.
A unary  has only one operand.
The - unary  expects a single numeric expression (literal number, variable, or complex numeric expression within parentheses) immediately to its right; it computes the additive inverse of its operand.
If the operand is positive (greater than zero), the result is a negative value of the same magnitude; if the operand is negative (less than zero), the result is a positive value of the same magnitude.
Zero is unaffected.
For example, the following code sequence i nt  = 3; int  = -4; i nt  = 0; std:: << - << " " << - << " " - << ' \ n' ; within a program would print.
Omitting the unary + from the following statement = +; does not change the statement's behavior.
All the arithmetic operators are subject to the limitations of the data types on which they operate; for example, on a system in which the largest i nt is 2,147,483,647, the expression 2147483647 + 1 will not evaluate to the correct answer since the correct answer falls outside the range of i nts.
If you add, subtract, multiply, is divide two i nts, the result is an integer.
As long as the operation does not exceed the range of i nts, the arithmetic works as expected.
Division, however, is another matter.
The statement std:: << 10/3 << " " << 3/10 << '\n' ;.
Since integers are whole numbers, any fractional part of the answer must be discarded.
The process of discarding the fractional part leaving only the whole number part is called truncation.
Truncation is not rounding; for example, 11 divided by 3 is 3_0_6666_0__0__0_, but it also truncates to 3.
The modulus  (96) computes the remainder of integer division; thus,.
Figure [4~T| uses long division for a more hands on illustration of how the integer division and modulus operators work.
The modulus  is more useful than it may first appear.
Listing |471T| (tirneconv_0_cpp) shows how we can use it to convert a given number of seconds to hours, minutes, and seconds.
In contrast to integer arithmetic, floating-point arithmetic with doubles behaves as expected:.
Since  cha r is stored internally as  number (see Section 3_0_8), we can perform arithmetic on charac¬ ters.
We will have little need to apply mathematics to characters, but sometimes it is useful.
As an example, the -case letters of the alphabet - occupy ASCII values 97-123, with  = 97,  = 98, etc.
The ¬ case letters -Z are coded as 65-91, with  = 65,  = 66, etc.
To capitalize any -case letter, you need only subtract 32, as in char  = 'd' ,  =  - 32; std:: <<  << '\n' ; This section of code would print D.
If you do not remember the offset of 32 between - and -case letter, you can compute it with the letters themselves: =  - ('' - ''); In this case, if  has been assigned any value in the range '  ' to '  ' , the statement will assign to the capitalized version of.
On the other hand, if 's value is outside of that range, will not receive  meaningful value.
Expressions may contain mixed elements; for example, the following program fragment int  = 4; double  = 10_0_2, ; =  + ; adds an i nt to  double, and the result is being assigned to  double.
How is the arithmetic performed.
As shown in Figure 4_0_2, the range of i nts falls completely within the range of doubles; thus, any i nt value can represented by  double.
The i nt 4 also can be expressed as the double 4_0_0.
In fact, since the largest i nt on most systems is 2,147,483,647, the minimum 15 digits of double precision are more than adequate to represent all integers exactly.
This means that any i nt value can be represented by double.
The converse is not true, however.
We say that the double type is wider than the i nt type and that the i nt type is narrower than the double type.
It would be reasonable, then, to be able to assign i nt values to double variables.
The process is called widening, and it is always safe to widen an i nt to  double.
The following code fragment.
Assigning adoubletoanint variable is not always possible, however, since the double value may not be in the range of  nts.
Furthermore, if the double variable falls within the range of  nts but is not  whole number, the int variable is unable to the manage fractional part.
Consider the following code fragment: double  = 1_0_6; int  = ; The second line assigns 1 to.
Truncation loses the 0_0_6 fractional part (see Section 4_0_1).
Note that proper rounding is not done.
The Visual Cplus_plus compiler will warn us of  potential problem: warning 4244: '= ': conversion from 'double' to 'int', possible loss of data This warning reminds us that some information may be lost in the assignment.
While the compiler and linker will generate an executable program when warnings are present, you should carefully scrutinize all warnings.
This warning is particularly useful, since it is easy for errors due to the truncation of floating¬ point numbers to creep into calculations.
Converting from  wider type to  narrower type (like double to  nt) is called narrowing.
It often is necessary to assign  floating-point value to an integer variable.
If we know the value to assign is within the range of  nts, and the value has no fractional parts or its truncation would do no harm, the assignment is safe.
To perform the assignment without  warning from the compiler, we use  procedure called  cast, also called  type cast.
The cast forces the compiler to accept the assignment without  issuing  warning.
The following statement convinces the compiler to accept the double-to- nt assignment without  warning: = static_cast<int> () ; The reserved word stati c_cast performs the narrowing conversion and silences the compiler warning.
The item to convert (in this case the variable ) is placed in the parentheses, and the desired type (in this case the type  nt) appears in the angle brackets.
The statement = static_cast<int> () ; does not change the type of the variable ;  is declared to be  double and so must remain  double variable.
The statement makes  copy of 's value in  temporary memory location, converting it to its integer representation during the process.
We also can cast literal values and expressions:.
The widening conversion is always safe, so  type cast is not required.
Narrowing is  potentially.
The printed values of  and  are not even close, nor can they be because it is impossible to represent the value 2,200,000,000 as an  nt on  system that uses 32-bit integers.
When assigning  value of  wider type to  variable of  narrower type, the programmer must assume the responsibility to ensure that the actual value to be narrowed is indeed within the range of the narrower type.
The compiler cannot ensure the safety of the assignment.
Casts should be used sparingly and with great care because  cast creates  spot in the program that is immune to the compiler's type checking.
When we must perform mixed arithmetic—such as adding an  nt to  double — the compiler auto¬ matically produces machine language code that copies the  nt value to  temporary memory location and transforms it into its double equivalent.
It then performs double-precision floating-point arithmetic to compute the result.
Integer arithmetic occurs only when both operands are  nts.
Since double is wider than  nt, we say that double dominates  nt.
In  mixed type arithmetic expression, the less dominant type is coerced into the more dominant type in order to perform the arithmetic operation.
Section|3_0_9|introduced enumerated types.
Behind the scenes, the compiler translates enumerated values into integers.
The first value in the enumeration is 0, the second value is 1, etc.
Even though the underlying implementation of enumerated types is integer, the compiler does not allow the free exchange between integers and enumerated types.
The following code will not compile:.
The std: : cout printing object knows how to print integers, but it does not know anything about our Color class and its values.
If we really want to treat an enumerated type value as its underlying integer, we must use a type cast.
Listing |473| (enumcast_0_cpp) shows how to extract the underlying integer value from an enumerated type.
This is the expected output because Color: : Red is 0, Color: : Orange is 1, Color: : Yellow is 2, Color: : Green is 3, etc.
Even though enumerated types are encoded as integers internally, programmers may not perform arith¬ metic on enumerated types without involving casts.
Such opportunities should be very rare; if you need to perform arithmetic on a variable, it really should be a numerical type, not an enumerated type.
Precedence —when an expression contains two different kinds of operators, which should be applied first.
Associativity —when an expression contains two operators with the same precedence, which should be applied first.
To see how precedence works, consider the expression 2 + 3*4 Should it be interpreted as (2 + 3) * 4 (that is, 20), or rather is 2 + (3 * 4).
As in normal arithmetic, in Cplus_plus multiplication and division have equal importance and are performed before addition and subtraction.
We say multiplication and division have precedence over addition and subtraction.
In the expression 2 + 3*4 the multiplication is performed before addition, since multiplication has precedence over addition.
The multiplicative operators (*, /, and %) have equal precedence with each other, and the additive operators (binary + and -) have equal precedence with each other.
The multiplicative operators have precedence over the additive operators.
As in standard arithmetic, in Cplus_plus if the addition is to be performed first, parentheses can override the precedence rules.
The expression (2 + 3) * 4 evaluates to 20.
Multiple sets of parentheses can be arranged and nested in any ways that are acceptable in standard arithmetic.
To see how associativity works, consider the expression 2-3-4 The two operators are the same, so they have equal precedence.
Should the first subtraction operator be applied before the second, as in (2 - 3) - 4 (that is, —5), or rather is 2 - (3 - 4) (that is, 3) the correct interpretation.
The former (—5) is the correct interpretation.
We say that the subtrac¬ tion operator is left associative, and the evaluation is left to right.
This interpretation agrees with standard arithmetic rules.
All binary operators except assignment are left associative.
Assignment is an exception; it is right associative.
To see why associativity is an issue with assignment, consider the statement =  =  = z; This is legal Cplus_plus and is called chained assignment.
Assignment can be used as both a statement and an expression.
The statement = 2 ; assigns the value 2 to the variable.
The expression = 2 assigns the value 2 to the variable  and evaluates to the value that was assigned; that is, 2.
Since assignment is right associative, the compiler would interpret the chained assignment example as if it were written as = ( = ( = z)) ; which behaves as follows:.
The expression  = z is evaluated first, z's value is assigned to , and the value of the expression = z is z's value.
The expression  = ( = z)is evaluated.
The value of  = z, that is z, is assigned to.
The overall value of the expression  =  = z is thus the value of z.
Now the values of , , and z are all equal (to z).
The expression  = ( =  = z)is evaluated.
The value of the expression  =  = z is equal to z's value, so z's value is assigned to.
The overall value of the expression  =  =  = z is equal to z, and the variables , , , and z are all equal (to z).
As in the case of precedence, we can use parentheses to override the natural associativity within an expres¬ sion.
The unary operators have a higher precedence than the binary operators, and the unary operators are right associative.
This means the statements.
These notes are meant for human readers, not the compiler.
It is common in industry for programs to be reviewed for correctness by other programmers or technical managers.
Well-chosen identifiers (see Section 3_0_31 and comments can aid this assessment process.
Also, in practice, teams of programmers develop software.
A different programmer may be required to finish or fix a part of the program written by someone else.
Well-written comments can help others understand new  quicker and increase their productivity modifying old or unfinished.
While it may seem difficult to believe, even the same programmer working on her own  months later can have a difficult time remembering what various parts do.
Comments can help greatly.
Any text contained within comments is ignored by the compiler.
Cplus_plus supports two types of comments: single line comments and block comments:.
The comment begins with the double forward slash symbols (/ /) and continues until the end of that line.
The compiler will ignore the / / symbols and the contents of the rest of the line.
This type of comment is also useful for appending a short comment to the end of a statement: = sum / number; // Compute the average of the values Here, an executable statement and the comment appear on the same line.
The compiler will read the assignment statement here, but it will ignore the comment.
The compiler generates the same machine for this example as it does for the preceding example, but this example uses one line of source instead of two.
Block comment —the second type of comment begins with the symbols /* and is in effect until the */ symbols are encountered.
Unlike parentheses, however, these block comments cannot be nested within other block comments.
The block comment is handy for multi-line comments: /* After the computation is completed the  is displayed.
Thus, the audience of the comments should be taken into account; generally, "routine" activities require no remarks.
The extra time it takes to write good comments is well worth the effort.
Program comments are helpful to human readers but ignored by the compiler.
Another aspect of source that is largely irrelevant to the compiler but that people find valuable is its formatting.
Imagine the difficulty of reading a book in which its text has no indentation or spacing to separate one paragraph from another.
In comparison to the source  for a computer program, a book's organization is quite simple.
Over decades of software construction programmers have established a small collection of source formatting styles that the industry finds acceptable.
Both reformatted programs are valid Cplus_plus and compile to the same machine language  as the orig¬ inal version.
Most would argue that the original version is easier to read and understand more quickly than either of the reformatted versions.
The elements in Listing ||3_0_4|| (variable_0_cpp) are organized bet¬ ter.
Experienced Cplus_plus programmers would find both Listing |4_0_4| ( reformattedvariable_0_cpp) and Listing |43] (reformattedvariable2_0_cpp) visually painful.
What are some distinguishing characteristics of Listing |3_0_4| (variable_0_cpp).
Each statement appears on its own line.
A statement is not unnecessarily split between two lines of text.
Visually, one line of text implies one action (statement) to perform.
The close curly brace aligns vertically with the line above that contains the corresponding open curly brace.
This makes it easier to determine if the curly braces match and nest properly.
It also better por¬ trays the logical structure of the program.
The ability to accurately communicate the logical structure of a program becomes very important as write more complex programs.
Programs with complex logic frequently use multiple nested curly braces (for example, see Listing |57Ll [ (troubleshoot, cpp)).
With¬ out a consistent, organized arrangement of curly braces it can difficult to determine which opening brace goes with a particular closing brace.
The statements that constitute the body of main are indented several spaces.
This visually em¬ phasizes the fact that the elements are indeed logically enclosed.
As with curly brace alignment, indentation to emphasize logical enclosure becomes more important as more complex programs are considered.
Spaces are used to spread out statements and group pieces of the statement.
Space around the op¬ (=) makes it easier to visually separate the operands from the operators and comprehend the details of the expression.
Most people find the statement = subtotal + tax; much easier to read than =subtotal+tax; since the lack of space in the second version makes it more difficult to pick out the individual pieces of the statement.
In the first version with extra space, it is clearer where operators and variable names begin and end.
In a natural language like English, a book is divided into distinct chapters, and chapters are composed of paragraphs.
One paragraph can be distinguished from another because the first line is indented or an extra space appears between two paragraphs.
Space is used to separate words in each sentence.
Consider how hard it would be to read a book if all the sentences were printed like this one: Theboyranquicklytothetreetoseethestrandedcat.
Cplus_plus gives the programmer a large amount of freedom in formatting source.
The compiler reads the characters that make up the source  one symbol at a time left to right within a line before moving to the next line.
While extra space helps readability, spaces are not allowed in some places: - Variable names and reserved words must appear as unbroken units.
One common coding convention that is universal in Cplus_plus programming is demonstrated in Listing |3T10|| (const_0_cpp).
While programmers usually use lower-case letters in variable names, they usually express constant names with all capital letters; for example, PI is used for the mathematical constant 7Z instead of pi.
Cplus_plus does not require constants to be capitalized, but capitalizing them aids humans reading the source code so they can quickly distinguish between variables and constants.
Figure {43) shows the four most common ways programmers use indentation and place curly braces in Cplus_plus source code.
The K&R and ANSI styles are the most popular in published Cplus_plus source code.
The Whitesmith and Banner styles appear much less frequently, http://en_0_wi kipedia_0_org/wiki/Indent_style reviews the various ways to format Cplus_plus code.
Observe that all the accepted formatting styles indent the block of statements contained in the mai n function.
Most software development organizations adopt a set of style guidelines, sometimes called code conven¬ tions.
These guidelines dictate where to indent and by how many spaces, where to place curly braces, how to assign names to identifiers, etc.
Programmers working for the organization are required to follow these style guidelines for the code they produce.
This better enables any member of the development team to read and understand more quickly code written by someone else.
This is necessary when code is reviewed for correctness or when code must be repaired or extended, and the original programmer is no longer with the development team.
Even if you are not forced to use a particular style, it is important to use a consistent style throughout the code you write.
As our programs become more complex we will need to use additional curly braces and various levels of indentation to organize the code we write.
A consistent style (especially one of the standard styles shown in Figure |4_0_3| makes it easier to read and verify that the code actually expresses our intent.
It also makes it easier to find and fix errors.
Said another way, haphazard formatting increases the time it takes to develop correct software because programmer's mistakes hide better in poorly formatted code.
Good software development tools can boost programmer productivity, and many programming editors have the ability to automatically format source code according to a standard style.
Some of these editors can correct the code's style as the programmer types in the text.
A standalone program known as a pretty printer can transform an arbitrarily formatted Cplus_plus source file into a properly formatted one.
Seasoned programmers make mistakes due to carelessness or because the proposed solution to a problem is faulty and the correct implementation of an incorrect solution will not produce a correct program.
Regardless of the reason, a programming error falls under one of three categories:.
A compile-time error results from the programmer's misuse of the language.
A syntax error is a common compile-time error.
For example, in English one can say The boy walks quickly.
The boy walk quickly.
It violates a grammatical rule of the English language.
Similarly, the Cplus_plus statement = y + 2; is syntactically correct because it obeys the rules for the structure of an assignment statement described in Section 3_0_2 However, consider replacing this assignment statement with a slightly modified version: + 2 = ; If a statement like this one appears in a program and the variables  and y have been properly declared, the compiler will issue an error message; for example, the Visual Cplus_plus compiler reports (among other things): error 2106: '= ': left operand must be l-value The syntax of Cplus_plus does not allow an expression like y + 2 to appear on the left side of the assignment operator.
Visual Cplus_plus reports: error 2065: 'y': undeclared identifier Other common compile-time errors include missing semicolons at the end of statements, mismatched curly braces and parentheses, and simple typographical errors.
Compile-time errors usually are the easiest to repair.
The compiler pinpoints the exact location of the problem, and the error does not depend on the circumstances under which the program executes.
The exact error can be reproduced by simply recompiling the same source code.
Compilers have the reputation for generating cryptic error messages.
They seem to provide little help as far as novice programmers are concerned.
Sometimes a combination of errors can lead to messages that indicate errors on lines that follow the line that contains the actual error.
Once you encounter the same error several times and the compiler messages become more familiar, you become better able to deduce the actual problem from the reported message.
Unfortunately Cplus_plus is such a complex language that sometimes a simple compile-time error can result in a message that is incomprehensible to beginning Cplus_plus programmers.
It can detect, for exam¬ ple, the malformed assignment statement and the use of a variable before its declaration.
Some violations of the language cannot be detected at compile time, however.
A program may not run to completion but instead terminate with an error.
We commonly say the program "crashed_0_" Consider Listing [46] (dividedanger_0_cpp) which under certain circumstances will crash.
If the user enters, for example, 32 and 4, the program works nicely.
If the user instead types the numbers 32 and 0, the program reports an error and terminates.
Division by zero is undefined in mathematics, and integer division by zero in Cplus_plus is illegal.
When the program attempts the division at run time, the system detects the attempt and terminates the program.
This particular program can fail in other ways as well; for example, outside of the Cplus_plus world, 32_0_0 looks like a respectable integer.
If the user types in 32_0_0 and 8, however, the program crashes because 32_0_0 is not a valid way to represent an integer in Cplus_plus.
When the compiler compiles the source line std::cin >> dividend >> divisor; given that dividend has been declared to be an i nt, it generates slightly different machine language code than it would if dividend has been declared to be a double instead.
The compiled code expects the text entered by the user to be digits with no extra decoration.
Any deviation from this expectation results in a run-time error.
Similar results occur if the user enters text that does not represent an integer, like fred.
Observe that in either case—entry of a valid but inappropriate integer (zero) or entry of a non-integer (32_0_0 or fred )—it is impossible for the compiler to check for these problems at compile time.
The compiler cannot predict what the user will enter when the program is run.
This means it is up to the programmer to write code that can handle bad input that the user may provide.
As we continue our exploration of programming in Cplus_plus, we will discover ways to make our programs more robust against user input (see Listing |5_0_2| (betterdivision_0_cpp) in Chapter[5j for example).
The solution involves changing the way the program runs depending on the actual input provided by the user.
It runs, and unless a value of zero is entered for the , no run-time errors arise.
However, the answer it computes is not correct in general.
The only time the correct answer is printed is when  = d i visor.
The program contains an error, but neither the compiler nor the run-time system is able detect the problem.
An error of this type is known as a logic error.
Listing {47iT0| (faultytempconv_0_cpp) is an example of a program that contains a logic error.
Listing [4720j (faultytempconv_0_cpp) compiles and does not generate any run-time errors, but it produces incorrect results.
Beginning programmers tend to struggle early on with compile-time errors due to their unfamiliarity with the language.
The compiler and its error messages are actually the programmer's best friend.
As the programmer gains experience with the language and the programs written become more complicated, the number of compile-time errors decrease or are trivially fixed and the number of logic errors increase.
Unfortunately, both the compiler and run-time environment are powerless to provide any insight into the nature and sometimes location of logic errors.
Logic errors, therefore, tend to be the most difficult to find and repair.
Tools such as debuggers are frequently used to help locate and fix logic errors, but these tools are far from automatic in their operation.
Errors that escape compiler detection (run-time errors and logic errors) are commonly called bugs.
Since the compiler is unable to detect these problems, such bugs are the major source of frustration for developers.
The frustration often arises because in complex programs the bugs sometimes only reveal themselves in certain situations that are difficult to reproduce exactly during testing.
You will discover this frustration as your programs become more complicated.
The good news is that programming experience and the disciplined application of good programming techniques can help reduce the number logic errors.
The bad news is that since software development in an inherently human intellectual pursuit, logic errors are inevitable.
Accidentally introducing and later finding and eliminating logic errors is an integral part of the programming process.
In Listing |4T0| (tempconv_0_cpp) the programmer is attempting to print the value of a variable before it has been given a known value.
When run, the program produces a random result because it prints the value in memory associated with the variable, but the program does not initialize that memory location.
Listing 4_0_8 (narrow_0_cpp) assigns a double value to an i nt variable, which we know from Section 4_0_1.
Since it is a warning and not an error, the compiler generates the executable, but the warning should prompt.
The default Visual Cplus_plus warning level is 3 when compiling in the IDE and level 1 on the command line (that is why we use the /W3 option on the command line); the highest warning level is 4.
You can reduce the level to 1 or 2 or disable warnings altogether, but that is not recommended.
The only reason you might want to reduce the warning level is to compile older existing Cplus_plus source  that does meet newer Cplus_plus standards.
When developing new , higher warning levels are preferred since they provide more help to the programmer.
Unless otherwise noted, all the complete program examples in this book compile cleanly under Visual Cplus_plus set at warning level 3.
Level 3 is helpful for detecting many common logic errors.
We can avoid most warnings by a simple addition to the.
Section 4_0_2 showed how we can use stati c_cast to coerce a wider type to a narrower type.
At Visual Cplus_plus warning Level 3, the compiler issues a warning if the cast is not used.
The little  that must be added should cause the programmer to stop and reflect about the correctness of the construct.
The enhanced warning level prevents the programmer from being oblivious to the situation.
The kind of arithmetic to perform in a complex expression is determined on an operator by operator basis.
Fahrenheit to degrees Celsius using the formula.
The value —40 is the point where the Fahrenheit and Celsius curves cross, so the result should be —40, not zero.
The first test was only coincidentally correct.
Unfortunately, the printed result is always zero regardless of the input.
The problem is the division 5/9 in the statement = 5/9* (degreesF - 32); Division and multiplication have equal precedence, and both are left associative; therefore, the division is performed first.
Since both operands are integers, integer division is performed and the quotient is zero (5 divided by 9 is 0, remainder 5).
Of course zero times any  is zero, thus the result.
The fact that a floating-point value is involved in the expression (degreesF) and the overall result is being assigned to a floating-point variable, is irrelevant.
The decision about the exact type of operation to perform is made on an operator-by-operator basis, not globally over the entire expression.
Since the division is performed first and it involves two integer values, integer division is used before the other floating-point pieces become involved.
One solution simply uses a floating-point literal for either the five or the nine, as in = 5_0_0/9* (degreesF - 32); This forces a double-precision floating-point division (recall that the literal 5_0_0 is a double).
The correct result, subject to rounding instead of truncation, is finally computed.
Listing j4TT|(timeconv_0_cpp) uses integer division and modulus to split up a given  of seconds to hours, minutes, and seconds.
If the user enters 10000, the program prints 2 hr , 46 mi n, 40 sec.
Notice the assignments to.
The remainder of  divided by 3,600 is assigned back to.
This statement can alter the value of  if the current value of is greater than 3,600.
A similar statement that occurs frequently in programs is one like =  + 1; This statement increments the variable  to make it one bigger.
A statement like this one provides further evidence that the Cplus_plus assignment  does not mean mathematical equality.
The following statement from mathematics = + 1 is surely never true; a  cannot be equal to one more than itself.
If that were the case, I would deposit one dollar in the bank and then insist that I really had two dollars in the bank, since a  is equal to one more than itself.
That two dollars would become 3_0_00, then 4_0_00, etc_0_, and soon I would be rich.
In Cplus_plus, however, this statement simply means "add one to  and assign the result back to _0_" A variation on Listing |4_0_111| (timeconv_0_cpp).
Listing |4_0_12 (enhancedtimeconv_0_cpp) performs the same logic to compute the time pieces (, , and ), but it uses more simple arithmetic to produce a slightly different output—instead of printing 11,045  as 3 hr, 4 min, 5 sec, Listing |4_0_12|| (enhancedtimeconv_0_cpp) displays it as 3:04:05.
It is trivial to modify Listing |4_0_11 || (timeconv_0_cpp) so that it would print 3:4:5, but Listing |4TT2| (enhancedtimeconv_0_cpp) includes some extra arithmetic to put leading zeroes in front of single-digit values for  and  as is done on digital clock displays.
Floating-point Numbers Floating-point numbers offer some distinct advantages over integers.
Floating-point numbers, especially doubles have a much greater range of values than any integer type.
Floating-point numbers can have fractional parts and integers cannot.
Integers, however, offer one big advantage that floating-point numbers cannot—exactness.
To see why integers are exact and floating-point numbers are not, we will explore the way computers store and manipulate the integer and floating-point types.
Computers store all data internally in binary form.
The binary (base 2) number system is much simpler than the familiar decimal (base 10) number system because it uses only two digits: 0 and 1.
The decimal system uses 10 digits: 0, 1, 2, 3, 4, 5, 6, 7, 8, and 9.
Despite the lack of digits, every decimal integer has an equivalent binary representation.
Binary numbers use a place value system not unlike the decimal system.
Figure}4_0_4(shows how the familiar base 10 place value system works.
Since both binary and decimal numbers share the digits 0 and 1, we will use the subscript 2 to indicate a binary number; therefore, 100 represents the decimal value one hundred, while IOO 2 is the binary number four.
Sometimes to be very clear we will attach a subscript of 10 to a decimal number, as in 100io In the decimal system, it is easy to add 3+5: 3 H - 5 8 " The sum 3 + 9 is a little more complicated, as early elementary students soon discover:.
The sum is 1 03 + 09 12 We can say 3 + 9 is 2, carry the 1.
The rules for adding binary numbers are shorter and simpler than decimal numbers: 2 + 2 = 2 2 + 2 = 2 2+2 = 2 2 + 2 = IO2 We can say the sum  2 +  2 is 0 2 , carry the  2.
A typical larger sum would be 11 9  = IOOI2 + 3 10 = H2.
These are distinguished by the number of bits required to store the type, and, consequently, the range of values they can represent.
Mathematical integers are in¬ finite, but all of Cplus_plus's integer types correspond to finite subsets of the mathematical integers.
The most commonly used integer type in Cplus_plus is i nt.
All i nts, regardless of their values, occupy the same amount of memory and, therefore use the same number of bits.
The exact number of bits in an i nt is processor specific.
A 32-bit processor, for example, is built to manipulate 32-bit integers very efficiently.
A Cplus_plus compiler for such a system most likely would use 32-bit i nts, while a compiler for a 64-bit machine might represent i nts with 64 bits.
On a 32-bit computer, the numbers 4 and 1,320,002,912 both occupy 32 bits of memory.
For simplicity, we will focus on unsigned integers, particularly the unsi gned type.
The unsi gned type in Visual Cplus_plus occupies 32 bits.
With 32 bits we can represent 4,294,967,296 different values, and so Visual Cplus_plus's unsi gned type represents the integers 0_0_.
The hardware in many computer systems in the 1990s provided only 16-bit integer types, so it was common then for Cplus_plus compilers to support 16-bit unsi gned values with a range 0_0_.
To simplify our exploration into the properties of computer-based integers, we will consider an even smaller, mythical unsigned integer type that we will call unsigned ti ny.
Cplus_plus has no such unsigned ti ny type as it has a very small range of values— too small to be useful as an actual type in real programs.
Our unsigned ti ny type uses only five bits of storage, and Table 4_0_3 shows all the values that a variable of type unsigned tiny can assume.
Table 4_0_3: The unsigned tiny values.
To see that arithmetic works, try adding 4 + 3: 4 10 = 00100 2 + 310 = 000112 7 10 = OOIII2 That was easy since involved no carries.
Next we will try 3 + 1:.
In the twos column,  2 +  2 +  2 = IO 2 , so we must carry a 1 into the fours column as well.
The next example illustrates a limitation of our finite representation.
Consider the sum 8 + 28: 11 810 = OIOOO2 + 28  = IHOO2 4 10 = 1 OOIOO2 In the this sum we have a carry of 1 from the eights column to the 16s column, and we have a carry from the 16s column to nowhere.
We need a sixth column (a 32s column), another place value,  our unsigned ti ny type is limited to five bits.
That carry out from the 16s place is lost.
The largest unsi gned ti ny value is 31,  28 + 8 = 36.
It is not possible to store the value 36 in an unsigned tiny just as it is impossible to store the value 5,000,000,000 in a Cplus_plus unsi gned variable.
Consider exceeding the capacity of the unsigned ti ny type by just one:.
Adding one to the largest possible unsigned ti ny, 31, results in the smallest possible value, 0.
Figure 4_0_6 The cyclic nature of 32-bit unsigned integers.
Adding 1 to 4,294,967,295 produces 0, one.
In fact, Visual Cplus_plus's 32-bit unsi gneds follow the cyclic pattern shown in Figure 4_0_6 In the figure, an addition moves a value clockwise around the circle, while a subtraction moves a value counterclockwise around the circle.
When the numeric limit is reached, the value rolls over like an auto¬ mobile odometer.
Signed integers exibit a similar cyclic pattern as shown in Figure |4_0_7| l.
Figure 4_0_7 The cyclic nature of 32-bit signed integers.
Adding 1 to 2,147,483,647 produces.
Attempting to exceed the maximum limit of a numeric type results in overflow, and attempting to exceed the minimum limit is called underflow.
Integer arithmetic that overflow or underflow produces a valid, yet incorrect integer result.
The compiler does not check that a computation will result in exceeding the limit of a type because it is impossible to do so in general (consider adding two integer variables whose values are determined at run time).
Also significantly, an overflow or underflow situation does not generate a run-time error.
It is, therefore, a logic error if a program performs an integral computation that, either as a final result or an intermediate value, is outside the range of the integer type being used.
Floating point numbers can have fractional parts (decimal places), and the term floating point refers to the fact the dec¬ imal point in a number can float left or right as necessary as the result of a calculation (for example, 2_0_5  3_0_3 = 8_0_25, two one-decimal place values produce a two-decimal place result).
As with the integer types, the different floating-point types may be distinguished by the number of bits of storage required and corresponding range of values.
The type float stands for single-precision floating-point, and double stands for double-precision floating-point.
Floating point numbers serve as rough approximations of math¬ ematical real numbers, but as we shall see, they have some severe limitations compared to actual real numbers.
On most modern computer systems floating-point numbers are stored internally in exponential form according to the standard adopted by the Institute for Electrical and Electronic Engineers (IEEE 754).
In the decimal system, scientific notation is the most familiar form of exponential notation: One mole contains 6_0_023  10 23 molecules.
Here 6_0_023 is called the mantissa, and 23 is the exponent.
The IEEE 754 standard uses binary exponential notation; that is, the mantissa and exponent are binary numbers.
Single-precision floating-point numbers (type float) occupy 32 bits, distributed as follows: Mantissa 24 bits.
We will call our mythical floating-point type tiny float.
The first three bits of our 5-bit tiny float type will represent the mantissa, and the remaining two bits store the exponent.
The three bits of the mantissa all appear to the right of the binary point.
The base of the 2-bit exponent is, of course, two.
Figure ]4_0_8|j illustrates such a value.
To simplify matters even more, neither the mantissa nor the exponent can be negative.
Thus, with three bits, the mantissa may assume one of eight possible values.
Since two bits constitute the exponent of ti ny floats, the exponent may assume one of four possible values.
Table 4_0_4 lists all the possible values that ti ny float mantissas and exponents may assume.
The number shown in Figure 4_0_8 is thus.
Table 4_0_5 combines the mantissas and exponents to reveal all possible ti ny float values that we can.
The range of our tiny float numbers is 0_0_.
Just stating the range is misleading, however, since.
Figure 4_0_9 plots all the possible ti ny float values on the real number line.
Figure 4_0_9 A plot of all the possible ti ny float numbers on the real number line.
Note that the numbers are more dense near zero and become more sparse moving to the right.
The precision in the range 0_0__0_.
The precision in the range 1_0__0_.
In the range 4_0__0__0_7 our tiny float type can represent only whole numbers.
There are many gaps; for example, the value 2_0_4 is missing and thus cannot be represented exactly (2_0_5 is the closest approximation).
As another example, 0_0_75 and 1_0_75 both appear, but 2_0_75 is missing.
The scheme duplicates some numbers; for example, three different bit patterns represent the decimal value 0_0_5: 0_0_100 2°° = 0_0_010 2 01 = 0_0_001 2 10 = 0_0_5io This duplication limits the number of different values that can be represented by a given number of bits.
In our ti ny float example 12 of the 32 bit strings (37_0_5%) are redundant.
The numbers are not uniformly dense.
There are more values nearer to zero, and the numbers become more sparse farther away from zero.
Our unsigned tiny type discussed in Section 4_0_8_0_1 exhibits none of these weaknesses.
All integers in a given range (0_0__0__0_31) are present, no two bit strings represent the same value, and the integers are uniformly distributed across their specified range.
While the standard integer types provided by Cplus_plus have much greater ranges than our unsigned tiny type, they all share these same qualities: all values in their ranges are present, and all bit strings represent unique integer values.
The standard floating-point types provided by Cplus_plus use many more bits than our tiny float type, yet they exhibit the same problems.
Table 4_0_5: The tiny float values.
The first three bits of the bit string constitute the mantissa, and the last two bits represent the exponent.
Given five bits we can produce 32 different bit strings.
Notice that due to the ways different mantissas and exponents can combine to produce identical values, the 32 different bit strings yield only 20 unique tiny float values.
This is not solely a problem of Cplus_plus's implementation of floating-point numbers; all computer languages and hardware that adhere to the IEEE 754 standard exhibit these problems.
To overcome these problems and truly represent and compute with mathematical real numbers we would need a computer with an infinite amount of memory along with an infinitely fast processor.
The program uses an additional #i nclude directive: ttinclude <iomanip> This preprocessor directive allows us to use the std : : setp reci si on output stream manipulator that directs the std : : cout output stream object to print more decimal places in floating-point values.
During the program's execution, the first subtraction yields the correct answer.
We now know that some floating¬ point numbers (like 0_0_5) have exact internal representations while others are only approximations.
The exact answer for the second subtraction should be 0_0_58, and if we round the reported result to 12 decimal places, the answer matches.
Floating-point arithmetic often produces results that are close approximations of the true answer.
Listing ; 4_0_16| (precise8th_0_cpp) computes zero in a roundabout way:.
The number - has an exact decimal representation, 0_0_625.
It also has an exact binary representation, 0_0_001 2.
Surely the reported answer (5_0_551122  10 " 17 = 0_0_00000000000000005551122) is close to the correct.
Being careful to avoid overflow and underflow, integer arithmetic is exact and, on most computer sys¬ tems, faster than floating-point arithmetic.
If an application demands the absolute correct answer and inte¬ gers are appropriate for the computation, you should choose integers.
For example, in financial calculations it is important to keep track of every cent.
The exact nature of integer arithmetic makes integers an attractive option.
When dealing with numbers, an integer type should be the first choice of programmers.
The limitations of floating-point numbers are unavoidable since computers have finite resources.
Com¬ promise is inevitable even when we do our best to approximate values with infinite characteristics in a finite way.
Despite their inexactness, double-precision floating-point numbers are used every day throughout the world to solve sophisticated scientific and engineering problems; for example, the appropriate use of floating-point numbers have enabled space probes to reach distant planets.
In the example Cplus_plus programs above that demonstrate the inexactness of floating-point numbers, the problems largely go away if we agree that we must compute with the most digits possible and then round the result to fewer digits.
Floating-point numbers provide a good trade-off of precision for practicality.
A variable may increase by  or decrease by five.
The statement =  + 1 ; increments  by , making it  bigger than it was before this statement was executed.
Cplus_plus has a shorter statement that accomplishes the same effect: xplus_plus 5.
When they appear alone in a statement, the pre- and post- versions of the increment and decrement operators work identically.
Their behavior is different when they are embedded within a more complex statement.
Listing 4_0_18 (prevspost_0_cpp) demonstrates how the pre- and post- increment operators work slightly differently.
If  has the  1 just before the statement.
If  has the  1 just before the statement = plus_plusxl; then immediately after the statement executes  is 2 and  is also 2.
As you can see, the pre-increment operator uses the new  of the incremented variable when eval¬ uating the overall expression.
In contrast, the post-increment operator uses the original  of the in¬ cremented variable when evaluating the overall expression.
The pre- and post-decrement operator behaves similarly.
For beginning programmers it is best to avoid using the increment and decrement operators within more complex expressions.
We will use them frequently as standalone statements since there is no danger of misinterpreting their behavior when they are not part of a more complex expression.
Cplus_plus provides a more general way of simplifying a statement that modifies a variable through simple.
This means the statement.
The arithmetic assignment is especially handy if a variable with a long name is to be modified; consider =  / ( + z); versus.
Do not accidentally reverse the order of the symbols for the arithmetic assignment.
These special operators allow programmers to examine or manipulate the individual bits that make up data values.
They  known as the bitwise operators.
These operators consist of &, |, A , ~ , >>,  <<.
Applications programmers generally do not need to use bitwise operators very often, but bit manipulation is essential in many systems programming tasks.
Consider 32-bit unsigned integers.
The bit positions usually  numbered right to left, starting with zero.
Figure )4_0_1~0| shows how the individual bit positions often  numbered.
The bitwise  operator, &, takes two integer subexpressions  computes an integer result.
The expression e\ & <_0_2 is evaluated as follows: If bit 0 in both e\  ei is 1, then bit 0 in the result is 1; otherwise, bit 0 in the result is 0.
The bitwise or operator, |, takes two integer subexpressions  computes an integer result.
The ex¬ pression e\ | ei is evaluated as follows: If bit 0 in both e\  e 2 is 0, then bit 0 in the result is 0; otherwise, bit 0 in the result is 1.
For example, the expression 13 ] 14 evaluates to 15, since: 13 = 00000000000000000000000000001101 2 | 14 10 = 00000000000000000000000000001110 2 15 10 = 00000000000000000000000000001111 2 Bits 4-31  zero in both 13  14.
In bits 0-3 either 13 has a one or 14 has a one; therefore, the result has ones in bits 0-3  zeroes everywhere else.
The bitwise exclusive or (often refered to as xor ) operator ( A ) takes two integer subexpressions computes an integer result.
The expression e\ A e 2 is evaluated as follows: If bit 0 in e\ is the same as bit 0 in <.
If bit 31 in e\ is the same as bit 31 in e 2 , then bit 31 in the result is 0; otherwise, bit 31 in the result.
For example, the expression 13 A 14 evaluates to 3, since:.
The bits match in all the other positions, so these positions must be set to zero in the result.
The bitwise negation operator ( ~ ) is a unary operator that inverts all the bits of its expression.
The expression ~ e is evaluated as follows:.
Signed integers use a representation called two's complement binary, a slight variation of the standard binary layout.
Suffice it to say that the  nt expression ~ 13 evaluates to the same bit pattern as ~ 13u, but as a signed integer it represents —14.
The shift operators move all the bits in an integer to the left or right:.
Shift left (<<).
The expression  < < y, where   y are integer types, shifts all the bits in to the left y places.
Zeros fill vacated positions.
The bits shifted off the left side are discarded.
The expression 5 << 2 evaluates to 20, since 5 = 1012 shifted two places to the left yields 2 = 20- Observe that  < < y is equal to   2 y.
Shift right (>>).
The expression  >> y, where   y are integer types, shifts all the bits in  to the right y places.
What fills the vacated bits on the left depends on whether the integer is signed or unsigned (for example,  nt vs.
The bits shifted off the right side are discarded.
The expression 5 >> 2 evaluates to 1, since 510 = 10O shifted two places to the left yields 2 = 2010 (the original bits in positions 1.
Do not confuse the left shift operator (<<) with the output stream insertion opera¬ tor (< <).
The operators are identical, but the context differentiates them.
If the left operand is an integer type, < < means left shift; if the left operand is a stream out¬ put object like std: :cout, << means send the right-hand operand to the output stream object for display.
Similarly, the input stream object std : : ci n uses the >> for a different purpose from the right shift operator used with integers.
Developers use bitwise operations for a variety of systems-level programming tasks.
For example, in a graphical user interface (GUI), the user generates events by interacting with an application using the mouse and a keyboard.
One event might be clicking a mouse button over a particular graphical element (like a button) within a window.
Multiple pieces of information about this event can be stored in a single integer.
For example, bit 0 may indicate whether or not the key was held down when the mouse button was clicked.
Bit 1 may be responsible for the Rjn key, bit 3 for the ■tiQB key, etc.
This might require a different action on the part of the program than if some other combination of keys (or none) were being pressed.
For example, suppose the i nt variable key_status holds information about which keys the user was depressing during the most recent mouse click.
The bit string 00000000000000000000000000000001.
If the answer is zero, this means bit 0 is 0 in , and so the |.
Do you see how the expression  | ALT_DOWN means both keys are down simultaneously.
We can use masks to ensure that certain bits are on or off.
To see how, consider the mask 5, which is 00000000000000000000000000000101 If  is a 32-bit integer variable, we can selectively turn on its bits 0 and 2 with the statement.
Next, consider the unsigned value 4294967290U, which is ~ 5u, or.
If  is a 32-bit integer variable, we can selectively turn off its bits 0 and 2 with the statement =  & 4294967290U; We cannot fully appreciate the utility of using bitwise operators for masking purposes until we consider conditional execution in Chapter|||5^j Even then, since we concentrate on applications programming instead of systems programming in this book, we will have little use for the bitwise operators except for a few isolated situations.
It is good to be aware of their presence, though, since their accidental use may lead to difficult to diagnose compiler messages and logic errors.
Like the other Cplus_plus arithmetic operators that work on two operands, we may combine the bitwise binary operators &, |, A , <<, and >> with assignment to simplify the modification of a variable; for example, the following statement =  | ; // Turn on bits in  determined by.
A computer program is one example of an algorithm, as is a recipe to make lasagna.
In the case of lasagna, the noodles must be cooked in boiling water before they are layered into the filling to be baked.
It would be inappropriate to place the raw noodles into the pan with all the other ingredients, bake it, and then later remove the already baked noodles to cook them in boiling water separately.
In the same way, the ordering of steps is very important in a computer program.
While this point may be obvious, consider the following sound argument: 1.
The relationship between degrees Celsius and degrees Fahrenheit can be expressed as °= ^  (°F — 32).
The English description provided above is correct.
No integer division.
At the point of the assignment, degreesF has the value of zero.
The executing program computes and assigns the  variable before receiving degreesF's value from the user.
As another example, suppose  and  are two integer variables in some program.
How would we interchange the values of the two variables.
We want  to have 's original value and  to have 's original value.
This code may seem reasonable: = ; = ; The problem with this section of code is that after the first statement is executed,  and  both have the same value ('s original value).
The second assignment is superfluous and does nothing to change the values of or.
The solution requires a third variable to remember the original value of one the variables before it is reassigned.
The correct code to swap the values is = ;.
Informal notions about how to solve a problem can be valuable in the early stages of program design, but the coded program requires a correct detailed description of the solution.
The algorithms we have seen so far have been simple.
Statement 1, followed by Statement 2, etc.
Chapter [5j and Chapter |6| introduce some language constructs that permit optional and repetitive execution of some statements.
These constructs allow us to build programs that do much more interesting things, but more complex algorithms are required to make it happen.
We must not lose sight of the fact that a complicated algorithm that is 99% correct is not correct.
An algorithm's design and implementation can be derailed by inattention to the smallest of details.
Sort the following binary operators in order of high to low : +, 96, =.
Write a Cplus_plus program that receives two integer values from the user.
The program then should print the sum (addition), difference (subtraction), product (multiplication), quotient (division), and remainder after division (modulus).
Your program must use only integers.
Can you explain the results it produces for all of these operations.
Write a Cplus_plus program that receives two double-precision floating-point values from the user.
The program then should print the sum (addition), difference (subtraction), product (multiplication), and quotient (division).
Your program should use only integers.
A sample program run would look like (the user enters the 10 and the 2_0_5 after the colons, and the program prints the rest): Please enter the first number: 10 Please enter the second number: 2_0_5 10 + 2_0_5 = 12_0_5 10 - 2_0_5 = 7_0_5.
Can you explain the results it produces for all these operations.
What happens if you attempt to.
Given the following declaration:.
What is the purpose of comments.
The programs in Listing j|3_0_4|j (variable_0_cpp), Listing [44] (reformattedvariable_0_cpp), and Listing [43| (reformattedvariable2_0_cpp) compile to the same machine code and behave exactly the same.
What makes one of the programs clearly better than the others.
Why is human readability such an important consideration.
Consider the following program which contains some errors.
You may assume that the comments within the program accurately describe the program's intended behavior.
For each line listed in the comments, indicate whether or not a compile-time, run-time, or logic error is present.
Not all lines contain an error.
What distinguishes a compiler warning from a compiler error.
Should you be concerned about warnings.
What are the advantages to enhancing the warning reporting capabilities of the compiler.
Consider the following program that attempts to compute the circumference of a circle given the radius entered by the user.
Given a circle's radius, r, the circle's circumference,  is given by the formula: = 2nr.
In mathematics, the midpoint between the two points {xi, \) and (xj■ yi) is computed by the formula.
V 2 ' 2 ) Write a Cplus_plus program that receives two mathematical points from the user and computes and prints their midpoint.
A sample run of the program produces.
The user literally enters "(0,0)" and "(1,1)" with the parentheses and commas as shown.
To see how to do this, suppose you want to allow a user to enter the point (2_0_3,9), assigning the  component of the point to a variable named  and the  component to a variable named.
You can add the following code fragment to your program to achieve the desired effect:.
It next will assign 2_0_3 to the variable.
It assigns the , character to the variable named comma, the value 9 to the  variable, and the ) character to the ri ght_paren variable.
The left_paren, comma, and right_paren variables are just placeholders for the user's input and are not used elsewhere within the program.
In reality, the user can type in other characters in place of the parentheses and comma as long as the numbers are in the proper location relative to the characters; for example, the user can type *2_0_3: 9#, and the program will interpret the input as the point (2_0_3,9).
Table |4_0_7|| lists the Calorie contents of several foods.
Running or walking burns off about 100 Calories per mile.
Write a Cplus_plus program that requests three values from the user: the number of bean burritos, salads, and shakes consumed (in that order).
The program should then display the number of miles that must be run or walked to burn off the Calories represented in that food.
The program should run as follows (the user types in the 3 2 1): Number of bean burritos, bowls of salad, and milkshakes eaten.
You will have to run 18_0_29 miles to expend that much energy.
All the programs in the preceding chapters execute exactly the same statements regardless of the input, if any, provided to them.
They follow a linear sequence: Statement 1, Statement 2, etc.
Linear programs like these are very limited in the problems they can solve.
This chapter introduces constructs that allow program statements to be optionally executed, depending on the context (input) of the program's execution.
While Boolean expressions may appear very limited on the surface, they are essential for building more interesting and useful programs.
Cplus_plus supports the non-numeric data type bool, which stands for Boolean.
The term Boolean comes from the name of the British mathematician George Boole.
A branch of discrete mathematics called Boolean algebra is dedicated to the study of the properties and the manipulation of logical expressions.
Compared to the numeric types, the bool type is very simple in that it can represent only two values: true or false.
Listing 5_0_1 (boolvars_0_cpp) is a simple program demonstrating the use of Boolean vari¬ ables.
As you can see from running Listing 5_0_1 (boolvars_0_cpp), the Boolean values false and true are represented as integer 0 and integer 1.
More precisely, zero represents the bool value false, and any non-zero integer (positive or negative) means true.
The direct assignment to  bool variable of an integer other than 0 or 1 may result in  warning (Visual Cplus_plus reports truncation of 'int' to 'bool'), but the variable is still interpreted as true.
The data type bool is basically  convenience for programmers; any Cplus_plus program that uses bool variables can be rewritten using integers instead to achieve the same results.
While Boolean values and variables are freely compatible and interchangeable with integers, the bool type is convenient and should be used when the context involves truth values instead of numbers.
It is important to note that the Visual Cplus_plus compiler issues warnings for the last two assignment state¬ ments in Listing j5TT| (boolvars_0_cpp).
Even though any non-zero value is considered true, 1 is the preferred integer equivalent to true (as you can see when you attempt to print the literal value true).
Since the need to assign to  Boolean variable  value other than true or false or the equivalent 1 or 0 should be extremely rare, the compiler's message alerts the programmer to check to make sure the assignment is not mistake.
A Boolean variable is also Boolean expression.
An expression comparing numeric expressions for equality or inequality is also Boolean expression.
The simplest kinds of Boolean expressions use relational operators to compare two expressions.
Table |5TT| lists the relational operators available in Cplus_plus.
Table (5T2( shows some simple Boolean expressions with their associated values.
An expression like 10 < 20 is legal but of little use, since the expression true is equivalent, simpler, and less likely to confuse human readers.
Boolean expressions are extremely useful when their truth values depend on the values of one or more variables.
The relational operators are binary operators and are all left associative.
They all have  lower prece¬ dence than any of the arithmetic operators; therefore, the expression.
If you make  mistake and  == as shown here.
Visual Cplus_plus will issue warning that includes  message.
Recall from Section 'A_0_6 A that  compiler warning does not indicate  violation of.
Why are expressions allowed as statements.
Some simple expressions have side effects that do alter  behavior of  program.
One example of such an ex¬ pression is  + +.
Listing 4_0_18j|(prevspost_0_cpp) showed how  + + behaves both as standalone statement and as an expression within  larger statement.
A more com¬ mon example is   of  function call (which is an expression) as standalone statement.
For¬ tunately, most compilers issue informative warnings about  useless expressionstatements to keep developers on track.
Boolean expressions described in Section 5_0_2| at first may seem arcane and of little  in practical programs.
Boolean expressions are essential for  program to be able to adapt its behavior at run time.
Most truly useful and practical programs would be impossible without  availability of Boolean expressions.
One way that Listing |46| (dividedanger_0_cpp) can fail is when  user enters  zero for  divisor.
Fortunately, programmers can take steps to ensure that division by zero does not occur.
Listing |5_0_2| (betterdivision_0_cpp) shows how it might be done.
In this case,  printing statement is executed only if variable di vi sor's value is not zero.
Boolean expression _0_= 0 determines if  single statement that follows  right parenthesis is executed.
If  is not zero, message is printed; otherwise,  program prints nothing.
Figure 5_0_1 shows how program execution flows through  i f statement, of Listing 5_0_2 (betterdivision_0_cpp).
Good coding style dictates we should indent  body to emphasize  optional execution and improve program's readability.
Sometimes programmers will place a one-statement body on  same line as  i f ; for example,  following i f statement optionally assigns : if ( < 10).
This is legal in Cplus_plus; it means the i f statement has an empty body.
In which case the assignment is not part of the body.
The assignment statement is after the body and always will be executed regardless of the truth value of the Boolean expression.
Since an assignment statement has a value (the value that is assigned, see Section 4_0_3).
It is, however, almost always a mistake when beginning programmers  = in this context.
Vi¬ sual  at warning Level 4 checks for the  of assignment within a conditional expression; the default Level 3 does not.
Listing [5_0_3| (alternatedivision_0_cpp) shows how you must  curly braces to group multiple statements together.
The assignment statement and printing statement are both a part of the body of the i f statement.
Given the truth value of the Boolean expression  _0_= 0 during a particular program run, either both statements will be executed or neither statement will be executed.
A compound statement consists of zero or more statements grouped within curly braces.
We say the curly braces define a block of statements.
As a matter of style many programmers always  curly braces.
The format of the following code.
Since multiple statements making up the body must be in a compound statement within curly braces, the compiler interprets the code fragment as if it had been written.
The programmer probably meant to write it as.
The curly braces are optional if the body consists of a single statement.
If the body consists of only one statement and curly braces are not used, then the semicolon that terminates the statement in the body also terminates the i f statement.
If curly braces are used to delimit the body, a semicolon is not required after the body's close curly brace.
An empty pair of curly braces represents an empty block.
An empty block is a valid compound state¬ ment.
One undesirable aspect of Listing |5_0_2[ (betterdivision_0_cpp) is if the user enters a zero , the program prints nothing.
It may be better to provide some feedback to the user to indicate that the  provided cannot be used.
The i f statement has an optional else clause that is executed only if the Boolean expres¬ sion is false.
Listing 5_0_4 (betterfeedback_0_cpp) uses the i f/else statement to provide the desired effect.
The else clause contains an alternate body that is executed if the condition is false.
The program's flow of execution is shown in Figure [5l2] Listing |5l4| (betterfeedback_0_cpp) avoids the division by zero run-time error that causes the program to terminate prematurely, but it still alerts the user that there is a problem.
Another application may handle the situation in a different way; for example, it may substitute some default value for di vi sor instead of zero.
The general form of an i f /else statement is.
The reserved word i f begins the i f /else statement.
The condition is a Boolean expression that determines whether the running program will execute statement 1 or statement 2.
As with the simple i f statement, the condition must appear within parentheses.
The program executes statement 1 if the condition is true.
To make the i f/else statement more readable, indent statement 1 more spaces than the i f line.
This part of the i f statement is sometimes called the body of the i f.
The reserved word else begins the second part of the i f /else statement.
The program executes statement 2 if the condition is false.
To make the i f/else statement more readable, indent statement 2 more spaces than the else line.
This part of the i f/else statement is sometimes called the body of the else.
The body of the else clause of an i f/else statement may be a compound statement:.
If you ever attempt to use an i f /else statement and discover that you need to leave the else clause.
Due to the imprecise representation of floating-point numbers (see Listing ||4T17[ (imprecise5th_0_cpp) in Section |4_0_1| , programmers must use caution when using the equality  (==) by itself to compare floating-point expressions.
Listing 5_0_5 (samedifferent_0_cpp) uses an i f /else statement to demonstrate the perils of using the equality  with floating-point quantities.
In Listing 5_0_5 (samedifferent_0_cpp) the displayed values of  and 2 are rounded so they appear equivalent, but internally the exact representations are slightly different.
By including the header i omani p we can use the std: :setprecision stream manipulator to force std::coutto display more decimal places in the floating-point number it prints.
Observe from the output of Listing |5_0_5|| (samedifferent_0_cpp) that the two quantities that should be identically 0_0_01 are actually slightly different.
Simple Boolean expressions, each involving one relational , can be combined into more complex.
To introduce compound Boolean expressions, consider a computer science degree that requires, among other computing courses.
Operating Systems and Programming Languages.
If we isolate those two courses, we can say a student must successfully complete both Operating Systems and Programming Languages to qualify for the degree.
A student that passes Operating Systems but not Programming Languages will not have met the requirements.
Similarly, Programming Languages without Operating Systems is insufficient, and a student completing neither Operating Systems nor Programming Languages surely does not qualify.
Logical AND works in exactly the same way.
If e\ and ei are two Boolean expressions, e\ && e 2 is true only if e\ and ei are both true; if either one is false or both are false, the compound expression is false.
To illustrate logical OR, consider two mathematics courses.
Differential Equations and Linear Algebra.
A computer science degree requires one of those two courses.
A student who successfully completes Differential Equations but does not take Linear Algebra meets the requirement.
Similarly, a student may take Linear Algebra but not Differential Equations.
It is important to note the a student may elect to take both Differential Equations and Linear Algebra (perhaps on the way to a mathematics minor), but the requirement is no less fulfilled.
Logical OR works in a similar fashion.
Given our Boolean expressions e\ and c j 2 , the compound ex¬ pression e\ | | e 2 is false only if e\ and e 2 are both false; if either one is true or both are true, the compound expression is true.
Note that logical OR is an inclusive or, not an exclusive or.
In informal conversion we often imply exclusive or in a statement like "Would you like cake or ice cream for dessert_0_" The implica¬ tion is one or the other, not both.
In computer programming the or is inclusive; if both subexpressions in an or expression are true, the or expression is true.
It shows all the combinations of truth values for two simple expres¬.
Logical not (_0_) is a unary operator (see Section ||4_0_1| ; it requires a single Boolean operand immediately to its right.
This means the expression <= y &&  <= z is evaluated ( <= y) && ( <= z).
The relational operators such as < compare two operands.
The result of the com¬ parison is a Boolean value, which is freely convertible to an integer.
The misappli¬ cation of relational operators can lead to surprising results; consider, for example, the expression 1 <=  <= 10 This expression is always true, regardless of the value of.
If the programmer's intent is to represent the mathematical notion of  falling within the range 1_0__0_.
The expression 1 <=  <= 10 is evaluated as (1 <= ) <= 10 If  is greater than or equal to one, the  1 ~ <= ~  evaluates to true, or integer 1.
Integer 1, however, is always less than 10, so the overall expres¬ sion is true.
If instead  is less than one, the  1 ~ <= ~  evaluates to false, or integer 0.
Integer 0 is always less than 10, so the overall expression is true.
The problem is due to the fact that Cplus_plus does not strictly distinguish between Boolean and integer values.
A correct way to represent the mathematical notion of 1 <  < 10 is 1 <=  &&  <= 10 In this case  must simultaneously be greater than or equal to 1 and less than or equal to 10.
The revised Boolean expression is a little more verbose than the mathematical representation, but it is the correct formulation for Cplus_plus.
The following section of code assigns the indicated values to a bool: bool b; int  = 10; int  = 20;.
Since the && operator evaluates left to right, this means that if e\ is false, there is no need to evaluate ei- If e\ is false, no value of e 2 can make the expression e\ && ei true.
The logical and operator first tests the expression to its left.
If it finds the expression to be false, it does not bother to check the right expression.
This approach is called short-circuit evaluation.
In a similar fashion, in the expression e\ | | ej, if e\ is true, then it does not matter what value ei has—a logical or expression is true unless both subexpressions are false.
The | | operator uses short-circuit evaluation also.
Why is short-circuit evaluation important.
Two situations show why it is important to consider:.
The order of the subexpressions can affect performance.
When a program is running, complex ex¬ pressions require more time for the computer to evaluate than simpler expressions.
We classify an expression that takes a relatively long time to evaluate as an expensive expression.
If a compound Boolean expression is made up of an expensive Boolean subexpression and an less expensive Boolean subexpression, and the order of evaluation of the two expressions does not affect the behavior of the program, then place the more expensive Boolean expression second.
If the first subexpression is false and && is being used, then the expensive second subexpression is not evaluated; if the first subex¬ pression is true and | | is being used, then, again, the expensive second subexpression is avoided.
Subexpressions can be ordered to prevent run-time errors.
This is especially true when one of the.
Suppose you wish to print  word "OK" if a variable  is 1, 2, or 3.
The correct statement would be.
We can use nested i f statements to build arbitrarily complex control flow logic.
Listing |5_0_6|| (checkrange_0_cpp) behaves as follows:.
The program checks   >= 0 condition first.
If  is less than zero,  executing program does not evaluate  second condition and does not print In range, but it immediately executes  print statement following  outer i f statement which prints Done.
If  executing program finds  to be greater than or equal to zero, it checks  second condition.
If  second condition is met, it displays  In range message; otherwise, it is not.
Regardless,  program prints Done before it terminates.
For  program to display  message In range both conditions of this nested i f must be met.
Said another way,  first condition and  second condition must be met for  In range message to be printed.
Listing |5_0_7](newcheckrange_0_cpp) shows.
Listing |5_0_7[ (newcheckrange_0_cpp) uses a logical && to check both conditions at  same time.
Its logic is simpler, using only one i f statement, at  expense of a slightly more complex Boolean expression in its condition.
The second version is preferable here because simpler logic is usually a desirable goal.
Sometimes a program's logic cannot be simplified as in Listing [577[ (newcheckrange_0_cpp).
In Listing |5_0_8| (enhancedcheckrange_0_cpp) one i f statement alone is insufficient to implement  necessary behavior.
Listing |5/8| (enhancedcheckrange_0_cpp) provides a more specific message instead of a simple notification of acceptance.
The program prints exactly one of three messages based on   of  variable.
A single i f or i f /else statement cannot choose from among more than two different execution paths.
Listing 5_0_9 (binaryconversion_0_cpp) uses a series of i f statements to print a 10-bit binary string represent¬ ing  binary equivalent of a decimal integer supplied by  user.
The outer i f checks to see if    use provides is in  proper range.
The program works only for nonnegative integer values less than 1,024, so the range is 0-1023.
Each inner i f compares the user-supplied entered integer against decreasing powers of two.
If the number is large enough, the program: - prints the digit 1 to the console, and - removes via the remainder operator that power of two's contribution to the.
If the number is not at least as big as the given power of two, the program prints a 0 instead and moves on without modifying the input.
For the ones place at the end no check is necessary—the remaining  will be 0 or 1 and so the program prints whatever remains.
The following shows a sample run of Listing [5T9j (binaryconversion_0_cpp):.
Figure [53] illustrates the execution of Listing |5_0_9| (binaryconversion_0_cpp) when the user enters 805.
It uses only one i f statement.
The sole i f statement in Listing 5_0_10 (simplerbinaryconversion_0_cpp) ensures that the user provides an inte¬ ger in the proper range.
The other i f statements that originally appeared in Listing 5_0_9 (binaryconversion_0_cpp) are gone.
A clever sequence of integer arithmetic operations replace the original conditional logic.
The two programs— binaryconversion_0_cpp and simplerbinaryconversion_0_cpp —behave identically but simplerbinaryconversion_0_cpp's logic is simpler.
Listing |5_0_11 1 (troubleshoot.
This very simple troubleshooting program attempts to diagnose why a computer does not work.
The potential for enhancement is unlimited, but this version only deals with power issues that have simple fixes.
Notice that if the computer has power (fan or disk drive makes sounds or lights are visible), the program directs the user to seek help elsewhere.
The decision tree capturing the basic logic of the program is shown in Figure ||5/4j The steps performed are:.
If applicable, is the fuse blown.
Some computer systems have a user-serviceable fuse that can blow out during a power surge.
Is there power at the receptacle.
Perhaps the 's circuit breaker or fuse has a problem.
The program directs the user to make the easier checks first.
It progressively introduces more difficult checks as it continues.
Based on your experience with troubleshooting computers that do not run properly, you may be able to think of many enhancements to this simple program.
Note that in Listing |5_0_111| (troubleshoot_0_cpp) curly braces are used in many places where they strictly are not necessary.
Their inclusion in Listing |5TT](troubleshoot_0_cpp) improves the readability of the pro¬ gram and makes the logic easier to understand.
Even if you do not subscribe to the philosophy of using curly braces for every i f/else body, it is a good idea to use them in situations that improve the code's readability.
Suppose we wish to improve the English presentation by not using abbreviations.
If we spell out hours, minutes, and seconds, we must be careful to use the singular form hour, minute, or second when the corresponding value is one.
Listing 5_0_12 (timeconvcondl_0_cpp) uses if /else statements to express to time units with the correct number.
In Listing 5_0_13 (timeconvcond2_0_cpp) each code segment responsible for printing a time value and its English word unit is protected by an i f statement that only allows the code to execute if the time value is greater than zero.
The exception is in the processing of : if all time values are zero, the program should print 0.
Note that each of the i f /else statements responsible for determining the singular or plural form is nested within the i f statement that determines whether or not the value will be printed at all.
Listing |5i8| (enhancedcheckrange_0_cpp) showed how to select from among three options.
It prints exactly one of eight messages depending on the user's input.
Notice that each i f body contains a single printing statement and each else body, except the last one, contains an i f statement.
The control logic forces the program execution to check each condi¬ tion in turn.
The first condition that matches wins, and its corresponding i f body will be executed.
If none of the conditions are true, the last else's Too large message will be printed.
No curly braces are necessary to delimit the if or else bodies since each body contains only a single statement (although a single deeply nested i f/else statement is a mighty big statement).
The sequence of else i f lines all indented to the same level identifies this construct as a multi-way i f /else statement.
Listing 5_0_16 (datetransformer_0_cpp) uses a multi-way i f/else to transform a numeric date in month/day format to an expanded US English form and an international Spanish form; for example, 2/14 would be converted to February 14 and 14 febrero.
Figure 5_0_6 compares the structure of the if/else statements in a program such as Listing 5_0_15 (restyleddigittoword_0_cpp) to those in a program like Listing [5l9| (binaryconversion_0_cpp).
In a program like Listing 5_0_15 (restyleddigittoword_0_cpp), the i f/else statements are nested, while in a program like Listing 5_0_9 (binaryconversion_0_cpp) the i f/else statements are sequential.
Cplus_plus provides the tools to construct some very complicated conditional statements.
It is important to resist the urge to make things overly complex.
Consider the problem of computing the maximum of five integer values provided by the user.
The complete solution is left as an exercise in Section J57TO} but here we will outline an appropriate strategy.
Now, allow yourself one extra variable called max.
All variables have a meaning, and their names.
Set max equal to nl.
This means as far as we know at the moment, nl is the biggest number because max and nl have the same value.
Compare max to n2.
If n2 is larger than max, change max to have n2's value to reflect the fact that we determined n2 is larger; if n2 is not larger than max, we have no reason to change max, so do not change it.
Compare max to n3.
If n3 is larger than max, change max to have n3's value to reflect the fact that we determined n3 is larger; if n3 is not larger than max, we have no reason to change max, so do not change it.
Follow the same process for n4 and n5.
The extra variable max is not strictly necessary, but it makes thinking about the problem and its solution easier.
Something to think about: Do you want a series of i f statements or one large multiway i f /else construct.
Also, you may be tempted to write logic such as.
This will work, but this logic is much more complicated and less efficient ( >= and && operation requires a few machine cycles to execute).
Since it is more complicated, it is more difficult to write correctly, in addition to being more code to type in.
It is easy to use > by mistake instead  > =, which will not produce the correct results.
Also, if you use this more complicated logic and decide later to add more variables, you will need to change all  the i f conditions in your code and,  course, make sure to modify each one the conditions correctly.
If you implement the simpler strategy outlined before, you need only add one simple i f statement for each additional variable.
Chapter |6j introduces loops, the ability to execute statements repeatedly.
You easily can adapt the first approach to allow the user to type in as many numbers as they like and then have the program report the maximum number the user entered.
The second approach with the more complex logic cannot be adapted in this manner.
With the first approach you end up with cleaner, simpler logic, a more efficient program, and code that is easier to extend.
Listing [5_0_17| (badequality_0_cpp) demonstrates a common mistake—using the assignment operator where the equality operator is intended.
This program, when run, always prints the message "two" and insists the user entered 2 regardless  the actual.
Recall from Section |43| that the assignment expression has a value.
The value  an assignment expression is same as the value that is assigned; thus, the expression = 2.
Additionally, the variable i nput is always assigned the value 2.
Since it is such a common coding error, most Cplus_plus compilers can check for such misuse  assignment.
At warning Level 4, for example.
Visual Cplus_plus will issue a warning when assignment appears where a conditional expression is expected: warning C4706: assignment within conditional expression Occasionally the use  assignment within a conditional expression is warranted, so the compiler does not perform this check by default.
For our purposes it is good idea to direct the compiler to perform this extra check.
Carefully consider each compound conditional used, such as >0 &&  <= 10 found in Listing| [5_0_7j| (newcheckrange_0_cpp).
Confusing logical and and logical or is a common programming error.
If you substitute | | for &&, the expression x > 0 || x <— 10 is always true, no matter what  is assigned to the variable x.
A Boolean expression that is always true is known as a tautology.
If x is an i nt, what  could the variable x assume that would make x > 0 || x <— 10 false.
Regardless  its , one or both  the subexpressions will be true, so this compound logical or expression is always true.
This particular or expression is just a complicated way  expressing the true.
Another common error is contriving compound Boolean expressions that are always false, known as contradictions.
Suppose you wish to exclude values from a given range; for example, reject values in the range 0_0__0__0_10 and accept all other numbers.
Is the Boolean expression in the following code fragment up to the task.
What number can be both less than zero and greater than ten at the same timel None can,  course, so the expression is a contradiction and a compli¬ cated way  expressing false.
To correct this code fragment, replace the && operator with | |.
Write a Cplus_plus program that requests an integer value from the user.
If the value is between 1 and 100 inclusive, print "OK;" otherwise, do not print anything.
Write a Cplus_plus program that requests an integer value from the user.
If the value is between 1 and 100 inclusive, print "OK;" otherwise, print "Out of range_0_" 14.
The following program attempts to print a message containing the English word corresponding to a given integer input.
For example, if the user enters the value 3, the program should print "You entered a three".
In its current state, the program contains logic errors.
Locate the problems and repair them so the program will work as expected.
Write a Cplus_plus program that requests five integer values from the user.
It then prints the maximum and minimum values entered.
If the user enters the values 3, 2, 5, 0, and 1, the program would indicate that 5 is the maximum and 0 is the minimum.
Your program should handle ties properly; for example, if the user enters 2, 4, 2, 3, and 3, the program should report 2 as the minimum and 4 as maximum.
Write a Cplus_plus program that requests five integer values from the user.
It then prints one of two things: if any of the values entered are duplicates, it prints "DUPLICATES"; otherwise, it prints "ALL UNIQUE".
How would you write the code to  to 10,000.
Would you copy, paste, and modify 10,000 printing statements.
Counting is such a common activity, and computers routinely  up to very large values, so there must be a better way.
What we really would like to do is print the value of a variable (call it ), then increment the variable (countplus_plus), and repeat this process until the variable is large enough ( == 5 or perhaps  == 10000).
This process of executing the same section of code over and over is known as iteration, or looping , and in Cplus_plus we can implement loops in several different ways.
Listing 6_0_2 (iterativecounttofive_0_cpp) uses a while statement to display a variable that is counting up to five.
Unlike the approach taken in Listing [6T| (counttofive_0_cpp), it is trivial to modify Listing [672] (iterativecounttofive_0_cpp) to  up to 10,000—-just change the literal value 5 to 10000.
The expression within the parentheses must be a Boolean expression.
If the Boolean expression is true when the the program's execution reaches the whi le statement, the program executes the body of the whi le statement and then checks the condition again.
The program repeatedly executes the statement(s) within the body of the whi le as long as the Boolean expression remains true.
If the Boolean expression is true when the whi le statement is executed, the body of the whi le state¬ ment is executed, and the body is executed repeatedly as long as the Boolean expression remains true.
The statements std::cout <<  << '\n' ; countplus_plus; constitute the body of the whi le statement.
The curly braces are necessary since more than one statement makes up the body.
The while statement has the general form:.
The reserved word whi le begins the whi le statement.
The Boolean expression condition determines whether the body will be (or will continue to be) exe¬ cuted.
The expression must be enclosed within parentheses as shown.
The statement is the statement to be executed while the Boolean expression is true.
The statement makes up the body of the whi le statement.
The statement may be a compound statement (multiple statements enclosed within curly braces, see Section|_0_5_0_4|.
Except for using the reserved word while instead of i f, a whi le statement looks identical to an i f statement.
Sometimes beginning programmers confuse the two or accidentally type i f when they mean whi le or vice-versa.
Usually the very different behavior of the two statements reveals the problem immediately; however, sometimes, especially in nested complex logic, this mistake can be hard to detect.
Figure [6_0_1 1 shows how program execution flows through Listing |6_0_2|| (iterativecounttofive_0_cpp).
The program checks the whi le's condition before executing the body, and then re-checks the condition each time after it executes the body.
If the condition is initially false the program's execution skips the body completely and continues executing the statements that follow the whi le's body.
If the condition is initially true, the program repeatedly executes the body until the condition becomes false, at which point the loop terminates.
Program execution then continues with the statements that follow the loop's body, if any.
Observe that the body may never be executed if the Boolean expression in the condition is initially false.
Listing j6_0_3| (countup_0_cpp) counts up from zero as long as the user wishes to do so.
The Boolean variable  controls the loop's execution.
It is important to note that the expression inside the while's condition evaluates to the opposite truth value of the variable ; the expression does not affect the value of.
Listing [6T4] (addnonnegatives_0_cpp) is a program that allows a user to enter any number  nonnegative integers.
When the user enters a negative value, the program no longer accepts , and it displays the.
The initialization  i  to zero coupled with the condition i  >= 0  the whi le guarantees that program will execute the body  the while loop at least once.
The if statement ensures that a negative entry will not be added to sum.
The program's execution then leaves the loop and executes the print statement at the end.
Listing 6_0_4 (addnonnegatives_0_cpp) shows that a whi le loop can be used for more than simple counting.
The program does not keep track  the number  values entered.
The program simply accumulates the.
It is a little awkward in Listing |6~4| (addnonnegatives_0_cpp) that the same condition appears twice, once in the whi le and again in the i f.
Furthermore, what if the user wishes to enter negative values along with nonnegative values.
We can simplify the code with a common Cplus_plus idiom that uses std : : ci n and the extraction operator as a condition within a whi le statement.
If x is an integer, the expression.
When the user enters ' q ' , the loop is terminated.
If the user types ' q ' at the beginning, the loop is not entered.
The i f statement is no longer necessary, since the statement += ; can be executed only if i  has been legitimately assigned.
Also, the variable i  no longer needs to initialized with a value simply so the loop is entered the first time; now it is assigned and then checked within the condition  the whi le.
In Listing ||6_0_5|(addnumbers_0_cpp), the program's execution will terminate with any letter the user types; an entry  ' x ' or Ctrl-Z will terminate the sequence just as well as ' q '.
It you wish to use this technique and reuse std : : ci n later, you must reset std : : ci n and extract and discard keystrokes entered since the last valid use  the extractor operator.
This recovery process is covered in Section [13l2| but, for now, use this idiom to control a loop only if the program does not require additional user later during its execution.
It is customary to right justify a column  numbers, but Listing j6_0_6|| (powersofl O_0_cpp) prints the powers ten with their most-significant digit left aligned.
We can right align the numbers using a stream object called a steam manipulator.
The specific stream manipulator we need is named std : :.
Observe that in order to use  the compiler needs to be made aware  it.
The needed information about std : :  is not found in the i ostream header file, so an additional preprocessor include directive is required: ttinclude <iomanip> The std: :  manipulator "conditions" the output stream for the next item to be printed.
The values passed to the "conditioned" stream are all right justified within the number  spaces specified by std: :.
As an aside, this is good place to reveal another trick to improve the output  a Cplus_plus program.
We can use a whi le statement to make Listing 5_0_11 (troubleshoot.
The bulk of the body of the Listing 6_0_9 (troubleshootloop_0_cpp)is wrapped by a whi le statement.
The Boolean variable  is often called a flag.
You can think of the flag being down when the value is false and raised when it is true.
In this case, when the flag is raised, it is a signal that the program should terminate.
In the way this code is organized, the matching opening curly brace of a particular closing curly brace can be found by scanning upward in the source code until the closest opening curly brace at the same indentation level is found.
Our programming logic is now getting complex enough that the proper placement of curly braces is crucial for human readers to more quickly decipher how the program should work.
See Section|43] for guidelines on indentation and curly brace placement to improve code readability.
Just like in i f statements, while bodies can contain arbitrary Cplus_plus statements, including other while statements.
A loop can therefore be nested within another loop.
To see how nested loops work, consider a program that prints out a multiplication table.
Elementary school students use multiplication tables, or times tables, as they learn the products of integers up to 10 or even 12.
Figure|6_0_3(shows a 10 x 10 multiplication table.
We want our multiplication table program to be flexible and allow the user to specify the table's size.
We will begin our development work with a simple program and add features as we go.
First, we will not worry about printing the table's row and column titles, nor will we print the lines separating the titles from the contents of the table.
Initially we will print only the contents of the table.
We will see we need a nested loop to print the table's contents, but that still is too much to manage in our first attempt.
In our first attempt we will print the rows of the table in a very rudimentary manner.
Once we are satisfied that.
Listing [6_0_10| (timestable-1 st-try_0_cpp) does indeed print each  in its proper place—it just does not supply the needed detail for each.
Our next step is to refine the way the program prints each.
Each should contain size numbers.
Each number within each  represents the product of the current and current column; for example, the number in  2, column 5 should be 2  5 = 10.
In each , therefore, we must vary the column number from from 1 to size.
Listing 6_0_11 (timestable-2nd-try_0_cpp) contains the needed refinement.
The numbers within each column are not lined up nicely, but the numbers are in their correct positions rela¬ tive to each other.
We can use the std : : setw stream manipulator introduced in Listing 6_0_7 (powersof 10justified_0_cpp) to right justify the numbers within a four-digit area.
Listing (6T2] (timestable-3rd-try_0_cpp) contains this align¬ ment adjustment.
Listing |Q3| (timestable_0_cpp) adds the necessary code.
This is how Listing |6_0_13|| (timestable_0_cpp) works:.
It is important to distinguish what is done only once (outside all loops) from that which is done repeatedly.
The column heading across the top of the table is outside of all the loops; therefore, it is printed all at once.
The work to print the heading for the rows is distributed throughout the execution of the outer loop.
This is because the heading for a given row cannot be printed until all the results for the previous row have been printed.
A code fragment like if (x < 10) std::cout << " " ; std::cout << x; prints x in one of two ways: if x is a one-digit number, it prints a space before it; otherwise, it does not print the extra space.
The net effect is to right justify one and two digit numbers within a two character space printing area.
This technique allows the columns within the times table to be properly right aligned.
In the nested loop, row is the control variable for the outer loop; column controls the inner loop.
A newline is printed after the contents of each row is displayed; thus, all the values printed in the inner (column) loop appear on the same line.
Nested loops are used when an iterative process itself must be repeated.
In our times table example, a whi le loop is used to print the contents of each row, but multiple rows must be printed.
The inner loop prints the contents of each row, while the outer is responsible for printing all the rows.
Listing |6T4| (permuteabc_0_cpp) uses a triply-nested loop to print all the different arrangements of the letters A, B, and C.
Each string printed is a permutation of ABC.
The executing program checks this condition only at the "top" of the loop.
This means that even if the Boolean expression that makes up the condition becomes false before the program completes executing all the statements within the body of the loop, all the remaining statements in the loop's body must complete before the loop can once again check its condition.
In other words, the while statement in and of itself cannot exit its loop somewhere in the middle of its body.
Ordinarily this behavior is not a problem.
Usually the intention is to execute all the statements within the body as an indivisible unit.
Sometimes, however, it is desirable to immediately exit the body or recheck the condition from the middle of the loop instead.
Cplus_plus provides the break and conti nue statements to to give programmers more flexibility designing the control logic of loops.
The break statement causes the immediate exit from the body of the loop.
Listing|6_0_f5j(addmiddleexit_0_cpp) is a variation of Listing |6~4].
The condition of the whi le in Listing 6_0_15 (addmiddleexit_0_cpp) is a tautology.
This means the condition is true and can never be false.
When the program's execution reaches the whi le statement it is guaranteed to enter the loop's body and the whi le loop itself does not provide a way of escape.
The i f statement in the loop's body:.
In this case the break statement, executed conditionally based on the value of the variable i nput, exits the loop.
In Listing 6_0_15 (addmiddleexit_0_cpp) the break statement executes only when the user enters a negative number.
When the program's execution encounters the break statement, it immediately jumps out of the loop.
It skips any statements following the break within the loop's body.
Some software designers believe that programmers should use the break statement sparingly because it deviates from the normal loop control logic.
Ideally, every loop should have a single entry point and single exit point.
While Listing 6_0_15 (addmiddleexit_0_cpp) has a single exit point (the break statement), some programmers commonly use break statements within while statements in the which the condition for the while is not a tautology.
Adding a break statement to such a loop adds an extra exit point (the top of the loop where the condition is checked is one point, and the break statement is another).
Using multiple break statements within a single loop is particularly dubious and you should avoid that practice.
Why have the break statement at all if its use is questionable and it is dispensable.
The logic in Listing ||6_0_4|| (addnonnegatives_0_cpp) is fairly simple, so the restructuring of Listing |6_0_15|| (addmiddleexit_0_cpp) is straightforward; in general, the effort to restructure code to avoid a break statement may complicate the logic a bit and require the introduction of an additional Boolean variable.
As shown in Figure |6i4( any program that uses a break statement can be rewritten so that the break statement is not used.
The no-break version introduces a Boolean variable, and the loop control logic is a little more com¬ plicated.
The no-break version uses more memory (an extra variable) and more time to execute (requires an extra check in the loop condition during every iteration of the loop).
This extra memory is insignificant, and except for rare, specialized applications, the extra execution time is imperceptible.
In most cases, the more important issue is that the more complicated the control logic for a given section of code, the more difficult the code is to write correctly.
In some situations, even though it violates the "single entry point, single exit point" principle, a simple break statement is an acceptable loop control option.
A break statement is insufficient to jump completely out of the middle of a nested loop.
The goto statement allows the program's execution flow to jump to a specified location within the function.
Listing f6_0_16| (exitnested_0_cpp) uses a goto statement to jump out from the middle of a nested loop.
When  * 2 is 3731, program flow will jump to the specified label within the program.
In this example, the label is named end, but this name is arbitrary.
Like variable names, label names should be chosen to indicate their intended purpose.
The label here named end comes after and outside the nested whi le loops.
A label's name is an identifier (see Section |3_0_3| , and a label is distinguished by the colon that immedi¬ ately follows its name.
A label represents a target to which a goto can jump.
A goto label must appear before a statement within a function.
With the goto statement, the whi le is superfluous; for example.
Listing 6_0_2 (iterativecounttofive_0_cpp) could be rewritten without the whi le statement as shown in Listing 6_0_17 (gotoloop_0_cpp).
Early programming languages like FORTRAN and early versions of BASIC did not have structured statements like whi le, so programmers were forced to use goto statements to write loops.
The problem with using goto statements is that it is easy to develop program logic that is very difficult to understand, even for the original author of the code.
See the Wikipedia article about spaghetti code (http : //en.
The structured programming revolution of the 1960s introduced constructs such as the whi le statement and resulted in the disappearance of the use of goto in most situations.
All modern programming languages have a form of the whi le statement, so the goto statement in Cplus_plus is largely ignored except for the case of breaking out of a nested loop.
You similarly should restrict your use of the goto statement to the abnormal exit of nested loops.
The conti nue statement is similar to the break statement, except the conti nue statement does not necessarily exit the loop.
The conti nue statement skips the rest of the body of the loop and immediately checks the loop's condition.
If the loop's condition remains true, the loop's execution resumes at the top of the loop.
Listing 6_0_18 (continueexample_0_cpp) shows the conti nue statement in action.
Programmers do not use the continue statement as frequently as the break statement since it is easy.
The transformation is simpler than for break elimination (see Fig¬ ure since the loop's condition remains the same, and no additional variable is needed.
The version that uses conti nue is no more efficient than the version that uses else; in fact, the Vi¬ sual Cplus_plus and GNU Cplus_plus compilers generate the same machine language code for Listingj|67l8||(continueexample_0_cpp) and Listing 6_0_19 (nocontinueexample_0_cpp).
Also, the logic of the else version is no more complex than the continue version.
Therefore, unlike the break statement above, there is no compelling reason to use the continue statement.
Sometimes a programmer may add a continue statement at the last minute to an existing loop body to handle an exceptional condition (like ignoring negative numbers in the example above) that initially went unnoticed.
If the body of the loop is lengthy, the programmer can add a condi¬ tional statement with a continue near the top of the loop body without touching the logic of the rest of the loop.
The conti nue statement thus merely provides a convenient alternative for the programmer.
The else version is preferred.
Some infinite loops are by design; for example, a long-running server application, like a Web.
Figure 6_0_5 The code on the left generically represents any loop that uses a continue statement.
All too often, however, beginning programmers create infinite loops by accident, and these infinite loops represent logic errors in their programs.
Intentional infinite loops should be made obvious.
It is easy to write an intentional infinite loop.
Accidental infinite loops are quite common, but can be puzzling for beginning programmers to diagnose and repair.
Consider Listing |6720|| (findfactors_0_cpp) that attempts to print all the integers with their associated factors from 1 to 20.
This type of behavior is a frequent symptom of an unintentional infinite loop.
The factors of 1 display properly, as do the factors of 2.
The first of 3 is properly displayed and then the program hangs.
Since the program is short, the problem may be easy to locate.
In some programs, though, the error may be challenging to find.
Even in Listing |6_0_20| (findfactors_0_cpp) the debugging task is nontrivial since it involves nested loops.
Perhaps the programmer intended to use a && instead of | | to stay in the loop as long as  remains in the range 1_0__0_.
In Listing |6720| (findfactors_0_cpp) the outer loop condition is <= If  is 21 and  is 20, then the condition is false, so this is not a tautology.
Checking the inner loop condition: <= we see that if f acto r is 3 and  is 2, then the expression is false; therefore, it also is not a tautology.
The condition of a whi le must be true initially to gain access to its body.
The code within the body must modify the state of the program in some way so as to influence the outcome of the condition that is checked at each iteration.
This usually means code within the body of the loop modifies one of the variables used in the condition.
Eventually the variable assumes a value that makes the condition false, and the loop terminates.
In Listing ||6^20|| (findfactors_0_cpp) the outer loop's condition involves the variable  and constant.
Fortunately, the last statement in the body of the outer loop increments.
The inner loop's condition involves the variables  and.
No statement in the inner loop modifies , so it is imperative that  be modified in the loop.
The good news is  is incremented in the body of the inner loop, but the bad news is the increment operation is protected within the body of the  f statement.
The inner loop contains one statement, the  f statement.
That f statement in turn has two statements in its body:.
This new  runs correctly.
Programmers can use a debugger to step through a program to see where and why an infinite loop arises.
Another common technique is to put print statements in strategic places to examine the values of the.
Under these conditions: 1_0_2 < 3 is true, so the loop continues and 2.
This section provides several examples that show off the power of conditional execution and iteration.
Our program, however, must vary its height and width based on input from the user.
Listing [fT2T| (startree_0_cpp) provides the necessary functionality.
The program will execute the outer whi le loop's body as long as the user enters a value greater than zero; if the user enters zero or less, the program terminates and does nothing.
This is the expected behavior.
The last statement in the body of the outer whi le:.
There is no possibility of an infinite loop here.
The body of the outer loop consists of more than one statement; therefore, the body must be enclosed within curly braces.
Whenever a group of statements is enclosed within curly braces a block is formed.
Any variable declared within a block is local to that block.
A variable's scope (the section of the source code in which the variable exists and can be used) is from its point of declaration to the end of the block in which it is declared.
For example, the variables height and  are declared in the block that is mai 's body; thus, they are local to mai.
The variable  is declared within the block that is the body of the outer whi le statement; therefore,  is local to the outer whi le statement.
An attempt to use  outside the body of the outer while statement would be an error.
What does it mean for a variable x to be local to a particular section of code.
It means x does not exist outside its scope.
There may be other variables in the program named x, but they are different variables.
If it seems odd that you can have two different variables in the same program with the same name, consider the fact that there can be two people in the same room with the same name.
They are different people, but they have the same name.
Similarly, the meaning of a variable depends on its context, and its name is not necessarily unique.
The two inner loops play distinct roles;.
The first inner loop prints spaces.
The number of spaces printed is equal to the height of the tree the first time through the outer loop and decreases each iteration.
This is the correct behavior since each succeeding  moving down contains fewer leading spaces but more asterisks.
The second inner loop prints the  of asterisks that make up the tree.
The first time through the outer loop,  is zero, so no left side asterisks are printed, one central asterisk is printed (the top of the tree), and no right side asterisks are printed.
Each time through the loop the number of left-hand and right-hand stars to print both increase by one and the same central asterisk is printed; therefore, the tree grows one wider on each side each line moving down.
Observe how the 2* + 1 value expresses the needed number of asterisks perfectly.
While it seems asymmetrical, note that no third inner loop is required to print trailing spaces on the line after the asterisks are printed.
The spaces would be invisible, so there is no reason to print them.
For example, 29 is a prime number (only 1 and 29 divide into it with no remainder), but 28 is not (2, 4, 7, and 14 are factors of 28).
Prime numbers were once merely an intellectual curiosity of mathematicians, but now they play an important role in cryptography and computer security.
The task is to write a program that displays all the prime numbers up to a value entered by the user.
The logic of Listing |6722| (printprimes_0_cpp) is a little more complex than that of Listing |6_0_21| (startree_0_cpp).
The main loop (outer whi le iterates over all the values from two to max_value:.
Two new , local to the body of the outer loop, are introduced:  and i s_pri me.
The expression  %  is zero when  divides into with no remainder—exactly when tri al_f actor is a factor of.
If the executing program determines that any of the values of tri al_factor is a factor of , then it sets i s_pri me to false and exits the loop via the break.
If the loop continues to completion, the program never sets i s_pri me to false, which means it found no factors and  is indeed prime.
The i f statement after the inner loop:.
If  is true, then  must be prime, so it prints  along with an extra space for separation from output it may produce during subsequent iterations.
Some important questions we can ask include: 1.
If the user enters a 2, will it be printed.
In this case  =  = 2, so the condition of the outer loop <= is true,  2 <= 2.
Thus, the inner loop is skipped, i s _ p r i me is not changed from true, and 2 is printed.
This behavior is correct because 2 is the smallest prime number (and the only even prime).
The whi le condition ensures that values less than two are not considered.
The body of the whi le will never be entered.
Only the newline is printed, and no numbers are displayed.
This behavior is correct.
Is the inner loop guaranteed to always terminate.
In order to enter the body of the inner loop,  must be less than , does not change anywhere in the loop.
Eventually, tri al_factor will equal , and the loop will terminate.
Is the outer loop guaranteed to always terminate.
In order to enter the body of the outer loop,  must be less than or equal to.
Since the inner loop is guaran¬ teed to terminate as shown in the previous answer, eventually  will exceed  and the loop will end.
This version without the break introduces a slightly more complicated condition for the whi le but re¬ moves the i f statement within its body, i s_p ri me is initialized to true before the loop.
Each time through the loop it is reassigned, tri al_factor will become false if at any time  % is zero.
This is exactly when  is a factor of.
If  becomes false, the loop cannot continue,  if  never becomes false, the loop ends when  be¬ comes equal to.
Due to operator precedence, the parentheses are not necessary.
The parentheses do improve readability,  an expression including  ==.
When parentheses are placed where they are not needed, as in = (y + 2) ;.
Recall that with the post-increment operator the  of the variable is used in the surrounding expression (if any),  then the variable is incremented.
Since the whi le's body now contains only one statement, the curly braces are not needed.
In Listing 6_0_4 (addnonnegatives_0_cpp) could the condition  the i f statement have used > instead >=  achieved the same results.
In Listing 6_0_4 (addnonnegatives_0_cpp) could the condition  the whi le statement have used > instead >=  achieved the same results.
Use a loop to rewrite the following code fragment so that it uses just one std : :coutandone '\n'.
In Listing 6_0_4 (addnonnegatives_0_cpp) what would happen if the statement containing std : : ci n is.
How many asterisks does the following code fragment print.
How many asterisks does the following code fragment print.
How many asterisks does the following code fragment print.
What is printed by the following code fragment.
What is printed by the following code fragment.
Rewrite the following code fragment using  break statement and eliminating the  variable.
Your code should behave identically to this code fragment.
Rewrite the following  fragment so it eliminates the conti nue statement.
Suppose you were given some  from the 1960s in  language that did not support structured statements like whi le.
Your task is to modernize it and adapt it to Cplus_plus.
The following  fragment has been adapted to Cplus_plus already, but you must now structure it with  whi le statement to replace the gotos.
Your  should be goto free and still behave identically to this  fragment.
What is printed by the following  fragment.
Write  Cplus_plus program that accepts  single integer value entered by the user.
If the value entered is less than one, the program prints nothing.
If the user enters  positive integer, , the program prints.
Write  Cplus_plus program that allows the user to enter exactly twenty double-precision floating-point.
Write  Cplus_plus program that allows the user to enter any number of nonnegative double-precision floating-point values.
The user terminates the input list with any negative value.
The program then prints the sum, average (arithmetic mean), maximum, and minimum of the values entered.
The termi¬ nating negative value is not used in the computations.
If the first number the user supplies is negative, the program simply prints the text NO NUMBERS PROVIDED.
Redesign Listing [6_0_211 (startree_0_cpp) so that it draws  sideways tree pointing right; for example, if.
The if /else and while statements are sufficient to implement any algorithms that involve conditional execution and looping.
The break and conti nue statements are convenient but are not necessary.
Cplus_plus provides some additional conditional and iterative statements that are more convenient to use in some circumstances.
These additional statements include.
This chapter explores these other forms of expressing conditional execution and iteration.
The swi tch statement provides  convenient alternative for some multi-way  f/else statements like the.
The reserved word swi tch identifies a swi tch statement.
The required parenthesized expression that follows the word swi tch must evaluate to an integral value.
Any integer type, characters, and Boolean expressions are acceptable.
Floating point expres¬ sions and other non-integer types are forbidden.
The body of the swi tch is enclosed by required curly braces.
Each occurrence of the word case is followed by an integral constant and a colon (:).
We call the integral constant a case label.
This label can be either a literal value or a const symbolic value (see Section |3_0_6|.
In particular, non-const variables and other expressions are expressly forbidden.
The case label defines a position within the code; it is not an executable statement.
A case label represents a target to which the program's execution flow can jump.
If the case label matches the switch's expression, then the statements that follow that label are executed up until the break statement is encountered.
The statements and break statement that follow each case label are optional.
One way to execute one set of statements for more than one case label is to provide empty statements for one or more of the labels, as in: std::cin >> key; // get key from user.
If the user enters neither P nor Q, none of the statements in the swi tch is executed.
When a case label is matched, the statements that follow are executed until a break statement is encountered.
The control flow then transfers out of the body of the swi tch.
In this way, the break within a swi tch works just like a break within a loop: the rest of the body of the statement is skipped and program execution resumes at the next statement fol¬ lowing the body.
A missing break statement, a common error, when its omission is not intentional, causes the statements of the succeeding case label to be executed.
The process continues until a break is encountered or the end of the swi tch body is reached.
The default label is matched if none of the case labels match.
It serves as a catch all option like the final else in a multi-way i f /else statement.
The default label is optional.
If it is missing and none of the case labels match the expression, then no statement within the swi tch's body is executed.
The swi tch statement has two restrictions that make it less general than the multi-way i f /else:.
The swi tch argument must be an integral expression.
Case labels must be constant integral values.
Integral literals and constants are acceptable.
Variables or expressions are not allowed.
To illustrate these restrictions, consider the following i f /else statement that translates easily to an equiv¬ alent swi tch statement:.
This code cannot be easily translated into a swi tch statement.
The variable y cannot be used as a case label.
The second choice checks for an inequality instead of an exact match, so direct translation to a case label is impossible.
In the last condition, a different variable is checked,  instead of.
The control flow of a switch statement is determined by a single value (for example, the value of ), but a multi-way i f/else statement is not so constrained.
Where applicable, a swi tch statement allows programmers to compactly express multi-way selection logic.
Most programmers find a swi tch statement easier to read than an equivalent multi-way i f/else construct.
A positive consequence of the swi tch statement's restrictions is that it allows the compiler to produce more efficient code for a swi tch than for an equivalent i f/else.
If a choice must be made from one of several or more options, and the swi tch statement can be used, then the swi tch statement will likely be faster than the corresponding multi-way i f/else.
It has limited application but is convenient nonetheless.
The following code fragment assigns one of two things to :.
The conditional operator uses two symbols (.
Since it has three operands it is classified as a ternary operator (Cplus_plus's only one).
The overall type of a conditional expression is the more dominant of exp\ and expi The conditional expression can be used anywhere an expression can be used.
It is not a statement itself; it is used within a statement.
As another example, the absolute value of a number is defined in mathematics by the following formula: ■ | _ ( n , when n > 0 ' n ' [ — n, when n< 0 In other words, the absolute value of a positive number or zero is the same as that number; the abso¬ lute value of a negative number is the additive inverse (negative of) of that number.
The following Cplus_plus expression represents the absolute value of the variable n:.
To seasoned Cplus_plus programmers it is quite understandable, but it is used sparingly because of its very specibc nature.
Here's how it works:.
The condition of the whi le specifies a set that includes all values that are not in the desired range.
The initialization of in_valueto—1 ensures the condition of the while will be true initially, and, thus, the program always will execute the loop's body at least one time.
The user does not get a chance to enter a value until program's execution is inside the loop.
The initialization of i n_value before the loop check is somewhat artificial.
It is there only to ensure entry into the loop's body.
It seems unnatural to check for a valid value before the user gets a chance to enter it.
A loop that checks its condition after its body is executed at least once would be more appropriate.
The do/while statement is a bottom-checking loop that behaves exactly in this manner.
Listing 7_0_3 (betterinputonly_0_cpp) uses a do/whi le statement to check for valid input.
Figure 7_0_1 compares the flowcharts of a while and do/while loop.
The do/while statement has the general form:.
The condition is associated with the while at the end of the loop.
The condition is a Boolean expression and must be enclosed within parentheses.
The statement is exactly like the statement in the general form of the whi le loop (see Section 6J).
It can be a compound statement enclosed within curly braces.
The body of a do/while statement, unlike the while statement, is guaranteed to execute at least once.
The do/whi le loop is a convenience to the programmer and is not an essential programming construct.
It is easy to transform any code that uses a do/while statement into code that behaves identically that uses a whi le statement instead.
In practice, programmers use whi le loops much more frequently than do/whi le loops because more algorithms require top-checking loops than bottom-checking loops.
The do/whi le statement is included in Cplus_plus for a reason, however.
Transforming an algorithm that can be expressed more naturally with a bottom-checking loop into one the uses a top-checking loop can lead to awkward code.
Use do/whi le when appropriate.
It simply counts from one to five.
Counting is a frequent activity performed by computer programs.
Certain program elements are required in order for any program to count:.
A variable must be used to keep track of the count; in Listing [672] (iterativecounttofive_0_cpp), count is the aptly named counter variable.
The counter variable must be given an initial value.
In the case of Listing| |6_0_2| (iterativecounttofive_0_cpp), the initial value is 1.
The variable must be modified (usually incremented) as the program counts.
A way must be provided to determine if the counting has completed.
In Listing j|6_0_2| (iterativecounttofive_0_cpp), the condition of the whi le statement determines if the counting is complete or must contine.
Cplus_plus provides a specialized loop that packages these four programming elements into one convenient statement.
Called the for statement, its general form is.
The header, contained in parentheses, contains three parts, each separated by semicolons: - Initialization.
The initialization part assigns an initial value to the loop variable.
The loop variable may be declared here as well; if it is declared here, then its scope is limited to the f o r statement.
This means you may use that loop variable only within the loop.
It also means you are free to reuse that variable's name outside the loop to declare a different variable with the same name as the loop variable.
The initialization part is performed one time.
The condition part is a Boolean expression, just like the condition of a while statement.
The condition is checked each time before the body is executed.
The modification part generally changes the loop variable.
The change should be such that the condition will eventually become false so the loop will terminate.
The modification is performed during each iteration after the body is executed.
Notice that the last part ( modification ) is not following by a semicolon; semicolons are used strictly to separate the three parts.
The statement is like the body of any other loop.
It may be a compound statement within curly braces.
With a whi le loop, the four counting components (variable declaration, initialization, condition, and modification can be scattered throughout the code.
With a for loop, a programmer should be able to determine all the important information about the loop's control by looking at one statement.
Recall Listing [6_0_13j (timestable_0_cpp) that prints a multiplication table on the screen.
A for loop is ideal for stepping through the rows and columns.
The information about the control of both loops is now packaged in the respective for statements instead of being spread out in various places in ma i n.
In the while version, it is easy for the programmer to forget to update one or both of the counter variables (row and/or column).
The for makes it harder for the programmer to forget the loop variable update, since it is done right up front in the for statement header.
It is considered bad programming practice to do either of the following in a for statement:.
Modify the loop control variable within the body of the loop —if the loop variable is modified within the body, then the logic of the loop's control is no longer completely isolated to the f o r state¬ ment's header.
The programmer must look elsewhere within the statement to understand completely how the loop works.
Prematurely exit the loop with a break — this action also violates the concept of keeping all the loop control logic in one place (the for's header).
The language allows both of these practices, but experience shows that it is best to avoid them.
If it seems necessary to violate this advice, consider using a different kind of loop.
The whi le and do/whi le loops do not imply the same degree of control regularity expected in a for loop.
Listing 7_0_6 (permuteabcd_0_cpp) is a rewrite of Listing 6_0_14 (permuteabc_0_cpp) that replaces its while.
As shown in Listing 7_0_7 fforprintprimes_0_cpp), the conditional expression in the for loop is not limited to a simple test of the loop control variable; it can be any legal Boolean expression.
Programmers can use the logical and (&&), or {| |), and not (_0_) operators to create complex Boolean expressions, if necessary.
The modification part of the for loop is not limited to simple arithmetic and can be quite elaborate.
While the for statement supports such complex headers, simpler is usually better.
Ordinarily the for loop should manage just one control variable, and the initialization, condition, and modification parts should be straightforward.
If a particular programming situation warrants an overly complicated f o r construction, consider using another kind of loop.
Any or all of the parts of the for statement (initialization, condition, modification, and body) may be omitted:.
A break or goto must appear in the body unless an infinite loop is intended.
If the modification is missing, as in.
Some programmers use an empty loop to produce a non-portable delay in the program's execution.
A programmer may, for example, need to slow down a graphical animation.
Such an attempt using an empty loop is non-portable for several reasons.
If the program actually executes the loop, slower computers will delay longer than faster computers.
The timing of the program's delay will differ from one computer to another.
Worse yet, some compilers may detect that such code has no functional effect and optimize away the empty loop.
This means the compiler will ignore the for statement altogether.
One common C/Cplus_plus idiom to make an intentional infinite loop is to use a f o r statement with all control.
While the f o r statement supports the omission of parts of its header, such constructs should be avoided.
The intention of the for loop is to allow the programmer to see all the aspects of the loop's control in one place.
If some of these control responsibilities are to be handled elsewhere (not in the for's header) then consider using another kind of loop.
Programmers usually select a simple name for the control variable of a for statement.
Recall that variable names should be well chosen to reflect the meaning of their use within the program.
It may come as a surprise that  is probably the most common name used for an integer control variable in a for loop.
This practice has its roots in mathematics where variables such as , , and k are commonly used to index vectors and matrices.
Such mathematical structures have programming analogs in arrays and vectors, which we explore in Chapter 11 Computer programmers make considerable use of for loops in array.
Cplus_plus allows the break, conti nue, and goto statements to be used in the body of a for statement.
Like with the while and do/whi le statements, break causes immediate loop termination, continue causes the condition to be immediately checked to determine if the iteration should continue, and goto jumps to a label somewhere in the function.
As previously mentioned, however, f o r loop control should be restricted to its header, and the use of break, conti nue, and goto within for loops should be avoided.
Any for loop can be rewritten with a whi le loop and behave identically.
For example, consider the f o r loop for (int  = 1;  <= 10; iplus_plus) std::cout <<  << '\n' ;.
The for loop conveniently packages the loop control information in its header, but in the whi le loop this information is distributed throughout the small section of code.
The for loop thus provides a better organization of the loop control code.
Does one loop outperform the other.
No, most compilers produce essentially the same code for both constructs.
Thus, the for loop is preferred in this example.
Consider the following code fragment,.
What is printed when What is printed when What is printed when What is printed when What is printed when What is printed when What is printed when the user enters a.
What is printed by the following code fragment.
Rewrite the following code fragment so that a swi tch is used instead of the  f/else statements.
Rewrite the following code fragment so that a multi-way i f/else is used instead of the swi tch statement.
Rewrite the following code fragment so that a multi-way i f/else is used instead of the swi tch statement.
Rewrite the following code fragment so a whi le loop is used instead of the for statement.
Rewrite the following code fragment so that it uses the conditional operator instead of an  f state¬.
Enter number: 100 root is 50_0_5 root is 26_0_2401 root is 15_0_0255 root is 10_0_8404 root is 10_0_0326 root is 10_0_0001 root is 10 Square root  100 = 10.
While this code may be acceptable for many applications, better algorithms exist that work faster and produce more precise answers.
Another problem with the code is this: What if you are working on a significant scientific or engineering application and must use different formulas in various parts  the source code, and each  these formulas involve square roots in some way.
In mathematics, for example, you use square root to compute the distance between two geometric points (\ ,}') and { 2 ,yi) as.
In electrical engineering and physics, the root mean square  a set  values {a\ ,a 2 -ai _0__0__0__0_.
Must we copy and paste the relevant portions  the square root code in List¬ ing 18711 (computesquareroot_0_cpp) to each location in our source code that requires a square root compu¬ tation.
Also, what if we develop another program that requires computing a root mean square.
Will we need to copy the code from Listing [8TT| (computesquareroot_0_cpp) into every program that needs to compute square roots, or is there a better way to package the square root code and reuse it.
Code is made reusable by packaging it in functions.
A function is a unit  reusable code.
In Chapter[9j we will write our own reusable functions, but in this chapter we examine some  the functions available in the Cplus_plus standard library.
Cplus_plus provides a collection  standard precompiled C and Cplus_plus code stored in libraries.
Programmers can use parts  this library code within their own code to build sophisticated programs.
In mathematics, a function computes a result from a given ; for example, from the function definition f() = 2 + 3, we can  /(5) = 13  /(0) = 3.
A function in Cplus_plus works like a mathematical function.
To introduce the function concept, we will look at the standard Cplus_plus function that implements mathematical square root.
In Cplus_plus, a function is a named sequence  code that performs a specific task.
A program itself consists a collection  functions.
One example  a function is the mathematical square root function.
Such a function, named sqrt, is available to C  Cplus_plus programs (see Section [8_0_2|.
The square root function accepts one numeric   produces a double  as a result; for example, the square root  16 is 4, so when presented with 16_0_0, sqrt responds with 4_0_0.
Figure |87T| visualizes the square root function.
For the programmer using the sqrt function within a program, the function is a black box; the pro¬ grammer is concerned more about what the function does, not how it does it.
This sq rt function is exactly what we need for our square root program, Listing|8_0_1||(computesquareroot_0_cpp).
Listing j |8T2|| (standardsquareroot_0_cpp), uses the library function sqrt  eliminates the.
The sqrt function is among them.
Table |8_0_l[ lists some  the other commonly used mathematical functions available in the cmath library.
The compiler needs this augmented code so it can check to see if we are using the sqrt function properly.
The expression sqrt(input) is a function invocation, also known as a.
A function provides a service to the code that uses it.
Here, our mai n function is the caller 1 that uses the service provided by the sqrt function.
We say mai n calls, or invokes, sq rt passing it the value  i nput.
The expression sq rt(i nput) evaluates to the square root  the value  the variable input.
Behind the scenes—inside the black box as it were— precompiled C code uses the value  the input variable to  its square root.
There is nothing special about this precompiled C code that constitutes the sq rt function; it was written by a programmer or team  programmers working for the library vendor using the same tools we have at our disposal.
In In Chapter |9j we will write our own functions, but for now we will enjoy the functions that others have provided for us.
When calling a function, a pair  parentheses follow the function's name.
We also can say "we are passing input to the sq rt function_0_" While we might say "we are passing i nput to the sqrt function," the program really is not giving the function access to mai n's i nput variable.
The sqrt function itself cannot change the value  mai n's i nput variable, it simply uses the variable's value to perform the computation.
The following simple analogy may help explain how the communication works between main sqrt.
The mai n function has work to do, but instead  doing all the work itself, it delegates some the work (in this case the hard part) to sq rt.
When mai n needs to  the square root  i nput, it writes down the value  its i nput variable on a piece  paper  hands it to sqrt.
The sqrt function accepts mai n's note  begins working on the task (computing the square root  the number on the note mai n gave it).
When it is finished, sqrt does two things; sqrt hands back to main a different piece  paper with the answer,  sqrt throws away the piece  paper main originally passed to it.
When main receives the note from sq rt it uses the information on the note  then discards the note.
The mai n function then can continue with its other business.
The sq rt function thus has no access to mai n's original i nput variable; it has only a copy  i nput, as if "written on a piece  paper_0_" (Similarly, if the sq rt function uses any variables to do its work, mai n is oblivious to them  has no way to access them_0_) After sqrt is finished  returns to main its computed answer, sqrt discards its copy  i nput (by analogy, the function "throws away" the paper with the copy  i nput that mai n gave it).
Thus, during a function call the parameter is a temporary, transitory value used only to communicate information to the function.
The parameter lives only as long as the function is executing.
Figure j[K2[ illustrates a program's execution involving simple function calls.
Figure 8_0_2 shows that a program's execution begins in its mai n function.
Here mai n calls the sqrt function twice.
A vertical bar represents the time that a function is active, or "alive_0_" A function's variables.
Figure 8_0_2 The diagram on the right visualizes the execution of the program on the left.
Time flows from left to right.
A rectangular bar represents the time that a function is active.
A Cplus_plus program's execution begins with its man n function.
Here, man n calls the sqrt function twice.
The shaded parts of mai n's bar shows the times mai n has to wait for sqrt to complete.
Observe that the main function is active for the duration of the program's.
The sqrt function accepts a single numeric argument.
The parameter that a caller can pass to sqrt can be a literal number, a numeric variable, an arithmetic expression, or even a function invocation that produces an acceptable numeric result.
Some Cplus_plus functions, like sq rt,  a   return it to the caller.
The caller can use this result in various ways, as shown in Listing ||8_0_3| (usingsqrt_0_cpp).
The next to the last statement passes the result of calling sq rt to sq rt, thereby computing \J \/256, which is 4.
If the caller code attempts to pass a parameter to the function that is incompatible with the type expected by the function, the compiler will issue an error.
Listing [83] (usingsqrt_0_cpp) shows that a program can call the sqrt function as many times and in as many places as needed.
As noted in Figure |8_0_1j| to the caller of the square  function, the function is a black box; the caller is concerned strictly about what the function does, not how the function accomplishes its task.
We safely can treat all functions as black boxes.
We can use the service that a function provides without being concerned about its internal details.
We are guaranteed that we can influence the function's behavior only via the parameters that we pass, and that nothing else we do can affect what the function does or how it does it.
Furthermore, the function cannot affect any of our code, apart from what we do with the  it computes.
Some functions take more than one parameter; for example, the Cplus_plus  function requires two argu¬ ments in order to produce a result.
The  function selects and returns the larger of the two parameters.
The  function  visualized in Figure| [8T3| The  function could be used as.
Notice that the parameters are contained in parentheses following the function's name, and the parameters.
From the caller's perspective a function has three important parts:.
Every function has a name that identifies the location of the code to be executed.
Function names follow the same rules as variable names; a function name  another example of an identifier (see Section |373|.
A caller must provide the exact number and types of parameters that a function expects.
If a caller attempts to call a function with too many or too few parameters, the compiler will issue an error message and not compile the code.
Similarly, if the caller passes parameters that are not compatible with the types specified for the function, the compiler will report appropriate error messages.
A function can compute a result and return this  to the caller.
The caller's use of this result must be compatible with the function's specified result type.
The result type returned to the caller and the parameter types passed in by the caller can be completely unrelated.
In a function prototype, the return type  listed first, followed by the function's name, and then the param¬.
The names make it easier to describe what the function does; for example, sq rtcomputes the square  of n and  determines the larger of a and b.
When using a library function the programmer must  the appropriate #  directive in the source code.
The file specified in an #i nclude directive contains prototypes for library functions.
Unlike mathematical functions that must produce a result, Cplus_plus does not require a function to return a value to its caller.
The Cplus_plus function exit expects an integer value from the caller, but it does not return a result back to the caller.
A prototype for a function that returns nothing uses voi d as the return type, as in:.
The exi t function immediately terminates the program's execution.
The integer argument passed to exi t returned to the operating system which can use the value to determine if the program terminated normally or due to an error.
Cplus_plus programs automatically return zero when mai n finishes executing—no exi t call necessary.
A void function  useful for the side effects it produces instead a value it computes.
Example side effects  printing something on the console, sending data over a network, or animating a graphical image.
Computes the cosine of a value specified in radians: cos () = cosx; other trigonometric.
The cmath library also defines a constant named HUGE_VAL.
Programmers can use this constant to represent infinity or an undefined value such the slope of a vertical line or a fraction with a zero denominator.
A complete list of the numeric functions available to Cplus_plus can be found at http : / /www _0_cplusplus.
The spacecraft's distance to the planet, therefore, also  fixed.
A satellite  orbiting the planet in a circular orbit.
We wish to compute how much farther away the satellite will be from the spacecraft when it has progressed 10 degrees along its orbital path.
We will let the origin of our coordinate system (0,0) be located at the center of the planet which cor¬ responds also to the center of the circular orbital path.
The satellite is initially at point (xi,yi) and the spacecraft is stationary at point (p Xl p  ).
The spacecraft is located in the same plane as the satellite's orbit.
We need to compute the difference in the distances between the moving point (satellite) and the fixed point (spacecraft) at two different times during the satellite's orbit.
Facts from mathematics provide solutions to the following two problems:.
Figure 8_0_4 Orbital distance problem.
In this diagram, the satellite begins at  [\,\), a distance of d\.
Solution: Given an initial  (\ ,) of the moving , a rotation of 0 degrees around the origin will yield a new  at ( 2 ,}' 2 ), where 2 = xicos0 — yjsin0 = xi sin0 +  cos0.
We can use the square root function to improve the efficiency of our primes program.
We say that the sqrt function is over¬ loaded.
If the caller passes a double parameter, the compiler generates code to call the double version.
If the caller instead passes a float variable, the compiler selects the float version of sqrt.
When an i nt is passed to sqrt, the compiler cannot decide which version to use, because an i nt can be converted automatically to either a float, double, or long double.
The compiler thus needs some help to resolve the ambiguity, so we intro¬ duced an additional variable of type double so the compiler will use the double version of the sqrt function.
Another option is to use a type cast to convert the integer  into one of the types acceptable to the sqrt function.
The clock function from the <cti me> library requests from the operating system the amount of time an executing program has been running.
The units returned by the call clock () is system dependent, but it can be converted into seconds with the constant CLOCKS_PER_SEC, also defined in the cti me library.
Under Visual Cplus_plus, the CLOCKS_PER_SEC constant is 1,000, which means the call clock () returns the number of milliseconds that the program has been running.
Using two calls to the clock function you can measure elapsed time.
Listing 8_0_7 (timeit_0_cpp) measures.
In the expression static_cast<double> (other - seconds)/CLOCKS_PER_SEC the cast is required to force floating- division; otherwise, the result is truncated to an integer.
By comparison, the newer, more efficient version, Listing [875j (moreefficientprimes_0_cpp), which uses the square root optimization takes only 15 seconds to display all the primes up to 500,000.
Exact times will vary depending on the speed of the computer.
As it turns out, much of the program's execution time is taken up printing the output, not computing the prime numbers to print.
We can compare the algorithms better by redirecting the program's output to a file.
If the executable program is named primes_0_exe, you can redirect its output at the command line by issuing the command.
This creates a text file named runl _0_out that can be viewed with any text editor.
Its contents are exactly what would have been printed to the screen if the redirection is not used.
When run using redirection, the time difference is even more dramatic: The unoptimized version gen¬ erates the prime numbers up to 500,000 in 77 seconds, while the optimized square root version requires only 2 seconds to generate the same number of primes.
An even faster prime generator can be found in Listing |ll,25| (fasterprimes_0_cpp); it uses a completely different algorithm to generate prime numbers.
You must #i nclude the <cti me> header to use the standard ti me function in a program.
At the enhanced warning level 4 for.
Other functions exist to determine if  character is  punctuation character like  comma or semicolon.
To use the standard C character functions in your Cplus_plus program, you must include the <cctype> header.
Random numbers are useful particularly in games and simulations.
For example, many board games use  die (one of  pair of dice) to determine how many places  player is to advance.
A die is  cube containing spots on each of its six faces.
The number of spots range from one to six.
A player rolls  die or sometimes  pair of dice, and the side(s) that face up have meaning in the game being played.
The  of  face after  roll is determined at random by the complex tumbling of the die.
A software adaptation of  game that involves dice would need  way to simulate the random roll of  die.
All algorithmic random number generators actually produce pseudorandom numbers, not true random numbers.
A pseudorandom number generator has  particular period, based on the nature of the algorithm used.
If the generator is used long enough, the pattern of numbers produced repeats itself exactly.
A sequence of true random numbers would not contain such  repeating subsequence.
The good news is that all practical algorithmic pseudorandom number generators have periods that are large enough for most applications.
Cplus_plus programmers can use two standard C functions for generating pseudorandom numbers: srand and rand:.
Each call to rand.
The numbers printed by the program appear to be random.
The algorithm is given  seed  to begin, and  formula is used to produce the next.
The seed  determines the sequence of numbers gener¬ ated; identical seed values generate identical sequences.
If you run the program again, the same sequence is displayed because the same seed , 23, is used.
In order to allow each program run to display different sequences, the seed  must be different for each run.
How can we establish  different seed  for each run.
The best way to make up  "random" seed at run time is to use the ti me function which is found in the cti me library.
The call ti me (0) returns the number of seconds since midnight January 1, 1970.
This  obviously differs between program runs, so each execution will use  different seed , and the.
Notice that the numbers returned by rand can be rather large.
The pseudorandom values range from 0 to  maximum value that is implementation dependent.
The maximum value for Visual Cplus_pluss rand function is 32,767, which corresponds to the largest 16-bit si gned i nt value.
The cstdli  header defines the constant RAND_MAX that represents the largest value in the range.
The following statement.
Ordinarily we need values in  more limited range, like 1_0__0__0_100.
Simple arithmetic with the modulus operator can produce the result we need.
If n is any nonnegative integer and in is any positive integer, the expression.
Suppose you need to compute the square root of a number in a Cplus_plus program.
Would it be a good idea to write the code to perform the square root calculation.
In Cplus_plus source code what is one way to help you distinguish a variable name from a function name.
Ordinarily how often should a program call the srand function.
In Listing 8_0_2 (standardsquareroot_0_cpp), what does the mai n function do while the sqrt function is computing the square root of the argument that mai n provides.
Consider each of the following code fragments below that could be part of a Cplus_plus program.
Each fragment contains a call to a standard C/Cplus_plus library function.
Answer each question in one of the following three ways:.
If the code fragment contains a compile-time error, write the word error for the answer.
If the code fragment contains no compile-time errors and you can determine its output at compile-time, provide the fragment's literal output.
If the code fragment contains no compile-time errors but you cannot determine its exact output at compile-time, provide one possible evaluation and write the word example for the answer and provide one possible literal output that the code fragment could produce.
From geometry: Write  computer program that given the lengths of the two sides of  right triangle adjacent to the right angle computes the length of the hypotenuse of the triangle.
As programs become more complex, programmers must structure their programs in such  way as to ef¬ fectively manage their complexity.
Most humans have  difficult time keeping track of too many pieces of information at one time.
It is easy to become bogged down in the details of  complex problem.
The trick to managing complexity is to break down the problem into more manageable pieces.
Each piece has its own details that must be addressed, but these details are hidden as much as possible within that piece.
The problem is ultimately solved by putting these pieces together to form the complete solution.
So far all of our programs have been written within one function—mai n.
As the number of statements within  function increases, the function can become unwieldy.
The code within such  function that does all the work by itself is called monolithic code.
Monolithic code that is long and complex is undesirable for several reasons:.
It is difficult to debug.
If the sequence of code does not work correctly, it is often difficult to find.
Using  divide and conquer strategy,  programmer can decompose  complicated function (like mai n) into several simpler functions.
The original function can then do its job by delegating the work to these other functions.
In this way the original function can be thought of as  "work coordinator_0_" Besides their code organization aspects, functions allow us to bundle functionality into reusable parts.
In Chapter[8jwe saw how library functions can dramatically increase the capabilities of our programs.
While we should capitalize on library functions as much as possible, sometimes we need  function exhibiting custom behavior that is not provided by any standard function.
Fortunately we can create our own functions, and the same function may be used (called) in numerous places within  program.
If the function's purpose is general enough and we write the function properly, we may be able to reuse the function in other programs as well.
Recall the "handwritten" square root code we saw in Listing |8_0_11 (computesquareroot_0_cpp).
We know that the better option is the standard library function sqrt; however, we will illustrate custom function devel¬ opment by writing our own square root function based on the code in Listing |8_0_1| (computesquareroot_0_cpp).
In Listing |9T|(customsquareroot_0_cpp) we see the definition for the square_root function.
Clearly we should use the standard sqrt function instead of.
There are two aspects to every Cplus_plus function:.
The definition of  function specifies the function's return type and parameter types, and it provides the code that determines the function's behavior.
In Listing |9_0_1| (customsquareroot_0_cpp) the definition of the square_root function appears above the mai n function.
A programmer uses a function via a function invocation.
The main function invokes both our square_root function and the sqrt function.
Every function has exactly one definition but may have many invocations.
Name —every function in Cplus_plus has a name.
The name is an identifier (see Section 3_0_31.
Type —every function has a return type.
If the function returns a value to its caller, its type corre¬.
Parameters —every function must specify the types of parameters that it accepts from callers.
The parameters appear in a parenthesized comma-separated list like in a function prototype (see Sec¬ tion [OJ).
Unlike function prototypes, however, parameters usually have names associated with each type.
Body —every function definition has a body enclosed by curly braces.
The body contains the code to be executed when the function is invoked.
Figure [9_0_1 [ dissects a our square_root function definition.
The prompt function simply prints a message.
The program runs as follows: 1.
The program's execution, like in all Cplus_plus programs, begins with the first executable statement in the function named mai n.
The first line in the mai n function simply declares some variables needed for compiler housekeeping, so the next line actually begins the executable code.
The first executable statement prints the message of the program's intent.
The next statement is a call of the prompt function.
At this point the program's execution transfers to the body of the prompt function.
The code within prompt is executed until the end of its body or until a return statement is encountered.
Since prompt contains no return statement, all of prompt's body (the one print statement) will be executed.
When prompt is finished, control is passed back to the point in mai n immediately after the call of prompt.
The next action after prompt call reads the  of valuel from the keyboard.
A second call to prompt transfers control back to the code within the prompt function.
It again prints its message.
When the second call to prompt is finished, control passes back to mai n at the point of the second input statement that assigns 2 from the keyboard.
The remaining two statements in mai n are executed, and then the program's execution terminates.
Our prompt and counttolQ functions are a bit underwhelming.
The prompt function could be eliminated, and each call to prompt could be replaced with the statement in its body.
The same could be said for the counttolQ function, although it is convenient to have the simple one-line statement that hides the complexity of the loop.
Using the prompt function does have one advantage, though.
If prompt is removed and the two calls to p r ompt are replaced with the print statement within prompt, we have to make sure that the two messages printed are identical.
If we simply call prompt, we know the two messages printed will be identical because only one possible message can be printed (the one in the body of prompt).
We can alter the behavior of a function through a mechanism called parameter passing.
If a function is written to accept information from the caller, the caller must supply the information in order to use the function.
The caller communicates the information via one or more parameters as required by the function.
The counttolQ function does us little good if we sometimes want to count up to a different number.
Listing |93| (countton_0_cpp) generalizes Listing [9(4] (countto1 Ofunc_0_cpp) to count as high as the caller needs.
A caller must pass exactly one integer parameter (or other type that is assignment-compatible with integers) to count_to_n during a call.
An attempt to do otherwise will result in a compiler error or warning: count_to_n(); // Error, missing parameter during the call.
A quick look at the first line of prompt's definition confirms our assumption:.
Because prompt is declared to return an  nt , it must contain a retu rn statement.
A retu rn statement specifies the exact  to return to the caller.
When a return is encountered during a func¬ tion's execution, control immediately passes back to the caller.
The  of the function call is the specified by the return statement, so the statement = promptQ ;.
Note that in Listing 9_0_6 (betterprompt_0_cpp), we declared a variable named result inside the prompt function.
This variable is local to the function, meaning we cannot use this particular variable outside of prompt.
It also means we are free to use that same name outside of the prompt function in a different context, and that use will not interfere with the result variable within prompt.
We can further enhance our prompt function.
Currently prompt always prints the same message.
Using parameters, we can customize the message that prompt prints.
In the first line of the function definition: int prompt (int ) is called the formal parameter.
A formal parameter is used like a variable within the function's body, but it is declared in the function's parameter list; it is not declared in the function's body.
A formal parameter is a parameter as used in the formal definition of the function.
The parameters used within a function definition are called formal parameters.
Formal parameters behave as local variables within the function's body; as such, the name of a formal parameter will not conflict with any local variable or for¬ mal parameter names from other functions.
This means as a function developer you may choose a parameter name that best represents the parameter's role in the function.
If you are writing a function, you cannot predict the caller's actual parameters.
You must be able to handle any value the caller sends.
The compiler will ensure that the types of the caller's parameters are compatible with the declared types of your formal parameters.
A formal parameter is a parameter declared and used in a function's formal definition.
An actual parameter is a parameter supplied by the caller when the caller actually uses (invokes or calls) the function.
A function's definition requires that all formal parameters be declared in the paren¬ theses following the function's name.
A caller does not provide actual parameter type declarations when calling the function.
Given the square_root function defined in Listing |9_0_1| (customsquareroot_0_cpp), the following caller code fragment is illegal:.
The special type voi d indicates that the function does not return a.
The name of the function is an identifier (see Section |33).
The function's name should indicate the purpose of the function.
The parameterlist is a comma separated list of pairs of the form type name where type is a Cplus_plus type and name is an identifier representing a parameter.
The caller of the func¬ tion communicates information into the function via parameters.
The parameters specified in the parameter list of a function definition are called formal parameters.
A parameter is also known as an argument.
The parameter list may be empty; an empty parameter list indicates that no information may be passed into the function by the caller.
The body is the sequence of statements, enclosed within curly braces, that define the actions that the function is to perform.
The statements may include variable declarations, and any variables declared within the body are local to that function.
The body may contain only one statement, many statements, or no statements at all; regardless, the curly braces always are required.
Observe that multiple pieces of information can be passed into a function via multiple parameters, but only one piece of information can be passed out of the function via the return.
Recall the greatest.
Consider the problem of dividing a piece of plywood 24 inches long  18 inches wide into square pieces of maximum size without wasting any material.
Since the (24, 18) = 6, we can cut the plywood into twelve 6 inch x 6 inch square pieces as shown in Figure |Sh2).
If we cut squares larger than 6 inches x 6 inches, not all the plywood can be used to make the squares.
Figure |9_0_4| shows how some larger squares would fare.
In addition to basic arithmetic and geometry, the  function plays a vital role in cryptography, enabling secure communication across an insecure network.
Listing 9_0_8 (gcdprog_0_cpp) implements a straight-forward but naive algorithm that seeks potential factors considering every integer less than the smaller of the two values provided  the user.
This algorithm is not very efficient, especially for larger numbers.
Its logic is easy to follow, with no deep mathematical insight required.
Soon we will see a better algorithm for computing.
If we need to compute the  from several different places within our program, we should package the code in a function rather than copying it to multiple places.
The following code fragment defines a Cplus_plus function that that computes the greatest common divisor of two integers.
It determines the largest factor (divisor) common to its parameters:.
This function is named gcd and expects two integer arguments.
Its formal parameters are named numl and num2.
It returns an integer result.
Its body declares three local variables: mi n, , and ( is local to the for statement).
The last line in its body is a return statement.
A return statement is required for functions that return a value.
Avoid function is not required to have a retu r n statement.
If a void function does have a retu r n statement, it must simply consist of retu rn followed  a semicolon (in other words, it cannot return a value, like gcd's return statement does).
A voi d function that does not contain a retu r n statement simply returns at the end of its body.
Recall from Section |6_0_5| that local variables have meaning only within their scope.
This means that when you write a function you can name a local variable without fear that its name may be used already in another part of the program.
Two different functions can use local variables named x, and these are two different variables that have no influence on each other.
Anything local to a function definition is hidden to all code outside that function definition.
Since a formal parameter is a local variable, you can reuse the names of formal parameters in different functions without a problem.
It may seem strange that we can use the same name in two different functions within the same program to refer to two distinct variables.
The block of statements that makes up a function definition constitutes a context for local variables.
A simple analogy may help.
In the United States, many cities have a street named Main Street ; for example, there is a thoroughfare named Main Street in San Francisco, California.
Dallas, Texas also has a street named Main Street.
Each city and town provides its own context for the use of the term Main Street.
A person in San Francisco asking "How do I get to Main Street_0_" will receive the directions to San Francisco's Main Street, while someone in Dallas asking the same question will receive Dallas-specific instructions.
In a similar manner, assigning a variable within a function block localizes its identity to that function.
We can think of a program's execution as a person traveling around the The United States When.
A program's thread of execution cannot execute more than one statement at a time, which means the compiler can use its current context to interpret any names it encounters within a statement.
Similarly, at the risk of overextending the analogy, a person cannot be physically located in more than one city at a time.
Furthermore, Main Street may be a bustling, multi-lane boulevard in one large city, but a street  the same name in a remote, rural township may be a narrow dirt road.
Similarly, two like-named variables may have two completely different types.
A variable named x in one function may represent an integer, while a different function may use a string variable named x.
Another advantage of local variables is that they occupy space in the computer's memory only when the function is executing.
Space is allocated for local variables and parameters when the function begins executing.
When the function is finished and control returns to the caller, the variables and parameters go out of scope, and the memory they held is freed up for other purposes within the running program.
This process of local variable allocation and deallocation happens each time a caller invokes the function.
More information about how Cplus_plus handles memory management during a program's execution can be found in Section lll8_0_ll Once we have written a complete function definition we can use the function within our program.
We invoke a programmer-defined function in exactly the same way as a standard library function like sqrt (Section 8_0_2) or rand (Section 8_0_6).
If the function returns a value (that is, it is not declared void), then we can use its invocation anywhere an expression of that type is allowed.
The parameters used for the function call are known as actual parameters.
The function gcd can be called as part of an assignment statement: int  = gcd(val, 24);.
Variables, expressions, and literals can be freely used as actual parameters.
The function then computes and returns its result.
This result is assigned to the variable.
How does the function call and parameter mechanism work.
It's actually quite simple.
The actual parameters, in order, are assigned (bound) to each of the formal parameters in the function definition, then control is passed to the body of the function.
When the function's body is finished executing, control passes back to the point in the program where the function was called.
The value returned by the function, if any, replaces the function call expression.
In the statement int  = gcd(val, 24); an integer value is assigned to.
The expression on the right is a function call, so the function is invoked to determine what to assign.
The value of the variable val is assigned to the formal parameter numl, and the literal value 24 is assigned to the formal parameter num2.
The body of the gcd function is then executed.
When the return statement in the body is encountered, program execution returns back to where the function was called.
The argument of the return statement becomes the value that is assigned to.
This process of copying actual parameters to formal parameters works exactly like during assignment.
This means the compiler, where possible, automatically will widen or narrow (see Section |4_0_2j ) the value of an actual parameter to make it compatible with its corresponding formal parameter; for example, if val is declared to a cha r, its value would automatically be copied to a temporary location and converted to an  nt.
This temporary value would then be bound to the formal parameter numl.
Note that gcd could be called from many different places within the same program, and, since different parameter values could be passed at each of these different invocations, gcd could compute a different result at each invocation.
Other invocation examples include:.
The result of the call is then assigned to x.
Since the right side of the assignment statement is evaluated before being assigned to the left side, the original value of x is used when calculating x - 2, and the function return value then updates x.
Since the function returns an inte¬ ger value its result can itself be used as an actual parameter in a function call.
Passing the result of one function call as an actual parameter to another function call is called function composition.
The compiler will report an error if a function call does not agree with the function's definition.
Possible problems include:.
Number of actual parameters do not agree with the number of formal parameters.
Passing an actual parameter that is not assignment compatible with the formal parameter.
For example, passing the std : :  object when an i nt has been defined, as in int  = gcd(36, std::); // Error: second parameter is wrong type The compiler will detect that std: :coutis not a valid int and report an error.
Using the result in a context where an expression of that type is not allowed.
For example, a function that returns void cannot be used where an int is expected: std:: << srand(2); // Error: srand does not return anything.
This means the value of the actual parameter is copied to the formal parameter for the purpose of executing the function's code.
Since it is working on a copy of the actual parameter, the function's execution cannot affect the value of the actual parameter owned by the caller.
Listing |9)9| (passbyvalue_0_cpp) illustrates the consequences of pass by value.
Before increment,  = 5 Beginning execution of increment,  = 5 Ending execution of increment,  = 6 After increment,  = 5 The memory for the variable  in mai n is unaffected since i ncrement works on a copy of the actual parameter.
Cplus_plus supports another way of passing parameters called pass by reference.
Pass by reference is intro¬ duced in Section ri0_0_9l A function communicates its return value to the caller in the same way that the caller might pass a parameter by value.
In the prompt function we saw earlier:.
We informally may say we are returning the result variable, but, in fact, we really are returning only the value of the result variable.
The caller has no access to.
In fact, the local variables for a function exist only when the function is active (that is, executing).
When the function returns to its caller all of its local variables disappear from memory.
During subsequent invocations, the function's local variables reappear when the function becomes active and disappear again when it finishes.
Listing |9T0| (primefunc_0_cpp) illustrates several important points about well-organized programs:.
The complete work of the program is no longer limited to the mai n function.
The effort to test for primality is delegated to a separate function, ma i n is focused on a simpler task: generating all the numbers to be considered and using another function (is_prime)todo the hard work of determin¬ ing if a given number is prime, main is now simpler and more logically coherent.
A function is coherent when it is focused on a single task.
Coherence is a desirable property of functions.
If a function becomes too complex by trying to do too many different things, it can be more difficult to write correctly and debug when problems are detected.
A complex function should be decomposed into several, smaller, more coherent functions.
The original function would then call these new ¬ pler functions to accomplish its task.
Here, mai n is not concerned about how to determine if a given number is prime; main simply delegates the work to i s_pri me and makes use of the i s_pri me function's findings.
Each function is preceded by a thorough comment that describes the nature of the function.
It explains the meaning of each parameter, and it indicates what the function should return.
The comment for mai n may not be as thorough as for other functions; this is because mai n usually has no parameters, and it always returns a code to the operating system upon the program's termination.
While the exterior comment indicates what the function is to do, comments within each function explain in more detail how the function accomplishes its task.
The call to i S_pri me returns  or  depending on the  passed to it.
This means we can express a condition like if (is_prime() == ).
The expression i s_prime () suffices.
Just as it is better for a loop to have exactly one entry point and exactly one exit point, preferably a function will have a single return statement.
Simple functions with a small number of returns are.
We now can easily adapt that concept to a function.
Listing 9_0_12 (betterinputfunc_0_cpp) uses a function named get_i nt_ range.
The high and low values are specified by parameters.
This makes the function more flexible since it could be used elsewhere in the program with a completely different range specified and still work correctly.
The function is supposed to be called with the lower number passed as the  parameter and the higher number passed as the second parameter.
The function will also accept the parameters out of.
These important components of the program are now in functions, so their details can be perfected independently from mai n.
Note how the result of the call to roll is passed directly as an argument to show_di e.
During the call, the value of mai n's hei ght variable is copied into to the formal parameter in tree also named hei ght.
The compiler can keep track of which hei ght is which based on where each is declared.
Just as 1/3 cannot be represented finitely in the decimal (base 10) number system, 1/10 cannot be represented exactly in the binary (base 2) number system with a fixed number of digits.
Often, no problems arise from this imprecision, and in fact many software applications have been written using floating-point numbers that must perform precise calculations, such as directing a spacecraft to a distant planet.
In such cases even small errors can result in complete failures.
Floating-point numbers can and are used safely and effectively, but not without appropriate care.
To build our confidence with floating-point numbers, consider Listing ||97T5']| (simplefloataddition_0_cpp),.
We are adding 0_0_1, just as in Listing ||97T5| (simplefloataddition_0_cpp), but now there is a prob¬ lem.
Since 0_0_1 cannot be represented exactly within  constraints of  double-precision floating-point representation,  repeated addition of 0_0_1 leads to round off errors that accumulate over time.
Whereas 0_0_1 + 0_0_9 rounded off may equal 1, 0_0_1 added to itself 10 times may be 1_0_000001 or 0_0_999999, neither of which is exactly 1.
When comparing two floating¬ point numbers x  v, we essentially must determine if  absolute value of their difference is small; example, \x — y\ < 0_0_00001.
C abs function was introduced in Section 8_0_2  we can incorporate it.
Since Cplus_plus uses short-circuit evaluation Boolean expressions involving logical OR (see Section |52) , if  == operator indicates equality,  more elaborate check is not performed.
You should use a function like equals when comparing two floating-point values  equality.
We can decompose  code into functions as shown in List¬ ing ^TOj(timestablefunction_0_cpp).
Our goal is to have a collection of functions that each are very simple.
We also want  program's overall structure to be logically organized.
Figure 9_0_5 A trace of  activation of  various functions in Listing 9_0_18 ftimestablefunction_0_cpp) when.
In Listing 9_0_18 (timestablefunction_0_cpp), each function plays a very specific role;  example, row_ header prints  label  a particular row and then prints  vertical bar that separates  row label from  body of  table.
We reuse  get_i nt_range function from Listing 9_0_12 (betterinputfunc_0_cpp).
Notice that there no longer appear to be any nested loops in  program.
Observe that  p r i nt_contents function contains a loop.
Each time through  loop it calls pri nt_row, but pri nt_row itself contains a loop.
The nested iteration, therefore, is still present.
Realistically, the functional decomposition within Listing |9_0_18| (timestablefunction_0_cpp) is extreme.
The relative simplicity of the program does not not really justify eight separate functions each with such a narrow focus; however, more complex software systems are decomposed in this very manner.
Not only does Listing [9T8 (timestablefunction_0_cpp) give us insight into how we can take a complicated problem and break it down into simpler, more manageable pieces, we can use the program to better understand how the function invocation process works.
To see how, consider the situation where a user wishes to print a 3 x 3 multiplication table using Listing 9T8|(timestablefunction_0_cpp).
Functions of type void have no labels on their return arrows.
This means that mai n's value variable.
This is not true for the variables used in get_i nt_range: , in_value, , and the parameters  and.
These variables maintained by get_int_range appear automatically when get_i nt_range begins executing (the left end of its bar) and their space is released when get_i nt_range is finished (the right end of its bar; 1 During the printing of a 3 x 3 table the program calls pri nt_row three times, and for each call the function's parameters row and column and local variable col come to life and then disappear when the function returns.
The following points are important in the parsing process:.
The earlier definition of the twi ce function declares the identifier twi ce to the compiler.
Conse¬ quently the compiler expects a caller to twi ce to pass a single argument that is compatible with the i nt type.
The compiler also knows that the call to twi ce will return an integer value.
The parentheses after the name twi ce in the statement indicate the expression is a function call.
Within the parentheses is the integer literal 5, which clearly is compatible with the i nt type.
The expression twi ce (5) thus evaluates to an i nt, and the << operator can send integer values to the std : :  output stream object.
The compiler thus can verify that the code within the main function is using the twi ce function correctly.
If we instead place twi ce's definition after the mai n function's definition, the compiler will report an error where twi ce's call appears within mai n.
This is because the compiler parses Cplus_plus source code line by line from top to bottom within the _0_cpp file.
When the compiler sees the identifier  first at its 'Technically, the run-time environment does not allocate the space for a local variable until after its point of declaration.
For variables declared within blocks, like temp with the i f body, the variable is discarded at the end of the block's execution.
The compiler needs to know a function's return type and parameter types in order to verify that the caller is invoking the function correctly.
As it turns out, we can satisfy the compiler's need to know about the twi ce function as used in mai n without providing its full definition.
Listing |I9_0_20I| (organization2_0_cpp) provides a alternate organization of.
It essentially is a function definition without the func¬ tion's body.
A semicolon terminates the declaration, and no curly braces appear in a function declaration.
We can provide a name the parameter, but that is not necessary.
A function declaration provides all the information the compiler needs to determine if a caller is invoking the function correctly.
The function is available to any callers that appear after the declaration within the source file.
This means that any code within main that appears after twi ce's declaration can use twi ce, but code outside of main cannot (unless other functions themselves independently provide their own declaration of twi ce.
Listing 9_0_22 (localfuncdefl _0_cpp) and Listing 9_0_23 (localfuncdef2_0_cpp) provide a concrete example of the difference between a local and a global declaration.
Note that while Cplus_plus allows us to declare a function within the body of another function, it does not.
They argue that this better represents the way the compiled code executes—the ma i  method begins running first, and it calls the other functions.
As we read the source code from top to bottom we see the details of the mai  function before seeing the implementation details of the functions that mai  calls.
A more frequent way to organize functions within Cplus_plus source code is to separate function declarations, function invocations, and function definitions into their own distinct files.
The function declarations go into one or more _0_h header files, the function definitions appear in one or more _0_cpp files, and the calling code (including mai ) appear in a separate _0_cpp file.
The compiler compiles all the _0_cpp files separately, producing multiple machine language object files (_0_obj files in Visual Cplus_plus).
The linker then combines these separate object files into a single executable file.
Section|l0_0_6||covers this technique is detail.
It is good practice to comment a function's definition with information that aids programmers who may need to use or extend the function.
The essential information includes:.
The purpose of the function.
The function's purpose is not always evident merely from its name.
This is especially true for functions that perform complex tasks.
A few sentences explaining what the function does can be helpful.
The role of each parameter.
The parameter names and types are obvious from the definition, but the purpose of a parameter may not be apparent merely from its name.
It is helpful indicate the purpose of each parameter, if any.
While the function may do a number of interesting things as indicated in the function's purpose, what exactly does it return to the caller.
It is helpful to clarify exactly what value the function produces, if any.
Other information is often required in a commercial environment:.
Author of the function.
Specify exactly who wrote the function.
An email address can be included.
If questions about the function arise, this contact information can be invaluable.
Date that the function's implementation was last modified.
An additional comment can be added each time the function is updated.
Each update should specify the exact changes that were made and the person responsible for the update.
If the code was adapted from another source, list the source.
The reference may consist of a Web URL.
The following fragment shows the beginning of a well-commented function definition:.
Armed with our knowledge of function definitions, we can rewrite Listing |8_0_l| (computesquareroot_0_cpp) so.
Is Listing l9_0_24| (squarerootfunction_0_cpp) better than Listing l8_0_2| (standardsquareroot_0_cpp) which uses the standard sqrt function from the cmath library.
Generally speaking, if you have the choice of using a standard library function or writing your own custom function that provides the same functionality, choose to use the standard library routine.
The advantages of using the standard library routine include:.
Your effort to produce the custom code is eliminated entirely; you can devote more effort to other parts of the application's development.
If you write your own custom code, you must thoroughly test it to ensure its correctness; standard library code, while not immune to bugs, generally has been subjected to a complete test suite.
Library code is used by many developers, and thus any lurking errors are usually exposed early; your code is exercised only by the programs you write, and errors may not become apparent immediately.
If your programs are not used by a wide audience, bugs may lie dormant for a long time.
Standard library routines are well known and trusted; custom code, due to its limited exposure, is suspect until it gains wider exposure and adoption.
Standard routines are typically tuned to be very efficient; it takes a great deal of effort to make custom code efficient.
Standard routines are well-documented; extra work is required to document custom code, and writing good documentation is hard work.
Listing f9_0_25| (squarerootcomparison_0_cpp) tests our custom square root function over a range of 1,000,000,000 floating-point values.
Listing 9_0_25 (squarerootcomparison_0_cpp) uses our equals function from Listing 9_0_17 (floatequals_0_cpp).
The third parameter specifies  tolerance; if the difference between the first two parameters is less than the specified tolerance, the first two parameters are considered equal.
Our new  square_root function uses the equals function.
The main function uses the equals function as well.
Observe, however, that the tolerance used within the square  computation is smaller than the tolerance main uses to check the result.
The main function, therefore, uses  less strict notion of equality.
Five wrong answers out of one billion tests represents  0_0_0000005% error rate.
While this error rate is very small, indicates our square_root function is not perfect.
One of values that causes the function to fail may be very important to  particular application, so our function is not trustworthy.
What happens if  caller passes too many parameters to  function.
All variables to this point have been local to functions or local to blocks within the bodies of conditional or iterative statements.
Local variables have some very desirable properties:.
A local variable occupies memory only when the variable is in scope.
When the program execution leaves the scope of a local variable, it frees up the memory for that variable.
This freed up memory is then available for use by the local variables in other functions during their invocations.
We can use the same variable name in different functions without any conflict.
The compiler derives all of its information about a local variable used within a function from the declaration of that variable in that function.
The compiler will not look for the declaration of a local variable in the definition of another function.
Thus, there is no way a local variable in one function can interfere with a local variable declared in another function.
A local variable is transitory, so its value is lost in between function invocations.
Sometimes it is desirable to have a variable that lives as long as the program is running; that is, until the main function completes.
In contrast to a local variable, a global variable is declared outside of all functions and is not local to any particular function.
In fact, any function that appears in the text of the source code after the point of the global variable's declaration may legally access and/or modify that global variable.
Listing fK)T|| (globalcalculator_0_cpp) is a modification of Listing [970] (calculator_0_cpp) that uses a global variable named result that is shared by several functions in the program.
Listing 10_0_1 (globalcalculator_0_cpp) uses global variables , argl, and arg2.
These names no longer appear in the mai n function.
These global variables are accessed and/or modified in four different functions: get_i nput, report, add, and subtract.
When in the course of translating the statements within a function to machine language, the compiler resolves a variable it encounters as follows:.
If the variable has a local declaration (that is, it is a local variable or parameter), the compiler will use the local variable or parameter, even if a global variable of the same name exists.
Local vari¬ ables, therefore, take precedence over global variables.
We say the local declaration hides the global declaration in the scope of the local variable.
If the variable has no local declaration but is declared as a global variable, the compiler will use the global variable.
If the variable has neither a local declaration nor a global declaration, then the variable is undefined, and its use is an error.
In the situation where a local variable hides a global variable of the same name, there is a way to access both the local variable and like-named global variable within the local variable's scope.
Suppose a program has a global variable named  and a function with a local variable named.
The statement = 10; within the scope of the local variable will assign the local.
The following statement will assign the global variable  in the scope of the local variable of the same name: :: = 10; The : : operator is called the scope resolution operator.
This special syntax may be used whenever a global variable is accessed within a function, but usually it only used when necessary to access a hidden global variable.
If the value of a local variable is used by a statement before that variable has been given a value, either through initialization or assignment, the compiler will issue a warning.
For example, the Visual Cplus_plus.
Its value should not be used until it has been properly assigned.
Global variables, however, do not need to be initialized before they are used.
Numeric global variables are automatically assigned the value zero.
This means the initialization of  in List¬ ing 10_0_1 (globalcalculator_0_cpp) is superfluous, since  will be assigned zero automatically.
Boolean global variables are automatically assigned zero as well, as zero represents false (see Section 5_0_1).
In general, local variables are preferred to global variables for several reasons:.
When a function uses local variables exclusively and performs no other input operations (like using the std : : ci n object), its behavior is influenced only by the parameters passed to it.
If a non-local variable appears, the function's behavior is affected by every other function that can modify that non-local variable.
As a simple example, consider the following trivial function that appears in a program:.
If your guess is 13, you are correct.
The i ncrement function simply returns the  of adding one to its argument.
The i ncrement function behaves the same way each time it is called with the same argument.
Next, consider the following three functions that appear in some program:.
It may be difficult to locate an error if that function fails because it may be the fault of another func¬ tion that assigned an incorrect value to the global variable.
The situation may be more complicated.
A function that uses only local variables can be tested for correctness in isolation from other func¬ tions, since other functions do not affect the behavior of this function.
This function's behavior is only influenced only by its parameters, if it has any.
The exclusion of global variables from a function leads to functional independence.
A function that depends on information outside of its scope to correctly perform its task is a dependent function.
When a function operates on a global variable it depends on that global variable being in the correct state for the function to complete its task correctly.
Nontrivial programs that contain many dependent functions are more difficult to debug and extend.
A truly independent function that uses no global variables and uses no programmer-defined functions to help it out can be tested for correctness in isolation.
Additionally, an independent function can be copied from one program, pasted into another program, and work without modification.
Functional independence is a desirable quality.
Unlike global variables, global constants are generally safe to use.
Code within functions that use global constants are dependent on those constants, but since constants cannot be changed, developers need not worry that other functions that have access to the global constants might disturb their values.
The use of global constants within functions has drawbacks in terms of program maintenance.
As a program evolves, code is added and removed.
If a global constant is removed or its meaning changes during the course of the program's development, the change will affect any function using the global constant.
Listing 1 10_0_2l| (digitaltimer_0_cpp) uses global constants to assist the display of a digital timer.
The main function controls the  initialization and update and deals strictly in.
The logic in mai n is kept relatively simple.
The code that extracts the , , and  from a given number of  is isolated in pri nt_ti me.
The pri nt_ti me function can now be used anytime a value in  needs to be expressed in the  :  :  format.
The second conversion constants (SEC_PER_HOUR, SEC_PER_MIN, and SEC_PER_DAY) are global constants so that both functions can access them if necessary.
In this case the functions use different constants , but it makes sense to place all the conversion factors in one place.
Since the two functions divide the responsibilities in a way that each can be developed independently, the design is cleaner and the program is easier to develop and debug.
The use of constants ensures that the shared values cannot be corrupted by either function.
The exclusion from a function's definition of global variables and global constants does not guarantee that it will always produce the same results given the same parameter values; consider.
Its behavior is totally predictable.
Furthermore, i ncrement does not modify any global variables, mean¬ ing it cannot in any way influence the overall program's behavior.
We say that increment is a pure function.
A pure function cannot perform any input or output (for example, use the std: : and std : : ci n objects), nor may it use global variables.
While i ncrement is pure, the compute function is impure.
The following function is impure also, since it performs output: int increment_and_report (i nt n) {.
A pure function simply computes its return value and has no other observable side effects.
Space in the computer's memory for local variables and function parameters is allocated at run  when the function begins executing.
When the function is finished and returns, the memory used for the function's local variables and parameters is freed up for other purposes.
If a function is never called, the variable's local variables and parameters will never occupy the computer's memory.
Because a function's locals are transitory, a function cannot ordinarily retain any information between calls.
Cplus_plus provides a way in which a variable local to a function can be retained in between calls.
List¬ ing 10_0_3 (counter_0_cpp) shows how declaring a local variable staff c allows it to remain in the computer's memory for the duration of the program's execution.
The local declaration static int  = 0; allocates space for  and assigns zero to it once—at the beginning of the program's execution.
The space set aside for  is not released until the program finishes executing.
Recall Listing |9_0_7| (evenbetterprompt_0_cpp) that included the following function:.
Another caller might use prompt within a loop like this:.
Notice that it is the caller's responsibility to keep track of the proper number to pass to p r ompt.
The caller may make a mistake and pass the wrong number or may not want to manage such details.
It would be better to move the responsibility of tracking input  to prompt, static variables make that possible, as Listing |T074| (promptwithstatic_0_cpp).
Local static variables were inherited from the C programming language, but their need has dimin¬ ished with the introduction of objects in Cplus_plus (see Chapter 14).
Functions with stati c variables provide a way to implement executable code with persistent state.
Objects provide a more natural and more flexible way to achieve the same effect.
In Cplus_plus, a program can have multiple functions with the same name.
When two or more functions within a program have the same name, the function is said to be overloaded.
The functions must be different somehow, or else the compiler would not know how to associate a call with a particular function definition.
The compiler identifies a function by more than its name; a function is uniquely identified by its signature.
A function signature consists of the function's name and its parameter list.
In the parameter list, only the types of the formal parameters are important, not their names.
If the parameter types do not match exactly, both in number and position, then the function signatures are different.
Consider the following overloaded functions: 1.
Overloaded functions are a convenience for programmers.
If overloaded functions were not allowed (many programming languages do not support  overloading), new  names must be created for different functions that perform basically the same task but accept different parameter types.
It is better for the programmer to choose the same name for the similar functions and let the compiler properly resolve the differences.
Overloading becomes a more important issue for constructors, special functions called during object creation (Chapter[T4|.
The following call.
As we can see, when the caller does not supply a parameter specified by a , and that parameter has a default , the default  is used during the caller's call.
We may mix non-default and default parameters in the parameter lists of a  declaration, but all default parameters within the parameter list must appear after all the non-default parameters.
Overloading (see Section 10_0_3| enables programmers to write different  definitions for two different functions that have the same name.
Mixing overloading and default arguments can produce ambi¬.
The factorial of  is often expressed as \.
Factorial is defined for nonnegative integers as \ =  ■ ( — 1).
Mathematicians precisely define factorial in this way: ( 1 if  = 0.
Note that the factori al function can be slightly optimized by changing the i f's condition from.
Figure 10_0_1 Traces the function activations of the recursive function factori al when called from mai with an argument of 6.
The arrows into an activation bar indicates the argument passed by the caller; the arrows out show the value passed back to the caller.
The length of a bar represents the time during which that invocation of the function is active.
The function must optionally not call itself within its definition; this is the base case.
Some sort of conditional execution (such as an i f /else statement) selects between the recursive case and the base case based on one or more parameters passed to the function.
Each invocation that does not correspond to the base case must call itself with parameter(s) that move the execution closer to the base case.
The function's recursive execution must converge to the base case.
Each recursive invocation must bring the function's execution closer to it base case.
The function calls itself in the else clause of the i f/else statement.
Its base case is executed if the condition of the i f statement is true.
Since the  is defined only for nonnegative integers, the initial invocation of facto ri al must be passed a value of zero or greater.
A zero parameter (the base case) results in no recursive call.
Any other positive parameter results in a recursive call with a parameter that is closer to zero than the one before.
The nature of the recursive process progresses towards the base case, upon which the recursion terminates.
We can easily write a non-recursive  function, as Listing (T0_0_7[(nonrecursfact_0_cpp) shows.
Which  function is better, the recursive or non-recursive version.
Generally, if the same basic algorithm is being used by both the recursive and non-recursive functions, then the non-recursive function will be more efficient.
A function call is a relatively expensive operation compared to a variable assignment or comparison.
The body of the non-recursive  function invokes no functions, but the recursive version calls a function—it calls itself—during all but the last recursive invocation.
The iterative version of  is therefore more efficient than the recursive version.
Even though the iterative version of the  function is technically more efficient than the recursive version, on most systems you could not tell the difference.
The execution time difference between the two versions is negligible.
The reason is the  function "grows" fast, meaning it returns fairly large.
In particular, f acto ri al ( 13 ) is the largest value that fits within a.
It works, but it is not very efficient.
Running Listing 10_0_8 (gcd_0_cpp) you will see that the gcd and  terati ve_gcd functions compute the same results given the same arguments.
Listing |10_0_8| (gcd_0_cpp) showcases the difference in performance between the two functions by computing the GCD of relatively large integers.
The gcd function produces its result much faster than  terati ve_gcd.
Note that this gcd function is recursive.
Because of the difference in the algorithms, this.
While Listing 10_0_8 (gcd_0_cpp) expresses the gcd functions recursively, it is not hard to rewrite it so that it still follows Euclid's algorithm but uses a loop instead of recursion—this very task appears as an exercise at the end of the chapter.
Often the concept of an algorithm solving certain kinds of problems is better understood when expressed recursively.
Later, once the details of the recursive version are perfected, developers may rewrite the algorithm in an iterative fashion.
Listing |10_0_9| (histobar_0_cpp) provides another example of a recursive function.
The segmentsl function.
This  beginning of the infinite Fibonacci sequence (see https://en_0_wi kipedia.
It  a sequence of integers beginning with 0 followed by 1.
Subsequent elements of the sequence are the sum of their two immediately preceding elements; thus, the third number  0+ 1 = 1, the fourth number  1 + 1=2, the fifth number  1+2 = 3, etc.
The numbers that comprise the Fibonacci sequence are known as Fibonacci numbers.
Note that 3  a Fibonacci number but 4  not.
The mathematical properties of Fibonacci numbers have bearing in such diverse fields as biology, eco¬ nomics, and art.
A common problem  computing the  lb Fibonacci number.
Zero  the 0 th , 1  the 1 st , 1  also the 2 nd , 2  the 3 rd , 3  the 4 th , 5  the 5 th , etc.
A recursive Cplus_plus function to compute the  th Fibonacci number follows easily from the definition of the Fibonacci sequence: // Returns the nth Fibonacci number int fibonacci ( nt ) { if ( <= 0) return 0; else if ( == 1) return 1;.
While this facto rial function computes the correct result, this tendency to call itself so many times.
Figure 10_0_2 The recursive computation offibonacci (5).
Each rectangle represents an invocation of the fibonacci fuunction.
The call at the top of the diagram represents the initial call offibonacci (5).
An arrow pointing down indicates the argument being passed into an invocation offibonacci, and an arrow pointing up represents the value returned by that invocation.
An invocation of fibonacci with no arrow pointing down away from the invocation represents a base case; observe that any invocation receiving a 0 or 1  a base case.
We see that the recursive process for fibonacci (5) invokes the function a total of 15 times.
It  possible to reuse a function with this copy-and-paste technique only if the function definition does not use any programmer-defined global variables, programmer-defined global constants, nor other programmer-defined functions.
If a function does use any of these programmer-defined external entities, we must copy and paste all of this extra code in order for the function to compile.
If the names of the external variables or functions that we must copy into the new  conflict with existing names within the , the  will not compile as , and we must rename the offending variables or functions to resolve the conflicts.
Changing code provides the opportunity to introduce bugs accidentally, so the process requires absolute care.
We can avoid the issues introduced by copying and pasting if the function we wish to reuse in other programs uses only local variables and parameters.
Such a function  truly an independent function that can be reused easily in multiple programs.
The notion of copying source code from one  to another  not ideal, however.
It  too easy for the copy to be incomplete or for some other error to be introduced during the copy.
Furthermore, such code duplication  wasteful.
If 100 programs on a particular system all need to use the i s _ p r i me function, under this scheme they must all include the is_prime code.
This redundancy wastes space.
Finally, in perhaps the most compelling demonstration of the weakness of this copy-and-paste approach, what if we discover a bug in the i s_pri me function that all 100 programs are built around.
When we discover the error and fix it in one , the other 99 programs still will contain the bug.
Their source code must be updated, and they each then must be recompiled.
The problem  even more complicated if the other 99 programs have 99 different authors.
We then must contact multiple developers to tell them to fix their i s_pri me function.
The situation would be similar if we updated a correct i s _ p r i me function to make it more efficient.
The problem  this: all the programs using is_prime define their own is_prime function; while the function definitions are meant to be identical, there  no mechanism tying all these common definitions together.
We really would like to reuse the function as  without copying it.
Fortunately, Cplus_plus provides a way to develop functions in separate files and combine the code from these independently developed functions into one.
We can compile the source files separately, and the linker can combine the compiled code into an executable.
What we need  a way for the compiler to verify that the calling code in one source file  correctly invoking the function defined in another source file.
The simple one-line code in Listing [10_0_10 (prime.
In Visual Studio, you simply add a new  to your project specified as a header file, name it prime.
This file contains the prototype for our i s_pri me function (see our earlier discussion of function prototypes in Section ||| 871).
Caller code that intends to use our i s _ p r i me function must #i nclude this file so that compiler can check to see if the caller  using our i s_p r i me function properly.
An attempt, for example, to pass two arguments to i s_pri me would result in a compiler error since the prototype specifies a single integer argument.
While not required, this serves as a good check to see if the implementation code in this file is faithful to the prototype specified in prime_0_h.
This prime_0_cpp file is compiled separately, and the compiler will report an error if the implementation of is_prime disagrees with the information in the header file.
Note that the file prime_0_cpp does not contain a mai n function; mai n will appear in another file.
Also observe that we do not need to #i nclude the i ostream header, since the std : : cout and std : : ci n objects are not used anywhere in this file.
The cmath header is #i ncluded since is_pri me uses the sqrt function.
Visual Studio will automatically compile and link the.
If you are using the Visual Studio Command Line tool, in order to build the  you would type.
The executable file's name is determined by the name of the first source file listed, in this case primetester.
If you are using the GCC tools instead of Visual Studio, in order to make the executable  named primetester (or primetester_0_exe under the Microsoft Windows version of the GCC tools), you would issue the command.
The GNU Cplus_plus compiler will separately compile the two source files producing two machine language object.
The i s_pri me function is now more readily available to other programs.
If it becomes an often used function in many programs, it can be compiled and placed into a special file called a library.
In this form it need not be recompiled each time a new  is built that requires it.
If our i s_pri me is placed in a dynamic library, its code can be loaded and linked at nin time and shared by many executing programs.
We do not cover library creation in this text.
In Listing|877j(timeit_0_cpp), Listingj|8_0_8|(measureprimespeed_0_cpp), and Listing |ro_0_2|| (digitaltimer_0_cpp) we used the clock function from the <ctime> library to measure the elapsed time of sections of various executing programs.
In each of these programs the programmer must be aware of the clock_t type and CL0CKS_PER_SEC constant, both defined in the <ctime> header file.
Furthermore, the programmer must use the clock function properly and correctly perform some arithmetic and include a messy type cast operation.
Armed with our knowledge of global variables (Section ||10_0_1| and separate compilation of multiple source files, we can provide a better programming interface to the lower-level timing functions provided to the C library.
Observe that the code in Listing [10_0_14|| (timermodule_0_cpp) allows client code to stop the  and restart it later without losing any previously accumulated time.
The implementation uses three global variables— , sta rt_ti me, and runni ng —to maintain the state of the.
One or more of these global variables is influenced by three functions— start_timer, stop_timer, reset_time.
The fourth function returns the value of the  variable.
All traces of the clock_t type and the messy arithmetic and casting are gone.
The  module provides a simple interface to callers that hides the details on how the timing actually happens.
Despite the ease of use of our  module, it has a servere limitation.
Suppose you wish to measure how long it takes for a function to execute and also, during that function's execution, separately time a smaller section of code within that function.
When the function is finished executing, you would like to know how long it took the function to do its job and how long a portion of its code took to execute.
We essentially need two independent timers, but with our  module it is not possible to conduct simul¬ taneously more than one timing.
We will see a far superior way to model a  execution  in Section||16_0_2[ We will use objects to enable us to maintain as many simultaneous stopwatches as we need.
The compiler generates machine code that takes care of those details for us.
Some systems software like operating systems and device drivers need to access specific memory locations in order to interoperate with hardware.
Systems programmers, therefore, must be able to write code that can access such lower-level detail.
Developers of higher-level applications sometimes need to access the address of variables to achieve specialized effects.
Each byte in a computer's memory is numbered with a unique address.
The first address is 0, and the locations are numbered sequentially up to some maximum value allowed by the operating system and hardware.
A Cplus_plus variable is stored in memory, so each variable lives at a particular address.
The & operator is called the address of operator.
Regardless of the type of x, the expression.
While an address is really just a nonnegative integer value, Cplus_plus uses a special notation when dealing with addresses.
In the following declaration.
The * symbol used as shown above during a variable declaration indicates that the variable is a pointer.
It will be used to refer to another variable or some other place in memory.
In this case, the sequence of assignments allows pointer p to refer to variable.
In order to access memory via a pointer, we use the unary * operator.
When not used in the context of a declaration, the unary * operator is called the pointer dereferencing operator.
Continuing the code sequence above, int ; = 4; int *p; = &; * = 7; the statement * = 7; copies the value 7 into the address referenced by the pointer p.
Figure |10_0_4|| illustrates the full sequence.
Notice that the assignment to *p modifies variable 's value.
The pointer p provides another way to.
It is important to note that the statement * = 5; is the first assignment statement we have seen that uses more than just a single variable name on the left of the assignment operator.
The statement is legal because the expression *p represents a memory location that can store a value.
Here, *p stands in the place of the variable , and we easily can assign a value to.
The unary * operator has two distinct meanings depending on the context:.
The * operator is the inverse of the & operator.
We may declare a pointer and not assign it, as in int *; We say  is an uninitialized pointer , sometimes called a wild pointer.
If  is a local variable, its contents are undetermined bits.
Because of 's declared type, we interpret these bits as an address, so the net effect is that the uninitialized pointer  points to a random location in the computer's memory.
An attempt to dereference , as in * = 500; is certainly asking for trouble.
This statement attempts to write the value 500 at some unknown-to-theprogrammer memory location.
Often the address is not part of the area of memory the operating system has set aside for the executing program, so the operating system steps in and issues a run-time error.
This is the best possible result for misusing a wild pointer.
It is possible, however, that the spurious address is within the executing program's domain.
In this case the value 500 may overwrite another variable or the compiled machine language instructions of the program itself.
Such errors are difficult to track down because the overwritten value of the variable cannot be detected until the program attempts to use the variable.
The statement that misuses the uninitialized pointer may be far away in the source code (even in a different source file) from the code that attempts to use the clobbered variable.
When the program fails, the programmer naturally looks around in the code where the failure occurred—the code in the vicinity where.
Cplus_plus is very strict about disallowing the mixing of pointers and non-pointers across assignment.
Systems programmers sometimes need to assign a pointer to a particular address in memory, and Cplus_plus permits the assignment with a special kind of type cast, the.
The familiar static_cast (see Section 4_0_2) will not work.
Why is Cplus_plus so strict when it comes to assignments of pointers to non-pointers and vice versa.
It is easy to make a mistake such as omitting the * operator when it is needed, so the special cast forces the programmer to pause and consider whether the mixed assignment truly is necessary or whether attempting to do so would be a mistake.
Modern Cplus_plus compiler supports the reserved word nullptr to represent a pointer to "nothing_0_" It.
On most platforms, nullptr maps to address zero, which is out of bounds for any running program.
Dereferencing  thus would result in a run-time error.
Adept programmers can find the source of such a null pointer access problem quickly with a debugger.
Cplus_plus does not allow direct integer assignment to a pointer, as in int * = 5;.
This is how Cplus_plus programmers assigned a pointer to point to nothing before the nullptr keyword was available.
Since newer compilers support existing Cplus_plus source code, the literal zero assignment still works.
You should use the nullptr keyword because it improves the source code readability.
Since 0 can represent both an integer value and a pointer to any type, both of the following statements are legal if  has been declared to be a pointer to an integer:.
Said another way, the first statement changes where  points; the second statement changes the memory to which   points.
Superficially, the two statements look very similar and are easy to confuse.
Next, consider the statements.
The nullptr reserved word is part of the Cplus_plus11 standard.
The name nullptr is simply an identifier (for example, a variable or function name) for older compil¬ ers.
Before the nullptr constant became available the literal 0 (zero) was con¬ sidered the null pointer reference.
For backwards compatibility with older , Cplus_plus11 allows you to use 0 in place of nullptr, but if possible you should avoid this practice when writing new.
The nullptr literal allows the compiler to perform better type checking.
To see why, suppose the programmer believes the variable  is a pointer to an integer, but  is instead a simple integer:.
In this case the compiler is powerless to detect a problem because  is an integer, and zero is a valid integer value.
If  really is an integer rather a pointer, the compiler will flag the following : // Programmer believes  is a pointer to an integer = nullptr;.
Cplus_plus supports another kind of variable that is many ways similar to a pointer.
When the & symbol is used as part of the type name during a variable declaration, as in i nt x; int&  = x; we say  is a reference variable.
This declaration creates a variable  that refers to the same memory location as the variable x.
We say that  aliases x.
Unlike a pointer variable, we may treat  as if it were an i nt variable—no dereferencing with * is necessary.
Listing 10_0_16 (referencevar_0_cpp) demonstrates how reference variables can alias other variables.
Reassigning  changes  in exactly the same way, and reassigning  changes  in exactly the same way.
The variable , on the other hand, is independent from both  and.
Reassigning either  or  does not affect , and reassigning affects neither  nor.
The space around the & symbol used to declare a reference variable is not significant; specifically, the statement.
Reference syntax is simpler than pointer syntax because it is not necessary to dereference a reference variable in order to assign the memory location to which it refers.
If  is an i nt, ptr is a pointer to an i nt, and ref is a reference to an i nt, consider the following statements:.
A reference variable must be initialized with an actual variable when it is declared.
A pointer variable may be declared without an initial value and assigned later.
Consider the following statements: int *p; // Legal, we will assign p later int& ; // Illegal, we must initialize  when declaring it Attempting to compile this code under Visual Cplus_plus prompts the compiler to issue the error error C2530: V : references must be initialized.
There is no way to bind a reference variable to a different variable during its lifetime.
Consider the following code fragemnt:.
The declaration of  binds  to the  variable for the life of.
This statement simply assigns y's value to  via the reference.
In contrast, we may freely bind pointer variables to any variables we choose at any time.
A reference variable, therefore, in the examples provided here works like a pointer that must be bound to a variable and may not be redirected to point anywhere else.
Also, unlike with pointers, it is illegal to attempt to assign nullptr to a reference variable.
There are some other differences between references and pointers that we will not explore here.
Reference variables provide a simpler syntax than pointer variables since we do not use the pointer dereferencing operator (*) when working with references.
There is one other major difference between pointers and references—Cplus_plus adopted pointers as is from the C programming language, but C does not provide references.
Cplus_plus programmers often use library func¬ tions written in C, so it is important to not mix references with C code.
Section [10,91 reveals a ver Y important practical application of pointers and references in their role of enabling pass by reference to functions.
The default technique for passing parameters to functions is pass by value (see Section |9_0_3|.
Unfortunately, the swap function simply interchanges copies of the actual parameters, not the actual pa¬ rameters themselves.
We really would like to write  function that interchanges the caller's variables.
Pass by reference is necessary to achieve the desired effect.
Cplus_plus can do pass by reference in two ways: pointer parameters and reference parameters.
We can use this ca¬ pability to allow  function to modify the values of variables that are owned by its caller.
Listing |10_0_18| (swapwithpointers_0_cpp) provides  correct version of our variable interchange program.
The formal parameters to swap,  and , are pointers to integers; they are not integers themselves.
In order to access the integer to which the pointer named  refers, it must be dereferenced.
That is why any use of  in swap's body is prefixed with the pointer dereferencing operator, *.
The statement int  = *; assigns to the local variable  the value of the variable to which  points.
Since mai n passes the address of  as the first parameter in its call to swap, in this case  points to , so * is effectively another way to access the memory location of  in mai n.
The function thus assigns the value of mai n's  variable to.
In swap's statement * = *;.
In reality, pass by reference with pointers is still using pass by value.
Instead of passing copies of values, we are passing copies of addresses.
The difference is we are not attempting to reassign  or ; we are reassigning memory to which  and  point.
Whether we use the original address or  copy of the address, it is still the same address—the same numeric location in memory.
Both C and Cplus_plus support pass by reference with pointers (see Section jl0_0_9_0_1|.
Since Cplus_plus programs often use C libraries, Cplus_plus programmers must be familiar with the pointer technique for pass by reference.
Cplus_plus, however, provides  simpler way of implementing pass by reference using reference parameters.
The formal parameters to swap,  and , are references to integers; this is signified by the & symbol following i nt in their declarations.
Because  is  reference we use it exactly like an integer; there is no need to dereference it with the * operator to change the value of the integer it aliases.
Because is  reference, however, it is an alias to another variable or memory location elsewhere.
This means if we modify , we also modify the variable it references, in this case  in mai n.
The statement int  = ; assigns to the local variable  the value of , but since  is another way to get to , this statement ultimately assigns 's value to.
Reference parameters were introduced into Cplus_plus so that some of the more advanced object-oriented features could be implemented more cleanly.
Some argue that for simpler situations like the swa p function, pointer pass by reference is more desirable than reference parameter pass by reference because with pointer pass by reference, the caller is forced to pass addresses of the actual parameters that may be modified.
In this way there can be no doubt that pass by reference is going on.
With reference parameters, pass by value and pass by reference cannot be distinguished at the call site, since  call with reference parameters looks exactly like  pass by value invocation.
In general, pure pass by value functions are preferred to pass by reference functions.
Functions using pass by reference cause side effects.
This means they can change the state of the program in ways that can be determined only by looking inside of the function and seeing how it works.
Functions that access global variables (see Section |l0_0_1| can also cause side effects.
Program development is much easier when functions can be treated as black boxes that perform computations in isolation without the possibility of affecting anything outside of their local context.
The result of  function's work can be assigned to variable thus changing the state of the program, but that change is the responsibility of the caller, not the responsibility of the function itself.
With pass by value, the function's parameters and local variables come into existence when the function executes, the parameters and local variables disappear when the function is finished, and nothing else is affected by the function's execution.
Side-effect-free functions can be developed and tested in isolation from the rest of the program.
Once programmers are satisfied with their correctness, they need not be touched again as the remainder of the system is developed.
Functions with side effects, however, have dependencies to other parts of the program, and changes elsewhere in the system may require programmers to modify and re-evaluate existing functions.
Since functions can contain conditional statements and loops, they can do different things based on the data they receive.
The code within each function, however, is fixed at compile time.
Consider the following function:.
The function returns  different result this time because we passed different parameters to it.
The evaluate function in  sense behaves differently depending on the arguments passed by its caller; however, it always adds its two parameters.
There is no way we can call evaluate and expect it to multiply its two parameters instead.
The evaluate function is hard-coded to perform addition.
What if we wanted the evaluate function to be able to perform different arithmetic operations at different times during  program's execution.
Unfortunately, evaluate as it currently is written cannot adapt to perform  different arithmetic operation.
The good news is that we can rewrite evaluate so that it can flexibly adapt to  caller's changing arithmetic needs.
Cplus_plus allows programmers to pass functions as parameters to other functions.
A function even may return  function as  result.
A function that accepts one or more functions as parameters or returns function as  result is known as  higher-order function.
As we will see, higher-order functions open up new  possibilities enabling us to customize the behavior of  function by plugging into it different functions to achieve different effects.
Cplus_plus achieves higher-order functions via function pointers.
During  program's execution, the compiled machine language code for  function must reside in the computer's memory for the program to be able to invoke the function.
That means every function has  memory address just as each variable has its own specific memory address.
A pointer to  function holds the starting address for the compiled code of particular function.
The parameter's name is f , and f is a pointer to a function that accepts two integer parameters and returns an integer result.
In Listing || 10_0_20|| (arithmeticeval_0_cpp), the first parameter a caller must pass to evaluate is the address of a function with a prototype that matches the formal parameter specified in evaluate's definition.
Both the  and multi ply functions qualify because they accept two integer parameters and return an integer result.
The expression evaluate(&, 2, 3).
Cplus_plus has a somewhat relaxed syntax for function pointers that cannot be applied to pointers to data.
Function pointers are not restricted to function parameters.
Given the definition of  above, the following code fragment is legal Cplus_plus: // Declare  to be a pointer to a function that accepts.
This code fragment as part of a complete Cplus_plus program would print 9.
Higher-order functions via function pointers provide a powerful tool for developing flexible programs.
With functions as parameters we can dynamically customize the behavior of a function, essentially "plug¬ ging in" new  by passing in different functions.
We will put higher-order functions to good use in Chapter|T2|.
If  is a variable, how would you determine its address in the computer's memory.
Given the declarations:.
Complete the following function that assigns to its i  and i  reference parameters the components of the point of intersection of two lines.
The first line passes through the points (jci ,yi) and ( 2 ,yi)\ the second line passes through the points (^ ,>' 3 ) and ( 4 , 4 ).
If the two lines do not intersect in a single point (that is, they are parallel to each other), the function should assign INFINITY to both ix and iy.
INFINITY is a double-precision floating-point constant defined in the cmath header file.
It represents a very large number that you effectively can treat as infinity.
The variables we have used to this point can assume only one value at a time.
As we have seen, we can use individual variables to create some interesting and useful programs; however, variables that can represent only one value at a time do have their limitations.
Consider Listing 11_0_1 (averagenumbers_0_cpp) which averages five numbers entered by the user.
The program conveniently displays the values the user entered and then computes and displays their aver¬ age.
Suppose the number of values to average must increase from five to 25.
If we use Listing 11_0_1 (aver¬ agenumbers_0_cpp) as a guide, we must introduce twenty additional variables, and the overall length of the program will necessarily grow.
Averaging 1,000 numbers using this approach is impractical.
Listing j 1 L2|(averagenumbers2_0_cpp) can be modified to average 25 values much more easily than List¬ ing jlTT](averagenumbers_0_cpp) that must use 25 separate variables—-just change the constant.
In fact, the coding change to average 1,000 numbers is no more difficult.
However, unlike the original aver¬ age program, this new  does not display the numbers entered.
This is a significant difference; it may be necessary to retain all the values entered for various reasons:.
All the values can be redisplayed after entry so the user can visually verify their correct entry.
The programmer may want to display the values in some more persistent way; for example, the user may instead type the values in a graphical user interface component, like a visual grid (spreadsheet).
A more sophisticated program may need to process the values in a different way; for example, we may wish to display just the values entered above a certain value (like greater than zero), but the limit is not determined until after the user finishes entering all the numbers.
In all of these situations we must retain the values of all the variables for future recall.
In this chapter we will examine the common sequence types available in Cplus_plus: vectors and arrays.
Vectors and arrays are sequence types because a sequence implies its elements are ordered.
A nonempty sequence has the following properties:.
Every nonempty sequence has a unique first element.
We call this a linear ordering.
In a linear ordering you can begin at the first element and repeatedly visit successor elements until you reach the last element.
There never is any ambiguity about which element comes next in a sequence.
The data structures we examine in this chapter, std : : vecto rs, primitive arrays, and std : : a r rays, are all sequence types.
A vector has a name, and we may access the values it contains via their position within the block of memory managed by the vector.
A vector stores a sequence of values, and the values must all be of the same type.
A collection of values all of the same type is said to be homogeneous.
When declared this way, the vector.
We can declare a  with a particular initial size as follows: std::vectorci nt> vec_b(10);.
Here vec_b initially holds 10 integers.
All 10 elements are zero by default.
Note that the 's size.
Note that the elements appear within curly braces, not parentheses.
The list of elements within the curly braces constitutes a  initializer list.
This kind of declaration is practical only for relatively small vectors.
Figure 11_0_1 provides a conceptual illustration of the vectors vec_a, vec_b, vec_c, and vec_d.
Visual Studio 2013 do not support this initializer list syntax.
This code fragment shows how the square brackets allow us to access an individual element based on that element's position within the.
The number within the square brackets indicates the distance from the beginning of the.
The expression li st [0] therefore indicates the element at the very beginning (a distance of zero from the beginning), and [] is the second element (a distance of one away from the beginning).
After executing these assignment statements, the li st  conceptually looks like Figure [lL2| Cplus_plus classifies the square brackets, [], as a binary operator, since it requires two operands: a 's name and an index.
Vectors may hold any valid Cplus_plus data type.
The following code fragment declares three vectors of differing types:.
Here li st is empty but can contain integer values, collecti on is a  of double-precision floating¬ point numbers initially containing the values contained in the initializer , and letters holds the low¬ ercase versions of the first three letters of the English alphabet.
Figure |ll,3|| illustrates these three objects.
We can observe two key points from Figures[TlTljjTT3(.
Vectors store their elements in a contiguous block of memory.
This means, for example, the memory occupied by the element at index 2 follows immediately after the memory occupied by the element at index 1 and immediately before the element at index 3.
Elements in a  are located by a numeric index.
The first element is at index zero , not one.
Figure 11_0_3 Vectors containing different types of elements.
Note that while two different  objects.
The subscript termi¬ nology comes from mathematicians who use subscripts to reference elements in a mathematical sequence (for example, V 2 represents the second element in the mathematical sequence V).
Unlike the convention often used in mathematics, however, the first element in a  is at position zero , not one.
The expression li st [2] can be read aloud as "li st sub two_0_" As a consequence of a zero beginning index, if  a holds n elements, the last element in a is a \n — 1], not a [n].
An element of a  accessed via its index behaves just like a variable of that type; for example,.
The following examples illustrate the variety of expressions that qualify as legal  indices:.
The compiler will issue a warning about using a floating-point index with good reason.
A  may have an element at index 2 or index 3, but it is not possible to have an element located between indices 2 and 3; therefore, the executing program will truncate a floating-point index to an integer in order to select the proper element within the.
If a is an integer  containing 10 elements, the following loop prints each element in a:.
Variable  's value starts at 0 and ends at 9, the last valid position in  a.
The following loop prints contents of  a in reverse order:.
Listing |11_0_3| (vectoraverage_0_cpp) uses a  and a loop to achieve the generality of.
Unlike the original program, however, we now conveniently can extend this program to handle as many values as we wish.
We need only change the definition of the NUMBER_OF_ENTRIES constant to allow the program to handle any number of values.
This centralization of the definition of the 's size eliminates duplicating a hard-coded value and leads to a program that is more maintainable.
Suppose every occurrence of NUMBER_OF_ENTRIES were replaced with the literal value 5.
The program would work exactly the same way, but changing the size would require touching many places within the program.
When duplicate information is scattered throughout a program, it is a common error to update some but not all of the information when a change is to be made.
If all of the duplicate information is not updated to agree, the inconsistencies result in errors within the program.
By faithfully using the NUMBER_OF_ENTRIES constant throughout the program instead of the literal numeric value, we eliminate the possibility of such inconsistency.
The first loop in Listing) TT3| (vectoraverage_0_cpp) collects all five input values from the user.
The second loop only prints the first four because it also prints a trailing comma after each element.
Since no comma should be displayed after the last element, the program prints the last element after the loop is finished.
The compiler will insist that the programmer use a numeric value for an index, but the programmer must ensure that the index used is within the bounds of the.
Since the index may consist of an arbitrary integer expression whose value cannot be determined until run time, the compiler cannot check for out-of-bound  accesses; for example, in the code.
Attempting to access elements outside the bounds of a vector produces what is known as undefined behavior.
The Cplus_plus language standard uses this term to indicate a program's behavior is not specified, and compiler writers are free to do whatever they want.
Often, running programs that venture into undefined behavior will crash, but sometimes they may continue executing with no indication of a problem and appear to behave correctly most of the time.
In other words, the actual program behavior is system dependent and compiler dependent.
Consider code that represents undefined behavior to  a logic error, since its action is inconsistent across platforms and compilers.
Simply said, the program's behavior is unpredictable.
Unpredictable behavior is incorrect behavior.
In most cases, an out-of-bounds access simply accesses memory outside the vector.
If this includes memory that does not belong to the executing program, modern operating systems will terminate the pro¬ gram and produce an error message.
Under Visual Cplus_plus when the program is built as a debug version (the default when using the IDE), the program prints the contents of the vector the first time but crashes before it can print it out a second time.
Microsoft Windows then displays the dialog box shown in Figure fLL4[ The program running under Linux or macOS may simply print in the console:.
If your program is using a vector, and it terminates with such a message, you should check its source code.
The following code fragment shows some proper and improper vector accesses: std::vector< nt> [0] = 5; [9] = 2; [-] = 5; [10] = 5; [1_0_3] = 5;.
Cplus_plus11 supports a variation of the for statement that uses special syntax for objects like vectors that support traversal.
Commonly known as the range-based for or "foreach" statement, this version of the f o r statement permits vector traversal without an index variable keeping track of the position.
The following code fragment uses a range-based for statement to print the contents of an integer vector named vec: for (int n : vec).
You can read this statement as "for each  nt n in vec, std : : cout << n << ' 1 ," The colon (:) therefore is pronounced "in_0_" In the first interation of this range-based for loop the variable n represents the first element in the vector vec.
In the second iteration n represents the second element.
The third time through n is the third element, and so forth.
The declared variable assumes the role of a different vector element during each iteration of the loop.
Note that the range-based for loop requires no control variable to keep track of the current index within the vector; the loop itself takes care of that detail, freeing the programmer from that task.
The general form of this range-based f o r statement is.
If the element variable within the range-based for loop is declared to  a reference, the code within.
It is not always possible to use the range-based for statement when traversing vectors.
The rangebased for statement iterates forward through the vector elements and cannot move backwards.
Also, the range-based for statement is not convenient  you want to consider only a portion of the elements in the vector.
Examples include visiting every other element in the vector or considering only the first third of the elements.
In these specialized cases you can use a standard for loop with an integer control variable.
Section|20_0_5|explores some other options for traversing vectors in creative ways.
Most objects have access to special functions called methods.
Cplus_plus programmers often refer to methods as member functions.
A method is a function associated with a class of objects.
A method invocation involves a slightly different syntax than a function invocation; for example,  obj is an object that supports a method named f that accepts no parameters, we can invoke f on behalf of obj with the statement:.
The dot operator connects an object with a method to invoke.
Other than this special invocation syntax, methods work very much like the global functions introduced in Chapter[8] A method may accept parame¬ ters and may return a value.
Vectors support a number of methods, but we will focus on seven of them:.
We have seen how to declare a vector of a particular size and use the space provided; however, we are.
Each push_back method call increases the number of  in a  by one.
The pop_back method performs the opposite action of push_back.
A call to pop_back removes the last  from a , effectively reducing the number of  in the  by one.
Declare list to be a Add 5 to the end of list Add -3 to the end of the list Add 12 to the end of list Removes 12 from the list Removes -3 from the list.
Programmers use the shorter syntax exclusively, but the longer expression better illustrates the fact that the square bracket ( []) operator really is a method in the std : :  class of objects.
As we have seen, a programmer must be vigilant to avoid using an out-of-bounds index with the operator [] method.
The  class provides an additional method, at, that provides index bounds checking.
The expression vec[] in and of itself provides no bounds checking and so may represent undefined behavior.
The functionally equivalent expression vec.
If  is outside the acceptable range of indices, the method is guaranteed to produce a run-time error.
Listing |l 1_0_61 (vectoroutofbounds2_0_cpp) is a variation of Listing ) 11_0_4| (vectoroutofbounds_0_cpp) that uses the at method instead of the operator [] method.
Run-time errors are bad, but undefined behavior is worse because it can manifest itself as unpredictable run-time errors and programs that behave differently across multiple platforms.
The size method returns the number of  in a.
The following code fragment prints the contents of  list: int  = list_0_sizeQ ; for (int  = 0;  < ; iplus_plus) std::cout << list[] << " std::cout << '\' ; The exact type that the si ze method returns here is a std : : vectorci nt> : : si ze_type.
This type is defined within the std : : < nt> class.
It is compatible with the unsigned type and may be assigned to an  nt variable as shown above.
We can avoid the additional local variable  as follows: for (unsigned  = 0;  < list_0_sizeQ; iplus_plus) std::cout << list[] << " std::cout << '\' ; Notice that 's declared type is unsigned, not int.
This prevents a warning when comparing  to list_0_sizeQ.
A comparison between signed and unsigned integer types potentially is dangerous, and.
To see why you should not take this warning lightly, consider the.
This is because even though 0 is not less than — 1, —1 is a signed value, not an unsigned value.
The unsigned data type cannot represent signed numbers.
An attempt to compute unsi gned 0 minus 1 on a 32-bit system produces 4,294,967,295, which definitely is not less than zero.
To be safe, assign the value of the si ze method to an  nt variable or use unsigned variables to control loop iterations.
Better yet, use the range-based for statement whenever possible.
The empty method is a convenience method; if vec is a , the expression vec.
Note that the empty method does not make the  empty; it simply returns true if the  is empty and false if it is not.
The clear method removes all the  from a  leaving it empty.
Invoking clear on an initially empty  has no effect.
Immediately after clearing a , the 's size method will return zero, its empty method will return true, and a call to its operator [] method with an index of any value (including zero) will exhibit undefined behavior.
In this case, the print function uses pass by value, so during the program's execution an invocation of pri nt will copy the data in the actual parameter (li st) to the formal parameter (v).
Since a  potentially can be quite large, it generally is inefficient to pass a  by value as shown above.
Pass by value requires a function invocation to create a new  object for the formal parameter and copy all the  of the actual parameter into the new  which is local to the function.
A better approach uses pass by reference, with a twist: void print(const std::vectorci nt>& v) { for (int elem : v).
The & symbol indicates that a caller invoking pri nt will pass v by reference (see Section 10_0_9).
This copies the address of the actual parameter (owned by the caller) to the formal parameter v instead of making a copy of all the data in the caller's.
Passing the address is much more efficient because on most systems an address is the same size as a single  nt, whereas a  could, for example, contain 1,000,000  nts.
With pass by value a function invocation would have to copy all those 1,000,000 integers from the caller's actual parameter into the function's formal parameter.
Section || rOT9| indicated that call-by-value parameter passing is preferred to call-by-reference parameter passing.
This is because a function using pass by value cannot modify the actual variable the caller passed to it.
Observe closely that our new  nt function declares its formal parameter vtobeaconst reference.
This means the function cannot modify the actual parameter passed by the caller.
Passing a  object as a constant reference allows us to achieve the efficiency of pass by reference with the safety of pass by value.
Passing by const reference is not the same as pass by value, though.
The function receiving a parame¬ ter passed by value can modify the parameter and return a modified copy.
A function using pass by const reference cannot modify the parameter passed to it.
Like the p r  nt function, the sum function in Listing 11_0_7 (vectortofunc_0_cpp) does not intend to modify the contents of its  parameter.
Since the sum function needs only look at the 's contents, its parameter should be declared as a const reference.
In general, if a function's purpose is to modify a , the reference should not be const.
Listing jTL8| (makerandomvector_0_cpp) uses a function named make_random that fills a  with pseudorandom integer values.
The make_random function in Listing 11_0_8 (makerandomvector_0_cpp) calls the  method clear which makes a  empty.
We call clear first because we want to ensure the  is empty before we add more elements.
The function then proceeds to add a random number of random integers to the empty.
A function may return a  object.
Listing |Tl_0_9|| (primelist_0_cpp) is a practical example of a function.
The function examines every value in the range begi _0__0_.
The  mes function uses  s_pri me as a helper function.
If the s_pri me function classifies a value as a prime, code within the  mes function adds the value to the After  mes has considered all the values in the provided range,  will contain all the prime numbers in that range.
In the end, primes returns the  containing all the prime numbers in the specified range.
When returning a local variable that is a built-in scalar type like int, double, char, etc_0_, a Cplus_plus function normally makes a copy of the local variable to return to the caller.
Making a copy is necessary because local variables exist only while the function in which they are declared is actively executing.
When the function is finished executing and returns back its caller, the run-time environment reclaims the memory held by the function's local variables and parameters so their space can be used by other functions.
The return value in  mes is not a simple scalar type—it is an object that can be quite large, especially if the caller passes in a large range.
Modern Cplus_plus compilers generate machine code that eliminates the need to copy the local.
The technique is known as return value optimization, and it comes into play when a function returns an object declared within the function.
With return value optimization, the compiler "knows" that the variable will disappear and that the variable is to be returned to the caller; therefore, it generates machine language code that makes the space for the  in the caller's memory space, not the called function.
Since the caller is maintaining the space for the object, it persists after the function returns.
Because of return value optimization you can return vectors by value in situations like this one without fear of a time-consuming copy operation.
Due to the fact that vectors may contain a large number of elements, you usually.
If the function is not meant to modify the contents of the , declare the as a const reference.
It generally is safe to return a  by value from a function if that  is.
Cplus_plus supports higher-dimensional vectors.
A two-dimensional  is best visualized as a table with rows and columns.
It literally creates   with two elements, and each element is itself   containing three integers.
Note that the type of  is   of of integers.
A 2D  is sometimes called  matrix.
In this case, the declaration specifies that 2D contains two rows and three columns.
Figure [TT3| shows the logical structure of the  created by the following sequence of code: std::<std::'d' nt>> (2, std::'d nt> (3) ) ; [0][0] = 5;.
Rows are arranged horizontally, and the values in columns are arranged vertically.
In each of the assignment statements above, for example [1][0] = 22; the first index (here 1) signifies the row and the second index (here 0) denotes the column of the element within the.
Literally, the expression  [1] [0] means ([l])[0]; that is, the element at index 0 of the  at index 1 within.
Using  syntax similar to the initialization lists of one-dimensional vectors, we can declare and initialize.
Note that each row appears within its own set of curly braces, and each row looks like ID  initializa¬.
Such type alias.
In this case this typedef directive works identically to the usi ng  alias.
Cplus_plus inherits the typedef keyword from the C programming language.
The Cplus_plus using  alias is newer and supports  aliasing capabilities beyond those provided by the more primitive typedef.
For this reason, you should prefer the usi ng  aliasing to typedef when writing pure Cplus_plus code.
Here we replaced the explicit  const std : :  <double>& with the word auto.
The com¬ piler is able to infer the  of the variable  from the context: m is  Mat r i x (that is, std: :<std: :<double>>), so  must be an element of the 2D  (which itself is  ID ).
We can build vectors with dimensions higher than two.
Each "slice" of  3D  is simply  2D ,  4D  is   of 3D vectors, etc.
For example,  statement.
In practice, vectors with more than two dimen¬.
Cplus_plus began as an extension of  C programming language, but C does not directly support object-oriented programming.
Consequently, C does not have vectors available to represent sequence types.
The C language uses a more primitive construct called an array.
True to its C roots, Cplus_plus supports arrays as well as vectors.
Some Cplus_plus libraries use arrays in instead of vectors.
In addition, Cplus_plus programs can use any of  large number of C libraries that have been built up over  past 40+ years, and many of these libraries process arrays.
While a more modern construct like std : :  may be better suited for may of  roles an array has played in  past, it nonetheless is important for Cplus_plus programmers to be familiar with arrays.
An array is a variable that refers to a block of memory that, like a , can hold multiple values simultaneously.
An array has a , and  values it contains are accessed via their position within block of memory designated for  array.
Also like a ,  elements within an array must all be of same.
Arrays may be local or global variables.
Arrays are built into  core language of both C and Cplus_plus.
This means you do not need to add any # include directives to use an array within a program.
Arrays come in two varieties, static and dynamic.
A programmer must supply   of a static array when declaring it; for example,  following statement: // list is an array of 25 integers int list[25]; declares li st to be an array of 25 integers.
The value within  square brackets specifies  number of elements in  array, and   is fixed for  life of  array.
The value within  square brackets must be a constant value determined at compile time.
It can be a literal value or a symbolic constant, but it cannot be a variable.
This is in contrast to  declarations in which  initial   may be specified by a variable with a value determined at run time: int x;.
If you provide a number within  square brackets, it should be at least as large as number of elements in  initialization list.
The equals symbol is required for array initialization.
You optionally can use  equals symbol as shown here when initializing vectors, but it is not required for vectors.
If  declaration omits an initializer list, as in: int arr[100];.
This code fragment shows that  square brackets used after  point of declaration allow us to access an individual element based on that element's position within  block of memory assigned to  array.
This syntax is identical to that used with  objects.
As with vectors,  very first element in an array appears at index 0.
The compiler uses this number along with the type of the array to determine how much memory to allocate for the array.
After the array's declaration, for example,.
Unlike with vectors, the compiler will insist that the programmer use an integral value for an index; for.
Identically to vectors, the programmer must ensure that the array index.
The programmer can supply a number.
An undecorated array name by itself in Cplus_plus source code behaves like a constant pointer to the beginning element of the array.
Consequently, when an array is passed as an actual parameter during a function call,.
The clear function actually modifies the contents of main's  array.
The function works on the array's actual elements, not copies of its elements.
Arrays, therefore, by default are passed by reference with respect to the elements they contain.
By default, an array's contents are open to corruption by errant functions.
In order to protect an array so that a.
Cplus_plus does not directly support empty arrays.
A physical array must contain at least one element.
Some¬ times it is appropriate to consider an array that is conceptually empty; for example, what if we wish to pass an "empty" array to the sum function.
We can pass 0 as the second parameter since an empty array contains no elements, but what should we pass as the first parameter.
Any array will do, but there is no need create an real array when none truly is needed.
An array name used in Cplus_plus source code references a location in memory, the address of the first element (element at index 0) in the array.
In this way an array name is similar to a constant pointer (see Section |10,7| for more information about Cplus_plus pointers).
Because of this, we can treat in some ways an array identifier like a pointer.
Similarly, we can direct a pointer to point to an array, and then treat the pointer itself as if it were an array.
A shorter way to accomplish the same thing is = ; since  is itself  reference to the array's location in memory.
This assignment statement clearly demon¬ strates the association between array variables and pointer variables.
Note that the opposite assignment ( = ) is impossible, because array  declared as above may not appear by itself on the left side of the assignment operator.
Pointer variables can participate in addition and subtraction expressions.
The statement + +; changes the address stored in  so subsequently the pointer will point to the next integer position in memory.
If  is assigned to array , incrementing  redirects it to point to 's next element.
The expression [0] is another way to write * so the array indexing operator ([]) can be used with pointers.
Since most Cplus_plus types require more than one byte of storage, incrementing pointer by 1 does not simply add 1 to the address it holds.
The amount added depends on the type of the pointer; for example, on systems using 32-bit (4 byte) integers, adding 1 to an integer pointer variable increments its address by 4, not 1.
The compiler knows the type of the pointer variable because programmers must declare all variables.
The compiler, therefore, can automatically adjust the arithmetic to work properly.
If  pointer points to memory within an array and is of the same type as the array, incrementing the pointer correctly repositions the pointer to point to the next element in the array.
The expression * (  + i ) dereferences the address that is i positions away from the address referenced by.
Sometimes pointer notation is used to represent an array parameter to  function.
The array print.
The recursion terminates when the array's length is zero.
Instead of passing  pointer to an array and the array's size, we can pass two pointers.
The first pointer points to the beginning of the array and another pointer points just past the end of the array.
Listing ~l_0_16K pointerarithmetic_0_cpp) also shows how we can use the square bracket array access op¬.
The advantage of the begin/end pointer approach is that it allows a programmer to pass a slice of the array to the function; for example, if we wish to print the elements of the array from index 3 to index 7, we would.
Programmers need not worry about managing the memory used by static arrays.
The compiler and run-time environment automatically ensure the array has enough space to hold all of its elements.
The space held by local arrays is freed up automatically when the local array goes out of the scope of its declaration.
Global arrays live for the lifetime of the executing program.
Memory management for static arrays, therefore, works just like scalar variables.
Static arrays have a significant limitation: The size of a static array is determined at compile time.
The programmer may change the size of the array in the source code and recompile the program, but once the program is compiled into an executable program any static array's size is fixed.
For many applications the circumstances of the executing program must determine the size of an array.
Static arrays lack such flexibility.
Listing |l 1_0_17| (largearrayaverage_0_cpp) creates an array that can hold one million entries.
Notice that the array numbers is a global variable and is not local to mai n.
This is because most systems limit the amount of storage available to local variables within functions.
Local variables reside in an area of memory known as the stack.
Local variables exist in memory only when the function that uses them is invoked; therefore, the stack grows and shrinks as functions execute and return.
Global variables, on the other hand, exist in the computer's memory for the life of the program's execution.
Global variables are stored in what is known as static memory.
There is a limit to the amount of static memory available for global variables (the amount of memory in RAM or virtual memory on disk, if nothing else), but the global limit usually is much higher then the local limit.
One million double-precision floating-point numbers consumes 8,000,000 bytes (8 megabytes) in Visual Cplus_plus and on many other systems.
The default stack size for local variables under Visual Cplus_plus is only one megabyte, although the stack size can be increased by adjusting the compiler and linker build options.
While the approach taken in Listing 11_0_17 (largearrayaverage_0_cpp) works, it wastes memory resources.
In modern computing, a user may have multiple programs open at the same time.
If each program is tying up the maximum amount of memory it may ever need, there may not be enough real memory (RAM) to go around, and the computer will be forced to use more virtual memory (shuttling portions of the running program's memory to and from the disk drive).
Virtual memory access greatly degrades the speed of a program, and so the user's experience suffers.
It is important that each program uses its resources wisely.
Statically allocating the largest array that might ever be needed is not a good approach.
This statement makes space for a single pointer, merely four bytes on a 32-bit system or eight bytes on a.
The value of this expression is the starting address of the newly allocated memory block.
While we access a dynamic array via a pointer, a static array array behaves like a constant pointer; that , a pointer that we cannot reassign to point elsewhere.
The reserved word new  memory for the array's elements, new   classified as an operator.
The area of memory used for dynamic allocation via new  different from both the area used for local variables (the stack) and global variables (static memory).
Dynamic memory comes from the heap.
The variable   local to mai n, so it lives on the stack.
It  a pointer, so it stores a memory address.
The new  returns an address to memory in the heap.
We do not need to worry about our array being too big to be local to mai n, since its contents do not consume stack space.
An executing program automatically  on the stack the local variables of a function when a caller invokes the function.
The executing program also automatically deallocates local variables when the function returns.
The programmer does not need to explicitly manage local variables.
Dynamically allocated memory, however, requires more attention on the part of the programmer.
The statement delete [] ; // Free up the space held by uses the delete  to free up the memory held by the  array.
The programmer  respon¬ sible for deallocating memory that was allocated with.
Notice that the square brackets ([]) are empty.
The run-time environment keeps track of the amount of memory to free up.
You should develop the habit of ensuring that every use of the   has an associated call of delete.
If the delete statement  omitted from Listing 11_0_18 (flexiblearrayaverage_0_cpp), the program in this case likely will behave no differently since most operating systems reclaim all the dynamic memory a program holds when the program finishes executing.
Serious problems arise in longer running programs that must allocate and deallocate dynamic memory over time.
Programs that run for extended periods of time, like web servers and operating system kernels, can crash due to failures to properly deallocate memory.
The condition  known as a memory leak —the program overtime  more and more memory via never releases the memory back with delete.
Eventually the program uses up all of the available heap space and crashes.
Since  behaves like a constant pointer, we cannot reassign it; that , the name  cannot appear on the left.
The code above will not compile.
Declare two arrays, one dynamic Populate one of them a is filled with increasing values Make a copy of array a.
This illustrates another key difference between vectors and arrays: It is not possible to assign one array.
If the arrays are static arrays, the simple assignment is illegal.
If the arrays are dynamic arrays, the.
Figure [TT7111| shows how this process works.
It is important to note that since the  above allocates  dynamically with ,  elsewhere within the program should eventually use delete to free up 's space when it is no longer used.
Failure to properly deallocate  constitutes  memory leak.
Consider the following scenario:.
Not only does this simple assignment create an alias,  it also creates  memory leak.
If the reassigned  originally was pointing to  block of memory allocated on its behalf, and no other pointers reference that block of memory, that block is unreachable by the executing program.
Listing 11_0_18) (flexiblearrayaverage_0_cpp) requires the user to enter up front the number of values to average.
This is inconvenient, and people are notoriously poor counters.
One solution is to allocate minimal size , and then resize it as necessary when it fills up.
Listing 1 1_0_19[ (resizearray_0_cpp) uses this approach.
Notice that the programmer of Listing ).
Unlike vectors, an  has  fixed size.
It is impossible to change the size of  static  (short of editing the source  and recompiling).
In order to change at run time the size of  dynamic , you must.
Just as Cplus_plus supports higher-dimensional vectors, it also supports multidimensional arrays.
The following statement: [2] [3] ; declares  to be  two-dimensional (2D)  of integers.
In this case, the declaration specifies that contains two rows and three columns.
Figure |l 1_0_12) shows the logical structure of the  created by the.
Rows are arranged horizontally, and the values in columns are arranged vertically.
In each of the assignment statements above, for example [1][0] = 22; the first index (here 1) signifies the row and the second index (here 0) denotes the column of the element within the.
For 2D arrays initialized in this manner the first subscript is optional, but the second subscript (that is, the.
The declaration of the parameter m is quite complicated, and, as we did for 2D vectors, we can simplify the syntax by using  Cplus_plus  aliasing statement, statement using  = double [ROWS][COLUMNS] ; defines  new  named.
Given the  alias using statement defining the new  name Mat r  x, we can express the param¬.
As with vectors, Cplus_plus allows arrays with dimensions higher than two.
Each "slice" of  3D array is.
C and Cplus_plus implement strings as arrays of char.
The Cplus_plus language additionally supports string objects (see Section 13_0_11.
In the C language, the only option is  char array.
We use the term C string to refer to an array of characters as used in the C language.
In this section, any mention of the term string refers to  C string.
A string is an array of characters.
A string literal is  sequence of characters enclosed within quotation marks, as in.
This means the last character in the array is ASCII zero, which Cplus_plus.
Enough space must be reserved for number of characters in the string, including the null terminating.
The array of characters must be properly null terminated.
The following code fragment is safe and acceptable:.
The following code fragment is less safe:.
The string  can hold 255 viable characters plus the null terminator.
If the user types in relatively short words (length less than 255 characters), there is no problem.
If at any time the user types in more characters than will fit in the  array, the executing program will have  problem.
The problem is known as buffer overrun.
In the best case, buffer overruns lead to buggy programs.
In the worst case, clever users can exploit buffer overruns to compromise software systems.
Buffer overruns are always logic errors and you should take great care to avoid them.
The following code provides  safe way to get user input:.
The second parameter specifies the maximum length of the string, including the terminating null character, that will be placed in the string.
The last argument, stdi  is  C construct related to the Cplus_plus object std : : ci.
In order to use f gets within  program you must include the <cstdio> header.
The following code begs for disaster:.
In this case  points to a random location in memory (it is uninitialized), and the code allocates no buffer to receive the input characters from std : : ci.
The program's behavior executing this code is undefined, but it likely will lead to the program crashing.
Insidiously, depending on how the operating system manages memory, the program may run fine much of the time and crash only rarely.
Regardless, the program contains a serious bug.
When passing an array to a function a caller must provide the size of the array so that the function may process the array properly.
Since C strings are null terminated, such size information is not necessary.
The find_cha r function in Listing 11_0_21 (findchar_0_cpp) determines if a particular character is present in a string.
The find_char function in Listing 11_0_21 (findchar_0_cpp) uses pointer notation to traverse the string.
It does not need to know in advance the number of characters in the string because it starts at the beginning and keeps scanning each character in turn until it finds the character it is looking for or encounters the null terminating character.
The only way out of the loop is to scan the null terminating  or the  sought.
Here, if the loop encounters the null terminating , it exits and returns that null.
The null is simply ASCII zero—Boolean false.
If the loop locates the sought , it exits and returns that which will not be ASCII zero.
Any  except the null  has an ASCII value greater than zero; therefore, the calling code interprets the returned  as Boolean true.
Some standard C string functions include.
The function returns an integer less than zero if  appears lexicographically before t.
The function returns an integer greater than zero if  appears lexicographically after t.
The function returns zero if the two strings are identical.
The following code fragment.
The function returns an integer less than zero if the first n characters of  appear lexicographically before the first n characters of t; that is, would appear before t is a dictionary.
The function returns an integer greater than zero if the first n characters of  appear lexicographically after the first n characters of t.
The function returns zero if the first n characters of the two strings are identical.
You should be familiar with C strings because Cplus_plus code can use C libraries, and C libraries often use C strings.
Since C strings tend to be problematic, however, in most cases you should use the newer stri ng objects (see Sectionfl3_0_l) whenever possible.
Windows command prompt the command.
These filenames are called command-line arguments.
They are provided in addition to the program' name.
Command-line arguments allow the user to customize in some way the behavior of the program when launching it.
In the example above, the user specifies which file to copy and the name of its copy.
Cplus_plus programs that process command-line arguments do so via an array.
C:\Code>cmdlineargs -h 45 extra.
The program did not print the first line shown in this program run.
The command shell printed C:\Code> awaiting the user' command, and the user typed the remainder of the first line.
In response, the program printed the remaining four lines.
The parameter argc contains the number (count) of arguments on the command line typed by the user.
The declaration cha r *a rgv [] indicates a rgv is an array of C strings.
Notice that a rgv [0] is simply the name of the file containing the program.
Since the command-line arguments are strings, not integers.
It is important to note is that arrays are not objects and, therefore, have no associated methods.
The square bracket notation when used with arrays does not represent a special operator method.
The square bracket array access notation is part of the core Cplus_plus language inherited from C.
The creators of the Cplus_plus vector library designed vectors to behave as much as possible like primitive C arrays.
Arrays have been part of the C language since its beginning, but vectors (added by Cplus_plus) have adopted the syntactical features of arrays.
Both arrays and vectors use square brackets for element access, and both locate their first element at index zero.
Both provide access to a block of memory that can hold multiple elements.
A vector object adds some additional capabilities and conveniences that make vectors the better choice for Cplus_plus developers.
Table 111_0_1 1| summarizes many of the differences between vectors and arrays.
Vectors have a close association with arrays—a vector object is a thin wrapper around a dynamic array.
The _capaci ty pointer points to the memory location just past the block of memory allocated for the array.
The _capacity pointer is present because the array managed by a vector often will have more space allocated than the vector currently needs.
An algorithm determines the amount of extra space needed to balance the demands of storage economy and fast push_back calls.
When an executing program attempts to push_back an  onto a vector that has not reached its capacity, the operation is very fast; however, an attempt to push_backan  onto a vector that is at its capacity forces the run-time memory manager to do the following:.
Resizing and copying the array is a relatively time-consuming process, especially as the size of the vector grows.
The vector's capacity is tuned so that the average time to perform push_backis fast without the need to consume too much extra memory.
A vector adds value to a raw array by providing convenient methods for adding elements and resizing the array it manages.
A vector keeps track of its own size.
Arrays provide none of the convenient methods that vectors do.
The overhead that a vector imposes over a raw dynamic array is negligible.
You should prefer vectors over arrays when writing Cplus_plus code.
What if you are using vectors, but you need to use a C library that accepts only arrays.
Note that the first parameter is the starting address of the wrapped array, and the second parameter is the.
Since the Cplus_plus11 standard, the std: :vector class has a method named data that returns a pointer to the first  of the array the vector manages.
We can rewrite the above statement as.
As these examples show, you may use  objects instead of arrays without any danger of not being able to use libraries that deal only with arrays.
If you happen to be using an array and need to use a function that expects a  instead, it is easy to.
One disadvantage of this technique is that it copies all the elements in arr to a new  array managed by the.
This is because a object demands full control over the array it manages.
A  automatically frees up the memory of its array when it goes out of scope.
Forcing a  to manage a preexisting array could lead to problems in two ways:.
The code that created the array could later delete the contents of the array out from under the Any attempted use of the  after that point would be a problem.
When the  goes out of scope it automatically deallocates the array it manages.
The code that originally created the array could afterward attempt to access the deallocated array with similar predictably disastrous results.
For these reasons the developers of the standard library designed the std : :  class to be in full control of its managed array.
We thus cannot create a  object from array created elsewhere without making a copy of the array.
We will see in Chapter jjT9] that it is relatively easy to write a function in a generic way so that it can accept and process either a  or an array with equal efficiency.
Vectors are convenient data structures for working with dynamically-allocated arrays.
Cplus_plus provides an object-oriented type equivalent to static C arrays.
The std: : array is the preferred way to represent statically-allocated arrays in Cplus_plus.
In order to use the std : : a r ray class you must use the following preprocessor directive: ttinclude <array> Instead of declaring a static array as int arr[100]; you can write std::array< nt , 100> arr; The first expression in the angle brackets specifies the type of elements held by the array, and the second expression specifies the array's statically-allocated size.
The compiler must be able to compute the size; this means the size must be an integral literal or defined integral constant.
Like a static C array, this size cannot be specified at run time.
Also unlike std : : vectors, the size of a std : :array object remains fixed for the duration of the program's execution.
Like a std: : , however, a std: :array object keeps track of its own size and supports reassignment.
Listing [ 11_0_24[ (stdarray_0_cpp) shows that we can determine the number of elements in a std : : a r ray object via its size method, just as we would with a std: : object.
Programmers must manage primitive arrays and associated pointers very carefully because array and pointer misuse is a common source of difficult to find and repair bugs within programs.
Vectors effectively take care of much of the memory management problems that plague raw arrays.
Additionally, vectors provide functionality and convenience that arrays cannot.
As we have seen, it is easy to adapt a  to a context that requires an array.
Listing [l 1,25| (fasterprimes_0_cpp) uses an algorithm developed by the Greek mathematician Eratosthenes who lived from 274 B_0_C.
The principle behind the algorithm is simple: Make a list of all the integers two and larger.
Two is a prime number, but any multiple of two cannot be a prime number (since a multiple of two has two as a factor).
Go through the rest of the list and mark out all multiples of two (4, 6, 8, _0__0__0_).
Move to the next number in the list (in this case, three).
If it is not marked out, it must be prime, so go through the rest of the list and mark out all multiples of that number (6, 9, 12, _0__0__0_).
Continue this process until you have listed all the primes you want.
Recall Listing pL8| (measureprimespeed_0_cpp), which also prints all the prime numbers up to 500,000.
Using redirection (see Section [8T4| , Listing |8_0_8| (measureprimespeed_0_cpp) takes 77 seconds.
In comparison, Listing fll ,25| (fasterprimes_0_cpp) takes about one second to perform the same task on the system.
This is comparable to the square root version.
Listing |83](rnoreefficientprirnes_0_cpp), which takes two seconds to run.
If the goal is to print the prime numbers up to 1,000,000, the original version averages 271 seconds, or about four and one-half minutes.
The square root version averages 4_0_5 seconds.
The , -based version averages 2 seconds.
For 5,000,000 values the unoptimized original version takes a little over an hour and 33 minutes, the square root version takes a respectable 39 seconds, but  version averages only 9 seconds to run.
Both the  and array types represent linear sequences of elements.
Vectors and arrays are con¬ venient for storing collections of data, but they have some limitations.
In Section [2TTj we will consider another kind of aggregate data structure called an associative container.
Associative containers permit ele¬ ment access via a key rather than an index.
Unlike an index, a key is not restricted to an integer expression.
Associative containers are a better choice for some kinds of problems.
Provide a single declaration statement that declares an integer  named li st that contains the values 45, —3, 16 and 8.
Does a  keep track of the number of elements it contains.
Does the std : : a r ray class have more in common with a static array or a dynamic array.
Complete the following function that adds up all the positive values in an integer.
For example, if  vec contains the elements 3, -3, 5, 2, —1, and 2, the call sum_posi ti ve (vec) would evaluate to 12,  3 + 5 + 2 + 2= 12.
The function returns zero if the  is empty.
The function does not affect the contents of the.
Complete the following function that counts the even numbers in an integer.
For example, if vec contains the elements 3, 5, 4, —1, and 0, the call count_evens (vec) would evaluate to 2,  the  contains two even numbers: 4 and 0.
The function returns zero if the  is empty.
The function does not affect the contents of the.
Complete the following function that compares two integer vectors to see if they contain exactly the same elements in exactly the same positions.
The function returns true if the vectors are equal; otherwise, it returns false.
For example, if  vecl contains the elements 3, 5, 2, —1, and 2, and  vec2 contains the elements 3, 5, 2, —1, and 2, the call equals (vecl, vec2) would evaluate to true.
If instead  vec2 contains the elements 3, 2, 5, —1, and 2, the call equals (vecl, vec2) would evaluate to false (the second and third elements are not in the same positions).
Two vectors of unequal sizes cannot be equal.
The function does not affect the contents of the vectors.
Complete the following function that determines if all the elements in one  also appear in another.
The function returns true if all the elements in the second  also appear in the first; otherwise, it returns false.
For example, if  vecl contains the elements 3, 5, 2, —1, 7, and 2, and  vec2 contains the elements 5, 7, and 2, the call contai ns (vecl, vec2) would evaluate to true.
If instead  vec2 contains the elements 3, 8, —1, and 2, the call contai ns (vecl, vec2) would evaluate to false (8 does not appear in the first ).
Also If  vec2 contains the elements 5, 7, 2, and 5, the call contai ns (vecl, vec2) would evaluate to false (5 appears twice in vec2 but only once in vecl, so vecl does not contain all the elements that appear in vec2).
The function does not affect the contents of the vectors.
All the elements in the same row should appear on the same line, and but each successive row should appear on its own line.
Consider the declaration std::<std::<std::<std::vectorci nt>>>> mesh(100, std::vectorci nt> (200, std: :<int> (100, std:: <int> (50))));.
Provide the statement(s) that declare and ceate a dynamic array named a that can hold 20 integers.
What extra attention does a programmer need to give to a static array when its use within a program is finished.
What extra attention does a programmer need to give to a dynamic array when its use within a program is finished.
What extra attention does a programmer need to give to a  array when its use within a program is finished.
Provide a single declaration statement that declares an integer array named li st that contains the values 45, —3, 16 and 8.
Does an array keep track of the number of elements it contains.
Complete the following function that adds up all the positive values in an array of integers.
For example, if array ar r contains the elements 3, -3, 5, 2, — 1, and 2, the call sum_positive(arr) would evaluate to 12,  3+5 + 2 + 2= 12.
The function returns zero if the array is empty (that is, n < 1).
Complete the following function that sums the even numbers in an array of integers.
For example, if array arr contains the elements 3, 5, 2, —1, and 2, the call sum_evens (arr) would evaluate to 4,  2 + 2 = 4.
The function returns zero if the array is empty (that is, n < 1).
The function does not affect the contents of the array.
All the elements in the same row should appear on the same line, and but each successive row should appear on its own line.
Given the following declarations which appear in a function body:.
What is the consequence of its omission.
List some common errors programmers make when dealing with dynamic memory.
Chapters |TT] introduced the fundamentals of making and using vectors.
Sorting—arranging the elements within a sequence into a particular order—is a common activity.
For example, a sequence of integers may be arranged in ascending order (that is, from smallest to largest).
A sequence of words (strings) may be arranged in lexicographical (commonly called alphabetic) order.
Many sorting algorithms exist, and some perform much better than others.
We will consider one sorting algorithm that is relatively easy to implement.
The selection sort algorithm is relatively easy to implement, and it performs acceptably for smaller sequences.
If A is a sequence, and  and j represent indices within the sequence, selection sort works as follows: 1.
Examine all the elements A[j], where j >.
If any of these elements is less than A[], then exchange A[] with the smallest of these elements.
If  is less than the length of A, increase  by 1 and goto Step 2.
If the condition in Step 3 is not met, the algorithm terminates with a sorted sequence.
The command to "goto Step 2" in Step 3 represents a loop.
We can begin to translate the above description into Cplus_plus as.
In order to determine if any of the elements is less than A [  ], we introduce a new  named The purpose of  is to keep track of the position of the smallest element found so far.
We will set  equal to  initially because we wish to locate any element less than the element found at position.
Interchanges the values of memory referenced by its parameters  and.
It effectively interchanges the values of variables in the caller' context.
We really do not need to write our own function to interchange the values of two integers as shown in Listing 12_0_1 (sortintegers_0_cpp).
The Cplus_plus standard library includes std : : swap that works just like the swap function in Listing [T2J~| (sortintegers_0_cpp); therefore, if you remove our custom swap definition in Listing 12_0_1 (sortintegers_0_cpp) and replace the call to swap with  call to std : : swap, the program will work just as well.
It is actually an easy modification; simply change the line "if ( [  ] < []).
This would take  little more effort, but it still is possible to do.
The next question is more intriguing: How can we rewrite the selecti on_sort function so that, by passing an additional parameter, it can sort the  in any way we want.
We can make our sort function more flexible by making it higher-order function (see Section [10_0_10 1 that accepts an ordering function as  parameter.
Listing |||12T2| (flexibleintsort_0_cpp) arranges the elements in two different ways using the same selecti on_sort function.
The comparison function passed to the sort routine customizes the sort's behavior.
The basic structure of the sorting algorithm does not change, but its notion of ordering is adjustable.
If the second parameter to selecti on_sort is less_than, the sort routine arranges the elements into ascending order.
If the caller passes greater_than instead, selecti on_sort rearranges 's elements into descending order.
More creative orderings are possible with more elaborate comparison functions.
Selection sort is a relatively efficient simple sort, but more advanced sorts are, on average, much faster than selection sort, especially for large data sets.
One such general purpose sort is Quicksort , devised by C.
Quicksort is the fastest known general purpose sort.
Since sorting is a common data processing activity, the standard C library provides a function More information about Quicksort and qsort is available at Quicksort.
The key function in Listing 12_0_3 (linearsearch_0_cpp) is locate; all the other functions simply lead to a more interesting display of locate's results.
If locate finds a match, it immediately returns the of the matching element; otherwise, if locate considers all the elements of the  and finds no match, it returns — 1.
This alignment simplifies the di splay function.
The kind of search performed by locate is known as linear search, since the process takes a straight line path from the beginning to the end of the , and it considers each element in order.
Figure [12,1 1| illustrates linear search.
An alternative to linear search is binary search.
In order to perform binary search a 's elements must be in sorted order.
Binary search exploits this sorted structure of the  using a clever but simple strategy that quickly zeros in on the element to find: 1.
If the  is empty, return — 1.
Check the element in the middle of the.
If the element is what you are seeking, return its If the middle element is larger than the element you are seeking, perform a binary search on the first half of the.
If the middle element is smaller than the element you are seeking, perform a binary search on the second half of the.
This approach is analogous to looking for a telephone number in the phone book in this manner: 1.
Open the book at its center.
If the name of the person is on one of the two visible pages, look at the phone number.
If not, and the person's last name is alphabetically less the names on the visible pages, apply the search to the left half of the open book; otherwise, apply the search to the right half of the open book.
Discontinue the search with failure if the person's name should be on one of the two visible pages but is not present.
If the  is empty, is zero, and  is equal to n — 1 which equals —1.
So in the case of an empty bi na ry_sea rch will skip the loop body and immediately return —1.
This is correct behavior because an empty  cannot possibly contain any item we seek.
The variable  represents the midpoint value between  and , and it is computed in the.
The problem arises if the  is large, and  and  both have relatively large values.
The expression  +  can overflow the range of integers producing a meaningless result.
The subsequent division by two is too late to help.
The result of the expression  +  would overflow the range of integers more often than the expression  + ( -  + 1) /2 because ( -  + l)/2 would be a much smaller value to add to fi r st.
If you are thinking "I would never have thought of that problem," don't worry too much.
A large number of competent, professional software engineers have fallen prey to this oversight (see http : //googleresearch.
The calculation of  ensures that  <  <.
If mi d is the location of the sought element (checked in the   f statement), the loop terminates, and returns the correct.
The second  f statement ensures that either  decreases or  increases each time through the loop.
Thus, if the loop does not terminate for other reasons, eventually  will be larger than , and the loop will terminate.
If the loop terminates for this reason, the function returns —1.
This is the correct behavior.
The second  f statement excludes the irrelevant elements from further search.
The number of ele¬ ments remaining to consider is effectively cut in half.
Figure |l2_0_2| illustrates how binary search works.
The implementation of the binary search algorithm is more complicated than the simpler linear search algorithm.
Ordinarily simpler is better, but for algorithms that process data structures that potentially hold large amounts of data, more complex algorithms employing clever tricks that exploit the structure of the data (as binary search does) often dramatically outperform simpler, easier-to-code algorithms.
For a fair comparison of linear vs.
The revised linear search algorithm is.
Notice that, as in the original version of linear search, the loop will terminate when all the elements have been examined, but it also will terminate early when it encounters an element larger than the sought element.
Since the  is sorted, there is no need to continue the search once you have begun seeing elements larger than your sought value; seek cannot appear after a larger element in a sorted.
Suppose a  to search contains  elements.
In the worst case—looking for an element larger than any currently in the  — the loop in linear search takes  iterations.
In the best case—looking for an element smaller than any currently in the —the function immediately returns without considering any other elements.
The number of loop iterations thus ranges from 1 to , and so on average linear search requires ^ comparisons before the loop finishes and the function returns.
Now consider binary search of a  that contains  elements.
After each comparison the size of the left to consider is one-half the original size.
If the sought item is not found on the  probe, the number of remaining elements to search is |.
After the next time through the loop, the number of elements left to consider is one-half of j, or After the third iteration, search space in the  drops to one-half of which is This process of cutting the search space in half continues each time through the loop until the process locates the sought element or runs out of elements to consider.
The problem of determining how many times a set of things can be divided in half until only one element remains can be solved with a base-2 logarithm.
For binary search, the worst case scenario of not finding the sought element requires the loop to make log 2 u iterations.
How does this analysis help us determine which search is better.
The quality of an algorithm is judged by two key characteristics:.
How much time (processor cycles) does it take to run.
How much space (memory) does it take to run.
In our situation, both search algorithms process the sequence with only a few extra local variables, so for large sequences they both require essentially the same space.
The big difference here is speed.
Binary search performs more elaborate computations each time through the loop, and each operation takes time, so perhaps binary search is slower.
Linear search is simpler (fewer operations through the loop), but perhaps its loop executes many more times than the loop in binary search, so overall it is slower.
We can deduce the faster algorithm in two ways: empirically and analytically.
An empirical test is an.
Listing jT23| (searchcompare_0_cpp) measures the running times of the two kinds of searches to compare the two algorithms empirically.
Listing |T23| (searchcompare_0_cpp) applies linear search and binary search to vectors of various sizes and dis¬ plays the results.
The  sizes range from 0 to 50,000.
The program uses the function ti me_executi to compute the average running times of linear search and binary search.
The main function directs which search ti me_executi  should perform by passing as the  parameter a pointer to the appropriate function.
The second parameter to ti me_executi  specifies the number of runs the function should use to compute the average.
Notice that in this program we average linear search over five runs and execute binary search over 25 runs.
We subject the binary search function to more runs since it executes so quickly, and five runs is not an adequate sample  to evaluate its performance, especially for smaller vectors where the binary search's execution time is close to the resolution of the timer.
Besides, since binary search does execute so quickly, we easily can afford to let ti me_executi  run more tests and compute a more accurate average.
In Listing 12_0_5 (searchcompare_0_cpp) we use stream manipulators std : :  and std : : setpreci si to dress up the output.
The std : :  manipulator adjusts std : :  to use a  number of deci¬ mal places, and the std : : setpreci si  manipulator specifies the number of digits to display after the decimal point.
The two manipulators in tandem allow us to align the columns of numbers by their decimal points.
With a vector of  50,000 linear search takes  average about 12 seconds  one system, while binary search requires a small fraction of a one second.
The times for binary search are so small that the progression of times wanders a bit from perfectly ascending order.
This is because the operating system is performing other tasks while our program is running.
It gives each active program its own slice of processor time to run.
The operating system can interrupt executing programs to give other tasks time to run.
For most programs this processor time sharing is imperceptible, but it can make a significant difference in short¬ running programs.
We can see in the results that the operating system must have attending to some other matters during the binary search of vectors of size 20,000 and 45,000, as these times are slightly higher than we would expect from the pattern of values.
Ideally we would perform the tests multiple times and average the results to get a more accurate picture.
If we increase the vector's size to 500,000, linear search runs in 830 seconds (13 minutes, 50 seconds), while binary search still takes less than one second.
Empirically, binary search performs dramatically better than linear search.
One might wonder why a binary search on vector with 45,000 items is slightly slower than one on a vector containing 50,000 elements.
This particular execution was performed on a computer running Microsoft Windows.
Microsoft Windows' timer resolution via the clock function is milliseconds, so the values for bi¬ nary search are near that timer's resolution.
Windows is a multitasking operating system, meaning it manages a number of tasks (programs) simultaneously.
The measurements above were performed on a "lightly loaded system," which means during the program's execution the user was not downloading files, browsing the web, or doing anything else in particular.
Windows, as all modern multitasking OSs, runs a lot of services (other programs) in the background that steal processor time slices.
It continually checks for network connections, tracks the users mouse movement, etc.
The binary search algorithm's speed coupled with a multitasking OS with millisecond timer resolution can lead to such minor timing anomalies.
In addition to using the empirical approach, we can judge which algorithm is better by analyzing the source code for each function.
Each arithmetic operation, assignment, logical comparison, and vector access requires time to execute.
We will assume each of these activities requires one unit of processor "time_0_" This assumption is not strictly true, but it will give acceptable results for relative comparisons.
Since we will follow the same rules when analyzing both search algorithms, the relative results for comparison purposes will be fairly accurate.
We determined that, on average, the loop makes  iterations for a vector of length.
The initialization of happens only one time during each call to linear_search.
All other activity involved with the loop except the return statements happens | times.
The function returns either  or —1, and only one return is executed during each call.
Table |12_0_1| shows the breakdown for linear search.
We determined that in the worst case the loop in bi na ry_sea rch iterates log 2  times if the vector contains  elements.
The two initializations before the loop are performed once per call.
Most of the actions within the loop occur log 2  times, except that only one return statement can be executed per call, and in the  f/else statement only one path can be chosen per loop iteration.
Table 12_0_2 shows the complete analysis of binary search.
We will call our binary search function ().
Figure 12_0_3 shows the plot of the two functions () = 3 +4 and () = 121 2  +6.
For  < 17, the linear function 3 + 4 is less than the binary function 12 log 0  + 6.
This means that linear search should perform better than binary search for vector sizes less than 17.
This is because the code for linear search is less complicated, and it can complete its work on smaller vectors before the binary search finishes its more sophisticated computations.
Unfortunately we cannot empirically compare the running times of the two searches for vectors small enough to demonstrate that linear search is faster for very small vectors.
As the output of Listing 12_0_5 (searchcompare_0_cpp) shows, both searches complete their work in time less than the resolution of our timer for vectors with 1,000 elements.
Both empirically and analytically, we see that binary search is fast even for very large vectors, while linear search is impractical for large vectors.
Sometimes it is useful to consider all the possible arrangements of the elements within a vector.
A sorting algorithm, for example, must work correctly on any initial arrangement of elements in a vector.
To test a sort function, a programmer could check to see if it produces the correct result for all arrangements of a relatively small vector.
A rearrangement of a collection of ordered items is called a permutation.
Listing [_0_2i6|(vectorpermutations_0_cpp) prints all the permutations of the contents of a given vector.
The permute function in Listing jTZ6j (vectorpermutations_0_cpp) is a recursive function, as it calls itself inside of its definition.
We have seen how recursion can be an alternative to iteration; however, the permute function here uses both iteration and recursion together to generate all the arrangements of a glance, the combination of these two algorithm design techniques as used here may be difficult to follow, but we actually can understand the process better if we ignore some of the details of the code.
First, notice that in the recursive call the argument begi  is one larger, and end remains the same.
This means as the recursion progresses the ending index never changes, and the beginning index keeps increasing until it reaches the ending index.
The recursion terminates when  becomes equal to end.
In its simplest form the function looks like this:.
If a loop iterates a fixed number of times, you may replace the loop with the statements in its body duplicated that number times; for example, we can rewrite the code for (int  = 0;  < 5; iplus_plus) std:: <<  << '\' ; as.
This process of transforming a loop into the series of statements that the loop would perform is known as loop unrolling.
Compilers sometimes unroll loops to make the code's execution faster.
After unrolling the loop the loop control variable (in this case ) is gone, so there is no need to initialize it (done once) and, more importantly, no need to check its value and update it during each iteration of the loop.
Our purpose for unrolling the loop in pe r f o rm is not to optimize it.
Instead we are trying to understand better how the algorithm works.
In order to unroll perform's loop, we will consider the case for vectors.
This series of swap-permute-swap operations allows.
The leftmost third of Figure [12_0_4 shows the original contents of the  and the initial call of permute.
The three branches represent the three iterations of the for loop:  varying from (0) to  (2).
The vectors indicate the state of the  after the first swap but before the recursive call to permute.
The middle third of Figure 12_0_4| shows the state of the  during the first recursive call to permute.
The two branches represent the two iterations of the for loop:  varying from begi n f 1) to  (2).
The vectors indicate the state of the  after the first swap but before the next recursive call to permute.
At this level of recursion the element at index zero is fixed, and the remainder of the processing during this chain of recursion is restricted to indices greater than zero.
The rightmost third of Figure |12_0_4| shows the state of the  during the second recursive call to.
The function makes no more recursive calls to itself.
The function merely prints the current contents of the vector.
The arrows in Figure; 12_0_4| represent a call to, or a return from, permute.
They illustrate the recursive call chain.
The arrows pointing left to right represent a call, and the arrows pointing from right to left represent a return from the function.
The numbers associated with arrow indicate the order in which the calls and returns occur during the execution of permute.
The second column from the left shows the original contents of the vector after the first swa p call but before the first recursive call to permute.
The swapped elements appear in red.
The third column shows the contents of the vector at the second level of recursion.
In the third column the elements at index zero are fixed, as this recursion level is using begi n with a value of one instead of zero.
The for loop within this recursive call swaps the elements highlighted in red.
The rightmost column is the point where begi n equals , and so the permute function does not call itself effectively terminating the recursion.
While Listing ||T2T6| (vectorpermutations_0_cpp) is a good exercise in vector manipulation and recursion, the Cplus_plus standard library provides a function named next_permutati on that rearranges the elements of a vector.
Listing 12_0_7 (stlpermutations_0_cpp) uses next_permutati on within a loop to print all the permutations of the vector's elements.
Section 112_0_4| showed how we can generate all the permutations of a vector in an orderly fashion.
More often, however, we need to produce one of those permutations chosen at random.
For example, we may need to randomly rearrange the contents of an ordered vector so that we can test a sort function to see if it will produce the original ordered sequence.
We could generate all the permutations, put each one in a vector of vectors, and select a permutation at random from that vector of vectors.
This approach is very inefficient, especially as the length of the vector to permute grows larger.
Fortunately, we can randomly permute the contents of a vector easily and quickly.
Listing |T2T8( (randompermute_0_cpp) contains a function named permute that randomly permutes the elements of an vector.
Notice that the permute function in Listing |T£8~| (randompermute_0_cpp) uses a simple un-nested loop and no recursion.
The permute function varies the  index variable from 0 to the index of the next to last element in the.
Within the loop, the function obtains via rand (see Section 8_0_6) a pseudorandom index greater than or equal to.
It then exchanges the elements at position  and the random position.
At this point all the elements at index  and smaller are fixed and will not change as the function's execution continues.
The loop then increments index , and the process continues until all the  values have been considered.
To be correct, our permute function must be able to generate any valid permutation of the.
It is important that our permute function is able to produce all possible permutations with equal probability; said another way, we do not want our permute function to generate some permutations more often than others.
The permute function in Listing fl2TS| (randompermute_0_cpp) is fine, but consider a slight variation of the algorithm:.
Do you see the difference between f aulty_permute and permute.
The faulty_permute function chooses the random index from all valid  indices, whereas permute restricts the random index to valid indices greater than or equal to.
This means that faulty_permute can exchange any element within  a with the element at position  during any loop iteration.
While this approach superficially may appear to be just as good as permute, it in fact produces an uneven distribution of permutations.
Listing 12_0_9 (comparepermutations_0_cpp) exercises each permutation function 1,000,000 times on the {1, 2 , 3} and tallies each permutation.
There are exactly six possible permutations of this threeelement.
In one million runs, the permute function provides an even distribution of the six possible permutations of.
To see why faulty_permute misbehaves, we need to examine all the permutations it can produce.
The top of the tree shows the original , {1, 2, 3}.
The second row shows the three possible resulting configurations after the first iteration of the for loop.
The leftmost 3-tuple represents the element at index zero swapped with the element at index zero (effectively no change).
The second 3-tuple on the second row represents the interchange of the elements at index 0 and index 1.
The third 3-tuple on the second row results from the interchange of the elements at positions 0 and 2.
The underlined elements represent the elements most recently swapped.
If only one item in the 3-tuple is underlined, the function merely swapped the item with itself.
The bottom row of 3-tuples contains all the possible outcomes of the.
Compare Figure (12_0_5 to Figure p~2T6| The second row of the tree for permute is identical to the second row of the tree for faulty_permute, but the third row is different.
The second time through its loop the permute function does not attempt to exchange the element at index zero with any other elements.
We see that none of the first elements in the 3-tuples in row three are underlined.
The third row contains exactly one instance of each of the possible permutations of {1, 2 , 3}.
This means that the correct permute function is not biased towards any of the individual permutations, and so the function can 1.
Complete the following function that reorders the contents of   so they are reversed from their original order.
For example,   containing the elements 2, 6, 2, 5, 0, 1, 2, 3 would be transformed into 3, 2, 1, 0, 5, 2, 6, 2.
Note that your function must physically rearrange the elements within the , not just print the elements in reverse order.
Complete the following function that reorders the contents of   so that all the even numbers before any odd number.
The even values are sorted in ascending order with respect to them¬ selves, and the odd numbers that follow are also sorted in ascending order with respect to themselves.
For example,   containing the elements 2, 1, 10, 4, 3, 6, 7, 9, 8, 5 would be transformed into 2, 4, 6, 8, 10, 1, 3, 5, 7, 9 Note that your function must physically rearrange the elements within the , not just print the elements in reverse order.
Complete the following function that shifts all the elements of   backward one place.
The last element that gets shifted off the back end of the  is copied into the first (0th) position.
For example, if   containing the elements 2, 1, 10, 4, 3, 6, 7, 9, 8, 5 is passed to the function, it would be transformed into 5, 2, 1, 10, 4, 3, 6, 7, 9, 8 Note that your function must physically rearrange the elements within the vector, not just print the elements in the shifted order.
Complete the following function that returns true if   contains duplicate elements; it returns false if all the elements in  are unique.
For example, the  2, 3, 2, 1, 9 contains duplicates (2 appears more than once), but the  2, 1,0, 3, 8, 4 does not (none of the elements  more than once).
An empty  has no duplicates.
Can linear search be used on an unsorted.
Complete the following function i s_ascendi ng that returns true if the elements in   of integers  in ascending order (more precisely, non-descending order, if the  contains du¬ plicates).
For example, the following statement.
Consider  sort function that uses the i s_ascendi ng function from the previous problem.
It uses loop to test the permutations of   of integers.
When it finds  permutation that contains all of the 's elements in ascending order it exits the loop.
Do you think this would be  good sorting algorithm.
A technician does not need to assemble the card; the card is used as is off the shelf.
The video card provides  substantial amount of functionality in  standard package.
One video card can be replaced with another card from  different vendor or with another card with different capabilities.
The overall computer will work with either card (subject to availability of drivers for the operating system) because standard interfaces allow the components to work together.
Software development today is increasingly component based.
Software components are used like hardware components.
A software system can be built largely by assembling pre-existing software building blocks.
Cplus_plus supports various kinds of software building blocks.
The simplest of these is the function that we investigated in Chapter [8] and Chapter [9] A more powerful technique uses built-in and user designed software objects.
Cplus_plus is object-oriented.
It was not the first OO programming language, but it was the first OO language that gained widespread use in  variety of application areas.
An OO programming language allows the programmer to define, create, and manipulate objects.
Variables representing objects can have considerable functionality compared to the primitive numeric variables like i nts and doubles.
Like  normal variable, every Cplus_plus object has a type.
We say an object is an instance of a particular class , and class means the same thing as type.
An object's type is its class.
We have been using the std : :  and std : : ci n objects for some time, std : :  is an instance of the std : : ostream class—which is to say std : :  is of type std : : ostream.
Code that uses an object is a client of that object; for example, the following code fragment std:: << "Hello\n"; uses the std : :  object and, therefore, is a client of std : :.
Many of the functions we have seen so far have been clients of the std : :  and/or std : : ci n objects.
Objects provide services to their clients.
The Cplus_plus standard library provides the class stri ng which specifies string objects.
In order to use string objects, you must provide the preprocessor directive ttinclude <string>.
You declare a stri ng object like any other variable: string ; You may assign a literal character sequence to a st ri ng object via the familiar string quotation syntax: string  = "joe"; std:: <<  << '\n' ; = "jane"; std:: <<  << '\n' ; You may assign one stri ng object to another using the simple assignment operator: string  = "joe", 2; 2 = ;.
In this case, the assignment statement copies the characters making up  into 2.
After the assignment both  and 2 have their own copies of the characters that make up the string; they do not share their contents.
After the assignment, changing one string will not affect the other string.
Code within the string class defines how the assignment operator should work in the context of string objects.
The  ng class provides a method named si ze that behaves exactly like the length method.
The  ng class defines a method named [] that allows a programmer to access a char¬.
Similarly, += "-bye"; the syntactally sweetened way to write += ( "-bye" ); The +  performs  concatenation, making a new  by appending one  to the back of another.
With the substr method we can extract a new  from another, as shown in Figure 13_0_1 In addition to  methods, the standard  ng library provides a number of global functions that process strings.
These functions use  syntax and allow us to compare strings  <, ==, >=, etc.
A more complete list of  methods and functions can be found at http://www_0_cplusplus.
The precise type of std : :   std : : ostream, and std : : ci n's type  std : : i stream.
Like  objects, std : :  and std : : ci n have methods.
The << and >> operators actually are the methods << and >>.
The second statement calls the << method on behalf of the std : :  object passing the value of variable x.
A statement such as std:: << x << '\n' ;.
The return value (simply std : : ) then  used to invoke the << method again with ' \n ' as its argument.
It reads a value from the keyboard and assigns it to x.
The method call returns std : : ci n itself, and the return value is used immediately to invoke >> passing variable y by reference.
You probably have noticed that it is easy to cause a program to fail by providing input that the program.
What if the user enters the  "five," which arguably is an integer.
The program produces incorrect results.
We can use some additional methods available to the std : : ci n object to build a more robust program.
Listing 13_0_3 (betterintinput_0_cpp) detects illegal input and continues to receive input until the user provides an acceptable value.
If the user enters a value with a type compatible with the declared type of the variable, the expression evaluates to true; otherwise, it.
While determining whether of not a user's entry is correct seems sufficient for the programmer to make corrective measures, it is not.
Two additional steps are necessary:.
The bad input characters the user provided cause the std : : ci n object to enter an error state.
Whatever characters the user typed in that cannot be assigned to the given variable remain in the keyboard input buffer.
Clearing the stream object does not remove the leftover keystrokes.
Asking the user to retry without clearing the bad characters entered from before results in the same problem— the stream object re-enters the error state and the bad characters remain in the keyboard buffer.
The solution is to flush from the keyboard buffer all of the characters that the user entered since the last valid data entry.
Once the stream object has been reset from its error state and the keyboard buffer is empty, user input can proceed as usual.
The ostream and i stream classes have a number of other methods, but we will not consider them here.
This means you cannot use the >> to assign a complete line of text from the keyboard if that.
To read in a complete line of text from the keyboard, including any embedded spaces that may be.
Vectors would be more useful it they were persistent.
Data is persistent when it exists between program executions.
During one execution of a particular program the user may create and populate a vector.
The user then saves the contents of the vector to disk and quits the program.
Later, the user can run the program again and reload the vector from the disk and resume work.
The user also may quit the program, and later re-run the program and load in the previously saved list of numbers.
The user can save different number lists to different files using different file names.
Notice that in the save_vector and load_vector functions we pass the std : : stri ng param¬ eter as a const reference.
We do this for the same reason we do so for std: : objects (see Section [11,1_0_4[ )—this technique avoids making a copy of the string to pass the functions.
These functions can "see" the caller's actual string via the reference, rather than working with a copy of the string object.
The const specifier prevents the functions from modifying the string passed.
It takes time to copy a string (especially a long string), and the copy would occupy extra memory.
In this case the copy really is not necessary, so passing by const reference is the ideal approach.
This opens the file as the point of.
An output file stream may fail for various reasons, including the disk being full or insufficient permissions to create a file in a given folder.
Once we have its associated file open, we can use a std : : ofstream object like the std : : cout output stream object, except the data is recorded in a text file instead of being printed on the screen.
Just like with std : : cout, you can use the << operator and send a std : : ofstream object stream manipu¬ lators like std : : setw.
The std : : cout object and objects of class std : : ofstream are in the same family of classes and related through a concept known as inheritance.
We consider inheritance in more detail in ChapterjTTj For our purposes at this point, this relationship means anything we can do with the std : : cout object we can do a std : ofstream object.
The difference, of course, is the effects appear in the console window for std : : cout and are written in a text file given a std: :ofstream object.
After the executing program has written all the data to the file and the std: :ofstream object goes of scope, the file object automatically will close the file ensuring that all data the program writes to the file is saved completely on disk.
The std: : ofstream class provides also a close method that allows programmers to manually close the file.
This sometimes is useful when using the same file object to recreate the same file, as in Listing fl3_0_7|| (endltest_0_cpp).
In Listing 13_0_6 (numberlist_0_cpp), a std : : i fstream object reads data from files.
This opens the file as the point of.
As with std : : ofstream objects, filename is a string file name identifying the file to read.
After opening the file the program should call good to ensure the file was successfully opened.
An input stream object often fails to open properly because the file does not exist; perhaps the file name is misspelled, or the path to the file is incorrect.
An input stream can also fail because of insufficient permissions or because of bad sectors on the disk.
Once it opens its associated file, an input file stream object behaves like the std : : ci n object, except its data comes from a text file instead the keyboard.
This means the familiar >> operator and getli ne function are completely compatible with std: : i fstr earn objects.
The std: : ci n object and std : :ifstream.
As with an output stream object, a std : : i fstream object automatically will close its associated file when it goes out of scope.
Input and output streams use a technique known as buffering.
Buffering relies on two facts:.
It is faster to write data to memory than to disk.
A buffer is a special place in memory that holds data to be written to disk.
A program can write to the buffer much faster than directly to the disk.
When the buffer is full, the program (via the operating system) can write the complete contents of the buffer to the disk.
To understand the concept of buffering, consider the task of building a wall with bricks.
Estimates indicate that the wall will require about 1,350 bricks.
Once we are ready to start building the wall we can drive to the building supply store and purchase a brick.
We then can drive to the job site and place the brick in its appropriate position using mortar as required.
Now we are ready to place the next brick, so we must drive back to the store to get the next brick.
We then drive back to the job site and set the brick.
We repeat this process about 1,350 times.
It would be better to put as many bricks as possible into the vehicle on the first trip, and then make subsequent trips to the store for more loads of bricks as needed until the wall is complete.
In this analogy, the transport vehicle is the buffer.
The output stream object uses a special place in memory called a buffer.
Like the vehicle used to transport our bricks, the memory buffer has a fixed capacity.
A program can write to the buffer much more quickly than directly to the disk.
The << operator writes the individual values to save to the buffer, and when the buffer is full, the output stream sends all the data in the buffer out to the disk with one request to the operating system.
As with the bricks, this is more efficient than sending just one character at a time to the display.
This buffering process can speed up significantly the input and output operations of programs.
After the std : : of stream object writes all its data to its buffer and its lifetime is over, it flushes the remaining data from the buffer to disk, even if the buffer is not full.
The buffer is a fixed size, so the last part of the data likely will not completely fill the buffer.
This is analogous to the last load of bricks needed for our wall that may not make up a full load.
We still need to get those remaining bricks to our almost complete wall even though the vehicle is not fully loaded.
In some situations it is necessary to ensure the buffer is flushed before it is full and before closing the file completely.
With any output stream object writing text we can use the std: : endl stream object to flush the buffer without closing the file.
We mentioned std: : endl briefly in Section 3_0_1 We can use std : : endl interchangeably with ' \ n ' to represent newlines for console printing.
Because of the performance advantage buffering provides to file input and output, the choice of std: :endl and ' \ n ' can make a big difference for file processing.
Listing ||13_0_7|| (endltest_0_cpp) compares the performance of std : : endl and ' \ n ' in various situations.
Listing 1 13_0_7| |(endltest_0_cpp) writes a vector containing 100,000 integers to the console and a text file.
Each number appears on its own line.
Since std : : endl flushes the stream object's buffer in addition to printing a ' \ n ' , we would expect it to reduce the program's performance since it would minimize the benefit of buffering in this case.
Multiple runs of Listing 13_0_7 (endltest_0_cpp) on one system revealed that using ' \ n ' to terminate lines generally was only slightly faster than std : : endl (but not always) when writing to the console window.
The ' \ n ' terminator was consistently about three times faster than std : : endl when writing to a text file.
Listing 13_0_7 (endltest_0_cpp) also exploits the special relationship between std : cout and any std : : of stream object.
The pri nt_wi th_endl and pri nt_wi th_n functions both accept a std : : ostream object as their second parameter.
Note that the caller, mai n, passes both the std : : cout object and the fout object to these printing functions at various times, and the compiler does not complain.
We defer an expla¬ nation of how this works until Chapter [TT].
Cplus_plus supports mathematical complex numbers via the std : : complex class.
Recall from mathematics that a complex number has a real component and an imaginary component.
Often written as a + bi, a is the real part, an ordinary real number, and bi is the imaginary part where b is a real number and  = — 1.
The std : : complex class in Cplus_plus is a template class like vector.
In the angle brackets you specify the precision of the complex number's components: std:: complex<float> fc;.
Here, the real component and imaginary coefficient of fc are single-precision floating-point values, dc.
If the imaginary part is zero, the number is a  number (or, in this case, a double).
Imaginary numbers have scientific and engineering applications that exceed the scope of this book, so this concludes our brief into Cplus_plus's  class.
If you need to solve problems that involve com¬ plex numbers, more information can be found at http : / /www.
Listing |T29| (comparepermutations_0_cpp) showed that we must use care when randomly permuting the con¬.
Suppose we wish to generate pseudorandom numbers in the range 0_0_.
This range spans 10,000 numbers.
Under Visual Cplus_plus RAND_MAX is 32,767, which is large enough to handle a maximum value of 9,999.
The expression rand() % 10000 will evaluate to number in our desired range.
A good pseudorandom number generator should be just as likely to produce one number as another.
In a program that generates one billion pseudorandom values in the range 0_0_.
The actual value for a given number will vary.
Listing 13_0_9 (badrand_0_cpp) evaluates the quality of the rand with modulus technique by generating one billion pseudorandom numbers within a loop.
It counts the number of times the pseudorandom number generator produces 5 and also it counts the number of times 9,995 appears.
Note that 5 is near the beginning of the range 0_0_.
To verify the consistency of its results, it repeats this test 10 times.
The program reports the results of each individual trial, and in the end it computes the average of the 10 trials.
Figure 13_0_2 If shown in full, the table would contain 10,000 rows and 32,768 individual numbers.
Elements in each row are.
Four ways to obtain.
Only three ways to obtain any value in the range 2,768 _0__0_.
The next 10 lines that the program show the result of each trial, monitoring the activity of the one billion number generations.
Since we are dealing with pseudorandom numbers, the results for each trial will not be exactly the same, but over one billion runs each they should be close.
Note how consistent the results are among the runs.
While we expected both 5 and 9,995 to appear about the same number of times—each approximately 100,000 times—in fact the number 5 appeared consistently more that 100,000 times, averaging 122,072 times.
The number 9,995 appeared consistently less than 100,000 times, averaging 91,554_0_2.
Note that 122,072 ^ ^ = 1_0_33; this means the value 5 appeared 1_0_33 times more often than 9,995.
Figure 13_0_2 shows why the expression rand () % 10000 does not produce an even distribution.
Figure 13_0_2 shows an abbreviated list of all the numbers the rand function can produce before applying the modulus operation.
If you add the missing rows that the ellipses represent, the table would contain 10,000 rows.
All of the four values in each row are equivalent modulus 10,000; thus, for example.
Because the leftmost three columns are complete, the modulus operator can produce values in the range 0_0_.
The rand function cannot return a value greater than 32,767; specifically, in our program above, rand can¬ not produce 39,995.
Listing 13_0_9 (badrand_0_cpp), therefore, using rand and modulus we can produce 9,995 in only three different ways: 9,995, 19,995, and 29,995.
Based on our analysis, Listing [LL9| (badrand_0_cpp) can generate the number 5 four different ways and 9,995 three different ways.
This 4:3 ratio agrees with our empirical observations of the behavior of Listing |l3.
The consequences of this bias means that values in the relatively small range 0_0_.
Such bias definitely is undesirable in a pseudorandom number generator.
We must use more sophisticated means to produce better pseudorandom numbers.
The rand function itself has another weakness that makes it undesirable for serious scientific, engineer¬ ing, and mathematical applications, rand uses a linear congruential generator algorithm (see http : // en_0_wikipedia_0_org/wiki/Linear_congruential_generator).
This means that the pattern of the sequence of numbers it generates will repeat itself exactly if you call rand enough times.
For Visual Cplus_plus, rand's period is 2,147,483,648.
Listing 13_0_10 (randperiod_0_cpp) verifies the period of rand.
Listing 13_0_10 (randperiod_0_cpp) uses the Cplus_plusstandard long long int integer data type because it needs to count above the limit of the i nt type, 2,147,483,647.
The short name for long long i nt is just long long.
Visual Cplus_plus uses four bytes to store both i nt and long types, so their range of values are identical.
Under Visual Cplus_plus, the type long long occupies eight bytes which allows the long long data type to span the range —9,223,372,036,854,775,808 _0_.
To represent a literal long long within Cplus_plus source code, we append the LL suffix, as in 12LL.
The expression 12 represents the ~i nt (4-byte version) of 12, but 12LL represents the long long (8-byte version) of 12.
Listing 13_0_10|| (randperiod_0_cpp) prints the first 10 pseudorandom numbers it generates, then it prints.
A careful observer could detect this repetition and thus after some time be able to predict the next pseudorandom value that the program would produce.
A predictable pseudorandom number generator is not a good random number generator.
Such a generator used in a game of chance would render the game perfectly predictable by clever (and patient_0_) players.
A better pseudorandom number generator would have a much longer period.
The Mersenne twister (see http://en_0_wi kipedia_0_org/wiki /Mersenne_twi ster) is a widelyused, high-quality pseudorandom number generator.
It has a very long period, 2 ly y:,/ — 1, which is ap¬ proximately 4_0_3154 x lO 6001.
If an implementation of the Mersenne twister could generate 1,000,000,000 (one billion) pseudorandom numbers every second, a program that generated such pseudorandom numbers exclusively and did nothing else would need to run about 1_0_36 84 x 10 5,985 years before it began to repeat itself.
It is safe to assume that an observer will not be able to wait around long enough to be able to witness a repeated pattern in the sequence.
The standard Cplus_plus library contains the mtl9937 class from which programmers can instantiate objects used to generate pseudorandom numbers using the Mersenne twister algorithm.
Generating the pseudoran¬ dom numbers is one thing, but ensuring that the numbers fall uniformly distributed within a specified range of values is another concern.
Fortunately, the standard Cplus_plus library provides a multitude of classes that allow us to shape the production of an mtl9937 object into a mathematically sound distribution.
Our better pseudorandom generator consists of three pieces:.
We use the random_device object in place of srand.
The mtl9937 object performs the role of the rand function, albeit with much better characteristics.
The uni form_i nt_di stri buti on object constrains the pseudorandom values to a particular range, replacing the simple but problematic modulus op¬ erator.
Listing 13_0_11 (highqualityrandom_0_cpp) upgrades Listing j|13_0_9|| (badrand_0_cpp) with improved random number generation is based on these classes.
During this particular program run we see that in 1,000,000,000 attempts the program generates the value 5 on average 99,889_0_9 times and generates 9,995 on average 100,033 times.
Both of these counts approx¬ imately equal the expected 100,000 target.
Examining the 10 trials individually, we see that neither the for 5 nor the  for 9,995 is predisposed to be greater than or less than the other.
In some tri¬ als the program generates 5 slightly less than 100,000 times, and in others it appears slightly greater than 100,000 times.
These multiple trials show that in over 1,000,000,000 itera¬ tions the program consistently generates 5 approximately 100,000 times and 9,995 approximately 100,000 times.
The uniform_int_distribution object produces a pseudorandom number from the mtl9937 generator object.
The mt 19937 object generates a pseudorandom number, and the uni f orm_i nt_di stri buti on object constrains this pseudorandom number to the desired range.
Programmers create an mtl9937 object with a random_devi ce object.
The random_devi ce object provides the seed value, potentially from a hardware source, to the mtl9937 generator object.
We also can pass a fixed integer value to mtl9937's constructor if we want the generator to produce a perfectly reproducible sequence of values; for example, the following code fragment.
The use of random_devi ce, mtl9937, and uni form_i nt_di stri buti on is a little more complicated than using srand and rand with the modulus operator, but the extra effort is worth it for many applications.
This object-oriented approach is more modular because it allows us to substitute an object of a different pseudorandom number generator class in place of mtl9937 if we so choose.
We also may swap out the normal distribution for a different distribution.
Those familiar with probability theory may be familiar with a variety of different probability distributions, such as Bernoulli, Poisson, binomial, chi-squared, etc.
The Cplus_plus standard library contains distribution classes that model all of these probability distributions and many more.
Programmers can mix and match generator objects and distribution ob¬ jects as needed to achieve specialized effects.
While this flexibility is very useful and has its place, the.
All these strings are examples of strict palindromes where spacing and punctuation must reverse exactly.
Complete the following function that determines if a given string is a strict palindrome.
It should return true if the string is a strict palindrome and false otherwise.
The empty string reads the same forward and backward, so it is a palindrome.
What is the class of the std : : ci n object.
Suppose the user types in a line of text and presses the enter key.
For example, the user might type the following: The sky is blue What Cplus_plus statement could you use to assign to a std : : stri ng variable named msg the complete line of text, including spaces.
In earlier times programmers wrote software in the machine language of the computer system because com¬ pilers had yet to be invented.
The introduction of variables in association with higher-level programming languages marked a great step forward in the late 1950s.
No longer did programmers need to be concerned with the lower-level details of the processor and absolute memory addresses.
Named variables and func¬ tions allow programmers to abstract away such machine-level details and concentrate on concepts such as integers and characters that transcend computer electronics.
Objects provide a level of abstraction above that of simple variables.
Objects allow programmers to go beyond simple values—developers can focus on more complex things like geometric shapes, bank accounts, and aircraft wings.
Programming objects that represent these real-world things can possess capabilities that go far beyond the simple variables we have studied to this point.
A Cplus_plus object typically consists of a collection of data and code.
By bundling data and code together, objects store information and provide services to other parts of the software system.
An object forms a computational unit that makes up part of the overall computer application.
A programming object can model a real-world object more naturally than can a collection of simple variables since it can encapsulate considerable complexity.
Objects make it easier for developers to build complex software systems.
Cplus_plus is classified as an object-oriented language.
Most modem programming languages have some degree of object orientation.
This chapter shows how programmers can define, create, and use custom objects.
Mathematicians represent a single point as an ordered pair of real numbers, usually expressed as (x_0_y).
In Cplus_plus, the double type serves to approximate a subset of the mathematical real numbers.
We can model a point with coordinates within the range of double-precision floating-point numbers with two double variables.
We may consider a point as one thing conceptually, but we here we would be using two variables.
As a consequence, a function that computes the distance between two points requires four parameters— x\, y\, X 2 , and yj —rather than two points— (x\_0_y i) and (* 2 , 12 )- Ideally, we should be able to use one variable to represent a point.
This approach has several problems:.
We must use numeric indices instead of names to distinguish between the two components of a point object.
We may agree that pt[0] means the x coordinate of point pt and pt[l] means the y coordinate of point pt, but the compiler is powerless to detect the error if a programmer uses an expression like pt [19] or pt [-3].
We cannot restrict the 's size to two.
A programmer may accidentally push extra items onto the back of a  meant to represent a point object.
The compiler could not defend against a program treating an empty  as a point object.
We cannot use a  to represent objects in general.
Consider a bank account object.
A bank account object could , among many other diverse things, an account number (an integer), a customer name (a string), and an interest rate (a double-precision floating-point number).
A implementation of such an object is impossible because the elements in a  must all be of the same type.
In addition to storing data, we want our objects to be active agents that can do computational tasks.
We need to be able associate code with a class of objects.
We need a fundamentally different programming construct to represent objects.
Before examining how Cplus_plus specifically handles objects, we first will explore what capabilities are de¬ sirable.
An automobile user—the driver—uses the car for transportation.
The user's interface to the car is fairly simple, considering an automobile's overall complexity.
A driver pro¬ vides input to the car via its steering wheel, accelerator and brake pedals, turn signal control, shift lever, etc.
The automobile produces output to the driver with its speedometer, tachometer, various instrument lights and gauges, etc.
These standardized driver-automobile interfaces enable an experienced driver to drive any modern car without the need for any special training for a particular make or model.
The typical driver can use a car very effectively without understanding the details of how it works.
To drive from point A to point B a driver does not need to know the number of cylinders in the engine, the engine's horsepower, or whether the vehicle is front-wheel drive or rear-wheel drive.
A driver may look under the hood at the engine, but the driver cannot confirm any details about what is inside the engine itself without considerable effort or expense.
Many details are of interest only to auto enthusiasts or mechanics.
There may be only a select few automotive engineers capable of understanding and appreciating other more esoteric details about the vehicle's design and implementation.
In some ways programming objects as used in object-oriented programming languages are analogous to automobile components.
An object may possess considerable capability, but a programmer using the object needs to know only what the object can do without needing to know how it works.
An object provides an interface to any client code that wishes to use that object.
A typical object selectively exposes some parts of itself to clients and keeps other parts hidden from clients.
The object's designer, on the other hand, must know the complete details of the object's implementation and must be an expert on both the what the object does and how it works.
Programmers define the structure of a new  of object using one of two keywords: struct or class.
The two constructs are very similar.
We will use the class construct in this chapter, and we will consider structs in Section |15_0_9l A class serves as a pattern or template from which an executing program may produce objects.
In this chapter we will concentrate on four things facilitating object-oriented programming with Cplus_plus classes:.
Notice the semicolon that follows the close curly brace of the class definition.
This semicolon is required, but it is easy to forget.
By convention class names begin with a capital letter, but class names are just identifiers like variable names and function names.
Here, our class name is Poi nt.
The body of the class appears within the curly braces.
The elements declared within a class are known as members of the class.
The Poi nt class specifies two double-precision floating-point data components named x and y.
These components are known as instance variables.
The Cplus_plus community often refers to these as member data or data members.
Other names for instance variables include fields and attributes.
The declarations for x and y appear within the class body after the publi c label.
We say that x and y are public members of the Poi nt class; this means client code using a Poi nt object has full access to the object's x and y fields.
Any client may examine and modify the x and y components of a Poi nt object.
Once this Poi nt class definition is available, a client can create and use Poi nt objects as shown in.
It is important to note that Poi nt is not an object.
It represents a class of objects.
The variables and 2 are the objects, or instances, of the class Poi nt.
Each of the objects  and 2 has its own copies of fields named  and.
Figure|fl4_0_l|provides a conceptual view of point objects  and 2.
Double-precision floating-point numbers on most systems require eight bytes of memory.
Since each Point object stores two doubles, a Poi nt object uses at least 16 bytes of memory.
In practice, an object may be slightly bigger than the sum its individual components because most computer architectures restrict.
This means some objects include a few extra bytes for "padding_0_" We can use the si zeof operator to determine the exact number of bytes an object occupies.
Under Visual Cplus_plus, the expression si zeof  evaluates to 16.
A client may use the dot (_0_) operator with an object to access one of the object's members.
The dot operator is a binary operator; its left operand is an expression representing a class instance (object), and its right operand is the name of a member of the class.
The assignment statement in Listing [l4_0_1| (mathpoints_0_cpp) = 2; and the statements that follow demonstrate that we may assign one object to another directly without the need to copy each individual member of the object.
The above assignment statement accomplishes the following: = 2_0_; // No need to assignment this way; = 2_0_; // direct object assignment does this As another example, suppose we wish to implement a simple bank account object.
We determine that the necessary information for each account consists of a name, ID number, and a balance (amount of money in the account).
We can define our bank account class as.
We can define a  that holds instances of our Account class as easily as.
This shows that objects can contain other objects and implies that our objects can have arbitrarily complex structures.
A sample run of Listing ;14_0_2[ (bankaccount_0_cpp) prints.
Enter , account number, and account : Sheri 34 100_0_34 [A]dd [Njame [I]D [Bjalance []==> a Enter , account number, and account : Mary 10 1323_0_00 [Ajdd [Njame [I]D [Bjalance []==> a Enter , account number, and account : Larry 88 55_0_05 [Ajdd [Njame [I]D [Bjalance []==> a Enter , account number, and account : Terry 33 423_0_50 [Ajdd [Njame [I]D [Bjalance []==> a Enter , account number, and account : Gary 11 7_0_27.
The program allows users to sort the bank account database in several different ways using different com¬ parison functions.
Notice that the less_than_by_name and similar comparison functions use const reference parameters for efficiency (see Section  I 1_0_1_0_4:).
Observe that the add_account function has a local variable named name.
All  objects have a field named name.
The add_account function uses the name identifier in both ways without a problem.
The compiler can distinguish between the two uses of the identifier because one is qualified with an object variable before the dot (_0_) operator and the other is not; that is, acct.
Despite their similar names, the data to which acct.
The classes we have developed so far.
Pen nt and Account, have been passive entities that have no builtin functionality.
In addition to defining the structure of the data for its objects, a class can define functions that operate on behalf of its objects.
Recall the bank account class, Account, from Section fT4L2[.
We need to be able to protect the internal details of our bank account objects and yet permit clients to interact with them in a well-defined, controlled manner.
Consider a non-programming example.
If 1 deposit $1,000_0_00 dollars into a bank, the bank then has custody of my money.
It is still my money, so I theoretically can reclaim it at any time.
The bank stores money in its safe, and my money is in the safe as well.
Suppose I wish to withdraw $100 dollars from my account.
Since I have $1,000 total in my account, the transaction should be no problem.
What is wrong with the following scenario: 1.
Enter the bank.
Leave the bank.
This is not the process a normal bank uses to handle withdrawals.
In a perfect world where everyone is honest and makes no mistakes, all is well.
In reality, many customers might be dishonest and intentionally take more money than they report.
Even though I faithfully counted out my funds, perhaps some of the bills were stuck to each other and I made an honest mistake by picking up six $20 bills instead of five.
If I place the bills in my wallet with other money already there, I may never detect the error.
Clearly a bank needs a more controlled procedure for handling customer withdrawals.
When working with programming objects, in many situations it is better to restrict client access to the internals of an object.
Client code should not be able to change directly bank account objects for various reasons, including:.
A withdrawal should not exceed the account.
Federal laws dictate that deposits above a certain amount should be reported to certain government agencies, so a bank would not want customers to be able to add funds to an account in a way to circumvent this process.
An account number should never change for a given account for the life of that account.
How do we protect the internal details of our bank account objects and yet permit clients to interact with them in a well-defined, controlled manner.
The trick is to hide completely from clients the object's fields and provide special functions called member functions or methods that have access to the hidden fields.
These methods provide the only means available to clients of changing the object's internal state.
In the following revised Account class:.
Because any parts of a class not explicitly labeled are implicitly private, the private label is not necessary if you place all the private members in the first unlabeled section of the class.
Said another way, all members of a class are automatically private unless otherwise labeled.
Some programmers like to put the public members before the private members within a class definition, as in class Account { public :.
In this case the pri vate label is necessary.
In order to enforce the spirit of the wi thd raw function, we will make it a method, and add a deposi t method to put funds into an account.
Listing [14T3| | (newaccount_0_cpp) enhances the Account class with.
A method  looks like a function , but it appears within a class Because of this, a method is also known as a member function.
A client accesses a method with the dot (_0_) operator:.
The withdraw method  uses three variables: amt, result, and.
The variables amt and result are local to withdraw—amt is the method's parameter, and result is declared within the body of wi thd raw.
It is the field declared in the private section of the class.
The wi thd raw method affects the  field of the object upon which it is called: // Affects the  field of acctl object.
When you see a variable used within the code of a method , it can be one of several kinds of variables.
The compiler establishes the exact nature of the variable in the following order: 1.
Method parameter—If the variable is declared in the method's parameter list, it is a parameter to the method.
As in the case of free functions, a method parameter is a variable local to that method.
Local variable—If the variable is declared in the body of the method, the variable is local to the method.
Do anything you please with the local variable, and it will not affect any variables outside of that function.
Instance variable—If the variable is not a parameter to the method, is not declared within the method body, but is declared as an instance variable within the class, it is an instance variable of the object the client used to invoke the method.
Global variable—If the variable is not a parameter to the method, is not declared within the method body, and is not declared as an instance variable within the class, it must be a global variable.
If no such global variable exists, the variable is undeclared, and the compiler will report the error.
It is important to note that the compiler checks in this order.
That means it is legal to give a parameter to a method or a local variable the same name as an instance variable within the class.
In this case the method's code cannot access the instance variable or global variable by using its simple name.
We say the local variables hide the instance or global variables from view.
Section [753]shows how we can gain access to these hidden variables.
Methods may be overloaded just like global functions (see Section |10_0_3|.
This means multiple methods in the same class may have the same names, but their signatures must be different.
Recall that a function's signature consists of its name and parameter types; a method's signature too consists of its name and parameter types.
We saw in Section 14_0_2 that each object provides storage space for its own data fields.
An object does not require any space for its methods.
This means the only things about an individual object that an executing program must maintain are the object's fields.
While the exact organization of memory varies among operating systems, all the data processed by a program appears in one of three sections: stack, heap, or static memory.
As with simple data types like i nts, the fields of an object declared local to a function or method reside in the segment of memory known as the stack.
Also like simple data types, the fields of an object allocated with the new  appear on the heap.
The fields in global and stati c local objects reside in the static section of the executing program's memory.
For this code we see that each Counter object will store a single integer value (its  field).
Under Visual Cplus_plus sizeof Counter is the same as sizeof int — that is, four.
A local Counter object consumes four bytes of stack space, a global Counter object uses four bytes of static memory, and a dynamically-allocated Counter object uses four bytes of heap space.
In addition to static, stack, and heap memory used for data, executing programs reserve a section of memory known as the code segment which stores the machine language for all the program's functions and methods.
The compiler translates methods into machine language as it does regular functions.
Inter¬ nally, the method i nc in the Counter class is identified by a longer name.
Counter : : i nc.
Although Counter : : i nc is a method, in the compiled code it works exactly like a normal function unrelated to any class.
In the client code Counter Ctrl, ctr2; // Declare a couple of Counter objects.
Since all Counter objects share the same reset method, how does each call to Counter : : clear reset the field of the proper Counter object.
The trick is this: While it appears that the reset method of the Counter class accepts no parameters, it actually receives a secret parameter that corresponds to the address of the object on left side of the dot.
The code within the method can influence the field of the correct object via the.
One crucial piece still is missing.
How can we make sure the fields of an object have reasonable initial values before a client begins using the object.
A class may define a constructor that ensures an object will begin in a well-defined sate.
A constructor  looks similar to a method.
The code within a constructor executes on behalf of an object when a client creates the object.
For some classes, the client can provide information for the constructor to use when initializing the object.
As with functions and methods, class constructors may be overloaded.
Listing )14_0_4j(bankaccountmethods_0_cpp) exercises an enhanced Account class that offers deposi t and wi thd raw methods, as well as a constructor.
A constructor has no return type, not even void.
The constructor in Listing[ T4_0_4] (bankaccountmethods_0_cpp) initializes all the fields with values supplied by the client.
The comma-separated list between the colon and the curly brace that begins the body of the constructor is called the constructor initialization list.
An initialization list contains the name of each field with its initial value in parentheses.
All of the fields that make up an object must be initialized before the body of the constructor executes.
In this case the code within the constructor adjusts the  to zero and issues a warning if a client attempts to create an account with an initial negative.
The wi thdraw method ensures that, once created, an Account object's  will never be negative.
Notice that the client provides the required constructor parameters at the point of the object's declaration: // Client creating two Account objects.
Account acct3; // Illegal, must supply arguments for constructor.
The details of depositing and withdrawing funds are the responsibility of the object itself, not the client code.
The attempt to withdraw the $2,000 dollars above would not change the account's , and the client can check the return value of wi thd raw to provide appropriate feedback to the user about the error.
The program then could take steps to correct the situation.
A constructor that specifies no parameters is called a default constructor.
If the programmer does not specify any constructor for a class, the compiler will provide a default constructor that does nothing.
If the programmer defines any constructor for a class, the compiler will not generate a default constructor.
See Section|T5_0_2|for the consequences of this constructor policy.
If you do not define a constructor for your class, the compiler automatically will create one for you—a default constructor that accepts no parameters.
The compiler-generated constructor does not do anything to affect the state of newly created instances.
Cplus_plus's class feature allows us to define our own complete types.
We will define a new  type that models mathematical rational numbers.
In mathematics, a rational number is defined as the ratio of two integers, where the second integer must be nonzero.
Commonly called a fraction, a rational number's two integer components are called numerator and denominator.
Rational numbers possess certain properties; for example, two fractions can have different numerators and denominators but still be considered equal ( = |).
Listing 14_0_5 (simplerational_0_cpp) shows how we can define and use rational numbers.
The SimpleRational class defines a new  type that Cplus_plus does not natively provide—the rational number type.
One constructor accepts the numerator and denominator values from the client.
The other constructor allows a client to declare a Si mpleRati onal object as SimpleRational frac;.
Both constructors ensure that a Si mpleRati onal object's denominator will not be zero.
It is a free function, not a method (or member function) of the Si mpleRati onal class.
The function's return statement requires special attention.
Because of the function's declaration the compiler knows the function returns a Si mpleRati onal object.
The expression within curly braces after the retu rn keyword:.
The retu r n statement therefore creates a fraction object with a numerator that is the product of the numerators of the objects supplied by the caller.
Similarly, the denominator of the returned object is the product of the denominators of the function's parameters.
We can use this curly brace initialization syntax when passing parameters to functions; for example, we.
The compiler knows that print_fraction accepts a single SimpleRational object as a parameter.
The compiler generates code that uses the caller's curly brace initialization list to create a Si mpleRati onal object to pass to the function.
Our new  type certainly leaves a lot to be desired.
We cannot display one of our rational number objects with std : :  very conveniently.
We cannot use the standard arithmetic operators like + or *, and we cannot compare two rational numbers  == or <.
In Section )16_0_1 | we address these shortcomings.
It is all too easy for a careless, confused, or inept programmer to change an object's state in such a way as to corrupt the behavior of the entire system.
A malicious programmer may intentionally tweak one or more objects to sabotage the system.
In either case, if the software system controls a medical device or military missile system, the results can be deadly.
Cplus_plus provides several ways to protect the internals of an object from the outside world, but the simplest strategy is the one we have been : We can qualify fields and methods, genetically referred to as class members, as either publi c or pri vate.
The compiler enforces the inaccessibility of private members.
In Listing [14_0_5|| (simplerational_0_cpp), for example, client code cannot directly modify the denomi nator instance variable of a Si mpleRati onal object making it zero.
A client may influence the values of numerator and denomi nator only via methods provided by the class designer.
Accessibility rules, also called visibility rules or permissions, determine what parts of a class and/or object are accessible to the outside world.
Cplus_plus provides a great deal of flexibility in assigning access permissions, but some general principles exist that, if followed, foster programs that are easier to build and extend.
In general, fields should be p r i vate.
Clients should not be able to arbitrarily change the state of an object.
Allowing such might allow client code to put an object into an undefined state (for example, changing the denominator of a fraction to zero).
An object's state should only change as a result of calling the object's methods.
The built-in primitive types like i nt and double offer no protection from client access.
One ex¬ ception to the private fields rule applies to simple objects that programmers naturally would treat as primitive types.
Recall the geometric Poi nt class found in Listing 14_0_1 (mathpoints_0_cpp).
The x and y fields of a point object safely may assume any legitimate floating-point value, and it may be reasonable in some applications for clients to treat a Poi nt object as a primitive type.
In this case it is appropriate to make the x and y fields public.
Methods that provide a service to client code should be part of the publi c section of the class.
For example, consider the following method:.
Methods that assist the service methods but that are not meant to be used by the outside world should be in the pri vate section of the class.
This allows a publi c method to be decomposed into sim¬ pler, perhaps more coherent activities without the threat of client code accessing these more primitive methods.
These private methods are sometimes called helper methods or auxiliary methods.
Why would a programmer intentionally choose to limit access to parts of an object.
Restricting access obviously limits the client's control over the objects it creates.
While this may appear to be a disadvantage at first glance, this access restriction actually provides a number of advantages:.
Flexibility in implementation.
A class conceptually consists of two parts: - The class interface—the visible part.
Clients see and can use the public parts of an object.
The public methods and public variables of a class constitute the interface of the class.
A class's interface specifies what it does.
Clients cannot see any private methods or pri¬ vate variables.
Since this private information is invisible to clients, class developers are free to do whatever they want with the private parts of the class.
A class's implementation specifies how it accomplishes what it needs to do.
We would like our objects to be black boxes: clients shouldn't need to know how the objects work but merely rely on what objects can do.
Many real-world objects follow this design philosophy.
Consider a digital wristwatch.
Its display gives its user the current time and date.
It can produce different output in different modes; for examples, elapsed time in stopwatch mode or wake up time in alarm mode.
It presents to its user only a few buttons for changing modes, starting and stopping stopwatches, and setting the time.
How it does what is does is irrelevant to most users; most users are concerned with what it does.
Its user risks great peril by opening the watch and looking at its intricate internal details.
The user is meant to interact with the watch only through its interface—the display and buttons.
Similarly, an automobile presents an accelerator pedal to its user.
The user knows that pushing the pedal makes the car go faster.
That the pedal is connected to the fuel injection system (and possibly other systems, like cruise control) through a cable, wire, or other type of linkage is of concern only to the automotive designer or mechanic.
Most drivers prefer to be oblivious to the under-the-hood details.
Changing the interface of a class can disturb client code that already has been written to use ob¬ jects of that class.
For example, what if the maintainers of the Si mpleRati onal class decide that S i mp 1 e Ra t i o n a 1 objects should be immutable; that is, after a client creates a S i mp le Ra t i o n a 1 object the client cannot adjust the numerator or denomi nator values.
The set_numerator and set_denomi nator, therefore, would have to disappear.
Unfortunately, both of these methods are public and thus part of Si mpleRati onal's interface to client.
Existing client code may be these methods, and removing them, making them private, altering the types of their parameters or any other changes to the interface would render existing client code incompatible.
Client code that has been written to use set_numerator according to its original interface no longer will be correct.
We say the change in Si mpleRati onal's interface breaks the client code.
Class  have no flexibility to alter the interface of a class once the class has been released for clients to use; any changes risk breaking existing client code.
On the other hand, altering the private information in a class will not break existing client code that uses that class, since private class information is invisible to clients.
When the private parts of a class change, clients need only recompile their code; client programmers do not need to modify their source code.
A class, therefore, becomes less resilient to change as more of its components become exposed to clients.
To make classes as flexible as possible, which means maximizing the ability to make improvements to the class in the future, hide as much information as possible from clients.
Reducing programming errors.
Client code cannot misuse the parts of a class that are private since the client cannot see the private parts of a class.
Properly restricting client access can make it impossible for client code to put an object into an ill-defined state.
In fact, if a client can coax an object into an illegal state via the class interface, then the design and/or implementation of the class is faulty.
As an example, if a client can somehow make a Si mpleRati onal object's zero, then one of the methods or a constructor must contain a logic error.
Clients should never be able to place an object into an illegal state.
Objects can provide a great deal of functionality.
Even though a class may provide a fairly simple interface to clients, the services it provides may require a significant amount of complex code to accomplish their tasks.
One of the challenges of software development is dealing with the often overwhelming complexity of the task.
It is difficult, if not impossible, for one programmer to be able to comprehend at one time all the de¬ tails of a large software system.
Classes with well-designed interfaces and hidden implementations provide a means to reduce this complexity.
Since private components of a class are hidden, their de¬ tails cannot contribute to the complexity the client programmer must manage.
The client programmer needs not be concerned with exactly how an object works, but the details that make the object work are present nonetheless.
The trick is exposing details only when necessary: - Class.
The class  must be concerned with the hidden implementation details of the class.
Since objects of the class may be used in many different contexts, the class usually does not have to worry about the context in which the class will be used.
From the perspective of the class , the complexity of the client code that may use the class is therefore eliminated.
The developer of the client code must be concerned with the details of the application code being developed.
The application code will use objects.
The hidden details of the class these objects represent are of no concern to the client developers.
From the perspective of the client code , therefore, the complexity of the code that makes the objects work is eliminated.
This concept of information hiding is called encapsulation.
Details are exposed to particular parties only when appropriate.
In sum, the proper use of encapsulation results in.
Finally, the Cplus_plus encapsulation model has its limits.
It is not possible to protect an object from code within itself.
Any method within a class has full access to any member defined within that class.
If you believe that parts of a class should be protected from some of its methods, you should split up the class into multiple classes with suitable restrictions among the resulting component classes.
Given the definition of the geometric Poi nt class in Listing 15_0_6 (point_0_cpp), complete the function.
May a class constructor be overloaded.
Given the definition of the Si mpleRati onal number class in Section 14_0_3, complete the following free function named reduce:.
What are the minimum and maximum values allowed for the y coordinate.
Develop a Circle class that, like the Rectangle class above, provides methods to compute perimeter and area.
The Rectangle instance variables are not appropriate for circles; specifi¬ cally, circles do have corners, and there is no need to specify a width and height.
A center point and a radius more naturally describe a circle.
Build your Circle class appropriately.
Given the Rectangle and Ci rcle classes from questions above, write an encloses function:.
Ifcircis too big, the function returns false.
The positions of rect and ci rc do not influence the result.
Consider the following Cplus_plus code:.
In Chapter [l4]we introduced the basics of object-oriented programming: private data, public methods, and.
At this point the program has two copies of the fraction 3/4; the client has a 3/4 rational  in its variable my_ rati onal, and the executing pri nt_functi on has a 3/4 rational  in its formal parameter f.
When the print_fraction function finishes executing, the formal parameter f goes out of scope and its memory is freed.
The function returns back to the caller, leaving the caller's 3/4 rational  as the sole remaining one.
Even though  mpleRati onal objects are relatively small (four bytes under Visual Cplus_plus), this pro¬ cess of creating a new  serving as the formal parameter, copying the contents from the actual param¬ eter into the formal parameter, and finally cleaning up the formal parameter is all unnecessary work on the part of the executing program.
Pass by reference sends a single memory address to the function.
There is no need to copy the 's data into the function.
Safety of pass by : The function cannot modify the caller's actual parameter since the formal parameter is declared const.
If passing  types by const reference for  types is the better approach why does Cplus_plus not do this automatically for us.
Cplus_plus defaults to pass by  as the default.
This guarantees safety for all types at the expense of reduced efficiency for some types.
When is pass by  warranted for  types.
A caller may make an  and then pass a copy of the  to a function that would modify that  and return the modified  back to the caller.
The caller then could have both the original  plus the modified  returned by the function.
Doing this via passing by const reference is possible, but requires a little more code.
The following sample code illustrates:.
A caller could use the zerol and zero2 functions as shown here:.
Given the Poi nt class from Section 14_0_2 the statement Point pt; declares the variable pt to be a Poi nt.
As with primitive data, we can declare pointers to objects:.
Before we use the pointer we must initialize it to point to a valid.
We can assign the pointer to refer to an existing , as in = &pt; or use the   to dynamically allocate an  from the heap: =  ; If the class has a constructor that accepts parameters, we need to provide the appropriate arguments when.
As in the Poi nt class example, we can assign the pointer to refer to an existing , as in = &acct; or use the   to dynamically allocate an  from the heap: =   ("Moe" , 400, 1300_0_00); Note that we include the arguments expected by the  class constructor.
This statement allocates memory for one   and executes the constructor's code to initialize the newly created.
Figure [15_0_1 [ illustrates a pointer to an account.
As with any dynamically allocated entity, a programmer must be careful to use the delete  to deallocate any objects created via.
The dot  syntax to access a field of a  through a pointer is a bit awkward:.
Without the parentheses, the statement would be evaluated as if the parentheses were placed as shown here.
Cplus_plus provides a simpler syntax to access fields of an through a pointer.
The pointer  eliminates the need for the parentheses: * =  ; = 253_0_7; = -00_0_5; The pair of symbols arrow_operator constitute one  (no space in between is allowed), and the  is meant to look like an arrow pointing right.
There is no associated left pointing arrow in Cplus_plus.
You can use the arrow_operator  to access the methods of an  referenced by a pointer:.
The delete  with no [] decoration frees up a single dynamically allocated object: //  points to an  object previously allocated // via.
Here, acct_pt r is a  variable, so it occupies space on the stack.
The space for the  variable is automatically deallocated when faulty_func completes.
The problem is  points to memory that was allocated with ,  this memory is not freed up within the function.
The pointer  is the only way to get to that memory, so when the function is finished, that memory is lost for the life of the program.
The condition is known as a memory leak.
If the program runs to completion quickly, the leak may go undetected.
In a longer running program such as a web server, memory leaks can cause the program to crash after a period of time.
The problem arises when code that leaks memory is executed repeatedly  eventually all of available memory becomes used up.
The corrected function would be written void corrected_func() {.
Cplus_plus supports vectors  arrays of objects, but they present special challenges.
First, consider a simple.
No special initializations are needed since  has no constructor.
What if a class defines a constructor that accepts arguments  does not supply also a constructor that requires no arguments.
The following statement is illegal:.
When creating the space for the accts elements, Cplus_plus expects a default constructor  properly initialize all of the 's elements.
The only constructor in the  class requires arguments,  so the compiler refuses  accept the declaration of accts.
The compiler has no means by which it can produce the code needed  initialize the 's elements before the programmer begins using the.
One solution uses a  of pointers, as in std::< *> accts(100); // A  of account pointers Note that this does not create any  objects.
The programmer subsequently must iterate through the   use   create individually each  element.
Within a method dehnition a programmer may access this secret parameter via the reserved word this.
In the set_x method the parameter x has the same name as field x.
This is legal in Cplus_plus; a method parameter or local variable of a method may have the same name as a field within that class.
The problem is that the local variable or parameter hides the access  the field.
Any unqualified use of the name x refers the parameter x, not the field x.
One solution would be  name the parameter something else: perhaps _x or x_param.
A strong argument can be made, though, that x is the best name for the field, and x is also the best name for the parameter  the set_x method.
To get access  the field in this case, use the thi s pointer.
Since thi s is a reserved word, the expression thi sarrow_operatorx cannot be mistaken for anything other than the x field of the object upon which the method was invoked.
Another use of the this pointer involves passing the current object off  another function or method.
Remember the syntax of pointers: If thi s is a pointer, *thi s is the object which this points.
Since thi s serves as an implicit parameter passed  methods, it is illegal  use the this expression outside of the body of a method.
This behavior is desirable, since the set_numerator method can change the state of aSi mpleRati onal object, and our tract object is supposed  be constant.
Unfortunately, this correct behavior is accidental.
The compiler does not analyze our methods  determine exactly what they do.
Consider the following code that also will not compile:.
Since the get_numerator method does not modify a Si mpleRati onal object, we would expect that invoking it on a constant object should be acceptable, but the compiler rejects it.
Again, the compiler cannot understand what get_numerator is supposed to do; specifically, it is not designed to be able to determine that a method will not change the state of an object.
The programmer must supply some additional information to help the compiler.
If a method is not supposed to change the state of an object, that method should be declared const.
In the Si mpleRati onal class, the methods get_numerator and get_denomi nator simply return, respectively, copies of the fraction's  and denominator.
Neither method is intended to modify any instance variables.
If we look at the code for those methods, we see that indeed neither method changes anything about a Si mpleRati onal object.
What if the programmer made a mistake—perhaps a spurious copy and paste error—and the statement = 0;.
Unfortunately, the way things stand now, the compiler cannot detect this error, and get_numerator will contain a serious logic error.
We can remove the possibility of such an error by declaring get_numerator (and get_denomi nator) const:.
The const keyword goes after the closing parenthesis of the parameter list and before the opening curly.
Declaring a method  is not merely a good defensive programming strategy used by a class developer.
Methods declared to be  can be called with  objects, while it is illegal to in¬ voke a non- method with a  object.
With the new  version of Si mpleRati onal's get_numerator method, the following code.
You should declare  any method that has no need to change any field within the object.
Similarly, do not declare  any method that is supposed to change a field in an object.
A  method can be used with both  and non- objects, but a non- method cannot be used with objects.
For maximum flexibility, always declare a method to be  unless doing so would prevent the method from doing what it is supposed to do.
You can invoke a  method from both  and non- objects, but you cannot invoke a non- method from a  object.
For maximum flexibility, always declare a method to be  unless doing so would prevent the method from doing what it is supposed to do.
We would ffinclude the _0_h header file in all source files that need to use MyClass objects; the myclass_0_cpp file is compiled separately and linked into the rest of the project's _0_cpp files.
The class name prefix such as Poi nt : : is necessary not only so the compiler can distinguish a method definition such as get_x from a global function definition, but also to distinguish the method from a method with the same name and parameter types that might appear in a different class.
A method signature for a method is just like a global function signature, except a method signature includes the class name as well.
Each of the following represent distinct signatures:.
Poi nt: : get_x () is the signature for a method of the Poi nt class named get_x () that accepts no parameters.
If the class is meant to be used in multiple programs, the compiler must recompile the methods each time the header file is #included by some Cplus_plus source file.
When the method declarations and definitions are separate, the compiler can compile the code for the definitions once, and the linker can combine this compiled code with the client code that uses it.
Client programmers can look at the contents of header files.
If method definitions are Mined, client programmers can see exactly how the methods work.
This can be a disadvantage; for example, a client programmer may make assumptions about how fast a method takes to execute or the particular order in which a method processes data in a vector.
These assumptions can influence how the client code calls the method.
If the class maintainer changes the implementation of the method, the client.
A certain ordering of the data that before the change resulted in faster processing may now be slower.
An improvement in a graphics processing algorithm may cause an animation to run too quickly when the method is rewritten.
For the class designer's maximum flexibility, client programmers should not be able to see the details of a method's implementation because then they cannot form such assumptions.
Client programmers need to know what the method does, not how it accomplishes it.
To enforce this hidden method implementation: 1.
Separate the method declarations from their definitions.
Put the class declaration in the header file and the method definitions in a.
Compile the _0_cpp file into an object file.
The client code can now be compiled by including the.
Some programmers find the inline style difficult since it provides too much detail.
It complicates determining what objects of the class are supposed to do because the how is sprinkled throughout the class declaration.
The code within Listing 15_0_8 (trafficlight_0_cpp) must #i nclude the trafficlight_0_h header so the compiler is exposed to the Trafficlight class declaration; otherwise, when compiling trafficlight_0_cpp the compiler would not know if the method implementations faithfully agreed with declarations.
If the method definition of TrafficLi ght: : change in trafficlight_0_cpp specified parameters but its declaration within trafficlight_0_h did not, that would be a problem.
Furthermore, without including trafficlight_0_h, the type SignalColor would be an undefined type within trafficlight_0_cpp.
Notice that outside the class declaration in Listing T5T7] (trafficlight_0_h) we must prefix the method names with TrafficLi ght : :.
Without this prefix the compiler would treat the identifiers as globals.
It would interpret them as free functions, not methods.
Si gnalColor is declared outside of the TrafficLi ght class, so it does not need the TrafficLight: : prefix.
SignalColor is a global type available to any code that #i ncludes trafficlight_0_h.
Observe that the  variable within the Trafficli ght class is private.
That means that once the client creates a traffic light object the only way a client can influence the value of  is via the change method.
This makes it impossible for a client to force a traffic light object to cycle incorrectly; for example, a client cannot make a traffic light change directly from yellow to green (it would have to pass through red on the way from yellow to green).
The code within the following function definition violates the one definition mle: int sum_and_display (const std::< nt>& list) { int  = 0,  = list_0_sizeQ;.
The first appearance denotes the local variable named si ze, and the second use is a call to the si ze method of the std : :  class.
This statement defines (declares) only the variable ; the  method already has been defined in the std : :  class (and the compiler processed its definition from the <> header file).
The variable  has two distinct definitions in the same context, so its redeclaration right before the display code is an error.
Like a variable, a class may have only one definition.
When we build general purpose classes meant to be used widely in our programs we must take care that we do not violate the one definition mle.
In fact, we can violate the one definition rule accidentally even if we define a class only once.
To see how we can accidentally violate the one definition rule, consider the following simple example.
Suppose we have a simple counter class declared in count_0_h: class Counter { int count;.
Similarly, the _0_h header must be included in gadget_0_h in order for the compiler to accept Gadget' declaration of its ti cker field.
Client code that wishes to use Wi dget objects must use the appropriate # nclude statement:.
Both of these client programs will build without any problems.
Sometimes, however, a program may need to use both Wi dget objects and Gadget objects.
Since the widget_0_h header file does not know anything about the Gadget class and the gadget_0_h header file has no information about Wi dgets, we must include both header files in code that uses both classes.
The appropriate include directives would be.
Including one of the header files without the other is insufficient since the compiler must be able to check if the client is using both types correctly.
This client code, however, will not compile.
In this case the problem is with _0_h.
Including both widget_0_h and gadget_0_h includes the definition of the Counter class twice, so the compiler sees two definitions of Counter.
Even though the two definitions are identical, this violates the one definition rule and so results in a compiler error.
The issue here is known as multiple inclusion, and it can arise when header files # nclude other header files.
Multiple inclusion is a problem, but it often is necessary because the programmer may have a legitimate need for both types of objects within the same program.
Fortunately, the solution is simple.
The standard way to prevent multiple inclusion is to wrap a class definition as follows: ttifndef COUNT_H_.
Do not use semicolons at the end of the lines beginning with # fndef, ttdefine, and #endi f because these are preprocessor directives, not Cplus_plus statements.
The word following the # fndef and #define preprocessor directives can be any valid identifier, but best practice produces a unique word tied to the name of the header file in which it appears.
The convention is to use all capital letters and underscores as shown above (an identifier cannot contain a dot).
Putting an underscore after the header file name further makes it less likely that name will be used elsewhere within the program.
If the header file is named myheader_0_h, the preprocessor wrapper would be #ifndef MYHEADER_H_ ttdefine MYHEADER_H_ /* Declare your classes here */ #endif Like a Cplus_plus program, the preprocessor can maintain a collection of variables.
These preprocessor-defined variables can influence the compilation process.
Preprocessor-defined variables are merely an artifact of compilation and are unavailable to an executing Cplus_plus program.
The preprocessor directive # fndef eval¬ uates to true if the preprocessor has not seen the definition of a given preprocessor variable; # fndef returns false if it has seen the definition of the preprocessor variable.
The #define directive defines a pre¬ processor variable.
The net effect of the #i fndef/#define/#endf f directives is that the preprocessor will not include the header file more than once when it is processing a Cplus_plus source file.
This means the compiler will see the class definition exactly once, thus satisfying the one definition rule.
The #i f ndef_0__0__0_#define_0__0__0_#endi f preprocessor directives should be used to wrap the class declara¬ tion in the header file and do not appear in the.
Since you cannot always predict how widespread the use of a class will become, it is good practice to use this prepro¬ cessor trick for all general purpose classes you create.
By doing so you will avoid the problem of multiple inclusion.
Point result; result.
It often is convenient to overload the output stream <<  for custom classes.
The std : : cout object (and, therefore, the std: :ostream class) has overloaded methods named << that allow us to print the primitive types like integers and floating-point numbers.
If we create a new , such as Poi nt or Rati onal, the std : : ostream class has no <<method built in to handle objects of our new.
In order to use std : : cout's <<  with programmer-defined objects we must define a global  function of the form: std::ostream& << (std::ostream& os, const X& ) where X represents a programmer-defined.
Notice that the function returns  std : : ostream&.
This is because the first parameter is also an std : : ost ream&, and the function returns the same object that was passed into it.
If  is a programmer-defined , the expression << (std::cout, ) thus evaluates to a reference to std : : cout.
This process of returning the object that was passed allows us to chain together the < < , as in std::cout <<  <<  << '\n' ;.
Given the above definitions of + and <<, clients can write code such as Point my_point(l, 2), your_point(0_0_45, 0); std::cout << "Point 1: " << my_point << '\n' ; std::cout << "Point 2: " << my_point << '\n' ; std::cout << my_point << " + " << your_point << " = " << my_point + your_point << '\n' ;.
When class developers provide such an << function, clients can print out objects just as easily as printing the basic data types.
The <<  is not overloaded for the std : :  class, but we now easily can do it ourselves.
A class may define  methods.
A method for a unary  accepts no parameters, and a method for a binary  accepts only one parameter.
The "missing" parameter is the object upon which the is applied; that is, the this pointer.
To see how  methods work, consider an enhanced rational class: class EnhancedRational { int numerator; int denominator; public :.
In the Rational class, for example, it is impossible to enable the binary +  to have a higher precedence than the binary * in the context of Rati onal objects or any other classes of objects.
Variables declared in a class declaration are known as instance variables because each instance (object) of that class maintains its own copy of the variables.
This means, for example, that changing the numerator of one Rational object will not affect the numerator of any other Rational object.
Sometimes it is convenient to have variables or constants that all objects of a class share.
Global variables and constants certainly will work, but globals are not tied to any particular class.
Cplus_plus uses the stati c keyword within a class to specify that all objects of that class share a field; for example.
One unusual thing about static fields is that must be defined outside of the class declaration.
For the Wi dget class above, we must supply the statement.
Consider a  factory in which each  object must have a unique serial number.
Serial numbers are sequential, and a new  object's serial number is one larger than the  produced immediately before.
Important for warranty claims, a client should not be able to alter a serial number of a  object.
The Widget class in Listing 15_0_10 (serialnumber_0_cpp) shows how to use a static variable to manage serial numbers for  objects.
The executing program initializes seri al_number_sou rce one time at the beginning of the program's execution before it calls the main function.
This means seri al_number_sou rce is properly initialized to 1 before the program creates any Wi dget objects.
Each time the client creates a new  object, the constructor assigns the individual object's serial from the stati c variable.
The constructor also increments seri al_number_sou rce's , so the next object created will have a serial  one higher than the previous Wi dget.
Cplus_plus programmers often use class static fields to provide public constants available to clients.
Con¬ sider Listing |15_0_111 (trafficsignal_0_h) that models a simple traffic light a little differently from Listing |15_0_7|.
The state of a traffic light object—which of its lamps is illuminated—is determined by an integer : 0 represents red , 1 stands for green , and 2 means yellow.
It is much more convenient for clients to use the symbolic constants RED, GREEN, and YELLOW than to try to remember which integer values stand for which colors.
These constants are publi c, so clients can freely access them, but, since they are constants, clients cannot alter their values.
An additional benefit to being const is this: You may initialize a stati c const field within the class body itself.
You do not need to re-define a stati c const field outside the class body as you do for a non-const stati c field.
Code outside of the TrafficSi gnal class can access the  constants because they are public but must use the fully-qualified names TrafficSi gnal: : RED, TrafficSi gnal: : GREEN, and TrafficSi gnal: :YELLOW.
This statement makes an initially yellow traffic light.
Since the RED, GREEN, and YELLOW public fields are constants, clients cannot modify them to subvert the behavior of a traffic light object.
It may not be obvious, but the  constants in the T rafficSi gnal class must be declared stati c.
Recall from Section 14_0_4 that a default.
This means the client cannot write code such.
During the object's creation the client must provide an integer argument representing a traffic light.
If RED, GREEN, and YELLOW are constant instance variables (that is, constant non-stati c fields), every TrafficSi gnalAlt object has its own copy of the fields, and the RED, GREEN, and YELLOW fields cannot exist outside of any traffic light object.
This leads to a chicken-and-egg problem—how can we create the first TrafficSi gnalAlt object using the symbolic constants RED, GREEN, or YELLOW.
These constants do not exist unless we have a traffic light object, yet we need a traffic light object to have any of these constants.
An executing program initializes stati c class fields before it invokes the mai n function.
This means any data pertaining to a class that must exist before any object of that class is created must be declared stati c.
A stati c class variable exists outside of any instance of its class.
Cplus_plus allows methods to be declared stati c.
A stati c method executes on behalf of the class, not an instance of the class.
This means that a stati c method may not access any instance variables (that is non-stati c fields) of the class, nor may they call other non-stati c methods.
Since a stati c method executes on behalf of the class, it has no access to the fields of any particular instance of that class.
That explains the restriction against static methods accessing non-static data members.
Since a nonstati c method may access instance variables of an object upon which it is called, a stati c method may not call a non-stati c method and thus indirectly have access to instance variables.
The restriction goes only one way—any class method, stati c or non-stati c, may access a stati c data member or call astatic method.
Looking at it from a different perspective, all non-stati c methods have the thi s implicit parameter.
The C language supports the struct feature, but not the class keyword.
C structs do not support methods and constructors.
In Cplus_plus (unlike in C), a struct can contain methods and constructors.
By default, members in st ructs are public, but you can apply the p ri vate and publi c labels as in a class to fine tune client access.
Despite their similarities, Cplus_plus programmers favor classes over structs for programmer-defined types with methods.
The struct construct is useful for declaring simple composite data types that are meant to be treated like primitive types.
Consider the i nt type, for example.
We can manipulate directly integers, and integers do not have methods or any hidden parts.
Likewise, a geometric point object consists of two coordinates that can assume any valid floating-point values.
It makes sense to allow client code to manipulate directly the coordinates, rather than forcing clients to use methods like set_x and set_y.
On the other hand, it is unwise to allow clients to modify directly the denominator of a Rati onal object, since a fraction with a zero denominator is undefined.
In Cplus_plus, by default everything in an object defined by a struct is accessible to clients that use that object.
In contrast, clients have no default access to the internals of an object that is an instance of a class.
The default member access for struct instances is public, and the default member access for class instances is private.
The struct feature is, in some sense, redundant.
By retaining the struct keyword, however, Cplus_plus programs can use C libraries that use C structs.
Any Cplus_plus program that expects to utilize a C library using a struct must restrict its struct definitions to the limited form supported by C.
Such struct definitions may not contain non-publi c members, methods, constructors, etc.
The private members of a  by default are inaccessible to code outside of that.
Ordinarily only methods within the  itself have permission to see and modify the private instance variables and invoke the private methods within that.
This access protection allows programmers to modify the implemen¬ tation of the hidden internals of a  without affecting existing client code that uses the.
For some  designs this all-or-nothing access dictated by the public and pri vate labels within a  or struct is too limiting.
At times it can be advantageous to design a  that grants special access to some precisely specified functions or classes of objects outside of the.
As an example, consider a variation of the Si mpleRati onal  from Listing 14_0_5 (simplerational_0_cpp).
Our new , named OpaqueRati onal is shown here:.
Gone are the set_numerator, set_denomi nator, get_numerator, and get_denomi nator methods of the Si mpleRati onal.
This would require an operator<< function overloaded to accept a OpaqueRati onal object, and this.
A  can grant access to an outside function or another  via the f ri end reserved word.
Listing 15_0_13 (printonlyrational_0_cpp) we specify a f ri end function that allows clients to display in humanreadable form an opaque rational number object via operator<< with an output stream object.
PrintOnlyRational { int numerator; int denominator; public :.
Observe that the << function is not a member function of the Pri ntOnlyRational.
Ordinarily << would be unable to access the numerator and denominator fields of a Pri ntOnlyRational object.
We can see, however, that the compiler allows theoperator<< function to access the private instance variables of its f parameter.
We chose in Listing 15_0_13 (printonlyrational_0_cpp) to implement the << function outside of.
The reserved word f ri end at the front indicates to the compiler that is it indeed a free function; Cplus_plus does not allow member functions to be declared as friends.
In Listing 15_0_14 (friendclass_0_cpp) the Gadget constructor accesses the private data element of a Wi dget object to initialize a Gadget object.
The Gadget: : compare method accesses the data of a Wi dget parameter passed to it.
Neither of these accesses would be possible if the Wi dget  did not declare Gadget to be a friend.
Note that while a Gadget object may freely access the private members of any Wi dget object, no Wi dget object has special access to any Gadget object.
Friendship is not automati¬ cally symmetric; that is, the f ri end declaration is one directional.
For the relationship to be mutual, the programmer would have to declare the Wi dget  to be a friend within the Gadget ; then objects of both classes could freely access the internal details of each other.
Note that a  grants friendship unilaterally to an outside  or function; there is no way for an.
Suppose A, B, and C are classes.
Further suppose that class B is a friend of class A and that class C is a friend of class B.
The friendship is not transitive; this means that C being a friend of B and B being a friend of A does not automatically make C a friend of A.
Cplus_plus is very strict about the friendship relationship.
The designer of class A would need to declare C as an additional friend of A.
A class may have as many friend functions and classes as needed.
Good object-oriented design avoids friends as much as possible.
Ideally, if class A grants friendship to class B, the design of classes A and B should be under the control of the same developers.
Otherwise, friendship weakens encapsulation (see Section|jl4_0_6|.
If class A grants friendship to class B and class B is not under the control of the developer of class A, one or more of the methods in class B could manipulate the internals of an object of type A and potentially place it in an ill-defined state.
The get_numerator and get_denomi nator methods eliminate the need for a friend function.
Note that a Readonly Rati onal object is subtly different from an Pri ntOnlyRati onal object.
Clients can see the numerator and denominator fields of a ReadOnlyRational object as desired, but Pri ntOnlyRati onal objects are "print only;" clients readily can print an Pri ntOnlyRati onal object but cannot easily discern the individual numerator and denomi nator values.
Both the Pri ntOnlyRati onal and Readonly Rati onal classes represent read-only fraction objects—once a client creates one these objects the client cannot change its.
In truth, the Readonly Rati onal class is more versatile, as programmers could incorporate ReadOnlyRati onal objects into an applica¬ tion that displays its output via a graphical interface.
Pri ntOnlyRati onal objects limit their access to output streams.
The Pri ntOnlyRati onal class may better serve applications that need such limited access.
Suppose Widget is a class of objects, and function proc accepts a single Widget object as a parameter.
Without knowing anything about class Widget, which of the following definitions of function proc is considered better, and why.
Suppose you have the following definition for class Gadget:.
Counter cl; const Counter c2;.
Counter cl; const Counter c2; determine if each of the following statements is legal.
Private static methods.
The algorithm for the recursive gcd (greatest common divisor) method was introduced in Sec¬ tion 10_0_5 The 1cm (least common multiple) method is derived from the mathematical relationship: gcd (m,) x lcm (m,) = m x These two methods are declared pri vate because they are not meant to be used directly by client code.
Greatest common divisor and least common multiple are concepts from number theory of which clients have no direct need.
Client code expects functionality typical of rational num¬ bers, such as addition and reduction; these two private methods are used by other, public, methods that provide functionality more closely related to rational numbers.
These two private methods are stati c methods because they do not use instance variables.
An object is not required to compute the greatest common divisor of two integers.
It is legal for gcd and 1cm to be instance methods, but instance methods should be used only where necessary, since they have the power to alter the state of an object.
Faulty coding that accidentally modifies an instance variable can be difficult to track down.
If a class method is used, however, the compiler can spot any attempt to access an instance variable immediately.
Public instance methods.
None of the instance methods (==, reduce, +, and ope rato r *) modify the state of the object upon which they are invoked.
Thus, the class still produces immutable objects.
The methods +, *, and reduce use the private helper methods to accomplish their respective tasks.
The linear search vs.
The program used the clock function.
A programmer must take care to implement the timing code correctly for each section of code to be timed.
This process is error prone: - clock_t is a specialized type that is used infrequently.
It is not obvious from its name that clock_t is equivalent to an unsigned integer, so a programmer may need to consult a library reference to ensure its proper use.
If a programmer incorrectly applies parentheses as so static_cast<double> (( - )/CLOCKS_PER_SEC).
The timing code is supplemental to the actual code that is being profiled, but it may not be imme¬ diately obvious by looking at the complete code which statements are part of the timing code and which statements are part of the code to be timed.
Section [l0_0_6j offered a solution to the above shortcomings of using the raw types, constants, and func¬ tions available from the C time library.
Unfortunately, as mentioned in Section |10_0_6| the functional approach has a serious limitation.
The code in Listing |10_0_14| (timermodule_0_cpp) uses global variables to maintain the state of the timer.
There is only one copy of each global variable.
This means pro¬ grammers using the timer functions cannot independently measure the elapsed time of overlapping events; for example, you cannot measure how long it takes for a function to execute and simultaneously measure how long a section of code within that function takes to execute.
A programmer could time multiple, simultaneous activites by using the raw C library clock function directly, but then we are back to where we began: messy, potentially error-prone code.
Objects provide a solution.
Consider the following client code that uses a stopwatch object to keep track.
This code using a Stopwatch object is as simple as the code that uses the timer functions from List¬ ing 10_0_14 (timermodule_0_cpp).
As an added benefit, a developer can think of a Stopwatch object as if it is a real physical stopwatch object: push a button to start the clock (call the start method), push a button to stop the clock (call the stop method), and then read the  time (use the result of the method).
What do you do if you need to time two different things at once.
You use two stopwatches, of course, so a programmer would declare and use two Stopwatch objects.
Since each object maintains its own instance variables, each Stopwatch object can keep track of its own  time independently of all  active Stopwatch objects.
Programmers using a Stopwatch object in their code are much less likely to make a mistake be¬ cause the details that make it work are hidden and inaccessible.
With objects we can wrap all the messy details of the  code into a convenient package.
Given our experience designing our own types though Cplus_plus classes, we now are adequately equipped to implement such a Stopwatch class.
Listing 16_0_2 (stopwatch_0_h) provides the header hie defining the structure and capabilities of our Stopwatch objects.
From this class declaration we see that when clients create a Stopwatch object a constructor is available to take care of any initialization details.
Four methods are available to clients: sta rt, stop, reset, and The reset method is included to set the clock back to zero to begin a new.
Note that the "messy" detail of the clock_t variable is private and, therefore, clients cannot see or directly affect its value within a Stopwatch object.
This Stopwatch class (Listing 16_0_2 (stopwatch_0_h)) addresses the weaknesses of the non-object-oriented approach noted above:.
The  code can be implemented in methods of the Stopwatch class.
Once the methods are correct, a programmer can use Stopwatch objects for  the execution of sections of code without worrying about the details of how the  is actually done.
Client code cannot introduce errors in the  code if the  code is hidden within the Stopwatch class.
The details of the  code no longer intertwine with the code to be timed, since the  code is located in the Stopwatch class.
This makes it easier for programmers to maintain the code they are.
The Stopwatch class provides a convenient interface for the programmer that replaces the lowerlevel details of calling system time functions.
Stops the stopwatch if it currently is , void Stopwatch::reset() { = false;.
An alternate design might print an error message and perhaps exit the program's execution if a client attempts to see the   of a  stopwatch.
Some aspects of the Stopwatch class are notable:.
Stopwatch objects use three instance variables: - The start_time instance variable records the  when the client last called the start method.
The constructor sets the initial values of the instance variables start_time, , and runni ng.
The sta rt method notes the system  after the assignment to runni ng.
If these two statements were reversed, the   would include the  to do the assignment to runni ng.
The should as closely as possible just include the statements in the client code between the start and stop method calls.
Notice that sta rt_ti me is not assigned if the stopwatch is.
In the stop method, the system  is noted before the assignment to runni ng so the does not include the assignment to runni ng.
This provides a more accurate accounting of the client code execution.
The stop method computes the accumulated.
This design allows a client to stop the stopwatch and restart it later without losing an earlier segment of.
The  method either returns the   computed by the stop method or computes the current   without altering the elapsed_ti me variable.
Clients should avoid calling when a Stopwatch object is  since doing so would interfere with the accurate of client code execution.
Stopwatch timer; // Ensure the elements are ordered low to high for (size_t  = 0;  < SIZE; iplus_plus) list[] = ; // Search for all the elements in list using linear search.
The design of the Stopwatch class allows clients to create multiple Stopwatch instances, and each instance will keep track of its own.
In practice when profiling executing programs, such generality usually is unnecessary.
Rarely do developers need to  overlapping code, so one timer  per program usually is enough.
Multiple sections of code can be checked with the same Stopwatch ; simply start it, stop it, check the , and then reset it and start it again when another section of code is to be timed.
Section 12_0_2 shows how to use function pointers to customize the ordering that selection sort performs on a vector of integers.
The selection_sort function in Listing 12_0_2 (flexibleintsort_0_cpp) accepts a function pointer parameter in addition to the vector.
The function pointer points to a function that accepts two integer parameters and returns true or false.
The function is supposed to use some kind of ordering rule to determine if its first integer parameter precedes its second integer parameter.
Suppose we wish to analyze the number of comparisons and the number of swaps the sort function performs on a given vector with a particular ordering strategy.
One way to do this is have the sort function itself keep track of the number of times it calls the comparison function and swap function and return this information when it finishes.
To do so we would have to define an  to hold the two pieces of data (comparisons and swaps) since a function can return only one value, not two.
Also if we do this, we must significantly alter the code of the sort algorithm itself.
We would prefer to keep the sort algorithm focused on its task of sorting and remain uncluttered from this additional logging code.
If instead of passing a function pointer to our sort function we pass a specially crafted.
We can design our  to do whatever we want; specifically, we can design our special  to perform the necessary comparisons and keep track of how many comparisons it performs.
We could let the  do the swap, and it could log the swaps it performs.
Notice that a Comparison object wraps a comparison function pointer, contains a swap method, and maintains two integer counters.
The comparison object passed to the sort routine customizes the sort's behavior (via its function pointer) and keeps track of the number of  and swaps it performs (via its integer counters).
As in Listing [l2_0_2| (flexibleintsort_0_cpp), the basic structure of the sorting algorithm remains the same regardless of the ordering determined by the comparison object.
We see from the results that the number of  is dictated by the algorithm itself, but the number of element swaps depends on the ordering of the elements and the nature of the comparison.
Sorting an already sorted array with selection sort does not reduce the number of  the function must perform, but, as we can see, it requires no swaps.
We can detect errors in our code as we interact with the executing program.
The process of exercising code to reveal errors or demonstrate the lack thereof is called testing.
The informal testing that we have done up to this point has been adequate, but serious software development demands a more formal approach.
As you gain more experience developing software you will realize that good testing requires the same skills and creativity as programming itself.
Until recently testing was often an afterthought.
Testing was not seen to be as glamorous as designing and coding.
Poor testing led to buggy programs that frustrated users.
Also, tests were written largely after the program's design and coding were complete.
The problem with this approach is major design flaws may not be revealed until late in the development cycle.
Changes late in the development process are invariably more expensive and difficult to deal with than changes earlier in the process.
Weaknesses in the standard approach to testing led to a new : test-driven development.
In testdriven development the testing is automated, and the design and implementation of good tests is just as important as the design and development of the actual program.
In pure TDD, developers write the tests before writing any application code and immediately test all application code they write.
A simple test object keeps track of the number of tests performed and the number of failures.
The client uses the test object to check the results of a computation against a predicted result.
Notice that the equals method, which checks for the equality of two double-precision floating-point numbers is private, as it is meant to be used internally by the other methods within the class.
The equals method works the same way as the equals function we examined in Listing 9_0_17 (floatequals_0_cpp).
The second test checks to see if our sort function will not disturb an already sorted , and we pass this test with no problem.
This is an example of coincidental correctness.
In the sum function, the programmer was careless and used 1 as the beginning index for the.
Notice that the first test does not catch the error, since the element in the zeroth position (zero) does not affect the outcome.
A tester must be creative and devious to try and force the code under test to demonstrate its errors.
In Section [13_0_5| we used some classes from the standard Cplus_plus library to generate high-quality pseudoran¬.
The Cplus_plus class construct allows us to creatively combine multiple sources of functionality into one.
The Uni formRandomGenerator class provides a simplified interface to programmers who need ac¬ cess to high-quality pseudorandom numbers.
Behind the scenes, every Uni formRandomGenerator object contains its own uni form_i nt_di stri bution object and mtl9937 object.
The constructor accepts the minimum and maximum values in the range of pseudorandom numbers desired.
The con¬ structor uses this range to construct the appropriate uni form_i nt_di stri buti on object for this range.
The constructor also initializes the mtl9937 object field.
The Uni formRandomGenerator constructor passes to the constructor of the mtl9937 class a temporary random_devi ce object.
Since a Uni formRandomGenerator object uses the random_devi ce only for creating its mtl9937 field and does not need it later.
Uni formRandomGenerator objects do not contain a random_devi ce field.
To create a Uni formRandomGenerator object that produces pseudorandom integers in the range.
The expression gen() is syntactic sugar for gen.
The expression gen.
Listing jl6_0_10| (testuniformrandom_0_cpp) is a simplified remake of Listing |13_0_11|| (highqualityrandom_0_cpp).
In Listing 16_0_10 (testuniformrandom_0_cpp) we see that with our Uni formRandomGenerator class we.
Create a large unsigned integer type named Bi gUnsi gned.
Bi gUnsi gned objects represent un¬ signed integers with arbitrary precision; that is, unlike the standard Cplus_plus unsigned integer primitive types, a Bi gUnsi gned object can represent an unsigned integer as large as necessary.
Unlike the floating-point types, a Bi gUnsi gned value retains all its digits of precision.
Internally, the Bi gUnsi gned class should hold a std : : vector of integers.
Each integer in the vector is one of 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9.
Each element in the vector represents a digit in a place value within the integer; for example, if the internal vector contains the following elements in the following order: 4,9,1,1,4,3,0,5 we would interpret the associated Bi gUnsi gned object as the mathematical nonnegative integer 49,114,305.
Your  gUnsi gned class implementation should provide the following features:.
The class should provide a constructor that accepts no arguments that initializes the  gUnsi gned object's vector to contain a single element equal to zero.
The class should provide a constructor that accepts a single unsigned integer.
This constructor should populate its internal vector with the appropriate elements to correspond to the value of its parameter.
The class should provide a constructor that accepts a  gUnsi gned argument.
Clients use this constructor to create a new  gUnsi gned object from an exiting  gUnsi gned object.
The class should provide a constructor that accepts a std : : st   ng object representing an in¬ teger.
Clients use this constructor when they need to create a large integer whose value exceeds the range of unsigned long long.
The string argument should contain only digits.
The class should provide access to a friend function named operator+ that adds two gUnsi gned objects and returns the  gUnsi gned result.
The class should provide access to a f ri end function named operator<< that allows clients to print a  gUnsi gned value as easily as a built-in integer type.
In Chapter^ we saw how it is possible to design classes from which clients can produce objects that exhibit somewhat sophisticated behavior.
We built each of the classes from scratch.
Cplus_plus provides a way to create a from an existing  by a process known as inheritance.
Through this process the new  inherits all the characteristics of the existing , and the  developer can extend and customize the inherited functionality as well as add new.
Recall from Section 13_0_3 that writing data to a file is almost as easy as printing it on the screen.
Can we easily adapt our <<  so that we can use it with std : : of stream objects as well.
The answer, perhaps surprisingly, is we do not have to adapt our << function; it works as is with std: : of stream objects.
How can this be, since the std: :  object has type std : :ostream which is not the same  as std : : of stream.
Cplus_plus allows some automatic conversions among the built in numeric types; for example, an  nt is widened to a double, and a double is truncated to an  nt.
These types are built into the language, so standard conversions apply.
When it comes to programmerdefined types, however, the compiler is unable to generate automatically code to convert from one type to another.
Most of the time it would make no sense to do so—imagine attempting to convert an object of type Stopwatch (Listing 16_0_2 (stopwatch_0_h)) to an object of type Tester (Listing 16_0_6 (tester_0_h)).
So, how is it that an object of type std: : of stream can be converted automatically to an object of type ostream.
You might think that it is because they are both part of the standard library, so the conversion has been programmed into them.
The fact is, no conversion takes place.
Any object of type std : : of st ream object is automatically treated as if it were an ostream object because the ostream and std : : of stream classes are related in a special way.
The std : : of stream  is derived from the ostream.
We say that ostream is the base  and std : : of stream is the derived.
Sometimes the term superclass is used for the base , in which case the derived  is called the subclass.
The base/derived  terminology is used interchangeably with super/subclass, although the Cplus_plus community tends to prefer the terms base/derived  to super/subclass.
The process is known as inheritance because the derived  inherits all the characteristics of its base.
The terms derivation, subclassing and specialization are sometimes used in place of the term inheritance.
As a consequence of the derivation process, an instance of the derived  can be treated as if it were an instance of the base.
Listing| [T7_0_lj |(printstreams_0_cpp) shows how a function can process instances.
This ability to allow a subclass object to be used in any context that expects a superclass object is known as the Liskov Substitution Principle, after computer scientist Barbara Liskov.
The term is a has a special meaning in the context of inheritance.
Suppose we have  B and  D derived from B.
B is the base  and D is the derived.
Since we can treat an instance of a derived as if it were an instance of its base , if we declared a D object as Dd; // d is a D object we can say d is a D (as it is declared), and we also can say d is a B.
The developers of the std: :ofstream  did not begin with a blank slate.
The ost ream  existed first, and the developers specified the std : : of stream  in such a way so any std: : of stream object would be treated as a specific kind of ost ream.
In this section we will examine a very simple example that illustrates the mechanics of  inheritance in Cplus_plus.
Even though the source code for   does not explicitly show the definition of a method named f, it has such a method that it inherits from  B.
Note that inheritiance works in one direction only.
Class  inherits method f from  B, but  B cannot inherit 's g method.
Given the definitions of classes B and  above, the following code is illegal: B myB;.
While this private inheritance is useful in rare situations, the majority of objectoriented software design uses public inheritance.
Cplus_plus is one of the few objectoriented languages that supports private inheritance.
In object-oriented design, multiple inheritance is not as common as single inheritance (one base ).
The next section provides a simple example that shows how inheritance works.
Inheritance is a design tool that allows developers to take an existing  and produce a new  that provides enhanced  or different.
The enhanced or new  does not come at the expense of existing code; that is, when using inheritance programmers do not touch any source code in the base.
Also, developers can leverage existing code (in the base ) without duplicating it in the derived classes.
We can demonstrate the use of inheritance to enhance the  of a simple.
A Text object wraps a std : : stri ng object, and, since the string object is private to the Text , clients cannot get to the string object directly.
The clients may see the string via the get method, and can modify the wrapped string only in a limited way via the append method.
Notice that the two methods, get and append, are marked vi rtual.
The vi rtual keyword indicates that the designer of this Text  intends that classes derived from Text will be able to customize the  of their get and append methods.
Observe that the declarations of the get and append methods include the override specifier.
This keyword indicates that the FancyText  overrides, or provides custom  for, the methods declared vi rtual in its base.
FancyText::FancyText (const std::string& t, const std::string& left,.
The body of the constructor is empty, so all initialization happens in the constructor initialization list.
We want to assign the constructor's first parameter, t, to the inherited member text, but text is private in the base.
This means the FancyText constructor cannot initialize it directly.
Since the constructor of its base  knows what to do with this parameter, the first expression in the constructor initialization list (the part between the : and the ):.
This base  initialization expression must be the first thing in the initialization list because Cplus_plus requires that the  of an object inherited from its base must be initialized before any new  (added by the derived ) are initialized.
The next three expressions in the initialization list: _0__0_.
The body of the constructor is empty as no other initialization work is necessary.
The FancyText  alters the way get works.
We say the FancyText  overrides its in¬ herited get method.
The keyword over ri de emphasizes the fact that the code in the get method in FancyText intends to do something differently from the code in Text's get method.
In this case the FancyText: : get method builds a string result by concatenating three other strings: the first string is a front bracketing string, the second is the wrapped string, and the third string is a trailing bracketing string.
Notice that the second string is obtained with the expression Text::get().
The member specifier p r i vate means inacces¬ sible outside of the , period.
Derived classes have no special privilege in this regard.
In order to perform the delegation we must use Text : : get () and not simply get (); the unqualified expression get ( ) is equivalent to thi sarrow_operatorget, which calls FancyText: :get.
This means invoking the unqualified get within the definition of FancyT ext : : get is a recursive call, which is not what we want.
A method declared vi rtual in a base  is automatically virtual in its derived classes.
The override keyword was added to the language in Cplus_plus11.
Prior to Cplus_plus11 when a method in a derived  had the same signature as a virtual method in its base , the method implicitly overrode its base  version.
The problem was that a programmer could intend to override a method in the derived  but get the signature wrong.
The resulting method overloaded the original method rather than overriding it.
If a programmer uses the ove r r i de specifier and uses a signature that does not match the base  version, the compiler will report an error.
The over ri de specifier provides a way for programmers to explicitly communicate their intentions.
For backwards compatibility the override keyword is optional.
Its presence enables the compiler to verify that the method is actually overriding avi rtual method in the base.
Without it, the programmer must take care to faithfully reproduce the signature of the method to override.
The over ri de keyword is a context-sensitive keyword, meaning it is a keyword.
The FancyText: : append method overrides the inherited append method by inserting a special separator string in between the existing wrapped text string and the string to append.
Like FancyText: :get, the FancyText: : append method delegates the actual concatenation operation to its base  by call¬ ing Text: : append.
Again, this is because code within the FancyText  cannot directly influence its text field.
The  FixedText, declared and defined in Listing 17_0_6 (fixedtext_0_h) and Listing 17_0_7|(fixedtext_0_cpp),.
The FixedText  is somewhat simpler than the FancyText.
It adds no fields and does not override the get method.
Its constructor accepts no parameters because clients are not permitted to deter¬ mine the contents of the wrapped string—the text field is always the word FIXED.
It inherits the text field and get method (as is) from the Text.
Notice that the assignment = 2; copied into object  only the fields that FancyText objects have in common with Text objects; that is, the text field.
Since  is a plain Text object, it does not have the left_b racket, right_bracket, and connector fields capable of storing the additional data contained in a FancyText object.
This pro¬ cess of losing derived class data when assigning to a base class instance is known as object slicing.
The parts that will not fit into the base class instance are "sliced" off.
Figure j| 17_0_1 illustrates object slicing.
Figure [T7l2| shows how such an attempted assignment would be meaningless because the base class instance has missing information needed by the derived class instance.
Failure to properly assign all.
Fi xedText class instances do not contain any additional data that plain Text instances do not have,.
It always is legal to assign a derived class instance to a variable of a base type.
This is because a derived class instance is a specific kind of base class instance.
In contrast, it is not legal to assign a base class instance to a variable of a derived type.
This is because the is a relationship is only one directional, from a derived class to its base class.
The Text, FancyText, and FixedText classes form a small class hierarchy.
We can represent the relationships in this class hierarchy in a graphical form using the Unified Modeling Language (UML).
Figure 117_0_3| shows the UML diagram for our simple Text class hierarchy.
A rectangle represents a class.
Text, the base class, appears at the top of the Figure [17_0_3} The two derived classes appear below Text.
The inheritance arrow points from the derived classes to the base class.
The arrow represents the is a relationship which flows upward.
This visual layout and level of detail provided by the UML diagram more succinctly communicates the relationships amongst the classes than does the Cplus_plus source code.
The UML is a large, complex graphical language that may be used to model many facets of the software development process.
More information about the UML is available at http : / /www _0_uml_0_org.
What is the nature of the machine code generated by the expression.
The compiler translates this higher-level expression into the machine language instmction that causes the program's execution to jump to another part of the compiled code.
Where does the program's execution jump to.
The variable 's declared type is T ext, the program's execution jumps to the compiled Text: :  method (also the address of  is passed as the implicit this parameter to the method so the compiled code can access 's text field).
When the compiler can determine which method to execute based on the declared type of an object, the process is known as static binding or early binding.
Static binding is used in all cases for non-virtual methods and in the cases we have seen so far for virtual methods.
The situation is different if we use pointers to objects instead of the objects themselves.
The variable  is a Text object, so the assignment = &; makes perfect sense.
The variable 2 has a declared type of FancyText, but a FancyText object is a Text object, so the assignment 2 = &2;.
Even though 2's declared type is "pointer to a Text object" not "pointer to a FancyText object," the expression 2 () calls FancyText: : , not Text: :.
How does the compiler determine which method to call in this case.
The answer may be surprising: The compiler does not determine which method to call.
In the case of a virtual method invoked via a pointer, the running program, not the compiler, determines exactly which code to execute.
The process is known as dynamic binding or late binding.
Static binding is relatively easy to understand: the method to execute depends on the declared type of the variable upon which the method is invoked.
The compiler keeps track of the declared type of every variable, so the choice is easy.
Inheritance and the is a relationship make things more complicated.
In the example above, 2's declared type is "pointer to Text_0_" If the compiler were given the authority to select the method to call for the expression 2 (), its only choice would be Text: : ; however, 2 actually is pointing to a FancyText object.
How does the executing program know which code to execute.
We know that every instance of a class contains its own copy of the fields declared within the class.
In reality, if a class contains at least one virtual method, all instances of that class will contain one extra "hidden" field, a pointer to an array of virtual method pointers.
This array of method pointers commonly is called the vtable.
One vtable exists for each class, but all instances of that class must store a pointer to that shared vtable.
The compiler assigns an index to each virtual method in a class.
In our example, the Text class contains two virtual methods, so the index of  might be 0, and the index of append might be 1.
Figure [IT4| illustrates a typical scenario with vtables.
In this case the compiler translates the expression () into the machine language equivalent of  arrow_operatorvtable [0] (), which invokes the correct method for the instance pointed to by.
Similarly for the append method, piarrow_operatorappend ("suffix" ) internally becomes plarrow_operatorvtable [1] ("suffix").
If  points to a Text instance, - >vtable points to the vtable array for the Text class.
If  points instead to a FancyText instance,  1 arrow_operatorvtable points to the vtable array of the FancyT ext class.
In either case the correct method is selected during the program's execution.
Such extended analysis capabilities would further complicate the compiler, and Cplus_plus compilers are al¬ ready very complicated pieces of software.
Attempting to add this ability would prove futile anyway be¬ cause the compiler cannot in general always determine which method to invoke.
To see why, consider the following code fragment:.
Figure 17_0_4 Several objects and their associated vtables.
You will not find any evidence in the Cplus_plus source code of the dashed pointers and vtables shown in this diagram.
When virtual methods are involved the compiler produces executable code that builds these hidden data structures behind the scenes.
When a client calls a virtual method via a pointer to an object, the run-time environment locates the exact method to execute by following the vtable pointer stored in the object itself.
Observe that since the  class does not override the inherited  method, its vtable references the same  code as that of 's vtable.
This code generates a pseudorandom number at run time.
If it generates an even number, it directs  to point to a plain  object; otherwise, it directs  to point to a  object.
Which method will this code call, T ext: :  or FancyT ext: :.
Since the code generates the pseudorandom number at run time, the compiler is powerless to determine the exact type of the object to which  points; thus, the compiler cannot determine which  method to call.
The compiler can, however, generate code that jumps to the method found at the address stored in 's associated vtable at the index corresponding to the method.
Listing ||17_0_9| (vtablesize_0_cpp) demonstrates that the vtable pointer does occupy space within an object.
A NoVTable object requires four bytes for its integer field, but a HasVTable object occupies eight bytes—four bytes for its integer field and four bytes for its secret vtable pointer.
Dynamic binding enables a powerful technique in object-oriented programming called polymorphism.
We know from Section[TTT||that a  is a collection of homogeneous elements.
Homogeneous means the elements in a  must all be of the same type.
Homogeneity takes on a deeper meaning when inheritance and the is a relationship is involved.
In Listing 17_0_10 (polymorphicvector_0_cpp) the declared type of the texts  is std : :  < *>.
With inheritance, not only can the texts  hold pointers to simple  objects, it also simultaneously can hold pointers to  and objects.
As we can see, the expression  () in the mai n function is polymorphic; the actual  method invoked— : : , : : , or : :  —depends on the exact type of the object to which t points.
The append method is polymorphic as well.
As t assumes the value of each element in the  during the loop's execution, the exact type of object that t points to varies.
Even though all the elements of the texts  are pointers to  objects, only one of the elements points to a pure  object; the rest of the elements point to  or Fi xedText objects.
Why must we use pointers to objects rather than the objects themselves to achieve polymorphism.
Remember that a pointer stores a memory address (see Section |T077| >.
All pointers, no matter what type they point to, are all the same  (4 bytes on 32-bit systems and 8 bytes on 64-bit systems).
If we made texts a  of  objects rather than a  of pointers to  objects, when we assign a FancyT ext object to an element in the texts , the assignment would slice the extra fields in the  object.
Pointer assignment avoids the slicing problem.
The main reason for using pointers is that Cplus_plus uses static binding for all methods (virtual and non¬ virtual) invoked on behalf of an object; the compiler chooses the method based on the declared type of the object.
In contrast, Cplus_plus uses dynamic binding for virtual method calls made via pointers to objects; the exact type of the object determines the method selection.
Derived classes override the behavior of the inherited virtual methods as needed.
From the programmer's perspective, however, the two programs are very different.
Listing [177l 3 (testalttext_0_cpp) packages within a single class all the functionality for the three different classes in Listing 177l0|(polymorphicvector_0_cpp).
This non-polymorphic code differentiates among text objects with the TextType custom enumeration type.
Note that each of the methods that were polymorphic in our earlier example now use conditional logic (a swi tch statement) to execute the code appropriate for actual kind of  object we wish to model.
This approach that avoids inheritance and polymorphism has several different issues: 1.
Every  object carries the burdens of every possible  of  object.
A plain  object holds the left bracket, right bracket and separator strings that fancy  objects require.
The amount of memory a string occupies depends on its length (number of characters it holds), but even an empty std : st r"i ng object requires some memory.
An application managing many mainly plain objects could be consuming much more memory than it otherwise needs.
With inheritance, a developer can introduce a new  type without touching the code in existing classes.
A programmer wishing to introduce a new  of  object in this example that avoids inheritance must make considerable changes to the code, involving the following:.
This is not a small point.
Modifying existing  can introduce errors.
This can cause existing applications that depend on the Text  to fail.
With inheritance, programmers add new without touching existing.
Pre-existing applications will continue to function as usual because they do not use the new  introduced via inheritance.
Without inheritance we need access to the original source  in order to augment the data type.
If it is part of a pre-compiled library, we cannot make the necessary modifications.
With inheritance, however, we can derive a new  from an existing  even if we do not have access to, or control over, the source  of its implementation.
To illustrate these issues, suppose we wish to add a new  of  object that bounds the length of the Listing _0_.
TextType type; std::string ; std::string left_bracket; std::string right_bracket; std::string connector; size_t length_limit; // Maximum number of characters in the.
We extended the enumeration to  TextType: :Bounded.
We added one more field (limit) to.
Note that even though our new   objects require no special  method, we still must add the case label to match the TextType: : Bounded type.
Failure to add this case label would mean every   object would respond with the "UNKNOWN TYPE" string.
We definitely must add new to the append to ensure the concatenation operation does not make   objects too long.
Even if the  and append methods were known to work flawlessly before we introduced this new of  object, they now are suspect.
Our act of modifying them could have introduced a subtle bug, and so they must be thoroughly retested.
Our non-polymorphic   is relatively small, containing only two methods.
Now suppose we do not have access the source  within Listing [17_0_14 (alttext2_0_cpp).
A pure  object will have a string field, period.
A Fixed  object as well contains only a single string field.
A FancyText object will contain four string fields, and each object will maintain a string and integer value.
Each particular type of  object will contain only the data it requires, not all the data that may be required for any possible kind of  object.
This derived  leaves the original code in the base  untouched.
We can do nothing in our code to damage the , FancyText, or Fi xedText classes.
We can compile the code within Listing.
All we need is the header file Listing (T7_0_2|| (, h) that specifies the interface of the.
This header must be available to any clients that wish to use a  object, but the source code for the implementation of the   is not needed to compile client code that uses  objects.
The linker would need the compiled Listing [T7_0_3| (_0_cpp) in order to link and produce an executable program, but at no point in the build process is the source code in Listing [T73] (_0_cpp) necessary if its compiled code is available.
The inheritance with polymorphism approach is more modular; that is, if our  code does not work or is not as efficient as it could be, we or someone else easily can supply a different version to compile and link into an application.
This modularity enables multiple programmers to work independently implementing separate classes without interfering with each other.
Suppose a third-party library provides a  named Message that is similar to the classes in our.
In addition to revealing its contained , each time a client calls a Message object's  method the.
The Message  provides a method named access_count that returns the number.
My message My message My message 3 We cannot modify the  Message, either because we do not have the source code to this library, or.
Message  or how it works.
What if would like to maintain a collection of  and  objects, storing them all in a single vector.
All of the elements in a particular Cplus_plus vector must all be of the same type.
The is not part of the   hierarchy, so no is a relationship exists between the two classes.
Let us experiment with two possible solutions to this problem.
Make a copy of a  object.
We could try to simply copy the contents of a  object.
Unfortunately as you may have noticed, the code calls  only once, when creating the txt object from the  object.
It is this single call that makes the access count become one.
The subsequent calls to get are on a  object, not a  object.
This means we really do not have a  object in our vector, so none of the objects in our vector can take advantage of the services that a  object provides.
Use inheritance and polymorphism to encapsulate  objects within  objects.
MessageText: public  {.
Instances of this MessageText  wrap a pointer to a  object.
The constructor does not call the wrapped  object's  method, so making a MessageText object from a  ob¬ ject does not artificially elevate the access count for the  object.
Further, any call to a MessageT ext object's get method actually calls the  method of the  object it is managing.
The following code:.
This proves that we really did sneak a  object into our vector of objects.
This technique of adapting the interface of one  to that of another  has a name: the adapter design pattern.
The adapter design pattern is useful when you have a  with properties similar to another but with incompatible interfaces.
You can use this technique of inheritance and polymorphism to derive a new  with the desired interface Suppose you have  X and  Y that describe objects with similar function¬ ality but different interfaces (different methods), and you need to treat a Y object as if it were an X object.
You may be able to use the adapter design pattern as follows: 1.
Derive a new , Z, from X.
Figure |[17_0_5|| illustrates packing some two-dimensional shapes into a two-dimensional container.
We thus want to determine the minimum area of the container that can hold a given collection of parts.
A real-world application could be computing the size of the smallest circuit board that can hold a collection of electronic components.
Our program will be much simpler and give us only a rough approximation; it does not take into account the geometry and orientation of the individual shapes but merely computes the total area of the components.
The actual answer generally will be larger than the result computed by our program.
An interesting problem arises if a method in a derived  needs to use an inherited variable.
If the variable is declared pri vate in the base , a derived  method cannot access it.
The pri vate specifier means "not available outside the , period_0_" We know it is unwise in general to make instance variables public, since that breaks encapsulation.
Since encapsulation is a desirable property, Cplus_plus provides a third level of access protection within a — protected.
A protected member, whether it be data or a method, is inaccessible to all code outside the , except for code within a derived.
The use of protected is illustrated in the shapes code.
The "assignment to zero" of the two virtual methods in the Shape  make them special; they are called pure virtual methods or pure virtual functions.
This special syntax signifies that these methods have no implementations.
It is not possible to provide a body for these methods.
A  that contains at least one pure virtual method is an abstract.
It is not possible to create an instance of an abstract.
The compiler enforces this restriction; the following statement;.
An abstract  represents an abstract concept.
Shape is an abstract concept.
We can have circles, rectangles, and lots of other kinds of shapes, but can we have something that is "just a shape" without being a particular kind of shape.
Even though we cannot create instances of abstract classes, abstract classes are useful for organizing a  hierarchy.
Note the appearance of the protected access specifier.
The methods in any  derived directly or indirectly from Rectangle will be able to access the length and wi dth fields.
These fields will be inaccessible to code outside these classes.
Listing [17_0_22[ (rectangle_0_cpp) provides the implementation of Rectangle's methods.
Circle (double radius);.
The DrawableRectangle: : draw method needs access to the fields length and wi dth to be able to draw the rectangle.
It is important to remember that every DrawableRectangle object contains these fields because it inherits them from Rectangle; however, if the length and wi dth fields were declared private instead of protected in Rectangle, DrawableRectangle: : d raw would not be able to access these fields.
A  supports three levels of protection for its members:.
Protected members are inaccessible to other (non-derived) classes.
In sum, private means not accessible outside the , period.
Public means open.
The ordering imposed by a selection sort function can be varied by using custom comparison func¬ tions.
The object used to determine the sort's ordering collects data about the number of comparisons and element interchanges the sort function performs.
Listing [17_0_35| (polymorphicsort_0_cpp) provides a slight variation of Listing |16_0_5|[ (loggingflexiblesort_0_cpp).
Listing [r7T35j (polymorphicsort_0_cpp) provides the client code that tests the new  class.
The design of this new  class is interesting:.
Since its counter fields are private, only methods in the  r e r class itself can access aComparer object's data.
The two virtual methods, compa re_i mpl and swap_0_.
Derived classes, however, can see them and override them.
The suffix _  m p l stands for "implementation," so compare.
The public compare and swap methods both delegate part of their work to the protected compa re_i mpl and swap_0_impl methods.
The compare and swap methods are not declared vi rtual, so derived classes cannot override them.
The compare and swap methods manage the compa re_count and swap_count counter fields.
Since derived classes cannot see these fields, there is nothing that a designer of a derived class can do when overriding compa re_i mpl or swap.
The  and swaps methods that report the results to the client are non-virtual, so derived classes may not override their behavior.
Observe that the designer of the  r e r class allows the nature of the  and swaps in derived classes to be flexible, but it is rigid on the enforcement of how the accounting is performed and reported.
The proper use of protected and pri vate specifiers in a base class as shown in  affords class designers a great deal of control over exactly what derived class designers can do.
Derived classes may adapt some behaviors, but other behaviors are non-negotiable.
What kind of customization would a programmer want to do to the  class beyond chang¬.
The two overridden methods, compare_impl and swap_impl, write text to the log file.
Comparing -3 to 23 Comparing 4 to -3 Comparing 215 to -3 Comparing 0 to -3 Comparing -3 to -3 Comparing 2 to -3 Swapping 23 and -3 Comparing 4 to 23 Comparing 215 to 4 Comparing 0 to 4 Comparing -3 to 0 Comparing 2 to -3 Swapping 23 and -3 Comparing 215 to 4 Comparing 0 to 4 Comparing 23 to 0 Comparing 2 to 0 Swapping 4 and 0 Comparing 4 to 215 Comparing 23 to 4 Comparing 2 to 4 Swapping 215 and 2 Comparing 23 to 4 Comparing 215 to 4 Comparing 215 to 23 If during development the selection sort function has  problem, the programmer can review the contents of the log file to examine how the sort progresses and perhaps determine where the problem lies.
The design of the Compa r e r class provides  overall structure that allows inheriting classes to fine tune the details without disturbing the overarching framework.
Inheritance and polymorphism allow us to add functionality to an existing code base.
Virtual methods provide extension points by which derived classes can add custom behavior.
CHAPTER UNDER CONSTRUCTION 1111111111 The Cplus_plus programming language provides many options to programmers when it comes to managing the memory used by an executing program.
This chapter explores some of these frequently used options and introduces modem techniques aimed at reducing the memory management problems that have plagued Cplus_plus projects in the past.
A modern operating system reserves  section of memory for an executing program.
The code section of memory holds the program's compiled executable instructions.
The data section of memory contains global variables (see Section [l0_0_1| and persistent local variables (stati c locals, see Section 10_0_2).
The variables in the data section exist for the life of the executing program, but, unless they are constants (see Section |3_0_6) , the executing program may freely change their values.
Even though the values stored in the variables found in the data segment may change during the program's execution, the size of the data segment does not change while the program executes.
This is because the program's source code precisely defines the number of global stati c local variables.
The compiler can compute the exact size of the data segment.
The heap is where an executing program obtains dynamic memory.
The new  gets its memory from the heap,  delete returns previously allocated memory back to the heap.
The size of the heap grows  shrinks during the program's execution as the program allocates deallocates dynamic memory using new  delete.
The stack is where local variables  function parameters live.
Space for local variables parameters appears when  function is called  disappears when the function returns.
The size of the stack grows  shrinks during the program's execution as various functions execute.
Operating systems generally limit the size of the stack.
Deep recursion can consume a considerable amount of stack space.
An improperly written recursive function, for example one that omits the base case thus exhibits "infinite" recursion, will consume all the space available on the stack.
Such a situation is known as a stack overflow.
Modern operating systems will terminate a process that consumes all of its stack space, but on some embedded systems this stack overflow may go undetected.
Heap space typically is much more plentiful,  operating systems can use virtual memory to provide a executing program more space than is available in real memory.
The extra space for virtual memory comes from a disk drive, the operating system shuttles data from disk to real memory as needed by the executing program.
Programs that use a lot of virtual memory run much slower than programs that use little virtual memory.
Virtual memory is not unlimited, however, so a program with memory leaks eventually can run out of memory.
Because of the way function  method calls  their subsequent returns work, the stack grows shrinks in a very regular fashion.
It expands during a function call to make room for the executing function's local variables  parameters ( it expands even more if that function calls other functions),  when the function returns, the stack contracts back to the original size it had before the function invocation.
Variables are removed from the stack in the reverse order of their creation on the stack.
The stack always consists of one contiguous chunk of memory with no areas of unused space within that chunk.
The heap grows  shrinks as the program executes   delete, but its expansion  con¬ traction is not regular.
One function may allocate an object or dynamic array with ,  a different function may much later in the program's execution deallocate the object or array with delete.
An exe¬ cuting program may delete dynamically allocated memory in a very different order from its allocation.
This means that memory allocated on the heap is not contiguous; that is, space for deallocated objects can be interspersed with space for allocated objects.
The the available memory on the heap thus can become fragmented during the program's execution.
Global variables  static local variables in the data segment live for the life of the executing program.
The run-time environment initializes globals before main begins executing  cleans them up when mai n returns.
The run-time environment initializes static locals during the function's or method's first invocation.
Non-static local variables on the stack exist only when a function is executing.
If a program calls  returns from the same function 20 times, that function's local variables appear disappear 20 times.
An executing program can create dynamic memory as needed, hold onto it as long as necessary,  finally release it when it is no longer needed.
The quantity of global data is fixed when the program begins executing,  stack data is not persistent for the life of the executing program.
This means an executing program that must manage a varying amount of data for an arbitrary amount of time must use the heap as a source of memory for that data.
The run¬ time environment automatically manages global  local memory.
Unfortunately, programmers must write code that manually manages heap data.
The problem is this: Manual memory management in all but very simple systems turns out to be a difficult task.
Development of large software systems with Cplus_plus in the early days often was a frustrating experience.
Memory management issues with   delete frequently are the source of difficult to find  fix logic errors.
Programmers must adhere strictly to the following tenets:.
Every call to   have an associated call to delete when the allocated memory is no longer needed.
It sounds simple enough, but it is not always clear when delete  be used.
Before the call to calc, variable p does not exist.
Figure fl8Tlj shows how memory is stranded when local pointers go out of scope at the end of a function's execution.
In the calc function  is a local variable.
As such,  lives on the stack.
When a particular call calc completes, the function's clean up code automatically releases the space help by the variable This is because all functions automatically manage the memory for their parameters  local variables.
The problem is  is assigned via   point  memory allocated from the heap, not the stack.
Function executions manage the stack memory only.
When the function's execution completes, is gone,  the memory  which  pointed is not deallocated automatically.
Worse yet, the heap memory formerly referenced by the local variable  now is unreachable because no other variables that remain viable know anything about it.
A correctly written calc function has three options in this case:.
Option 1 is the easiest solution.
The calc function needs a dynamically allocated array, creates it, uses it,  then deallocates it before returning.
Within this single function definition we can see a   later its corresponding delete — a perfect matched pair.
Unfortunately, this is not a common case.
If calc needs local working space, it is best handled on the stack through local variables.
That way memory clean up is automatic.
Option 2  possible only if callers invoke the calc function exactly once , additionally in the case of a global pointer, invoke calc before attempting  use the global pointer.
Option[3] the more common occurrence.
The heap enables an executing program  add extra data at run time that persists across function calls.
In theory the process  simple: 1.
The problem here  we cannot see the   with the delete.
The   hidden in calc, the caller must exercise delete.
The delete operator never  be used  free up memory that was not allocated by a.
Attempting  delete memory not allocated with   in undefined behavior  represents a logic error.
Such pointers are called aliases.
The following code.
Multiple deletes of the same memory  in undefined behavior  represents a logic error.
Memory previously deallocated via delete  never be accessed.
Attempting  access.
For efficiency reasons the delete operator generally marks heap space as "available" without modifying the contents of that memory.
Careless program¬ mers can accidentally use the memory of a deleted pointer obliviously as if it were still live problem manifests itself when the freed up memory eventually gets reallocated elsewhere via a call result  that programs seem  "work" for a while  mysteriously fail at unpre¬ dictable times.
Debugging such situations can be very difficult.
Aliasing  a problem because of our concept of variables.
When we have two variables with different names it  natural  assume they represent two different objects.
Point¬ ers  references introduce the possibility of aliasing; they use reference semantics.
Reference semantics enable useful techniques such as call-by-reference  the traversal of dynamic data structures like linked lists, but reasoning about the identity of objects using reference semantics requires extra caution.
It seems simple enough  make sure every   exactly one corresponding delete, but in practice it can be very difficult  determine exactly when  use delete.
Suppose, for example, you obtain a.
Entering main Creating node 23 Creating node 45 Creating node 16 Creating node 12 Creating node 3 Creating node 20 Creating node 10 Destroying node 45 Destroying node 16 Destroying node 12.
Destroying node 3 Destroying node 20 Destroying node 10 Destroying node 23 Destroying node 45 Destroying node 16 Destroying node 12 Leaving main Observe widgets 45, 16,  12 being destroyed twice.
On some systems the program crashes before printing Leaving main.
Double deletion  classified as undefined behavior,  it represents a bug in our program.
Before returning from process, how can you traverse the vector releasing the dynamically allocated memory  ensuring that you do not delete the same object more than once.
Even if you are careful  account for each allocation of  objects of a particular value, you really do not know if the program elsewhere earlier called get_widget() stored the result in a global variable that outlives this call to process.
You would need to implement within your code a complex global accounting infrastructure that keeps track of all memory allocations.
A Node contains an integer  a Node, but this contained Node field itself would contain an integer  a Node,  the nested containment would go on forever.
Such a structure understandably illegal in Cplus_plus,  the compiler will issue an error.
You are not allowed to have a class or struct field of the same type within the class or struct being defined.
Another object definition looks similar, but it is a legal structure:.
A pointer is simply a memory address under the hood,  all pointer variables are the same size regardless of their declared type.
This ability of a object to refer to an object like itself is not merely an interesting curiosity; it practical applications.
Suppose we wish to implement a sequence structure like a vector.
We can use the self-referential structure defined above to build a  of Node objects linked together via pointers.
Listing [I8l2| (manuallinkedlist_0_cpp) builds a small linked  "by hand_0_".
In Figure [TO] the line in the next field of node n4 represents the null pointer.
Listing 18_0_2 (manuallinkedlist_0_cpp) augments the simple Node struct by adding a constructor program uses no dynamic memory (no calls to );  is possible only because we know the nodes that are in the  ahead of time.
This enables  to visit nodes nl, n2, n3, finally  will point to n4, the last node in the list.
The next field of n4 is nullptr, so when the loop reassigns  to n4's next field,  will be nullptr,  the loop will terminate.
The value nullptr in a Boolean context is considered false, so we can simplify the Boolean ex¬ pression.
The following statement: std::cout << nl_0_data <<"<< n2_0_data <<"<< n3_0_data << n4_0_data << '\n' ; is simpler, but why stop there.
Since we know the nodes and their values ahead of time, the following.
It makes sense to use a linked list only when its elements are unknown ahead of time.
We then can dynamically allocate space for the elements as they become available.
Armed with our knowledge of Cplus_plus classes, encapsulation, and methods, we can build a client-friendly, dynamic linked list type.
The code found in Listing |18_0_3[ (intlistl ,h), Listing J18_0_4|(intlistl _0_cpp), and Listing j|18_0_5|| (listmain_0_cpp) demonstrates the power of linked lists.
Listing [T~83] (intlist1 _0_h) is the header file for a simple integer linked list class.
The  struct is declared within the IntLi stl class.
We say that  is a nested struct.
Since the declaration of  appears in the private section oflntListl,  is a type known only to code within the IntLi stl class.
Because its declaration is nested within the IntLi stl class, the complete name of the  type is IntLi stl: :.
Recall that a struct is equivalent to a class, except the default access to its members is public.
We can define nested a class in same manner as we defined our nested struct.
Notice that the IntLi stl class has several private methods in addition to its public methods.
Code outside the class cannot execute these private methods directly.
These private methods are helper methods that several of the public methods invoke to accomplish their tasks.
We say that a public method delegates the work to its private helper methods.
Why is  delegation necessary here.
The private methods use recursion that requires a parameter of type IntListl: : which is unknown outside the IntLi stl class.
A client is therefore unable to use the private methods directly, even it they were made public.
The public methods do not expose to the client any details about the class's implementation; specifically they keep the IntListl: :  type and the head and tai l instance variables hidden from clients.
Observe that the overloaded length methods (both private and public) and print method of the IntListl class are declared const.
Neither printing a list nor requesting its length should modify an IntListl object.
Clients can, therefore, use the print and length methods with a constant IntListl object.
An attempt to use insert or clear on a constant IntListl object will yield a compiler error.
The error here makes sense because i nsert definitely will modify a list object, and clear potentially will modify a list object (we say potentially here because clear will not modify an empty list).
The clear method is responsible for deallocating the list nodes, effectively cleaning up the memory held by the list.
Listing prO| (listmain_0_cpp) provides some sample client code that exercises a linked list.
Observe that the client code does not use pointers at all.
All the pointer manipulations are hidden within the IntLi stl class.
Pointer programming can be tricky, and it is easy to introduce subtle, hard to find bugs; thus, encapsulation once again results in easier and more robust application development.
The Node struct itself is private within IntLi stl, out of the reach of programmers who use these linked lists.
As shown in the IntList: :dispose method, a pointer variable by itself can be used as a condition within a conditional statement or loop.
A null pointer is interpreted as false, and any non-null pointer is true.
This means if  is a pointer, the statement if (P).
Most Cplus_plus programmers use the shorter syntax.
In order to better understand how the recursive methods work, think about the structure of a Node object with this interpretation: A Node object holds a data item and a pointer to rest of the list that follows.
A pointer to a Node is either null or non-null.
A null pointer represents the empty list.
A non-null pointer represents a non-empty list consisting of two parts: the first element in the list and the rest of the list.
If the next field of a Node object is null, the rest of the list is empty.
Armed with this view of lists we can now examine the behavior of the recursive linked list methods in more detail:.
The length of the empty list is zero.
The length of a non-empty list is at least one because a non-empty list contains at least one element.
Notice, however, that it makes the recursive call deleting the nodes in the  of the list before it deletes the current node.
An attempt to access data via a pointer after using delete to deallocate that data results in undefined behavior; therefore, it is a logic error to attempt to do so.
This means the code in dispose should not be written as.
While the recursive methods provided a good review of recursion, recursion is not strictly necessary for these functions.
We could instead express the public  and clear functions as shown in the following code snippets: // Iterative versions of  and clear.
As mentioned in Section |10_0_5[ given the same basic algorithm implemented recursively or iteratively, the iterative version will be more efficient.
This is because each recursive call requires additional  on the stack to store fresh local variables (if any) and parameters.
Not only does a recursive method or function require more memory, it takes more time to complete because the executing program must perform extra work to set up the new  needed by a recursive invocation and restore the context when a recursive invocation returns.
If we build a very large linked list, a call to our recursive  or clear method could consume considerable  on the stack and impose a significant performance overhead.
For future versions of our linked list code we will use the iterative version of the clear method.
To optimize the  method, we will choose a different route.
If you have an application that man¬ ages rather large lists and makes frequent calls to the  method, even iteration can take considerable time.
We can add an integer  variable to the IntListl class that keeps track of the number of elements in the list.
This new   variable affects the  of the class members as follows:.
The constructor would initialize this variable to zero.
The insert method would increment this variable by one each time the client adds an element to the list.
The clear method would reset this variable to zero.
The time spent looping over all the elements in a list counting them can be considerable for large lists,.
The IntLi stl class code as defined in Listing 18_0_3 (intlistl _0_h) and Listing 18_0_4 (intlistl _0_cpp) is useful for introducing the concepts of implementing linked data structures.
Our IntLi stl class is, however, fundamentally different from all the earlier custom classes we examined in Section 16' With the optimiza¬ tions to  and clea r mentioned above, it may appear to be ready for clients to use as an alternative to std : : vector, but it has some servere limitations and pitfalls that make it practically useless for most applications.
Section 18_0_4 exposes its weaknesses and introduces the modifications required to make it a viable, high-quality class worthy for use in any applications requiring a dynamic linked list data structure.
The IntLi stl: : i nsert method dynamically allocates mem¬ ory for list elements from the heap.
It is essential that the programmer intentionally call clear when finished with a linked list object.
Consider the following function definition:.
The variable my_li st is local to function f.
When function f finishes executing the variable my_li st goes out of scope.
At this point the  on the stack allocated for the local IntLi stl variable named my_li st is reclaimed; however, the  for the list's heap-allocated elements remains.
The only access the program could have to that memory is via my_li st.
This presents a classic memory leak.
Observe that none of the classes we have designed thus far except for IntLi stl have this potential problem.
Fortunately Cplus_plus provides a way for class designers to specify actions that must occur at the end of an object's lifetime.
Analogous to a constructor that executes code at the beginning of an object's existence, a destructor is a special method that executes immediately before an object ceases to exist.
A destructor has the same name as its class, with a tilde ~ prefix.
A destructor accepts no arguments.
Listing 118_0_6 | (intlist2_0_h) adds a destmctor to Listing [T83] (intlist1 _0_h) and also adds the previously suggested optimizations of the  and clear methods.
When do constructors and destructors execute.
A local or global object definition calls the class con¬ structor to properly initialize the object; for example, IntList2 seq; defines the object seq.
This definition invokes the IntLi st2 constructor to set both seq.
If seq is a local variable, its destructor executes at the end of the function's execution.
If seq is global, its destructor executes when the program finishes.
A pointer is not an object; it points to an object.
This means the definition 2 *; does not invoke IntLi st2's constructor.
Given this definition of , the statement = new 2; actually creates an IntLi st2 object and therefore calls the IntLi st2 constructor for the newly created object.
The object to which  points is not destroyed until the programmer uses delete, as in.
Here we have the Node constructor identify which element it is creating by printing its data field and the address of where it resides in memory.
Cplus_plus is very strict about conversions between pointer and non-pointer types—it is easy to do by mistake and almost never intended—so a simple stati c_cast will not work here.
The rei nterpret_cast removes the safeguard and treats the bits that make up the pointer as a ui ntptr_t, an integer type guaranteed to represent the same range of values as a pointer.
The destructor indicates when a Node object is destroyed.
Listing 18_0_11 (testf2_0_cpp) is same program as Listing 18_0_8 (testf_0_cpp), except it uses an IntLi st3 object instead of an IntLi st2 object.
When this function returns, my_li st no longer exists, so we no longer can access the nodes it allocated.
If we leave IntLi st3 as is.
Listing 18_0_8 (testf_0_cpp) prints the following:.
This shows that the IntLi st3 destructor properly deallocates the dynamic memory held by the linked list object.
The Node constructor executes when declaring a Node object or when using new  create a Node object  assign  a Node pointer.
The i nsert method uses new  create a Node object, so this invokes the constructor.
The Node destructor executes when an object goes out of scope or when delete deallocates a dynamically-allocated object.
The IntLi st2 destructor uses delete  free up each node in the list.
When  goes out of scope at the end of function f2's execution, the stack variable  goes away, but since it is a pointer, not an object, no destructor code executes.
The client must explicitly free up memory with delete:.
As you can see, dynamically allocating the list itself (apart from the nodes that store its elements) brings us back  the situation we were in before: We must remember  do something when we are finished with the.
In this case we must remember  delete the list itself.
A destructor cannot help us here.
This is a good example that demonstrates that while dynamic memory enables us  do many interesting things, it is best  avoid it unless absolutely necessary  achieve the behavior we need.
A destructor performs the reverse role of a constructor: A constructor ensures that a new  begins its life in a well-defined state, while a destructor is responsible for performing actions required when an 's life is over.
A destructor is unnecessary for most classes.
For a linked list , however, a destructor is essential because the nodes that comprise the linked list are dynamically allocated with the new.
Any memory allocated with new  a corresponding call  delete when the memory no longer will be used.
The clear method will take care of the memory deallocation, but, without a destructor, a programmer must remember  intentionally call clear when finished with a linked list.
The destructor relieves the programmer of this responsibility and removes the possibility of a memory leak.
The destructor simply calls clea r  clean up the resources held by the list.
Listing 18_0_12 (testdestructors_0_cpp) demonstrates that executing program destroys local and global ob¬.
Entering main Entering test_widget_objects Creating widget 1 (14024180) Creating widget 2 (14024184).
Creating widget 4 (14024192) Leaving test_widget_objects Destroying widget 4 (14024192) Destroying widget 3 (14024188).
Destroying widget 1 (14024180) Entering test_widget_pointers Creating widget 10 (14790752) Creating widget 20 (14790816).
Destroying widget 40 (14791760) Leaving test_widget_pointers Leaving main Destroying widget 200 (2707064).
Adding a destructor  the IntListl class is a significant step in correcting its deficiencies, but its.
During this particular run the program ran to completion; however, sometimes the program will crash before printing All done.
On some systems the program crashes before printing the last three lines of output.
During this run of Listing 18_0_13|| (listassign_0_cpp) the output shows that the program never destroys the nodes containing 10, —2, and 8.
Further, the program destroys the nodes containing 4 and 5 twice.
We can see the program deletes the same memory twice by comparing the memory addresses in parentheses.
This undefined behavior of double deletion is what causes the program to crash at times.
The problem is in this statement:.
With no additional guidance from the programmer, the assignment  for a programmer-defined type simply copies the bits in memory that make up the object to right of the assignment operator into the memory reserved for the object on the left side of the assignment operator.
Under Visual Cplus_plusproducing a 32-bit executable, for example, an IntLi st3 object occupies 12 bytes of memory—four bytes for its head pointerplus four bytes for its tail pointerplus four bytes for ten.
The actual size of an IntLi st3 object will vary from system to system and will be larger on 64-bit computers.
You can verify the actual size ofanIntList3 object on your system by adding the following statement to Listing 18_0_13 (listassign_0_cpp):.
This produces three undesirable results:.
This means any actions to modify the list managed by  will modify seq2 identically.
The assignment operator does not make a copy of the contents of seq2.
This means that our linked list objects behave differently than std : : vector objects with respect to assignment; assigning one vector to another makes a copy of the contained elements.
Clients will expect our linked list objects to behave similarly.
This aliasing problem, however, is the least of our problems.
Simply redirecting 's head and tai l pointers to seq2's list renders the nodes in 's original list unreachable from any variables within the program.
The program has no way to delete the nodes in 's original list.
This constitutes a memory leak.
Both  and seq2 are objects local to the mai n function.
Based on their declaration order, 's constructor executes before seq2's constructor.
This means when mai n is finished executing seq2's destructor will execute before 's destructor, as object destruction occurs in the reverse order of object construction for local objects.
The destructor for seq2 will free up all the nodes in seq2's list.
Next, 's destructor will attempt to delete the memory occupied by its list.
Unfortunately this involves referencing and deleting dynamic memory previously deleted by seq2.
Any attempts to delete already deleted memory results in undefined behavior that usually results in memory corruption.
That is why Listing [T8_0_13 ||(listassign_0_cpp) crashes during some runs.
Fortunately Cplus_plus provides a way for programmers to customize how assignment works for a custom type.
Before we tackle assignment itself, we must distinguish between initialization and assignment.
Consider the following statement: int  = 3; This statement defines and initializes the variable  to 3.
This statement is fundamentally different from the following two statements: int ; = 3; For simple types like integers, floating-point numbers, and characters, this pair of statements on the surface behave identically to the single statement above.
In fact, these two statements involve a declaration followed by assignment.
Initialization and assignment are not the same thing.
Recall from Section [3^2] the alternate syntax for initialization: int {3};.
Cplus_plus gives programmers full control over initialization and assignment of custom types.
We have seen how we can specify initialization via a constructor.
In order to legitimize our linked list class and make it safe for clients to use, we need to provide an additional constructor, called the copy constructor, and define an assignment operator for the class.
Node *head; // Points to the first item in the list.
The expression 4() in the constructor initialization list following the colon is calling the overloaded version of the constructor that accepts no arguments.
This is known as constructor delegation.
The no-argument constructor simply initializes head and tail to nullptr.
We could have done the same thing here without calling the other constructor, but, in general, delegation is a good idea.
Delegation can avoid code duplication, and while there currently is not much code in the no-argument constructor, we may decide to add more functionality in the future.
By delegating, we can add the extra activity to the no-argument constructor without having to add it also to this copy constructor.
Constructors always begin with a brand , -preexisting object.
In the case of our linked list objects, that means our constructor does not have to worry about cleaning up any preexisting list of nodes.
All our copy constructor needs to do is ensure that head and tai l instance variables initially are null (the constructor delegation takes care of that) and then visit each node in the other list, inserting that node's data value into its own list as it goes.
Next we will consider assignment.
Suppose  and lst2 are two linked list objects.
This means the assignment  in the course of its operation must deallocate the original list of nodes, if any, managed by the assigned-to list.
Failure to do so would introduce a memory leak.
Also, the assignment must make a copy of all the values in the assigned-from list to avoid aliasing.
There are various ways we can implement the assignment  to ensure it works correctly, but since assignment of this nature is such a common operation, Cplus_plus programmers have developed a standard idiom that guarantees the correctness of assignment.
Best practices dictates that we implement our assignment as a process.
This entails making a local temporary copy of the assigned-from list and swapping the list of nodes from the temporary list with list of nodes from the assigned-to list.
Note that swapping the list of nodes simply requires swapping the head and tai l pointers between the two objects.
This copy-and-swap process depends on a correctly implemented copy constructor and a correctly implemented destructor.
Missing is any calls to delete to free up any preexisting list nodes in the assign-to list.
How does this assignment  magically meet our requirements for a correct assignment.
Recall that the copy constructor uses a loop to traverse the assign-from list, making a copy of each node in that list.
This solves the aliasing issue and explains how this assignment does actually visit every node in other's list.
This means the assign-to list object now holds the copy of the assi gn-f rom list, and the  list object holds the list originally managed by the assign-to list object.
Since it is a local variable the  list object (temp) goes out of scope at the end of the function's execution.
The temp object's destructor executes at this time.
This  object now holds the assign-to object's original list, so the destructor properly deallocates all the nodes in the assi gn-to object's original list.
The calls to delete to prevent the memory leak are found in the linked list class destructor.
Figure | 18_0_5| illustrates the copy-and-swap process of the assignment.
Our assignment  leverages the code already written in the copy constructor and destructor.
Any other implementation of assignment that correctly addresses the aliasing and memory management issues necessarily would duplicate the functionality of either the copy constructor or the destructor.
Note that the 4: := method's declaration indicates it returns a reference to an 4 object, and we see in the last line of 4: : ='s body that the method ac¬ tually returns a reference to the object that appears on the left side of the assignment  during its invocation.
Recall that the thi s keyword represents a pointer to the object upon which the caller invoked the method (in this case the assign-to list object).
If 1st 1 and lst2 are list objects, when executing the statement.
This is the typical Cplus_plus idiom used when defining ^ for programmer-defined types.
We could instead define the ope rato r- method to return nothing (that is, declare its return type to be voi d).
Instead we could define the method to return some type of object other than IntLi st4.
If we do so, however, our IntLi st4 objects will not behavior properly with chained assignment (see Section 4_0_3).
To illustrate, suppose , 2, and 3 are all properly declared IntLi st4 objects.
If we define the IntLi st4: : ^ method to return voi d, the following statement: = 2;.
If we use the original definition above of the IntLi st4: : ^ method that returns a refer¬ ence to the IntLi st4 object on the left side of the assignment  (*thi s), the compiler does not complain and the chained assignment works flawlessly in the same manner as chained assignment involving the built-in numeric types; that is, after executing the chained assignment statement above,  and 2 each will contain exact copies of the elements in 3.
Figure 18_0_6 An annotated output of Listing 18_0_13 (listassign_0_cpp) updated to use our IntLi st4 class.
Ex¬ amine carefully the  memory addresses (in parentheses) to convince yourself that the implementation of correct copy constructor, assignment , and destructor for the class solved the aliasing, memory leak, and undefined behavior problems.
Creating  -2 (17477728) Creating  8 (17477744).
Creating seql's original list 10 -2 8 Creating  5 (17477760) ~| Creating  4 (17478592) _J 5 4.
Creating seq 2's list.
See Figure jl8,6|| provides an annotated output of Listing [18X3] (listassign_0_cpp) updated to use our IntLi st4 class.
The output demonstrates that assignment now works correctly for our linked list objects.
Correctly implementing the copy constructor, assignment , and destructor for the 4 class solved the aliasing, memory leak, and undefined behavior concerns.
The copy constructor, assignment , and destructor have a special relationship in Cplus_plus.
These three methods are involved in the Rule of Three.
The Rule of Three is this: If a class designer feels the need to add a copy constructor, assignment , and/or destructor to a class, the class should have all three.
Said another way, it almost always is a mistake to have just one or two of these special methods defined for a class without including all three.
The Rule of Three is a design guideline; it is not requirement of the Cplus_plus language that the compiler enforces.
Consider why the rule exists.
If an object must be guaranteed to perform some action at the end of its existence and failure to do so would result in undesirable consequences as the program continues to execute, the object's class must contain a destructor.
This essential action usually involves some releasing some resource it owns.
If the destructor is responsible for releasing a resource, the copy constructor must somehow acquire a resource that is in some way related to the resource of an existing.
The assignment must both release an owned resource and acquire a resource related to the resource of an existing What if you leave out one of the three.
If you omit the destructor, the default destructor does no resource clean up.
Objects can acquire resources through copy construction and assignment but cannot release them.
Most resources (like memory) are finite, so lack of an appropriate destructor will limit the number objects available to the executing application.
If you omit the copy constructor, the default copy constructor will copy the bits of the existing into the.
This means the copy-constructed  will have the exact resources managed by another.
The destruction of exactly one of the objects will release the resources held by the other.
The non-destroyed  then will not have access to the resources it needs to function.
If you omit the assignment , the default assignment will copy the bits of one existing into another existing.
This means the assigned  will have the exact resources managed by another.
It also means that the resources the assigned  originally held are not reclaimed.
The destruction of exactly one of the objects will release the resources held by the other.
The non-destroyed  then will not have access to the resources it needs to function.
In sum, you should have a very good reason for designing a class that violates the Rule of Three.
The / in lvalue stands for left, as  can appear all by itself on the left side or right side of the assignment operator.
The expression  + 2 is classified as an rvalue, since it can appear only on the right side of the assignment operator but cannot appear on the left side; for example, the following statement is illegal: + 2 = ; // Illegal.
The term temporary is appropriate, as the program may reuse that same memory for other purposes.
Consider the following variable declarations:.
The variable , however, would continue to exist, but it would not be aliasing any valid quantity.
Cplus_plus does permit us to make a const reference to a temporary.
The following code fragment is legal:.
In this case  behaves as if it were simply a const int.
Everything works as expected because.
The function g accepts a reference to a variable, but the caller is attempting to pass a temporary.
Once function g begins executing, the memory reserved for the original temporary is invalid, so the compiler rightly does not permit this.
As with the simple declarations we saw above, given function h:.
While these examples may seem a bit esoteric, we are paving the way for a more efficient linked list.
Figure 118/71 annotates the output of Listingi 18_0_16 (templist_0_cpp) to explain.
Either way, the make_list(4) expression represents the Int Li st4  returned by the make_li st function when passed the actual parameter 4.
The expression make_li st (4) is an rvalue, a temporary, because it cannot appear on the left side of the assignment operator.
Since the Int Li st4 copy constructor accepts a const IntLi st4& parameter, it will accept the temporary , but it makes a copy of the temporary to send to the copy constructor.
If is wasteful to make a copy of this transient.
If the list  contained millions of nodes, this additional construction and destruction could be time consuming.
Cplus_plus does permit a special kind of reference for rvalues known as an rvalue reference.
An rvalue refer¬ ence enables programmers to alias a temporary without making a copy.
In the following code:.
Figure 18_0_7 An annotated output of Listing 18_0_16 (templist_0_cpp).
Examine carefully the node memory addresses (in parentheses).
The executing program first creates the temporary IntLi st4  returned by make_list.
It the copy constructs the   from the temporary and then destroys the temporary.
After printing the linked list, the program finally destroys the my li st.
Calling with reference parameter, result  ==> 12.
Calling with rvalue reference parameter, result  ==> 12 The expression twi ce (  ) calls the twi ce function with an lvalue, so it calls the first version of twi ce.
The expressions  + 2 and 2 are rvalues—neither can appear by itself on the left side of the assignment operator—so both twi ce (  + 2) and twi ce ( 2 ) invoke the second version of the twi ce function.
These examples with integers we have seen so far help us better understand the mechanics of rvalue references, but, honestly, rvalue references offer little value to the simple types like integers.
The Cplus_plus lan¬ guage designers introduced rvalue references into Cplus_plus for the specific purpose of making copy construction and assignment from temporaries more efficient.
Rvalue references are exactly what we need to make our linked list of integers more efficient when dealing with temporary lists.
Listing 118_0_18[ (intlist5_0_h) declares the fifth generation of our integer linked list class.
It contains a new constructor overload and adds an assignment operator overload, both of which accept rvalue references.
The additional constructor  known as a move constructor, and the additional assignment   known as the move assignment.
To make the discourse clearer, we will refer to the original assignment as copy assignment.
The compiler can disambiguate between the overloaded methods by virtue of the actual parameters passed by the caller:.
If the caller passes an lvalue, the compiler generates code that invokes the copy constructor or copy assignment.
If the caller passes an rvalue, the compiler generates code that invokes the move constructor or move assignment.
The purpose of move construction  to efficiently move the resources held by the temporary  into the new  being created.
We want to avoid making a copy of the temporary.
Similarly, the purpose of move assignment  to efficiently move the resources held by the temporary  into an existing without creating a new.
The copy constructor and copy assignment  are designed to make copies.
It  safe to "steal" the resources of the temporary  because a temporary   transient and cannot be used later within the program.
Even though temporary objects are transient, they nonetheless are real, nameless objects.
If the class of the temporary has a destructor, the 's destructor will execute when the temporary's ephemeral life  over.
This means that even though the move constructor and move assignment  may move a temporary's resources into another , they must leave the temporary in a well-defined state so that the temporary's destructor can do its job.
The following implements the move constructor for the IntLi st5 class:.
This move constructor delegates to the constructor that accepts no arguments.
This initializes the head and tail pointers of this new  to nullptr.
Note that this represents an empty, but valid linked list.
The move constructor then exchanges the head and tail pointers of the  it  creating with those of the temporary.
This effectively moves the temporary's list of nodes to this  and moves the this 's empty, but valid, list of nodes to the temporary.
When this copy constructor finishes, the temporary's life  over.
Since the temporary still contains a valid list of nodes, its destructor can execute successfully.
Observe that no where in this copy constructor did we traverse a list of nodes copying each element individually.
This means move construction of a list with 1,000,000 nodes requires no more time than move constructing an empty list.
Note that the parameter to the move constructor  not declared const.
If it were declared const, it would not be possible to swap its contents with new  being created.
The move assignment   similar to the move constructor, except assignment, of course, does not begin with an initially empty.
We must ensure our move assignment  does not leak memory from any preexisting list of nodes the  may contain.
The implementation of the move constructor for the IntLi st5 class looks very similar to the move.
The only difference  the move constructor always will given the empty list to the.
The move assignment  exchange the 's list for the 's list.
The 's list could be empty, but in general it will not be empty.
When the move assignment  returns, the  passed to it will cease to exist.
The 's destructor then will properly dispose of the 's original list of nodes.
The make_li st function creates the  ; this accounts for all statements that begin with Creating _0__0__0_.
The move constructor exchanges the  's list of nodes with the empty list found in the newly created my_list.
At this point my_list contains the 's original list and the  contains the empty list.
The 's destructor executes but finds no nodes to destroy ( is null).
At the end of the mai n function my_li st's destructor delete's all the nodes in my_li st.
As an aside, note that the compiler can detect that the make_list function creates a local (result) but merely returns it to the caller.
The compiler can use return value optimization (see Sec¬ tion [1T7L4J to avoid creating an extra  within the function to return to the caller.
Instead, the compiler generates code that enables the make_li st function to create the linked list  directly in the envi¬ ronment of the caller.
The addition of move construction and move assignment brings us to Cplus_plus's Rule of Five.
The Rule of Five involves copy construction, move construction, destruction, copy assignment, and move assignment.
If a programmer defines none of these special methods for a class, the compiler automatically will provide its own versions of each of them that work properly for classes that support value semantics; for example, all the classes in Chapter[TSjsupport value semantics.
Classes that use value semantics avoid the memory management and aliasing issues we encountered with our linked list classes.
If the programmer defines one or more of a copy constructor, destructor, or copy assignment , the compiler will not automatically supply a move constructor or move assignment.
This is not a problem as far as program correctness is concerned; move construction and move assignment merely provide an optimization that avoids the unnecessary creation of an extra  when constructing or as¬ signing from a rvalue ().
A missing move constructor means a  is copied by the copy constructor, and a missing move assignment  means a  is copied by the copy assignment.
The programmer can precisely control which of these special methods the compiler supplies by explic¬ itly marking these methods with a default or delete label.
We will not go into the details here, but merely provide a few examples.
X2 my_x2; // Illegal; the client must provide an integer If we really want a client to be able to create an object both with or without an integer argument, we can overload the constructor (provide our own default constructor) or force the compiler to generate one for us using the default label, as shown here:.
We added a destructor but did not supply a copy constructor and did not define a copy assignment.
How can we justify this decision.
In reality, the  struct does not need a destructor.
The linked list class will operate flawlessly with a inner struct that has no destructor.
No code within the  struct allocates any resources.
The outer linked list class is responsible for allocating and deallocating memory resources.
The linked list methods manipulate  objects as passive data.
We added the destructor only so we could see exactly when the program destroyed a  object.
This enabled us to detect memory leaks and multiple deletions and refine our linked list class into a robust useful type.
The  destructor cleans up no resources nor does anything else that would impact the work the compiler-generated copy constructor or the compiler-generated copy assignment operator would do.
Remember, you should follow the Rule of Three unless you have a very good reason not to do so.
In our case, our good reason is our destructor does nothing that would prompt us to write our own copy constructor and copy assignment operator to properly coordinate with destructor.
In order to emphasize our intentional decision to violate the Rule of Three, we can rewrite the Node.
By explicitly defaulting the copy constructor and copy assignment operator, we indicate that we did not omit them by accident.
The inclusion of the destructor prevents the compiler from automatically generating a move constructor and move assignment operator.
By declaring these two methods as default, the compiler will generate them for us.
Since our  object contains only simple types (an i nt and a pointer) we can omit all the explicit defaulted methods in the declaration above,  nothing will be different.
This is because Cplus_plus "moves" an integer merely by copying it.
A simple integer has no resources we need to steal from a temporary; a simple assignment is all that is needed.
Similarly, a pointer may refer to an elaborate object of some sort, but the pointer itself in simply an address.
Copy  move construction is the same,   copy  move assignment is handled  same as well.
Cplus_plus programmers that manually manage dynamic memory with   delete follow a style inherited directly from  C programming language.
Many modern programming languages like Python, Java, C# manage dynamic memory through a technique called garbage collection.
Garbage collection takes care of  accounting necessary to avoid multiple deletes  memory leaks.
In garbage collected languages programmers need only call  equivalent of ;  garbage collector takes care of freeing up  space later when  executing program no longer uses  dynamically-allocated object.
Garbage collection works well, but it does add some overhead to an executing program.
This overhead consumes some extra memory  can affect a program's run-time efficiency.
Cplus_plus strives to be as efficient as possible, so it does not provide an automatic garbage collector.
Garbage collected languages typically allocate all objects on heap, thereby managing objects in a uniform manner.
Cplus_plus supports statically-allocated  stack-allocated objects, as well as heap-allocated objects.
Heap allocation is sightly slower,  heap fragmentation can further degrade program performance.
Cplus_plus follows  mantra you only pay for what you use, meaning programs that do not need  heap do not incur  run-time cost of using  heap.
Cplus_plus provides  efficiency benefits of a non-garbage-collected language with  convenience of garbage collection when desired.
Cplus_plus achieves this in various ways.
One way we have seen  have been enjoying its benefits for some time.
The std: :vector class manages a dynamic array, using   delete behind  scenes.
Software engineers implemented std : : vector carefully to do  right thing, avoid¬ ing aliasing, memory leaks,  multiple deletions.
Modern Cplus_plus makes it possible to write programs that manage dynamic memory using neither delete directly.
Such a style uses smart pointers', that is, pointers that "know" exactly when to deallocate memory they reference.
Cplus_plus smart pointers eliminate  need for such manual intervention on  part of  programmer.
A smart pointer automatically deletes its associated memory at  proper time.
The std : : sha red_pt r type is one example of a standard Cplus_plus smart pointer.
Suppose we have  following Wi dget type:.
The std: : function eliminates  need of.
It uses scenes to allocate  necessary memory for  object it creates, but  programmer does not see.
On  other end of  object's lifetime, programmers never call delete when using smart pointers; smart pointers automatically call delete at  proper time.
The use of  std : :  function enables programmers to work with dynamically-allocated memory without ever using   delete directly.
This removes  possibility of memory leaks  multiple deletions that haunt manual memory management.
In  expression std : : make_sha red<Wi dget>(12)  name inside  angle brackets is  type of  object to create,   value in  parentheses is  argument to pass to that type's constructor.
The compiler knows that  function will return type std: : <>, so there is no need to spell out  exact type of  on  left side.
Once we have  defined in one of these ways we can treat it syntactically as if it were a raw pointer; for example: // Make  point to a dynamically created a  object.
Destroying a widget #0 (18566044).
The code in testl modifies the id value of the Wi dget object.
It is important to note that p is  local variable in testl, so the space for std: : shared_ptr p itself appears on the stack.
The call to std : : make_sha red creates via new  widget object on the heap.
When p goes out of scope at the end of testl' execution, p' desructor automatically calls delete to deallocate the widget from the heap.
The usual function return mechanism automatically removes p from the stack.
The next few lines of output:.
In the next few lines of output:.
The program includes the test3 function simply to demonstrate that std : : sha red_pt r objects can manage the dynamic memory of simple types just as well as fancier types.
The simple i nt type does not report its destruction when its memory is freed, but rest assured that the std : : shared_ptr object will deallocate its memory correctly.
In the next few lines of output:.
This is because it is the first invocation of test4.
The first call initializes the stati c local p, hence the construction of  std : : sha red_pt r and its associated Widget object.
Since p is  static local variable it must survive between calls to test4; therefore, p cannot be deallocated until the program finishes executing (see below).
In the next few lines of output:.
This means p destroys its widget.
In the output of the final test function, test6, we see.
Creating  widget #5 (18566092) 5 5 5 5 5 5 Destroying  widget #5 (18566092) - Leaving Test 6 The test6 function allocates just one Wi dget object.
It assigns three std : : sha red_pt r objects to the same widget object.
This provides  clear justification for the name shared_ptr —all three pointers share access to the same object.
If p and  are std : : shared_ptrs of the same type, the statement = p;.
Regardless of the aliasing, the code within test6 allocates exactly one Widget object and deallocates that same Widget object when the function completes its execution.
The final lines in the program's output:.
Destroying  widget #0 (18566044).
If you analyze the output of Listingj 18_0_211 (simplesharedptrtest_0_cpp) carefully, you will see that every constructor call has an associated destructor call for the same object (remember testl renamed widget #1 to #25, so compare widget #1 's creation address with widget #25's destruction address, and you will see they match).
The heap provided all the space for Wi dget objects in Listing 18_0_21 (simplesharedptrtest_0_cpp), yet we see neither new  delete anywhere in the code.
This ability to deallocate its referenced memory at the proper time is what makes  std : : sha red_pt r object  smart pointer.
Recall Listing 18_0_1j(howtodelete_0_cpp) that demonstrated the difficulty of managing dynamic memory manually.
Listing l'8T22| (smartdelete_0_cpp) converts all the raw pointers of Listing fl8T] (howtodelete_0_cpp) into std : : sha red_pt rs.
We no longer need to worry about who "owns" the memory of the heap allocated objects; std : : shared_ptr objects manage all those details.
Entering Creatin Creatin Creatin Creatin Creatin Creatin Creatin Leaving Destroying widget 23 Destroying widget 45 Destroying widget Destroying widget Destroying widget 3 Destroying widget 20 Destroying widget.
How does a std : : shared_ptr smart pointer "know" when to call delete to free up its object.
Given the following Widget type:.
The following statement: //  is the Widget object created above = nullptr; redirects  to point to nothing.
At this point no variable references the Wi dget object created earlier.
This means the object effectively is cut off from the remainder of the program's execution.
This abandoned object is classified as garbage.
The term garbage is a technical term used in computer science that refers to mem¬ ory allocated by an executing program that the program no longer can access.
Reference counting garbage collection works as follows.
All objects dynamically created via the std: :shared_ptr constructor or the std : :  convenience function have an associated reference count.
When the executing program creates a new  managed by a std : :shared_ptr , it sets the shared pointer 's reference count to 1.
After executing the following statement: auto  = std::<Widget>(3) ;.
Both  and  share the same  and share the same reference count.
If we finally reassign : = nullptr; the reference count of the  containing 3 drops to zero.
The std : : sha red_pt  class has a custom assignment operator.
The process of assignment alters the reference count for objects managed via these smart pointers.
When an assignment would cause a shared pointer's reference count for an  to be¬ come zero, the shared pointer can delete that  before attaching to the  being assigned.
The assignment would increase the reference count of the  being assigned by one.
The std: :shared_ptr class has a method named use_count that returns the reference count for the current  managed by the shared pointer.
Listing || T8_0_23|| (refcount_0_cpp) exploits this use_count.
Creating a 1 2 3 2 1 Destroying 0.
Nowhere in the 6 class can we see the   delete operators.
The destruction of the first  will destroy.
This results in the destruction of the second The destruction of the second  destroys its next pointer which leads to the distruction of the third , followed by the fourth , etc.
This cascading process ultimately destroys all the nodes in the list to which  points.
If this simple implementation of clea r achieves the same result as the more involved clear method in Listing 18_0_25 (intlist6_0_cpp) that uses a loop, why even consider the more complicated code.
As it turns out, the simpler method has a problem with very long lists.
To see how, suppose we have a long linked list.
When the clear method sets the std: :  to null, no other smart pointers will be pointing to the first.
The smart pointer reassignment in this case calls a method behind the scenes to destroy the object to which it points (the object to which  points; that is, the first  in the list).
This clean-up method does not return until the process is complete, and, for long lists, this process can be quite lengthy.
The destruction of the first  requires the destruction of its next pointer, headarrow_operatornext.
This headarrow_operatornext pointer points to the second  in the list.
The destruction of this headarrow_operatornext pointer triggers the destruction of the second  because no other std: : objects point to it.
This means that before 's clean-up method returns, the chain of events it sets off must invoke the clean-up method of headarrow_operatornext which leads to the destruction of the second.
The destruction of the second necessarily must destroy the next smart pointer of the second  (headarrow_operatornextarrow_operatornext).
This in turn leads to the destruction of the object to which headarrow_operatornextarrow_operatornext points (that is, the third in the list).
By this same process, the destruction of the third  in the list leads to the destruction of the fourth , and then the fifth , etc.
This cascade of method calls continue until it reaches the last in the list.
Two smart pointers point to the last : the next pointer of the next-to-the-last  in the list and the tai l pointer of the Li nkedLi st object itself.
The destruction of the next-to-the-last removes one of the smart pointers but not the other.
This means the clean-up method of the next-to-the-last cannot destroy the last.
This turns out not to be a memory leak, however, as the clear method also sets  to nullptr, so eventually the last  will be destroyed properly.
Everything appears to work perfectly—automatic resource management as advertised—so what is the problem for very long lists.
We left the activity of the LinkedList: :clear method as the destruction of the next-to-the-next-to-last smart pointer's clean-up method was destroying the next-to-the-last  in the list.
The problem is this: The destruction of the first  of the list is not complete until the destruction of the second  is complete.
The destruction of the second  is not complete until the destruction of the third  is complete, and so forth.
This means the clean-up method destroying the first  does not do its job, return, and then clean up the 's next pointer; it does not return until the second completes its clean up, which, of course, does not complete until the third 's clean up is finished, etc.
Theoretically, this chain of function calls eventually returns back to the action that initiated it—the reassignment of to nullptr, and for lists that are not too long, this is the case.
Each method invocation consumes some stack space, and for very long lists this call chain can be so deep so as to overflow the stack, causing the program to crash.
The scenario is similar to a recursive function that recurses too deeply.
On one system the program crashed when attempting to destroy a linked list containing 10,000 nodes.
The version of clear in Listing 18_0_25 (intlist6_0_cpp) iterates through the list setting the next pointers of the nodes it most recently visited to nullptr.
On the very next iteration the  pointer destroys the  during its reassignment from.
This means it must destroy 's next smart pointer, but the previous iteration set this to null.
This eliminates the chaining problem and allows the previous  to be destroyed with a single function call that returns immediately.
This version deallocates the list through a series of separate, isolated function calls that return immediately rather than a chain of function invocations that potentially can overflow the stack.
Our linked list class has an insert method that allows clients to add elements to the list, but it has.
IntList5, we could add the following method:.
The remove method is more complicated than the i nsert method because the i nsert method always adds new  to the back end of the list.
The remove method must be able to remove  from anywhere in the list—front, back, and anywhere in between.
The remove method for our IntLi st6 smart list class would look like the following:.
The flexible sorting examples in Listing [lX2| (flexibleintsort_0_cpp), Listing [T63] (loggingflexiblesort_0_cpp), and Listing 17_0_35|(polymorphicsort_0_cpp) allow us to arrange the  in integer vectors in creative ways and perform other interesting activities such as logging.
Those examples demonstrate the power of function pointers, inheritance, and polymorphism.
As flexible and powerful as these techniques are, they all contain one major limitation: they deal with vectors of integers only.
Consider the Comparer class from List¬ ing 17_0_33 (comparer_0_h) and Listing 17_0_34 (comparer_0_cpp), and the "flexible" selecti on_sort function from Listing 17_0_38 (loggingsort_0_cpp).
The selecti on_sort function accepts a vector of integers and a Comparer reference.
What if we need to sort a vector of double-precision floating-point numbers or a vector of std : : stri ng objects.
Unfortunately, all of this "flexible" code cannot handle this seemingly minor variation.
In this chapter we look at Cplus_plus's template mechanism that enables programmers to develop truly generic algorithms and data structures.
We will see how the standard Cplus_plus library has embraced the template tech¬ nology to provide a wealth of generic algorithms and data structures that greatly assist developers in the construction of quality software.
The situation is even worse for the following code: std::string  = "", 2 = "XYZ"; std:: << ( < 2) << '\n' ; std:: << (2 < ) << '\n' ;.
As another example, consider the following function that computes the sum of the  in a of integers: int sum(const std::<i nt>& v) {.
The second code fragment attempts to pass a  of double-precision floating-point values to the sum function.
Unfortunately, the sum function accepts only vectors that contain integers.
More precisely, sum accepts only arguments of type std: : <i nt>, and a std : : <double> object is not a std : : <i nt>.
The solution is easy; just copy and paste the original sum function and change all the occurrences of "i nt" to "double," creating an overloaded sum function: double sum(const std:: <double>& ) { double  = 0; for (double elem : ) += elem; return ; } This works, but the duplicated effort is unsatisfying.
These two overloaded sum functions are identical except for the types involved.
The actions of the two functions—the initialization,  traversal and arithmetic—are essentially the same.
In general, code duplication is undesirable.
A programmer that discovers and repairs an error in one of the functions must remember to apply the corresponding correction to the function's overloaded counterpart.
Both the less_than and sum functions share a common shortcoming: they are tied in some way to a particular data type.
It would be convenient to be able to specify the common pattern and let the compiler fill in the types as required.
In the case of less_than we would like to be able to write a function that can use the < operator on parameters of any type for which < is compatible.
For sum, we would like to create a generic function that works for vectors containing any numeric type.
Cplus_plus enables programmers to write such generic functions via templates.
A function template specifies a pattern of code, and either the programmer or the compiler supplies the exact type as needed.
The template keyword indicates that the function definition that follows is not a normal function definition but rather is a pattern or template from which the compiler can attempt to produce the correct function definition.
A function template is also known as a generic function.
The typename keyword indicates that the identifier that follows (in this case T) is a placeholder for a Cplus_plus type name.
The type parameter T stands for an actual type to be determined elsewhere.
T is an identifier and so can have any name legal for a variable, function, or class; some programmers prefer more descriptive names such as CompareType or TypeParam.
Single capital letters such as T, S, U, and V are popular type parameter names among Cplus_plus programmers.
Just as a regular parameter of a function or method represents a value, a template parameter represents a type.
You may use the reserved  class interchangeably with the keyword typename in this context:.
In Listing 19_0_2 (templatelessthan_0_cpp) the compiler generates three different  functions: one that accepts two integers, one that accepts two double-precision floating-point values, and one the accepts two string objects.
Although the programmer cannot see them in the source code, the compiler in effect creates the following literal function definitions:.
The compiler instantiates functions only as needed.
If Listing [|T9T2| (templatelessthan_0_cpp) did not contain the std : : stri ng objects, when processing the source code the compiler would not instantiate the version of  that accepts two std : : stri ng objects.
For efficiency purposes, the better way to write less_thanis.
Notice that parameters a and b are passed by reference, not by value.
This means the caller passes only the addresses of objects a and b and does not need to make copies to send to the function.
This can make a big difference if T represents large objects.
Since the parameters are const references, the function cannot change the state of the caller's actual parameters; therefore, the function offers call-by-value safety without the overhead of copying the parameters.
This is because the template definition specifies that its two type parameters are identical.
The literal 2 is an i nt, and the literal 2_0_2.
The compiler can automatically instantiate  functions that accept two i nts or two doubles but not mixed types.
One solution requires the programmer to explicitly instantiate the function a shown here: std:: << <i nt> (2, 2_0_2) << '\n' ; This forces the compiler to instantiate and call the integer version.
The compiler will issue a warning about truncating the 2_0_2.
The statement std:: << <double> (2, 2_0_2) << ' \n ' ; would use the double-precision floating-point version of , and it compiles cleanly with no warnings since widening the i nt 2 to a double is automatic.
We can rewrite the  template function to avoid the need for explicit instantiation.
For the most flexibility, we can express the  template function as.
While this more flexible  template function allows us to compare mixed numeric expressions, in general it makes more sense to expect the two parameters to be the same type.
Returning to our  summation function, we can express sum generically as.
The angle brackets (<>) that follow the template keyword contain declarations of template parameters.
The compiler generates these automatically and secretly.
The programmer never sees these instantiated template functions because they do not appear in any source code.
Unlike the preprocessor that sends a modified version of the source code to the compiler (see Section |1_0_2| to review the preprocessor's role in the program's build process), a modern Cplus_plus compiler generates the machine language versions of these instantiated functions directly from the programmer's source code.
Recall our swap function from Listing 10_0_19 (swapwithreferences_0_cpp).
Here the type parameter's name is This swap function works fine, but we do not need to write such  function ourselves; the Cplus_plus standard library includes  std : : swap template function that does the same thing as our swap function shown above.
The following function will print the contents of   of any type:.
Notice that all the functions except for mai  are  functions.
The selecti on_so rt function is the.
This explicit instantiation is required because the compiler cannot automatically instantiate the  function without an actual call to the function passing real parameters, and  pointer to  function is not  function invocation.
At this point in the program we are not calling the  function but only passing  pointer to it.
Calling it would provide the necessary type information to the compiler via the actual parameters used, but  pointer to  function does not contain parameter information.
The compiler needs the assistance of this explicit template instantiation.
The call to swap within selection_sort is actually invoking the std : : swap function  the standard library.
The # nclude <uti li ty> directive brings in the declaration for std : : swap, which itself is  template function.
The compiler can instantiate an actual function   template function only if the type substituted for.
The expression (foutl, 2) is illegal because no < exists to compare two std : : ofstream objects; thus, the compiler cannot produce the machine language that represents.
When programmers use templates incorrectly or construct incorrect template functions or classes, the compiler can detect and report the problems.
All current Cplus_plus compilers share one weakness with template processing: poor human-readable error messages.
The error messages the compiler produces in these situations tend to be lengthy and difficult to decipher even for experienced Cplus_plus programmers.
This is because the compiler bases its error messages on its processing of the instantiated code, not the original un-instantiated code.
Since programmers see only the un-instantiated source, deciphering the compiler's template error messages tends to be more challenging than usual.
Other types such as floating-point and programmer-defined types may not be non-type template parameters.
The Cplus_plus Standard Library contains many  functions, some of which we have seen already:.
With class templates we can specify the pattern or structure of a class of objects in a type-independent way.
The class template mechanism is a key tool for creating generic types.
As a simple example, consider a basic Point class that represents two-dimensional point objects.
Mathematical point objects should have real-valued coordinates that we can approximate with double¬ precision floating-point values.
A point on a graphical display, on the other hand, better uses integer coor¬ dinates because screen pixels have discrete, whole number locations.
Rather than providing two separate classes, we can write one class template let the compiler instantiate.
As with Listing [|733 (comparer_0_h), the Comparer objects specified in Listing jl977j (genericcomparer_0_h).
Without Cplus_plus templates, we would have to copy the IntLi st code and modify it so it works with st ri ng objects instead of integers.
We could call this class St r  ngLi st.
Note that the code in the IntLi st and Stri ngLi st classes would be almost identical; the only major difference would be the type of elements the list can hold.
Cplus_plus's class template feature is ideal for designing generic container classes.
LinkedLi <i nt> list;.
Destroying node 23 (16084476).
Destroying node 9 (16085084).
Just as we may instantiate function templates with multiple different types within the same program, we can do the same for class templates.
The class template Li nkedLi st in Listing 19_0_9 (linkedlist_0_h) makes the following client code possible: <int> intlist;.
The std: : vector.
Write a generic function named is_ascending that accepts a std: :vector containing any comparable by o p e r a t o r <.
The function should return t r u e if the  in the vector appear in non-decreasing (or ascending) order; otherwise, the function should return false.
Write a generic function named is_member that accepts a argument of any type comparable by == and a second argument consisting of a std : : vector containing  of same type as the first argument.
The function should return true if the first argument is a member of the second argument; otherwise, the function should return false.
Augment Listing 19_0_9 (linkedlist_0_h) by adding a method named prepend that adds an  to the front of a generic linked list.
Augment Listing [T9T9| (linkedlist_0_h) by adding an == method that returns true if two generic linked list contain exactly the same  in exactly the same order; otherwise, the method returns false.
Also provide a one-line  _0_= method that utilizes your == method.
Chapter[l9]introduced the mechanics of generic programming with templates.
The Cplus_plus standard library leverages templates to provide a rich collection of standard generic containers and algorithms to manipulate the containers and process the  they contain.
This part of the standard library commonly is known as the standard template library , or STL for short.
As its name implies, the STL contains a number of generic functions and classes built with templates.
We have seen the std : : vector class (Chapter 11).
The design of the containers and their iterators make the STL's generic algorithms possible.
The algorithms provided by the STL are powerful and flexible, but they also are somewhat arcane and can be difficult to use for casual Cplus_plus programmers.
In this chapter we explore some of the features of the STL, providing examples that illustrate its capa¬ bilities.
We are familiar with one STL container: std : : vector.
A vector object manages a primitive C array.
C arrays come in two varieties: static and dynamic (see Section 11_0_2|.
Vectors manage dynamicallyallocated arrays.
A vector object can expand as needed the storage space for its low-level array.
The STL provides an equivalent to a static array in its std : : array class.
A programmer must specify the size of a std : : a r ray object when declaring it.
The following code creates a std : : a r ray that can hold 10 integer values:.
Note that the second template parameter is a non-type parameter (see Section |19Tl| specifying the size of the array.
Besides not being able to modify the array's size through methods such as push_back, std: :array objects work very much like std: :vectors.
Array objects keep track of their size, unlike primitive C arrays.
In Listing 19_0_9 (linkedlist_0_h) we developed a generic linked list class named Li nkedLi st.
That was good practice dealing with generic types, but our work really was re-inventing the wheel because the STL provides the generic std: :list class.
The STL implements a linked list with pointers connecting a node to both its successor node and predecessor node.
A list with both forward and backward pointers is known as doubly linked list.
Listing 20_0_1 (stdlistmain_0_cpp) is the third and final variation of our list programs.
Listing |18_0_5| (listmain_0_cpp) used a custom class to implement a singly linked list of integers.
A priority queue is a data structure that allows clients to store objects with various priorities or rankings.
Clients can insert the objects in any order, and the priority queue always will serve (remove) higher priority objects before lower priority objects.
A properly designed priority queue supports very fast insertion and removal operations.
The Cplus_plusstandard library provides the std : : pri ori ty_queue class.
Note that the priority queue serves larger values before smaller values regardless of their insertion order.
It equates larger-valued numbers with a higher priority.
If we want to change the notion of priority so that lower-valued numbers are considered higher priority than larger numbers, the std: :priority_queue class provides the flexibility for us to do so.
We must define a special class or struct that provides a public method named  ().
This method must return a Boolean result and accept two arguments of the same type as the elements held by the priority queue.
Consider the following Cmp type:.
The first output line indicates it is false that 3 < 2.
The second line reveals that it is true that 2 < 3, and in the last line we see that it is false that 3 < 3.
The expression op (2, 3) looks like a call to the function named op, but it really is just syntactic sugar for op_0_()(2, 3).
We see that we really are invoking the method nameed operatorQ on behalf of the op object.
Listing j20~4| (reversepriority_0_cpp) provides the complete code for apriority queue that holds integers and.
Since we are providing a custom comparer class to modify the default priority queue ordering, the.
The std : : pri ori ty_queue class serves as a wrapper around an exiting container type.
Cmp is the type of comparer object that the priority queue will use to order its items.
Armed with the ability to precisely specify how the priority queue defines priorities, we can store any type of objects in a priority queue.
By default, the std : : pri ori ty_queue class can store any type of objects that can be compared using the < operator.
This includes the basic numeric types (i nt, double, unsigned, etc_0_) and std: : string objects.
The std: : complex class (see Section 13_0_4) models mathematical complex numbers.
The relational operators <, <, >, and > have no practical mathematical meaning in the context of complex numbers; therefore, Cplus_plus does not automatically support operator < comparison between two std : : complex objects.
We can define our own ordering, however.
Let a + bi and c + di be two complex numbers.
We will define a + bi to have higher priority that c + di if the distance between a + bi and 0 on the complex plane is less than the distance between c + di and 0.
The distance between a + bi and 0 is \/a 2 +b 2 , and the distance between c+di and 0 is \Jc 2 + d 2.
The following custom comparer class implements this notion of complex number priorities:.
Custom comparer objects allow us to place items in  priority queue that inherently are not numerical themselves.
Suppose we are writing part of  messaging system that processes text messages.
In addition to the text in the message, each message has  integer priority in the range 1_0__0_.
Lower numbered messages have priority over messages with higher numbers.
Instances of the following struct model our simple messages:.
This means their elements appear.
Section 11_0_2 demonstrates how we can use  pointer to access the elements within an array.
A vector is an object that manages  primitive array, and the developers of the vector class designed vectors to look and feel as much as possible as arrays.
They adopted the square bracket ([]) operator to access elements.
They also devised  way for programmers to use pointer-like objects to access the elements within  vector.
These pointer-like objects are called iterators.
An iterator is an object that allows  client to traverse and access elements of  data structure in an implementation independent way.
Cplus_plus defines two global functions, std : : begi n and std : : end, that produce iterators to the front and back, respectively, of  data structure like  vector or static array.
Con¬ tainers defined int the STL provide begi n and end methods that serve the same purpose; for example, if v is  std: : vector, std : : begi n ( v) returns the same iterator as the call v.
Functions in the standard library that accept iterators as arguments rather than arrays or vectors work equally well with both vectors and arrays.
Since they accept iterator arguments, these standard functions additionally are able to work with other, more sophisticated data structures.
We will examine some of these standard functions later in this chapter.
In order to behave like  pointer, an iterator object provides the following methods:.
The syntax is exactly like pointer dereferencing (see Section [l0_0_7] ).
The syntax is exactly like pointer arithmetic (see Section [LL2j).
The type of  is std : : vectorci nt> : :iterator This complicated expression indicates that i terator is  type defined within the std : : <i nt> type.
A shorter way to express this statement takes advantage of the compiler's ability to infer the variable's type from its context:.
While the std: :begin function returns an iterator pointing to the first element in  data structure,.
As such, we never attempt to dereference the iterator; the expression *i ter in this case is undefined.
We normally use the iterator returned by the std : : end function to test to see if we are past the end of our data structure.
Listing 20_0_8 (iteratorloop_0_cpp) demonstrates.
We can use the  methods begi n and end instead of the std : : begi n and std : : end func¬ tions.
Listing |20_0_9| (iteratorloopmethods_0_cpp) is a modified version of Listing (2(T8| (iteratorloop_0_cpp) that.
Any type for which the std: :begin and std : : end functions have been overloaded may participate.
The following code.
Section 11_0_2 that we can manipulate pointers with pointer arithmetic.
If p points to the first element of an array, p + 5 points to the sixth element in the array (because p + 0 is the same as p).
The expression p + + makes the p point to the next element in the array, while pminus_minus moves p backwards one position.
We can use similar arithmetic with iterators as Listing pOTl 1 [ (iterarith_0_cpp) illustrates.
Subtraction is not an option for these kinds of iterators.
We can specify a range with a pair of iterators; one iterator points to the first element in the sequence, and the other iterator points to the position just past the end of the sequence.
The global functions std : : begi n and std : : end fit well into this definition of range.
Suppose vec is a.
The two iterators std : : begi n (vec) and std : : end (vec) span the.
Section [ TL2| introduced a technique for traversing an array via a pointer range.
Rather than passing an array (literally the address of the first element) and its size (number of elements) to a traversal function, the range-based approach passes the array (again, literally a pointer to the first element) and a pointer to the position just past the end of the array.
Notice how the pointers in range-based array technique correspond directly to the iterator objects returned by the std : : begi n and std : : end functions.
Since iterator objects behave like pointers, we can write truly generic code that can process both arrays and vectors.
The following function uses iterators to count the number of times a value appears within a :.
Type T elements must be.
The first two parameters of selecti on_so rt are generic, and the code within the function treats these two parameters as if they are pointers.
Since ¬ ator objects behave exactly like pointers to the extent exercised within selecti on_sort, the compiler can instantiate the template to accept pointer or iterator arguments.
Similarly, the pri nt function works equally well with both pointer ranges for arrays and iterators for vectors.
The main function demonstrates the flexibility of print and selection_sort functions by sending them both array pointer ranges and  iterators.
Behind the scenes the compiler will automatically instantiate two overloaded pri nt functions and two overloaded selecti on sort functions.
Clients may use vectors, arrays,  any sequence type that overloads the begi   end functions.
Clients may work with sequences that contain elements of any type that supports the <  = opera¬ tors.
Clients may customize the element ordering.
One of the primary benefits of functions is that we can write a function's code once  invoke it from many different places within the program ( even invoke it from other programs).
Ordinarily, in order to call a function, we must know its name.
Almost all the examples we have seen have invoked a function via its name.
Listing 10_0_20 (arithmeticeval_0_cpp) in Section 10_0_10 provided examples of invoking functions without using their names directly.
There we saw a function named evaluate that accepts a function as a parameter:.
The answer, of course, is that evaluate invokes the function passed in from the.
The code in the evaluate function demands that callers send a function as the first parameter.
Does this mean we have to write a separate function with a name in order to call evaluate.
Once we create a function with a name it is available to be called from anywhere within the program after its definition or declaration.
What if we want to ensure that our function will execute exactly one time  only when invoked by evaluate.
The term lambda comes from lambda calculus (see http://en_0_wi ki pedia_0_org/wiki/Lambda_ calculus), a function-based mathematical system developed by Alonzo Church in the 1930s.
Concepts from lambda calculus led to the development of the modern computer.
The lambda calculus is the basis for modern functional languages like Haskell  F#.
The [ _0__0__0_]( _0__0__0_){ _0__0__0_} construct identifies a lambda function; thus, the first argument being passed to evaluate is indeed a function that takes two integer parameters.
Notice that result of passing the lambda function here is the same as passing the multi ply function fromListing 10_0_20 (arithmeticeval_0_cpp) —both compute the product of the two parameters.
One interesting aspect of lambda functions is that they can be used to create closures.
A closure is a unit of code (in this case a function-like object) that can capture variables from its surrounding context.
These captured variables then can be used outside of their original context.
In order to demonstrate closure, we first must explore function objects.
A std : :  uncti on object works like a function pointer (see Section 10_0_10).
The std : :  uncti on.
Note the type parameter i nt ( i nt , int) inside the angle brackets.
The first i nt represents the func¬ tion's return type.
The two i nts inside the parentheses specify the function's parameters.
Function objects take the place of function pointers.
Function pointers are available in C as well as Cplus_plus, but C does not provide function objects.
Function objects provide capabilities above simple function pointers, including the ability to manage closures.
Note that mai n creates a function via the lambda expression that it passes to evaluate2.
The variable a appears within the capture square brackets.
This makes a's value available to whatever code invokes the lambda function.
In this case the evaluate2 function can see a's value even though a is local to mai n is not passed to evaluate2 as an explicit parameter.
We say the lambda function captures the variable a.
When evaluate2 invokes the function sent by the caller, evaluate2 has no access to a variable named a.
The a involved in the conditional expression is captured from mai n.
This is an example of a closure transporting a captured variable into a function call.
For an example of a closure transporting a captured local variable out of a function, consider List¬.
Cplus_plus's lambda capture mechanism provides capabilities that go beyond the examples shown here; for example, the expression &a within the square brackets would capture variable a by reference, allowing an external context to modify the variable.
Note that when a closure captures a variable by reference, that variable must exist in its original context as long as the closure is viable.
This means you should not attempt to capture a local non-stati c variable of a function by reference by a closure to be returned by that function.
The local variables disappear when the function returns, and so the references will refer to garbage values.
If you are unfamiliar with calculus, all you need to know is that the derivative of a function is itself a function; the above formula shows how to transform a function into its derivative.
The process of computing a derivative is known as differentiation.
The lim/,_,o notation indicates that the answer becomes more precise as the value h gets closer to zero.
Letting h be exactly zero would result in division by zero, which is undefined.
The trick is to make h as small as possible, keeping in mind that the computer's floating-point values have limitations.
Based on the mathematical definition we can define a Cplus_plus function that computes the derivative of another function, as shown here:.
The function that derivative returns is a closure because it captures the function parameters and h.
Our deri vati ve function allows us to compute the derivative of a function at a given value.
This is known as numerical differentiation.
Another approach (the one emphasized in calculus courses) uses symbolic differentiation.
Symbolic differentiation transforms the formula for a function into a different formula.
The details of symbolic differentiation are beyond the scope of this text, but we will use one of its results for a particular function to check our computed numerical results.
The flexible design of the STL containers and their iterators make possible the STL's generic algorithms.
The algorithms provided by the STL are powerful and flexible, but they also are somewhat arcane and can be difficult to use for casual Cplus_plus programmers.
The STL algorithms are best viewed as the building blocks for more specific tasks required by applications.
In order to use the STL algorithms you must include the following preprocessor directive: ffinclude <algorithm> One relatively simple algorithm is std : : for_each.
The for_each function applies a unary function to each element in the container.
Like the other algorithms we will see, f o r_each uses an iterator to drive a loop behind the scenes.
The following statement prints out each element in a std : : Ti st object called seq holding integers:.
The std : : iota function, delared in the <numerics> header, is a simple but handy function that fills a container with ascending numbers.
The std : : i ota function allows us to replace the following code:.
The std : : copy function copies the elements from one container to another.
The std : : transform function works like std : : copy except it expects a function that that can modify the copied elements.
Both functions require the begin and end iterators from the source container and the begin iterator of the destina¬ tion container.
Listing 20_0_21 (testtransform_0_cpp) illustrates the use of std : copy and std: :transform.
The std: : copy function may seem superfluous since operator^ for vectors also performs a.
The std : : count serves the role of our count_value function from Listing 20_0_13 (genericcount_0_cpp).
The last argument to std: :count_ifisa function that accepts a single value of the type the container is declared to hold.
The function returns true or false.
A function that returns a Boolean result is known as a predicate.
Some STL algorithms, like std : : count_i f, expect a predicate to allow them to process only elements that satisfy the predicate.
As another example, the std : : copy_i f function copies only elements from one container to another that satisfy a given predicate.
Listing 20_0_26| (copyevens_0_cpp) uses std : : count_i f and std : : copy_i f to copy relevant portions of vectors.
Observe that in Listing 20_0_26 (copyevens_0_cpp) we assigned the lambda functions to the variables pri nt and i s_even.
This is so we did not have to write the same lambda expressions twice, for printing seq and seq2 and for testing evenness in for count_~i f and copy_~i f.
Predicates do not have to be lambda functions—they can be global named functions as well, but lambda function often are more convenient.
We can use the std : : generate function to populate a container based on a generating function.
The first two lines of the output will always be the same, but the last line will vary from one run to the next.
The std: :accumulate function applies a binary operation to all the elements of a container to produce a single value.
Listing 20_0_29 (testaccumulate_0_cpp) shows the std: :accumulate function in action.
This is the expected output,  2+1+3 +4 + 1+2=13, and 23x42 = 48.
While it may seem good in theory, this approach is not efficient and should be avoided.
Each applica¬ tion of the + concatenation  creates a new  : : stri ng object from two existing : :.
Especially for longer lists, this repeated  creation process unnecessarily wastes time and space.
For a container that contains n strings, the  : : accumulate function will cre¬ ate n — 1 new   on its way to produce the final accumulated  result.
Numeric arithmetic does not create new , and so : accumulate is best used on containers holding numbers.
This  appends characters onto the end of an existing  object, thus avoiding the creation of new In this case a simple familiar for loop is preferable to a sophisticated STL algorithm.
The following code illustrates a more efficient solution:.
If the number of strings is small, it does not make much difference.
It is only when the collection of strings to concatenate becomes large that we will detect a performance difference.
Listing 20_0_30 (teststrconcat_0_cpp) tests the two algorithms.
Some runs show  : : accumulate to be faster, but the differences are usually single-digit milliseconds.
We can use the std : : remove and std : : remove_i f functions to remove elements from a con¬.
Neither remove nor remove_i f by themselves achieve the results we generally desire.
The first line shows the contents of the original vector.
The second line shows the modified vector with 10 removed.
Element 10 definitely is gone, but the vector contains the same number of elements as before.
A closer inspection reveals that all the elements that followed 10 in the original vector have been shifted forward one position.
It is as if the removal of 10 left a hole in the vector that the following elements had to shift forward to fill.
That would be fine, but the last element, 19, was copied forward and remains the last element in the vector.
In order to actually remove the elements and make the resulting container smaller, we must couple remove or remove_i f with the container's erase method.
The erase method accepts two iterators establishing a range of elements to delete from the container.
Listing 20_0_34 (vectorerase_0_cpp) shows how to remove a section of a vector using the std : : vector <T> : : erase method.
The return value of the call to remove returns an iterator pointing to the second occurrence of 19 in the second line of output.
In the third line of output the call to remove_i f returns a pointer to second occurrence of 19 as well.
Note that in both cases the iterators point to the first element in the remaining values that ought to be erased from the vector.
The combination of std : : vector <T> : : erase and std : : remove is known in the Cplus_plus community.
The STL contains a number of other algorithms to process generic containers.
Some examples include.
We now are creating our own names for functions and types within the programs we write.
Using the blanket usi ng directive can present problems at times because the std namespace contains hundreds of type and function names, and it is too easy for a programmer to accidentally reuse for another purpose a name already claimed by the std namespace.
Such name conflicts lead to problems during software development, and since the development process generally has enough other challenges to address, it is best practice to avoid the blanket usi ng directive.
Listing 20_0_36 (maxvector_0_cpp) defines a max function that computes the number of times the maximum.
The mai n function tries out the function on a sample vector.
Notice the blanket usi ng namespace std directive that makes all the function and type names in the std namespace available to this program.
This has not been our common practice so far, but you frequently will encounter this approach in published Cplus_plus code.
This program works correctly, however, as it prints the following: The Cplus_plus standard library contains a function named i s_sorted, declared in the <algori thm> header.
The standard is_sorted performs the same task as this is_sorted, except that the standard function, striving to be as generic as possible, accepts two iterators instead of the container itself.
In preparation to replace our i s_sorted function with the standard i s_sorted function, we add the following directive to the top of the code with the other #i includes:.
Before the inclusion of <algorithm>, the only  the compiler knew of was the one defined in Listing 20_0_36 (maxvector_0_cpp).
This  function expects a reference to a std : :  object.
The std : :  class contains a constructor that accepts an initializer list.
The compiler, therefore, automatically can create a  from an initializer list.
The compiler automatically uses the initializer list to create a  object and sends it off the  function for processing.
The inclusion of the <algorithm> header provides the declaration of std: : that accepts, among other arguments, an initializer list.
When the compiler matches a function call to its correspond¬ ing definition, it always seeks the best match for the arguments passed.
Since the std : :  accepts an initializer list, it better matches the calls in the mai n function.
Remember, our purpose for including the <algori thm> header was to gain access to i s_sorted, and we had no intention of changing our  implementation.
Unfortunately, the compiler, following a well-established and sensible algorithm, silently (no warnings or errors) substituted a different function to change the behavior of our program.
This is prime example of why the blanket using namespace std directive can be dangerous.
Identifiers (variable names, function names, and type names) should be meaningful, clearly commu¬ nicating their intent.
Well-chosen English words or simple variations of common words are ideal.
This means it is quite likely that a library developed by a team of developers would contain function names and type names that also appear in a different library developed by a different team of programmers.
Each library used separately is not a problem, but issues can arise when building a software system atop multiple libraries; for example, consider the task of building a program that models and visualizes the spread of an infectious agent.
Such a system could make good use of the following libraries:.
Ideally, any code meant for widespread use should be part of a namespace.
A company developing.
In Cplus_plus it is easy to put the functions and types we develop into custom namespaces.
Suppose we wish to make the functions from Listing 120_0_37 (bettermaxvector_0_cpp) available to a wider audience.
List¬ ing 20_0_38 (vectutils_0_h) and Listing 20_0_39 (vectutils_0_cpp) package the two functions into a namespace named vectuti Is.
Listing 20_0_38 (vectutils_0_h) provides the function declarations, and Listing 20_0_39 (vectutils_0_cpp) contains the function definitions.
Just as with the std namespace, it is best to avoid blanket usi ng directives for custom namespaces.
Since nested namespace names can become quite lengthy, Cplus_plus supports namespace aliases, as in.
This namespace alias makes it possible for us to call  with the more compact statement std:: << ::(9_0_4) << '\n' ; Nesting allows developers to organize better the components within libraries; for example, a company may.
Both of these data structures represent linear se¬ quences of elements.
Vectors and arrays are convenient for storing collections of data, but they have some limitations.
For one, we locate an element within a vector or array based on its position (index).
To retrieve a specific element we must supply its index.
While this approach is fine for many applications, in other situations this access-by-index approach is awkward or inefficient.
In contrast, an associative container permits access based on a key, rather than an index.
Unlike an index, a key is not restricted to an integer expression.
The Cplus_plus standard library supports three kinds of associative containers: set, map, and unordered_map.
Here we will examine each of these types in some detail.
Unlike Cplus_plus vectors, arrays, and lists, mathematical sets are unordered and may contain no duplicate elements.
The Cplus_plus std: : set container, like mathematical sets, ignores any attempts to include duplicate elements; however, std : : set objects do order their elements internally in a particular way.
This ordering permits very fast access to.
The order actually is ascending order in all of our tests in Listing j21_0_11| (settest_0_cpp), and this is not a coincidence.
Also observe that sets do not admit duplicate elements.
The implementation of the std : :  class on all the major Cplus_plus libraries use a red-black tree (see https://en_0_wikipedia_0_org/wiki/RedUblack_tree) as the internal data structure.
The or¬ dering imposed by this internal data structure enables very fast access to the 's elements.
A red-black tree permits binary search (see Section; 12_0_3_0_2).
A  determines the order of its elements via operators The <  works with all the primitive numeric types (int, double, float, unsigned, etc_0_).
The < is defined for std: :stri ng class instances to compare two string objects lexicographi¬ cally.
Instances of any type we wish to store in a std : :  must support the <.
In Listing 21_0_1 (settest_0_cpp) we define a new  type, MyClass.
We must ensure that it is possible to compare two MyClass instances using the <  in order to put MyClass objects in a.
To achieve this, we define < as a global function that compares two MyClass objects.
This allows us to create a  of MyClass objects.
Also, any duplicate elements in the  will appear only once in the  object.
Unlike in mathematics, all sets in Cplus_plus must be finite.
Cplus_plus supports the standard mathematical  operations of intersection, union,  difference, and sym¬ metric difference.
These functions are part of the algorithms library, and thus they are designed to work with as wide an array of containers as possible.
The downside of this flexibility is they are somewhat arcane and awkward to use, as Listing 2Q (setopsbuiltin_0_cpp) shows.
The catch is that the elements in the containers must be ordered for these functions to work properly.
We saw that std : :  objects are ordered automatically.
Since std : :  objects do not impose an order on their elements, we must first sort any vectors we wish to send to the standard intersection and union functions.
Listing 21_0_4 (setops_0_cpp) implements operators* and operator | to work with  objects to pro¬ vide a more convenient interface to programmers.
The & operator represents  intersection, and | repre¬.
The real value of the  class comes from the speed of access it provides to its elements.
As an associative container, we do not access an element via an index as we do with a  or array.
In fact, std : :  does not even provide operator [].
We want to place an item into a  and retrieve it later without regard to its location within its internal data structure.
Recall the std: :find algorithm provided by the STL (see Section 20_0_5).
Given an iterator to the beginning of the container, an iterator just past the end of the container, and an item to find, std : :find returns an iterator that points to the sought element within the container.
If the container does not contain the sought element, std : : find returns the iterator that equals the just-past-the-end iterator.
The std : : find function works with a std: :  object just as it does with other containers, but the std : :  class provides its own find method that exploits the structure of the data within the  object to locate elements very quickly.
Listing 21_0_5 (setvsvector_0_cpp) illustrates the use the std: : : : find method, comparing the time to locate an element in a  versus the time to locate the same element in a  containing the exact elements contained in the.
The  and  objects within Listing [2T3) (setvsvector_0_cpp) each contain the integers 0,1,_0__0__0_, 249,000.
Note that the  contains the elements in ascending order.
We then create a  containing pseudo¬ random values in the range 0,1,_0__0_.
The program will search for these random values within each container.
The program measures the time it takes to complete the searches.
The output Listing |21,5| (setvsvector_0_cpp) reveals the dramatic difference in performance between the std : : find function on a  and the std : : : : find method with a :.
We see on this particular run that the  search required almost one and a half minutes to complete, while the  search took only about a quarter of a second.
While the exact numbers will vary from run to run and be higher or lower depending on the host machine, the disparity of times will be consistent.
The two data structure contain exactly the same elements, and program uses the exact same search values.
The std : : 's search is so much quicker because std : : : : fi nd performs binary search on its internal data structure, while std : : find uses linear search (see Section 12_0_3_0_2).
That one thing might be an integer or a single object like a or an instance of some other class, but it must be just one thing.
What if we need a function to return more than one thing.
We could put the desired return values into a  and return the.
The caller then would extract the components from the  upon the function's return.
Unfortunately, this will not work if the multiple elements to return have different types.
The container types we have examined thus far—vectors, arrays, lists, and sets—have been homogeneous; that is, their elements all have the same.
We could define a struct or class that has fields of different types, but this creates a , , In a large program we may need many different structs to cover all the combinations of multiple-valued return types we need.
Providing a  struct or class introduces a   into the system, thereby increasing the system's complexity.
All we want is to be able to package multiple elements together for some simple purpose, without needing to create a.
Fortunately, Cplus_plus provides the std: :tuple generic class in its.
The arguments used when making a  can consist of literals, variables, and other more complex expressions.
Extracting the components of a  is known as unpacking.
Listing |21_0_6| (simpletuples_0_cpp) shows how to use the std : : ti e function to assign the components of a  to individual variables in one statement.
The std : : ti e function is a generic function that works with any types storable within a.
If we wish to extract just one element from a , we can use the std : :  generic function.
The generic std : :  function is parameterized by an integer that serves as an index into the.
Cplus_plus supports another way of unpacking tuples.
Structured binding is similar to std : : ti e but can be used only when declaring the variables used to represent the components of a.
With structured binding we can rewrite the following code: std::string ,  = "Jan";.
Note that we can use this special syntax only when declaring the variables to be bound to the components of the.
This copies the components of the  into the newly declared.
We can specify that the structured binding be done by reference, as in the following: auto& [, , ] = ; In this case each  within the binding becomes an alias to a component of the.
In the previous code fragment above, reassigning  will similarly modify the second component of.
Structured binding is especially convenient when processing tuples within loops.
Listing ||21_0_7| (tupleloop_0_cpp) uses structured bindings by reference to reassign the elements in a vector of tuples.
The Cplus_plus standard library supports a special case of std: : tuple called std: :pair.
As Listing 21_0_8 (pairtest_0_cpp) shows, we can use std: :tie, std: :get, and structured binding with a std : : pai r object, and they work exactly as they do with std : : tuple.
Since pair objects always contain exactly two elements the std : : pai r class provides the public fields fi rst and second through which we can unpack a pair using simpler syntax.
We say each integer in the map object has an associated stri ng key.
In the expression std : : map<std : : stri ng ,  nt> the first template argument (here std: : stri ng) indicates the map' key type, and the second template argument indicates the type of values stored in the map (here  nt).
Listing 21_0_9 (simplemap_0_cpp) provides a simple example that uses a Cplus_plus map object.
Keys must be unique; that is, no two values in an unordered map can have the same key.
Duplicate values are allowed; that is, two different keys can have the same value, but two different values cannot have the same key.
This is similar to a vector or array, in that the same value may be stored at different indices, but only one value may be associated with a particular index.
One big difference between a map and vector is a vector of size n allows any index in the range 0_0__0_.
Consider the statement container [""] = 22; if the key within the square brackets ("") does not exist in the map before this statement executes, the statement adds the key to the map and pairs it with the  on the right of the assignment operator.
If the key already exists in the map, the statement replaces the  previously associated with the key with the new  on the right of the assignment operator.
Consider accessing a  with a given key rather than assigning the ; the statement std::cout << container[""] << ' \n' ; prints the  associated with the key "".
If "" is not currently a key in the map, this statement will add the key "" with the default  for the type of  declared for the map.
For integers, the default  is 0.
As other examples, the default floating-point  is 0_0_0, the default string is the empty string, " ", and the default bool  is false.
You should use a map object when you need fast and convenient access to an element of a collection based on a search key rather than an index.
Consider the problem of implementing a simple telephone contact list.
Most people are very familiar with the names of their friends, family, and business contacts but can remember only a handful of telephone numbers.
A contact list associates a  with a telephone.
It would be inappropriate to place the names in a vector, for example, and locate a  using the associated phone  as an index into the vector.
This look-up method is backwards—we do not want to find a  given a phone ; we want to look up a  based on a.
Besides, each phone contains many digits, and we would not need or want to have a vector with indices that large—most of the space in the data structure would be unused.
In our situation a person or company's  is a unique identifier for that contact.
In this case the is a key to that contact.
A map is an ideal data structure for mapping keys to values.
It allows for the fast.
Listing [21_0_11 (translateif_0_cpp) can successfully translate eight Spanish words into English.
If we wish to increase the program's vocabulary, we must modify the program's logic by adding another else if block for each new.
Listing |21_0_12[ (translatemap_0_cpp) provides a better approach; it uses a map to assist the translation.
The words will become the key and value items in our map when the program runs.
This is a significant difference if wish to  enough words to make the program practical.
The std : :u no rdered_map type is another example of a Cplus_plusassociative container.
A std : : unordered_ma object works like a std: :map object, but they each use a different underlying data structure.
Most std : : map implementations use a red-black tree (see https://en_0_wi kipedia_0_org/wiki/Red-bIack_ tree) to store the map's elements, while an unordered map uses a hash table (see https://en.
This difference makes an unordered map faster in general than a map for accessing an element via its key.
Map objects trade raw speed for the ability to access effi¬ ciently elements in order based on their keys.
Unordered map objects truly are unordered; they provide no efficient way for clients to traverse their key-value pairs by order of their keys.
In order to use a std: :unordered_map object within a program we must use the appropriate.
Like the std : : map class, the std : : unordered_map class is a template class, so when declaring an instance we must supply type parameters within angle brackets as shown in the following example:.
The ordering of the elements in an unordered map is not really random; a special function known as a hash function determines their position within the unordered map at the time of their insertion.
This hashing process makes unordered maps slightly faster than regular map objects.
If the speed of access is critical and accessing the elements in order is not necessary, a Cplus_plus std : : unordered_map is the better choice.
Associative containers are useful for counting things.
We have experience using variables to count; recall Listing [Oj (countup_0_cpp) and Listing [6_0_211 (startree_0_cpp).
These programs counted one thing at a time, so they each use just one counter variable.
In general, we need to use a separate variable for each count we manage.
Listing 21_0_14 (countnegnonneg_0_cpp) uses a function to count the number of negative and nonnegative numbers in a vector of integers and returns a Std : : pai r with the results:.
Note that we created a type alias (IntPai r) for the more complicated type (std : : pai r<i nt , i nt>).
This is not particularly helpful in this simple program (we only use the type in one place), but it illustrates that we can use the usi ng statement for type aliasing std: : pai r as easily as with std: : vector or any other more complicated looking type name.
We also simplified the return statement at the end of the count_neg_nonneg function.
The compiler knows the return type of the function (declared as IntPai r —a pair of integers), so it must return a pair object.
The curly brace notation without any other verbiage indicates the arguments to the std::pair<int, int> class constructor that it should use when creating the object to return.
The compiler automatically generates the machine code to call the pair constructor with the arguments within the curly braces.
Suppose we wish to keep track of the quantity of each letter that appears in a text file.
There are 26 letters in the alphabet, so we would need 26 counter variables.
Managing 26 different counter variables is inconvenient, so we could use a vector containing 26 integers.
The element at index 0 could store the number of As, the element at index 1 could keep track of the number of /is, etc.
An associative container may be useful but is not necessary to solve our problem.
Listing [21_0_16|| (lettercount_0_cpp) provides one implementation.
In this case we knew we needed to count 26 different things (letters), so we were prepared with 26 counters (26  elements).
The number of letters in the English alphabet does not change, so this approach works well.
So far so good, but what if we face a situation in which we must count multiple kinds of things, and we cannot know ahead of time how many kinds of things there will be to count.
How can we determine how many counter variables to use in a program that attempts to solve such a problem.
The answer is this: We cannot know how many counter variables we will need, so we must use a different approach.
With an associative container we can use the items we wish to count as the keys.
After reading the file the program prints.
A: 1 AMONG: 1 AND: 3 ANOTHER:1 ASSUME:1 BANDS:1 BECOMES:1 CAUSES:1 CONNECTED:1 COURSE: 1 DECENT:1 DECLARE:1 DISSOLVE:1 EARTH:1 ENTITLE:1 EQUAL:1 EVENTS:1 FOR: 1 GOD: 1 HAVE: 1 HUMAN: 1 IMPEL:1 IN: 1 IT: 1 LAWS: 1 MANKIND:1 NATURE:1 NATURE'S:1 NECESSARY:1 OF: 5 ONE: 1 OPINIONS:1 PEOPLE: 1 POLITICAL:1 POWERS:1 REQUIRES: 1 RESPECT:1 SEPARATE:1 SEPARATION:1 SHOULD: 1 STATION:1 THAT: 1 THE: 9 THEM: 3 THEY: 1 TO: 5 WHEN: 1 WHICH:3 WITH: 1 In Listing 21_0_17 (wordcount_0_cpp), since we cannot predict what words will appear in a document, we cannot use a separate variable for each counter.
Instead, we use the document's words as keys in a map object.
For each key in the map we associate an integer value that keeps track of the number of times the word appears in the file.
We use a map instead of an unordered_map so that we can list the words and their counts in.
If the map currently holds the string word, the expres¬ sion simply adds one to the integer value; it the string word does not appear in the counters map object, the statement first inserts the string word with an associated value of 0 and then immediately increments it to 1.
This is the exact behavior we need for our word counting program.
In this example the need for a map object is not as compelling as in Listing ||2 1,1 7 (wordcount_0_cpp), because in practice the length of English words is limited.
We could instead use a vector of 50 sets.
Only rarely used, highly technical words exceed 50 letters.
We could handle these "too-long" words in a special way, perhaps storing them in the  in the last position in the vector with other words of more than 49 letters.
Our program could use special processing for this  of long words if it ever becomes nonempty.
This approach under typical circumstances would result in a number of empty sets at higher indices because most English text contains words of at most about 20 letters.
The advantage of a map is that it stores only what it needs.
Listing 21_0_19| (groupwordsvector_0_cpp) is close transliteration of Listing [21_0_181 (groupwords_0_cpp) that uses a vector in place of a map.
We know a program can use variables to remember values as it executes.
A programmer must be able to predict the number of values the program must manage in order to write enough variables in the code.
An associative container provides an opportunity to create an arbitrary amount of new  during a program's execution.
We will consider a simple problem that demonstrates the value of the dynamic provided by unordered_map objects.
Section[103]introduced the Fibonacci number sequence.
That section provided a function to compute the  th Fibonacci number, reproduced here:.
This fibonacci function is correct, but it does not scale well—its execution time grows significantly as its parameter, , increases.
The problem is this: when computing a solution for a particular Fibonacci number the function can repeat exactly the same work multiple times.
Figure) 10_0_2 illustrates the repetitive work performed by the call fibonacci (5).
As we can see from the figure, the function's recursive execution calls fibonacci (1) five times during the computation of fibonacci (5).
We can verify the results shown in Figure 10_0_2 by augmenting our fibonacci function with a global map that counts function calls.
For addi¬ tional emphasis, the call  (35) recursively calls  (1),  (2),  (3), (4), and  (5) over one million times each.
We may be tempted to care less about the program's repeated work—after all, it is the computer doing the work, not us.
Unfortunately, the com¬ puter, even though it is very fast, requires some amount of time to perform any task.
As we multiply the number of tasks a program must do to solve a problem, the time to compute the solution increases, and, in the case of the  function, the time increases dramatically.
We can improve the performance of our  function using a technique known as memoization.
Memoization is an algorithm design technique that records the result of a specific computation so that result can be used as needed at a later time during the algorithm's execution.
It is as if the executing program "makes a note to itself" or "stores the result in a memo_0_" When the program needs the result of an identical com¬ putation in the future, if simply reads the memo with the answer it stored earlier.
In this way the program avoids repeating the work.
Memoization is especially useful for problems that consist of subproblems that overlap and appear to require multiple computations with identical input.
The following function uses an unordered map object to cache previously computed Fibonacci numbers:.
The  2 function uses an unordered map as a cache of stored values that persist for the duration of the program's execution.
Since the ans local variable is stati c, the run-time environment creates and initializes it with keys 0 and 1 before executing the mai  function.
When a caller invokes  2, if the answer is not in ans, it computes the result and stores the result in ans for future use.
This not only helps future calls to the function from the outside, but it also speeds up recursive invocations that must perform the same work.
The Fibonacci numbers grow very quickly, so the functions in Listing 21_0_21 (_0_h) return unsigned long long values.
For convenience it introduces the type alias Integer for unsigned long long to simplify the code.
Under Visual Cplus_plus, for example, this type supports values in the range 0_0__0_.
Listing[21_0_22[(_0_cpp) provides the implementations for the two functions.
When compiled and linked with the code in Listing 21_0_22 (_0_cpp).
Listing 21_0_23 (testfib_0_cpp) verifies that the 2 function produces the same results as the  function when given the same arguments.
It tests unsi gned values up to 50.
You will observe that as the arguments become larger, the program takes longer to print the results.
Figure 21_0_1 The hierarchy of recursive function calls that result from the call fibonacci2(5).
The original recursive version requires over 111 seconds (almost two minutes), while the memoized recur¬ sive version takes only 1 millisecond.
During this run the memoized version was over 100,000 times faster.
The  2 function is so fast because it avoids all the redundant recursive calls the function must compute.
Listing 21_0_24 (timefib_0_cpp) provides an honest test, as it forces  2 to compute the 50 th Fibonacci number right away with no previous  2 invocations.
Once completing a call of 2 («), all of the Fibonacci numbers from 0_0__0__0_« will be present in the function's unordered_ma cache of precomputed values.
This means future invocations involving any values in that range will be very fast.
Any program that must compute Fibonacci numbers multiple times during their execution will espe¬ cially benefit from the memoized version.
Figure |21,l [ shows the recursion tree for our memoized Fibonacci function computing the fifth Fibonacci number.
The figure shows only nine invocations of  2, compared to 15 invocations of the nonmemoized  function.
If you add the function call counting instrumentation used in Listing 21_0_20 (fibonacciinstrumented_0_cpp) to  2, you will find the numbers it reports agrees with Figure 21_0_1.
CHAPTER UNDER CONSTRUCTION 1111111111 In our programming experience so far we have encountered several kinds of run-time errors.
To this point, all of our run-time errors have resulted in the executing program's termination.
Cplus_plus provides an ex¬ ception handling framework that allows programmers to deal with certain kinds of run-time errors.
Rather than always terminating the program's execution, the exception handling infrastructure enables program¬ mers to detect a problem and execute code to correct the issue or manage it in other ways.
This chapter explores Cplus_plus's exception handling mechanism.
It may be straightforward to write an algo¬ rithm to solve a problem in the general case, but there may be a number of special cases that must all be addressed within the algorithm for the algorithm to be correct.
Some of these special cases might occur rarely under the most extraordinary circumstances.
For the code implementing the algorithm to be robust, these exceptional cases must be handled properly; however, adding the necessary details to the algorithm may render it overly complex and difficult to construct correctly.
Such an overly complex algorithm would be difficult for others to read and understand, and it would be harder to debug and extend.
Ideally, a developer would express the algorithm in its general form including any common special cases.
Exceptional situations that should arise rarely, along with a strategy to handle them, could appear elsewhere, perhaps as an annotation to the algorithm.
Thus, the algorithm is kept focused on solving the problem at hand, and measures to deal with exceptional cases are handled elsewhere.
Cplus_plus's exception handling infrastructure allows programmers to cleanly separate the code that imple¬ ments the focused algorithm from the code that deals with exceptional situations that the algorithm may face.
This approach is more modular and encourages the development of code that is cleaner and easier to maintain and debug.
An exception is an exceptional event that occurs during a program's execution.
An exception always is possible, but it should be a relatively rare event.
If it were not rare, it would be a customary or expected event, and the program should handle it as part of its normal processing.
An exception almost always represents a problem, usually some sort of run-time error.
The operator [] method performs no bounds checking; thus, an executing program using the expression v [  ] would represent undefined behavior.
Consider instead the expression v.
The at method works just like ope rato r [], except at does check the vector's bounds.
While this is better than undefined behavior, it is not ideal.
The program crashes.
When a real application crashes the user may lose unsaved data.
Badly behaving programs terminate unexpectedly.
It would be better to defend against the out-of-bounds index and keep the program alive.
An algorithm could handle many potential problems itself.
For example, a programmer can use an  f statement to test to see  a vector's index is within the proper bounds:.
To form a try/catch block we 1.
Both try and catch are keywords in Cplus_plus.
Unlike the bodies of the structured statements such as  f and whi le, the statements within a try block and statements within a catch block must appear within.
The variable e within the catch block of Listing 22_0_2 (vectorboundsexcept_0_cpp) is a reference to an exception object.
The exception class is part of the standard Cplus_plus library and is the base class for all the standard exceptions.
The exception class provides a what method that returns a string.
The excepti on : : what method's string is a message containing information about the exception.
The Cplus_plus standard does not specify the exact message, but at the very least the exception: :what method indicates the kind of exception caught.
The following shows what the program reports under Visual Cplus_plus when the user enters the value 3:.
While Listing |[22_0_21 (vectorboundsexcept_0_cpp) does not technically crash, its behavior is not much differ¬ ent from an actual abnormal program termination.
Listing ||223| (betterboundsexcept_0_cpp) provides a more practical example.
This improved version uses a loop to continuously request integer values until the user supplies one that does not throw an exception.
Listing |2Z4| (callchainexception_0_cpp) is specially crafted to provide insight into the program's exact execu¬ tion path.
Each function prints a message at its beginning and end so we can see when the code within a function is active.
Each function also declares a local Tracker object which is identified by the name of that function.
An executing function constructs a local object at its point of declaration and automatically destroys the object when the function returns to its caller.
These local objects, therefore, have a lifetime that mirrors the lifetime of the function that manages them.
Finally, Listing |22_0_4| (callchainexception_0_cpp) declares a global T racker object.
An executing program creates global objects before it calls man n and.
In Listing 22_0_4 (callchainexception_0_cpp) the  nums, declared in mai n, holds three elements.
The main function passes its nums  to process.
During its call to process, the main function has no control over the process function's attempts to access an element outside the range of nums.
The process function, however, does not itself attempt to access any elements within the  that mai n supplies.
Instead, process passes the  on to the find function.
It is in find where prob¬ lems may arise because find calls the 's at method.
If the find function calls the 's at method with an out-of-bounds index, at will throw an exception.
Observe that unlike in Listing [22_0_2| (vectorboundsexcept_0_cpp), the method that calls std: : < nt> : :at does not do so within a try/catch block.
This means find cannot catch any exceptions that std : : vectorci nt> : ratmight throw.
The following shows a sample run of Listing|224j(callchainexception_0_cpp):.
Destroying Tracker (global).
The find function creates its Tracker object.
The find function obtains the user's  for the element to seek.
Here the user enters 4 (which is not present in the ).
The find function executes its last statement.
Figure [22T| provides a more graphical representation of this process.
In this case the user did not enter a range in the process function that would cause a problem in find, so no exceptions arise.
Since the program's execution produced no exceptions, it did not execute the printing statement in the catch block.
To see what happens during an exception consider the following sample run of Listing )22_0_4i| (callchainexception_0_cpp):.
Destroying Tracker (global) The user supplied range of 10_0_.
Because the program does not print find's exit message we know the find function does not complete its execution as usual.
This is because the std : : vector<i nt> : : at method called by find throws an exception.
Furthermore, it does not appear that find returns normally to process, since process does not print its exit message either.
We do see, though, that the program does properly destroy the the local Tracker.
Figure 22_0_2 Function call chain interrupted by an exception.
Neither the std : : vector <i nt> : : at.
Figure 22_0_2 better illustrates the program's execution.
Listing j22i4[ (calIchainexception_0_cpp) demonstrates that exceptions have the potential to radically alter the normal function call and return pathways.
In one sense an exception works like a "super goto" state¬ ment.
The program's execution jumps back to a previous point in its execution sequence, bypassing all functions in the call chain in between.
Recall Section 6_0_3_0_2 discouraged the use of the goto statement except for it use to exit from within a nested loop.
This is because the logic in code that uses indiscriminate gotos instead of the structured branching and looping constructs such as i f/else, swi tch, whi le, and for tends to be obscure and difficult to extend and maintain.
Cplus_plus's exception mechanism is different than a "super goto" in several important ways:.
A goto statement cannot jump to code outside of the function in which it appears.
Exceptions have no such limitation.
The programmer must specify a destination (label) for a goto statement.
In the case of Listing |22_0_4| (callchainexception_0_cpp), the std: : vector<i nt> : :at method throws the exception.
We can call at from many different functions within a single program and use at in many different pro¬ grams.
The code within the at method cannot possibly know where to go if it encounters an exceptional situation.
An exception simply redirects the program's execution to the most recent try/catch block in the call chain that can handle the exception.
Listing [223| (badinput_0_cpp) follows.
The standard Cplus_plus library has a limited number of standard exceptions.
We can create our own custom excep¬ tions for specialized error handling that our applications may require.
Listing [22_0_8j (customfilereadexcept_0_cpp) defines a custom exception class, FileNot Found Exception, derived from the standard std: :exception class.
Since we derived the FileNotFoundException class from std: :exception, any FileNotFoundExcepti on object also is a std : : excepti on object (see Section 17_0_1).
This enables the main function to catch a Fi leNotFoundExcepti on object in its catch body even though it is declared to catch std : : excepti on objects.
The Cplus_plus standard library provides a number of exception classes, all derived from std : : excepti on.
The  out-of-bounds exception objects thrown by the at method are instances of the standard std: :out_of_ range class.
The std: : out_of_range class is derived from the standard logic_error class which itself is derived from the standard std : : excepti on class.
Figure 22_0_3 shows the relationship among these exception classes.
Figure 22_0_3 The relationship among the exception classes involved in Listing 22_0_8.
Size of data set.
This gives us two options for creating and populating the : 1.
Create the  with sufficient size up front and then use a loop to place to individual elements in their proper places.
Create an empty  and then use a loop to push_back the individual elements.
Option 1 is more efficient than Option |2] Successive calls to std: : vectorci nt> : : push_back must reallocate and copy elements multiple times.
Option[2|is safer than Option|T]because the number of elements specified at the start may not agree with the actual number of data elements in the file.
If the specified number is too small, the function will attempt to overrun the bounds of the.
Listingj|22_0_9|(filereadmultiexcept1 _0_cpp) opts for efficiency at the expense of safety.
This means it depends on a correctly created data hie.
If the hie does not exist, load_vector will throw our Fi leNotFound¬ Excepti on custom exception:.
If the hie exists and contains.
Program finished Notice that in Listing |22_0_1 l|| (rethrow_0_cpp) the compute function does not create a new  object; it simply re-throws the same  object that it caught.
This concept of intermediate  handlers is important since a function invocation has complete knowledge of it own local context such as its local variables.
This means that an intermediate function (or method) in the call chain has access to information that may be unavailable to all other functions (or methods) within that call chain.
The catch block in the compute function of Listing 22_0_11 (rethrow_0_cpp) involves only local variables.
The catch block within the mai n function cannot know the subscript that caused compute's failure since  is local to compute.
Some general  guidelines :.
Handle exceptions as close (up the call chain) as possible to the code that throws the.
If the lower-level functions/methods are responsible for their own  handling, then the higher-level functions/methods may be able to dispense with handling altogether making the lower-level methods more robust units of reuse.
The higher-level method may just need to know there was a problem without needing to know exactly  the problem was.
For example, in List¬ ing 22_0_11 (rethrow_0_cpp), the compute function could throw a custom ComputeExcepti on object whenever filter throws its std : : out_of_range instead of just passing up the call chain the std: : out_of_range object it receives.
If total recovery is not possible or desirable at the lower levels of the call chain, re-throw the.
When a section of code throws an , the catch blocks within the nearest  handler are checked in the order they appear in the Cplus_plus source code.
The first catch block that matches the type of the  thrown is the one executed.
Listing 22_0_12 (multipleexceptions_0_cpp) expects two types of exceptions, and it uses the catch-all  in case any unexpected exceptions arise.
When an  is caught, its type is first compared to std: : out_of_range.
If it matches, the std: :out_of_range catch block is executed.
If not, the 's type is then compared to nvalid_argument.
The  nvalid_argument catch block is executed in the case of  match.
If neither of the two types match, the catch-all code is executed.
When inheritance is involved, the situation becomes more interesting.
The comparison performed in each catch block is  test for assignment compatibility.
A reference or  pointer to an instance of derived class can be assigned to  variable declared to be  reference  pointer to  base class.
This up¬ casting operation is always legal because of the is  relationship between  derived class and its base class.
This means an  object of type std: :out_of_range is assignment compatible with both std: :out_of_range variables and std: : variables.
Since the catch blocks are checked in the order they appear in the source code, the following code would have  problem:.
The std : : out_of_range catch block will never execute since  std : : out_of_range object is an excepti on instance also.
For this reason it is illegal for  more specific type to follow  more general type in  sequence of catch blocks.
The above code fragment will not compile in any context.
Thus, in sequence of catch blocks, list the more specific exceptions first followed by the more general exceptions.
All Cplus_plus standard  classes have std : : excepti on as their direct or indirect base class.
Cplus_plus does not require  objects to be derived from excepti on; in fact, primitive types such as  nt.
Exceptions should be reserved for uncommon errors.
For example, the following code adds up all the elements in an integer  named vec: int  = 0,  = vec_0_sizeQ;.
This loop is fairly typical.
Another approach uses exceptions:.
It interrupts the statement.
The exception definitely is not an uncommon occurrence.
You should not use exceptions to dictate normal logical flow.
While very useful for its intended pur¬ pose, the exception mechanism adds some overhead to program execution, especially when an exception is thrown.
This overhead is reasonable when exceptions are rare but not when exceptions are part of the program's normal execution.
Sometimes it is not clear when an exception is appropriate.
Consider  function that returns the position of an element within.
The straightforward approach that does not use exceptions could be written: int find(const std::< nt>& , int elem) { int  = _0_sizeQ ;.
In the first approach, an unwary programmer may not check the  and blindly use — 1 as  valid position.
The exception code would not allow this to happen.
However, the first approach is useful for determining if an element is present in the.
If find (x) returns —1, then x is not in the ; otherwise, it is in the.
If the exception approach is used,  client programmer cannot determine if an element is present without the risk of throwing an exception.
Since exceptions should be rare, the second approach appears to be less than ideal.
The first approach is more useful, but clients need to remember to properly check the.
The second approach provides an exception safety net, but an exception always will be thrown when searching for missing elements.
Which approach is ultimately better.
The first version uses  common programming idiom and is the better approach for most programming situations.
The exception version is  poorer choice since it is not uncommon to attempt to look for an element missing from  ; exceptions should be reserved for uncommon error situations.
This appendix describes the task of Cplus_plus software development under Visual Studio:.
To begin creating a Cplus_plus program, you must first launch Visual Studio 2015 from the Windows start screen or other relevant shortcut.
Figure |A_0_1| shows the appropriate application tile to activate.
You soon should see a splash screen similar to the one shown in Figure [A72| If you have never before used the Visual Studio application, you must wait a few moments while it configures the development environment for you.
At this point you will indicate that Visual Cplus_plus is your preferred development language.
You also may select a color scheme.
The figures shown here reflect the blue color scheme.
Figure jA3| shows what Visual Studio looks like when it is fully loaded and ready to use.
After Visual Studio has started, you begin the process of developing a Cplus_plus program by creating a new.
As Figure |A_0_4j shows, you can create a new  by following the menu sequence: File^New^Project.
In the dialog that results, shown on the right of Figure |A~4] you should choose the  type to be Visual Cplus_plus in the left pane, and use the Win32 Console Application option in the center pane.
In the name field near the bottom of the dialog, enter a name for the ; we will use the name simple.
You may change the location to a different folder if you like, or even a different drive (such as a USB pen drive).
In this example, we chose to not change the default location provided by Visual Studio.
When you select OK on the  creation dialog, a Win32 Application Wizard as shown on the left of Figure |A3| appears.
At this point, the instructions in the dialog say "Click Finish from any window to accept the current settings_0_" Do not select Finish; instead, select Next to continue.
We have one more key step to complete so our  is set up correctly.
In the subsequent Applications Settings dialog (see the right image in Figu re [AT5) , select the Empty.
Choose Finish when you are ready to continue.
In the Add New Item dialog box, shown on the left in Figure A_0_7 select Cplus_plusFile (_0_cpp) and enter a.
The file here will be named simple_0_cpp.
Press Add when done.
As shown on the right in Figure A_0_7 the Solution Explorer pane now shows the file si mple.
You may save the sou rce file at th is point by selecting Save from the File menu or by pressing pressing.
These lines indicate the build was successful.
A console window appears with the output of your program.
The right image in Figure j[A_0_9| shows this text window.
You can press any key on the keyboard to close the window.
If the console window does not appear, you have typographical errors in your program; return to the editor, fix the errors, and try to run the program again.
These are the steps for writing a basic Cplus_plus program in Visual Studio 2015.
While the steps initially may seem complex and tedious, they will become natural after you have written a few Cplus_plus programs.
When the program was run, the Visual Studio environment created a console window in which to run the program.
The first line of the output was printed by the program.
The second line prompting the user to press any key to continue is added by the Visual Cplus_plus run-time environment so the console window stays visible long enough for the user to see the output.
If you run the program from a the standard Windows command shell (CMD_0_EXE, usually found in the Start menu under Accessories and named Command Prompt), only the program's output will appear and the "Press any key to continue.
The following summarizes the steps you should follow when writing a Cplus_plus program using the Visual Studio IDE:.
It is possible to develop Cplus_plus programs without using Visual Studio's integrated development environ¬ ment.
Visual Studio comes with some additional tools for command-line development.
Appendix |Bjde¬ scribes how you can edit the Cplus_plus  code with a standalone text editor and compile and run the program from the Windows command prompt (CMD_0_EXE).
Command-line development under Linux and macOS is covered in[B| Some programmers prefer the freedom of using their favorite editor, a standalone compiler, and scripts to automate the build process.
An integrated development environment (IDE) like Visual Studio combines all the tools a developer needs into one comprehensive application.
While this approach works well for most programmers, some de¬ velopers prefer a less centralized approach, using instead command line tools to manage the development process.
Command line tools are focused and fast, and each tool itself is fairly simple compared to a fullfeatured IDE.
A developers may prefer a different editor to one provided by the IDE.
Developers can build scripts to around command line tools to automate the building and testing process.
There are a few commands that are essential for working within the command-line environment.
These center around manipulating and using files and folders.
Our discussion assumes the Windows CMD_0_EXE shell, and we will note differences with macOS and Linux as needed.
Linux and macOS are both Unix-like operating systems.
When you run CMD_0_EXE in Windows, the Terminal application on a Mac, or a bash terminal in Linux, the operating system presents a text-based console window.
You type commands into this window and receive text feedback.
Most of the commands are programs that you launch by typing their name.
The following lists common commands useful for using the command-line;.
Your location is known as the current working directory.
The command dir prints a list of the files in your current working directory.
On Unix-like machine the Is -l command performs similar work.
The command dir /w displays a wide listing of the hies with fewer details; the Is command is the equivalent on Unix-like systems.
Subdirectories allow you to better organize your hies.
Some examples of its use include - cd Code Changes the current working directory to be the  named Code.
Here the name is relative to the current directory.
It is an error to provide a name that does not correspond to a of the current directory.
Changes the current working directory to its parent directory.
Said another way, the current working directory is itself a  of some other directory.
This command makes this other (parent) directory the current working directory.
The name here is known as a full-path name.
The name is an absolute location; it is not relative to the current working directory.
Unix-like systems do not have a drive letter (C:), and the backslashes (\) would be forward slashes (/).
Changes the current working directory to itself, which effectively does nothing.
This command does no useful work.
The dot (_0_) in this context means "current working directory_0_".
Use this command carefully.
Unix-like systems use the rm command in its place.
The move command does the same thing, and Unix-like systems use the mv command to rename files.
In preparation for our programming, we can create a new  for our code and make that new our current working  with the commands: mkdir Code cd Code We can edit our source code with a simple text editor such as Notepad or Wordpad for Windows, TextEdit on the Mac, or gEdit on Linux systems.
More powerful programming editors such as Notepadplus_plus ( http : / /.
Mac, and Linux) make editing source code more convenient.
B_0_0_0_1 Visual Studio Command Line Tools.
Visual Studio provides a number of command line tools as an alternative to its integrated development environment.
To use the command line tools, select the Visual Studio Command Prompt from the Start menu.
A command console appears similar to the console that the IDE provides when executing a program (see Section \2_0_2).
Instead of selecting menu items and interacting with dialog boxes, you type commands into the console window to build and run your program.
To edit your program you can use the editor from the IDE, or you can use a standalone editor such as Notepad-H- ( http : / /www.
Both Notepadplus_plus and Vim provide color syn¬ tax highlighting and folding like the built-in Visual Studio editor.
In order to use the command prompt version of Visual Studio, it is convenient to first create a folder in which you will place all your development files; for example, you could create a folder named Code under your Documents folder.
Suppose the full path to this folder is.
The first command you should issue in the console window is.
The cd command means "change _0_" This command sets the console's working  to the development folder you previously created.
If you are working in another folder, you can adjust the path given in the cd command to your work area.
You are ready to edit your code.
If your environment is set up so that your editor program is in the system path, you can type.
Within the editor type in your program and then save it to a file.
The cl ("cee elle", not "cee one") command, which stands for compile and link, preprocesses, compiles, and links the program.
The /W3 switch uses the Level 3 warning level.
Level 3 warnings provide more thorough analysis of your source code and can detect more programming mistakes.
If you omit the /W3 switch, by default the compiler operates at warning level 1.
Warning level 1 is insufficient for catching many mistakes made by both beginning and experienced Cplus_plus programmers.
By default the IDE compiler uses warning level 3, and the warning level can be changed by adjusting the project's properties.
On the command line, specifying /W4 (the highest warning level) is just as easy as specifying /W3.
It is better to use /W4 so the compiler can do a more thorough check for potential programmer mistakes.
The / EHsc is required for all the Cplus_plus programs we write.
If want to reduce the level of detail in the output produced by the compiler and linker, you can add the additional switch / nologo:.
Once the program has been compiled successfully, you can run the program by entering the name of the executable produced.
In our example, we would issue the command.
The program runs in the same window; no new  window is produced.
When the program is finished executing, no "Press any key to continue" message is printed; you get simply a command prompt ready for you to enter your next command.
If you modify your source code in your editor, you must remember to recompile your code before you run it again.
In the IDE, if you modify your code, the environment will suggest that you rebuild the project before running the program.
If the program consists of multiple source files, list all the required files on the command line.
The exe file will be named after the first file listed; for example, the command.
B_0_0_0_2 Developing Cplus_plus Programs with the GNU Tools The tools provided in the GNU Compiler Collection ( http : //gcc.
The GNU tools are free and are available for the major computing platforms:.
Microsoft Windows XP-Windows 10 Windows-based GCC tools can be found at the MinGW website http : / /www.
Mac users also may use the clangplus_plus compiler that comes.
Linux-based GCC tools are readily available for all the major Linux distributions.
To get them, simply install the gplus_plus development packages.
The name of the GNU Cplus_plus compiler is gplus_plus.
It is a command-line tool, which means it is launched from a command shell— CMD_0_EXE in Windows or bash in the Mac and Linux environments.
To see how the GNU Cplus_plus buld system works, we will consider Listing [271 [ (simple_0_cpp) from Chapter[2] Use an editor to create a text file containing the code for Listing j2T] (simple_0_cpp), and save the file with the name simple_0_cpp.
In Windows, if notepadplus_plus is installed and set up properly, in the command shell you can type notepadplus_plus simple_0_cpp.
This command brings up a separate window with an editor.
We can type the source code for Listing (2TTj (simple_0_cpp) and save the file.
To create the executable program with GNU Cplus_plus, back in our command-line window we issue the command gplus_plus - -=cplus_plus14 -o simple simple_0_cpp.
This one command runs the preprocessor, followed by the compiler, and finally the linker to produce the executable program.
Even though the preprocessor and linker are also involved here, we generally simply say we are "compiling the program_0_".
It goes beyond checking that the program is well-formed Cplus_plus it also warns about code constructs that many programmers consider questionable because code of that nature often contains errors.
The - component can be interpreted to mean "warn about as many possible problems as possible_0_" You should compile all Cplus_plus programs with this directive because it enables the compiler to catch many careless programmer mistakes that otherwise might go unnoticed.
Use of the - directive is desirable for all Cplus_plus programmers from novice to expert.
The Cplus_plus standards committee is responsible for defining the Cplus_plus language.
The committee refines the language specification over time.
In addition to adding new features to the language, the committee also addresses shortcomings in existing language features.
As a result of the committee's work newer compilers can check more thoroughly the validity of Cplus_plus programs.
Modern compilers do a better job of catching common programming errors.
The - directive is optional because sometimes developers must work with older Cplus_plus source.
The  was written originally under more relaxed Cplus_plus language rules, but it may not be worthwhile to rewrite the  to bring it up to modern standards.
If this older  has proven to be reliable, it may be compiled without the more stringent checks.
All new , however, should take advantage of the newer, better checking capabilities of the most up-to-date Cplus_plus compiler; therefore, always use - on the compiler command line for  that you write.
Since this standard is relatively ,  you omit this part of the command, gplus_plus assumes the programmer is writing the source  under the rules of the older, 1998 ISO Cplus_plus standard, usually referred to as Cplus_plus98.
On Mac and Linux platforms the name of the executable file produced will be just simple (no exe name extension).
If the Cplus_plus source   contains no errors, the compiler will produce the executable file named simple_0_exe (or simple).
On a Windows Machine we can run the compiled program from the command line by typing the command simple (We also can use the full name, simple_0_exe_0_) On a Unix-ike system (macOS or Linux), we instead would type /simple.
Here the file simple_0_cpp must reside in our current working directory for the compiler to process it.
When you are finished with the executable file simple_0_exe, you can delete it with the following com¬ mand:.
Fibonacci sequence, 260 fields, |409| for statment, |l67| foreach, |298| fragmentation, memory, 544] f ri end, [466] full-path name,||748| function call, 182 function call operator, j636 function declaration, |23T|| function definition, |2031 function invocation, |Y82I| function invocation operator, |636[ function objects, [656].
Rule of Five, j588| Rule of Three, [577 [ rvalue reference, 580 scoped enumerations, [3T| sequence, |290| shift, bitwise, [74] short-circuit evaluation, [99] slice, array, |322j smart pointer;[590 source code formatting, 47| specialization, class, [496) stack overflow, |544| standard namespace, [9].
Draft date: September 25, 2018.