Location of VideoNotes in the Text Chapter  Public Private .

Walter Savitch University of California , San Diego Contributor Kenrick Mock University of Alaska , Anchorage Boston Columbus Indianapolis New York San Francisco Upper Saddle River Amsterdam Cape Town Dubai London Madrid Milan Munich Paris Montreal Toronto Delhi Mexico City SÃ£o Paulo Sydney Hong Kong Seoul Singapore Taipei Tokyo Editorial Director : Marcia Horton Acquisitions Editor : Matt Goldstein Program Manager : Kayla Editorial Assistant : Kelsey Loanes Marketing Coordinator : Kathryn Ferranti Production Director : Erin Gregg Managing Editor : Scott Disanno Senior Operations Supervisor : Vincent Scelta Operations Specialist : Linda Sager Cover Designer : Joyce Wells Permissions Manager : Timothy Nicholls Image Permissions Manager : Karen Sanatar Media Producer : Renata Butera Media Project Manager : Wanda Rockwell Vendor : Hardik Popli , Publisher Services Composition : Cenveo Publisher Services : Cover Printer : Credits acknowledgments borrowed from other sources reproduced , with permission , in this textbook appear on appropriate page within text .

are registered trademarks of the Microsoft Corporation in the The United States of America other countries .
Screen shots icons reprinted with permission from the Microsoft Corporation .
This book is not sponsored or endorsed by or affiliated with the Microsoft Corporation .

Copyright , Pearson Education , Inc .
All rights reserved .
Manufactured in the United States of America .
This publication is protected by Copyright , permission should be obtained from the publisher prior to any prohibited reproduction , storage in retrieval system , or transmission in any form or by any means , electronic , mechanical , photocopying , recording , or likewise .
To obtain to use material from this work , please submit written request to Pearson Education , Permissions Department , Boylston Street , Suite , Boston , Massachusetts .

Many of the designations by manufacturers sellers to distinguish their products are claimed as trademarks .

Where those designations appear in this book , the publisher was aware of trademark claim , the designations have been printed in initial caps or all caps .

Library of Congress Data Savitch , Walter , solving with Walter Savitch  contributor , Kenrick Mock .

program .

ISBN : ISBN : Preface This book is meant be used in first course in programming and computer science using the language .
It assumes no previous programming experience and no mathematics beyond high school algebra .

If you have used the previous edition of this book , you should read the following section that explains the changes this ninth edition and then you can skip the rest of this preface .
If you are new this book , the rest of this preface will give you an overview of the book .

Changes the Ninth Edition This ninth edition presents the same programming philosophy as the eighth edition .
All of the material from the eighth edition remains , but with the following enhancements : programs are now split into Programs and Projects .
Programs require direct application of concepts presented in the chapter and solutions are usually short .
Programs are appropriate for laboratory exercises .
Projects require additional problem solving and solutions are generally longer than Programs .
Projects are appropriate for homework problems .

Examples of content includes new types , the auto type , raw string literals , strong enumerations , nullptr , ranged for loop , conversion between strings and integers , member initializers , and constructor delegation .

These walk students through the process of both problem solving and coding help reinforce key programming concepts .
An icon appears in the margin of the book when VideoNote is available regarding the topic covered in the text .

If you are an instructor already using the eighth edition , you can continue teach your course almost without change .

Flexibility in Topic Ordering This book was written allow instructors wide latitude in reordering the material .
To illustrate this flexibility , we suggest two alternative ways order .

Preface the topics .
There is no loss of continuity when the book is read in either of these ways .
To ensure this continuity when you rearrange material , you may need move sections rather than entire chapters .
However , only large sections in convenient locations are moved .
To help customize particular order for any needs , the end of this preface contains dependency chart , and each chapter has " section that explains what material needs be covered before each section in that chapter .

Reordering : Earlier Classes To effectively design classes , student needs some basic tools such as control structures and function definitions .
This basic material is covered in Chapters through .
After completing Chapter , students can begin write their own classes .
One possible reordering of chapters that allows for such early coverage of classes is the following : Basics : Chapters , and .
This material covers all control structures , function definitions , and basic file .
Chapter , which covers additional control structures , could be deferred if you wish cover classes as early as possible .

Classes and namespaces : Chapter , Sections and of Chapter , and Chapter .
This material covers defining classes , friends , overloaded operators , and namespaces .

Arrays , strings and vectors : Chapters and Pointers and dynamic arrays : Chapter Arrays in classes : Sections and of Chapter Inheritance : Chapter Recursion : Chapter , recursion may be moved later in the Pointers and linked lists : Chapter Any subset of the following chapters may also be used : Exception handling : Chapter Templates : Chapter Standard Template Library : Chapter Reordering : Classes Slightly Later but Still Early This version covers all control structures and the basic material on arrays before doing classes , but classes are covered later than the previous ordering and slightly earlier than the default ordering .

This material covers all control structures , function definitions , and the basic file .

Preface Arrays and strings : Chapter , Sections and of Chapter Classes and namespaces : Chapter , Sections and of Chapter , and Chapter .
This material covers defining classes , friends , overloaded operators , and namespaces .

Pointers and dynamic arrays : Chapter Arrays in classes : Sections and of Chapter Inheritance : Chapter Recursion : Chapter .
It is not even enough for it be clear and correct when read by an instructor or other experienced programmer .
The material needs be presented in way that is accessible beginning students .
In this introductory textbook , have endeavored write in way that students find clear and friendly .
Reports from the many students who have used the earlier editions of this book confirm that this style makes the material clear and often even enjoyable students .

Standard This edition is fully compatible with compilers that meet the latest standard .
At the time of this writing the latest standard is .

Advanced Topics Many topics " are becoming part of standard course .
Even if they are not part of course , it is good have them available in the text as enrichment material .
This book offers number of advanced topics that can be integrated into course or left as enrichment topics .
It gives thorough coverage of templates , inheritance virtual , exception handling , and the STL Template .
Although this book uses libraries and teaches students the importance of libraries , it does not require any nonstandard libraries .
This book uses only libraries that are provided with essentially all implementations .

Preface Dependency Chart The dependency chart on the next page shows possible orderings of chapters and subsections .
line joining two boxes means that the upper box must be covered before the lower box .
Any ordering that is consistent with this partial ordering can be read without loss of continuity .
If box contains section number or numbers , then the box refers only to those sections and not to the entire chapter .

Summary Boxes Each major point is summarized in boxed section .
These boxed sections are spread throughout each chapter .

Exercises Each chapter contains numerous Exercises at strategic points .
Complete answers for all the Exercises are given at the end of each chapter .

VideoNotes VideoNote VideoNotes are designed for teaching students key programming concepts and techniques .
These short videos demonstrate how to solve from design through coding .
VideoNotes for with easy navigation including the ability to select , play , rewind , and stop within each VideoNote exercise .

Online Practice and Assessment with MyProgrammingLab MyProgrammingLab helps students fully grasp the logic , semantics , and syntax of programming .
Through practice exercises and immediate , personalized feedback , MyProgrammingLab improves the programming competence of beginning students who often struggle with the basic concepts and paradigms of popular programming languages .

and homework tool , MyProgrammingLab course consists of hundreds of small practice problems organized around the structure of this textbook .
For students , the system automatically detects errors in the logic and syntax of their code submissions and offers targeted hints that enable students to figure out what went why .
For instructors , comprehensive gradebook tracks correct and incorrect answers and stores the code inputted by students for review .

MyProgrammingLab is offered to users of this book in partnership with Craft , the makers of the CodeLab interactive programming exercise system .
For full demonstration , to see feedback from instructors and students , or to get started using MyProgrammingLab in your course , visit .

Preface DISPLAY Dependency Chart Chapter Introduction Chapter Basics Chapter Functions Chapter Functions Chapter More Flow of Control Chapter Arrays Chapter Streams Chapter Recursion Chapter Classes Chapter MultiDimensional Arrays Chapter Classes Chapter Strings and Vectors Exception Handling Chapter Separate Namespaces Chapter Classes Arrays Chapter Pointers and Dynamic Arrays Chapter Classes Dynamic Arrays Chapter Pointers and Linked Lists Chapter Inheritance Chapter Templates contains occasional references to derived classes , but those references can be omitted Chapter STL ix .

Preface Support Material There is support material available to all users of this book and additional material available only to qualified instructors .

Materials Available to All Users of this Book Source Code from the book PowerPoint slides VideoNotes To access these materials , go to : Resources Available to Qualified Instructors Only Visit Pearson instructor resource center at to access the following instructor resources : Resource teaching hints , quiz questions with solutions , and solutions to many programming projects Test Bank and Test Generator PowerPoint programs and art from the text Lab Manual Integrated Development Environment Resource Kits Instructors who adopt this text can order it for students with kit containing five popular IDEs Visual Studio Express Edition , Dev , NetBeans , Eclipse , and and access to Web site containing written and video tutorials for getting started in each IDE .
For ordering information , please contact your campus Pearson Education representative .

Contact Us Your comments , suggestions , questions , and corrections are always welcome .

Please them to Acknowledgments Numerous individuals and groups have provided me with suggestions , discussions , and other help in preparing this textbook .
Much of the first edition of this book was written while was visiting the Computer Science Department at the University of Colorado in Boulder .
The remainder of the writing on the first edition and the work on subsequent editions was done in the Computer Science and Engineering Department at the University of California , San Diego .
am grateful to these institutions for providing conducive environment for teaching this material and writing this book .

Preface extend special thanks to all the individuals who have contributed critiques or programming projects for this or earlier editions and drafts of this book .

In alphabetical order , they are : Alex Feldman , Amber Settle , Andrew Burt , Andrew Haas , Anne Marchant , Barney MacCabe , Bob Holloway , Bob Matthews , Brian .
King , Bruce Johnston , Carol Roberts , Charles Dowling , Claire Bono , Cynthia Martincic , David Feinstein , David Teague , Dennis Heckman , Donald Needham , Doug Cosman , Dung Nguyen , Edward Carr , Eitan .
Gurari , Ethan Munson , Firooz Khosraviyani , Frank Moore , Gilliean Lee , Huzefa Kagdi , James Stepleton , Jeff Roach , Jeffrey Watson , Jennifer Perkins , Jerry Weltman , Joe Faletti , Joel Cohen , John .
Westman , John Marsaglia , John Russo , Joseph Allen , Joseph .
Oldham , Jerrold Grossman , Jesse Morehouse , Karla Chaveau , Ken Rockwood , Larry Johnson , Len Garrett , Linda .
Wilson , Mal Gunasekera , Marianne Lepp , Matt Johnson , Michael Keenan , Michael Main , Michal Sramka , Naomi Shapiro , Nat Martin , Noah Aydin , Nisar Hundewale , Paul .
Kaiser , Paul Kube , Paulo Franca , Richard Borie , Scot Drysdale , Scott Strong , Sheila Foster , Steve Mahaney , Susanne Sherba , Thomas Judson , Walter .
Manrique , Wei Lian Chen , and Wojciech Komornicki .

extend special thanks to the many instructors who used early editions of this book .
Their comments provided some of the most helpful reviewing that the book received .

Finally , thank Kenrick Mock who implemented the changes in this edition .
He had the almost impossible task of pleasing me , my editor , and his own sensibilities , and he did superb job of it .

Walter Savitch xi .

To improving results get with the programming Through the power of practice and immediate personalized feedback , MyProgrammingLab improves your performance .

Learn more at Brief Contents Table of Location of VideoNotes Inside front cover and inside back cover Chapter Introduction to Computers and Programming .

Chapter Streams as an Introduction to Objects and Classes .

Pointers and Dynamic Arrays Chapter Defining Classes Chapter Friends , Overloaded Operators , and Arrays in Classes xiv .

Brief Contents Chapter Separate Compilation and Namespaces Chapter Pointers and Linked Lists Chapter Recursion Chapter Inheritance Chapter Exception Handling Chapter Templates Chapter Standard Template Library Appendices Keywords .

Contents Table of Location of VideoNotes Inside front cover and inside back cover Chapter to Computers and Programming .

Contents Chapter Summary Answers to Exercises Practice Programs Programming Projects Chapter .

Contents Global Constants and Global Variables Formal Parameters Are Local Variables Block Scope Namespaces Revisited .

Contents Chapter Summary Answers to Exercises Practice Programs Programming Projects Chapter .

Contents Chapter Summary Answers to Exercises Practice Programs Programming Projects Chapter .

Efficiency Issues Chapter Summary Answers to Exercises Practice Programs Programming Projects Chapter .

Contents Copy Constructors Overloading the Assignment Operator Chapter Summary Answers to Exercises Practice Programs Programming Projects Chapter .

Contents Pointers as Iterators Inserting and Removing Nodes Inside List Pitfall : Using the Assignment Operator with Dynamic Data Structures Variations on Linked Lists Linked Lists of Classes Stacks and Queues Stacks Programming Example : Stack Queues Programming Example : Queue Class Chapter Summary Answers to Exercises Practice Programs Programming Projects Chapter .

Standard Template Library Iterators using Declarations .

Contents Programming Tip : Use auto to Simplify Variable Declarations Pitfall : Compiler Problems Kinds of Iterators Constant and Mutable Iterators Reverse Iterators Other Kinds of Iterators .

As soon as an Analytical Engine exists , it will necessarily guide the future course of science .

Introduction In this chapter we describe the basic components of computer , as well as the basic technique for designing and writing program .
We then show you sample program and describe how it works .

The collection of programs used by computer is referred to as the software for that computer .
The actual physical machines that make up computer installation are referred to as hardware .
As we will see , the hardware for computer is conceptually very simple .
However , computers now come with large array of software to aid in the task of programming .
This software includes editors , translators , and managers of various sorts .
The resulting environment is complicated and powerful system .
In this book we are concerned almost exclusively with software , but brief overview of how the hardware is organized will be useful .

Hardware There are three main classes of computers : PCs , workstations , and mainframes .

PC is relatively small computer designed to be used by one person at time .
Most home computers are PCs , but PCs are also widely used in business , industry , and science .
workstation is essentially PC .
mainframe is an even larger computer that typically requires some support staff and generally is shared by more than one user .
The distinctions between PCs , workstations , and mainframes are not precise , but the terms are commonly used and do convey some very general information about computer .

network consists of number of computers connected so that they may share resources such as printers and may share information .
network might contain number of workstations and one or more mainframes , as well as shared devices such as printers .

For our purposes in learning programming , it will not matter whether you are working on PC , mainframe , or workstation .
The basic configuration of the computer , as we will view it , is the same for all three types of computers .

The computer can be thought of as having five main components : the input , the output , the processor called the CPU , for central processing , the main memory , and the secondary memory .
The processor , main memory , and secondary memory are normally housed in single cabinet .
The processor and main memory form the heart of computer and can be thought of as an integrated unit .
Other components connect to the main memory and operate under the direction of the processor .
The arrows in Display indicate the direction of information flow .

An input device is any device that allows person to communicate information to the computer .
Your primary input devices are likely to be keyboard and mouse .

An output device is anything that allows the computer to communicate information to you .
The most common output device is display screen , referred to as monitor .
Quite often , there is more than one output device .
For example , in addition to the monitor , your computer probably is connected to printer for producing output on paper .
The keyboard and monitor are sometimes thought of as single unit called terminal .

Display Main Components of Computer .

Chapter Introduction to Computers and Programming In order to store input and to have the equivalent of scratch paper for performing calculations , computers are provided with memory .
The program that the computer executes is also stored in this memory .
computer has two forms of memory , called main memory and secondary memory .
The program that is being executed is kept in main memory , and main memory is , as the name implies , the most important memory .
Main memory consists of long list of numbered locations called memory locations ; the number of memory locations varies from one computer to another , ranging from few thousand to many millions , and sometimes even into the billions .
Each memory location contains string of and .
The contents of these locations can change .

Hence , you can think of each memory location as tiny blackboard on which the computer can write and erase .
In most computers , all memory locations contain the same number of digits .
digit that can assume only the values or is called binary digit or bit .
The memory locations in most computers contain eight bits some multiple of eight .
An eightbit portion of memory is called byte , so we can refer to these numbered memory locations as bytes .
To rephrase the situation , you can think of the main memory as long list of numbered memory locations called bytes .
The number that identifies byte is called its address .
data item , such as number or letter , can be stored in one of these bytes , and the address of the byte is then used to find the data item when it is needed .

In this case , the entire chunk of memory that holds the data item is still called memory location .
The address of the first of the bytes that make up this memory location is used as the address for this larger memory location .
Thus , as practical matter , you can think of the main memory as long list of memory locations of varying sizes .
The size of each of these locations is expressed in bytes and the address of the first byte is used as the address of that memory location .
Display shows picture of hypothetical main memory .
The sizes of the memory locations are not fixed , but can change when new is run on the computer .

Bytes and Addresses Main memory is divided into numbered locations called bytes .
The number associated with byte is called its address .
group of consecutive bytes is used as the location for data item , such as number or letter .
The address of the first byte in the group is used as the address of this larger memory location .

The fact that the information in memory is represented as and need not be of great concern to you when programming in Computer Systems Display Memory Locations and Bytes byte byte byte byte byte byte byte byte byte byte location with address byte location with address byte location with address byte location with address in most other programming .
There is , however , one point about this use of and that will concern us as soon as we start to write programs .
The computer needs to interpret these strings of and as numbers , letters , instructions , or other types of information .
The computer performs these interpretations automatically according to certain coding schemes .
different code is used for each different type of item that is stored in the memory : one code for letters , another for whole numbers , another for fractions , another for instructions , and so on .
For example , in one commonly used set of codes , is the code for the letter and also for the number .
In order to know what the string in particular location stands for , the computer must keep track of which code is currently being used for that location .
Fortunately , the programmer seldom needs to be concerned with such codes and can safely reason as though the locations actually contained letters , numbers , or whatever is desired .

byte is memory location that can hold eight bits .

There are two reasons why eight is special .
First , eight is power of .
Second , it turns out that eight bits are required to code single character as letter or other keyboard .

Chapter Introduction to Computers and Programming The memory we have been discussing up until now is the main memory .

Without its main memory , computer can do nothing .
However , main memory is only used while the computer is actually following the instructions in .
The computer also has another form of memory called secondary memory or secondary storage .

Some alternative terms that are commonly used to refer to secondary memory are auxiliary memory , auxiliary storage , external memory , and external storage .

Information in secondary storage is kept in units called files , which can be as large or as small as you like .
 for example , is stored in file in secondary storage and copied into main memory when the is run .
You can store  letter , an inventory list , or any other unit of information in file .

Several different kinds of secondary memory can be attached to single computer .
The most common forms of secondary memory are hard disks , diskettes , CDs , DVDs , and removable flash memory drives .
CDs and DVDs for computers can be so that your computer can read , but cannot change , the data on the disc ; CDs and DVDs for computers can also be write , which can have their data changed by the computer .
Hard disks are fixed in place and are normally not removed from the disk drive .
Diskettes and CDs can be easily removed from the disk drive and carried to another computer .
Diskettes and CDs have the advantages of being inexpensive and portable , but hard disks hold more data and operate faster .
Flash drives have largely replaced diskettes today and store data using type of memory called flash memory .
Unlike main memory , flash memory does not require power to maintain the information stored on the device .
Other forms of secondary memory are also available , but this list covers most forms that you are likely to encounter .

Main memory is often referred to as RAM or random access memory .
It is called random access because the computer can immediately access the data in any memory location .
Secondary memory often requires sequential access , memory locations until it finds the item it needs .

The processor known as the central processing unit , or is the " of the computer .
When computer is advertised , the computer company tells you what chip it contains .
The chip is the processor .
The processor follows the instructions in program and performs the calculations specified by the program .
The processor is , however , very simple brain .
All it can do is follow set of simple instructions provided by the programmer .
Typical processor instructions say things like the and as numbers , and then add the number in memory location to the number in memory location , and Computer Systems put the answer in location " or letter of input , convert it to its code as string of and , and place it in memory location " The processor can add , subtract , multiply , and divide and can move things from one memory location to another .
It can interpret strings of and as letters and send the letters to an output device .
The processor also has some primitive ability to rearrange the order of instructions .
Processor instructions vary somewhat from one computer to another .
The processor of modern computer can have as many as several hundred available instructions .
However , these instructions are typically all about as simple as those we have just described .

Software You do not normally talk directly to the computer , but communicate with it through an operating system .
The operating system allocates the resources to the different tasks that the computer must accomplish .
The operating system is actually program , but it is perhaps better to think of it as your chief servant .
It is in charge of all your other servant programs , and it delivers your requests to them .
If you want to run program , you tell the operating system the name of the file that contains it , and the operating system runs the program .
If you want to edit file , you tell the operating system the name of the file and it starts up the editor to work on that file .

To most users , the operating system is the computer .
Most users never see the computer without its operating system .
The names of some common operating systems are UNIX , DOS , Linux , Windows , Mac OS , iOS , and Android .

program is set of instructions for computer to follow .
As shown in Display , the input to computer can be thought of as consisting of two parts , program and some data .
The computer follows the instructions in the program and in that way performs some process .
The data is what we conceptualize as the input to the program .
For example , if the program adds two numbers , then the two numbers are the data .
In other words , the data is the input to the program , and both the program and the data are input to the computer via the operating .
Whenever we give computer Display Simple View of Running Program Program Data .

Chapter Introduction to Computers and Programming both program to follow and some data for the program , we are said to be running the program on the data , and the computer is said to execute the program on the data .
The word data also has much more general meaning than the one we have just given it .
In its most general sense , it means any information available to the computer .
The word is commonly used in both the narrow sense and the more general sense .

Languages There are many languages for writing programs .
In this text we will discuss the programming language and use it to write our programs .
is language , as are most of the other programming languages you are likely to have heard of , such as , Java , Python , PHP , Pascal , Visual Basic , FORTRAN , COBOL , Lisp , Scheme , and Ada .
languages resemble human languages in many ways .
They are designed to be easy for human beings to write programs in and to be easy for human beings to read .
language , such as , contains instructions that are much more complicated than the simple instructions processor is capable of following .

The kind of language computer can understand is called lowlevel language .
The exact details of languages differ from one kind of computer to another .
typical instruction might be the following : ADD This instruction might mean the number in the memory location called to the number in the memory location called , and place the result in the memory location called " The above sample instruction is written in what is called assembly language .
Although assembly language is almost the same as the language understood by the computer , it must undergo one simple translation before the computer can understand it .

In order to get computer to follow an assembly language instruction , the words need to be translated into strings of and .
For example , the word ADD might translate to , the might translate to , the to , and the to .
The version of the instruction above that the computer ultimately follows would then be : Assembly language instructions and their translation into and differ from machine to machine .

Programs written in the form of and are said to be written in machine language , because that is the version of the program that the computer actually reads and follows .
Assembly language and machine language are almost the same thing , and the distinction between them will not be important to us .
The important distinction is that between Computer Systems machine language and languages like : Any language program must be translated into machine language before the computer can understand and follow the program .

Compilers program that translates language like to machine language is called compiler .
compiler is thus somewhat peculiar sort of program , in that its input or data is some other program , and its output is yet another program .
To avoid confusion , the input program is usually called the source program or source code , and the translated version produced by the compiler is called the object program or object code .
The word code is frequently used to mean program or part of program , and this usage is particularly common when referring to object programs .
Now , suppose you want to run program that you have written .
In order to get the computer to follow your instructions , proceed as follows .
First , run the compiler using your program as data .
Notice that in this case , your program is not being treated as set of instructions .
To the compiler , your program is just long string of characters .
The output will be another long string of characters , which is the equivalent of your program .
Next , run this program on what we normally think of as the data for the program .
The output will be what we normally conceptualize as the output of the program .
The basic process is easier to visualize if you have two computers available , as diagrammed in Display .
In reality , the entire process is accomplished by using one computer two times .

Compiler compiler is program that translates language program , such as program , into program that the computer can directly understand and execute .

The complete process of translating and running program is bit more complicated than what we show in Display .
Any program that have already been programmed for you .
These items that are already programmed for you input and output are already compiled and have their object code waiting to be combined with your object code to produce complete program that can be run on the computer .
Another program , called linker , combines the object code for these program pieces with the object code that the compiler produced .

Chapter Introduction to Computers and Programming from your program .
The interaction of the compiler and the linker are diagrammed in Display .
In routine cases , many systems will do this linking for you automatically .
Thus , you may not need to worry about linking in many cases .

Linking The object code for your program must be combined with the object code for routines as input and output that your program uses .
This process of combining object code is called linking and is done by program called linker .
For simple programs , linking may be done for you automatically .

program Data for program Compiler .

Computer Output of program Computer Systems Display Preparing Program for Running program Compiler .

What are the five main components of computer .

What would be the data for program to add two numbers .

What would be the data for program that assigns letter grades to students in class .

What is the difference between program and highlevel language program .

What is the role of compiler .

What is source program .
What is an object program .

What is an operating system .

What purpose does the operating system serve .

Chapter Introduction to Computers and Programming .
Name the operating system that runs on the computer you use to prepare programs for this course .

Find out whether linking is done automatically by the compiler you use for this course .

It can do whatever we know how to order it to perform .
It can follow analysis ; but it has no power of anticipating any analytical relations or truths .
Its province is to assist us in making available what we are already acquainted with .

History Note Babbage , Ada Augusta The first truly programmable computer was designed by Charles Babbage , an English mathematician and physical scientist .

Babbage began the project sometime before and worked on it for the rest of his life .
Although he never completed the construction of his machine , the design was conceptual milestone in the history of computing .
Much of what we know about Charles Babbage and his computer design comes from the writings of his colleague Ada Augusta , the Countess of Lovelace and the daughter of the poet Byron .
Ada Augusta is frequently given the title of the first computer programmer .
Her comments , quoted in the opening of the this section , still apply to the process of solving problems on computer .
Computers are not magic and do not , at least as yet , have the ability to formulate sophisticated solutions to all the problems we encounter .
Computers simply do what the programmer orders them to do .
The solutions to problems are carried out by the computer , but the solutions are formulated by the programmer .
Our discussion of computer programming begins with discussion of how programmer formulates these solutions .

In this section we describe some general principles that you can use to design and write programs .

They apply no matter what programming language you are using .

Algorithms When learning your first programming language , it is easy to get the impression that the hard part of solving problem on computer is translating your ideas into the specific language that will be fed into the computer .
This definitely is not the case .
The most difficult part of solving problem on computer is discovering the method of solution .
After you come up with method of solution , it is routine to translate your method into the required language , be it or some other programming language .
It is therefore helpful to temporarily ignore the programming language and to concentrate instead on formulating the steps of the solution and writing them down in plain English , as if the instructions were to be given to human being rather than computer .
sequence of instructions expressed in this way is frequently referred to as an algorithm .

sequence of precise instructions which leads to solution is called an algorithm .
Some approximately equivalent words are recipe , method , Programming and Charles Babbage model of computer Ada Augusta , Countess of Lovelace and the first computer programmer directions , procedure , and routine .
The instructions may be expressed in programming language or human language .
Our algorithms will be expressed in English and in the programming language .
computer program is simply an algorithm expressed in language that computer can understand .
Thus , the term algorithm is more general than the term program .

However , when we say that sequence of instructions is an algorithm , we usually mean that the instructions are expressed in English , since if they were expressed in programming language we would use the more specific term program .
An example may help to clarify the concept .

Display contains an algorithm expressed in English .
The algorithm determines the number of times specified name occurs on list of names .

If the list contains the winners of each of last football games and the name is that of your favorite team , then the algorithm determines how many games your team won .
The algorithm is short and simple but is otherwise very typical of the algorithms with which we will be dealing .

Chapter Introduction to Computers and Programming Display An Algorithm Algorithm that determines how many times name occurs in list of names :

Get the list of names .

Get the name being checked .

Set counter to zero .

Do the following for each name on the list : Compare the name on the list to the name being checked , and if the names are the same , then add one to the counter .

Announce that the answer is the number indicated by the counter .

The instructions numbered through in our sample algorithm are meant to be carried out in the order they are listed .
Unless otherwise specified , we will always assume that the instructions of an algorithm are carried out in the order in which they are given .
Most interesting algorithms do , however , specify some change of order , usually repeating of some instruction again and again such as in instruction of our sample algorithm .

The word algorithm has long history .
It derives from the name alKhowarizmi , Persian mathematician and astronomer .
He wrote famous textbook on the manipulation of numbers and equations .

The book was entitled Kitab , which can be translated as Rules for Reuniting and Reducing .
The word algebra was derived from the Arabic word , which appears in the title of the book and which is often translated as reuniting or restoring .
The meanings of the words algebra and algorithm used to be much more intimately related than they are today .
Indeed , until modern times , the word algorithm usually referred only to algebraic rules for solving numerical equations .
Today , the word algorithm can be applied to wide variety of kinds of instructions for manipulating symbolic as well as numeric data .
The properties that qualify set of instructions as an algorithm now are determined by the nature of the instructions rather than by the things manipulated by the instructions .

To qualify as an algorithm , set of instructions must completely and unambiguously specify the steps to be taken and the order in which they are taken .
The person or machine carrying out the algorithm does exactly what the algorithm says , neither more nor less .

Algorithm An algorithm is sequence of precise instructions that leads to solution .

There is no complete set of rules , no algorithm to tell you how to write programs .
Program design is creative process .
Still , there is the outline of plan to follow .
The outline is given in diagrammatic form in Display .
As indicated there , the entire program design process can be divided into two phases , the phase and the implementation phase .
The result of the phase is an algorithm , expressed in English , for solving the problem .
To produce program in programming language such as , the algorithm is translated into the programming language .
Producing the final program from the algorithm is called the implementation phase .

The first step is to be certain that the you want your program to completely and precisely specified .
Do not take this step lightly .

If you do not know exactly what you want as the output of your program , you may be surprised at what your program produces .
Be certain that you know what the input to the program will be and exactly what information is supposed to be in the output , as well as what form that information should be in .
For example , if the program is bank accounting program , you must know not only the interest rate but also whether interest is to be compounded annually , monthly , daily , or whatever .
If the program is supposed to write poetry , you need to determine whether the poems can be in free verse or must be in iambic pentameter or some other meter .

Many novice programmers do not understand the need to design an algorithm before writing program in programming language , such as , and so they try to the process by omitting the problemsolving phase entirely , or by reducing it to just the part .

Why not for the mark " and save time .
The answer is that it does not save time .
Experience has shown that the process will produce correctly working program faster .
The process simplifies the algorithm design phase by isolating it from the detailed rules of programming language such as .
The result is that the algorithm design process becomes much less intricate and much less prone to error .
For even program , it can represent the difference between half day of careful work and several frustrating days of looking for mistakes in poorly understood program .

The implementation phase is not trivial step .
There are details to be concerned about , and occasionally some of these details can be subtle , but it is much simpler than you might at first think .
Once you become familiar with or any other programming language , the translation of an algorithm from English into the programming language becomes routine task .

As indicated in Display , testing takes place in both phases .
Before the program is written , the algorithm is tested , and if the algorithm is found to be deficient , then the algorithm is redesigned .
That desktop testing is performed by mentally going through the algorithm and executing the steps yourself .

Chapter Introduction to Computers and Programming Display Program Design Process phase Start Implementation phase Problem definition Algorithm design Translating to Desktop testing Testing Working program For large algorithms this will require pencil and paper .
The program is tested by compiling it and running it on some sample input data .
The compiler will give error messages for certain kinds of errors .
To find other types of errors , you must somehow check to see whether the output is correct .

The process diagrammed in Display is an idealized picture of the program design process .
It is the basic picture you should have in mind , but reality is sometimes more complicated .
In reality , mistakes and deficiencies are discovered at unexpected times , and you may have to back up and redo an earlier step .
For example , as shown in Display , testing the algorithm might reveal that the definition of the problem was incomplete .
In such case you must back up and reformulate the definition .
Occasionally , deficiencies in the definition or algorithm may not be observed until program is tested .
In that case you must back up and modify the problem definition or algorithm and all that follows them in the design process .

Programming The program design process that we outlined in the previous section represents program as an algorithm of for manipulating some data .
That is correct view , but not always the most productive view .

Modern programs are usually designed using method known as objectoriented programming , or OOP .
In OOP , program is viewed as collection Programming and of interacting objects .
The methodology is easiest to understand when the program is simulation program .
For example , for program to simulate highway interchange , the objects might represent the automobiles and the lanes of the highway .
Each object has algorithms that describe how it should behave in different situations .
Programming in the OOP style consists of designing the objects and the algorithms they use .
When programming in the OOP framework , the term Algorithm design in Display would be replaced with the phrase Designing the objects and their algorithms .

The main characteristics of OOP are encapsulation , inheritance , and polymorphism .
Encapsulation is usually described as form of information hiding or abstraction .
That description is correct , but perhaps an characterization is to say that encapsulation is form of simplification of the descriptions of objects .
Inheritance has to do with writing reusable program code .
Polymorphism refers to way that single name can have multiple meanings in the context of inheritance .
Having made those statements , we must admit that they hold little meaning for readers who have not heard of OOP before .
However , we will describe all these terms in detail later in this book .
accommodates OOP by providing classes , kind of data type combining both data and algorithms .

The Software Life Cycle Designers of large software systems , such as compilers and operating systems , divide the software development process into six phases collectively known as the software life cycle .
The six phases of this life cycle are :
Maintenance and evolution of the system .
Obsolescence We did not mention the last two phases in our discussion of design because they take place after the is finished and put into service .

However , they should always be kept in mind .
You will not be able to add improvements or corrections to your unless you design it to be easy to read and easy to change .
Designing programs so that they can be easily modified is an important topic that we will discuss in detail when we have developed bit more background and few more programming techniques .
The meaning of obsolescence is obvious , but it is not always easy to accept .
When is not working as it should and cannot be fixed with reasonable amount of effort , it should be discarded and replaced with completely new .

Chapter Introduction to Computers and Programming Se es Exe cise .
An algorithm is approximately the same thing as recipe , but some kinds of steps that would be allowed in recipe are not allowed in an algorithm .

Which steps in the following recipe would be allowed in an algorithm .

Place teaspoons of sugar in mixing bowl .

Add egg to mixing bowl .

Add cup of milk to mixing bowl .

Add ounce of rum , if you are not driving .

Add vanilla extract to taste .

Beat until smooth .

Pour into pretty glass .

Sprinkle with nutmeg .

What is the first step you should take when creating .

The design process can be divided into two main phases .

In this section we introduce you to the programming language , which is the programming language used in this book .

Origins of the Language The first thing that people notice about the language is its unusual name .

Are there programming languages named and .
The answer to most of these questions is no .
But the general thrust of the questions is on the mark .
There is programming language ; it was not derived from language called , but from language called BCPL .
The language was derived from the language , and was derived from the language .
Why are there two pluses in the name .
As you will see in the next chapter , is an operation in the and languages , so using produces nice pun .
The languages BCPL and do not concern us .
They are earlier versions of the programming language .
We will start our description of the programming language with description of the language .

The programming language was developed by Dennis Ritchie of Bell Laboratories in the .
It was first used for writing and maintaining the Introduction to UNIX operating system .
If you wanted to maintain your UNIX system , you needed to use .
and UNIX fit together so well that soon not just systems programs , but almost all commercial programs that ran under UNIX were written in the language .
became so popular that versions of the language were written for other popular operating systems ; its use is not limited to computers that use UNIX .
However , despite its popularity , is not without its shortcomings .

The language is peculiar because it is language with many of the features of language .
is somewhere in between the two extremes of very high level language and language , and therein lies both its strengths and its weaknesses .
Like assembly language , language programs can directly manipulate the memory .
On the other hand , has many features of language , which makes it easier to read and write than assembly language .
This makes an excellent choice for writing systems programs , but for other programs in some sense even for systems , is not as easy to understand as other languages ; also , it does not have as many automatic checks as some other languages .

To overcome these and other shortcomings of , Bjarne Stroustrup of Bell Laboratories developed in the early .
Stroustrup designed to be better .
Most of is subset of , and so most programs are also programs .
The language continues to evolve .
Major new were added in .
This version is referred to as .
Minor are expected in and major again in .

Sample Program Display contains simple and the screen display that might be generated when user runs and interacts with this .
The person who runs is called the user .
The output when the is run is shown in the Sample Dialogue .
The text typed in by the user is shown in color to distinguish it from the text output by the .
On the actual screen both texts would look alike .
The source code for the is shown in lines .

The line numbers are shown only for reference .
You would not type in the line numbers when entering the .
Keywords with predefined meaning in are shown in color .
These keywords are discussed in Chapter .
The person who writes the is called the programmer .
Do not confuse the roles of the user and the programmer .
The user and the programmer might or might not be the same person .
For example , if you write and then run  you are both the programmer and the user .
With professionally produced programs , the programmer and the user are usually different persons .

Chapter Introduction to Computers and Programming Display Sample Program .

Sample Dialogue Press return after entering number .

Enter the number of pods : Enter the number of peas in pod : If you have pea pods and peas in each pod , then you have peas in all the pods .

In the next chapter we will explain in detail all the you need to write programs like the one in Display , but to give you feel for how program works , we will now provide brief description of how this particular program works .
If some of the details are bit unclear , do not worry .

In this section we just want to give you feel for what program is .

The beginning and end of our sample program contain some details that need not concern us yet .
The program begins with the following .

We will briefly describe these lines , starting with the following line : int ,  This line is called variable declaration .
This variable declaration tells the computer that , and will be used as names for three variables .
Variables will be explained more precisely in the next chapter , but it is easy to understand how they are used in this program .

In this program the variables are used to name numbers .
The word that starts this line , int , is an abbreviation for the word integer and it tells the computer that the numbers named by these variables will be integers .
An integer is whole number , like , and so forth .

The remaining lines are all instructions that tell the computer to do something .
These instructions are called statements or executable statements .

In this program each statement fits on exactly one line .
That need not be true , but for very simple programs , statements are usually listed one per line .

Most of the statements begin with either the word cin or .
These statements are input statements and output statements .
The word cin , which is pronounced " is used for input .
The statements that begin with cin tell the computer what to do when information is entered from the keyboard .
The word  which is pronounced " is used for output , that is , for sending information from the program to the terminal screen .
The letter c is there because the language is .
The arrows , written or , tell you the direction that data is moving .
The arrows , and , are called ' and ' or to ' and ' respectively .
For example , consider the line : return after entering ; This line may be read , to  or simply .
If you think of the word as name for the screen output , then the arrows tell the computer to send the string in quotes to the screen .
As shown in the sample dialogue , this causes .

Chapter Introduction to Computers and Programming the text contained in the quotes to be written to the screen .
The at the end of the quoted string tells the computer to start new after writing out the text .
Similarly , the next of the program also begins with  and that program causes the following of text to be written to the screen : Enter the number of pods : The next program starts with the word cin , so it is an input statement .

look at that  cin ; This may be read , from cin ' or simply .

If you think of the word cin as standing for the keyboard input , then the arrows say that input should be sent from the keyboard to the variable .
Look again at the sample dialogue .
The next shown has written in bold .
We use bold to indicate something typed in at the keyboard .
If you type in the number , then the appears on the screen .
If you then press the Return key is also sometimes called the Enter , that makes the available to the program .
The statement which begins with cin tells the computer to send that input value of to the variable .
From that point on , has the value ; when we see later in the program , we can think of it as standing for the number .

Consider the next two program lines : the number of peas in ; cin ; These lines are similar to the previous two lines .
The first sends message to the screen asking for number .
When you type in number at the keyboard and press the Return key , that number becomes the value of the variable .
In the sample dialogue , we assume that you type in the number .

After you type in and press the Return key , the value of the variable becomes .

The next nonblank program  shown below , does all the computation that is done in this simple program : The asterisk symbol , is used for multiplication in .
So this statement says to multiply and .
In this case , is multiplied by to give result of .
The equal sign says that the variable should be made equal to this result of .
This is special use of the equal sign ; its meaning here is different than in other mathematical contexts .
It gives the variable on the side  in this case it makes the of .

These are just three more output statements that work basically the same as the previous statements that begin with .
The only thing that is is the second of these three statements , which says to output the variable .
When variable is output , it is the of the variable that is output .
So this statement causes to be output .
is not begun until the special instruction is sent as output .

The rest of the program contains nothing  if you understand what we have discussed so far , you should be able to understand the rest of the program .

PITFALL Using the Wrong Slash in When you use in statement be sure that you use the backslash , which is written .
If you make mistake use rather than , the compiler will not give you an error message .
Your program will run , but the output will look peculiar .

They point in the direction that data moves .
For example , consider the statement : cin ; In the above statement , data moves from the keyboard to the variable .

On the other hand , consider the output statement : In this statement the data moves from the variable to the screen , so the arrow points from the variable to .

Chapter Introduction to Computers Programming Layout of Simple Program The general form of simple program is shown in Display .
As far as the compiler is concerned , the breaks spacing need not be as shown there in our examples .
The compiler will accept any reasonable pattern of breaks indentation .
In fact , the compiler will even accept most unreasonable patterns of breaks indentation .
However , program should always be laid out so that it is easy to read .
Placing the opening brace , on by itself also placing the closing brace , on by itself will make these punctuations easy to find .
Indenting each statement placing each statement on separate makes it easy to see what the program instructions are .
Later on , some of our statements will be too long to fit on one then we will use slight variant of this pattern for indenting breaks .
You should follow the pattern set by the examples in this book , or follow the pattern specified by your instructor if you are in class .

In Display , the variable declarations are on the that begins with the word int .
As we will see in the next chapter , you need not place all your variable declarations at the beginning of your program , but that is good default location for them .
Unless you have reason to place them somewhere else , place them at the start of your program as shown in Display in the sample program in Display .
The statements are the instructions that are followed by the computer .
In Display , the statements are the lines that begin with or cin the one that begins with followed by an equal sign .
Statements are often called executable statements .
We will use the terms statement executable statement interchangeably .
Notice that each of the statements we have seen ends with semicolon .
The semicolon in statements is used in more or less the same way that the period is used in English sentences ; it marks the end of statement .

Display Layout of Simple Program .

For now you can view the first few lines as funny way to say is the beginning of the " But we can explain them in bit more detail .
The first is called an directive .
It tells the compiler where to find information about certain items that are used in your program .
In this case iostream is the name of library that contains the definitions of the routines that handle input from the keyboard output to the screen ; iostream is file that contains some basic information about this library .
The linker program that we discussed earlier in this chapter combines the object code for the library iostream the object code for the program you write .
For the library iostream this will probably happen automatically on your system .
You will eventually use other libraries as well , when you use them , they will have to be named in directives at the start of your program .
For other libraries , you may need to do more than just place an directive in your program , but in order to use any library in your program , you will always need to at least place an directive for that library in your program .
Directives always begin with the symbol .
Some compilers require that directives have no spaces around the , so it is always safest to place the at the very start of the line not any space between the the word .

The following line further explains the directive that we just explained : using namespace std ; This line says that the names defined in iostream are to be interpreted in the way " is an abbreviation of .
We will have more to say about this line bit later in this book .

The third and fourth nonblank lines , shown next , simply say that the main part of the program starts here : The correct term is main function , rather than main part , but the reason for that subtlety will not concern us until Chapter .
The braces and mark the beginning and end of the main part of the program .
They need not be on line by themselves , but that is the way to make them easy to find and we will therefore always place each of them on line by itself .

The line return ; says to the program when you get to " This line need not be the last thing in the program , but in very simple program it makes no sense to place it anywhere else .
Some compilers will allow you to omit this line and will figure out that the program ends when there are no more statements to .

Chapter Introduction to Computers and Programming execute .
However , other compilers will insist that you this line , so it is best to get in the habit of including it , even if your compiler is happy without it .
This line is called return statement and is considered to be an executable statement because it tells the computer to do something ; specifically , it tells the computer to end the program .
The number has no intuitive significance to us yet , but must be there ; its meaning will become clear as you learn more about .
Note that even though the return statement says to end the program , you still must add closing brace , at the end of the main part of your program .

PITFALL Putting Space Before the File Name Be certain that you do not have any extra space between the and the iostream file name or between the end of the file name and the closing .
The compiler directive is not very smart : It will search for file name that starts or ends with space .
The file name will not be found , producing an error that is quite difficult to locate .
You should make this error deliberately in small program , then compile it .
Save the message that your compiler produces so you know what the error message means the next time you get that error message .

But where is that program and how do you make it run .

You write program using text editor in the same way that you write any other term paper , love letter , shopping list , or whatever .

The program is kept in file just like any other document you prepare using text editor .
There are different text editors , and the details of how to use them will vary from one to another , so we cannot say too much more about your text editor .
You should consult the documentation for your editor .

The way that you compile and run program also depends on the particular system you are using , so we will discuss these points in only very general way .
You need to learn how to give the commands to compile , link , and run program on your system .
These commands can be found in the manuals for your system and by asking people who are already using on your system .
When you give the command to compile your program , this will produce translation of your program .
This translated version is called the object code for your program .

The object code must be linked is , with the object code for routines as input and output that are already written for you .
It is likely that this linking will be done automatically , so you do not need to worry about linking .
But on some systems , you may be required to make separate call to the linker .
Again , consult your manuals or local expert .
Finally , you give the command to run your program ; how you give Introduction to that command also depends on the system you are using , so check with the manuals or local expert .

PITFALL Compiling Program known as is the most recent version of the standard of the programming .
It was approved on August , by the International Organization for Standardization .
compiler is able to compile and run programs written for older versions of .
However , the version includes new features that are not compatible with older compilers .
This means that if you have an older compiler then you may not be able to compile and run programs .

You may also need to specify whether or not to compile against the standard .
For example , requires the compiler flag of to be added to the command line ; otherwise the compiler will assume that the program is written to an older standard .
The command line to compile program named would look like : Check the documentation with your compiler to determine if any special steps are needed to compile programs and to determine what features are supported .

Obtain copy of the program in Display .
It is available for downloading over the Internet .

Do not type in the line numbers .
Compile the program .
If you get an error message , check your typing , fix any typing mistakes , and recompile the file .

Once the program compiles with no error messages , try running the program .

If you get the program to compile and run normally , you are all set .
You do not need to do anything different from the examples shown in the book .

If this program does not compile or does not run normally , then read on .
In what follows we offer some hints for dealing with your setup .
Once you get this simple program to run normally , you will know what small changes to make to your program files in order to get them to run on your system .

If your program seems to run , but you do not see the output line Testing , then , in all likelihood , the program probably did give that output , but it disappeared before you could see it .
Try adding the following to the end of your program , just before the line return ; these lines should stop your program to allow you to read the output .

Chapter Introduction to Computers and Programming Display .

If the program does not compile or run at all , then try changing .

If your program requires instead of iostream , then you have an .

If your program still does not compile and run normally , try deleting using namespace  If your program still does not compile and run , then check the documentation for your version of to see if any more " are needed for "

If you are not in course or you are not using the course computer , check the documentation for your compiler or check with friend who has similar computer setup .
The necessary change is undoubtedly very small and , once you find out what it is , very easy .

Se st Exer cise .
If the following statement were used in program , what would it cause to be written on the screen .

What , if anything , is wrong with the following directives .

Lewis Carroll , Through the mistake in program is usually called bug , and the process of eliminating bugs is called debugging .
There is colorful history of how this term came into use .
It occurred in the early days of computers , when computer hardware was .

Chapter Introduction to Computers and Programming extremely sensitive and occupied an entire room .
Rear Admiral Grace Murray Hopper was third programmer on the first largescale digital "
Gurer , women in computer science " CACM , January While Hopper was working on the Harvard Mark computer under the command of Harvard professor Howard .
Aiken , an unfortunate moth caused relay to fail .
Hopper and the other programmers taped the deceased moth in the logbook with the note actual case of bug being " The logbook is currently on display at the Naval Museum in Dahlgren , Virginia .
This was the first documented computer bug .
Professor Aiken would come into the facility during slack time and inquire if any numbers were being computed .
The programmers would reply that they were debugging the computer .
For more information about Admiral Hopper and other persons in computing , see Robert Slater , Portraits in Silicon Press ,
Today , bug is mistake in program .

In this section we describe the three main kinds of programming mistakes and give some hints on how to correct them .

Kinds of Program Errors The compiler will catch certain kinds of mistakes and will write out an error message when it finds mistake .
It will detect what are called syntax errors , because they are , by and large , violation of the syntax is , the grammar of the programming language , such as omitting semicolon .

If the compiler discovers that your program contains syntax error , it will tell you where the error is likely to be and what kind of error it is likely to be .

When the compiler says your program contains syntax error , you can be confident that it does .
However , the compiler may be incorrect about either the location or the nature of the error .
It does better job of determining the location of an error , to within line or two , than it does of determining the source of the error .
This is because the compiler is guessing at what you meant to write down and can easily guess wrong .
After all , the compiler cannot read your mind .
Error messages subsequent to the first one have higher likelihood of being incorrect with respect to either the location or the nature of the error .
Again , this is because the compiler must guess your meaning .
If the first guess was incorrect , this will affect its analysis of future mistakes , since the analysis will be based on false assumption .

If your program contains something that is direct violation of the syntax rules for your programming language , the compiler will give you an error message .
However , sometimes the compiler will give you only warning message , which indicates that you have done something that is not , technically speaking , violation of the programming language syntax rules , but that is unusual enough to indicate likely mistake .
When you get warning message , the compiler is saying , you sure you mean " At this stage of your development , you should treat every warning as if it were an error until your instructor approves ignoring the warning .

Appropriately enough , these are called errors .
Most computer systems will detect certain errors and output an appropriate error message .
Many errors have to do with numeric calculations .
For example , if the computer attempts to divide number by zero , that is normally error .

If the compiler approved of your program and the program ran once with no error messages , this does not guarantee that your program is correct .
Remember , the compiler will only tell you if you wrote syntactically is , correct program .
It will not tell you whether the program does what you want it to do .
Mistakes in the underlying algorithm or in translating the algorithm into the language are called logic errors .

For example , if you were to mistakenly use the addition sign + instead of the multiplication sign in the in Display , that would be logic error .
The would compile and run normally but would give the wrong answer .
If the compiler approves of your and there are no runtime errors but the does not perform properly , then undoubtedly your contains logic error .
Logic errors are the hardest kind to diagnose , because the computer gives you no error messages to help find the error .
It cannot reasonably be expected to give any error messages .
For all the computer knows , you may have meant what you wrote .

PITFALL Assuming Your Program Is Correct In order to test new for logic errors , you should run the on several representative data sets and check its performance on those inputs .

If the passes those tests , you can have more confidence in it , but this is still not an absolute guarantee that the is correct .
It still may not do what you want it to do when it is run on some other data .
The only way to justify confidence in is to carefully and so avoid most errors .

What are the three main kinds of errors .

What kinds of errors are discovered by the compiler .

If you omit punctuation symbol as from  an error is produced .
What kind of error .

Omitting the final brace from produces an error .
What kind of error .

Chapter Introduction to Computers and Programming Suppose your has situation about which the compiler reports warning .

Give the answer and your local answer if it is different from the .
Identify your answers as the or as based on your local rules .

What kind of error is this .

Chapter Summary The collection of programs used by computer is referred to as the software for that computer .
The actual physical machines that make up computer installation are referred to as hardware .

Main memory is used only while the is running .
Secondary memory is used to hold data that will stay in the computer before after the is run .

The number associated with one of these bytes is called the address of the byte .
Often , several of these bytes are grouped together to form larger memory location .
In that case , the address of the first byte is used as the address of this larger memory location .

digit that can only be zero or one is called bit .

Algorithms can be written in English or in programming language , like .
However , the word algorithm is usually used to mean sequence of instructions written in English some other human language , such as Spanish or .

The computer will usually tell you about errors in the first two categories .
You must discover logic errors yourself .

Answers to Exercises The individual instructions in are called statements .

Answers to Exer cises .
The five main components of computer are the input , the output , the processor , the main memory , and the secondary memory .

The two numbers to be added .

The grades for each student on each test and each assignment .

is language consisting of and that the computer can directly execute .
language is written in more format and is translated by compiler into machinelanguage that the computer can directly understand and execute .

compiler translates language into .

The language that is input to compiler is called the source .
The translated that is output by the compiler is called the object .

An operating system is  or several cooperating programs , but is best thought of as the chief servant .

An operating purpose is to allocate the resources to different tasks the computer must accomplish .

Among the possibilities are the Macintosh operating system Mac OS , Windows , VMS , Solaris , SunOS , UNIX perhaps one of the operating systems such as .

The object code for your program must be combined with the object code for routines as input and output that your program uses .
This process of combining object code is called linking .
For simple programs , this linking may be done for you automatically .

Chapter Introduction to Computers and Programming .
The answer varies , depending on the compiler you use .
Most UNIX and compilers link automatically , as do the compilers in most integrated development environments for Windows and Macintosh operating systems .

The following instructions are too vague for use in an algorithm : Add vanilla extract to taste .

Beat until smooth .

Pour into pretty glass .

Sprinkle with nutmeg .

The notions of " and " are not precise .

The instruction " is too vague , since it does not specify how much nutmeg to sprinkle .
The other instructions are reasonable to use in an algorithm .

The first step you should take when creating program is to be certain that the task to be accomplished by the program is completely and precisely specified .

The phase and the implementation phase .

is easy to understand .

The symbols tell the computer to start new in the output so that the next item output will be on the next .

This statement tells the computer to read the next number that is typed in at the keyboard and to send that number to the variable named .

This statement says to multiply the two numbers in the variables and , and to place the result in the variable named .

The directive tells the compiler to fetch the file and extraction operators for and .
This enables correct linking of the object code from the iostream library with the statements in the program .

Practice Programs .
The three main kinds of program errors are syntax errors , errors , and logic errors .

The compiler detects syntax errors .
There are other errors that are not technically syntax errors that we are lumping with syntax errors .
You will learn about these later .

The text states that you should take warnings as if they had been reported as errors .
You should ask your instructor for the local rules on how to handle warnings .

logic error .

Practice ProgramS Practice Programs can generally be solved with short program that directly applies the programming principles presented in this chapter .

Using your text editor , enter is , type the program shown in Display .
Be certain to type the first exactly as shown in Display .
In particular , be sure that the first begins at the end of the with no space before or after the symbol .
Compile and run the program .
If the compiler gives you an error message , correct the program and recompile the program .
Do this until the compiler gives no error messages .
Then run your program .

Modify the program you entered in Practice Program .
Change the program so that it first writes the word Hello to the screen and then goes on to do the same things that the program in Display does .
You will only have to add one to the program to make this happen .
Recompile the changed program and run it .
Then change the program even more .
Add one more that will make the program write the word to the screen at the end of the program .
Be certain to add the symbols to the last output statement so that it reads as follows : systems require that final , and your system may be one of Recompile and run the changed program .

Further modify the program that you already modified in Practice Program .
Change the multiplication sign in your program to division sign .
Recompile the changed program .
Run the program .
Enter input for of peas in " Notice the error message due to division by zero .

Chapter Introduction to Computers and Programming .
Modify the program that you entered in Practice Program .
Change the multiplication sign in your program to an addition sign +

Recompile and run the changed program .
Notice that the program compiles and runs perfectly fine , but the output is incorrect .
That is because this modification is logic error .

Modify the program that you entered in Practice Program .
In this version calculate the total length of fence you would need to enclose rectangular area that is width feet long and height feet tall .
The program should have variables for width and height with values entered by the user .
Create another variable , totalLength , that stores the total length of fence needed your program should .
Output the total with an appropriate message .

VideoNote Solution to Practice Program .
The purpose of this exercise is to produce catalog of typical syntax errors and error messages that will be encountered by beginner and to continue acquainting you with the programming environment .
This exercise should leave you with knowledge of what error to look for when given any of number of common error messages .

If not , you should use program from one of the previous Practice Programs .

Keep the catalog of errors and add program errors and messages to it as you continue through this course .

The sequence of suggested errors to introduce is :
Put an extra space between the and the iostream file name .

Omit one of the or symbols in the include directive .

Omit the int from int .

Omit or misspell the word main .

Omit one of the ; then omit both the .

Omit one or both of the in the statement ; leave off the ending curly brace .

Programming Projects Programming Projects require more than Practice Programs and can usually be solved many different ways .
Visit to complete many of these Programming Projects online and get instant feedback .

Write program that reads in two integers and then outputs both their sum and their product .
One way to proceed is to start with the program in Programming Projects Display and to then modify that program to produce the program for this project .
Be certain to type the first line of your program exactly the same as the first line in Display .
In particular , be sure that the first line begins at the end of the line with no space before or after the symbol .

Also , be certain to add the symbols to the last output statement in your program .
For example , the last output statement might be the following : is the end of the ; systems require that final , and your system may be one of .
Write program that prints out " in large block letters inside border of followed by two blank lines then the message Computer Science is Cool Stuff .
The output should look as follows :

OO Computer Science is Cool .

Write program that allows the user to enter number of quarters , dimes , and nickels and then outputs the monetary value of the coins in cents .
For example , if the user enters for the number of quarters , for the number of dimes , and for the number of nickels , then the program should output that the coins are worth cents .

Write program that allows the user to enter time in seconds and then outputs how far an object would drop if it is in freefall for that length of time .
Assume that the object starts at rest , there is no friction or resistance from air , and there is constant acceleration of feet per second due to gravity .
Use the equation : acceleration time You should first compute the product and then divide the result by reason for this will be discussed later in the .

VideoNote Solution to Programming Project Chapter Introduction to Computers and Programming .
Write program that inputs character from the keyboard and then outputs large block letter " composed of that character .
For example , if the user inputs the character " then the output should look as follows : Basics Variables and Assignments Variables Names : Identifiers Variable Declarations Assignment Statements Pitfall : Uninitialized Variables Programming Tip : Use Meaningful Names The Type char The Type bool Introduction to the Class Type Compatibilities Arithmetic Operators and Expressions Pitfall : Whole Numbers in Division More Assignment Statements Input and Output Output Using Include Directives and Namespaces Escape Sequences Programming Tip : End Each Program with or endl Formatting for Numbers with Decimal Point Input cin Designing Input and Output Programming Tip : Line Breaks in Simple Flow Control Simple Branching Mechanism  Strings Inequalities  in place Compound Statements Simple Loop Mechanisms Increment and Decrement Operators Programming Example : Charge Card Balance  Infinite Loops Data Types and Expressions The Types int and double Other Number Types Types Chapter Summary Answers to Exercises Program Style Indenting Comments Naming Constants Practice Programs Programming Projects imagine you know what computer terminal is .
computer terminal is not some clunky old television with typewriter in front it .
It is an interface where the mind and the body can connect with the universe and move bits it about .

Introduction In this chapter we explain some additional sample programs and present enough details the language to allow you to write simple programs .

Prerequisites In Chapter we gave brief description one sample program .

DIjkstra , Notes on Structured Programming Programs manipulate data such as numbers letters .
most other common programming languages use programming constructs known as variables to name store data .
Variables are at the very heart programming language like , so that is where we start our description .
We will use the program in Display for our discussion will explain all the items in that program .
While the general idea that program should be clear , some the details are new will require some explanation .

Variables variable can hold number or data other types .
For the moment , we will confine our attention to variables that hold only numbers .
These variables are like small blackboards on which the numbers can be written .

Just as the numbers written on blackboard can be changed , so too can the number held by variable be changed .
Unlike blackboard that might possibly contain no number at all , variable is guaranteed to have some value in it , if only garbage number left in the memory by some previously run program .
The number or other type data held in Variables Assignments variable is called its value ; that is , the value variable is the item written on the figurative blackboard .
In the program in Display , are variables .
For example , when this program is run with the input shown in the sample dialogue , has its value set equal to the number with the statement cin ; Later , the value the variable is changed to when second copy the same statement is executed .
We will discuss exactly how this happens little later in this chapter .

Of course , variables are not blackboards .
In programming languages , variables are implemented as memory locations .
The compiler assigns memory location the kind discussed in Chapter to each variable name in the program .
The value the variable , in coded form consisting , is kept in the memory location assigned to that variable .
For example , the three variables in the program shown in Display might be assigned the memory locations with addresses ,
The exact numbers will depend on your computer , your compiler , number other factors .

We do not know , or even care , what addresses the compiler will choose for the variables in our program .
We can think as though the memory locations were actually labeled with the variable names .

Sample Dialogue Enter the number of candy bars in package the weight in ounces of one candy bar .

Then press return .

Try another brand .

Enter the number of candy bars in package the weight in ounces of one candy bar .

Then press return .

Perhaps an apple would be healthier .

Names : Identifiers The first thing you might notice about the names of the variables in our sample programs that they are longer than the names normally used for variables in mathematics classes .
To make your program easy to understand , you should always use meaningful names for variables .
The name of variable other item you might define in called an identifier .

If you cannot get your programs to compile and run , read the That section has tips for dealing with variations in compilers and environments .

An identifier must start with either letter or the underscore symbol , and all the rest of the characters must be letters , digits , or the underscore symbol .
For example , the following are all valid identifiers : sum RATE count All of the previously mentioned names are legal and would be accepted by the compiler , but the first five are poor choices for identifiers , since they are not descriptive of the use .
None of the following are legal identifiers and all would be rejected by the compiler : The first three are not allowed because they do not start with letter or an underscore .
The remaining three are not identifiers because they contain symbols other than letters , digits , and the underscore symbol .

language ; that  it distinguishes between uppercase and lowercase letters in the spelling of identifiers .
Hence the following are three distinct identifiers and could be used to name three distinct variables : rate RATE Rate However , it not good idea to use two such variants in the same program , since that might be confusing .
Although it not required by , variables are often spelled with all lowercase letters .
The predefined identifiers , such as main , cin ,  and so forth , must be spelled in all lowercase letters .
We will see uses for identifiers spelled with uppercase letters later in this chapter .

identifier can be of any length , although some compilers will ignore all characters after some specified and typically large number of initial characters .

Identifiers Identifiers are used as names for variables and other items in program .
An identifier must start with either letter or the underscore symbol , and the remaining characters must all be letters , digits , or the underscore symbol .

Chapter Basics There special class of identifiers , called keywords or reserved words , that have predefined meaning in and that you cannot use as names for variables or anything else .
In this book , keywords are written in different type font like so : int , double .

You may wonder why the other words that we defined as part of the language are not on the list of keywords .
What about words like cin and The answer that you are allowed to redefine these words , although it would be confusing to do so .
These predefined words are not keywords ; however , they are defined in libraries required by the language standard .

We will discuss libraries later in this book .
For now , you need not worry about libraries .
Needless to say , using predefined identifier for anything other than its standard meaning can be confusing and dangerous , and thus should be avoided .
The safest and easiest practice to treat all predefined identifiers as if they were keywords .

Variable Declarations Every variable in program must be declared .
When you declare variable you are telling the , ultimately , the kind of data you will be storing in the variable .
For example , the following two declarations from the program in Display declare the three variables used in that program : int  double   When there is more than one variable in declaration , the variables are separated by commas .
Also , note that each declaration ends with semicolon .

The word int in the first of these two declarations is an abbreviation of the word integer .
Do not write out the entire word This line declares the identifier to be variable of type int .
This means that the value of must be whole number , such as , or .

The word double in the second of these two lines declares the two identifiers and to be variables of type double .
variable of type double can hold numbers with fractional part , such as or .
The kind of data that is held in variable is called its type and the name for the type , such as int or double , is called type name .

Every variable in program must be declared before the variable can be used .
There are two natural places to declare variable : either just before it is used or at the start of the main part of your program right after the lines .

The syntax for variable declarations is as follows : Syntax ,

Variable declarations provide information the compiler needs in order to implement the variables .
Recall that the compiler implements variables as memory locations and that the value of variable is stored in the memory location assigned to that variable .
The value is coded as string of and .

Different types of variables require different sizes of memory locations and different methods for coding their values as string of and .
The computer uses one code to encode integers as string of and .
It uses different code to encode numbers that have fractional part .
It uses yet another code to encode letters as strings of and .
The variable declaration tells the , ultimately , the size memory location to use for the variable and which code to use when representing the value as string of and .

Syntax is the set of grammar rules for that language .
For example , when we talk about the syntax for variable declaration in the box labeled , we are talking about the rules for writing down wellformed variable declaration .
If you follow all the syntax rules for , then the compiler will accept your program .
Of course , this only guarantees that what you write is legal .
It guarantees that your program will do something , but it does not guarantee that your program will do what you want it to do .

Assignment Statements The most direct way to change the value of variable is to use an assignment statement .
An assignment statement is an order to the computer saying ,

An assignment statement ends with semicolon .
The expression on the side of the equal sign may be variable , number , or more complicated expression made up of variables , numbers , and arithmetic operators such as and +
An assignment statement instructs the computer to evaluate is , to compute the value the expression on the side of the equal sign and to set the value of the variable on the side equal to the value of that expression .
few more examples may help to clarify the way these assignment statements work .

You may use any arithmetic operator in place of the multiplication sign .

The following , for example , is also valid assignment statement : + This statement is just like the assignment statements in our sample program , except that it performs addition rather than multiplication .
This statement changes the value of to the sum of the values of and .
Of course , if you made this change in the program in Display , the program would give incorrect output , but it would still run .

In an assignment statement , the expression on the side of the equal sign can simply be another variable .
The statement ; changes the value of the variable so that it is the same as that of the variable .
If you were to use this in the program in Display , it would give out incorrectly low values for the total weight of package there is more than one candy bar in , but it might make sense in some other program .

As another example , the following assignment statement changes the value of to : number , like the in this example , is called constant , because unlike variable , its value cannot change .

Since variables can change value over time and since the assignment operator is one vehicle for changing their values , there is an element of time involved in the meaning of an assignment statement .
First , the expression on the side of the equal sign is evaluated .
After that , the value of Variables and Assignments the variable on the left side of the equal sign is changed to the that was obtained from that expression .
This means that variable can meaningfully occur on both sides of an assignment operator .
For example , consider the assignment statement + This assignment statement may look strange at first .
If you read it as an English sentence , it seems to say is equal to the plus " It may seem to say that , but what it really says is the new of equal to the old of plus " The equal sign in is not used the same way that it is used in English or in simple mathematics .

Assignment Statements In an assignment statement , first the expression on the side of the equal sign is evaluated , and then the variable on the side of the equal sign is set equal to this .

Syntax .

Pitfall Uninitialized Variables variable has no meaningful until program gives it one .
For example , if the variable has not been given either as the lefthand side of an assignment statement or by some other means as being given an input with cin , then the following is an error : + This is because has no meaningful  so the entire expression on the side of the equal sign has no meaningful .
variable like that has not been given is said to be uninitialized .
This situation is , in fact , worse than it would be if had no at all .
An uninitialized variable , like , will simply have some " The of an uninitialized variable is determined by whatever pattern of and was left in its memory location by the last program that used that portion of memory .
Thus if the program is run twice , an uninitialized .

Chapter Basics variable may receive different each time the program is run .
Whenever program gives different output on exactly the same input data and without any changes in the program itself , you should suspect an uninitialized variable .

One way to avoid an uninitialized variable is to initialize variables at the same time they are declared .
This can be done by adding an equal sign and  as follows : int ; This both declares to be variable of type int and sets the of the variable equal to .
You can use more complicated expression involving operations such as addition or multiplication when you initialize variable inside the declaration in this way .
However , simple constant is what is most often used .
You can initialize some , all , or none of the variables in declaration that lists more than one variable .
For example , the following declares three variables and initializes two of them : double , time , allows an alternative notation for initializing variables when they are .

Do whatever makes your program the easiest to understand .

It is much easier to understand program if the variables have meaningful names .
Contrast the following :

The two statements accomplish the same thing , but the second is easier to understand .

Both variables are of type int and both are to be initialized to zero in the declaration .
Use both initialization alternatives .

The variable length is of type double .

Write program that contains statements that output the of five or six variables that have been declared , but not initialized .
Compile and run the program .

Chapter Basics Give good variable names for each of the following :
variable to hold the speed of an automobile .
variable to hold the pay for an hourly employee c .
variable to hold the highest score in an exam Input and Output Garbage in means garbage out .

Programmers ' Saying There are several different ways that program can perform input and output .
We will describe what are called streams .
An input stream is simply the stream of input that is being fed into the computer for the program to use .
The word stream suggests that the program processes the input in the same way no matter where the input comes from .
The intuition for the word stream is that the program sees only the stream of input and not the source of the stream , like mountain stream whose water flows past you but whose source is unknown to you .
In this section we will assume that the input comes from the keyboard .
In Chapter we will discuss how program can read its input from file ; as you will see there , you can use the same kinds of input statements to read input from file as those that you use for reading input from the keyboard .
Similarly , an output stream is the stream of output generated by the program .
In this section we will assume the output is going to terminal screen ; in Chapter we will discuss output that goes to file .

Output Using The values of variables as well as strings of text may be output to the screen using There may be any combination of variables and strings to be output .
For example , consider the following line from the program in Display :  candy ; This statement tells the computer to output two items : the value of the variable and the quoted string  candy .
Notice that you do not need separate copy of the word for each item output .
You can simply list all the items to be output preceding each item to be output with the arrow symbols .
The above single statement equivalent to the following two statements :   candy .

The symbol the same as the than " symbol .
The two symbols should be typed without any space between them .
The arrow notation often called the insertion operator .
The entire statement ends with semicolon .

Whenever you have two statements in row , you can combine them into single long statement .
For example , consider the following lines from Display :  candy ;  ounces .

better way to write the previous long statement You should not break quoted string across two lines , but otherwise you can start new anywhere you can insert space .
Any reasonable pattern of spaces and breaks will be acceptable to the computer , but the previous example and the sample programs are good models to follow .
good policy to use one for each group of output that intuitively considered unit .
Notice that there just one semicolon for each  even if the statement spans several lines .

Pay particular attention to the quoted strings that are output in the program in Display .
Notice that the strings must be included in double quotes .
The double quote symbol used single key on your keyboard ; do not type two single quotes .
Also , notice that the same double quote symbol used at each end of the string ; there are not separate left and right quote symbols .

Also , notice the spaces inside the quotes .
The computer does not insert any extra space before or after the items output by statement .
That why the quoted strings in the samples often start end with blank .

The blanks keep the various strings and numbers from running together .
If all you need space and there no quoted string where you want to insert the space , then use string that contains only space , as in the following :   As we noted in Chapter , tells the computer to start new of output .
Unless you tell the computer to go to the next  it will put all the output on the same .
Depending on how your screen set up , this can .

Chapter Basics produce anything from arbitrary breaks to output that runs off the screen .

Notice that the goes inside of the quotes .
In , going to the next considered to be special character and the way you spell this special character inside quoted string , with no space between the two symbols in .
Although it typed as two symbols , considers to be single character that called the character .

Include Directives and Namespaces .

This the library that includes , among other things , the definitions of cin and .
So if your program uses either cin or  you should have these two lines at the start of the file that contains your program .

The following known as an directive .
It " the library iostream in your program so that you have cin and available : The operators cin and are defined in file named iostream and the above directive equivalent to copying that named file into your program .
The second bit more complicated to explain .

divides names into namespaces .
namespace collection of names , such as the names cin and .
statement that specifies namespace in the way illustrated by the following called using directive .

This means that the names you use will have the meaning defined for them in the std namespace .
In this case , the important thing that when names such as cin and were defined in iostream , their definitions said they were in the std namespace .
So to use names like cin and  you need to tell the compiler you are using namespace .

That all you need to know about namespaces , but brief clarifying remark will remove some of the mystery that might surround the use of namespace .
The reason that has namespaces at all because there are so many things to name .
As result , sometimes two or more items receive the same name ; that  single name can get two different definitions .
To eliminate these ambiguities , divides items into collections so that no two items in the same collection same have the same name .

Note that namespace not simply collection of names .
It body of code that specifies the meaning of some names , such as some definitions declarations .
The function of namespaces to divide all the name Input and Output specifications into collections such that each name in namespace has only one specification in that namespace .

namespace divides up the names , but it takes lot of code along with the names .

What if you want to use two items in two different namespaces such that both items have the same name .
It can be done and not too complicated , but that topic for later in the book .
For now , we do not need to do this .

Some versions of use the following , older form of the directive any using :

If your program requires instead of iostream , then you have an old compiler and should obtain more recent compiler .

Escape Sequences The backslash , preceding character tells the compiler that the character following the does not have the same meaning as the character appearing by itself .
Such sequence is called an escape sequence .
The sequence is typed in as two characters with no space between the symbols .
Several escape sequences are defined in .

If you want to put or  into string constant , you must escape the ability of the  to terminate string constant by using , or the ability of the to escape , by using .
The tells the compiler you mean real backslash , not an escape sequence backslash , and " means real quote , not string constant end .

stray , say , in string constant will on one compiler simply give back ; on another it will produce an error .
The ANSI Standard provides that the unspecified escape sequences have undefined behavior .
This means compiler can do anything its author finds convenient .
The consequence is that code that uses undefined escape sequences is not portable .
You should not use any escape sequences other than those provided .
We list few here .

Chapter Basics Alternately , supports format called raw string literals , which is convenient if you have many escape characters .
In this format use an followed by the string in parentheses .
For example , the following outputs the literal string :

good rule for deciding whether to use or endl is the following : If you can the at the end of longer string , then use as in the .

Alternatively , you can start new by outputting endl .
An equivalent way to write the above statement is as follows : have definitely won " endl of the following " endl ; Input and Output Programming Tip End Each Program with or endl It is good idea to instruction at the end of every program .

If the last item to be is string , then at the end of the string ; if not , an endl as the last action in your program .
This serves two purposes .
Some compilers will not the last of your program unless you instruction at the end .
On other systems , your program may work fine without this final instruction , but the next program that run will have its first of mixed with the last of the previous program .
Even if neither of these problems occurs on your system , putting instruction at the end will make your programs more portable .

For example , the following simple statement can produce any of wide range of outputs : endl ; If has the value , the might be The or it might be The or it might be in the following notation we will explain in Section : The But it extremely unlikely that the will be the following , even though this the format that makes the most sense : The To ensure that the in the form you want , your program should contain some sort of instructions that tell the computer how to the numbers .

There formula " that you can insert in your program to cause numbers that contain decimal point , such as numbers of type double , to be in everyday notation with the exact of digits after the decimal point that you specify .
If you want two digits after the decimal point , use the following magic .

You can even use variable of type int in place of the .
We will explain this magic formula in detail in Chapter .
For now you should think of this magic formula as one long instruction that tells the computer how you want it to numbers that contain decimal point .

If you wish to change the of digits after the decimal point so that different values in your program are with different numbers of digits , you can repeat the magic formula with some other in place of .

However , when you repeat the magic formula , you only need to repeat the last of the formula .
If the magic formula has already occurred once in your program , then the following will change the of digits after the decimal point to for all subsequent values of type double that are  Input Using cin You use cin for input more or less the same way you use for .
The syntax similar , except that cin used in place of and the arrows point in the opposite direction .
For example , in the program in Display , the variables and were filled by the following cin statements along with the statements that tell the user what to : Outputting Values of Type double If you insert the following formula " in your program , then all numbers of type double any other type that allows for digits after the decimal will be in ordinary , everyday notation with two digits after the decimal .

You can even use variable of type int in place of the .

When program reaches cin statement , it waits for input to be from the keyboard .
It sets the first variable equal to the first value typed at the keyboard , the second variable equal to the second value typed , and so forth .
However , the program does not read the input until the user presses the Return key .
This allows the user to backspace and correct mistakes when entering of input .

Numbers in the input must be separated by one or more spaces or by break .
If , for instance , you want to enter the two numbers and and instead you enter the numbers without any space between them , then the computer will think you have entered the single number .
When you use cin statements , the computer will skip over any number of blanks or breaks until it finds the next input value .
Thus , it does not matter whether input numbers are separated by one space or several spaces or even break .

Syntax cin .

Chapter Basics Designing Input and Output Input and output , or , as it often called , the part of the program that the user sees , so the user will not be happy with program unless the program has .

When the computer executes cin statement , it expects some data to be typed in at the keyboard .
If none typed in , the computer simply waits for it .
The program must tell the user when to type in number other data .
The computer will not automatically ask the user to enter data .
That why the sample programs contain output statements like the .

These output statements prompt the user to enter the input .
Your programs should always prompt for input .

When entering input from terminal , the input appears on the screen as it typed in .
Nonetheless , the program should always write out the input values some time before it ends .
This called echoing the input , and it serves as check to see that the input was read in correctly .
Just because the input looks good on the screen when it typed in does not mean that it was read correctly by the computer .
There could be an unnoticed typing mistake or other problem .
Echoing input serves as test of the integrity of the input data .

If you simply omit or endl at the end of the last prompt line , then the input will appear on the same line as the prompt .
For example , suppose you use the following prompt and input statements : the cost per person : cin .

Enter the cost per person : When the user types in the input , it will appear on the same line , like this : Enter the cost per person : Input and Output el est Exer cis es Give an output statement that will produce the following message on the screen : The answer to the question of Life , the Universe , and Everything .

Precede the input statement with prompt statement asking the user to enter whole number .

What statements should you include in your program to ensure that , when number of type double is output , it will be output in ordinary notation with three digits after the decimal point .

Write complete program that writes the phrase Hello world to the screen .

Write complete program that reads in two whole numbers and outputs their sum .
Be sure to prompt for input , echo input , and label all output .

Write short program that declares and initializes double variables one , two , three , four , and five to the values , and , respectively .
Then write output statements to generate the following legend and table .
Use the tab escape sequence to up the columns .
If you are unfamiliar with the tab character , you should experiment with it while doing this exercise .
tab works like mechanical stop on typewriter .
tab causes output to begin in next column , usually multiple of eight spaces away .
Many editors and most word processors will have adjustable tab stops .

The output should be : Square Root .

Chapter Basics Data Types and Expressions never be happy together .

Overheard at Cocktail Party The Types int and double Conceptually , the numbers and are the same number .

The whole number is of type int ; the number is of type double , because it contains fraction part though the fraction is .
Once again , the mathematics of computer programming is bit different from what you may have learned in mathematics classes .
Something about the practicalities of computers makes numbers differ from the abstract definitions of these numbers .

The whole numbers in behave as you would expect them to .
The type int holds no surprises .
But values of type double are more troublesome .

Because it can store only limited number of significant digits , the computer stores numbers of type double as approximate values .
Numbers of type int are stored as exact values .
The precision with which double values are stored varies from one computer to another , but you can expect them to be stored with or more digits of accuracy .
For most applications this is likely to be sufficient , though subtle problems can occur even in simple cases .
Thus , if you know that the values in some variable will always be whole numbers in the range allowed by your computer , it is best to declare the variable to be of type int .

Number constants of type double are written differently from those of type int .
Constants of type int must not contain decimal point .
Constants of type double may be written in either of two forms .
The simple form for double constants is like the everyday way of writing decimal fractions .

Why is the type for numbers with fraction part called double .
Is there type called " that is half as big .
No , but something like that is true .
Many programming languages traditionally used two types for numbers with fractional part .
One type used less storage and was very imprecise is , it did not allow very many significant .

The second type used double the amount of storage and was therefore much more precise ; it also allowed numbers that were larger programmers tend to care more about precision than about .

The kind of numbers that used twice as much storage were called Data Types and Expressions numbers ; those that used less storage were called corresponds to this type was named double in .

The type that corresponds to in was called float .

also has third type for numbers with fractional part , which is called long double .
These types are described in the subsection entitled Number " However , we will rarely use the types float and long double in this book .

There is , however , one thing that constants of type double and constants of type int have in common : No number in may contain comma .

The more complicated notation for constants of type double is frequently called scientific notation or notation and is particularly handy for writing very large numbers and very small fractions .
For instance , which is the same as is best expressed in by the constant .
The number which is the same as is best expressed in by the constant .
The stands for exponent and .

Chapter Basics be , and this limit is different for different number types .
The largest allowable number of type double is always much larger than the largest allowable number of type int .
Most current implementations of will allow values of type int as large as and values of type double up to about .

Other Number Types has other numeric types besides int and double .

The various number types allow for different size numbers and for more or less precision is , more or fewer digits after the decimal .
In Display , the values given for memory used , size range , and precision are only one sample set of values , intended to give you general feel for how the types differ .
The values vary from one system to another and may be different on your system .

Although some of these other numeric types are spelled as two words , you declare variables of these other types just as you declare variables of types int and double .
For example , the following declares one variable of type long double : long double .

Of course , in any one program , you should use only one of the above two declarations for the variable , but it does not matter which one you use .
Also , remember that the type name long by itself means the same thing as long int , not the same thing as long double .

The types for whole numbers , such an int and similar types , are called integer types .
The type for numbers with decimal as the type double and similar called types .
They are called because when the computer stores number written in the usual way , like , it first converts the number to something like notation , in this case something like .
When the computer performs this conversion , the decimal point floats is , to new position .

You should be aware that there are other numeric types in .
However , in this book we will use only the types int , double , and occasionally long .

For most simple applications , you should not need any types except int and double .
However , if you are writing program that uses very large whole numbers , then you might need to use the type long .

Precision short called bytes .

The values for any of these entries may be different on your system .
Precision refers to the number of meaningful digits , including digits in front of the decimal point .
The ranges for the types float , double , and long double are the ranges for positive numbers .
Negative numbers have similar range , but with negative sign in front of each number .

Types The size of data types can vary from one machine to another .
For example , on machine an might be bytes while on machine an might be bytes .
Sometimes this is problematic if you need to know exactly what range of values can be stored in an type .

To address this problem , new types were added to that specify exactly the size and whether or not the data type is signed or unsigned .
These types are accessible by including .
Display illustrates some of these number types .
In this text we will primarily use the more ambiguous types of int and long , but consider the types if you want to specify an exact size .

also includes type named auto that deduces the type of variable based on an expression on the right side of the equal sign .
For example , the following line of code defines variable named whose data type matches whatever is computed from : auto expression ; This feature buy us much at this point but will save us some long , messy code when we start to work with longer data types that we define ourselves .

Fixed Width Integer Types This code declares to be the same type as .
The expression is double so is declared as double .

The Type char We do not want to give you the impression that computers and are used only for numeric calculations , so we will introduce some nonnumeric types now , though eventually we will see other more complicated nonnumeric types .
Values of the type char , which is short for character , are single symbols such as letter , digit , or punctuation mark .
Values of this type are frequently called characters in books and in conversation , but in program this type must always be spelled in the abbreviated fashion char .
For example , the variables symbol and letter of type char are declared as follows : char symbol , letter ; variable of type char can hold any single character on the keyboard .
So , for example , the variable symbol could hold an ' or ' or an .
Note that uppercase and lowercase versions of letter are considered different characters .

The text in double quotes that are output using cout are called string values .
For example , the following , which occurs in the program in Display , is string : Data Types and Expressions Be sure to notice that string constants are placed inside of double quotes , while constants of type char are placed inside of single quotes .
The two kinds of quotes mean different things .

The fact that the string happens to contain only one character does not make " value of type char .
Also notice that , for both strings and characters , the left and right quotes are the same .

The use of the type char is illustrated in the program shown in Display .

Notice that the user types space between the first and second initials .

Yet the program skips over the blank and reads the letter as the second input character .
When you use cin to read input into variable of type char , the computer skips over all blanks and line breaks until it gets to the first nonblank character and reads that nonblank character into the Display The Type char .

Sample Dialogue Enter two initials , without any periods : The two initials are : JB Once more with space : all .

Chapter Basics variable .
It makes no difference whether there are blanks in the input or not .

The program in Display will give the same output whether the user types in blank between initials , as shown in the sample dialogue , or the user types in the two initials without blank , like so : JB The Type bool The next type we discuss here is the type bool .
This type was added to the language by the Standards American National Standards committee in .
Expressions of type bool are called Boolean after the English mathematician George Boole , who formulated rules for mathematical logic .

Boolean expressions evaluate to one of the two values , true or false .

Boolean expressions are used in branching and looping statements that we study in Section .
We will say more about Boolean expressions and the type bool in that section .

Introduction to the Class string Although lacks native data type to directly manipulate strings , there is string class that may be used to process strings in manner similar to the data types we have seen thus far .
The distinction between class and native data type is discussed in Chapter .
Further details about the string class are discussed in Chapter .

To use the string class we must first the string library :

Note that space is not automatically added between the strings .
If you wanted space between the two days , then space must be added explicitly : +   + Display The string Class .

Sample Dialogue Enter your middle name and the name of your pet .

Parker Pippen The name of your alter ego is Pippen Parker .

Sample Dialogue Enter your middle name and the name of your pet .

Bojangles The name of your alter ego is Mr .

Chapter Basics When you use cin to read input into string variable , the computer only reads until it encounters whitespace character .
Whitespace characters are all the characters that are displayed as blank spaces on the screen , including the blank or space character , the tab character , and the character .

This means that you cannot input string that contains spaces .
This may sometimes cause errors , as indicated in Display , Sample Dialogue .
In this case , the user intends to enter .
Bojangles " as the name of the pet , but the string is only read up to " since the next character is space .
The " string is ignored by this program but would be read next if there was another cin statement .
Chapter describes technique to input string that may spaces .

Type Compatibilities As general rule , you cannot store value of one type in variable of another .

The constant is of type double and the variable is of type int .
Unfortunately , not all compilers will react the same way to the above assignment statement .
Some will issue an error message , some will give only warning message , and some compilers will not object at all .
But even if the compiler does allow you to use this assignment , it will probably give the int value , not the value .

Since you cannot count on your compiler accepting this assignment , you should not assign double value to variable of type int .

The same problem arises if you use variable of type double instead of the constant .
Most compilers will also object to the .

The fact that the value out even " makes no difference .
The value is of type double , not of type int .
As you will see shortly , you can replace with in the preceding assignment to the variable  but even that is not enough to make the assignment acceptable .
The variables and are of different types , and that is the cause of the problem .

Even if the compiler will allow you to mix types in an assignment statement , in most cases you should not .
Doing so makes your program less portable , and it can be confusing .
For example , if your compiler lets you assign to variable of type int , the variable will receive the value , Data Types and Expressions rather than , which can be confusing since the program seems to say the value will be .

There are some special cases where it is permitted to assign value of one type to variable of another type .
It is acceptable to assign value of type int to variable of type double .
For example , the following is both legal and acceptable style : double  The above will set the value of the variable named equal to .

Although it is usually bad idea to do so , you can store an int value such as in variable of type char and you can store letter such as ' in variable of type int .
For many purposes , the language considers the characters to be small integers ; and perhaps unfortunately , inherited this from .
The reason for allowing this is that variables of type char consume less memory than variables of type int and so doing arithmetic with variables of type char can save some memory .
However , it is clearer to use the type int when you are dealing with integers and to use the type char when you are dealing with characters .

The general rule is that you cannot place value of one type in variable of another it may seem that there are more exceptions to the rule than there are cases that follow the rule .
Even if the compiler does not enforce this rule very strictly , it is good rule to follow .
Placing data of one type in variable of another type can cause problems , since the value must be changed to value of the appropriate type and that value may not be what you would expect .

Values of type bool can be assigned to variables of an integer type , int , and integers can be assigned to variables of type bool .

However , it is poor style to do this and you should not use these features .
For completeness and to help you read other code , we do give the details : When assigned to variable of type bool , any nonzero integer will be stored as the value true .
Zero will be stored as the value false .
When assigning bool value to an integer variable , true will be stored as and false will be stored as .

Arithmetic Operators and Expressions In program , you can combine variables numbers using the arithmetic operators + for addition , for subtraction , for multiplication , and for division .
For example , the following assignment statement , which appears in the program in Display , uses the operator to multiply the .

Chapter Basics All of the arithmetic operators can be used with numbers of type int , numbers of type double , and even with one number of each type .
However , the type of the value produced and the exact value of the result depends on the types of the numbers being combined .
If both operands is , both are of type int , then the result of combining them with an arithmetic operator is of type int .
If one , or both , of the operands is of type double , then the result is of type double .
For example , if the variables and increase are of type int , then the number produced by the following expression is of type int : + increase However , if one or both of the two variables is of type double , then the result is of type double .
This is also true if you replace the operator + with any of the operators , or .

The type of the result can be more significant than you might suspect .

For example , has one operand of type double , namely .
Hence , the result is the type double number .
However , has two operands of type int and so it yields the type int , which is the result .
Even if the result out " there is difference .
For example , has one operand of type double , namely .
Hence , the result is the type double number , which is only an approximate quantity .
However , has two operands of type int , so it yields the result , which is of type int and so is an exact quantity .
The division operator is the operator that is affected most severely by the type of its arguments .

When used with one or both operands of type double , the division operator , behaves as you might expect .
However , when used with two operands of type int , the division operator , yields the integer part resulting from division .
In other words , integer division discards the part after the decimal point .

Notice that the number not rounded ; the part after the decimal point discarded no matter how large it .

The operator can be used with operands type int to recover the information lost when you use to do division with numbers type int .

When used with values type int , the two and yield the two numbers produced when you perform the long division algorithm you learned in grade school .
For example , divided by yields with remainder .

The operation yields the number times one number into " another .

The operation gives the remainder .
For example , the statements divided by  endl ; remainder 

Display Integer Division When used with negative values type int , the result the operators and can be different for different implementations .
Thus , you should use and with int values only when you know that both values are nonnegative .

Any reasonable spacing will do in arithmetic expressions .
You can insert spaces before and after operations and parentheses , or you can omit them .
Do whatever produces result that easy to read .

You can specify the order operations by inserting parentheses , as illustrated in the following two expressions : + To evaluate the first expression , the computer first adds and and then multiplies the result by .
To evaluate the second expression , it multiplies and and then adds the result to .
Although you may be used to using mathematical formulas that contain square brackets and various other forms parentheses , that not allowed in .
allows only one kind parentheses in arithmetic expressions .
The other varieties are reserved for other purposes .

If you omit parentheses , the computer will follow rules called precedence rules that determine the order in which the operators , such as + and , are performed .
These precedence rules are similar to rules used in algebra and other mathematics classes .
For example , + evaluated by first doing the multiplication and then the addition .
Except in some standard cases , such as string additions or simple multiplication embedded inside an addition , it usually best to include the parentheses , even if the intended order operations the one dictated by the precedence rules .
The parentheses make the expression easier to read and less prone to programmer error .
complete set precedence rules given in Appendix .

Display shows some examples common kinds arithmetic expressions and how they are expressed in .

VideoNote Precedence and Arithmetic Operators Chapter Basics Display Arithmetic Expressions Mathematical Formula Expression .

Pitfall Whole Numbers in Division When you use the division operator on two whole numbers , the result whole number .
This can be problem if you expect fraction .
Moreover , the problem can easily go unnoticed , resulting in program that looks fine but producing incorrect output without your even being aware the problem .
For example , suppose you are landscape architect who charges per mile to landscape highway , and suppose you know the length the highway you are working on in feet .
The price you charge can easily be calculated by the following statement : This works because there are feet in mile .
If the stretch highway you are landscaping feet long , this formula will tell you that the total price Your program obtains the final value as follows : computed as .
Then the program multiplies by to produce the value .
With the aid your program , you know that you should charge for the project .

Now suppose the variable feet type int , and you forget to put in the decimal point and the zero , so that the assignment statement in your program reads : It still looks fine but will cause serious problems .
If you use this second form the assignment statement , you are dividing two values type int , so the result the division , which the int value the value , which you think you are .
So the value assigned to , or .
If you forget the decimal point , you will charge .
However , as we have already seen , the correct value is .
missing decimal point has cost you .
Note that this will be true whether the type of is int or double ; the damage is done before the value is assigned to .

Convert each of the following mathematical formulas to expression : + + + +
What is the output of the following program lines when embedded in .

Write complete program that reads two whole numbers into two variables of type int and then outputs both the part and the remainder when the first is divided by the second .

What value is assigned .

Rewrite the code as the programmer intended .

What is the output of the following program lines when embedded in correct program that declares    and be of type string .

Chapter Basics More Assignment Statements There is shorthand notation that combines the assignment and an arithmetic so that given variable can have its value changed by adding , subtracting , multiplying by , or dividing by specified value .
The general form is Expression which is equivalent is an such as + or .
The Expression can be another variable , constant , or more complicated arithmetic expression .
Following are examples : Example .

The programs you have seen thus far each consist of simple list of statements be executed in the order given .
However , write more sophisticated programs , you will also need some way vary the order in which statements are executed .
The order in which statements are executed is often referred as flow of control .
In this section we will present two simple ways add some flow of control your programs .
We will discuss branching mechanism that lets your program choose between two alternative actions , choosing one or the other depending on the values of variables .
We will also present looping mechanism that lets your program repeat an action of times .

For example , suppose you want design program compute salary for an hourly employee .
Assume the firm pays an overtime rate of times the regular rate for all hours after the first hours worked .
As long as the employee works or more hours , the pay is then equal However , if there is possibility that the employee will work less than hours , this formula will unfairly pay negative of overtime .

The poor employee will get negative The correct pay formula for an employee who works less than hours is simply rate hours If both more than hours and less than hours of work are possible , then the program will need choose between the two formulas .
In order compute the pay , the program action should be Decide whether or not is true .

If it is , do the following assignment statement : rate + rate .

There is statement that does exactly this kind of branching action .
The statement chooses between two alternative actions .
For example , the wage calculation we have been discussing can be accomplished with the following statement : rate + rate ; else rate hours ; complete program that uses this statement is given in Display .

Two forms of an statement are described in Display .
The first is the simple form of an statement ; the second form will be discussed in the subsection entitled " In the first form shown , the two statements may be any executable statements .
The Expression is test that can be checked see if it is true or false , that is , see if it is satisfied or not .
For example , the in the earlier statement is hours .

Chapter Basics When the program reaches the statement , exactly one of the two embedded statements is executed .
If the is true is , if it is , then the is executed ; if the is false is , if it is not , then the is executed .

Notice that the must be enclosed in parentheses .

Sample Dialogue Enter the hourly of  Enter the number of worked , rounded to whole number of  Hourly Simple Flow of Control Sample Dialogue Enter the hourly of  Enter the number of worked , rounded to whole number of  Hourly Display Syntax for an Statement Single Statement for Each Alternative : else Sequence of Statements for Each Alternative :

Boolean expression is any expression that is either true or false .
An statement always contains .
The simplest form for consists of two expressions , such as numbers or variables , that are compared with one of the comparison operators shown in Display .
Notice that some of the operators are spelled with two symbols : for 
Be sure to notice that you use double for .

Chapter Basics Display Comparison Operators Math Symbol English .

Such operators should not have any space between two .
The part of compiler that separates characters into names and will see , for  and tell rest of compiler that programmer meant to test for INEQUALITY .
When an statement is executed , two expressions being compared are evaluated and compared using operator .

If comparison turns out to be true , then first statement is performed .

If comparison fails , then second statement is executed .

You can combine two comparisons using " operator , which is spelled in .
For  following Boolean expression is true is , is provided is greater than and is less than : When two comparisons are connected using , entire expression is true , provided both of comparisons are true is , provided both are ; otherwise , entire expression is false .

You can also combine two comparisons using " operator , which is spelled in .
For  following is true provided is less than or is greater than : When two comparisons are connected using , entire expression is true provided that one or both of comparisons are true is , otherwise , entire expression is false .

Remember that when you use Boolean expression in an statement , Boolean expression must be enclosed in parentheses .
Therefore , an statement that uses operator and two comparisons is parenthesized as .

You can negate any Boolean expression using .
If you want to negate Boolean expression , place expression in parentheses and place .
For  is The " Operator You can form more elaborate Boolean expression by combining two simple tests using " operator .

If value of score is greater than and value of score is also less than , then first statement will be executed ; otherwise , second statement will be executed .

Since Boolean expression in an statement must be enclosed in parentheses , you should place second pair of parentheses around negated expression when it is used in an statement .
For  an statement might begin as follows :

For example , our hypothetical statement can instead begin with following , which is equivalent and easier to read :

We will not have much call to use .

Chapter Basics Sometimes you want one of two alternatives in an statement to do nothing at all .
In this can be accomplished by omitting else part .
These sorts of statements are referred to as if statements to distinguish them from statements .
For example , first of following two statements is an if statement : + bonus ;   If value of is greater than or equal to value of minimum , assignment statement is executed and then following statement is executed .
On other hand , if value of is less than minimum , then embedded assignment statement is not executed , so if statement causes no change is , no bonus is added to base , and program proceeds directly to statement .

The " Operator You can form more elaborate Boolean expression by combining two simple tests using " operator .

Pitfall Strings of Inequalities Do not use string of inequalities such as following in your program : is between and .

We will explain why this happens after we learn more details about language .
The same problem will occur with string comparisons using any comparison operators ; problem is not limited to comparisons .
The correct way to express string inequalities is to use " operator as follows : correct form is between and ; in place Unfortunately , you can write many things in that you would think are incorrectly formed statements but turn out to have some obscure meaning .
This means that if you mistakenly write something that you would expect to produce an error message , you may find out that the program compiles and runs with no error messages , but gives incorrect output .
Since you may not realize you wrote something incorrectly , this can cause serious problems .
By the time you realize something is wrong , the mistake may be very hard to find .
One common mistake is to the when you .
For example , consider an statement that begins as follows : else Suppose you wanted to test to see if the value is equal to so that you really meant to rather .
You might think the compiler will catch your mistake .
The expression is not something that is satisfied or not .
It is an assignment statement , so surely the compiler will give an error message .
Unfortunately , that is not the case .
In the expression is an expression that returns value , just like + or +
An assignment value is the value transferred to the variable on the left .
For example , the value is .
We saw in our discussion Boolean value compatibility that int values may be converted to true or false .
Since is not zero , it is converted to true .
If you as the Boolean expression in an if statement , the Boolean expression is always true , so the first branch is always executed .

This error is very hard to find because it looks correct .
The compiler can find the error without any special instructions if you put the on the left side the comparison , as in VideoNote Common Bugs with .

; Then , compiler will give error message you mistakenly instead .

Remember that dropping one in is common error that is not caught by many compilers , is very hard to see , is almost certainly not what you wanted .
In , many executable statements can also be used as almost any kind expression , including as Boolean expression for statement .
If you put assignment statement where Boolean expression is expected , assignment statement will be interpreted as Boolean expression .
Of course result " will undoubtedly not be what you intended as Boolean expression .
The statement above looks fine at quick glance it will compile run .
But , in all likelihood , it will produce puzzling results when it is run .

To accomplish this , enclose statements for each branch between pair braces , as indicated in second syntax template in Display illustrated in Display .
list statements enclosed in pair braces is called compound statement .
compound statement is treated as single statement by may be used anywhere that single statement may be used .

Syntax rules for demand that Yes statement No statement be exactly one statement .
If more statements are desired for branch , statements must be enclosed in braces to convert them to one compound statement .
If two or more statements not enclosed by braces are placed between else , then compiler will give error message .

Display Compound Statements Used With .

el est Exer cis es .
Write statement that outputs word High value variable score is greater Low value score is at most .
The variable score is type int .

Suppose savings expenses are variables type double that have been given values .
Write statement that outputs word Solvent , decreases value savings by value expenses , sets value expenses to , provided that savings is at least as large as expenses .
If , however , savings is less expenses , statement simply outputs word Bankrupt does not change value any variables .

Write statement that outputs word Passed provided value variable exam is greater or equal to value variable is greater or equal to .
Otherwise , statement outputs word Failed .
The variables exam are both type int .

Write statement that outputs word Warning provided that either value variable temperature is greater or equal to , or value variable pressure is greater or equal to , or both .
Otherwise , statement outputs word OK .
The variables temperature pressure are both type int .

Consider quadratic expression , say Describing where this quadratic is positive is , greater , involves describing set numbers that are either less than smaller root is or greater than larger root is .
Write Boolean expression that is true when this formula has positive values .

Consider quadratic expression + Describing where this quadratic is negative involves describing set numbers that are simultaneously greater than smaller root less than larger root .
Write Boolean expression that is true when value this quadratic is negative .

What is output following statements embedded in these statements .
You are to assume that these are embedded in complete correct program .
Explain your answer .

Simple Loop Mechanisms Most programs include some action that is repeated number times .
For example , program in Display computes gross pay for one worker .

If company employs workers , then more complete payroll program would repeat this calculation times .
portion program that repeats statement or group statements is called loop .
The language has number of ways to create loops .
One of these constructions is called while statement or while loop .
We will first illustrate its use with short toy example and then do more realistic example .

The program in Display contains simple while statement shown in color .
The portion between the braces , and , is called the body of the while loop ; it is the action that is repeated .
The statements inside the braces are executed in order , then they are executed again , then again , and so forth until the while loop ends .
In the first sample dialogue , the body is executed three times before the loop ends , so the program outputs Hello three times .
Each repetition of the loop body is called an iteration of the loop , and so the first sample dialogue shows three iterations of the loop .

The meaning of while statement is suggested by the English word while .
The loop is repeated while the Boolean expression in the parentheses is satisfied .
In Display this means that the loop body is repeated as long as the value of the variable is greater than .
consider the first sample dialogue and see how the while loop performs .
The user types in so the cin statement sets the value of to .
Thus , in this case , when the program reaches the while statement , it is certainly true that is greater than , so the statements in the loop body are executed .
Every time the loop body is repeated , the following two statements are executed : Simple Flow of Control Display while Loop .

Sample Dialogue How many greetings do you want .

Sample Dialogue How many greetings do you want .

Sample Dialogue How many greetings do you want .

The loop body is executed .

After the computer repeats the loop body three times , the value of is decreased to .

Chapter Basics Display Syntax of the while Statement Loop Body with Several Statements :

Do NOT put .

So , this while statement ends after repeating the loop body three times .

The syntax for while statement is given in Display .
The Expressions allowed are exactly the same as the Boolean expressions allowed in an statement .
Just as in statements , the Boolean expression in while statement must be enclosed in parentheses .

In Display we have given the syntax templates for two cases : the case when there is more than one statement in the loop body and the case when there is just single statement in the loop body .
Note that when there is only single statement in the loop body , you need not the braces and .

go over the actions performed by while statement in greater detail .

When the while statement is executed , the first thing that happens is that the Boolean expression following the word while is checked .
It is either true or false .
For example , the comparison is true if the value of is positive .
If it is false , then no action is taken and the program proceeds to the next statement after the while statement .
If the comparison is true , then the entire body of the loop is executed .
At least one of the expressions being compared typically contains something that might be changed by the loop body , such as the value of in the while statement in Display .
After the body of the loop is executed , the comparison is again checked .
This process is repeated again and again as long as the comparison continues to be true .
After each iteration of the loop body , the comparison is again checked and if it is true , then the entire loop body is executed again .
When the comparison is no longer true , the while statement ends .

If the Boolean expression is not true when the while statement begins , then the loop body is never executed .
That is exactly what happens in Sample Dialogue of Display .
In many programming situations you want the possibility of executing the loop body zero times .
For example , if your while loop is reading list consisting of all the failing scores on an exam and nobody failed the exam , then you want the loop body to be executed zero times .

As we just noted , while loop might execute its loop body zero times , which is often what you want .
If , on the other hand , you know that under all circumstances your loop body should be executed at least one time , then you can use statement .
statement is similar to while statement except that the loop body is always executed at least once .
The syntax for statement is given in Display .
program with sample loop is given in Display .
In that loop , as in any loop , the first thing that happens is that the statements in the loop body are executed .
After that first iteration of the loop body , the dowhile statement behaves the same as while loop .
The Boolean expression is checked .
If the Boolean expression is true , the loop body is executed again ; the Boolean expression is checked again , and so forth .

Increment and Decrement Operators We discussed binary operators in the section entitled Operators and " Binary operators have two operands .
Unary operators have only one operand .
You already know of two unary operators , + and , as used in the expressions and .
The language has two other very common unary operators , and .
The operator is called the increment operator Display Syntax of the Statement Loop Body with Several Statements : do .

while ; body Do not forget the final semicolon .

Loop Body with Single Statement : do Statement .

Chapter Basics Display Loop .

Sample Dialogue Hello Do you want another greeting .

Press for yes , for no , and then press return : Hello Do you want another greeting .

Press for yes , for no , and then press return : Hello Do you want another greeting .

Press for yes , for no , and then press return : and the operator is called the decrement operator .

If is variable of type int , then increases the value of by one and decreases the value of by one .
So and followed by are executable statements .
For example , the statements .

For example , we used the following statement in the while loop in Display : However , most experienced programmers would use the decrement operator rather than the assignment statement , so the entire while loop would read as .

Charge Card Balance Suppose you have bank charge card with balance owed of and suppose the bank charges you per month interest .
How many months can you let pass without making any payments before your balance owed will exceed .
One way solve this problem is simply read each monthly statement and count the number of months that go by until your balance reaches or more .
Better still , you can calculate the monthly balances with program rather than waiting for the statements arrive .
In this way you will obtain an answer without having wait so long without endangering your credit .

After one month the would be plus of , which is .

After two months the would be plus of , which is .

After three months the would be plus of , and so on .
In general , each month increases the by .
The program could keep track of the by storing it in called .
The change in the value of for one month can be calculated as follows : +  If we repeat this action until the value of reaches and we count the number of repetitions , then we will know the number of months it will take for the reach .
To do this , we need another count the number of times the is changed .
Let us call this new count .
The final body of our while loop will thus contain the following statements :

In order make this loop perform correctly , we must give appropriate values the variables and count before the loop is executed .
In this case , we can initialize the variables when they are declared .
The complete program is shown in Display .

Pitfall Infinite Loops while loop or loop does not terminate as long as the Boolean expression after the word while is true .
This Boolean expression normally contains that will be changed by the loop body , and usually the value of this eventually is changed in way that makes the Boolean expression false and therefore terminates the loop .
However , if you make mistake and write your program so that the Boolean expression is always true , then the loop will run forever .
loop that runs forever is called an infinite loop .

First describe loop that does terminate .
The following code will write out the positive even numbers less than .
That is , it will output the numbers , and , one per line , and then the loop will end .

The value of is increased by on each loop iteration until it reaches .

At that point , the Boolean expression after the word while is no longer true , so the loop ends .

Now suppose you want write out the odd numbers less than , rather than the even numbers .
You might mistakenly think that all you need do is change the initializing statement ; but this mistake will create an infinite loop .
Because the value of goes from , the value of is never equal , so the loop will never terminate .

This sort of problem is common when loops are terminated by checking numeric quantity .
When dealing with numbers , it is always safer test for passing value .
For example , the following will work fine as the first line of our while loop : With this change , can be initialized any number and the loop will still terminate .

Since you can now write programs that contain an infinite loop , it is good idea learn how force program terminate .
The method for forcing program stop varies from system system .
The keystrokes will terminate program on many systems .

Sample Dialogue This program tells you how long it takes to accumulate debt of , starting with an initial of owed .

The interest rate is per month .

Chapter Basics el est Exe cis es .
What is the output produced by the following embedded in correct program with declared to of type .

What output would produced in the previous exercise if the sign were replaced with .

What is the output produced by the following embedded in correct program with declared to of type .

What is the most important difference between while statement and statement .

What is the output produced by the following embedded in correct program with declared to of type .

Oscar Wilde , The Importance of Being Earnest All the variable names in our sample programs were chosen to suggest their use .
Our sample programs were laid out in particular format .
For example , the declarations and statements were all indented the same amount .
These and other matters of style are of more than aesthetic interest .
program that is written with careful attention to style is easier to read , easier to correct , and easier to change .

Indenting program should laid out so that elements that are naturally considered group are made to look like group .
One way to do this is to skip line between parts that are logically considered separate .
Indenting can also help to make the structure of the program clearer .
statement within statement should indented .
In particular , statements , while loops , and dowhile loops should indented either as in our sample programs in some similar manner .

The braces determine large part of the structure of program .
Placing each brace on line by itself , as we have been doing , makes it easy to find the matching pairs .
Notice that we have indented some pairs of braces .
When one pair of braces is embedded in another pair , the embedded braces are indented more than the outer braces .
Look back at the program in Display .
The braces for the body of the while loop are indented more than the braces for the main part of the program .

There are at least two schools of thought on where you should place braces .
The first , which we use in this book , is to reserve separate line for each brace .
This form is easiest to read .
The second school of thought holds that the opening brace for pair need not on line by itself .
If used with care , this second method can effective , and it does save space .
The important point is to use style that shows the structure of the program .
The exact layout is not precisely dictated , but you should consistent within any one program .

Comments In order to make program understandable , you should some explanatory notes at key places in the program .
Such notes are called comments .
and most other programming languages have provisions for including such comments within the text of program .
In the symbols are used to indicate the start of comment .
All of the text between the and the end of the line is comment .
The compiler simply ignores anything that .

Chapter Basics follows on line .
If you want comment that covers more than one line , place on each line of the comment .
The symbols are two slashes space between .

In this book , comments will always written in italic so that they stand out from the program text .
Some text editors indicate comments by showing them in different color from the rest of the program text .

There is another way to insert comments in program .
Anything between the symbol pair and the symbol pair is considered comment and is ignored by the compiler .
Unlike the comments , which require an additional on each line , the to comments can span several lines , like so : is comment that spans three lines .
Note that there is no comment symbol of any kind on the second Comments of the type may inserted anywhere in program that space or line break is allowed .
However , they should not inserted anywhere except where they are easy to read and do not distract from the layout of the program .
Usually , comments are only placed at the ends of lines or on separate lines by themselves .

There are differing opinions on which kind of comment is best to use .

Either variety kind or the can effective if used with care .

We will use the kind in this book .

It is difficult to say just how many comments program should contain .

The only correct answer is " which of course conveys little to the novice programmer .
It will take some experience to get feel for when it is best to include comment .
Whenever something is important and not obvious , it merits comment .
However , too many comments are as bad as too few .
program that has comment on each line will be so buried in comments that the structure of the program is hidden in sea of obvious observations .

Comments like the following contribute nothing to understanding and should not appear in program : speed time ; the traveled Notice the comment given at the start of the program in Display .

All programs should begin with comment similar to the one shown there .
It gives all the essential information about the program : what file the program is in , who wrote the program , how to contact the person who wrote the program , what the program does , the date that the program was last modified , and any other particulars that are appropriate , such as the assignment number , if the program is class assignment .
Exactly what you include in this comment will depend on your particular situation .

We will not include such long comments in the programs in the rest of this book , but you should always begin your programs with similar comment .

Sample Dialogue Enter your temperature : You have fever .

Naming Constants There are two problems with numbers in computer program .
The first is that they carry no mnemonic value .
For example , when the number is encountered in program , it gives no hint of its significance .
If the program is banking program , it might be the number of branch offices or the number of teller windows at the main office .
In order to understand the program , Chapter Basics you need to know the significance of each constant .
The second problem is that when program needs to have some numbers changed , the changing tends to introduce errors .
Suppose that occurs twelve times in banking program , that four of the times it represents the number of offices , and that eight of the times it represents the number of teller windows at the main office .
When the bank opens new and the program needs to be updated , there is good chance that some of the that should be changed to will not be , or some that should not be changed will be .
The way to avoid these problems is to name each number and use the name instead of the number within your program .
For example , banking program might have two constants with the names and .
Both these numbers might have value of , but when the bank opens new  all you need do in order to update the program is to change the definition of .

How do you name number in program .
One way is to initialize variable to that number value , as in the following example : int ; int ; There is , however , one problem with this method of naming number constants : You might inadvertently change the value of one of these variables .

provides way of marking an initialized variable so that it cannot be changed .
If your program tries to change one of these variables , it produces an error condition .
To mark variable declaration so that the value of the variable cannot be changed , precede the declaration with the word const is an abbreviation of .
For example : const int ; const int .

The word const is often called modifier , because it modifies the variables being declared .

variable declared using the const modifier is often called declared constant .
Writing declared constants in all uppercase letters is not required by the language , but it is standard practice among programmers .

Once number has been named in this way , the name can then be used anywhere the number is allowed , and it will have exactly the same meaning as the number it names .
To change named constant , you need change only the initializing value in the const variable declaration .
The meaning of all occurrences of  for instance , can be changed from to simply by changing the initializing value of in the declaration of .

It often makes sense to use unnamed number constants for , easily recognizable , and unchangeable quantities , such as for the number of centimeters in meter .
However , all other numeric constants should be given names in the fashion we just described .

This will make your programs easier to read and easier to change .

Display contains simple program that illustrates the use of the declaration modifier const .

Naming Constants with the const Modifier When you initialize variable inside declaration , you can mark the variable so that the program is not allowed to change its value .
To do this , place the word const in front of the declaration , as described below : Syntax const .

el est Exer cis es .
The following statement will compile and run without any problems .
However , it is not laid out in way that is consistent with the other statements we have used in our programs .
Rewrite it so that the layout and line matches the style we used in this chapter .

Write complete program that asks the user for number of gallons and then outputs the equivalent number of liters .
There are liters in gallon .
Use declared constant .
Since this is just an exercise , you need not have any comments in your program .

Chapter Basics Chapter Summary Use meaningful names for variables .

This can be done when the variable is declared or with an assignment statement before the variable is first used .

An if statement allows your program to decide whether to perform some one particular action .

This can be done by using the modifier const in variable declaration .

There is no unique right answer for this one .
Below are possible answers :

This makes the value of the entire expression  which of course .

Answers to Exercises has int value ; since numerator and denominator are both int , integer division done ; the fractional part discarded .

The strings are concatenated with the + operator .

In the section on type compatibility , it noted that the int value converts to false .

In the section on type compatibility , it noted that nonzero int value converts to true .

In the section on type compatibility , it noted that nonzero int value converts to true .

There would be no output , since the Boolean expression not satisfied and so the while statement ends without executing the loop body .

The output exactly the same as it was for Exercise .

The body of the loop executed before the Boolean expression checked , the Boolean expression false , and so the output .
With statement the loop body always executed at least once .

With while statement there can be conditions under which the loop body not executed at all .

This an infinite loop .
The output would begin with the following and conceptually go on forever : the value of becomes larger than the largest integer allowed on your computer , the program may stop or exhibit other strange behavior ,

Practice ProgramS Practice Programs can generally be solved with short program that directly applies the programming principles presented in this chapter .

metric ton ounces .
Write program that will read the weight of package of breakfast cereal in ounces and output the weight in metric tons as well as the number of boxes needed to yield metric ton of cereal .

Your program should allow the user to repeat this calculation as often as the user wishes .

The Babylonian algorithm to compute the square root of number is as follows : Make at the answer can pick as your initial .

The more that steps and are repeated , the closer will become to the square root of .

Write program that inputs double for and iterates through the Babylonian algorithm times .
For more challenging version , iterate until is within of the previous  and outputs the answer as double .

VideoNote Solution to Practice Many treadmills output the speed of the treadmill in miles per hour on the console , but most runners think of speed in terms of pace .

common pace is the number of minutes and seconds per mile instead of mph .

Write program that starts with quantity in mph and converts the quantity into minutes and seconds per mile .
As an example , the proper output for an input of mph should be minutes and seconds per mile .
If you need to convert double to an int , which will discard any value after the decimal point , then you may use ;
Write program that plays the game of Mad Lib .
Your program should prompt the user to enter the following strings : The first or last name of your instructor .

An animal After the strings are input , they should be substituted into the story below and output to the console .

Programming Projects Dear Instructor , am sorry that am unable to turn in my homework at this time .
First , ate rotten , which made me turn and extremely ill .
came down with fever of .
Next , my pet must have smelled the remains of the on my homework , because he ate it .
am currently rewriting my homework and hope you will accept it late .

Sincerely ,
The following is short program that computes the volume of given the radius .
It will compile and run , but it does not adhere to the program style recommended in Section .
Rewrite the program using the style described in the chapter for indentation , adding comments , and appropriately named constants .

Programming Projects Programming Projects require more than Practice Programs and can usually be solved many different ways .
Visit to complete many of these Programming Projects online and get instant feedback .

government research lab has concluded that an artificial sweetener commonly used in diet soda pop will cause death in laboratory mice .
friend of yours desperate to lose weight but cannot give up soda pop .

Your friend wants to know how much diet soda pop it possible to drink without dying as result .
Write program to supply the answer .
The input to the program the amount of artificial sweetener needed to kill mouse , the mass of the mouse , and the weight of the dieter grams for pound .
Assume that the lethal dose for mouse proportional to the lethal dose for the human .

single can of soda pop has mass of grams .
To ensure the safety of your friend , be sure the program requests the weight at which the dieter will stop dieting , rather than the current weight .
Assume that diet .

Chapter Basics soda contains of artificial sweetener .
Use variable declaration with the modifier const to give name to this fraction .
You may want to express the percent as the double value .
Your program should allow the calculation to be repeated as often as the user wishes .

Workers at particular company have won pay increase retroactive for months .
Write program that takes an previous salary as input , and outputs the amount of retroactive pay due the employee , the new salary , and the new salary .
Use variable declaration with the modifier const to express the pay increase .
Your program should allow the calculation to be repeated as often as the user wishes .

The number of months entered by the user .

Negotiating consumer loan not always straightforward .
One form of loan the discount installment loan , which works as follows .
Suppose loan has face value of , the interest rate , and the duration months .
The interest computed by multiplying the face value of by , to yield .
That figure then multiplied by the loan period of years to yield as the total interest owed .
That amount immediately deducted from the face value , leaving the consumer with only .
Repayment made in equal installments based on the face value .
So the loan payment will be divided by , which .
This method of calculation may not be too bad if the consumer needs dollars , but the calculation bit more complicated if the consumer needs .
Write program that will take three inputs : the amount the consumer needs to receive , the interest rate , and the duration of the loan in months .
The program should then calculate the face value required in order for the consumer to receive the amount needed .
It should also calculate the payment .
Your program should allow the calculations to be repeated as often as the user wishes .

Write program that determines whether meeting room in violation of fire law regulations regarding the maximum room capacity .
The program will read in the maximum room capacity and the number of people attending the meeting .
If the number of people less than or equal to the maximum room capacity , the program announces that it legal to hold the meeting and tells how many additional people may legally attend .
If the number of people exceeds the maximum room capacity , the program announces that the meeting cannot be held as planned due to fire regulations and tells how many people must be excluded in order to meet the fire regulations .
For harder version , write your program so that it allows the calculation to be repeated as often as the user wishes .
If this class exercise , ask your instructor whether you should do this harder version .

Programming Projects .
An employee paid at rate of per hour for the first hours worked in week .
Any hours over that are paid at the overtime rate of times that .
From the gross pay , withheld for Social Security tax , withheld for federal income tax , withheld for state income tax , and per week withheld for union dues .
If the worker has three or more dependents , then an additional withheld to cover the extra cost of health insurance beyond what the employer pays .

Write program that will read in the number of hours worked in week and the number of dependents as input and will then output the gross pay , each withholding amount , and the net pay for the week .
For harder version , write your program so that it allows the calculation to be repeated as often as the user wishes .
If this class exercise , ask your instructor whether you should do this harder version .

It difficult to make budget that spans several years , because prices are not stable .
If your company needs pencils per year , you cannot simply use this price as the cost of pencils years from now .
Because of inflation the cost likely to be higher than it today .
Write program to gauge the expected cost of an item in specified number of years .
The program asks for the cost of the item , the number of years from now that the item will be purchased , and the rate of inflation .
The program then outputs the estimated cost of the item after the specified period .
Have the user enter the inflation rate as percentage , like .
Your program should then convert the percent to fraction , like , and should use loop to estimate the price adjusted for inflation .
You have just purchased stereo system that cost on the following credit plan : no down payment , an interest rate of per year hence per , and payments of .
The payment of used to pay the interest and whatever left used to pay part of the remaining debt .
Hence , the first month you pay of in interest .

So , the remaining deducted from your debt , which leaves you with debt of .
The next month you pay interest of of , which .
Hence , you can deduct from the amount you owe .
Write program that will tell you how many months it will take you to pay off the loan , as well as the total amount of interest paid over the life of the loan .
Use loop to calculate the amount of interest and the size of the debt after each month .
You may want to use other variables as well .
The last payment may be less than .

Do not forget the interest on the last payment .

Chapter Basics payment of will not pay off your debt , although it will come close .
One interest on is only cents .

Write program that reads in ten whole numbers and that outputs the sum of all the numbers greater than zero , the sum of all the numbers less than zero will be negative number or , and the sum of all the numbers , whether positive , negative , or zero .
The user enters the ten numbers just once each and the user can enter them in any order .
Your program should not ask the user to enter the positive numbers and the negative numbers separately .

The temperature of the air affects the speed of the molecules , which in turn affects the speed of sound .
The velocity of sound in dry air can be approximated by the formula : velocity + Tc where Tc is the temperature of the air in degrees Celsius and the velocity is in .

Write program that allows the user to input starting and an ending temperature .
Within this temperature range , the program should output the temperature and the corresponding velocity in increments .
For example , if the user entered as the start temperature and as the end temperature , then the program should output At degrees Celsius the velocity of sound is At degrees Celsius the velocity of sound is At degrees Celsius the velocity of sound is VideoNote Solution to Programming Project Many private water wells produce only or gallons of water per minute .
One way to avoid running out of water with these wells is to use holding tank .
family of four will use about gallons of water per day .
However , there is " water holding tank in the casing is , the of the well itself .
deeper well stores more water that can be pumped out for household use .
But how much water will be available .

Write program that allows the user to input the radius of the well casing in inches typical well will have and the depth of the well in feet water will fill this entire depth , although in Programming Projects practice that will not be true since the static water level will generally be feet or more below the ground .
The program should output the number of gallons stored in the well casing .
For your reference , the volume of cylinder is , where is the radius and is the height , and cubic gallons of water .

For example , full of water with radius of inches for the casing holds about gallons of for family of four and no need to install separate holding tank .

The equation estimates the number of calories your body needs to maintain your weight if you do no exercise .
This is called your basal metabolic rate , or .

The formula for the calories needed for woman to maintain her weight is + weight in + height in The formula for the calories needed for man to maintain his weight is + weight in + height in typical chocolate bar will contain around calories .
Write program that allows the user to input his or her weight in pounds , height in inches , age in years , and the character for male and for female .
The program should then output the number of chocolate bars that should be consumed to maintain weight for the appropriate sex of the specified weight , height , and age .

Write program that calculates the total grade for classroom exercises as percentage .
The user should input the value for followed by each of the scores and totals .
Calculate the overall percentage of the total points earned divided by the total points and output it as percentage .
Sample input and output is shown below .

How many exercises to input .

It is important to consider the effect of thermal expansion when building structure that must withstand changes in temperature .
For example , metal beam will expand in hot temperatures .
The additional stress could cause the structure to fail .
Similarly , material will contract in cold temperatures .

The linear change in length of material if it is allowed to freely expand is described by the following equation : Here , is the initial length of the material in meters , is the displacement in meters , is the change in temperature in Celsius , and is coefficient for linear expansion .

Write program that inputs , and , then calculates and outputs the linear displacement .
If the displacement is positive then output that material will expand by " the displacement in meters .
If the More Flow of Control Using Boolean Expressions Evaluating Boolean Expressions Pitfall : Boolean Expressions Convert to int Values Enumeration Types Multiway Branches Nested Statements Programming Tip : Use Braces in Nested Statements Multiway Statements Programming Example : State Income Tax The switch Statement Pitfall : Forgetting break in switch Statement Using switch Statements for Menus Blocks Pitfall : Inadvertent Local Variables Chapter Summary Answers to Exercises about Loop Statements The while Statements Reviewed Increment and Decrement Operators Revisited The for Statement Pitfall : Extra Semicolon in for Statement What Kind of Loop to Use Pitfall : Uninitialized Variables and Infinite Loops The break Statement Pitfall : The break Statement in Nested Loops Designing Loops Loops for Sums and Products Ending Loop Nested Loops Debugging Loops Practice Programs Programming Projects When you come to fork in the road , take it .

Attributed to Yogi Berra Introduction The order in which the statements in your program are performed is called flow of control .
The statement , the while statement , and the dowhile statement are three to specify flow of control .
This chapter explores some new to use these statements and introduces two new statements called the switch statement and the for statement , which are also used for flow of control .
The actions of an statement , while statement , or statement are controlled by Boolean expressions .
We begin by discussing Boolean expressions in more detail .

Prerequisites This chapter uses material from Chapter .

Thus far you have used Boolean expressions the test condition in statements and the controlling expression in loops , such while loop .
However , Boolean expression has an independent identity apart from any statement or loop statement you might use it in .
The type bool provides you the ability to declare variables can carry the values true and false .

Boolean expression can be evaluated in the same way an arithmetic expression is evaluated .
The only difference is an arithmetic expression uses operations such + and and produces number the final result , whereas Boolean expression uses relational operations such and and Boolean operations such , and .

First review evaluating an arithmetic expression ; the same technique will work to evaluate Boolean expressions .
Consider the following arithmetic expression : Assume the variable has the value .
To evaluate this arithmetic expression , you evaluate the two sums to obtain the numbers and , then you combine these two numbers and using the operator to obtain the final value .

Notice in performing this evaluation , you do not multiply the expressions + and +
Instead , you multiply the values of these expressions .

The computer evaluates Boolean expressions the same way .

Subexpressions are evaluated to obtain values , each of which is either true or false .
These individual values of true or false are then combined according to the rules in the tables shown in Display .
For example , consider the Boolean expression which might be the controlling expression for an statement or while statement .
Suppose the value of is .
In this case , evaluates to false and evaluates to true , so the Boolean expression above is equivalent to Consulting the tables for is labeled OR in Display , the .

Consulting the tables again , the computer sees evaluates to false , and so it concludes false is the value of the original Boolean expression .

Almost all the examples we have constructed thus far have been fully parenthesized to show exactly how each , and .
Parentheses are not always required .
If you omit parentheses , the default precedence is follows : perform .
However , it is good practice to include most parentheses in order to make the expression easier to understand .
One place where parentheses can safely be omitted is simple string of or not mixture of the .
The following expression is acceptable in terms of both the compiler and readability :

Chapter More Flow of Control Display Truth Tables AND .

When parentheses are omitted from an expression , the computer groups items according to rules known precedence rules .
Some of the precedence rules for are given in Display .
If one operation is evaluated before another , the operation is evaluated first is said to have higher precedence .

Binary operations of equal precedence are evaluated in order .

Unary operations of equal precedence are evaluated in order .
complete set of precedence rules is given in Appendix .

Notice that the precedence rules include both arithmetic operators such as + as well as Boolean operators such as .
This is because many expressions combine arithmetic Boolean operations , as in the following simple example : + + If you check the precedence rules given in Display , you will see that this expression is equivalent to because have higher precedence than .
In fact , you could omit all the parentheses in the expression above it would have the same meaning , Using Expressions Display Precedence Rules The unary operators +

Highest precedence The binary arithmetic , The binary arithmetic + The ,  The .
Although we do not advocate omitting all the parentheses , it might be instructive to see how such an expression is interpreted using the precedence rules .
Here is the expression without any parentheses : + + The precedence rules say first apply the unary , then apply the + signs , then do the the , finally do the , which is exactly what the fully parenthesized version says to do .

The preceding description of how expression is evaluated is basically correct , but in , the computer actually takes an occasional shortcut when evaluating expression .
Notice that in many cases you need to evaluate only the first of two subexpressions in expression .

For example , consider the following : If is negative , then is false , as you can see in the tables in Display , when one subexpression in an expression is false , then the whole expression is false , no matter whether the other expression is true or false .
Thus , if we know that the first expression is false , there is no need to evaluate the second expression .
similar thing happens with expressions .
If the first of two expressions joined with the operator is true , then you know the entire expression is true , no matter whether the second expression is true or false .
The language uses this fact to sometimes save itself the trouble of evaluating the second subexpression in logical expression connected with an or an .
first evaluates the leftmost of the two expressions joined by an or an .
If that gives it enough information to determine the final value of the expression of the value of the second , then does not bother to evaluate the second expression .
This method of evaluation is called evaluation .

Chapter More Flow of Control Some languages , other than , use complete evaluation .
In complete evaluation , when two expressions are joined by an or an , both subexpressions are always evaluated then the truth tables are used to obtain the value of the final expression .

Both evaluation complete evaluation give the same answer , so why should you care that uses evaluation .
Most of the time you need not care .
As long as both subexpressions joined by the or the have value , the two methods yield the same result .
However , if the second subexpression is undefined , you might be happy to know that uses evaluation .

look at an example that illustrates this point .
Consider the following statement : child may have two ; If the value of is not zero , this statement involves no subtleties .
However , suppose the value of is zero consider how evaluation handles this case .
The expression evaluates to false , so there would be no need to evaluate the second expression .
Using evaluation , says that the entire expression is false , without bothering to evaluate the second expression .
This prevents error , since evaluating the second expression would involve dividing by zero .

sometimes uses integers as if they were values .
In particular , converts the integer to true converts the integer to false .
The situation is even bit more complicated than simply using for true for false .
The compiler will treat any nonzero number as if it were the value true will treat as if it were the value false .
As long as you make no mistakes in writing expressions , this conversion causes no problems you usually need not even be aware of it .
However , when you are debugging , it might help to know that the compiler is happy to combine integers using the operators ,

Pitfall Expressions Convert to int Values Suppose you want to use expression in an statement , and you want it to be true provided that time has not yet run out some game or .
To phrase it bit more precisely , suppose you want to use expression in an statement and you want it to be true provided the value of variable time of type int is not greater than the value Using Expressions of variable called limit .
You might write the following Something and are some : Something else Wrong for what we want This looks like nonsense , and intuitively it is nonsense .
If the value of time is , for example , what could possibly be the meaning of .

After all , that is equivalent to " But in , any nonzero integer converts to true and is converted to false .
Thus , is interpreted as true " and so it evaluates to false , which is in turn converted back to because we are comparing to an int .

What we want as the value of this Boolean expression and what gives us are not the same .
If time has value of and limit has value of , you want the displayed Boolean expression above to evaluate to true it is not true that time .
Unfortunately , the Boolean expression instead evaluates as follows : evaluates to false , which is converted to , so the entire Boolean expression is equivalent to limit That in turn is equivalent to , because is the value of limit .

This evaluates to false .
Thus , the above logical expression evaluates to false , when you want it to evaluate to true .

There are two ways to correct this problem .

When using the operator , be sure to include parentheses around the argument .
The correct way to write the preceding Boolean expression is as follows : Something else Another way to correct this problem is to completely avoid using the .

For example , the following is also correct and easier to read : Something else .

They say that just as not in English can make things not undifficult to read , so too can the " operator .

There is no need to be obsessive in avoiding the .

If you have an older version of that does not have the type bool , you should obtain new .

est Exe rc ise Determine the value , true or false , of each of the following Boolean expressions , assuming that the value of the variable count is and the value of the variable limit is .
Give your answer as one of the values true or false .

Name two kinds of statements in that alter the order in which actions are performed .
Give some examples .

Explain and give the correct Boolean expression that specifies that lies between and .

An enumeration type is very much like list of declared constants .

When defining an enumeration type , you can use any int values and can have any number of constants defined in an enumeration type .
For example , the following enumeration type defines constant for the length of each month : enum MonthLength , As this example shows , two or more named constants in an enumeration type can receive the same int value .

If you do not specify any numeric values , the identifiers in an enumerationtype definition are assigned consecutive values beginning with .
For example , the type definition enum ,

The form that does not explicitly list the int values is normally used when .

If you initialize only some enumeration constant to some values , say enum , TWO ,  FIVE ; then takes the value , TWO takes the next int value , takes the next value , takes , and FIVE takes the next value ,

In short , the default for the first enumeration constant is .
The rest increase by unless you set one or more of the enumeration constants .

introduced new of enumerations called strong enums or enum classes that avoids some problems of conventional enums .
For example , you may not want an enum to act as an integer .
Additionally , enums are global in scope so you have the same enum value twice .
To define strong enum , add the word class after enum .
You can qualify an enum value by providing the enum name followed by two colons followed by the value .
For example : enum class Sun , Mon , Tue , Wed .

It is legal to check if .

The statement chooses between two alternatives .
In this section we will discuss methods for choosing from among more than two alternatives .

Nested Statements As you have seen , statements and if statements contain smaller statements within them .
Thus far we have used compound statements and simple statements such as assignment statements as these smaller substatements , but there are other possibilities .
In fact , any statement at all can be used as subpart of an statement , of an if statement , of while statement , or of statement .
This is illustrated in Display .

The statement in that display has three levels of nesting , as indicated by the boxes .
Two statements are nested within an statement , and that statement is nested within an if statement .

When nesting statements , you normally indent each level of nested substatements .
In Display there are three levels of nesting , so there are Display An Statement Within an if Statement .

Both statements are indented the same amount because they are both at the same level of nesting .
Later in this chapter , you will see some specific cases where it makes sense to use other indenting patterns , but unless there is some rule to the contrary , you should indent each level of nesting as illustrated in Display .

This part of the program warns the driver when fuel is low but tells the driver to bypass pit stops if the fuel tank is close to full .
In all other situations the program gives no output so as not to distract the driver .
We design the following pseudocode : If the fuel gauge is below full , then : Check whether the fuel gauge is below full and issue low fuel warning if it is .

Otherwise is , if fuel gauge is over : Output statement telling the driver not to stop .

If we are not being too careful , we might implement the pseudocode as follows : Read text to see what is wrong with this .

stop ; This implementation looks fine , and it is indeed correctly formed statement that the compiler will accept and that will run with no error messages .

However , it does not implement the pseudocode .
Notice that this statement has two occurrences of if and only one else .
The compiler must decide which if gets paired with the one else .
We have nicely indented this nested statement to show that the else should be paired with the first if , but the compiler does not care about indenting .
To the compiler , the preceding nested statement is the same as the following  which differs only in how it is indented : very low .

stop ; Unfortunately for us , the compiler will use the second interpretation and will pair the one else with the second if rather than the first if .
This is sometimes called the dangling else problem ; it is illustrated by the program in Display .

The compiler always pairs an else with the nearest previous if that is not already paired with some else .
But , do not try to work within this rule .

Chapter More Flow of Control Display The Importance of Braces .

stop ; This indenting is .

Enter fuel gauge reading : First with braces : Braces make no difference in this case , but see Dialogue .

Fuel very low .

Now without braces : Fuel very low .

Sample Dialogue Enter fuel gauge reading : First with braces : Now without braces : Fuel over .

There should be no output here , and thanks to braces , there is none .

Incorrect output from the version without braces .

Change the rules .

Always tell the compiler what you want it to do and the compiler will then do what you want .
How do you tell the compiler what you want .

Braces in nested statements are like parentheses in arithmetic expressions .
The braces tell the compiler how to group things , rather than leaving them to be grouped according to default conventions , which may or may not be what you want .
To avoid problems and to make your programs easier to read , place braces , and , around substatements in statements , as we have done in the first statement in Display .

For very simple substatements , such as single assignment statement or single statement , you can safely omit the braces .
In Display , the are not needed : over .
stop ; However , even in these simple cases , the braces can sometimes aid readability .

Some programmers advocate using braces around even the simplest substatements when they occur within statements , which is what we have done in the first statement in Display .

It allows program to choose one of two possible actions .
Often you will want to have or branch so that your program can choose between more than two alternative actions .

You can implement such multiway branches by nesting statements .
By way of example , suppose you are designing program in which the user must the value of some number .
The number can be in variable named number , and the can be in variable named .
If you wish to give hint after each  you might design the following pseudocode : Output " when number .

Output " when number .

Output " when number .

Any time branching action is described as list of mutually exclusive conditions and corresponding actions , as in this example , it can be implemented by using nested statement .
For example , this pseudocode translates to the following code :

If we followed our indenting rules , we would produce something like the following : rule for pairing with .

This is one of those rare cases in which you should not follow our general guidelines for indenting nested statements .
The reason is that by lining up all the , you also line up all the pairs and so make the layout of the program reflect your reasoning .
Another reason is that even for nested statements , you can quickly run out of space on your page .

Since the conditions are mutually exclusive , the last if in the nested statement above is superfluous and can be omitted , but it is sometimes best to it in comment as follows :

You can use this form of statement even if the conditions are not mutually exclusive .
Whether the conditions are mutually exclusive or not , the computer will evaluate the conditions in the order in which they appear until it finds the first condition that is true and then it will execute the action corresponding to this condition .
If no condition is true , no action is taken .
If the statement ends with plain else without any if , then the last statement is executed when all the conditions are false .

Multiway Statement Syntax .

else Multiway Branches .

The Boolean expressions are checked in order until the first true Boolean expression is encountered , and then the corresponding statement is executed .
If none of the Boolean expressions is true , then the is executed .

Programming Example State Income Tax Display contains program that uses multiway statement .

The program takes the net income rounded to whole number of dollars and computes the state income tax due on this net income .
This state computes tax according to the following rate schedule :
No tax is paid on the first of net income .

tax of percent is assessed on each dollar of net income from to .

tax of percent is assessed on each dollar of net income over .

The program defined in Display uses multiway statement with one action for each of these three cases .
The condition for the second case is actually more complicated than it needs to be .
The computer will not get to the second condition unless it has already tried the first condition and found it to be false .
Thus , you know that whenever the computer tries the second condition , it will know that is greater than .
Hence , you can replace the line with the following , and the program will perform exactly the same :

Chapter More Flow of Control Display Multiway Statement .

Sample Dialogue Enter net to whole Multiway Branches est Exerc ise .
What output will be produced by the following code , when embedded in complete program .

What would be the output in Exercise if the Boolean expression were changed to .

What output will be produced by the following code , when embedded in complete program .

Assume that neither Output " nor Output " is output .
So , you know the value of is output .

Write multiway statement that classifies the value of an int variable into one of the following categories and writes out an appropriate message : or or Given the following declaration and output statement , assume that this .

You have seen statements used to construct multiway branches .
The switch statement is another kind of statement that also implements Multiway Branches multiway branches .
sample switch statement is shown in Display .
This particular switch statement has four regular branches and fifth branch for illegal input .
The variable grade determines which branch is executed .
There is one branch for each of the grades , and .
The grades ' and ' cause the same branch to be taken , rather than having separate action for each of ' and .
If the value of grade is any character other than , or , then the statement after the identifier default is executed .

Chapter More Flow of Control Sample Dialogue Enter your midterm and press Return : Excellent .
You need not take the final .

End of program .

Sample Dialogue Enter your midterm and press Return : Very good .
Your midterm is now .

End of program .

Sample Dialogue Enter your midterm and press Return : Not good .

End of program .

Sample Dialogue Enter your midterm and press Return : That is not possible .

End of program .

VideoNote switch Statement Example The syntax and preferred indenting pattern for the switch statement are shown in the sample switch statement in Display and in the box entitled Multiway Branches Notice that the constant is followed by colon .
Also note that you cannot have two occurrences of case with the same constant value after them , since that would be an ambiguous instruction .

break statement consists of the keyword break followed by semicolon .

When the computer executes the statements after case label , it continues until it reaches break statement .
When the computer encounters break statement , the switch statement ends .
If you omit the break statements , then after executing the code for one case , the computer will go on to execute the code for the next case .

Note that you can have two case labels for the same section of code .
In the switch statement in Display , the same action is taken for the values ' and .
This technique can also be used to allow for both and lowercase letters .
For example , to allow both lowercase ' and uppercase ' in the program in Display , you can replace case : with the following : case : case : Of course , the same can be done for all the other letters .

If no case label has constant that matches the value of the controlling expression , then the statements following the default label are executed .
You need not have default section .
If there is no default section and no match is found for the value of the controlling expression , then nothing happens when the switch statement is executed .
However , it is safest to always have default section .
If you think your case labels list all possible outcomes , then you can put an error message in the default section .

Chapter More Flow of Control case :

Pitfall Forgetting break in switch Statement If you forget break in switch statement , the compiler will not issue an error message .
You will have written syntactically correct switch statement , but it will not do what you intended it to do .
Consider the switch statement in the box entitled " If break statement were omitted , as indicated by the arrow , then when the variable has the value , the case labeled case : Multiway Branches would be executed as desired , but then the computer would go on to also execute the next case .
This would produce puzzling output that says the vehicle is passenger car and then later says it is bus ; moreover , the final value of would be , not as it should be .
When the computer starts to execute case , it does not stop until it encounters either break or the end of the switch statement .

For example , the switch statement is perfect for implementing menus .

Chapter More Flow of Control .

Sample Dialogue Choose to see the next homework assignment .

Choose for your grade on the last assignment .

Choose for assignment hints .

Choose to exit this program .

Enter your and press Return : Assignment hints : Analyze the problem .

Write an algorithm in pseudocode .

Translate the pseudocode into program .

Choose to see the next homework assignment .

Choose for your grade on the last assignment .

The exact output will depend on the code inserted into the switch statement .

Choose for assignment hints .

Choose to exit this program .

Enter your and press Return : End of Program .

menu in restaurant presents list of alternatives for customer to choose from .
menu in computer program does the same thing : It presents list of alternatives on the screen for the user to choose from .
Display shows the outline of program designed to give students information on homework assignments .
The program uses menu to let the student choose which information she or he wants .
more readable way to implement the menu actions is through functions .
Functions are discussed in Chapter .

As indicated in the previous Programming Tip , it is often best to make the action of each branch function call .
That way the subtask for each branch can be designed , written , and tested separately .
On the other hand , sometimes the action of one branch is so simple that you can just make it compound statement .
Occasionally , you may want to give this compound statement its own local variables .
For example , consider the program in Display .
It calculates the final bill for specified number of items at given price .
If the sale is wholesale transaction , then no sales tax is charged because the tax will be paid when the items are resold to retail .
If , however , the sale is retail transaction , then sales tax must be added .
An statement is used to produce different calculations for wholesale and retail purchases .
For the retail purchase , the calculation uses temporary variable called subtotal , and so that variable is declared within the compound statement for that branch of the statement .

As shown in Display , the variable subtotal is declared within compound statement .
If we wanted to , we could have used the variable name subtotal for something else outside of the compound statement in which it is declared .
variable that is declared inside compound statement is local to the compound statement .
Local variables are created when the compound statement is executed and are destroyed when the compound statement is completed .
In other words , local variables exist only within the compound statement in which they are declared .
Within compound statement , you can use all the variables declared outside of the compound statement , as well as the local variables declared inside the compound statement .

Chapter More Flow of Control number purchased :

Sample Dialogue Enter  Enter purchased : Type if this is wholesale purchase .

Type if this is retail purchase .

Then press Return .

Local to the block Multiway Branches compound statement with declarations is more than simple compound statement , so it has special name .
compound statement that contains variable declarations is usually called block , and the variables declared within the block are said to be local to the block or to have the block as their scope .
Any code enclosed in braces is In Chapter we will show how to define functions .
The body of function definition is also block .
There is no standard name for block that is not the body of function .
However , we want to talk about these kinds of blocks , so let us create name for them .
call block statement block when it is not the body of function not the body of the main part of .

Statement blocks can be nested within other statement blocks , and basically the same rules about local variable names apply to these nested statement blocks as those we have already discussed , but applying the rules can be tricky when statement blocks are nested .
better rule is to not nest statement blocks .
Nested statement blocks make program hard to read .

If you feel the need to nest statement blocks , instead make some of the statement blocks into function definitions and use function calls rather than nested statement blocks .
In fact , statement blocks of any kind should be used sparingly .
In most situations , function call is preferable to statement block .
For completeness , we the scope rule for nested blocks in the accompanying summary box .

Blocks block is some code enclosed in braces .
The variables declared in block are local to the block and so the variable names can be used outside of the block for something else as being reused as the name for different .

Scope Rule for Nested Blocks If an identifier is declared as variable in each of two blocks , one within the other , then these are two different variables with the same name .

One variable exists only within the inner block and cannot be accessed outside of the inner block .
The other variable exists only in the outer block and cannot be accessed in the inner block .
The two variables are distinct , so changes made to one of these variables will have no effect on the other of these two variables .

Chapter More Flow of Control Pitfall Inadvertent Local Variables When you declare variable within pair of braces , that variable becomes local variable for the block enclosed in the pair .
This is true whether you wanted the variable to be local or not .
If you want variable to be available outside of the braces , then you must declare it outside of the braces .

What output will be produced by the following code , when embedded in complete program .

What output is produced by the following code , when embedded in .

Though we urge you not to program using this style , we are providing an exercise that uses nested blocks to help you understand the scope rules .

Give the output that this code fragment would produce if embedded in an otherwise complete , correct program .

Vincent Millay , Letter to Arthur Darison Ficke , October , loop is any program construction that repeats statement or sequence of statements of times .
The simple while loops and loops that we have already seen are examples of loops .
The statement group of to be repeated in loop is called the body of the loop , and each repetition of the loop body is called an iteration of the loop .
The two main design questions when constructing loops are : What should the loop body be .

How many times should the loop body be iterated .

The while Statements Reviewed The syntax for the while statement and its variant , the statement , is reviewed in Display .
The important difference between the two types of loops .

Chapter More Flow of Control involves when the controlling Boolean expression is checked .
When while statement is executed , the Boolean expression is checked before the loop body is executed .
If the Boolean expression evaluates to false , then the body is not executed at all .
With statement , the body of the loop is executed first and the Boolean expression is checked after the loop body is executed .
Thus , the statement always executes the loop body at least once .
After this , the while loop and the loop behave very much the same .
After each iteration of the loop body , the Boolean expression is again checked ; if it is true , then the loop is iterated again .
If it has changed from true to false , then the loop statement ends .

Display of the while Statement and Statement while Statement with Single Statement Body Statement Body while Statement with Multistatement Body .

Body Statement with Single Statement Body do Statement while ; Body .

Statement with Multistatement Body do .

while ; More About Loop Statements The first thing that happens when while loop is executed is that the controlling Boolean expression is evaluated .
If the Boolean expression evaluates to false at that point , then the body of the loop is never executed .

It may seem pointless to execute the body of loop zero times , but that is sometimes the desired action .
For example , while loop is often used to sum list of numbers , but the list could be empty .
To be more specific , checkbook balancing program might use while loop to sum the values of all the checks you have written in you might take vacation and write no checks at all .
In that case , there are zero numbers to sum and so the loop is iterated zero times .

Thus far we have always used the increment operator as statement .
But the increment operator is also an operator , just like the + and .
An expression like also returns value , so can be used in an arithmetic expression such as The expression first returns the value of the variable  and then the value of is increased by .
For example , consider the following .

When evaluates this expression , it uses the value that has before it is incremented , not the value that it has after it is incremented .
Thus , the value produced by the expression is , even though the increment operator changes the value of to .
This may seem strange , but sometimes it is just what you want .
And , as you are about to see , if you want an expression that behaves differently , you can have it .

The expression evaluates to the value of the variable , and then the value of the variable is incremented by .
If you reverse the order and place increment operator in expressions Chapter More Flow of Control the in front of the variable , the order of these two actions is reversed .
The expression first increments the value of the variable and then returns .

This code is the same as the previous piece of code except that the is before the variable , so this code produces the following output : Notice that the two increment operators and have the same effect on variable  They both increase the value of by .

But the two expressions evaluate to different values .
Remember , if the is before the variable , then the incrementing is done before the value is returned ; if the is after the variable , then the incrementing is done after the value is returned .

The program in Display uses the increment operator in while loop to count the of times the loop body is repeated .
One of the main uses of the increment operator is to control the iteration of loops in ways similar to what is done in Display .

Display Increment Operator as an Expression .

Sample Dialogue How many items did you eat .

Chapter More Flow of Control returns the value of and then decrements  on the other hand , first decrements and then returns the value of .

Expressions such as + + and so forth are all illegal in .

est Exe rc ise .
What is the output of the following embedded in complete .

What is the output of the following embedded in complete .

What is the output of the following embedded in complete .

The for Statement The while statement and the statement are all the loop mechanisms you absolutely need .
In fact , the while statement alone is enough .
However , there is one sort of loop that is so common that includes special statement for this .
In performing numeric calculations , it is common to do calculation with the , then with the , then with , and so forth , until some last value is reached .
For example , to add through , you More About Loop Statements want the computer to perform the following statement ten times , with the value of equal to the first time and with increased by each subsequent time : +

The following for statement will neatly accomplish the same task : +  look at this for statement piece by piece .

First , notice that the while loop version and the for loop version are made by putting together the same pieces : They both start with an assignment statement that sets the variable equal to .
In both cases , this assignment statement for is placed before the loop statement itself begins .
The loop statements themselves are both made from the pieces .

The for statement is simply more compact way of saying the same thing .
Although other things are possible , we will only use for statements to perform loops controlled by one variable .
In our example , that would be the variable .
With the equivalence of the previous two loops to guide us , go over the rules for writing for statement .

for statement begins with the keyword for followed by three things in parentheses that tell the computer what to do with the controlling variable .

The beginning of for statement looks like the following : The first expression tells how the variable is initialized , the second gives Boolean expression that is used to check for when the loop should end , and the last expression tells how the loop control variable is updated after each iteration of the loop body .
For example , the above for loop begins .

Chapter More Flow of Control says that is initialized to .

Do not succumb to the temptation to place semicolon after the third expression .
Notice that in for statement , as in the corresponding while statement , the stopping condition is tested before the first loop iteration .

Thus , it is possible to have for loop whose body is executed zero times .

Output bottles of beer on the shelf .

Display shows sample for statement embedded in complete very program .
So , the declaration of is inside the for statement .
When variable is used only within the for statement , this can be the best place to declare the variable .
However , if the variable is also used outside of the for statement , then it is best to declare the variable outside of the for statement .

ANSI standard requires that compiler claiming compliance with the standard treat any declaration in for loop initializer as if it were local to the body of the loop .
Earlier compilers did not do this .
You should determine how your compiler treats variables declared in for loop initializer .
In the interests of portability , you should not write code that depends on this behavior .
ANSI standard requires that variables declared in the initialization expression of for loop be local to the block of the for loop .

Our description of for statement was bit less general than what is allowed .
However , our for statements will always use only single variable in these expressions .

In the for statement in Display , the body was the simple assignment statement +  declaring variables within for statement Chapter More Flow of Control Display for Statement .

Done after each loop body iteration for ; that the variable is local +

The of the numbers to is Display for Loop with Multistatement Body SYNTAX .

The body may be any statement at all .
In particular , the body may be compound statement .
This allows us to place several statements in the body of for loop , as shown in Display .

Thus far , you have seen for loops that increase the loop control variable by after each loop iteration , and you have seen for loops that decrease the loop control variable by after each loop iteration .
There are many more possible kinds of variable updates .
The variable can be incremented or decremented by or or any .
If the variable is of type double , it can be incremented or decremented by fractional amount .
All of the following are legitimate for loops : int   is now equal 

Moreover , the initialization need not simply set variable equal constant .
You can initialize and change loop control variable in just about any way you wish .
For example , the following demonstrates one more way start for loop :  is now equal  endl ; Pitfall Extra Semicolon in for Statement .

If you do notice the semicolon , you might expect the compiler issue an error message .

If you embed this for loop in complete program , the compiler will not complain .
If you run the program , only one Hello will be output instead of ten Hellos .

To answer that question , we need little background .

One way create statement in is put semicolon after something .
If you put semicolon after , you change the expression more possible update actions .

Thus , the semicolon by itself is statement , which is called the empty statement or the null statement .
The empty statement performs no action , but it is still statement .
Therefore , the following is complete and legitimate for loop , whose body is the empty statement : for ; This for loop is indeed iterated ten times , but since the body is the empty statement , nothing happens when the body is iterated .
This loop does nothing , and it does nothing ten times .

Now go back and consider the for loop code labeled Problem semicolon .
Because of the extra semicolon , that code begins with for loop that has an empty body , and as we just discussed , that for loop accomplishes nothing .
After the for loop is completed , the following statement is executed and writes Hello the screen one time : You will eventually see some uses for for loops with empty bodies , but at this stage , such for loop is likely be just careless mistake .

First design the loop using pseudocode , then translate the pseudocode into code .
At that point it will be easy decide what type of loop statement use .

If the loop involves numeric calculation using variable that is changed by equal amounts each time through the loop , use for loop .
In fact , whenever you have loop for numeric calculation , you should consider using for loop .
It will not always be suitable , but it is often the clearest and easiest loop use for numeric calculations .

In most other cases , you should use while loop or loop ; it is fairly easy decide which of these two use .
If you want insist that the loop body will be executed at least once , you may use loop .
If there are circumstances for which the loop body should not be executed at all , then you must use while loop .
common situation that demands while loop is reading input when there is possibility of no data at all .
For example , if the program reads in list of exam scores , there may be cases of students who have taken no exams , and hence the input loop may be faced with an empty list .
This calls for while loop .

What is the output of the following embedded in complete .

What is the output of the following embedded in complete .

For each of the following situations , tell which type of loop , or would work best :

Summing series , such as + + + +

Pitfall Uninitialized Variables and Infinite Loops When we first introduced simple while and loops in Chapter , we warned you of two pitfalls associated with loops .
We said that you should be sure all variables that need to have value in the loop are initialized is , given before the loop is executed .
This seems obvious when stated in the abstract , but in practice it is easy to become so concerned with designing loop that you forget to initialize variables before the loop .
We also said that you should be careful to avoid infinite loops .
Both of these cautions apply equally well to for loops .

This same break statement can be used to exit loop .
Sometimes you want to exit loop before it ends in the normal way .
For example , the loop might contain check for improper input and if some improper input is encountered , then you may want to simply end the loop .
The code in Display reads list of negative numbers and computes their sum as the value of the variable sum .
The loop ends normally provided the user types in ten negative numbers .
If the user forgets minus sign , the computation is ruined and the loop ends immediately when the break statement is executed .

Sample Dialogue Enter negative numbers : ERROR : positive or zero was entered as the .
Input ends with the .

The break Statement The break statement can be used to exit loop statement .
When the break statement is executed , the loop statement ends immediately and execution continues with the statement following the loop statement .

The break statement may be used in any form of while loop , in loop , or in for loop .

Pitfall The break Statement in Nested Loops break statement ends only the innermost loop that contains it .
If you have loop within loop and break statement in the inner loop , then the break statement will end only the inner loop .

What is the output of the following embedded in complete .

What is the output of the following embedded in complete .

Traditional Carnival Call When designing loop , you need to design three things :
The body of the loop .
The initializing statements .
The conditions for ending the loop We begin with section on two common loop tasks and show how to design these three elements for each of the two tasks .

Loops for Sums and Products Many common tasks involve reading in list of numbers and computing their If you know how many numbers there will be , such task can easily be accomplished by the following pseudocode .
The value of the variable many is the of numbers to be added .
The is accumulated in the variable .

In order to determine the correct initializing value for  think about what you want to happen after one loop iteration .
After adding in the first  the value of should be that That is , the first time through the loop the value of + next should equal next .
To make this true , the value of must be initialized to .

for statement can be used to produce loop that repeats the loop body predetermined of times .

Pseudocode Repeat the following times : Equivalent for Statement Example , Hip , You can form the of list of numbers in way that is similar to how we formed the of list of numbers .
The technique is illustrated by the following code : int .

The variable must be given an initial value .
Do not assume that all variables should be initialized to zero .
If were initialized to , then it would still be zero after the loop above has finished .
As indicated in the code shown earlier , the correct initializing value for is .

To see that is the correct initial value , notice that the first time through the loop this will leave equal to the first read in , which is what you want .

Ending Loop There are four commonly used methods for terminating an input loop .
We will discuss them in order .

List headed by size .
Ask before iterating .
List ended with sentinel value Running out of input If your program can determine the size of an input list beforehand , either loop to read input exactly times , where is the size of the list .
This method is called list headed by size .

The second method for ending an input loop is simply to ask the user , after each loop iteration , whether or not the loop should be iterated again .

However , for reading in long list , this is very tiresome to the user .
Imagine typing in list of numbers this way .
The user is likely to progress from happy to sarcastic and then to angry and frustrated .
When reading in long list , it is preferable to include only one stopping signal , which is the method we discuss next .

Chapter More Flow of Control Perhaps the nicest way to terminate loop that reads list of values from the keyboard is with sentinel value .
sentinel value is one that is somehow distinct from all the possible values on the list being read in and so can be used to signal the end of the list .
For example , if the loop reads in list of positive numbers , then negative can be used as sentinel value to indicate the end of the list .
loop such as the following can be used to add list of nonnegative .

Notice that the last in the list is read but is not added into .
To add the numbers , and , the user appends negative to the end of the list like so : The final is read in but not added into the .

To use sentinel value this way , you must be certain there is at least one value of the data type in question that definitely will not appear on the list of input values and thus can be used as the sentinel value .
If the list consists of integers that might be any value whatsoever , then there is no value left to serve as the sentinel value .
In this situation , you must use some other method to terminate the loop .

When reading input from file , you can use sentinel value , but more common method is to simply check to see if all the input in the file has been read and to end the loop when there is no more input left to be read .
This method of ending an input loop is discussed in Chapter in the Programming Tip section entitled for the End of File " and in the section entitled The techniques we gave for ending an input loop are all special cases of more general techniques that can be used to end loops of any kind .
The more general techniques are as .

Ask before iterating .

Exit on flag condition loop is any loop that determines the of iterations before the loop begins and then iterates the loop body that many times .
The technique that we discussed for input loops is loops are loops .

You can use it for loops other than input loops , but the most common use for this technique is for processing input .

Earlier in this section we discussed input loops that end when sentinel value is read .
In our example , the program read nonnegative integers into variable called .
When received negative value , that indicated the end of the input ; the negative value was the sentinel value .
This is an example of more general technique known as exit on flag condition .
variable that changes value to indicate that some event has taken place is often called flag .
In our example input loop , the flag was the variable  when it becomes negative , that indicates that the input list has ended .

Ending file input loop by running out of input is another example of the technique .
In this case the flag condition is determined by the system .
The system keeps track of whether or not input reading has reached the end of file .

flag can also be used to terminate loops other than input loops .
For example , the following sample loop can be used to find tutor for student .

Students in the class are numbered starting with .
The loop checks each student to see if that student received high and stops the loop as soon as student with high is found .
For this example , of or more is considered high .
The code is call to function .

In this case , the function will execute some code that will compute numeric value from to that corresponds to student .
The numeric value then is copied into the variable .
Chapter discusses functions in more detail .

In this example , the variable serves as the flag .

The previous loop indicates problem that can arise when designing loops .
What happens if no student has score or better .
The answer depends on the definition for the function .
If is defined for all positive integers , it could be an infinite loop .
Even worse , if is defined to be , say , for all arguments that are not students , then it may try to make tutor out nonexistent student .
In any event , something will go wrong .
If there is danger loop turning into an infinite loop or even danger it iterating more times than is sensible , then you should include check to see that the loop is not iterated too many times .
For example , better condition for our example loop is the following , where the variable has been set equal to the students in the class :

In the district where this vulture survives , conservationists annually perform count the eggs in vulture nests .
The program in Display takes the reports each the conservationists in the district and calculates the total eggs contained in all the nests they observed .

Each report consists list numbers .
Each is the count the eggs observed in one vulture nest .
The program reads in the report one conservationist and calculates the total eggs found by this conservationist .
The list numbers for each conservationist has negative added to the end the list .
This serves as sentinel value .
The program loops through the reports and calculates the total eggs found for each report .

The body loop may contain any kind statement , so it is possible to have loops nested within loops well as eggs nested within .
The program in Display contains loop within loop .
The nested loop in Display is executed once for each value count from to reports .
For each such iteration the outer for loop there is one complete execution the inner while loop .
In Chapter use subroutines to make the program in Display more readable .

est Exercises .
Write loop that will write the word Hello to the screen ten times embedded in complete .

The list is ended with sentinel value .
Among other things , you must decide what would be good sentinel value to use .

Predict the output of the following nested loops : int    times    endl ; Debugging Loops .

First , localize the problem No matter how carefully program is designed , mistakes will still sometimes occur .
In the case of loops , there is pattern to the kinds of mistakes programmers most often make .
Most loop errors involve the first or last iteration of the loop .
If you find that your loop does not perform as expected , check to see if the loop is iterated one too many or one too few times .
Loops that iterate one too many or one too few times are said to have an error ; these errors are among the most common loop bugs .
Be sure you are not confusing with .
Be sure you have initialized the loop correctly .
Remember that loop may sometimes need to be iterated zero times and check that your loop handles that possibility correctly .

Infinite loops usually result from mistake in the Boolean expression that controls the stopping of the loop .
Check to see that you have not reversed an inequality , confusing with .
Another common source of infinite loops is terminating loop with test for equality , rather than something involving or .
With values of type double , testing for equality does not give meaningful answers , since the quantities being compared are only approximate values .
Even for values of type int , equality can be dangerous test to use for ending loop , since there is only one way that it can be satisfied .

If you check and recheck your loop and can find no error , but your program still misbehaves , then you will need to do some more sophisticated testing .
First , make sure that the mistake is indeed in the loop .
Just because the program is performing incorrectly does not mean the bug is where you think it is .
If your program is divided into functions , it should be easy to determine the approximate location of the bug or bugs .

Once you have decided that the bug is in particular loop , you should watch the loop change the value of variables while the program is running .

This way you can see what the loop is doing and thus see what it is doing wrong .
Watching the value of variable change while the program is running is called tracing the variable .
Many systems have debugging utilities that allow you to easily trace variables without making any changes to your program .
If your system has such debugging utility , it would be well worth your effort to learn how to use it .
If your system does not have debugging utility , you can trace variable by placing temporary statement in the loop body ; that way the value of the variable will be written to the screen on each loop iteration .

The comment at the end of the loop tells what the loop is supposed to do , but we have tested it and know that it gives the variable an incorrect value .
We need to find out what is wrong .
To help us debug this loop , we trace the variables and .
If you have debugging utility , you could use it .
If you do not have debugging facility , you can trace the variables by inserting statement as follows : int ,

When we trace the variables and  we find that after the first loop iteration , the values of and are both .
It is then clear to us that we have multiplied only the numbers through and have missed multiplying by .

There are at least two good ways to fix this bug .
The easiest fix is to initialize the variable to , rather than .
That way , when is incremented the first time through the loop , it will receive the value rather than .
Another way to fix the loop is to place the increment after the multiplication , as follows : int ,

assume we fix the bug by moving the statement as indicated above .
After we add this fix , we are not yet done .
We must test this revised code .

When we test it , we will see that it still gives an incorrect result .
If we again trace variables , we will discover that the loop stops after multiplying by , and never multiplies by .
This tells us that the Boolean expression should now use sign , rather than sign .
Thus , the correct code is .

Never assume that your change will make the program correct .
Just because you found one thing to correct does not mean you have found all the things that need to be corrected .
Also , as illustrated by this example , when you change one part of your program to make it correct , that change may require you to change some other part of the program as well .

Testing Loop Every loop should be tested with inputs that cause each of the following loop behaviors as many as are : zero iterations of the loop body , one iteration of the loop body , the maximum number of iterations of the loop body , and one less than the maximum number of iterations of the loop body .
You should The techniques we have developed will help you find the few bugs that may find their way into program .
However , no amount of debugging can convert poorly designed program into reliable and readable one .
If program or algorithm is very difficult to understand or performs very poorly , do not try to fix it .
Instead , throw it away and start over .
This will result in program that is easier to read and that is less likely to contain hidden errors .
What may not be so obvious is that by throwing out the poorly designed code and starting over , you will produce working program faster than if you try to repair the old code .
It may seem like wasted effort to throw out all the code that you worked so hard on , but that is the most efficient way to proceed .
The work that went into the discarded code is not wasted .

The lessons you learned by writing it will help you to design better program faster than if you started with no experience .
The bad code itself is unlikely to help at all .

Debugging Very Bad Program If your program is very bad , do not try to debug it .
Instead , throw it out and start over .

Chapter Summary est Exerc ise .
What does it mean to trace variable .
How do you trace variable .

What is an loop error .

You have fence that is to be meters long .
Your fence posts are to be placed every feet .
How many fence posts do you need .
Why is the presence of this problem in programming book not as silly as it might seem .
What problem that programmers have does this question address .

Chapter Summary Boolean expressions are evaluated similarly to the way arithmetic expressions are evaluated .

call to such function can be used as Boolean expression in an statement or anywhere else that Boolean expression is permitted .

This can be implemented in as multiway statement .

The variables declared in block are local to the block .
Among other uses , blocks can be used for the action in one branch of multiway branch statement , such as multiway statement .

Once the algorithm has been designed , the choice of which loop statement to use is usually clear .

Instead , throw it away and start over .

Answers to Self Test Exerci ses .

Note that expressions and mean exactly the same thing .

Because the and have higher precedence than , you easier to read than the expression in , even though they mean the same thing .

Since the value of the first subexpression is false , you know that the entire expression is false without bothering to evaluate the second subexpression .
Thus , it does not matter what the values of and are .
This is called evaluation , which is what does .

Since the value of the first subexpression is true , you know that the entire expression is true without bothering to evaluate the second subexpression .
Thus , it does not matter what the values of and are .
This is called evaluation , which is what does .

This subexpression is evaluated using evaluation as we described for .
The entire expression in is equivalent to in turn is equivalent to true true , and that is equivalent to , which is equivalent to the final value of false .

Answers to Exercises .
Since the value of the first subexpression is true , you know that the entire expression is true without bothering to evaluate the second subexpression .
Thus , the second subexpression never evaluated and so the fact that it involves division by zero is never noticed by the computer .
This is evaluation , which is what does .

Since the value of the first subexpression is false , you know that the entire expression is false without bothering to evaluate the second subexpression .
Thus , the second subexpression never evaluated and so the fact that it involves division by zero is never noticed by the computer .
This is evaluation , which is what does .

The expression has no intuitive meaning , but converts the int values to bool values and then evaluates the and .
Thus , will evaluate this mess .
Recall that in , any nonzero integer converts to true , and converts to false .
will evaluate follows : In the expression , the and convert to true .
In , the is converted to true , so evaluates to false , which converts to .
The entire expression thus evaluates to + which is .
The final value is thus .
will convert the number to true , but the answer has little intuitive meaning as true ; it is perhaps better to just say the answer is .

To this point we have studied branching statements , iteration statements , and function call statements .
Examples of branching statements we have studied are if and statements .
Examples of iteration statements are while and statements .

Since is Boolean  its value is either true or false , which converts to or , so that is always true .
The output is " regardless of the value of .

The Boolean is false was just assigned .

The uses evaluation , which does not evaluate the second if the truth value can be determined from the first .
The first is false , so the entire evaluates to false without evaluating the second .
So , there is no division by zero .

Start Hello from the second if .

End Start again End again .

Start Second Output End .
The statements are the same whether the second Boolean is or .
So , the output is the same as in Exercise .

Start End .
Both of the following are correct :  is less than .

The constants increment by .

Unassigned constants increment the previous value by .

Chocolate ice cream Onion ice cream .

Hello Hello Hello Hello Hello .

for loop .
Both require while loop since the input list might be empty .

loop can be used since at least one test will be performed .

The second number is the base log of the first number .

The ' after the for is probably pitfall error .

This is an infinite loop .
Consider the update expression .
It cannot change because its initial value is , so it leaves at its initial value ,

break statement is used to exit loop while , or for or to terminate case in switch statement .
break is not legal anywhere else in program .
Note that the loops are nested , break statement only terminates one level of the loop .

Answers to Exercises .

The output is too long to reproduce here .
The pattern is as follows :

Tracing variable means watching program variable change value while the program is running .
This can be done with special debugging facilities or by inserting temporary output statements in the program .

Loops that iterate the loop body one too many or one too few are said to have an error .

Typical reasoning from those who do not think carefully is feet of fence feet between This , of course , will leave the last feet of fence without post .
You need to provide intervals to get feet of fence .

Chapter More Flow of Control Practice Programs Practice Programs can generally be solved with short program that directly applies the programming principles presented in this chapter .

Write program to score the game .
Each of two users types in either , or .
The program then announces the winner as well as the basis for determining the winner : Paper covers rock , Rock breaks scissors , Scissors cut paper , or Nobody wins .
Be sure to allow the users to use lowercase as well as uppercase letters .
Your program should include loop that lets the user play again until the user says she or he is done .

Write program to compute the interest due , total amount due , and the minimum payment for revolving credit account .
The program accepts the account balance as input , then adds on the interest to get the total amount due .
The rate schedules are the following : The interest is percent on the first and percent on any amount over that .
The minimum payment is the total amount due if that is or less ; otherwise , it is or percent of the total amount owed , whichever is larger .
Your program should include loop that lets the user repeat this calculation until the user says she or he is done .

Write an astrology program .
The user types in birthday , and the program responds with the sign and horoscope for that birthday .
The month may be entered as number from to .
Then enhance your program so that if the birthday is only one or two days away from an adjacent sign , the program announces that the birthday is on " and also outputs the horoscope for that nearest adjacent sign .
This program will have long multiway branch .
Make up horoscope for each sign .
Your program should include loop that lets the user repeat this calculation until the user says she or he is done .

The horoscope signs and dates are : Aries March Taurus April Gemini May Cancer June Leo July Virgo August Libra September Scorpio October Sagittarius November Capricorn December Aquarius January Pisces February Practice Programs .
Horoscope Signs of the same Element are most compatible .
There are Elements in astrology , and Signs in each : FIRE , Leo , EARTH , Virgo , AIR , Libra ,  WATER , Scorpio ,

According to some astrologers , you are most comfortable with your own sign and the other two signs in your Element .
For example , Aries would be most comfortable with other Aries and the two other FIRE signs , Leo and Sagittarius .

Modify your program from Practice Program to also display the name of the signs that will be compatible for the birthday .

Write program that finds and prints all of the prime numbers between and .
prime number is number such that and itself are the only numbers that evenly divide it example ,

One way to solve this problem is to use doubly nested loop .
The outer loop can iterate from to while the inner loop checks to see if the counter value for the outer loop is prime .
One way to see if number is prime is to loop from to and if any of these numbers evenly divides , then cannot be prime .
If none of the values from to evenly divides , then must be prime .
Buoyancy is the ability of an object to float .
Archimedes ' principle states that the buoyant force is equal to the weight of the fluid that is displaced by the submerged object .
The buoyant force can be computed by where is the buoyant force , is the volume of the submerged object , and is the specific weight of the fluid .
If is greater than or equal to the weight of the object , then it will float , otherwise it will sink .

Use as the specific weight of water .
The volume of sphere is computed by .

Write program that finds the temperature that is the same in both Celsius and .
The formula to convert from Celsius to is + Your program should create two integer variables for the temperature in Celsius and .
Initialize the temperature to degrees Celsius .

In loop , decrement the Celsius value and compute the corresponding temperature in until the two values are the same .

Chapter More Flow of Control Since you are working with integer values , the formula may not give an exact result for every possible Celsius temperature .
This will not affect your solution to this particular problem .

Programming Projects Programming Projects require more than Practice Programs and can usually be solved many different ways .
Visit to complete many of these Programming Projects online and get instant feedback .

Write program that computes the cost of call .
The cost of the call is determined according to the following rate schedule : call started between am and pm , Monday through Friday , is billed at rate of per minute .

The input will consist of the day of the week , the time the call started , and the length of the call in minutes .
The output will be the cost of the call .
The time is to be input in notation , so the time pm is input as The day of the week will be read as one of the following pairs of character values , which are stored in two variables of type char : Mo Tu .

Su Be sure to allow the user to use either uppercase or lowercase letters or combination of the two .
The number of minutes will be input as value of type int .

The roots of quadratic equation + bx + is not are given by the formula Programming Projects The value of the discriminant determines the nature of roots .

If the value of the discriminant is zero , then the equation has single real root .
If the value of the discriminant is positive then the equation has two real roots .
If the value of the discriminant is negative , then the equation has two complex roots .

The program takes values of , and as and outputs the roots .
Be creative in how you output complex roots .
Include loop that allows the user to repeat this calculation for new values until the user says she or he wants to end the program .

Write program that accepts year written as Arabic numeral and outputs the year written in Roman numerals .
Important Roman numerals are for , for , for , for , for , and for .
Recall that some numbers are formed by using kind of subtraction of one Roman ; for example , IV is produced as minus , XL is , CM is , and so on .
few sample years : MCM is , MCML is , MCMLX is , MCMXL is , MCMLXXXIX is .
Assume the year is between and .
Your program should include loop that lets the user repeat this calculation until the user says she or he is done .

Write program that scores blackjack hand .
In blackjack , player receives from two to five cards .
The cards through are scored as through points each .
The face , queen , and scored as points .
The goal is to come as close to score of as possible without going over .
Hence , any score over is called " The ace can count as either or , whichever is better for the user .
For example , an ace and can be scored as either or .
Since is better score , this hand is scored as .
An ace and two can be scored as either or .

Since is " score , this hand is scored as .

The user is asked how many cards she or he has , and the user responds with one of the integers , or .
The user is then asked for the card values .
Card values are through , jack , queen , king , and ace .
good way to handle is to use the type char so that the card , for example , is read as the character , rather than as the number .
Input the values through as the characters ' through .
Input the values , jack , queen , king , and ace as the characters , and .

After reading in the values , the program should convert them from character values to numeric card scores , taking special care for aces .
The output is either number between and or the word Busted .
You are likely to have one or more long multiway branches that use switch statement or nested statement .
Your program should include loop that lets the user repeat this calculation until the user says she or he is done .

Chapter More Flow of Control Interest on loan is paid on declining balance , and hence loan with an interest rate of , say , percent can cost significantly less than percent of the balance .
Write program that takes loan amount and interest rate as and then outputs the monthly payments and balance of the loan until the loan is paid off .
Assume that the monthly payments are onetwentieth of the original loan amount , and that any amount in excess of the interest is credited toward decreasing the balance due .
Thus , on loan of , the payments would be month .
If the interest rate is percent , then each month the interest is of percent of the remaining balance .
The first month , percent of , or , would be paid in interest , and the remaining would decrease the balance to .
The following month the interest would be percent of , and so forth .
Also have the program output the total interest paid over the life of the loan .

Finally , determine what simple annualized percentage of the original loan balance was paid in interest .
For example , if was paid in interest on loan and it took years to pay off , then the annualized interest is , which is percent of the loan amount .
Your program should allow the user to repeat this calculation as often as desired .

The Fibonacci numbers Fn are defined as follows .

In other words , each number is the sum of the previous two numbers .
The first few Fibonacci numbers are , and .
One place that these numbers occur is as certain population growth rates .
If population has no deaths , then the series shows the size of the population after each time period .
It takes an organism two time periods to mature to reproducing age , and then the organism reproduces once every time period .
The formula applies most straightforwardly to asexual reproduction at rate of one offspring per time period .

Assume that the green crud population grows at this rate and has time period of days .
Hence , if green crud population starts out as pounds of crud , then in days there is still pounds of crud ; in days there is pounds of crud , in days pounds , in days pounds , and so forth .

Write program that takes both the initial size of green crud population and number of days as  and that outputs the number of pounds of green crud after that many days .
Assume that the population size is the same for days and then increases every fifth day .
Your program should allow the user to repeat this calculation as often as desired .

The value can be approximated by the sum +

The program should also output calculated using the predefined function exp .
The function exp is predefined function such that returns an approximation to the value ex .
The function exp is in the library with the header file cmath .
Your program should repeat the calculation for new of until the user says she or he is through .

Use variables of type double to store the factorials or you are likely to produce integer overflow arrange your calculation to avoid any direct calculation of .

Output the output in format that will fit all on the screen .
For example , you might output lines with on each line .

An approximate value of can be calculated using the series given below : + +
The program takes an that determines the number of terms in the approximation of the value of and outputs the approximation .

Include loop that allows the user to repeat this calculation for new until the user says she or he wants to end the program .

The following problem is sometimes called Monty Hall Game Show " You are contestant on game show and have won shot at the grand prize .
Before you are three closed doors .
Behind one door is brand new .
Behind the other two doors are consolation prizes .
The location of the prizes is randomly selected .
The game show host asks you to select door , and you pick one .
However , before revealing the contents behind your door , the game show host reveals one of the other doors with consolation prize .

At this point , the game show host asks if you would like to stick with your original choice or switch your choice to the other closed door .
What choice should you make to optimize your chances of winning the .
Does it matter whether you stick with your original choice or switch doors .

Write simulation program to solve the game show problem .
Your program should make simulated runs through the problem , randomly selecting locations for the prize , and then counting the number of times the was won when sticking with the original choice , and counting the number of times the was won when switching doors .
Output the estimated probability of winning for both strategies .
Be sure that your program exactly simulates the process of selecting the door , revealing one , and then switching .
Do not make assumptions about the actual solution example , simply assuming that there is or chance of getting the .

Appendix gives library functions for generating random numbers .
more detailed description is provided in Chapter .

VideoNote Solution to Programming Project Chapter More Flow of Control Repeat Programming Project from Chapter but in addition ask the user if he or she is :
Sedentary If the user answers " then increase the calculated by percent .
If the user answers " then increase the calculated by percent .
If the user answers " then increase the VideoNote Solution to Programming Project .
The keypad on your oven is used to enter the desired baking temperature and is arranged like the digits on phone :

In other words , the digits , and do not work .

If recipe calls for temperature that be entered , then you would like to substitute temperature that can be entered .
Write program that inputs desired temperature .
The temperature must be between and degrees .
If the desired temperature does not contain , or , then output the desired temperature .
Otherwise , compute the next largest and the next smallest temperature that does not contain , or and output both .

For example , if the desired temperature is , then the program should output and .
Similarly , if the desired temperature is , then the program should output and .

The game of " is game that begins with pile of toothpicks .
Players take turns , withdrawing either , or toothpicks at time .

The player to withdraw the last toothpick loses the game .
Write human vs .

The human should always move first .

When it is the turn , it should play according to the following .

If there are more than toothpicks left , then the computer should withdraw toothpicks , where is the number of toothpicks the human withdrew on the previous turn .

If there are to toothpicks left , then the computer should withdraw enough toothpicks to leave .

If there is toothpick left , then the computer has to take it and loses .

When the human player enters the number of toothpicks to withdraw , the program should perform input validation .
Make sure that the entered number is between and and that the player is not trying to withdraw more toothpicks than exist in the pile .

Holy digits Batman .
The Riddler is planning his next caper somewhere on Pennsylvania Avenue .
In his usual sporting fashion , he has left the address in the form of puzzle .
The address on Pennsylvania is number .

All four digits are different The digit in the thousands place is three times the digit in the tens place The number is odd The sum of the digits is Write program that uses loop to find the address where the Riddler plans to strike .

Jonathan Swift , Travels Introduction program can be thought of as consisting of subparts , such as obtaining the input data , calculating the output data , and displaying the output data .
, like most programming languages , has facilities to name and code each of these subparts separately .

In this chapter we present the basic syntax for one of the two main kinds of those designed to compute single value .
We also discuss how these functions can aid in program design .
We begin with discussion of fundamental design principle .

Prerequisites You should read Chapter and at least look through Chapter before reading this chapter .

As we noted in Chapter , this set of instructions is called an algorithm .
good plan of attack for designing the algorithm is to break down the task to be accomplished into few subtasks , decompose each of these subtasks into smaller subtasks , and so forth .
Eventually , the subtasks become so small that they are trivial to implement in .
This is called design .

Preserving this structure in your program makes the program easier to understand , easier to change if need be , and , as will become apparent , easier to write , test , and debug .
, like most programming languages , has facilities to include separate subparts inside of program .
In other programming languages these subparts are called subprograms , procedures , or methods .

Additionally , dividing the task allows different people to work on the different subtasks .
When producing very large program , such as compiler or system , this sort of teamwork is needed if the program is to be produced in reasonable amount of time .
We will begin our discussion of functions by showing you how to use functions that were written by somebody else .

Before we show you how to define functions , we will first show you how to use some functions that are already defined for you .

Using Predefined Functions We will use the sqrt function to illustrate how you use predefined functions .

The sqrt function calculates the square root of number .
The value the function starts out with is called its argument .

The value it computes is called the value returned .
Some functions may have more than one argument , but no function has more than one value returned .
If you think of the function as being similar to small program , then the arguments are analogous to the input and the value returned is analogous to the output .

The syntax for using functions in your program is simple .
To set variable named equal to the square root of , you can use the following assignment statement : The expression is called function call if you want to be fancy you can also call it function .
An argument in function call can be constant , such as , or variable , or more complicated expression .
function call is an expression that can be used like any other expression .
You can use function call wherever it is legal to use an expression of the type specified for the value returned by the function .
For example , the value returned by sqrt is of type double .
Thus , the following is legal perhaps : sales and are variables that would normally be of type double .
The function call is single item , just as if it were enclosed in parentheses .
Thus , this assignment statement is equivalent to .

The program computes the size of the largest square dog house that can be built for the amount of money the user willing to spend .
The program asks the user for an amount of money and then determines how many square feet of floor space can be purchased for that amount of money .

That calculation yields an area in square feet for the floor area of the dog house .
The function sqrt yields the length of one side of the dog house floor .

Notice that there another new in the program in Display : Function Call function call an expression consisting of the function name followed by arguments enclosed in parentheses .
If there more than one argument , the arguments are separated by commas .
function call an expression that can be used like any other expression of the type specified for the value returned by the function .

Syntax where the list of .

As we noted in Chapter , such lines are called directives .
The name inside the angular brackets the name of file known as header file .
header file for library provides Predefined Functions Display Function Call .

Sample Dialogue Enter the amount budgeted for your dog house : For price of can build you luxurious square dog house that feet on each .

This enables the linker to find object code for the functions in the library so that it can correctly link the library to your program .
For example , the library iostream contains the definitions of cin and  and the header file for the iostream library called iostream .

The math library contains the definition of the function sqrt and number of other mathematical functions , and the header file for this library cmath .
If your program uses predefined function from some library , then it must contain directive that names the header file for that library , such as the following :

Be sure to follow the syntax illustrated in our examples .
Do not forget the symbols and ; they are the same symbols as the and symbols .
There should be no space between the and the filename , nor between the filename and the .
Also , some compilers require that directives have no spaces around the , so it always safest to place the at the very start of the line and not to put any space between the and the word .
These directives are normally placed at the beginning of the file containing your program .

As we noted before , the directive .

This because the definitions of names like cin and  which are given in iostream , define those names to be part of the std namespace .

If you have an directive for standard library such as .

There no need to use multiple copies of this using directive when you have multiple directives .

Usually , all you need to do to use library to place an directive and using directive for that library in the file with your program .
If things work with just the directive and the using directive , you need not worry about doing anything else .
However , for some libraries on some systems , you may need to give additional instructions to the compiler or to explicitly run linker program to link in the library .
Early and compilers did not automatically search all libraries for linking .
The details vary from one system to another , so you will have to check your manual or local expert to see exactly what is necessary .

Some people will tell you that directives are not processed by the compiler , but are processed by preprocessor .
right , but the difference is more of word game than anything that need concern you .

On almost all compilers the preprocessor is called automatically when you compile your program .

few predefined functions are described in Display ; more predefined functions are described in Appendix .
Notice that the absolute value functions abs and labs are in the library with header file cstdlib , so any program that uses either of these functions must contain the following directive :

Also notice that there are three absolute value functions .
If you want to produce the absolute value of number of type int , you use abs ; if you want to produce the absolute value of number of type long , you use labs ; and if you want to produce the absolute value of number of type double , you use fabs .
To complicate things even more , abs and labs are in the library with header file cstdlib , while fabs is in the library with header file cmath .
Recall that numbers with fraction after the decimal point , such as numbers of type double , are often called numbers .

Another example of predefined function is pow , which is in the library with header file cmath .
The function pow can be used to do exponentiation in .
For example , if you want to set variable equal to xy , you can use the following : Display Some Predefined Functions .

Description Type of Arguments Type of Value Returned Example Value Library Header sqrt .

Chapter Procedural Abstraction and Functions That Return Value .

The function pow always returns value of type double , not of type int .
Also notice that the function pow requires two arguments .
function can have any number of arguments .
Moreover , every argument position has specified type and the argument used in function call should be of that type .
In many cases , if you use an argument of the wrong type , then some automatic type conversion will be done for you by .
However , the results may not be what you intended .

When you call function , you should use arguments of the type specified for that function .
One exception to this caution is the automatic conversion of arguments from type int to type double .
In many situations , including calls to the function pow , you can safely use an argument of type int when an argument of type double is specified .

Many implementations of pow have restriction on what arguments can be used .
In these implementations , if the first argument to pow is negative , then the second argument must be whole number .
Since you probably have enough other things to worry about when learning to program , it might be easiest and safest to use pow only when the first argument is nonnegative .

Random Number Generation Random and pseudorandom numbers Games and simulation programs often require the generation of random numbers .
has predefined function to generate pseudorandom numbers .

pseudorandom number is one that appears to be random but is really determined by predictable formula .
For example , here is the formula for very simple pseudorandom number generator that specifies the ith random number based on the previously generated random number : VideoNote Random Number Generation set the initial "
The first time we fetch " number we compute with the formula : The second time we fetch " number we compute with : The third time we fetch " number we compute with : and so on .

This is why they are called pseudorandom .
This particular function would not be very good pseudorandom number generator because it would repeat numbers rather quickly .
The random number generator in varies depending upon the library implementation but uses the same basic idea as our simple generator with some enhancements to achieve random uniform distribution .

We can get different sequence of random numbers if we start with different seed value .
In the example , the seed always started at .
However , if the seed is initialized with number that changes , such as the time on the clock , then we will likely get different sequence of random numbers every time we run the program .

To seed random number generator use the predefined method srand .
It returns no value and takes as input an unsigned integer that is the initial seed value .
To always seed the random number generator with the value , we would use : To vary the random number sequence every time the program is executed , we can seed the random number generator with the time of day .
Invoking the predefined function returns the number of seconds that have elapsed since January , on most systems .
The time function requires you to the ctime library .

We can get random number by calling the function rand , which will return an integer in the range to .
is constant defined in cstdlib and is guaranteed to be or higher .
Usually , number between and is not what is desired , in which case the random number can be scaled by modulus and addition .
For example , to simulate rolling sixsided we could use the following : int + The random number modulo gives us number between and .
Adding results in random integer that is in the range from to .

It is important to seed the random number generator only once .
common error is to invoke srand every time random number is generated .
If both srand and rand are placed in loop , then the likely is sequence of identical numbers , because the computer runs quickly enough that the time value will probably not change for repeated calls to srand .

The number of seconds elapsed since January , is known as Unix time .

Chapter Procedural Abstraction and Functions That Return Value Type Casting Division may require the type double Recall that is integer division and evaluates to , not .
If you want division to produce an answer of type double is , including the fractional part after the decimal , then at least one of the two numbers in the division must be of type double .
For example , evaluates to .
If one of the two numbers is given as constant , you can simply add decimal point and zero to one numbers , and the division will then produce value that includes the digits after the decimal point .

But what if both of the operands in division are variables , as in the following .

It does not matter how the program does ; Unless you convert the value in one of the variables or to value of type double , then the result of the division will be , not as it should be .
The fact that the variable is of type double does not help .
The value of obtained by division will be converted to value of type double before it is stored in the variable  but that will be too late .
The will be converted to and the final value of will be , not .
If one of the quantities in the division were constant , you could add decimal point and zero to convert the constant to type double , but in this case both quantities are variables .
Fortunately , there is way to convert from type int to type double that you can use with either constant or variable .

In you can tell the computer to convert value of type int to value of type double .
The way that you write the value to value of type double " is The notation is kind of predefined function that converts value of some other type , such as , to value of type double , in this case .
An expression such as is called type cast .
You can use variable or other expression in place of the .
You can use other type names besides double to obtain type cast to some type other than double , but we will postpone that topic until later .

For example , in the following we use type cast to change the type of from int to double and so the value of is set to : double 

You can use instead of when you want to convert to value of type double .
However , if the division involves only variables , then type casting may be your only sensible alternative .
Using type casting , we can rewrite our earlier example so that the variable receives the correct value of , instead of ; in order to do this , the only change we need is the replacement of with , as shown in what follows : int , double  program somehow sets the value of to and the value of to .

It does not matter how the program does ; Notice the placement of parentheses in the type casting used in the code .

You want to do the type casting before the division so that the division operator is working on value of type double .
If you wait until after the division is completed , then the digits after the decimal point are already lost .

If you mistakenly use the following for the last line of the previous code , then the value of will be , not .

Function to Convert from int to double The notation can be used as predefined function and will convert value of some other type to value of type double .
For example , returns .
This is called type casting .

Chapter Procedural Abstraction and Functions That Return Value Older Form of Type Casting double used as function The use of , as we discussed in the previous section , is the preferred way to perform type cast .
However , older versions of used different notation for type casting .
This older notation simply uses the type name as if it were function name , so returns .
Thus , if is variable of type double , and if both and are variables of type int , then the following two assignment statements are equivalent :

Pitfall Integer Division Drops the Fractional Part In integer division , such as computing , it is easy to forget that gives .

The fractional part is not generated .
Observe that the fact that is of type double does not change the division result .
The variable receives the value , not .

Convert each of the following mathematical expressions to arithmetic expression : + xy + time + tide nobody + area + fudge .
Write complete program to compute and output the square root of PI ; PI is approximately .
The const double PI is predefined in cmath .
You are encouraged to use this predefined constant .

Write and compile short programs to test the following issues : whether your compiler will allow the anywhere on the line , or if the needs to be flush with the left margin .

My Uncle , The Tailor In the previous section we told you how to use predefined functions .
In this section we tell you how to define your own functions .

Function Definitions You can define your own functions , either in the same file as the main part of your program or in separate file so that the functions can be used by several different programs .
The definition is the same in either case , but for now , we will assume that the function definition will be in the same file as the main part of your program .

Display contains sample function definition in complete program that demonstrates call to the function .
The function is called .

The function takes two price for one item and number of items for purchase .
The function returns the total cost , including sales tax , for that many items at the specified price .
The function is called in the same way predefined function is called .
The description of the function , which the programmer must write , is bit more complicated .

The description of the function is given in two parts that are called the function declaration and the function definition .
The function declaration known as the function describes how the function is called .
requires that either the complete function definition .

Chapter Procedural Abstraction and Functions That Return Value Display Function Definition .

Sample Dialogue Enter the number of items purchased : Enter the price per item : items at each .

Final  including tax , is function body function definition Functions or the function declaration appears in the code before the function is called .

The function declaration for the function is in color at the top of Display and is reproduced here : double , double ; The function declaration tells you everything you need to know in order to write call to the function .
It tells you the name of the function , in this case .
It tells you how many arguments the function needs and what type the arguments should be ; in this case , the function takes two arguments , the first one of type int and the second one of type double .

The identifiers and are called formal parameters .
formal parameter is used as kind of blank , or place holder , to stand in for the argument .
When you write function declaration , you do not know what the arguments will be , so you use the formal parameters in place of the arguments .
The names of the formal parameters can be any valid identifiers , but for while we will end our formal parameter names with so that it will be easier for us to distinguish them from other items in program .
Notice that function declaration ends with semicolon .

The first word in function declaration specifies the type of the value returned by the function .
Thus , for the function , the type of the value returned is double .

As you can see , the function call in Display satisfies all the requirements given by its function declaration .
take look .
The function call is in the following line : The function call is the expression on the side of the equal sign .
The function name is , and there are two arguments : The first argument is of type int , the second argument is of type double , and since the variable is of type double , it looks like the function returns value of type double it .
All that detail is determined by the function declaration .

The compiler does not care whether comment along with the function declaration , but you should always comment that explains what value is returned by the function .

Function Declaration function declaration tells you all you need to know to write call to the function .
function declaration is required to appear in your code prior to call to function whose definition has not yet appeared .

Function declarations are normally placed before the main part of your program .

; Do not forget this semicolon .

In Display the function definition is in color at the bottom of the display .
function definition describes how the function computes the value it returns .
If you think of function as small program within your program , then the function definition is like the code for this small program .
In fact , the syntax for the definition of function is very much like the syntax for the main part of program .
function definition consists of function header followed by function body .
The function header is written the same way as the function declaration , except that the header does not have semicolon at the end .
This makes the header bit repetitious , but OK .

Although the function declaration tells you all you need to know to write function call , it does not tell you what value will be returned .
The value returned is determined by the statements in the function body .
The function body follows the function header and completes the function definition .
The function body consists of declarations and executable statements enclosed within pair of braces .
Thus , the function body is just like the body of the main part of program .
When the function is called , the argument values are plugged in for the formal parameters and then the statements in the body are executed .
The value returned by the function is determined when the function executes return statement .
The function definition in Display contains the following return statement : return + When this return statement is executed , the value of the following expression is returned as the value of the function call : Functions .

For consistency , some programmers advocate using these parentheses even on simple expressions .
In the function definition in Display , there are no statements after the return statement , but if there were , they would not be executed .
When return statement is executed , the function call ends .

Function Is Like Small Program To understand functions , keep the following three points in mind : function definition is like small program and calling the function is the function uses formal parameters , rather than cin , for input .
The arguments to the function are the input and they are plugged in for the formal parameters .

The function returns value , which is like the " for the function .
The function uses return statement instead of cout statement for see exactly what happens when the following function call is executed in the program shown in Display : First , the values of the arguments number and price are plugged in for the formal parameters ; that is , the values of the arguments number and price are substituted in for and .
In the Sample Dialogue , number receives the value and price receives the value .

This substitution process is known as the mechanism , and the formal parameters are often referred to as formal parameters , or simply as parameters .
There are three things that you should note about this substitution process :
It is the values of the arguments that are plugged in for the formal parameters .
If the arguments are variables , the values of the variables , not the variables themselves , are plugged in .

The first argument is plugged in for the first formal parameter in the parameter list , the second argument is plugged in for the second formal parameter in the list , and so forth .

Chapter Procedural Abstraction and Functions That Return Value .
When an argument is plugged in for formal parameter instance , when is plugged in for , the argument is plugged in for all instances of the formal parameter that occur in the function body instance , is plugged in for each time it appears in the function .

The entire process involved in the function call shown in Display is described in detail in Display .

Display Details of Function Call .

Before the function is called , values of the variables number and price are set to and , by cin statements you can see the Sample Dialogue in .
The function call executes and the value , of number is plugged in for and value of price ; is plugged in for .

When the return statement is executed , the value of the expression after return is evaluated and returned by the function .

The value is returned to where the function was invoked .
The result is that , is replaced by the return value of .
The value of the side of the equal is set equal to when the statement , finally ends .

Functions That Return Boolean Value function may return bool value .
Such function can be used in Boolean expression to control an statement or to control loop statement , or it can be used anywhere else that Boolean expression is allowed .
The returned type for such function should be the type bool .

call to function that returns Boolean value of true or false can be used anywhere that Boolean expression is allowed .
This can often make program easier to read .
By means of function declaration , you can associate complex Boolean expression with meaningful name and use the name as Boolean expression in an statement or anywhere else that Boolean expression is allowed .
For example , the statement .

The following two function declarations are equivalent : double , double .

We will always use the first form so that we can refer to the formal parameters in the comment that accompanies the function declaration .
However , you will often see the second form in manuals that describe All needs to link to your program to the library for your function is the function name and sequence of types of the formal parameters .
The formal parameter names are important only to the function definition .
However , programs should communicate to programmers as well as to compilers .
It is frequently very helpful in understanding function to use the name that the programmer attaches to the data .

Chapter Procedural Abstraction and Functions That Return Value This alternate form applies only to function declarations .
Function headers must always list the formal parameter names .

Pitfall Arguments in the Wrong Order When function is called , the computer substitutes the first argument for the first formal parameter , the second argument for the second formal parameter , and so forth .
It does not check for reasonableness .
If you confuse the order of the arguments in function call , the program will not do what you want it to do .
In order to see what can go wrong , consider the program in Display .

The programmer who wrote that program carelessly reversed the order of the arguments in the call to the function grade .
The function call should have been , This is the only mistake in the program .
Yet , some poor student has been mistakenly failed in course because of this careless mistake .
The function grade is so simple that you might expect this mistake to be discovered by the programmer when the program is tested .
However , if grade were more complicated function , the mistake might easily go unnoticed .

If the type of an argument does not match the formal parameter , then the compiler may give you warning message .
Unfortunately , not all compilers will give such warning messages .
Moreover , in situation like the one in .

Sample Dialogue Enter your score and the minimum needed to pass : You received score of Minimum to pass Sorry .

will be entered in your record .

Display , no compiler will complain about the ordering of the arguments , because the function argument types will match the formal parameter types no matter what order the arguments are in .

Display gives summary of the syntax for function declaration and definition .
There actually bit more freedom than that display indicates .
The declarations and executable statements in the function definition can be intermixed , as VideoNote Function Example .

Chapter Procedural Abstraction and Functions That Return Value Spacing and line breaks long as each variable declared before it used .
The rules about intermixing declarations and executable statements in function definition are the same as they are for the main part of program .
However , unless you have reason to do otherwise , it best to place the declarations first , as indicated in Display .

Since function does not return value until it executes return statement , function must contain one or more return statements in the body of the function .
function definition may contain more than one return statement .
For example , the body of the code might contain an statement , and each branch of the statement might contain different return statement , as illustrated in Display .

Any reasonable pattern of spaces and line breaks in function definition will be accepted by the compiler .
However , you should use the same rules for indenting and laying out function definition as you use for the main part of program .
In particular , notice the placement of braces in our function definitions and in Display .
The opening and closing braces that mark the ends of the function body are each placed on line by themselves .

More About Placement of Function Definitions We have discussed where function definitions and function declarations are normally placed .
Under normal circumstances these are the best locations for the function declarations and function definitions .
However , the compiler will accept programs with the function definitions and function declarations in certain other locations .
more precise statement of the rules as follows : Display Syntax for Function That Returns Value Function Declaration ;

Functions Each function call must be preceded by either function declaration for that function or the definition of the function .
For example , if you place all of your function definitions before the main part of the program , then you need not include any function declarations .
Knowing this more general rule will help you to understand programs you see in some other books , but you should follow the example of the programs in this book .
The style we are using sets the stage for learning how to build your own libraries of functions , which the style that most programmers use .

However , doing so can make the switch statement or statement difficult to read .
Look at the switch statement in Display .
Each of the branches for choices , and could be single function call .
This makes the layout of the switch statement and the overall structure of the program clear .
If we had instead placed all the code for each branch in the switch statement , instead of in the function definitions , then the switch statement would be an incomprehensible sea of statements .
In fact , the switch statement would not even fit on one screen .

Chapter Procedural Abstraction and Functions That Return Value .
Write function declaration and function definition for function that takes three arguments , all of type int , and that returns the sum of its three arguments .

Write function declaration and function definition for function that takes one argument of type int and one argument of type double , and that returns value of type double that is the average of the two arguments .

Write function declaration and function definition for function that takes one argument of type double .
The function returns the character value ' if its argument is positive and returns ' if its argument is zero or negative .

Carefully describe the parameter mechanism .

List the similarities and differences between use of predefined is , function and function .

Write function definition for function called that takes three arguments of type int .
The function returns true if the three arguments are in ascending order ; otherwise , it returns false .
For example , and , both return true , while , returns false .

Write function definition for function called even that takes one argument of type int and returns bool value .
The function returns true if its one argument is an even number ; otherwise , it returns false .

Write function definition for function that takes one argument of type char and returns bool value .
The function returns true if the argument is decimal digit ; otherwise , it returns false .

Write function definition for function that takes two arguments of type int and returns bool value .
The function returns true if the first argument is the square root of the second ; otherwise , it returns false .

OVID , Metamorphoses iv The Analogy person who uses program should not need to know the details of how the program is coded .
Imagine how miserable your life would be if you had Procedural Abstraction to know and remember the code for the compiler you use .
program has job to do , such as compile your program or check the spelling of words in your paper .
You need to know what the job is so that you can use the program , but you do not at least should need to know how the program does its job .
function is like small program and should be used in similar way .
programmer who uses function in program needs to know what the function does as calculate square root or convert temperature from degrees Fahrenheit to degrees but should not need to know how the function accomplishes its task .
This is often referred to as treating the function like black box .

Calling something black box is figure of speech intended to convey the image of physical device that you know how to use but whose method of operation is  because it is enclosed in black box and you cannot see inside the box cannot pry it .
If function is well designed , the programmer can use the function as if it were black box .
All the programmer needs to know is that if he or she puts appropriate arguments into the black box , then an appropriate returned value will come out of the black box .

Designing function so that it can be used as black box is sometimes called information hiding to emphasize that the programmer acts as if the body of the function were hidden from view .

Display contains the function declaration and two different definitions for function named .
As the function declaration comment explains , the function calculates the new in bank account when simple interest is added .
For instance , if an account starts with , and percent interest is posted to the account , then the new is .
Hence , the following code will change the value of from to : It does not matter which of the implementations of shown in Display that programmer uses .
The two definitions produce functions that return exactly the same values .
We may as well place black box over the body of the function definition so that the programmer does not know which implementation is being used .
In order to use the function  all the programmer needs to read is the function declaration and the accompanying comment .

Writing and using functions as if they were black boxes is also called procedural abstraction .
When programming in it might make more sense to call it functional abstraction .
However , procedure is more general term .

Chapter Procedural Abstraction and Functions That Return Value Display Definitions That Are Equivalent Function Declaration .

The three terms mean the same thing .
Whatever you call this principle , the important point is that you should use it when designing and writing your function definitions .

Procedural Abstraction When applied to function definition , the principle of procedural abstraction means that your function should be written so that it can be used like black box .
This means that the programmer who uses the function should not need to look at the body of the function definition Procedural Abstraction to see how the function works .
The function declaration and the accompanying comment should be all the programmer needs to know in order to use the function .
To ensure that your function definitions have this important property , you should strictly adhere to the following rules : How to Write Function Definition Returns The function declaration comment should tell the programmer any and all conditions that are required of the arguments to the function and should describe the value that is returned by the function when called with these arguments .

On large programming projects , different programmer may be assigned to write each function .
The programmer should choose the most meaningful names he or she can find for formal parameters .
The arguments that will be substituted for the formal parameters may well be variables in the main part of the program .
These variables should also be given meaningful names , often chosen by someone other than the programmer who writes the function definition .
This makes it likely that some or all arguments will have the same names as some of the formal parameters .
This is perfectly acceptable .
No matter what names are chosen for the variables that will be used as arguments , these names will not produce any confusion with the names used for formal parameters .
After all , the functions will use only the values of the arguments .

When you use variable as function argument , the function takes only the value of the variable and disregards the variable name .

Now that you know you have complete freedom in choosing formal parameter names , we will stop placing " at the end of each formal parameter name .
For example , in Display we have rewritten the definition for the function from Display so that the formal parameters are named number and price rather than and .
If you replace the function declaration and definition of the function that appear in Display with the versions in Display , then the program will perform in exactly the same way , even though there will be formal parameters named number and price and there will be variables in the main part of the program that are also named number and price .

Chapter Procedural Abstraction and Functions That Return Value Display Simpler Formal Parameter Names Function Declaration .

Function Definition .

Consider the explicitly nested loops in Display that computed the total number of vulture eggs counted by all conservationists .
We can make this code more readable by moving the loops into procedure calls , as shown in Display .

The two versions of our program for totaling vulture eggs are equivalent .
Both programs produce the same dialogue with the user .

However , most people find the version in Display easier to understand because the loop body is function call .
When considering the outer loop , you should think of computing the for one report as single operation and not think of it as loop .

This way you can separate the design of the loop body from the design of the rest of the program .
This divides your programming task into two smaller subtasks .

Chapter Procedural Abstraction and Functions That Return Value .

Sample Dialogue This program tallies conservationist on the vulture .

Each report consists of list of numbers .
Each is the of the eggs observed in one vulture nest .

This program then tallies the of eggs .

Place negative integer at the end of your list .

Place negative integer at the end of your list .

This is particularly true when buying pizzas .
Pizza sizes are given as the diameter of the pizza in inches .
However , the quantity of pizza is determined by the area of the pizza , and the area is not proportional to the diameter .
Most people cannot easily estimate the difference in area between pizza and pizza and so cannot easily determine which size is the best is , which size has the lowest price per square inch .
In this case study we will design program that compares two sizes of pizza to determine which is the better buy .

Problem Definition The precise specification of the program input and output are as follows : Input The input will consist of the diameter in inches and the price for each of two sizes of pizza .

Output The output will give the cost per square inch for each of the two sizes of pizza and will tell which is the better buy , that is , which has the lowest cost per square inch .

Subtask : Compute the price per square inch for the small pizza .

Subtask : Compute the price per square inch for the large pizza .

Subtask : Determine which is the better buy .

Subtask : Output the results .

Notice subtasks and .
They have two important properties : Subtasks and .

Chapter Procedural Abstraction and Functions That Return Value .
They are exactly the same task .
The only difference is that they use different data to do the computation .
The only things that change between subtask and subtask are the size of the pizza and its price .

The result of subtask and the result of subtask are each single value : the price per square inch of the pizza .

When to define function Whenever subtask takes some values , such as some numbers , and returns single value , it is natural to implement the subtask as function .

Whenever two or more such subtasks perform the same computation , they can be implemented as the same function called with different arguments each time it is used .
We therefore decide to use function called unitprice to compute the price per square inch of pizza .
The function declaration and explanatory comment for this function will be as follows : double diameter , double ; the price per square inch of pizza .
The formal named diameter is the diameter of the pizza in .
The formal parameter named price is the price of pizza .

Subtasks and Subtasks and Subtask is straightforward .
The program will simply ask for the input values and store them in four variables , which we will call , and .

Subtask is routine .
To determine which pizza is the best buy , we just compare the cost per square inch of the two pizzas using the operator .
Subtask is routine output of the results .

Subtasks and are implemented as calls to the function unitprice .

Next , we design the algorithm for this function .
The hard part of the algorithm is determining the area of the pizza .
Once we know the area , we can easily determine the price per square inch using division , as follows : where area is variable that holds the area of the pizza .
This expression will be the value returned by the function unitprice .
But we still need to formulate method for computing the area of the pizza .

pizza is basically circle up of bread , cheese , sauce , and so .
The area of circle hence of is Ïr , where is the radius of the circle and is the number called " which is approximately equal to .
The radius is one half of the diameter .

The algorithm for the function unitprice can be outlined as follows : Algorithm Outline for the Function unitprice .
Compute the radius of the pizza .

Compute the area of the pizza using the formula Ïr .

Return the value of the expression .

We will express this more detailed version of our algorithm in pseudocode .
Pseudocode is mixture of and ordinary English .
Pseudocode allows us to make our algorithm precise without worrying about the details of syntax .
We can then easily translate our pseudocode into code .

In our pseudocode , and will be variables for holding the values indicated by their names .

Pseudocode for the Function unitprice .

Coding Coding subtask is routine , so we next consider subtasks and .
Our program can implement subtasks and by the following two calls to the .

One of the benefits of function definition is that you can have multiple calls to the function in your program .
This saves you the trouble of repeating the same almost the code .
But we still must write the code for the function unitprice .

When we translate our pseudocode into code , we obtain the following for the body of the function unitprice : draft of the function body for unitprice .

Yet , as written , this line contains serious mistake .
We want the division to produce the of the pizza including any fraction .

Chapter Procedural Abstraction and Functions That Return Value For example , if we are considering buying the luck " which is pizza , then the is inches .
But the variable diameter is of type int .

Thus , as we saw in Chapter , this line would perform integer division and would compute the to be instead of the correct value of , and we would have disregarded half inch of pizza .
In all likelihood , this would go unnoticed , but the result could be that millions of subscribers to the Pizza Consumers Union could be wasting their money by buying the wrong size pizza .
This is not likely to produce major worldwide recession , but the program would be failing to accomplish its goal of helping consumers find the best buy .
In more important program , the result of such simple mistake could be disastrous .

How do we fix this mistake .
We want the division by to be regular division that includes any fractional part in the answer .
That form of division requires that at least one of the arguments to the division operator must be of type double .
We can use type casting to convert the constant to value of type double .
Recall that , which is called type casting , converts the int value to value of type double .
Thus , if we replace by , that will change the second argument in the division from type int to type double , and the division will then produce the result we want .
The rewritten assignment statement is ; The complete corrected code for the function definition of unitprice , along with the rest of the program , is shown in Display .

The type cast returns the value , so we could have used the constant in place of .
Either way , the function unitprice will return the same value .
However , by using , we make it conspicuously obvious that we want to do the version of division that includes the fractional part in its answer .
If we instead used , then when revising or copying the code , we can easily make the mistake of changing to , and that would produce subtle problem .

We need to make one more remark about the coding of our program .

As you can see in Display , when we coded tasks and , we combined these two tasks into single section of code consisting of sequence of cout statements followed by an statement .
When two tasks are very simple and are closely related , it sometimes makes sense to combine them into single task .

Program Testing Just because program compiles and produces answers that look right does not mean the program is correct .
In order to increase your confidence in your program , you should test it on some input values for which you know the correct answer by some other means , such as working out the answer with paper and pencil or by using handheld calculator .
For example , it does not make sense to buy pizza , but it can still be used as Procedural Abstraction .

Chapter Procedural Abstraction and Functions That Return Value .

Sample Dialogue Welcome to the Pizza Consumers Union .

Enter diameter of small pizza : Enter the price of small pizza : Enter diameter of large pizza : Enter the price of large pizza : Small pizza : inches Per square Large pizza : inches Per square The small one is the better buy .

It is an easy test case because it is easy to compute the answer by hand .
calculate the cost per square of pizza that sells for .
Since the diameter is inches , the is .

If we divide this into the price of , we find that the price per square is , which is approximately .
Of course , this is an absurd size for pizza and an absurd price for such small pizza , but it is easy to determine the value that the function unitprice should return for these arguments .

Having checked your program on this one case , you can have more confidence in it , but you still cannot be certain your program is correct .

An incorrect program can sometimes give the correct answer , even though it will give incorrect answers on some other inputs .
You may have Procedural Abstraction tested an incorrect program on one of the cases for which the program happens to give the correct output .
For example , suppose we had not caught the mistake we discovered when coding the function unitprice .

Suppose we mistakenly used instead of in the following .

As long as the pizza diameter is an even number , like , or , the program gives the same answer whether we divide by or by .
It is unlikely that it would occur to you to be sure to check both and pizzas .
However , if you test your program on several different pizza sizes , then there is better chance that your test cases will contain samples of the relevant kinds of data .

Pseudocode is mixture of whatever programming language you are and ordinary English whatever human language you are .
Pseudocode allows you to state your algorithm precisely without having to worrying about all the details of syntax .
When the code for step in your algorithm is obvious , there is little point in stating it in English .
When step is difficult to express in , the algorithm will be clearer if the step is expressed in English .
You can see an example of pseudocode in the previous case study , where we expressed our algorithm for the function unitprice in pseudocode .

What is the purpose of the comment that accompanies function declaration .

What is the principle of procedural abstraction as applied to function definitions .

What does it mean when we say the programmer who uses function should be able to treat the function like black box .
Carefully describe the process of program testing .

Chapter Procedural Abstraction and Functions That Return Value .
Consider two possible definitions for the function unitprice .
One is the definition given in Display .
The other definition is the same except that the type cast is replaced with the constant ; in other words , the line .

Are these two possible function definitions equivalent .

Common Saying In the last section we advocated using functions as if they were black boxes .

In order to define function so that it can be used as black box , you often need to give the function variables of its own that do not interfere with the rest of your program .
The variables that to " function are called local variables .
As we will see , these variables simply conform to the scope rule for nested blocks described in Chapter .
In this section we take another look at scoping with an emphasis on local variables and how to use them .

The Small Program Analogy Look back at the program in Display .
It includes call to the predefined function sqrt .
We did not need to know anything about the details of the function definition for sqrt in order to use this function .
In particular , we did not need to know what variables were declared in the definition of sqrt .

function that you define is no different .
Variable declarations in function definitions that you write are as separate as those in the function definitions for the predefined functions .
Variable declarations within function definition are the same as if they were variable declarations in another program .
If you declare variable in function definition and then declare another variable of the same name in the main part of your program in the body of some other function , then these two variables are two different variables , even though they have the same name .
look at program that does have variable in function definition with the same name as another variable in the program .

The program in Display has two variables named ; one is declared and used in the function definition for the function , and the other is declared and used in the main part of the program .
The variable Scope and Local Variables .

Chapter Procedural Abstraction and Functions That Return Value Sample Dialogue Enter minimum and maximum number of peas in  Enter the number of pods : Enter the of an average pea : Min number of peas per Max number of peas per Average pea ounces Estimated average ounces in the function definition for and the variable in the main part of the program are two different variables .
It is the same as if the function were predefined function .
The two variables named will not interfere with each other any more than two variables in two completely different programs would .
When the variable is given value in the function call to , this does not change the value of the variable in the main part of the program that is also named .
Variables that are defined within the main body of the program are said to be local to the main part of the program or to have the main part of the program as their scope .
There are other kinds of variables that are not local to any function or to the main part of the program , but we will have no use for such variables .
Every variable we will use is either local to function definition or local to the main part of the program .
When we say that variable is local variable without any mention of function and without any mention of the main part of the program , we mean that the variable is local to some function definition .

Local Variables Variables that are declared within the body of function definition are said to be local to that function or to have that function as their scope .
Variables that are declared within the main part of the program are said to be local to the main part of the program or to have the main part of the program as their scope .
When we say that variable is local variable without any mention of function and without any mention of the main part of the Scope and Local Variables program , we mean that the variable is local to some function definition .

If variable is local to function , then you can have another variable with the same name that is declared in the main part of the program or in another function definition , and these will be two different variables , even though they have the same name .

Programming Example Experimental Pea Patch The program in Display gives an estimate for the total on small garden plot used to raise an experimental variety of peas .
The function returns an estimate of the total number of peas harvested .
The function takes three arguments .
One argument is the number of pea pods that were harvested .
The other two arguments are used to estimate the average number of peas in .
Different pea pods contain differing numbers of peas , so the other two arguments to the function are the smallest and the largest number of peas that were found in any one .
The function averages these two numbers and uses this average as an estimate for the average number of peas in .

Global Constants and Global Variables As we noted in Chapter , you can and should name constant values using the const modifier .
For example , in Display we used the following declaration to give the name to the constant : const double .

This worked out fine because each named constant was used by only one function .
However , it can easily happen that more than one function uses named constant .
In that case you can place the declaration for naming constant at the beginning of your program , outside of the body of all the functions and outside the body of the main part of your program .
The named constant is then said to be global named constant and the named constant can be used in any function definition that follows the constant declaration .

Display shows program with an example of global named constant .
The program asks for radius and then computes both the area of .

Chapter Procedural Abstraction and Functions That Return Value the area of circle and the volume of sphere .

The programmer who wrote that program looked up the formulas for computing those quantities and found the following : Both formulas the constant , which is approximately equal to .
The symbol is the Greek letter called " In previous programs we have used the following declaration to produce named constant called to use when we convert such formulas to code : const double ; In the program in Display we use the same declaration but place it near the beginning of the file so that it defines global named constant that can be used in all the function bodies .

The compiler allows you wide latitude with regard to where you place the declarations for your global named constants , but to aid readability you should place all your directives together , all your global named constant declarations together in another group , and all your function declarations together .
We will follow standard practice and place all our global named constant declarations after our directives and before our function declarations .

Placing all named constant declarations at the start of your program can aid readability even if the named constant is used by only one function .
If the named constant might need to be changed in future version of your program , it will be easier to find if it is at the beginning of the program .

For example , placing the constant declaration for the sales tax rate at the beginning of an accounting program will make it easy to revise the program should the tax rate increase .

It is possible to declare ordinary variables , without the const modifier , as global variables , which are accessible to all function definitions in the file .
This is done the same way that it is done for global named constants , VideoNote Walkthrough of Functions and Local Variables Chapter Procedural Abstraction and Functions That Return Value except that the modifier const is not used in the variable declaration .

However , there is seldom any need to use such global variables .

Moreover , global variables can make program harder to understand and maintain , so we will not use any global variables .
Once you have had more experience designing programs , you may choose to occasionally use global variables .

Formal Parameters Are Local Variables Formal parameters are more than just blanks that are filled in with the argument values for the function .
Formal parameters are actually variables that are local to the function definition , so they can be used just like local variable that is declared in the function definition .
Earlier in this chapter we described the mechanism that handles the arguments in function call .
We can now define this mechanism for in arguments " in more detail .

When function is called , the formal parameters for the function are local are initialized to the values of the arguments .
This is the precise meaning of the phrase in for the formal parameters " that we have been using .
Typically , formal parameter is used only as kind of blank , or place holder , that is filled in by the value of its corresponding argument ; occasionally , however , formal parameter is used as variable whose value is changed .
In this section we will give one example of formal parameter used as local variable .

The program in Display is the billing program for the law offices of Dewey , Cheatham , and Howe .
Notice that , unlike other law firms , the firm of Dewey , Cheatham , and Howe does not charge for any time less than quarter of an hour .
That is why called law office with " If they work for hour and minutes , they only charge for quarter hours , not quarter hours as other firms do ; so you would pay only for the consultation .

Sample Dialogue Welcome to the offices of Dewey , Cheatham , and Howe .

The law office with heart .

Enter the hours and minutes of your consultation : For hours and minutes , your Notice the formal parameter in the definition of the function fee .
It used as variable and has its value changed by the following line , which occurs within the function definition : +  Formal parameters are local variables just like the variables you declare within the body of function .
However , you should not add variable Do not add declaration for formal parameter Chapter Procedural Abstraction and Functions That Return Value declaration for the formal parameters .
Listing the formal parameter worked in the function declaration also serves as the variable declaration .
The following the wrong way to start the function definition for fee as it declares .

Block Scope The scope of local variable refers to the part of program that can directly access that variable and sometimes referred to as local scope .
Similarly , global identifiers declared at the beginning of your program , outside of the body of all the functions , are sometimes referred to as having global scope .
Despite their differences , local and global identifiers are really examples of block scope described in Chapter .
block some code enclosed in braces , with the exception of the " which an implied outermost block that encompasses all code .
The scope rule states that identifiers declared within their block are local to that block and accessible only from the point they are defined to the end of their block .
Blocks are commonly nested .
For example , the braces of the main function defines block and for loop inside main defines nested block .

The program outlined in Display compute anything interesting but illustrates the scope of identifiers declared in different blocks .

In this example , the constant has global scope , along with the functions and main , because they are declared outside the body of all functions .
This allows us to access from both main and .

The main function declares the variables and that are local to main .
Their scope extends to the end of block .
Similarly , the function has parameter param and local variable that have scope extending to the end of .
Neither of these variables directly accessible from outside their scope .
The scope of local variables and parameters really uses the same rule of block scope , but in this case the block refers to the function in which the variables or parameters are declared .

The for loop in Display illustrates the scope of nested block .
The variable declared inside the for loop and thus only has scope to the end of the loop block .
Attempts to reference anywhere outside its scope , even if we are still inside main example , on line would result in compiler error .

You can think of variables as being created when their scope begins and destroyed when their scope ends .
For example , the local variable in Display created and initialized to every time called .

If code on line changed the value stored in , then these changes would be Scope and Local Variables Display Local , Global , and Block Scope Block Scope Revisited .

Block scope : Variable has scope from lines Local scope to main : Variable has scope from lines and variable has scope from lines .

Local to : Variable param has from lines and variable has from lines lost when the function exits and goes out of because the variable is destroyed .
repeat call to will not recall the previous value of  but rather new will be created .

In addition to block there is also namespace and class .

Class is discussed in Chapter and namespace in Chapter .

also defines function prototype  which refers to the line of for parameters defined in function prototype .
Finally , supports function  which is used for labels .
Labels are remnant from the language and are used with goto statements .
Their use is generally shunned because they can result in logic that is difficult to follow , whereas the same task can be performed by loops in an understandable fashion .

The constant has from lines and the function has from lines .

This will allow you to use two different namespaces in two different function definitions , even if the two function definitions are in the same file and even if the two namespaces have some with different meanings in the two different namespaces .

Placing using directive inside function definition is analogous to placing variable declaration inside function definition .
If you place variable definition inside function definition , the variable is local to the function ; that is , the meaning of the variable declaration is confined to the function definition .
If you place using directive inside function definition , the using directive is local to the function definition ; in other words , the meaning of the using directive is confined to the function definition .

It will be some time before we use any namespace other than std in using directive , but it will be good practice to start placing these using directives where they should go .
In Display we have rewritten the program in Display with the using directives where they should be placed .
The program in Display will behave exactly the same as the one in Display .
In this particular case , the difference is only one of style , but when you start to use more namespaces , the difference will affect how your programs perform .

Exerc ise .
If you use variable in function definition , where should you declare the variable .
In the function definition .
In the main part of the program .

Any place that is convenient .

Chapter Procedural Abstraction and Functions That Return Value .
Suppose function named has variable named sam declared within the definition of , and function named also has variable named sam declared within the definition of .

Will the program compile everything else is .
If the program will compile , will it run that everything else is .
If it runs , will it generate an error message when run everything else is .
If it runs and does not produce an error message when run , will it give the correct output everything else is .

The following function is supposed to take as arguments length expressed in feet and and return the total number of in that many feet and .
For example , is supposed to return , because foot and is the same as .

Write function declaration and function definition for function called that has no parameters and that returns value of type double .
The function prompts the user for value of type double and reads the value into local variable .
The function returns the value read provided this value is greater than or equal to zero and returns zero if the value read is negative .

Programming Example The Factorial Function Display contains the function declaration and definition for commonly used mathematical function known as the factorial function .
In mathematics texts , the factorial function is usually written .
In traditional mathematical notation , you can define .
Note that the multiplication is performed in the reverse order to what you might expect .
The program multiplies by  then , then , and so forth .

Function Definition .

The function definition for factorial uses two local variables :  which is declared at the start of the function body , and the formal parameter .
Since formal parameter is local variable , we can change its value .
In this case we change the value of the formal parameter with the decrement operator .
If the function factorial is called with as its argument , then the first time the loop body is executed the value of is , the next time the loop body is executed the value of is , the next time the value of is , and then the while loop ends .
Thus , the following will set the variable equal to which is : Notice that the local variable is initialized to the value when the variable is declared .
To see that this is the correct initial value for  note that after executing the body of the while loop the first time , we want the value of to be equal to the value of the formal parameter  if is initialized to , then this will be what happens .

Formal parameter used as local variable Chapter Procedural Abstraction and Functions That Return Value Overloading Function Names and that shows that there are three hundred and days when question " said Alice , you can make words mean so many Lewis Carroll , Through the allows you to give two or more different definitions to the same function name , which means you can reuse names that have strong intuitive appeal across variety of situations .
For example , you could have three functions called max : one that computes the largest of two numbers , another that computes the largest of three numbers , and yet another that computes the largest of four numbers .
When you give two function definitions for the same function name , that is called overloading the function name .

Overloading does require some extra care in defining your functions and should not be used unless it will add greatly to your readability .
But when it is appropriate , overloading can be very effective .

Introduction to Overloading Suppose you are writing program that requires you to compute the average .

This will work , and in many programming languages you have no choice but to do something like this .
Fortunately , allows for more elegant solution .
In you can simply use the same name ave for both functions ; you can use the following definition in place of the definition .

Display Overloading Function Name .

The average of , and is The average of and is three arguments .

Chapter Procedural Abstraction and Functions That Return Value Determining which definition applies The now has two definitions .
This is an example of overloading .
In this case we have overloaded the .
In Display we have embedded these two definitions for into complete sample program .
Be sure to notice that each definition has its own declaration .

Overloading is great idea .
It makes program easier to read , and it saves you from going crazy trying to think up new for just because you already used the most natural in some other definition .
But how does the compiler know which definition to use when it encounters call to that has two or more definitions .
The compiler cannot read mind .
In order to tell which definition to use , the compiler checks the number of arguments and the types of the arguments in the call .
In the program in Display , one of the functions called has two arguments and the other has three arguments .
To tell which definition to use , the compiler simply counts the number of arguments in the call .
If there are two arguments , it uses the first definition .
If there are three arguments , it uses the second definition .

Whenever you give two or more definitions to the same  the various definitions must have different specifications for their arguments ; that is , any two definitions that have the same must use different numbers of formal parameters or use formal parameters of different types .
Notice that when you overload  the declarations for the two different definitions must differ in their formal parameters .
You cannot overload by giving two definitions that differ only in the type of the value returned .

Overloading Function Name If you have two or more definitions for the same  that is called overloading .
When you overload  the definitions must have different numbers of formal parameters or some formal parameters of different types .
When there is call , the compiler uses the definition whose number of formal parameters and types of formal parameters match the arguments in the call .

You saw kind of overloading in Chapter with the division operator .
If both operands are of type int , as in , then the value returned is the result of integer division , in this case .

On the other hand , if one or both operands are of type double , then the value returned is the result of regular division ; for example , returned the value .
There are two definitions for the division operator , and the two Overloading Function Names definitions are distinguished not by having different numbers of operands , but rather by requiring operands of different types .
The difference between overloading of and overloading names is that the compiler has already done the overloading of but you program the overloading of the function .
We will see in later chapter how overload operators such as + and so on .

Programming Example Revised Program The Pizza Consumers Union has been very successful with the program that we wrote for it in Display .
In fact , now everybody always buys the pizza that is the best buy .
One disreputable pizza parlor used make money by fooling consumers into buying the more expensive pizza , but our program has put an end their evil practices .
However , the owners wish continue their despicable behavior and have come up with new fool consumers .

They now offer both round pizzas and rectangular pizzas .
They know that the program we wrote cannot deal with rectangularly shaped pizzas , so they hope they can again confuse consumers .
We need update our program so that we can foil their nefarious scheme .
We want change the program so that it can compare round pizza and rectangular pizza .

The changes we need make our pizza evaluation program are clear : We need change the input and output bit so that it deals with two different shapes of pizzas .
We also need add new that can compute the cost per square inch of rectangular pizza .
We could use the following definition in our program so that we can compute the unit price for rectangular pizza : double .

However , this is rather long for  in fact , so long that we needed put the heading on two lines .
That is legal , but it would be nicer use the same  unitprice , for both the that computes the unit price for round pizza and for the that computes the unit price for rectangular pizza .
Since allows overloading of names , we can do this .
Having two definitions for the unitprice will pose no problems the compiler because the two functions will have different numbers of arguments .
Display shows the program we obtained when we modified our pizza evaluation program allow us compare round pizzas with rectangular pizzas .

Chapter Procedural Abstraction and Functions That Return Value whether round pizza or rectangular pizza is the best buy .

The formal parameter named price is the price of the pizza .

Sample Dialogue Welcome to the Pizza Consumers Union .

Enter the diameter in inches of round pizza : Enter the price of round pizza : Enter length and width in inches of rectangular pizza : Enter the price of rectangular pizza : Round pizza : inches Per square Rectangular pizza : inches Rectangular pizza : inches Per square The round one is the better buy .

Chapter Procedural Abstraction and Functions That Return Value Automatic Type Conversion Suppose that the following function definition occurs in your program and that you have not overloaded the function name mpg this is the only definition of function called .

Hence , the following will output miles per gallon to the screen :  miles per ; Interaction of overloading and type conversion converts the to and the to , then performs the division to obtain the value returned , which is .

If function requires an argument of type double and you give it an argument of type int , will automatically convert the int argument to value of type double .
This is so useful and natural that we hardly give it thought .
However , overloading can interfere with this automatic type conversion .
look at an example .

Now , suppose you had overloaded the function name so that your program also contained the following definition of well as the previous .

If it finds such function definition , uses that function definition .
does not convert an int argument to value of type double unless that is the only way it can find matching function definition .

The example illustrates one more point about overloading .
You should not use the same function name for two unrelated functions .
Such careless use of function names is certain to eventually produce confusion .

Suppose you have two function definitions with the following function .

Suppose you have two function definitions with the function declarations .

Suppose you have two function definitions with the function declarations .

This question has to do with the Programming Example PizzaBuying " Suppose the evil pizza parlor that is always trying to fool customers introduces square pizza .
Can you overload the function unitprice so that it can compute the price per square of square pizza as well as the price per square of round pizza .

Look at the program in Display .
The main function contains the using directive : using namespace .

Chapter Procedural Abstraction and Functions That Return Value Chapter Summary good plan of attack for designing the algorithm for program is to break down the task to be accomplished into few subtasks , then decompose each subtask into smaller subtasks , and so forth until the subtasks are simple enough that they can easily be implemented as code .
This approach is called design .

The arguments to the function serve as the input to this program " and the value returned When subtask for program takes some values as input and produces single value as its only result , then that subtask can be implemented as function .

The programmer who uses the function should not need to know any details about how the function is coded .
All the programmer should need to know is the function declaration and the accompanying comment that describes the value returned .
This rule is sometimes called the principle of procedural abstraction .

Declarations for global named constants are normally placed at the start of program after the include directives and before the function declarations .

Occasionally , it is useful to use formal parameter as local variable .

When you overload function name , the function definitions must have different numbers of formal parameters or some formal parameters of different types .

Answers to Self est Exerci ses .

Suppose the function is defined with arguments , say and .

The function is then called with corresponding arguments and .

The values of the arguments are in " for the corresponding formal parameters , into , into .
The formal parameters are then used in the function .

Predefined functions usually require that you header file .
For function , the programmer puts the code for the function either into the file with the main part of the program or in another file to be compiled and linked to the main program .

The comment explains what value the function returns and gives any other information that you need to know in order to use the function .

The principle of procedural abstraction says that function should be written so that it can be used like black box .
This means that the programmer who uses the function need not look at the body of the function definition to see how the function works .
The function declaration and accompanying comment should be all the programmer needs to know in order to use the function .

When we say that the programmer who uses function should be able to treat the function like black box , we mean the programmer should not need to look at the body of the function definition to see how the function works .
The function declaration and accompanying comment should be all the programmer needs to know in order to use the function .

In order to increase your confidence in your program , you should test it on input values for which you know the correct answers .
Perhaps you can calculate the answers by some other means , such as pencil and paper or hand calculator .

Yes , the function would the same value in either case , so the two definitions are equivalent .

If you use variable in function definition , you should declare the variable in the body of the function definition .

Everything will be fine .
The program will compile everything else is .
The program will run that everything else is .
The program will not generate an error message when run everything else is .
The program will give the correct output everything else is .

The function will work fine .
That is the entire answer , but here is some additional information : The formal parameter inches is parameter and , as discussed in the text , it is therefore local variable .
Thus , the value of the argument will not be changed .

The function call has only one argument , so it would use the function definition that has only one formal parameter .

The function call has two arguments of type double , so it would use the function corresponding to the function declaration with two arguments of type double  the first function .

The second argument of type int and the first argument would be automatically converted to type double by if needed , so it would use the function corresponding to the function declaration with the first argument of type double and the second argument of type int  the second function .

The second argument of type double and the first argument would be automatically converted to type double by if needed , so it would use the function corresponding to the function declaration with two arguments of type double  the first function .

This cannot be done least not in any nice .
The natural ways to represent square and round pizza are the same .
Each naturally represented as one  which the diameter for round pizza and the length of side for square pizza .
In either case the function unitprice would need to have one formal parameter of type double for the price and one formal parameter of type int for the size radius or .

Thus , the two function declarations would have the same and types of formal parameters .
You can still defeat this evil pizza strategy by defining two functions , but they will need to have different names .

The definition of unitprice does not do any input or output and so does not use the library iostream .
In main we needed the using directive because cin and are defined in iostream and those definitions place cin and in the std namespace .

Practice Programs Practice Programs can generally be solved with short program that directly applies the programming principles presented in this chapter .

liter gallons .
Write program that will read in the of liters of gasoline consumed by the car and the of miles traveled by the car and will then output the of miles per gallon the car delivered .
Your program should allow the user to repeat this calculation as often as the user wishes .
Define function to compute the of miles per gallon .
Your program should use globally defined constant for the of liters per gallon .

Modify your program from Practice Program so that it will take input data for two cars and output the of miles per gallon delivered by each car .
Your program will also announce which car has the best fuel efficiency of miles per .

The price of stocks sometimes given to the nearest eighth of dollar ; for example , or .
Write program that computes the value of the holding of one stock .
The program asks for the of shares of stock owned , the portion of the price , and the fraction portion .

The fraction portion to be input as two int values , one for the numerator and one for the denominator .
The program then outputs the value of the holdings .
Your program should allow the user to repeat this calculation as often as the user wishes and will include function definition that has three int arguments consisting of the portion of the price and the two integers that make up the fraction part .
The function returns the price of one share of stock as single of type double .

It estimates the inflation rate as the difference in price divided by the price .
Your program should allow the user to repeat this calculation as often as the user wishes .
Define function to compute the rate of inflation .
The inflation rate should be value of type double giving the rate as percent , for example for percent .

Chapter Procedural Abstraction and Functions That Return Value .
Enhance your program from the previous Practice Program by having it also print out the estimated price of the item in one and in two years from the time of the calculation .
The increase in cost over one year estimated as the inflation rate times the price at the start of the year .
Define second function to determine the estimated cost of an item in one year , given the current price of the item and the inflation rate as arguments .

Write function declaration for function that computes interest on credit card account balance .
The function takes arguments for the initial balance , the monthly interest rate , and the number of months for which interest must be paid .
The value returned the interest due .
Do not forget to compound the  to charge interest on the interest due .
The interest due added into the balance due , and the interest for the next month computed using this larger balance .
Use while loop that similar to need not be identical the one shown in Display .
Embed the function in program that reads the values for the interest rate , initial account balance , and number of months , then outputs the interest due .
Embed your function definition in program that lets the user compute interest due on credit account balance .
The program should allow the user to repeat the calculation until the user says he or she wants to end the program .

VideoNote Solution to Practice Program .
The gravitational attractive force between two bodies with masses and separated by distance given by : where is the universal gravitational constant : cm Write function definition that takes arguments for the masses of two bodies and the distance between them and that returns the gravitational force .

Since you will use the preceding formula , the gravitational force will be in dynes .
One dyne equals You should use globally defined constant for the universal gravitational constant .
Embed your function definition in complete program that computes the gravitational force between two objects given suitable inputs .

Your program should allow the user to repeat this calculation as often as the user wishes .

That we are " with several absolute value functions is an accident of history .
libraries were already available when arrived ; they could be easily used , so they were not rewritten using function overloading .
You are to find all the absolute value functions you can and rewrite all of them Programming Projects overloading the abs function name .
At minimum , you should have the int , long , float , and double types represented .

Write an overloaded function max that takes either two or three parameters of type double and returns the largest of them .

Programming Projects Programming Projects require more than Practice Programs and can usually be solved many different ways .
Visit to complete many of these Programming Projects online and get instant feedback .

Write program that computes the annual cost of new for the first year of ownership .
The cost is computed as the annual mortgage cost minus the tax savings .
The input should be the price of the and the down payment .
The annual mortgage cost can be estimated as percent of the initial loan balance credited toward paying off the loan principal plus percent of the initial loan balance in interest .
The initial loan balance is the price minus the down payment .
Assume percent marginal tax rate and assume that interest payments are tax deductible .
So , the tax savings is percent of the interest payment .
Your program should use at least two function definitions and should allow the user to repeat this calculation as often as the user wishes .

Write program that asks for the height , weight , and age , and then computes clothing sizes according to the formulas : weight in pounds divided by height in and all that multiplied by .

So , there is no in weight divided by and then adjusted by adding of an inch for each years over age .
So , there is no adjustment for age , Use functions for each calculation .
Your program should allow the user to repeat this calculation as often as the user wishes .

Modify your program from Programming Project so that it also calculates the jacket and waist sizes after years .

Write program that outputs the lyrics for the song Bottles of Beer on the " Your program should print the number of bottles in English , not as number .

Chapter Procedural Abstraction and Functions That Return Value bottles of beer on the wall , bottles of beer , Take one down , pass it around , bottles of beer on the wall .

Zero bottles of beer on the wall .

Design your program with function that takes as an argument an integer between and and returns string that contains the integer value in English .
Your function should not have different statements .

Instead , use and to extract the tens and ones digits to construct the string .
You may need to test specifically for values such as , etc .

To maintain body weight , an adult human needs to consume enough calories daily to meet the basal metabolic rate to breathe , maintain body temperature , account for physical activity such as exercise , and account for the energy to digest the food that is being eaten .
For an adult that weighs pounds , we can estimate these caloric requirements using the following formulas :
Basal metabolic rate :
Physical activity : Intensity Minutes Here , Minutes is the number of minutes spent during the physical activity , and Intensity is number that estimates the intensity of the activity .
Here are some sample numbers for the range of values : Activity Intensity .

Energy to digest food : calories TotalCaloriesConsumed In other words , percent of the calories we consume goes towards digestion .

Write function that computes the calories for the basal metabolic rate , taking as input parameter for the weight .
Write another that computes the calories for physical activity , taking as input parameters for the intensity , weight , and minutes spent exercising .

Programming Projects Use these functions in program that inputs weight , an estimate for the intensity of physical activity , the number of minutes spent performing the physical activity , and the number of calories in one serving of your favorite food .
The program should then calculate and output how many servings of that food should be eaten per day to maintain the current weight at the specified activity level .
The computation should include the energy that is to digest food .

You can find estimates of the caloric content of many foods on the Web .

For example , double cheeseburger has approximately calories .

You have invented vending machine capable of deep frying twinkies .

Write program to simulate the vending machine .
It costs to buy twinkie , and the machine only takes coins in denominations of dollar , quarter , dime , or nickel .
Write code to simulate person putting money into the vending machine by repeatedly prompting the user for the next coin to be inserted .
Output the total entered so far when each coin is inserted .
When or more is added , the program should output your twinkie " along with any change that should be returned .

Use design to determine appropriate functions for the program .

Your time machine is capable of going forward in time up to hours .

The machine is configured to jump ahead in minutes .
To enter the proper number of into your machine , you would like program that can and calculate the difference in between the start and future time .

time is specified in your program with three variables : int   bool .

Write program that allows the user to enter start time and future time .

Include function named computeDifference that takes the six variables as parameters that represent the start time and future time .
Your function should return , as an int , the time difference in .
For example , given start time of AM and future time of PM , your program should compute as the time difference .
Given start time of AM and future time of AM , your program should compute as the time difference and .

Chapter Procedural Abstraction and Functions That Return Value You may need " or " from the input by reading in two character values .
For example , if the variable is of type char , then is Boolean expression that evaluates to true if contains the letter .

VideoNote Solution to Programming Project .
Do Programming Project from Chapter except write function named containsDigit that determines if number contains particular digit .
The header should look like : bool number , int ; If number contains digit , then the function should return true .
Otherwise , the function should return false .
Your program should use this function to find the closest numbers that can be entered on the keypad .

Your sports league uses the following lottery system to select draft picks for the four worst teams in the league : The .

To determine the first pick in the draft ball is selected at random .
The team owning that ball gets the first pick .
The ball is then put back in the urn .

To determine the second pick in the draft ball is selected at random .
If the ball belongs to the team that got the first pick then it is put back in and the process repeats until ball is selected that does not belong to the first pick .

To determine subsequent picks in the draft the process repeats until ball is selected that belongs to team that has not already been chosen .

Write function that takes as input which of the four teams have already been granted picks , simulates selecting ball from the urn according to the lottery rules , and returns the team that belongs to the selected ball .
You get to choose how to design your function to perform these actions .
Write main function that outputs the draft order , possible order is : picks , last place picks , picks , and picks .
If you change the random seed then the order should differ if you run the program multiple times .

For slightly harder version of the problem , allow the user to input the names of the four teams .
The program should then output the team names in the draft order .

Functions for All Subtasks void Functions Definitions of void Functions Programming Example : Converting Temperatures return Statements in void Functions Parameters First View of in Detail Programming Example : The Function Mixed Parameter Lists Programming Tip : What Kind of Parameter to Use Pitfall : Inadvertent Local Variables Chapter Summary Answers to Exercises Using Procedural Abstraction Functions Calling Functions Preconditions and Postconditions Case Study : Supermarket Pricing and Debugging Functions Stubs and Drivers Debugging TeCHniques Keep an Open Mind Check Common Errors Localize the Error The assert Macro Practice Programs Programming Projects Everything is possible .

COMMON MAXIM Introduction The design strategy discussed in Chapter is an effective way to design an algorithm for program .
You divide the task into subtasks and then implement the algorithms for these subtasks as functions .

Thus far , we have seen how to define functions that start with the values of some arguments and return single value as the result of the function call .
subtask that computes single value is very important kind of subtask , but it is not the only kind .
In this chapter we will complete our description of functions and present techniques for designing functions that perform other kinds of subtasks .

Prerequisites You should read Chapters through before reading this chapter .

The functions discussed in Chapter always return single value , but there are other forms of subtasks .

subtask might produce several values or it might produce no values at all .
In , function must either return single value or return no values at all .
As we will see later in this chapter , subtask that produces several different values is usually perhaps implemented as function that returns no value .
For the moment , however , let us avoid that complication and focus on subtasks that intuitively produce no values at all , and let us see how these subtasks are implemented .
function that returns no value is called void function .
For example , one typical subtask for program is to output the results of some calculation .
This subtask produces output on the screen , but it produces no values for the rest of the program to use .
This kind of subtask would be implemented as void function .

Definitions of void Functions In void function is defined in almost the same way as function that returns value .
For example , the following is void function that outputs the result of calculation that converts temperature expressed in Fahrenheit void Functions degrees to temperature expressed in Celsius degrees .
The actual calculation would be done elsewhere in the program .
This void function implements only the subtask for outputting the results of the calculation .
For now , we do not need to worry about how the calculation will be performed .

As this function definition illustrates , there are only two differences between function definition for void function and the function definitions we discussed in Chapter .
One difference is that we use the keyword void where we would normally specify the type of the value to be returned .
This tells the compiler that this function will not return any value .
The name void is used as way of saying value is returned by this " The second difference is that the return statement does not contain an expression for value to be returned , because , after all , there is no value returned .
The syntax is summarized in Display .

void function call is an executable statement .
For example , our function might be called as follows : If this statement were executed in program , it would cause the following to appear on the screen : degrees Fahrenheit is equivalent to degrees Celsius .

Notice that the function call ends with semicolon , which tells the compiler that the function call is an executable statement .

When void function is called , the arguments are substituted for the formal parameters and the statements in the function body are executed .

For example , call to the void function , which we gave earlier in this section , will cause some output to be written to the screen .

One way to think of call to void function is to imagine that the body of the function definition is copied into the program in place of the function call .
When the function is called , the arguments are substituted for the formal parameters , and then it is just as if the body of the function were lines in the program .

Function definition Function call .

Chapter Functions for All Subtasks Display Syntax for void Function Definition void Function Declaration void ; void Function Definition body .

function header You may intermix the declarations with the executable statements include one or more return statements .

It is perfectly legal , and sometimes useful , to have function with no arguments .
In that case , there simply are no formal parameters listed in the function declaration and no arguments are used when the function is called .

For example , the void function , defined next , simply sends new command to the .

The next programming example shows these two sample void functions in complete program .

Fahrenheit temperature can be converted to an equivalent Celsius temperature as follows : The function celsius shown in Display uses this formula to do the temperature conversion .

In the case of function that returns value , the return statement specifies the value returned .
In the case of void function , the return statement simply ends the function call .
As we saw in the previous chapter , every function that returns value must end by executing return statement .
However , void function need not contain return statement .

If it does not contain return statement , it will end after executing the code in the function body .
It is as if there were an implicit return statement just before the final closing brace at the end of the function body .
For example , the functions and in Display would perform exactly the same if we omitted the return statements from their function definitions .

The fact that there is an implicit return statement before the final closing brace in function body does not mean that you never need return statement in void function .
For example , the function definition in Display might be used as part of restaurant management program .

That function outputs instructions for dividing given amount of ice cream among the people at table .
If there are no people at the table is , if number equals , then the return statement within the if statement terminates the function call and avoids division by zero .
If number is not , then the function call ends when the last statement is executed at the end of the function body .

By now you may have guessed that the main part of program is actually the definition of function called main .
When the program is run , the function main is automatically called and it , in turn , may call other functions .
Although it may seem that the return statement in the main part of program should be optional , officially it is not .
Technically , the main part of program is function that returns value of type int , so it requires return statement .

However , the function main is used as if it were void function .
Treating the main part of your program as function that returns an integer may sound void functions and return statements The main part of program is function Chapter Functions for All Subtasks .

Sample Dialogue will convert Fahrenheit temperature to Celsius .

Enter temperature in Fahrenheit : degrees Fahrenheit is equivalent to degrees Celsius .

Display Use of return in void Function Function Declaration .

Function Definition .

Chapter Functions for All Subtasks crazy , but the tradition .
It might be best to continue to think of the main part of the program as just main part of the program " and not worry about this minor el est Exe rcis es .

Are you required to have return statement in void function definition .

Suppose you omitted the return statement in the function definition for in Display .
What effect would it have on the program .
Would the program compile .

Would the program behave any differently .
What about the return statement in the function The Standard says that you can omit the return in the main part , but many compilers still require it .

What effect would it have on the program if you omitted the return statement in the definition of .
What about the return statement in the function definition for celsius in that same program .
What effect would it have on the program if you omitted the return statement in the definition of celsius .

Write definition for void function that has three arguments of type int and that outputs to the screen the product of these three arguments .

Put the definition in complete program that reads in three numbers and then calls this function .

Does your compiler allow void and int .
What warnings are issued if you have int and do not supply return ; statement .
To find out , write several small test programs and perhaps ask your instructor or local guru .

Is call to void function used as statement or is it used as an expression .

There are different mechanisms used for this substitution process .
The mechanism we used in Chapter , and thus far in this chapter , is known as the mechanism .
The second main mechanism for substituting arguments is known as the mechanism .

First View of The mechanism that we used until now is not sufficient for certain subtasks .
For example , one common subtask is to obtain one or more input values from the user .
Look back at the program in Display .
Its tasks are divided into four subtasks : initialize the screen , obtain the Fahrenheit temperature , compute the corresponding Celsius temperature , and output the results .
Three of these four subtasks are implemented as the functions , celsius , and .
However , the subtask of obtaining the input is implemented as the following four lines of code than as function : temperature in Fahrenheit : cin .

Chapter Functions for All Subtasks function for obtaining input should set the values of one or more variables to values typed in at the keyboard , so the function call should have one or more variables as arguments and should change the values of these argument variables .
With the formal parameters that we have used until now , an argument in function call can be variable , but the function takes only the value of the variable and does not change the variable in any way .
With formal parameter only the value of the argument is substituted for the formal parameter .
For an input function , we want the variable the value of the to be substituted for the formal parameter .
The mechanism works in just this way .
With formal parameter called simply reference , the corresponding argument in function call must be variable and this argument variable is substituted for the formal parameter .
It is as if the argument variable were literally copied into the body of the function definition in place of the formal parameter .
After the argument is substituted in , the code in the function body is executed and this code can change the value of the argument variable .

parameter must be marked in some way so that the compiler will know it from parameter .
The way that you indicate parameter is to attach the ampersand sign , to the end of the type name in the formal parameter list in both the function declaration and the header of the function definition .
For example , the following function definition has one formal parameter , and that formal parameter is parameter : using namespace .

However , rather than rewrite an old  look at completely new .

Display demonstrates parameters .

It just reads in two numbers and writes the same numbers out , but in the reverse order .
The parameters in the functions and are parameters .
The input is performed by the function call , Parameters Display Parameters .

Enter two integers : In reverse order the numbers are :

Chapter Functions for All Subtasks The values of the variables and are set by this function call .
After that , the following function call reverses the values in the two variables and  In the next few subsections we describe the mechanism in more detail and also explain the particular functions used in Display .

in Detail In most situations , the mechanism works as if the name of the given as the function argument were literally substituted for the formal parameter .
However , the process is bit more subtle than that .
In some situations , this subtlety is important , so we need to examine more details of this substitution process .

Recall that variables are implemented as memory locations .
The compiler assigns one memory location to each .
For example , when the in Display is compiled , the might be assigned location , and the might be assigned .

For purposes of this example , consider these variables to be stored at these memory locations .
In other words , after executing the line int , the value will be stored at memory locations and .
The arrows in the diagram below point to the memory locations referenced by the variables .

Memory Location Value .

Next , consider the following function declaration from Display : void ,

The formal parameters and are place holders .

The corresponding argument in call to the function should then be  not constant or other expression .
When the function is called , the corresponding argument its will be substituted for the formal parameter .
Any change made to the formal parameter in the function body will be made to the argument when the function is called .
The exact details of the substitution mechanisms are given in the text of this chapter .

Example parameters in function : void ,

When the function call is executed , the function is not given values stored in and .
Instead , it is given the memory locations associated with each name .
In this example , the locations are which are the locations assigned to the argument variables and  in that order .
It is these memory locations that are associated with the formal parameters .
The first memory location is associated with the first formal parameter , the second memory location is associated with the second formal parameter , and so forth .
In our example is the first parameter , so it gets the same memory location as .
The second parameter is and it gets the same memory location as .

Diagrammatically , the correspondence is Memory Location Value .

Chapter Functions for All Subtasks When the function statements are executed , whatever the function body says to do to formal parameter is actually done to the in the memory location associated with that formal parameter .
In this case , the instructions in the body of the function say that value should be stored in the formal parameter using cin statement , and so that value is stored in the in memory location happens to be where the variable is .
Similarly , the instructions in the body of the function say that value should then be stored in the formal parameter using cin statement , and so that value is stored in the variable in memory location happens to be where the variable is .
Thus , whatever the function instructs the computer to do to and is actually done to the variables and For example , if the user enters and as in Display , then the result is Memory Location Value .

This means we can no longer retrieve the data values at and through the variables and .

However , the data still exists in memory location and and is accessible through the variables and within the scope of the main function .
These details of how the mechanism works in this function call to are described in Display .

It may seem that there is an extra level of detail , or at least an extra level of verbiage .
If is the variable with memory location , why do we insist on saying variable at memory location " instead of simply saying .
This extra level of detail is needed if the arguments and formal parameters contain some confusing coincidence of names .
For example , the function has formal parameters named and .
Suppose you want to change the program in Display so that it uses the function with arguments that are also named and , and suppose that you want to do something less than obvious .
Suppose you want the first number typed in to be stored in variable named , and the second Parameters Anatomy of Function Call from Display Using Arguments the variables and have been assigned the following memory address by the compiler : We do not know what addresses are assigned and the results will not depend on the actual In the program in Display , the following function call begins .

The effect is the same as if the function definition were rewritten to the following is not legal code , but does have clear meaning to : void variable at memory location ,

The effect is the same as if the following were executed :

Now , suppose that the variables and , which are declared in the main part of your program , have been assigned memory locations and .
The function call could be as follows : int , input ;

However , if the variable declared in the main part of your program is assigned memory location , the phrase variable at memory location " is unambiguous .
go over the details of the substitution mechanisms in this case .

In this call the argument corresponding to the formal parameter is the variable , and the argument corresponding to the formal parameter is the variable .
This can be confusing to us , but it produces no problem at all for the computer , since the computer never does The computer simply deals with memory locations .
The computer substitutes variable at memory location " for the formal parameter , and variable at memory location " for the formal parameter .

The Function The function defined in Display interchanges the values stored in two variables .
The description of the function is given by the .

As shown in Display , the definition of the function uses local called temp .
This local is needed .
You might be tempted to think the function definition could be simplified to the .

The value of is set equal to the value of  just as it should be .
But then , the value of is set equal to the changed value of  which is now the original value of .
Thus the value of is not changed at all .
This is what the local temp in the correct function definition is used for .
That correct definition is the one in Display .
When that correct version is used and .

Chapter Functions for All Subtasks .

Parameters and Arguments All the different terms that have to do with parameters and arguments can be confusing .
However , if you keep few simple points in mind , you will be able to easily handle these terms .

formal parameter any is kind of blank or place holder that is filled in with something when the function is called .

When you write down function call , the arguments are listed in parentheses after the function name .
When the function call is executed , the arguments are in " for the formal parameters .

In the method , only the value of the argument is used .
In this mechanism , the formal parameter is local that is initialized to the value of the corresponding argument .
In the mechanism , the argument is and the entire is used .
In the mechanism , the argument is substituted for the formal parameter so that any change that is made to the formal parameter is actually made to the argument .

Mixed Parameter Lists Mixing and Whether formal parameter is parameter or parameter is determined by whether there is an ampersand attached to its type specification .
If the ampersand is present , then the formal parameter is parameter .
If there is no ampersand associated with the formal parameter , then it is parameter .

It is perfectly legitimate to mix and formal parameters in the same function .
For example , the first and last of the formal parameters in the following function declaration are formal parameters and the middle one is parameter : void , int ,

You can also use them in functions that return value .
Thus , function with parameter could both change the value of given as an argument and return value .

The parameters value and are both assigned value inside the body of the function definition .
But since they are different kinds of parameters , the effect is different in the two cases .

When the function is called as follows , the local is initialized to the value of .
That is , the local is initialized to and the is then ignored by the function .
As you can see from the sample dialogue , the formal parameter is local is set to in the function body and this value is output to the screen .
However , the value of the argument is not changed .
As shown in the sample dialogue , has retained its value of .

VideoNote Call by Reference and Call by Value Chapter Functions for All Subtasks .

Sample Dialogue in function in function after function after function On the other hand , is parameter .
When the function is called , the variable argument just its is substituted for the formal parameter .
So that when the following code is executed :

Thus , the value of the variable is changed when the function body is executed , so as the dialogue shows , the value of is changed from to by the function .

If you keep in mind the lesson of Display , it is easy to decide which parameter mechanism to use .
If you want function to change the value of variable , then the corresponding formal parameter must be formal parameter and must be marked with the ampersand sign ,
In all other cases , you can use formal parameter .

If you carelessly omit the ampersand , the function will have parameter where you meant to have parameter , and when the program is run , you will discover that the function does not change the value of the corresponding argument .
This is because formal parameter is local variable , so if it has its value changed in the function , then as with any local variable , that change has no effect outside of the function body .
This is logic error that can be very difficult to see because it looks right .

As result , the formal parameters and are local variables .
The argument variables and are never substituted in for and ; and are instead initialized to the values of and .
Then , the values of and are interchanged , but the values of and are left unchanged .
The omission of two ampersands has made the program completely wrong , yet it looks almost identical to the correct program and will compile and run without any error messages .

Chapter Functions for All Subtasks .

What would be the output of the program in Display if you omit the ampersands , from the first parameter in the function declaration and function heading of .
The ampersand is not removed from the second parameter .

What would be the output of the program in Display if you change the function declaration for the function to the following and you change the function header to match , so that the formal parameter is changed to parameter : void , int ;
Write void function definition for function called that has two reference parameters , both of which are variables of type int , and sets the values of both variables to .

Write void function definition for function called .
The function has two formal parameters : which is the amount of sales tax expressed as percentage , and cost , which is the cost of an item before tax .
The function changes the value of cost so that it includes sales tax .

Can function that returns value have parameter .

May function have both and parameters .

MIGUEL DE CERVANTES SAAVEDRA , Don Quixote Recall that the principle of procedural abstraction says that functions should be designed so that they can be used as black boxes .
For programmer to use function effectively , all the programmer should need to know is the function declaration and the accompanying comment that says what the function accomplishes .
The programmer should not need to know any of the details contained in the function body .
In this section we discuss number of topics that deal with this principle in more detail .

Functions Calling Functions function body may contain call to another function .
The situation for these sorts of function calls is exactly the same as it would be if the function call had occurred in the main function of the program ; the only restriction is that the function declaration should appear before the function is used .
If you set up your programs as we have been doing , this will happen automatically , since all function declarations come before the main function and all function definitions come after the main function .
Although you may function call within the definition of another function , you cannot place the of one function within the body of another function definition .

Display shows an enhanced version of the program shown in Display .
The program in Display always reversed the values of the variables and .
The program in Display reverses these variables only some of the time .
The program in Display uses the function order to reorder the values in these variables so as to ensure that If this condition is already true , then nothing is done to the variables and .
If , however , is greater than num , then the function is called to interchange the values of these two variables .
This testing for order and exchanging of values all takes place within the body of the function order .
Thus , the function is called within the body of the function order .
This presents no special problems .
Using the principle of procedural abstraction , we think of the function as performing an action , interchanging the values of two ; this action is the same no matter where it occurs .

Chapter Functions for All Subtasks .

Enter two integers : In increasing order the numbers are : Preconditions and Postconditions One good way to write function declaration comment is to break it down into two kinds of information , called precondition and postcondition .
The precondition states what is assumed to be true when the function is called .

The function should not be used and cannot be expected to perform correctly unless the precondition holds .
The postcondition describes the effect of the function call ; that is , the postcondition tells what will be true after the function is executed in situation in which the precondition holds .
For function that returns value , the postcondition will describe the value returned by the function .
For function that changes the value of some argument variables , the postcondition will describe all the changes made to the values of the arguments .

For example , the function declaration comment for the function values shown in Display can be put into this format as .

When the only postcondition is description of the value returned , programmers often omit the word postcondition .
common and acceptable alternative form for the previous function declaration comments is the following : fahrenheit is temperature expressed degrees Fahrenheit .

Another example of preconditions and postconditions is given by the .

You do not need to know the definition of the function in order to use this function , so we have given only the function declaration and accompanying comment .

Preconditions and postconditions are more than way to summarize actions .
They should be the first step in designing and writing function .
When you design program , you should specify what each function does before you start designing how the function will do it .
In particular , the function declaration comments and the function declaration should be designed and written down before starting to design the function body .
If you later discover that your specification cannot be realized in reasonable way , you may need to back up and rethink what the function should do , but by clearly specifying what you think the function should do , you will minimize both design errors and wasted time writing code that does not fit the task at hand .

Some programmers prefer not to use the words precondition and postcondition in their function comments .
However , whether you use the words or not , your function comment should always contain the precondition and postcondition information .

Case Study Supermarket Pricing This case study solves very simple programming task .
It may seem that it contains more detail than is needed for such simple task .
However , if you see the design elements in the context of simple task , you can concentrate on learning them without the distraction of any side issues .
Once you learn the Using Procedural Abstraction techniques that are illustrated in this simple case study , you can apply these same techniques to much more complicated programming tasks .

Problem Definition We have been commissioned by the supermarket chain to write program that will determine the retail price of an item given suitable input .
Their pricing policy is that any item that is expected to sell in one week or less is marked up percent , and any item that is expected to stay on the shelf for more than one week is marked up percent over the wholesale price .
Be sure to notice that the low markup of percent is used for up to days and that at days the markup changes to percent .
It is important to be precise about exactly when program should change from one form of calculation to different one .

As always , we should be sure we have clear statement of the input required and the produced by the program .

Input The input will consist of the wholesale price of an item and the expected number of days until the item is sold .

Output The will give the retail price of the item .

Analysis of the Problem Like many simple programming tasks , this one breaks down into three main subtasks :
Input the data .

Compute the retail price of the item .

Output the results .

These three subtasks will be implemented by three functions .
The three functions are described by their function declarations and accompanying comments , which are given below .
Note that only those items that are changed by the functions are parameters .
The remaining formal parameters are parameters .

The value of turnover has been to the expected number of days until the item is sold .

Even though we have not yet written the function bodies and have no idea of how the functions work , we can write the above code that uses the functions .

That is what is meant by the principle of procedural abstraction .
The functions are treated like black boxes .

Algorithm Design The implementations of the functions and are straightforward .
They simply consist of few cin and cout statements .
The algorithm for the function price is given by the following pseudocode : if turnover days then return of ; else .

Coding There are three constants used in this program : low markup figure of percent , high markup figure of percent , and an expected shelf stay of days as the threshold above which the high markup is used .
Since these constants might need to be changed to update the program should the company decide to change its pricing policy , we declare global named constants at the start of our program for each of these three numbers .
The declarations with the const modifier are the .

The complete program is shown in Display .

The value of has been to the expected number of days until the item is sold .

Chapter Functions for All Subtasks .

Sample Dialogue This program determines the retail for an item at supermarket store .
Enter the wholesale of item : Enter the expected number of days until  Expected time until days Testing and Debugging Functions .

Program Testing An important technique in testing program is to test all kinds of input .
There is no precise definition of what we mean by " of input , but in practice , it is often easy to decide what kinds of input data program deals with .
In the case of our supermarket program , there are two main kinds of input : input that uses the low markup of percent and input that uses the high markup of percent .
Thus , we should test at least one case in which the item is expected to remain on the shelf for less than days and at least one case in which the item is expected to remain on the shelf for more than days .

Another testing strategy is to test boundary values .
Unfortunately , boundary value is another vague concept .
An input value is boundary value if it is value at which the program changes behavior .
For example , in our supermarket program , the behavior changes at an expected shelf stay of days .
Thus , is boundary value ; the program behaves differently for number of days that is less than or equal to than it does for number of days that is greater than .
Hence , we should test the program on at least one case in which the item is expected to remain on the shelf for exactly days .
Normally , you should also test input that is one step away from the boundary value as well , since you can easily be off by one in deciding where the boundary is .
Hence , we should test our program on input for an item that is expected to remain on the shelf for days , an item that is expected to remain on the shelf for days , and an item that is expected to remain on the shelf for days .
Can function definition appear inside the body of another function definition .

Can function definition contain call to another function .

Rewrite the function declaration comment for the function order shown in Display so that it is expressed in terms of preconditions and postconditions .

Give precondition and postcondition for the predefined function sqrt , which returns the square root of its argument .

This is the essence of the design strategy .

When you treat each function as separate unit , you transform one big task into series of smaller , more manageable tasks .
But how do you test function outside of the program for which it is intended .
You write special program to do the testing .
For example , Display shows program to test the function , which was used in the program in Display .

The value of turnover has been to the expected number of days until the item is sold .

Sample Dialogue Enter the wholesale cost of item : Enter the expected number of days until sold : Wholesale cost is now Days until sold is now Test again .
These driver programs are temporary tools and can be quite minimal .
They need not have fancy input routines .
They need not perform all the calculations the final program will perform .

All they need do is obtain reasonable values for the function arguments in as simple way as from the execute the function and show the result .
loop , as in the program shown in Display , will allow you to retest the function on different arguments without having to rerun the program .

If you test each function separately , you will find most of the mistakes in your program .
Moreover , you will find out which functions contain the mistakes .
If you were to test only the entire program , you would probably find out if there were mistake but may have no idea where the mistake is .
Even worse , you may think you know where the mistake is but be wrong .

Once you have fully tested function , you can use it in the driver program for some other function .
Each function should be tested in program in which it is the only untested function .
However , fine to use fully tested function when testing some other function .
If bug is found , you know the bug is in the untested function .
For example , after fully testing the function with the driver program in Display , you can use as the input routine in driver programs to test the remaining functions .

Chapter Functions for All Subtasks It is sometimes impossible or inconvenient to test function without using some other function that has not yet been written or has not yet been tested .
In this case , you can use simplified version of the missing or untested function .
These simplified functions are called stubs .
These stubs will not necessarily perform the correct calculation , but they will deliver values that suffice for testing , and they are simple enough that you can have confidence in their performance .
For example , the program in Display is designed to test the function from Display as well as the basic layout of the program .
This program uses the function , which we already .

The value of turnover has been to the expected number of days until the item is sold .

Enter the wholesale of item : Enter the expected number of days until  Expected time until days .

Chapter Functions for All Subtasks fully tested using the driver program shown in Display .
This program also includes the function , which we assume has been tested in driver program of its own , even though we have not bothered to show that simple driver program .
Since we have not yet tested the function  we have used stub to stand in for it .
Notice that we could use this program before we have even written the function .
This way we can test the basic program layout before we fill in the details of all the function definitions .

Using program outline with stubs allows you to test and then out " the basic program outline , rather than write completely new program to test each function .
For this reason , program outline with stubs is usually the most efficient method of testing .
common approach is to use driver programs to test some basic functions , like the input and output functions , and then use program with stubs to test the remaining functions .
The stubs are replaced by functions one at time : One stub is replaced by complete function and tested ; once that function is fully tested , another stub is replaced by full function definition , and so forth until the final program is produced .

The Fundamental Rule for Testing Functions Every function should be tested in program in which every other function in that program has already been fully tested and debugged .

el est Exe rcis es .
What is the fundamental rule for testing functions .
Why is this good way to test functions .

What is driver program .

Write driver program for the function introduction shown in Display .

Write driver program for the function from Exercise .

Write stub for the function whose function declaration is given next .

Do not write whole program , only the stub that would go in program .

However , examination of the code and the output of test cases may be insufficient to track down many logic errors .

In this case , there are number of general debugging techniques that you may employ .

Keep an Open Mind Examine the system as whole and assume that the bug occurs in one particular place .
If the program is giving incorrect output values , then you should examine the source code , different test cases for the input and output values , and the logic behind the algorithm itself .
For example , consider the code to determine for the supermarket example in Display .
If the wrong is displayed , the error might simply be that the input values were different from those you were expecting in the test case , leading to an apparently incorrect program .

Some novice programmers will " change portions of the code hoping that it will fix the error .
Avoid this technique at all costs .
Sometimes this approach will work for the first few simple programs that you write .
However , it will almost certainly fail for larger programs and will often introduce new errors to the program .
Make sure that you understand what logical impact change to the code will make before committing the modification .

Finally , if allowed by your instructor , you could show the program to someone else .
fresh set eyes can sometimes quickly pinpoint an error that you have been missing .
Taking break and returning to the problem few hours later or the next day can also sometimes help in discovering an error .

Check Common Errors One the first mistakes you should look for are common errors that are easy to make , as described throughout the textbook in the Pitfall and Programming Tip sections .
Examples sources for common errors include uninitialized variables , errors , exceeding data boundary , automatic type conversion , and instead .

VideoNote Debugging .

Chapter Functions for All Subtasks Localize the Error Determining the precise cause and location bug is one the first steps to fixing the error .
Examining the input and output behavior for different test cases is one way to localize the error .
related technique is to add cout statements to strategic locations in the program that print out the values for critical variables .

The cout statements also serve to show what code the program is executing .

This is the strategy tracing variables that was described in Chapter for loops , but it can be used even when there are no loops present in the code .

For example , consider the code in Display that is intended to convert temperature from Fahrenheit to Celsius the formula When this program is executed with an input degrees Fahrenheit , the output is in Celsius is .
This is obviously incorrect , as the correct answer is degrees Celsius .

To track down the error we can print out the value critical variables .

In this case , something appears to be wrong with the conversion formula , so and in the second step we compute and then output both values .
This Display Temperature Conversion Program with Bug .

Sample Dialogue Enter temperature in .

We have also commented out the original line code by placing at the beginning the line .
This tells the compiler to ignore the original line code but still leave it in the program for our reference .
If we ever wish to restore the code , we simply remove the instead having to type the line in again if it was deleted .

By examining the result the statements we have now identified the precise location the bug .
In this case , the conversion factor not computed correctly .
Since we are setting the conversion factor to , Display Debugging with Statements .

Sample Dialogue Enter temperature in .

The simple fix to perform division instead of integer division by changing one of the operands to type , for example : double ; Once the bug has been identified we can now remove or comment out .

However , it can sometimes be tedious to add large number of statements to program .
Moreover , the output of the statements may be long or difficult to interpret , and the introduction of debugging code might even introduce new .
Many compilers and integrated developing environments separate program , debugger , that allows the programmer to stop execution of the program at specific line of code called breakpoint and step through the execution of the code one line at time .
As the debugger steps through the code , the programmer can inspect the contents of variables and even manually change the values stored in those variables .
No statements are necessary to view the values of critical variables .
The interface , commands , and capabilities of debuggers vary among compilers , so check your user manual or check with your instructor for help on how to use these features .

The assert Macro In Section we discussed the concept of preconditions and postconditions for subroutines .
The assert macro tool to ensure that the expected conditions are true at the location of the assert statement .
If the condition not met , then the program will display an error message and abort .
To use assert , first the definition of assert in your program with the following statement : To use assert , add the following line of code at the location where you .

As an example , consider subroutine that uses method to calculate the square root of number : General Debugging Techniques .

subroutine that implements this algorithm requires that be positive number and that the number of iterations we will repeat the calculation also positive number .
We can guarantee this condition by adding assert to the subroutine as shown below : Approximates the square root of using Iteration .

If we try to execute this subroutine with any negative parameters , then the program will abort and display the assertion that failed .
The assert statement can be used in similar manner for any assertion that you would like to enforce and an excellent technique for defensive programming .

If you are going to distribute your program , you might not want the executable program to the assert statements , since users could then get error messages that they might not understand .
If you have added many assert statements to your code , it can be tedious to remove them all .

Fortunately , you can disable all assert macros by adding the following line to the beginning of your program , before the statement for as follows : NDEBUG If you later change your program and need to debug it again , you can turn .

Chapter Functions for All Subtasks el est Exe rcis es .
If computing the statement : how can you use the assert macro to avoid division by zero .

What general techniques can you use to determine the source of an error .

Chapter Summary All subtasks in program can be implemented as functions , either as functions that return value or as void functions .

There are two methods of performing this substitution , and .

In the substitution mechanism , the argument should be variable and the entire variable substituted for the corresponding argument .

An argument corresponding to parameter can be changed by function call .
If you want function to change the value of variable , then you must use parameter .

The precondition states what is assumed to be true when the function is called .
The postcondition describes the effect of the function call ; that is , the postcondition tells what will be true after the function is executed in situation in which the precondition holds .

stub is used in place of function definition that has not yet been tested possibly not even so that the rest of the program can be tested .

Answers to Exercises Answe rs to est Exer cises .

Hello Goodbye One more time : Hello End of program .

No , void function definition need not contain return statement .
void function definition may contain return statement , but one is not required .

Omitting the return statement in the function definition for in Display would have absolutely no effect on how the program behaves .
The program will compile , run , and behave exactly the same .
Similarly , omitting the return statement in the function definition for also will have no effect on how the program behaves .
However , if you omit the return statement in the function definition for celsius , that will be serious error that will keep the program from running .
The difference is that the functions and are void functions , but celsius is not void function .

call to void function followed by semicolon statement .
call to function that returns value an expression .

Enter two integers : In reverse order the numbers are : different in function in function after function after function .

The division by to convert percent to fraction .

Yes , function that returns value can have parameter .

Yes , function can have combination of and parameters .

No , function definition cannot appear inside the body of another function definition .

Yes , function definition can contain to another function .

Answers to Exercises .
The fundamental rule for testing functions that every function should be tested in program in which every other function in that program has already been fully tested and debugged .
This good way to test function because if you follow this rule , then when you find bug , you will know which function contains the bug .

driver program program written for the sole purpose of testing function .

debugger tool that allows the programmer to set breakpoints , step through the code line by line , and inspect or modify the value of variables .

Keeping an open mind , adding statements to narrow down the cause of the error , using debugger , searching for common errors , and devising variety of tests are few techniques that you can use to debug program .

Practice Programs Practice Programs can generally be solved with short program that directly applies the programming principles presented in this chapter .

Write function that computes the average and standard deviation of four scores .
The standard deviation defined to be the square root of the average of the four values : where average of the four scores , and .
The function will have six parameters and will two other Practice Programs functions .
Embed the function in driver program that allows you to test the function again and again until you tell the program you are finished .

Write program that reads in length in feet and inches and outputs the equivalent length in meters and centimeters .
Use at least three functions : one for  one or more for calculating , and one for output .
Include loop that lets the user repeat this computation for new values until the user says he or she wants to end the program .
There are meters in foot , centimeters in meter , and inches in foot .

Write program like that of the previous exercise that converts from meters and centimeters into feet and inches .
Use functions for the subtasks .

The program asks the user if he or she wants to convert from feet and inches to meters and centimeters or from meters and centimeters to feet and inches .
The program then performs the desired conversion .
Have the user respond by typing the integer for one type of conversion and for the other conversion .
The program reads the answer and then executes an statement .
Each branch of the statement will be function .
The two functions called in the statement will have function definitions that are very similar to the programs for the previous two Practice Programs .
Thus , they will be function definitions that other functions in their function bodies .
Include loop that lets the user repeat this computation for new values until the user says he or she wants to end the program .

Write program that reads in weight in pounds and ounces and outputs the equivalent weight in kilograms and grams .
Use at least three functions : one for  one or more for calculating , and one for output .

Include loop that lets the user repeat this computation for new values until the user says he or she wants to end the program .
There are pounds in kilogram , grams in kilogram , and ounces in pound .

Write program like that of the previous exercise that converts from kilograms and grams into pounds and ounces .
Use functions for the subtasks .

The program asks the user if he or she wants to convert from pounds and ounces to kilograms and grams or from kilograms and grams to pounds and ounces .
The program then performs the desired conversion .
Have the user respond by typing the integer for one type of conversion and for the other .
The program reads the answer and then executes an statement .
Each branch of the statement VideoNote Solution to Practice Program .

Chapter Functions for All Subtasks will be function .
The two functions called in the statement will have function definitions that are very similar to the programs for the previous two Practice Programs .
Thus , they will be function definitions that other functions in their function bodies .
Include loop that lets the user repeat this computation for new values until the user says he or she wants to end the program .

Write program that combines the functions of Practice Programs and .
The program asks the user if he or she wants to convert lengths or weights .
If the user chooses lengths , then the program asks the user if he or she wants to convert from feet and inches to meters and centimeters or from meters and centimeters to feet and inches .
If the user chooses weights , similar question about pounds , ounces , kilograms , and grams asked .
The program then performs the desired conversion .
Have the user respond by typing the integer for one type of conversion and for the other .
The program reads the answer and then executes an statement .
Each branch of the statement will be function call .
The two functions called in the statement will have function definitions that are very similar to the programs for Practice Programs and .
Thus , these functions will be function definitions that call other functions in their function bodies ; however , they will be very easy to write by adapting the programs you wrote for Practice Programs and .

Notice that your program will have statements embedded inside of statements , but only in an indirect way .
The outer statement will two function calls as its two branches .
These two function calls will each in turn an statement , but you need not think about that .
They are just function calls and the details are in black box that you create when you define these functions .
If you try to create branch , you are probably on the wrong track .
You should only need to think about branches though the entire program does ultimately branch into four .
Include loop that lets the user repeat this computation for new values until the user says he or she wants to end the program .

The of an arbitrary triangle can be computed using the formula where , and c are the lengths of the sides , and the semiperimeter .

The function should use five value parameters that provide the lengths of the edges and two reference parameters that store the computed Programming Projects and perimeter .
Make your function robust .
Note that not all of , and c produce triangle .
Your function should correct results for legal data and reasonable results for illegal combinations .

Programming Projects Programming Projects require more than Practice Programs and can usually be solved many different ways .
Visit to complete many of these Programming Projects online and get instant feedback .

Write program that converts from notation to notation .

For example , it should convert to PM .
The is given as two integers .
There should be at least three functions , one for  one to do the conversion , and one for output .
Record the information as value of type char , for AM and ' for PM .
Thus , the function for doing the conversions will have formal parameter of type char to record Include loop that lets the user repeat this computation for new values again and again until the user says he or she wants to end the program .

Write program that requests the current time and waiting time as two integers for the number of hours and the number of minutes to wait .
The program then outputs what the time will be after the waiting period .
Use notation for the times .
Include loop that lets the user repeat this calculation for additional values until the user says she or he wants to end the program .

Modify your program for Programming Project so that it uses notation , such as PM .

Write program that tells what coins to give out for any amount of change from cent to cents .
For example , if the amount is cents , the output would be something like the following : cents can be given as Use coin denominations of cents , cents , and cent .

Chapter Functions for All Subtasks For example , suppose the value of the variable is .
Then , after the following call , the value of number will be and the value of will be if you take quarters from cents , that leaves : number , Include loop that lets the user repeat this computation for new values until the user says he or she wants to end the program .
In cold weather , meteorologists report an index called the windchill factor , that takes into account the wind speed and the temperature .
The index provides measure of the chilling effect of wind at given air temperature .

Windchill may be approximated by the formula : + + where wind speed in temperature in degrees  Write function that returns the windchill index .
Your code should ensure that the restriction on the temperature is not violated .
Look up some weather reports in back issues of newspaper in your university library and compare the windchill index you calculate with the result reported in the newspaper .

VideoNote Solution to Programming Project .
In the land of Puzzlevania , Aaron , Bob , and Charlie had an argument over which one of them was the greatest puzzler of all time .
To end the argument once and for all , they agreed on duel to the death .
Aaron is poor shooter and only hits his target with probability of .
Bob is bit better and hits his target with probability of .
Charlie is an expert marksman and never misses .
hit means kill and the person hit drops out of the duel .

To compensate for the inequities in their marksmanship skills , it is decided that the contestants would fire in turns starting with Aaron , followed by Bob , and then by Charlie .
The cycle would repeat until there was one man standing .
And that man would be remembered as the greatest puzzler of all time .

It should use the following declaration : void targetAlive , double ; would simulate someone shooting at targetAlive with the given .

Programming Projects number is less than accuracy , then the target is hit and targetAlive should be set to false .
Chapter illustrates how to generate random numbers .

For example , if Bob is shooting at Charlie , this could be invoked as : charlieAlive is Boolean variable that indicates if Charlie is alive .

Test your function using driver program before moving on to step .

Write second function named startDuel that uses the shoot function to simulate an entire duel using this strategy .
It should loop until only one contestant is left , invoking the shoot function with the proper target and probability of hitting the target according to who is shooting .
The function should return variable that indicates who won the duel .

Output the probability that each contestant will win when everyone uses the of shooting at the most accurate shooter left alive .

Thereafter , everyone uses the of shooting at the most accurate shooter left alive .
This means that Aaron is guaranteed to live past the first round , since Bob and Charlie will fire at each other .

Modify the program to accommodate this new and output the probability of winning for each contestant .

Write program that inputs date example , July , and outputs the day of the week that corresponds to that date .
The following algorithm is from .

The implementation will require several functions .

Here is pseudocode to determine leap  divisible by or divisible by and int .

Chapter Functions for All Subtasks .

First , extract the last two digits the .
For example , is extracted for .
Next , factor in leap years .
Divide the value from the previous step by and discard the remainder .
Add the two results together and return this value .
For example , from we extract .

remainder corresponds to Sunday , corresponds to Monday , Programming Projects up to , which corresponds to Saturday .
For example , the date July , should be computed as + + + + + +
The fifth day the week corresponds to Friday .

Your program should allow the user to enter any date and output the corresponding day the week in English .

This program should include void function named getInput that prompts the user for the date and returns the month , day , and using parameters .
You may choose to have the user enter the month as either number or month name .

Complete the previous Programming Project and create function named dayOfWeek with the header : int month , int day , int ; The function should encapsulate the necessary logic to return the day the week the specified date as an int , You should add validation code to the function that tests if any the inputs are invalid .
If so , the function should return as the day the week .
In your main function write test driver that checks if dayOfWeek is returning the correct values .
Your set test cases should include at least two cases with invalid inputs .

As leaf is carried by stream , whether the stream ends in lake or in the sea , so too is the output of your program carried by stream not knowing if the stream goes to the screen or to file .

Introduction refers to program input and output .
Input can be taken from the keyboard or from file .
Similarly , output can be sent to the screen or to file .
This chapter explains how you can write your programs to take input from file and send output to another file .

Input is delivered to your program via construct known as stream , and output from your program is delivered to the output device via stream .
Streams are our first examples of objects .
An object is special kind of variable that has its own functions that are , in sense , attached to the variable .
The ability to handle objects is one of the language features that sets apart from earlier programming languages .

In this chapter we tell you what streams are and explain how to use them for program .
In the process of explaining streams , we will introduce you to the basic ideas about what objects are and about how objects are used in program .

Prerequisites This chapter uses the material from Chapters through .

For more than forty years have been speaking prose without knowing it .

MoliÃ¨re , Le Bourgeois Gentilhomme You are already using files to store your programs .
You can also use files to store input for program or to receive output from program .
The files used for program are the same kind of files you use to store your programs .

Streams , which we discuss next , allow you to write programs that handle file input and keyboard input in unified way and that handle file output and screen output in unified way .

stream is flow of characters other kind of .
If the flow is into your program , the stream is called an input stream .
If the flow is out of your program , the stream is called an output stream .
If the input Streams and Basic File stream flows from the keyboard , then your program will take input from the keyboard .
If the input stream flows from file , then your program will take its input from that file .
Similarly , an output stream can go to the screen or to file .

Although you may not realize it , you have already been using streams in your programs .
The cin that you have already used is an input stream connected to the keyboard , and cout is an output stream connected to the screen .
These two streams are automatically available to your program , as long as it has an include directive that names the header file iostream .
You can define other streams that come from or go to files ; once you have defined them , you can use them in your program in the same way you use the streams cin and cout .

For example , suppose your program defines stream called that comes from some file .

Similarly , if your program defines an output stream named that goes to another file , then you can output the value of this variable to this other file .
The following will output the string   followed by the contents of the variable to the output file that connected to the stream    endl ; Once the streams are connected to the desired files , your program can do file the same way it does using the keyboard and screen .

Why Use Files for .

The keyboard input and screen output we have used so far deal with temporary data .
When the program ends , the data typed in at the keyboard and the data left on the screen go away .
Files provide you with way to store data permanently .
The contents of file remain until person or program changes the file .
If your program sends its output to file , the output file will remain after the program has finished running .
An input file can be used over and over again by many programs without the need to type in the data separately for each program .

The input and output files used by your program are the same kind of files that you read and write with an editor , such as the editor you use to write your programs .
This means you can create an input file for your program or read an output file produced by your program whenever convenient for you , as opposed to having to do all your reading and writing while the program running .

When your program takes its input from large input file , the program receives lot of data without making the user do lot of typing .

File stream variable Declaring streams ifstream and ofstream When your program takes input from file , it said to be reading from the file ; when your program sends output to file , it said to be writing to the file .
There are other ways of reading input from file , but the method we will use reads the file from the beginning to the end as far as the program gets before .
Using this method , your program not allowed to back up and read anything in the file second time .
This exactly what happens when the program takes input from the keyboard , so this should not seem new strange .
It not allowed to back up and change any output that it has previously written to the file .
This exactly what happens when your program sends output to the screen .
You can send more output to the screen , but you cannot back up and change the screen output .
The way that you get input from file into your program send output from your program into file to connect the program to the file by means of stream .

In , stream special kind of variable known as an object .
We will discuss objects in the next section , but we will first describe how your program can use stream objects to do simple file .
If you want to use stream to get input from file give output to , you must declare the stream and you must connect the stream to the file .

You can think of the file that stream connected to as the value of the stream .
You can disconnect stream from one file and connect it to another file , so you can change the value of these stream variables .
However , you must use special functions that apply only to streams in order to perform these changes .
You cannot use stream variable in an assignment statement the way that you can use variable of type int char .
Although streams are variables , they are unusual sorts of variables .

The streams cin and cout are already declared for you , but if you want stream to connect to file , you must declare it just as you would declare any other variable .
The type for stream variables named ifstream .
The type for stream variables named ofstream .
Thus , you can declare to be an input stream for file and to be an output stream for another file as follows : ifstream .

This called opening the file and done with function named open .
For example , suppose you want the input stream connected to the file named .
Your program must then contain the following before it reads any input from this file : This may seem like rather strange syntax for function call .
We will have more to say about this peculiar syntax in the next section .
For now , just notice couple of details about how this call to open written .
First , the stream variable name and dot  placed before the function named open , and the file name given as an argument to open .

Also notice that the file name given in quotes .
The file name that given as an argument the same as the name you would use for the file if you wanted to write in it using the editor .
If the input file in the same directory as your program , you probably can simply give the name of the file in the manner just described .
In some situations you might also need to specify the directory that contains the file .
The details about specifying directories varies from one system to another .
If you need to specify directory , ask your instructor some other local expert to explain the details .

Once you have declared an input stream variable and connected it to file using the open function , your program can take input from the file using the extraction operator .
For example , the following reads two input numbers from the file connected to and places them in the variables number and : int ,

If the output file does already exist , the member function open will discard the contents of the file so that the output file is empty after the call to open .

After file is connected to the stream with call to open , the program can send output to that file using the insertion operator .
For example , the following writes two strings and the contents of the variables and to the file that is connected to the stream in this example is the file named :      Notice that when your program is dealing with file , it is as if the file had two names .
One is the usual name for the file that is used by the operating system .
This name is called the external file name .
In our sample code the external file names were and .
The external file name is in some sense the name " for the file .

The conventions for spelling these external file names vary from one system to another ; you will need to learn these conventions from your instructor from some other local expert .
The names and that we used in our examples might might not look like file names on your system .
You should name your files following whatever conventions your system uses .
Although the external file name is the real name for the file , it is typically used only once in program .
The external file name is given as an argument to the function open , but after the file is opened , the file is always referred to by naming the stream that is connected to the file .
Thus , within your program , the stream name serves as second name for the file .

The sample program in Display reads three numbers from one file and writes their sum , as well as some text , to another file .

File Has Two Names Every input and every output file used by your program has two names .

The external file name is the real name of the file , but it is used only in the call to the function open , which connects the file to stream .
After the call to open , you always use the stream name as the name of the file .

Every file should be closed when your program is finished getting input from the file or sending output to the file .
Closing file disconnects the stream from the file .
file is closed with call to the function close .
The following lines from the program in Display illustrate how to use the function close :

Notice that the function close takes no arguments .
If your program ends normally but without closing file , the system will automatically close the file for you .
However , it is good to get in the habit of closing files for at least two reasons .
First , the system will only close files for you if your program ends in normal fashion .
If your program ends abnormally due to an error , the file will not be closed and may be left in corrupted state .
If your program closes files as soon as it is finished with them , file corruption is less likely .
second reason for closing file is that you may want your program to send output to file and later read that output back into the program .
To do this , your program should close the file after it is finished writing to the file , and then your program should connect the file to an input stream using the function Display Simple File three numbers from the file , sums the numbers , writes the sum to the file .

Chapter Streams as an Introduction to Objects and Classes open .
An object is variable that has functions as well as data associated with it .
For example , the streams and both have function named open associated with them .
Two sample calls of these functions , along with the declarations of the objects and , are given .

There is reason for this peculiar notation .
The function named open that is associated with the object is different function from the function named open that is associated with the object .
One function opens file for input , and the other opens file for output .
Of course , these two functions are similar .
They both " When we give two functions the same name , it is because the two functions have some intuitive similarity .
However , these two functions named open are different functions , even if they may be only slightly different .
When the compiler sees call to function named open , it must decide which of these two functions named open you mean .
The compiler determines this by looking at the name of the object that precedes the dot , in this case , either or .
function that is associated with an object is called member function .
So , for example , open is member function of the object , and another function named open is member of the object .

As we have just seen , different objects can have different member functions .

These functions may have the same names , as was true of the functions named open , or they may have completely different names .
The type of an object determines which member functions the object has .
If two objects are of the same type , they may have different values , but they will have the same member functions .
For example , suppose you declare the following stream objects : ifstream , ofstream , The functions and are the same function .

Similarly , and are the same function they are different from the functions and .

type whose variables are as ifstream and is called class .
Since the member functions for an object are completely determined by its class is , by its , these functions are called member functions of the class well as being called members of the .
For example , the class ifstream has member function called open , and the class ofstream Streams and Basic File has different member function called open .
The class ofstream also has member function named precision , but the class ifstream has no member function named precision .
You have already been using the member function precision with the stream cout , but we will discuss it in more detail later .

When you call member function in program , you always specify an object , usually by writing the object name and dot before the function name , as in the following example : One reason for naming the object is that the function can have some effect on the object .
In the preceding example , the call to the function open connects the file to the stream , so it needs to know the name of this stream .

In function call , such as ; the dot is called the dot operator and the object named before the dot is referred to as the calling object .
In some ways the calling object is like an additional argument to the function can change the calling object as if it were an the calling object plays an even larger role in the function call .
The calling object determines the meaning of the function name .

The compiler uses the type of the calling object to determine the meaning of the function name .
For example , in the earlier call to open , the type of the object determines the meaning of the function name open .

Calling Member Function Syntax .

Classes and Objects An object is variable that has functions associated with it .
These functions are called member functions .
class is type whose variables are objects .
The class is , the type of the determines which member functions the object has .

The classes ifstream and ofstream each have member function named close .
They both " but they close them in different ways because the files were opened and were manipulated in different ways .
We will be discussing more member functions for the classes ifstream and ofstream later in this chapter .

For example , if you open an input file and there is no file with the external name that you specify , then the call to open will fail .
When this happens , you might not receive an error message and your program might simply proceed to do something unexpected .
Thus , you should always follow call to open with test to see whether the call to open was successful and end the program take some other appropriate if the call to open was unsuccessful .

You can use the member function named fail to test whether stream operation has failed .
There is fail member function for each of the classes ifstream and ofstream .
The fail function takes no arguments and returns bool value .
call to the function fail for stream named would be as follows : This is Boolean expression that can be used to control while loop or an statement .

You should place call to fail immediately after each call to open ; if the call to open fails , the function fail will return true is , the Boolean expression will be .
For example , if the following call to open fails , then the program will output an error message and end ; if the call succeeds , the fail function returns false , so the program will continue .

Of course , the call to refers only to call to open of the form , and not to any call to the function open made with any other stream as the calling object .

The exit statement causes your program to end immediately .
The exit function returns its argument to the operating system .
To use the exit statement , your program must contain the following directive : When using exit , your program must also contain the following , normally .

By convention , is used as the argument if the call to exit was due to an error , and is used For our purposes , it makes no difference what integer you use , but it pays to follow this convention since it is important in more advanced programming .

The exit Statement The exit statement is written ; When the exit statement is executed , the program ends immediately .

Any may be used , but by convention , is used for call to exit that is caused by an error , and is used in other cases .
The exit statement is call to the function exit , which is in the library with header file named cstdlib .
Therefore , any program that uses the exit statement must contain the following directives : using namespace .

They are placed in the same locations as similar directives we have UNIX and Windows use for error and for success , but other operating systems may reverse this convention .
You should ask your instructor what values to use .

Chapter Streams as an Introduction to Objects and Classes Display contains the program from Display rewritten to tests to see if the input and output files were opened successfully .
It processes files in exactly the same way as the program in Display .
In particular , assuming that the file exists and has the contents shown in Display , the program in Display will create the file that is shown in Display .
However , if there were something wrong and one of the calls to open failed , then the program in Display would end and send an appropriate error message to the screen .
For example , if there were no file named , then the call to would fail , the program would end , and an error message would be written to the screen .

Notice that we used to output the error message ; this is because we want the error message to go to the screen , as opposed to going to file .
Since this program uses to output to the screen well as doing file , we have added an directive for the header file iostream .

However , the programming style for file different from that for using the screen and keyboard .

When reading input from the keyboard , you should prompt for input and echo the input , like .

When your program takes its input from file , you should not such prompt lines or echoing of input , because there nobody there to read and respond to the prompt and echo .
When reading input from file , you must be certain the data in the file exactly the kind of data the program expects .
Your program then simply reads the input file assuming that the data it needs will be there when it requested .
If stream variable that connected to an input file and you wish to replace the previous shown with input from the file connected to , then you would replace those three lines with the following line : You may have any number of streams opened for input or for output .

Thus , single program can take input from the keyboard and also take input from one or more files .
The same program could send output to the screen and Streams and Basic File to one or more files .
Alternatively , program could take all of its input from the keyboard and send output to both the screen and file .
Any combination of input and output streams allowed .
Most of the examples in this book will use cin and to do using the keyboard and screen , but it easy to modify these programs so that the program takes its input from file sends its output to file .

Display File with Checks on open three numbers from the file , sums the .

Chapter Streams as an Introduction to Objects and Classes Summary of File Statements In this sample the input comes from file with the directory name infile .

For file For For exit Choose stream name for the input stream example , and declare it to be variable of type ifstream .
Choose stream name for the output .

Connect each stream to file using the member function open with the external file name as an argument .
Remember to use the member function fail to test that the call to open was successful :

For example :

Sel st Exerc .
Suppose you are writing program that uses stream called fin that will be connected to an input file , and stream called fout that will be connected to an output file .
How do you declare fin and fout .

What directive , if any , do you need to place in your program file .

Suppose you are continuing to write the program discussed in the previous exercise and you want it to take its input from the file .

What statements do you need to place in your program in order to connect the stream fin to the file and to connect the stream fout to the file .
Be sure to checks to make sure that the openings were successful .

Suppose that you are still writing the same program that we discussed in the previous two exercises and you reach the point at which you no longer need to get input from the file and no longer need to send output to the file .
How do you close these files .

Suppose you want to change the program in Display so that it sends its output to the screen instead of the file .

What directive do you need to place in your program file if your program uses the function exit .

Continuing Exercise , what does do with its argument .

Suppose bla is an object , dobedo is member function of the object bla , and dobedo takes one argument of type int .
How do you write call to the member function dobedo of the object bla using the argument .

What characteristics of files do ordinary program variables share .
What characteristics of files are different from ordinary variables in program .

program has read half of the lines in file .
What must the program do to the file to enable reading the first line second time .

In the text it says file has two " What are the two names .

Chapter Streams as an Introduction to Objects and Classes When sending output to file , your code must first use the member function open to open file and connect it to stream of type ofstream .
The way we have done that thus far single argument for the file always gives an empty file .
If file with the specified name already exists , its old contents are lost .
There is an alternative way to open file so that the output from your program will be appended to the file after any data already in the file .

To append your output to file named , you would use version of open , as illustrated by the following : ofstream outStream ; If the file does not exist , this will create an empty file with that name to receive your output , but if the file already exists , then all the output from your program will be appended to the end of the file so that old data in the file is not lost .
This is illustrated in Display .

Screen Output Opening for appending .

End of appending to file .

The second argument is special constant that is defined in iostream and so requires the following directive :

We did this by giving the file name as the argument to call to the function open , as in the following example : This can sometimes be inconvenient .
For example , the program in Display reads numbers from the file and outputs their sum to the file .
If you want to perform the same calculation on the numbers in another file named and write the sum of these numbers to another file named , then you must change the file names in the two calls to the member function open and then recompile your program .
preferable alternative is to write your program so that it asks the user to type in the names of the input and output files .
This way your program can use different files each time it is run .

Chapter Streams as an Introduction to Objects and Classes Appending to File If you want to append data to file so that it goes after any existing contents of the file , open the file as follows .

file name is string and we will not discuss string handling in detail until Chapter .
However , it is easy to learn enough about strings so that you can write programs that accept file name as input .
string is just sequence of characters .
We have already used string values in output statements such as the following : is ; We have also used string values as arguments to the member function open .

Whenever you write literal string , as in the statement shown , you must place the string in double quotes .

In order to read file name into your program , you need variable that is capable of holding string .
We discuss the details of strings in Chapter , but for now we will cover just enough to store file name .
variable to hold string value is declared as in the following example : char ; This declaration is the same as if you had declared the variable to be of type char , except that the variable name is followed by an integer in square brackets that specifies the maximum number of characters you can have in string stored in the variable .
This number must be one greater than the maximum number of characters in the string value .
So , in our example , the variable can contain any string that contains or fewer characters .

The name can be replaced by any other identifier is not , and the number can be replaced by any other positive integer .

You can input string value to string variable the same way that you input values of other types .
For example , consider the following piece of .

For example , the following will connect the stream to the whose name is stored in the variable will use the member function fail to check whether the opening was : String variables as arguments to .

Note that when you use string variable as an argument to the member function open , you do not use any quotes .

In Display we have rewritten the program in Display so that it takes its input from and sends its output to whatever files the user specifies .

The input and output names are read into the string variables name and and then these variables are used as the arguments in calls to the member function open .
Notice the declaration of the string variables .
You must number in square brackets after each string variable name , as we did in Display .

String variables are not ordinary variables and cannot be used in all the ways you can use ordinary variables .
In particular , you cannot use an assignment statement to change the value of string variable .

Richard Brinsley Sheridan , The School for Scandal Formatting Output with Stream Functions The layout of output is called the format of the output .
In you can control the format with commands that determine such details as the number of spaces between items and the number of digits after the decimal point .
You already used three output formatting instructions when you learned the formula for outputting dollar amounts of money in the usual way in Warning .

Chapter Streams as an Introduction to Objects and Classes three numbers from the specified by the user , sums the .

Enter the input file name of : Enter the output file name of : will read numbers from the file and place the sum in the file End of Program .

Before outputting amounts .

Now that learned about object notation for streams , we can explain this magic formula and few other formatting commands .

The first thing to note is that you can use these formatting commands on any output stream .
If your program is sending output to file that is connected to an output stream called , you can use these same commands to ensure that numbers with decimal point will be written in the way we normally write amounts of money .
Just insert the following in your program :

To explain this magic formula , we will consider the instructions in reverse order .

Every output stream has member function named precision .
When your program executes call to precision such as the previous one for the stream , then from that point on in your program , any number with decimal point that is output to that stream will be written with total of two significant figures , or with two digits after the decimal point , depending on when your compiler was written .
The following is some possible output from compiler that sets two significant digits :

call to precision applies only to the stream named in the call .
If your program has another output stream named , then the call to affects the output to the stream but has no effect on the stream .
Of course , you can also call precision with the stream ; you can even specify different number of digits for the numbers output to the stream , as in the following : The other formatting instructions in our magic formula are bit more complicated than the member function precision .
We now discuss these other instructions .
The following are two calls to the member function setf with the stream as the calling object : setf is an abbreviation for set flags .
flag is an instruction to do something in one of two possible ways .
If flag is given as an argument to setf , then the flag tells the computer to write output to that stream in some specific way .

What it causes the stream to do depends on the flag .

In the previous example , there are two calls to the function setf , and these two calls set the two flags and .
The flag causes the stream to output numbers of type double in what is called notation , which is fancy phrase for the way we normally write numbers .
If the flag is set call to , then all floatingpoint numbers as numbers of type that are output to that stream will be written in ordinary everyday notation , rather than .

Not set If this flag is set , decimal point and trailing zeros are always shown for numbers .
If it is not set , number with all zeros after the decimal point might be output without the decimal point and following zeros .

Not set If this flag is set , plus sign is output before positive integer values .

Not set If this flag is set and some value is given with call to the member function width , then the next item output will be at the right end of the space specified by width .
In other words , any extra blanks are placed before the item output .
In other words , any extra blanks are placed after the item output .
So if the number to be output has value of , then it will be output as and not simply as ; that is , the output will include the decimal point even if all the digits after the decimal point are .
Some common flags and the actions they cause are described in Display .

Another useful flag is .
If this flag is set for stream , then positive numbers output to that stream will be written with the plus sign in front of them .
If you want plus sign to appear before positive numbers , insert the following :

Chapter Streams as an Introduction to Objects and Classes .

The width function tells the stream how many spaces to use when giving an item as output .
In this case the item , the number occupies only one space , and width said to use four spaces , so three of the spaces are blank .

If the output requires more space than you specified in the argument to width , then as much additional space as is needed will be used .
The entire item is always output , no matter what argument you give to width .

call to width applies only to the next item that is output .
If you want to output numbers , using four spaces to output each number , then you must call width times .
If this becomes nuisance , you may prefer to use the manipulator setw that is described in the next subsection .

Any flag that is set may be unset .
To unset flag , you use the function unsetf .
For example , the following will cause your program to stop including plus signs on positive integers that are output to the stream  Flag Terminology Why are the arguments to setf , such as , called flags .

And what is meant by the strange notation .

The word flag is used for something that can be turned on or off .
The origin of the term apparently comes from some phrase similar to the flag is up , do " Or perhaps the term was the flag is down , do " Moreover , apparently nobody can recall what the exact originating phrase was because programmers now say the flag is set " and that does not conjure up any picture .
In any event , when the flag is set is , when it is an argument to , the stream that called the setf function will behave as described in Display ; when any other flag is set is , is given as an argument to , that signals the stream to behave as Display specifies for that flag .

The explanation for the notation : is rather mundane for such exotic notation .
The ios indicates that the meaning of terms such as fixed or showpoint is the meaning that they have when used with an input or output stream .
The notation : means the meaning of what follows the : in the context of what comes before the " We will say more about this : notation later in this book .

In turn , the manipulator function calls member function .
Manipulators are placed after the insertion operator , just as if the manipulator function call were an item to be output .
Like traditional functions , manipulators may or may not have arguments .
We have already seen one manipulator , endl .
In this subsection we will discuss two manipulators called and setprecision .

The manipulator and the member function width you have already do exactly the same thing .
You call the manipulator by writing it after the insertion operator , as if it were to be sent to the output stream , and this in turn calls the member function width .
For example , the following outputs the numbers , and , using the field widths specified :

However , call to is written after the insertion operator , in manner similar to how you call the manipulator .
For example , the following outputs the numbers listed using the number of digits after the decimal point that are indicated by the call to .

To use either of the manipulators or  you must the following directive in your program :

Chapter Streams as an Introduction to Objects and Classes Sel es Exe rc is .
What output will be produced when the following lines are executed the lines are embedded in complete and correct program with the proper .

What output will be sent to the file when the following lines .

In formatting output , the following flag constants are used with the stream member function setf .

What changes are necessary to make the output .

Chapter Streams as an Introduction to Objects and Classes Streams as Arguments to Functions Stream parameters must be stream can be an argument to function .
The only restriction is that the function formal parameter must be .
stream parameter cannot be parameter .
For example , the function in Display has two stream parameters : one is of type ifstream and is for stream connected to an input file ; another is of type ofstream and is for stream connected to an output file .
We will discuss the other features of the program in Display in the next two subsections .

When you write program that takes its input from file , you will often want the program to read all the data in the file .
For example , if the file contains numbers , you might want your program to calculate the average of all the numbers in the file .
Since you might run the program with different data files at different times , the program cannot assume it knows how many numbers are in the file .
You would like to write your program so that it keeps reading numbers from the file until there are no more numbers left to be read .
If is stream connected to the input file , then the algorithm for computing this average can be stated as follows : double next ,

This algorithm is already almost all code , but we still must express the following test in : Even though it may not look correct at first , one way to express the aforementioned test is the following : The previous algorithm can thus be rewritten as the following code one last line in pseudocode that is not the issue : Tools for Stream output formatting instructions .

Chapter Streams as an Introduction to Objects and Classes iostream , fstream , and .

Notice that the loop body is not identical to what it was in our pseudocode .

Since is now in the Boolean expression , it is no longer in the loop body .

This loop may look bit peculiar , because is both the way you input number from the stream and the controlling Boolean expression for the while loop .
An expression involving the extraction operator is simultaneously both an action and Boolean It is an instruction to take one input number from the input stream , and it is also Boolean expression that is either satisfied or not .
If there is another number to be input , then the number is read and the Boolean expression is satisfied , so the body of the loop is executed one more time .
If there are no more numbers to be read in , then nothing is input and the Boolean expression is not satisfied , so the loop ends .
In this example the type of the input variable was double , but this method of checking for the end of the file works the same way for other data types , such as int and char .

This is an admirable goal , but now we have whose parameter type is in namespace .
In our immediate examples we need the stream type names that are in the namespace std .
Thus , we need using directive outside of the function definition body so that will understand the parameter type names , such as ifstream .
The easiest fix is to simply place one using directive at the start of the file the include .

Placing single using directive at the start of file is the easiest solution to our problem , but many experts would not consider it the best solution , since it would not allow the use of two namespaces that have names in common , and that is the whole purpose of namespaces .
At this point we are Technically , the Boolean condition works this way : The overloading of operator for the input stream classes is done with functions associated with the stream .
This function is named operator .
The return value of this operator function is an input stream reference or .
function is provided that automatically converts the stream reference to bool value .
The resulting value is true if the stream is able to extract data , and false otherwise .

Chapter Streams as an Introduction to Objects and Classes only using the namespace so there is no problem .
In Chapter , we will teach you another way around this problem with parameters and namespaces .

This other approach will allow you to use any kinds of multiple namespaces .

Many programmers prefer to place using directives at the start of the program file .
For example , consider the following using directive : using namespace std ; Many of the programs in this book do not place this using directive at the start of the program file .
Instead , this using directive is placed at the start of each function definition that needs the namespace std after the opening .
An example of this is shown in Display .
An even better example is shown in Display .
All of the programs that have appeared so far in this book , and almost all programs that follow , would behave exactly the same if there were just one using directive for the namespace std and that one using directive were placed immediately after the include directives , as in Display .
For the namespace std , the using directive can safely be placed at the start of the file almost all .
For some other namespaces , single using directive will not always suffice , but you will not see any of these cases for some time .

We advocate placing the using directives inside function definitions inside some other small units of so that it does not interfere with any other possible using directives .
This trains you to use namespaces correctly in preparation for when you write more complicated code later in your programming career .
In the meantime , we sometimes violate this rule ourselves when following the rule becomes too burdensome to the other issues we are discussing .
If you are taking course , do whatever your instructor requires .

Otherwise , you have some latitude in where you place your using directives .

Programming Example Cleaning Up File Format The program in Display takes its input from the file and writes its output , in neat format , both to the screen and to the file .

The program copies numbers from the file to the file , but it uses formatting instructions to write them in neat way .
The numbers are written one per line in field of width , which means that each number is preceded by enough blanks so that the blanks plus the number occupy spaces .
The numbers are written in ordinary notation ; that is , they are not written in .
Each number is written with five digits after the decimal We are actually using two namespaces : the namespace std and namespace called the global namespace , which is namespace that consists of all names that are not in some other namespace .
But this technical detail is not big issue to us now .

The output to the screen is the same as the output to the file , except that the screen output has one extra line that announces that the program is ending .
The program uses function , named , that has formal parameters for the stream and the stream .

Sel st Exerc is .
What output will be produced when the following lines are executed , assuming the file contains the data shown assuming the lines are embedded in complete and correct program with the proper include .

The file contains the following three numbers nothing .
Write the definition for void function called .
The function has one formal parameter called , which is of type ifstream .
The precondition and postcondition for the function are as follows : The stream has been connected file with call to the member function open .
The contains list of integers nothing .

Hamlet : Words , words , words .

William Shakespeare , Hamlet All data is input and output as character data .
When your program outputs the number , it is really the two characters ' and ' that are output .

Similarly , when the user wants to type in the number , he or she types in the character ' followed by the character .
Whether the computer interprets this as two characters or as the number depends on how your program is written .
But , however your program is written , the computer hardware is always reading the characters ' and , not the number .
This conversion between characters and numbers is usually done automatically so that you need not think about such detail .
Sometimes , however , all this automatic help gets in the way .
Therefore , provides some facilities for input and output of character data .
These facilities no automatic conversions .
This allows you to bypass the automatic facilities and do output in absolutely any way you want .
You could even write input and output functions that read and write numbers in Roman numeral notation , if you wanted to be so perverse .

The Member Functions get and put The function get allows your program to read in one character of input and store it in variable of type char .
Every input stream , whether it is an inputfile stream or the stream cin , has get as member function .
We will describe get as member function of the stream cin , but it behaves in exactly the same way for streams as it does for cin , so you can apply all that we say about get to streams as well as to the stream cin .

Before now , we have used cin with the extraction operator in order to read character of input any other input , for that .
When you use the extraction operator , as we have been doing , some things are done for you automatically , such as skipping blanks .

If you want , for example , to skip over blanks using , you must write code to read and discard the blanks .

That argument receives the input character that is read from the input stream .
For example , the following reads in the input character from the keyboard and stores it in the variable : char ; It is important to note that your program can read any character in this way .

If the input character is blank , this code will not skip over the blank , but will read the blank and set the value of equal to the blank character .
If the character is the character , that is , if the program has just reached the end of an input  then the call to shown earlier sets the value of equal to .

Although we write it as two symbols , is just single character in .

With the member function get , the character ' can be input and output just like any other character .
For example , suppose your program contains the following code : Reading blanks .

As you would expect , the value of is set to ' and the value of is set to .
When this code is executed on the input we showed , the value of is set to ; that is , the value of is set equal to the character .
The variable is not set equal to .

One thing you can do with the member function get is to have your program detect the end of .
The following loop will read of input and stop after passing the character .
Then , any subsequent input will be read from the beginning of the .
For this first example , we have simply echoed the input , but the same technique would allow you to do whatever you want with the input : of input and will echo .

This loop will read any of input and echo it exactly , including blanks .
The following is sample dialogue produced by this code : Enter of input and will echo it : Do Be Do Do Be Do all for this demonstration .

Notice that the character ' is both read and output .
Since ' is output , the string that begins with the word " is on .

The Member Function get Every input stream has member function named get that can be used to read one character of input .
Unlike the extraction operator , get reads the next input character , no matter what that character is .
In particular , get reads blank or the character ' if either of these is the next input character .
The function get takes one argument , which should be variable of type char .
When get is called , the next input character is read and the argument variable has its value set equal to this input character .

If you wish to use get to read from file , you use an stream in place of the stream cin .
For example , if is an input stream for file , then the following reads one character from the input file and places the character in the char variable : Before you can use get with an stream such as , your program must first connect the stream to the input file with call to open .

On the other hand , is string that happens to be made up of exactly one character .
Thus , is not of type char and cannot be stored in variable of type char .

The member function put is analogous to the member function get except that it is used for output rather than input .
The member function put takes one argument , which should be an expression of type char , such as constant or variable of type char .
The value of the argument is output to the stream when the function is called .
For example , the following outputs the letter ' to the screen : The function does not allow you to do anything you could not do by using the methods we discussed previously , but we it for completeness .

If your program uses or , then just as with other uses of cin and  your program should the following directive : Similarly , if your program uses get for an stream or put for an .

When the member function put is called , the value of its argument is output to the output stream .

If you wish to use put to output to file , you use an stream in place of the stream .
For example , if is an output stream for file , then the following will output the character ' to the file connected to : Before you can use put with an stream , such as , your program must first connect the stream to the output file with call to the member function open .

When using either of these directives , your program must also the following : using namespace std ; Sometimes your program needs to know the next character in the input stream .

However , after reading the next character , it might turn out that you do not want to process that character and so you would like to simply put it back in the input stream .
For example , if you want your program to read up to but not including the first blank it encounters in an input stream , then your program must read that first blank in order to know when to stop then that blank is no longer in the stream .
Some other part of your program might need to read and process this blank .
There are number of ways to deal with this sort of situation , but the easiest is to use the member function putback .
The function putback is member of every input stream .
It takes one argument of type char and it places the value of that argument back in the input stream .
The argument can be any expression that evaluates to value of type char .

For example , the following code will read characters from the file connected to the input stream fin and write them to the file connected to the output stream fout .

The code reads characters up to , but not including , the first blank it encounters .

Notice that after this code is executed , the blank that was read is still in the input stream fin , because the code puts it back after reading it .

Notice that putback places character in an input stream , while put places character in an output stream .
The character that is put back into the input stream with the member function putback need not be the last character read ; it can be any character you wish .
If you put back character other than the last character read , the text in the input file will not be changed by putback , although your program will behave as if the text in the input file had been changed .

Programming Example Checking Input If user enters incorrect input , the entire run of the program can become worthless .
To ensure that your program is not hampered by incorrect input , you should use input functions that allow the user to reenter input until the input is correct .
The function in Display asks the user whether the input is correct and asks for new if the user says the input is incorrect .

The program in Display is just driver program to test the function int , but the function , or one very similar to it , can be used in just about any kind of program that takes its input from the keyboard .

Notice the call to the function .
The function reads all the characters on the remainder of the current line but does nothing with them .
This amounts to discarding the remainder of the line .
Thus , if the user types in No , then the program reads the first letter , which is , and then calls the function , which discards the rest of the input line .
This means that if the user types on the input line , as shown in the sample dialogue , the program will read the number and will not attempt to read the letter in the word No .
If the program did not call to the function , then the item read would be the in the line containing No instead of the number on the following line .

Chapter Streams as an Introduction to Objects and Classes .

Sample Dialogue Enter input number : You entered .

If the input is not correct , the user is supposed to type No some variant such as , which will cause one more iteration of the loop .
However , rather than checking to see if the user types word that starts with , the loop checks to see if the first letter of the response is not equal to ' not equal to the lowercase version of .
As long as the user makes no mistakes and responds with some form of Yes or No , but never with anything else , then checking for No or checking for not being Yes are the same thing .
However , since the user might respond some other way , checking for not being Yes is safer .
To see why this is safer , suppose the user makes mistake entering the input number .
The computer echoes the number and asks if it is correct .
The user should type No , but suppose the user makes mistake and types Bo , which is not unlikely since ' is right next to ' on the keyboard .
Since ' is not equal to , the body of the loop will be executed , and the user will be given chance to reenter the input .

But , what happens if the correct response is Yes and the user mistakenly enters something that begins with letter other than ' or .
In that case , the loop should not iterate , but it does iterate one extra time .
This is mistake , but not nearly as bad mistake as the one discussed the last paragraph .
It means the user must type the input number one extra time , but it does not waste the entire run of the program .
When checking input , it is better to risk an extra loop iteration than to risk proceeding with incorrect input .

common problem when using get is forgetting to dispose of the ' that ends every input .
If there is newline character the input stream that is not read usually , then when your program next expects to read " using the member function get , it will instead read the character .
To clear the input stream of any leftover ' characters , you can use the function , which we defined Display .
look at concrete example .

It is legal to mix the different forms of cin .
For example , the following is .

However , if you expect the value of the variable to be , you will be disappointed .

The value given to is .
After reading the number , the next character the input stream is the character , and so that is read next .
Remember , get does not skip over breaks and spaces .
Once the variable is filled with the character , the program proceeds to whatever statement is next the program .
If the next statement sends output to the screen , the screen will be filled with Either of the following rewritings of the previous code will cause the previous dialogue to fill the variable number with and fill the variable with .

However , an stream , even if used as an argument of type istream , must still be declared to be of type ifstream an .

However , an stream , even if used as an argument of type ostream , must still be declared to be of type ofstream .
You cannot open or close stream parameter of type istream or ostream .
Open these objects before passing them to your function and close them after the call .

PROGRAMMING EXAMPLE Another Function As another example of how you can make stream function more versatile , consider the function Display .
That function works only for input from the keyboard , which is input from the predefined stream cin .
The function Display has no arguments .
Below we have rewritten the function so that it has formal parameter of type istream for the input .

If your program is taking input from an input stream called fin is connected to an input , the following will discard all the input left on the currently being read from the input file : On the other hand , if your program is also reading some input from the .

But thanks to overloading , you can have both versions of the function in the same program : the with Using both versions of .

Chapter Streams as an Introduction to Objects and Classes no arguments that is given in Display and the with one argument of type istream that we just defined .
In program with both definitions of , the following two calls are equivalent :

You do not really need two versions of the function .
The with one argument of type istream can serve all your needs .
However , many programmers find it convenient to have with no arguments for keyboard input , since keyboard input is used so frequently .

VideoNote Default Arguments An alternative to having two versions of the function is to use default arguments .
In the following code , we have rewritten the function third time :

This facility is available to us with any argument type and any number of arguments .

If some parameters are provided default arguments and some are not , the formal parameters with default arguments must all be together at the end of the argument list .
If you provide several defaults and several nondefault arguments , the call may provide either as few arguments as there are nondefault arguments or more arguments , up to the number of parameters .

The arguments will be applied to the parameters without default arguments in order , and then will be applied to the parameters with default arguments up to the number of parameters .

The output is Next , consider , This call supplies the nondefault arguments and the first default argument , and the last argument uses the default .
This call gives the following output : The call , assigns all the arguments from the argument list and gives the following output : Sel st Exerc is .
Suppose c is variable of type char .
What is the difference between the following two statements .

Chapter Streams as an Introduction to Objects and Classes .

Does the that is put back have to be the last input from the stream .
For example , if your program reads an ' from the input stream , can it use the putback function to put back , or can it only put back an .

Consider the following code assume that it is embedded in complete and correct program and then .

Enter line of input :
Consider the following code assume that it is embedded in .

Enter line of input : abcdef gh Character .
Suppose that the program described in Exercise is run and the dialogue begins as follows of beginning as shown in Exercise .
What will be the line of output .

Enter line of input :
Consider the following code assume that it is embedded in .

Enter line of input : Define function called that takes one argument that is an input stream .
When called , will read one character of input from the input stream given as its argument and will write that character to the screen .
You should be able to call your function using either cin or an stream as the argument to your function .

When called , reads one line of input from the input stream given as its argument and writes that line to the screen .

You should be able to call your function using either cin or an stream as the argument to your function .

Chapter Streams as an Introduction to Objects and Classes is an stream , then the stream is connected to file before the function is called , so will not open or close any For example , the first of the following two calls to will copy line from the file to the screen , and the second will copy line from the keyboard to the .

When called , reads one line of input from the keyboard and outputs the line to the output stream given as its argument .

You should be able to call your function using either or an outputfile stream as the argument to your function .

This is the second technique we have presented for determining when program has read everything in file .

The letters eof stand for end of file , and eof is normally pronounced by saying the three letters .
The function eof takes no arguments , so if the input stream is called fin , then call to the function eof is written This is Boolean expression that can be used to control while loop , dowhile loop , or an statement .
This expression is satisfied is , is if the program has read past the end of the input file ; otherwise , the expression above is not satisfied is , is .

Since we usually want to test that we are not at the end of file , call to the member function eof is typically used with not in front of it .
Recall that in the symbol .
For example , consider the following statement : eof is usually .

The statement will output the following , if the program has read beyond the end of the file : End of the file .

As another example of using the eof member function , suppose that the input stream has been connected to an input file with call to open .
Then the entire contents of the file can be written to the screen with the following while loop :

Ending an input loop with the eof function Chapter Streams as an Introduction to Objects and Classes This while loop reads each character from the input file into the char variable using the member function get , and then writes the character to the screen .
After the program has passed the end of the file , the value of changes from false to true .
So , changes from true to false and the loop ends .

Notice that does not become true until the program attempts to read one character beyond the end of the file .
For example , suppose the file contains the following any after the : ab c This is actually the following list of four characters : character Deciding how to test for the end of an input file This loop reads an ' and writes it to the screen , then reads ' and writes it to the screen , then reads the character ' and writes it to the screen , and then reads ' and writes it to the screen .
At that point the loop will have read all the characters in the file .
However , will still be false .
The value of will not change from false to true until the program tries to read one more character .
That is why the while loop ends with .
The loop needs to read one extra character in order to end the loop .

There is special marker at the end of file .
The member function eof does not change from false to true until this marker is read .
why the example while loop could read one character beyond what you think of as the last character in the file .
However , this marker is not an ordinary character and should not be manipulated like an ordinary character .
You can read this marker but you should not write it out again .
If you write out the marker , the result is unpredictable .
The system automatically places this marker at the end of each file for you .

The next Programming Example uses the eof member function to determine when the program has read the entire input file .

You now have two methods for detecting the end of file .
You can use the eof member function or you can use the method we described in the Programming Tip entitled for the End of " In most situations you can use either method , but many programmers use the two different methods in different situations .
If you do not have any other reason to prefer one of these two methods , then use the following general rule : Use the eof member function when you are treating the input as text and reading the input with the get member function ; use the other method when you are processing numeric data .

Suppose ins is file input stream that has been connected to file with the member function open .
Suppose your program has just read the last character in the file .
At this point , would evaluate to true or false .

Write the definition for void function called that has one formal parameter called that is of type ifstream .
The precondition and postcondition for the function are as follows : The stream has been connected file with call to the member function open .

Programming Example Editing Text File The program discussed here is very simple example of text editing applied to files .
It might be used by software firm to update its advertising literature .

The firm has been marketing compilers for the programming language and has recently introduced of compilers .
This program can be used to automatically generate advertising material from the existing advertising material .
The program takes its input from that contains advertising copy that says good things about and writes similar advertising copy about in another .
The that contains the advertising copy is called , and the new that receives the advertising copy is called .
The program is shown in Display .

The program simply reads every character in the and copies the characters to the .
Every character is copied unchanged , except that when the uppercase letter ' is read from the input  the program writes the string " to the output .
This program assumes that whenever the letter ' occurs in the input  it names the programming language ; thus , this change is exactly what is needed to produce the updated advertising copy .

Notice that the breaks are preserved when the program reads characters from the input and writes the characters to the output .
The character ' is treated just like any other character .
It is read from the input with the member function get , and it is written to the output using the insertion operator .

Chapter Streams as an Introduction to Objects and Classes read the input .
If we instead use the extraction operator to read the input , the program would skip over all the whitespace , which means that none of the blanks and none of the characters ' would be read from the input  so they would not be copied to the output .

Also notice that the member function eof is used to detect the end of the input and end the while loop .

Predefined Character Functions In text processing , you often want to convert lowercase letters to uppercase or vice versa .
The predefined function toupper can be used to convert lowercase letter to an uppercase letter .
For example , returns .
If the argument to the function toupper is anything other than lowercase letter , also returns .
The function tolower is similar except that it converts an uppercase letter to its lowercase version .

The functions toupper and tolower are in the library with the header cctype , so any program that uses these functions , or any other functions in this library , must contain the following directive : to create called that is identical to the , except that all occurrences of ' are replaced by .

There is no language as versatile as , and is fun to use .

There is no language as versatile as , and is fun to use .

Screen Output Begin editing files .

End of editing files .

Chapter Streams as an Introduction to Objects and Classes Display contains descriptions of some of the most commonly used functions in the library cctype .

The function isspace returns true if its argument is whitespace character .

If the argument to isspace is not whitespace character , then isspace returns false .
Thus , returns true and returns false .

For example , the following code reads sentence terminated with period and echoes the string with all whitespace characters replaced with the symbol .

Each character is assigned number , and when the character is stored in variable of type char , it is this number that is placed in the memory .
In you can use value of type char as example , by placing it in variable of type int .
You can also store number of type int in variable of type char the number is not too .
Thus , the type char can be used as the type for characters or as type for small whole numbers .

Usually you need not be concerned with this detail and can simply think of values of type char as being characters and not worry about their use as numbers .
However , when using the functions in cctype , this detail can be important .
The functions toupper and tolower actually return values of type int rather than values of type char ; that is , they return the number corresponding to the character we think of them as returning , rather than the character itself .
Thus , the following will not output the letter , but will instead output the number that is assigned to :

is an uppercase letter ; otherwise , returns false .

Returns true provided is lowercase letter ; otherwise , returns false .

is letter of the alphabet ; otherwise , returns false .

Returns true provided is one of the digits ' through ; otherwise , returns false .

Returns true provided is whitespace character , such as the blank or symbol ; otherwise , returns false .

Chapter Streams as an Introduction to Objects and Classes In order to get the computer to treat the value returned by toupper or tolower as value of type char opposed to value of type , you need to indicate that you want value of type char .
One way to do this is to place the value returned in variable of type char .
The following will output the character , which is usually what we want : char ;

Consider the following code assume that it is embedded in complete and correct program and then : of .

Enter of input : see you at AM .

Write some code that will read of text and echo the with all uppercase letters deleted .

Chapter Summary stream of type ifstream can be connected to file with call to the member function open .
Your program can then take input from that file .

Answers to Exercises An object is variable that has functions associated with it .
These functions are called member functions .
class is type whose variables are objects .

stream is an example of an object .
The types ifstream and ofstream are examples of classes .

An example with the stream as the calling object and precision as the .

These output functions work the same for the stream  which is connected to the screen , and for output streams connected to files .

The member function get does not skip over whitespace .
Every output stream also has member function named put that can be used to write one character to the output stream .

The member function eof works well for text processing .
However , when processing numeric data , you might prefer to test for the end of file by using the other method we discussed in this chapter .

The type ifstream can be used for an stream , and the type ofstream can be used for an stream .
If you use ostream without the as the type for an output stream parameter , then the argument corresponding to that formal parameter can be either the stream or an stream of type ofstream with the .

Answe rs to est Exer cises .

You need to replace the stream with the stream .
Note that you do not need to declare  you do not need to call open with  and you do not need to close .

By convention , the operating system uses as an indication of error status and as an indication of success .
What is actually done is .

Both files and program variables store values and can have values retrieved from them .
Program variables exist only while the program runs , whereas files may exist before program is run and may continue to exist after program stops .
In short , files may be permanent ; variables are not .
Files provide the ability to store large quantities of data , whereas program variables do not provide quite so large store .

We have seen the open , close , and fail member functions at this point .

The following illustrate their use .

This is the over " the text describes at the beginning of this chapter .

The file must be closed and opened again .
This action puts the read position at the start of the file , ready to be read again .

The two names are the external file name and the stream name .
The external file name is the one used by the operating system .
It is the real name of the file , but it is used only in the call to the function open , which connects the file to stream .
The stream name is stream variable of type ifstream or .
After the call to open , your program always uses the stream name as the name of the file .

Notice that call to width or call to setw only lasts for one output item .

Each of the other spaces contains exactly two blank characters .

Chapter Streams as an Introduction to Objects and Classes .
The output to the file will be exactly the same as the output given in the answer to Exercise .

Setting this flag causes numbers not to be displayed in , that is , not in scientific notation .
Setting this flag unsets .

Setting this flag causes numbers to be displayed in , that is , in scientific notation .
Setting this flag unsets .

Setting this flag causes the decimal point and trailing zeros to be always displayed .

Setting this flag causes plus sign to be output before positive integer values .

Setting this flag causes subsequent output to be placed at the right end of any field that is set with the width member function .

That is , any extra blanks are put before the output .
Setting this flag unsets .

Setting this flag causes subsequent output to be placed at the left end of any field that is set with the width member function .

That is , any extra blanks are put after the output .
Setting this flag unsets .

You need to replace outstream with and delete the open and close calls for outstream .
You do not need to declare  open  or close The directive has all the iostream members you need for screen , though it does no harm , and may make the program clearer , to .

The two statements are equivalent .
Both of the statements output the value of the variable c .

The character that is back " into the input stream with the member function putback need not be the last character read .
If your program reads an ' from the input stream , it can use the putback function to put back .
The complete dialogue is Enter line of input : c END OF OUTPUT .
The complete dialogue is Enter line of input : abcdef gh ace Note that the output is simply every other character of the input , and note that the blank is treated just like any other character .

The complete dialogue is Enter line of input : Be sure to note that only the ' in the input string is output .
This is because is reading characters , not numbers , and so it reads the input as the two characters , and .
Since this code is written to echo only every other character , the ' is not output .
Since the ' is not output , the character , which is blank , is output , and so there is one blank in the output .
Similarly , only one of the two ' characters in is output .
If this is unclear , write the input on sheet of paper and use small square for the blank character .
Then , cross out every other character ; the output shown above is what is left .

Chapter Streams as an Introduction to Objects and Classes .
This code contains an infinite loop and will continue as long as the user continues to give it input .
The Boolean expression is always true because is filled via the statement cin  and this statement always skips the character ' well as any .
The code will run and if the user gives no additional input , the dialogue will be as follows : Enter of input : Notice that the code in Exercise used , so it reads every character , whether the character is blank or not , and then it outputs every other character .
So the code in Exercise outputs every other character even if the character is blank .
On the other hand , the code in this Exercise uses cin and , so it skips over all blanks and considers only nonblank characters in this case are the digits ' through .
Thus , this code outputs every other nonblank character .
The two ' characters in the output are the first character in the input and the first character in the input .

The complete dialogue is as follows : Enter of input : see you at AM .

see you at OF OUTPUT .

Chapter Streams as an Introduction to Objects and Classes Note that you should use and not use .

This is because is false if contains character that is not letter as the blank or comma .

Practice Programs Practice Programs can generally be solved with short program that directly applies the programming principles presented in this chapter .

Write program that will search file of numbers of type int and write the largest and the smallest numbers to the screen .
The file contains nothing but numbers of type int separated by blanks or breaks .
If this is being done as class assignment , obtain the file name from your instructor .

Write program that takes its input from file of numbers of type double and outputs the average of the numbers in the file to the screen .
The file contains nothing but numbers of type double separated by blanks breaks .
If this is being done as class assignment , obtain the file name from your instructor .

The median is the number that has the same number of data elements greater than the number as there are less than the number .
For purposes of this problem , you are to assume that the data is sorted is , is in increasing .
The median is the middle element of the file if there are an odd number of elements , or the average of the two middle elements if the file has an even number of elements .
You will need to open the file , count the elements , close the file and calculate the location of the middle of the file , open the file again the over " discussion in this , count up to the file entries you need , and calculate the middle .

If your instructor has assigned this problem , ask for data file to test your program with .
Otherwise , construct several files on your own , including one with an even number of data points , increasing , and one with an odd number , also increasing .

Find the three quartiles for the data file you used for part .

You also should recognize that you have done almost all the work toward finding Practice Programs .
Write program that takes its input from file of numbers of type double .

The program outputs to the screen the average and standard deviation of the numbers in the file .
The file contains nothing but numbers of type double separated by blanks breaks .
The standard deviation of list of numbers , and so forth is defined as the square root of the average of the following numbers : and so forth The number is the average of the numbers , and so forth .

If this is being done as class assignment , obtain the file name from your instructor .

Write program that gives and takes advice on program writing .
The program starts by writing piece of advice to the screen and asking the user to type in different piece of advice .
The program then ends .
The person to run the program receives the advice given by the person who last ran the program .
The advice is kept in file , and the contents of the file change after each run of the program .
You can use your editor to enter the initial piece of advice in the file so that the first person who runs the program receives some advice .
Allow the user to type in advice of any length so that it can be any number of lines long .
The user is told to end his or her advice by pressing the Return key two times .
Your program can then test to see that it has reached the end of the input by checking to see when it reads two consecutive occurrences of the character .

Write program that reads text from one file and writes an edited version of the same text to another file .
The edited version is identical to the unedited version except that every string of two or more consecutive blanks is replaced by single blank .
Thus , the text is edited to remove any extra blank characters .
Your program should define function that is called with the and streams as arguments .
If this is being done as class assignment , obtain the file names from your instructor .

Write program that merges the numbers in two files and writes all the numbers into third file .
Your program takes input from two different files and writes its output to third file .
Each input file contains list of numbers of type int in sorted order from the smallest to the largest .
After the program is run , the output file will contain all the numbers in the two input files in one longer list in sorted order from smallest to largest .
Your program should define function that is called with the two streams and the stream as three arguments .
If this is being done as class assignment , obtain the file names from your instructor .

Chapter Streams as an Introduction to Objects and Classes Programming Projects Programming Projects require more than Practice Programs and can usually be solved many different ways .
Visit to complete many of these Programming Projects online and get instant feedback .

Write program to generate personalized junk mail .
The program takes input both from an input file and from the keyboard .
The input file contains the text of letter , except that the name of the recipient is indicated by the three characters .
The program asks the user for name and then writes the letter to second file but with the three letters replaced by the name .
The string will occur exactly once in the letter .

When it encounters the three letters , it then sends output to the screen asking for the name from the keyboard .

You should be able to figure out the rest of the details .
Your program should define function that is called with the and Harder version material in the optional section Names as : Allow the string to occur any number of times in the file .

In this case , the name is stored in two string variables .
For this version , assume that there is first name and last name but no middle names or initials .

Write program to compute numeric grades for course .
The course records are in file that will serve as the input file .
The input file is in exactly the following format : Each line contains last name , then one space , then the first name , then one space , then ten quiz scores all on one line .

The quiz scores are whole numbers and are separated by one space .
Your program will take its input from this file and send its output to second file .

The data in the output file will be the same as the data in the input file except that there will be one additional number type at the end of each line .
This number will be the average of the ten quiz scores .
If this is being done as class assignment , obtain the file names from your instructor .

Use at least one function that has file streams as all or some of its arguments .

This amounts to giving the student for any missed quiz .

Programming Projects output file will contain line at the beginning of the file explaining the output .
Use formatting instructions to make the layout neat and easy to read .

Use at least two functions that have file streams as all or some of their arguments .
If this is being done as class assignment , obtain the file names from your instructor .

Write program that will compute the average word length number of characters per for file that contains some text .
word is defined to be any string of symbols that is preceded and followed by one of the following at each end : blank , comma , period , the beginning of line , or the end of line .
Your program should define function that is called with the stream as an argument .
This function should also work with the stream cin as the input stream , although the function will not be called with cin as an argument in this program .
If this is being done as class assignment , obtain the file names from your instructor .

Write program that will correct program that has errors in which operator , or , it uses with cin and cout .
The program replaces each occurrence of cin with the corrected version cin and each occurrence of cout with the corrected version cout For an easier version , assume that there is always exactly one blank space between any occurrence of cin and following , and similarly assume that there is always exactly one blank space between each occurrence of cout and following .

For harder version , allow for the possibility that there may be any number of blanks , even zero blanks , between cin and and between cout and .
In this harder case , the replacement corrected version has only one blank between the cin or cout and the following operator .
The program to be corrected is in one file and the corrected version is output .

Chapter Streams as an Introduction to Objects and Classes to second file .
Your program should define function that is called with the and streams as arguments .

If this is being done as class assignment , obtain the file names from your instructor and ask your instructor whether you should do the easier version or the harder version .

Write program that allows the user to type in any question and then answers that question .
The program will not really pay any attention to the question , but will simply read the question line and discard all that it reads .
It always gives one of the following answers : not sure , but think you will find the answer in Chapter .

That question has puzzled philosophers for centuries .

just machine .

Think about it and the answer will come to you .

used to know the answer to that question , but forgotten it .

The answer can be found in secret place in the woods .

These answers are stored in file answer per , and your program simply reads the next answer from the file and writes it out as the answer to the question .
After your program has read the entire file , it simply closes the file , reopens the file , and starts down the list of answers again .

Whenever your program outputs the first answer , it should replace the two symbols with number between and the possibility of and .
In order to choose number between and , your program should initialize variable to and decrease the value by each time it outputs number so that the chapter numbers count backward from to .
When the variable reaches the value , your program should change its value back to .
Give the number the name with global named constant declaration using the const modifier .

This project is the same as Programming Project , except that in this project your program will use more sophisticated method for choosing the answer to question .
When your program reads question , it counts the number of characters in the question and stores the number in variable named count .
It then responds with answer number count .
The first answer in the file is answer number , the next is answer number , then , and so forth .

Assume that the answer listed first in the file will always be the following , even if the answer file is changed : not sure , but think you will find the answer in Chapter .

When replacing the two characters with number , use the number + where count is the variable discussed above , and is global named constant defined to be equal to the number of chapters in this book .

This program numbers the lines found in text file .
Write program that reads text from file and outputs each line to the screen and to another file preceded by line number .
Print the line number at the start of the line and in field of three spaces .
Follow the line number with colon , then one space , then the text of the line .
You should get character at time and write code to ignore leading blanks on each line .
You may assume that the lines are short enough to fit within line on the screen .

Otherwise , allow default printer or screen output behavior if the line is too long is , wrap or .

somewhat harder version determines the number of spaces needed in the field for the line numbers by counting lines before processing the lines of the file .
This version of the program should insert new line after the last complete word that will fit within line .

Write program that computes all of the following statistics for file and outputs the statistics to both the screen and to another file : the total number of occurrences of characters in the file , the total number of nonwhitespace characters in the file , and the total number of occurrences of letters in the file .

The text file , which is included in the source code for this book and is available online from the Web site , contains list of the most popular boy and girl names in the United States for the year as compiled by the Social Security Administration .

This is file of entries in which the rank is listed first , followed by the corresponding boy name and girl name .
The most popular names are listed first and the least popular names are listed last .

For example , the file begins with Jacob Sophia Mason Emma Ethan Isabella .

Chapter Streams as an Introduction to Objects and Classes This indicates that Jacob is the most popular boy name and Sophia is the most popular girl name .
Mason is the second most popular boy name and Emma is the second most popular girl name .

Write program that allows the user to input name .
The program should then read from the file and search for matching name among the girls and boys .
If match is found , it should output the rank of the name .

The program should also indicate if there is no match .

For example , if the user enters the name " then the program should output : Justice is ranked in popularity among boys .

Justice is ranked in popularity among girls .

If the user enters the name " then the program should output : Walter is ranked in popularity among boys .

Walter is not ranked among the top girl names .

VideoNote Solution to Programming Project .
To complete this problem you must have computer that is capable of viewing Scalable Vector Graphics files .
Your Web browser may already be able to view these files .
To test to see if your browser can display SVG files , type in the file below and see if you can open it in your Web browser .
If your Web browser cannot view the file , then you can search on the Web and download free SVG viewer .

The graphics screen to draw an image uses coordinate system in which , is located in the corner .
The coordinate increases to the right , and the coordinate increases to the bottom .
Consequently , coordinate , would be located pixels directly toward the right from the corner , and coordinate , would be located pixels directly toward the bottom from the corner .

This is illustrated in the figure below .

The SVG format defines graphics image using XML .
The specification for the image is stored in text file and can be displayed by an SVG viewer .
Here is sample SVG file that draws two rectangles and line .
To view it , save it to text file with the " extension , such as , and open it with your SVG viewer .

Programming Projects "

The lines that begins with blue rectangle whose corner is at coordinate , and whose is pixels and is pixels .

The lines that begin with green rectangle color value of is all whose corner is at coordinate , and whose is pixels and is pixels .

Finally , the tag draws purple line from , to , with of .

Based on this example , write program that inputs four nonnegative integer values and creates the SVG file that displays simple bar chart that depicts the integer values .
Your program should scale the values so they are always drawn with maximum of pixels .
For example , if your input values to graph were , and , you might generate SVG file that would display as follows :
Refer to Programming Project for information about the SVG format .

Shown below is another example that illustrates how to draw circles , ellipses , and multiple lines :

It is filled in with gold and has border in green .

The tag draws an ellipse centered at , with radius of and radius of .
It is filled using purple with black border .

The tag draws red line from , to , to , to ,
The is set to , making the of the polygon transparent .

Based on these examples and those presented in Project , write program that creates an SVG image that draws picture of your professor .

It can be somewhat abstract and simple .
If you wish to draw fancier image , you can research the SVG picture format ; there are additional tags that can draw using filters , gradients , and polygons .

Write program that prompts the user to input the name of text file and then outputs the number of words in the file .
You can consider " to be any text that is surrounded by whitespace example , space , carriage return , or borders the beginning or end of the file .

The following is an old word puzzle : common word , besides tremendous , stupendous and horrendous , that ends in " If you think about this for while , it will probably come to you .
However , we can also solve this puzzle by reading text file of English words and outputting the word if it contains " at the end .
The text file " contains , English words , including the word that completes the puzzle .
This file is available online with the source code for the book .
Write program that reads each word from the text file and outputs only those containing " at the end to solve the puzzle .

Arrays Introduction to Arrays Declaring and Referencing Arrays Programming Tip : Use for Loops with Arrays Pitfall : Array Indexes Always Start with Zero Programming Tip : Use Defined Constant for the Size of an Array Arrays in Memory Pitfall : Array Index Out of Range Initializing Arrays Programming Tip : for Statement Arrays in Functions Indexed Variables as Function Arguments Entire Arrays as Function Arguments The const Parameter Modifier Pitfall : Inconsistent Use of const Parameters Functions That Return an Array Case Study : Production Graph Chapter Summary Answers to Exercises Programming with Arrays Partially Filled Arrays Programming Tip : Do Not Skimp on Formal Parameters Programming Example : Searching an Array Programming Example : Sorting an Array Programming Example : Bubble Sort Multidimensional Arrays Multidimensional Array Basics Multidimensional Array Parameters Programming Example : Grading Program Pitfall : Using Commas Between Array Indexes Practice Programs Programming Projects It is capital mistake to theorize before one has data .

Introduction An array is used to process collection of data all of which is of the same type , such as list of temperatures or list of names .
This chapter introduces the basics of defining and using arrays in and presents many of the basic techniques used when designing algorithms and programs that use arrays .

Prerequisites This chapter uses material from Chapters through .

For instance , the program might compute the highest test score and then output the amount by which each score falls short of the highest .
The highest score is not known until all five scores are read in .
Hence , all five scores must be retained in storage so that after the highest score is computed each score can be compared to it .

To retain the five scores , we will need something equivalent to five variables of type int .
We could use five individual variables of type int , but five variables are hard to keep track of , and we may later want to change our program to handle scores ; certainly , variables are impractical .
An array is the perfect solution .
An array behaves like list of variables with uniform naming mechanism that can be declared in single line of simple code .
For example , the names for the five individual variables we need might be , and .
The part that does not this case , the name of the array .
The part that can change is the integer in the square brackets ,

Declaring and Referencing Arrays In , an array consisting of five variables of type int can be declared as follows : int ; This declaration is like declaring the following five variables to all be of type int : Introduction to Arrays , The individual variables that together make up the array are referred to in variety of different ways .
We will call them indexed variables , though they are also sometimes called subscripted variables or elements of the array .
The number in square brackets is called an index or subscript .
In , indexes are numbered starting with , not with or any other number except .
The number of indexed variables in an array is called the declared size of the array , or sometimes simply the size of the array .
When an array is declared , the size of the array is given in square brackets after the array name .
The indexed variables are then numbered using square , starting with and ending with the integer that is one less than the size of the array .

In our example , the indexed variables were of type int , but an array can have indexed variables of any type .
For example , to declare an array with indexed variables of type double , simply use the type name double instead of int in the declaration of the array .
All the indexed variables for one array are , however , of the same type .
This type is called the base type of the array .
Thus , in our example of the array score , the base type is int .

You can declare arrays and regular variables together .
For example , the following declares the two int variables next and max in addition to the array score : int next , max ; An indexed variable like can be used anyplace that an ordinary variable of type int can be used .

Do not confuse the two ways to use the square brackets with an array name .
When used in declaration , such as int ; the number enclosed in the square brackets specifies how many indexed variables the array has .
When used anywhere else , the number enclosed in the square brackets tells which indexed variable is meant .
For example , through are indexed variables .

The index inside the square brackets need not be given as an integer constant .
You can use any expression in the square brackets as long as the expression evaluates to one of the integers through the integer that is one less than the size of the array .
For example , the following will set the value of equal to : int ; + Although they may look different , and are the same indexed variable in the code above .

The identity of an indexed variable , such as , is determined by the value of its index , which in this instance is .
Thus , you can write programs .

Chapter Arrays that say things such as such and such to the ith indexed " where the value of is computed by the program .
For example , the program in Display reads in scores and processes them in the way we described at the start of this chapter .

Array Indexes Always Start with Zero The indexes of an array always start with and end with the integer that is one less than the size of the array .

It only works for classes that have exactly five students .
Most classes do not have exactly five students .
One way to make program more versatile is to use defined constant for the size of each array .
For example , the program in Display could be rewritten to use the following defined constant : const int .

Of course , all places that have for the size of the array should also be changed to have instead of .
If these changes are made to the program better still , if the program had been written this way in the first , then the program can be rewritten to work for any number of students by simply changing the one line that defines the constant .
Note that on many compilers you cannot use variable for the array size , such as the .

Display Program Using an Array .

Sample Dialogue Enter scores : The highest score is The scores and their differences from the highest are : off by off by off by off by off by .

Chapter Arrays Some but not all compilers will allow you to specify an array size with variable in this way .
However , for the sake of portability you should not do so , even if your compiler permits it .

memory consists of list of numbered locations called The number of byte is known as its address .
simple variable is implemented as portion of memory consisting of some number of consecutive bytes .
The number of bytes is determined by the type of the variable .

Thus , simple variable in memory is described by two pieces of information : an address in memory the location of the first byte for that and the type of the variable , which tells how many bytes of memory the variable requires .

When we speak of the address of variable , it is this address we are talking about .

When your program stores value in the variable , what really happens is that the value as and is placed in those bytes of memory that are assigned to that variable .
Similarly , when variable is given as argument to function , it is the address of the variable that is actually given to the calling function .
Now move on to discuss how arrays are stored in memory .

Array indexed variables are represented in memory the same way as ordinary variables , but with arrays there is little more to the story .
The locations of the various array indexed variables are always placed next to one another in memory .
For example , consider the following : int ; When you declare this array , the computer reserves enough memory to hold six variables of type int .
Moreover , the computer always places these variables one after the other in memory .
The computer then remembers the address of indexed variable , but it does not remember the address of any other indexed variable .
When your program needs the address of some other indexed variable , the computer calculates the address for this other indexed variable from the address of .
For example , if you start at the address of and count past enough memory for three variables of type int , then you will be at the address of .
To obtain the address of , the computer starts with the address of is .
The computer then adds the number of bytes needed to hold three variables of type int to the number for the address of .
The result is the address of .
This implementation is diagrammed in Display .

Many of the peculiarities of arrays in can be understood only in terms of these details about memory .
For example , in the next Pitfall section , we use these details to explain what happens when your program uses an illegal array index .

An array declaration , of the form shown , will define indexed variables , namely , the indexed variables through .
Each indexed variable is variable of type .

The array consists of the indexed variables , and , all of type double .
The array consists of the indexed variables , and , also all of type double .
You can combine array declarations with the declaration of simple variables such as the variable shown above .

Pitfall Array Index Out of Range The most common programming error made when using arrays is attempting to reference nonexistent array index .
For example , consider the following array declaration : int ; When using the array , every index expression must evaluate to one of the integers through .
For example , if your program contains the indexed variable , the must evaluate to one of the six integers , or .

If evaluates to anything else , that is an error .
When an index expression evaluates to some value other than those allowed by the array declaration , the index is said to be out of range or simply illegal .
On most systems , the result of an illegal array index is that your program will do something wrong , possibly disastrously wrong , and will do so without giving you any warning .

Attackers have also exploited this type of error to break into software .

An programming error could potentially compromise the entire system , so take great care to avoid this error .
In , the Common Weakness Enumeration Institute identified this type of error as the third most dangerous programmer error .

VideoNote Array Walkthrough .

There is no indexed variable , but if there were one , it would be here .

For example , suppose your system is typical , the array is declared as shown , and your program contains the following : Now , suppose the value of  unfortunately , happens to be .
The computer proceeds as if were legal indexed variable .
The computer calculates the address where would be only there were an , and places the value in that location in memory .
However , there is no indexed variable , and the memory that receives this probably belongs to some other variable , maybe variable named .
So the value of has been unintentionally changed .
The situation is illustrated in Display .

Array indexes get out of range most commonly at the first or last iteration of loop that processes the array .
So , it pays to carefully check all array processing loops to be certain that they begin and end with legal array indexes .

In practice it is more difficult , because there are often subtle or unanticipated ways to change an index variable .
For example , consider the following code that inputs some numbers into an .

This program suffers from two errors .
First , the loop has an error .
By starting at index and continuing up to and including num the loop will input numbers instead num numbers .
As long as value less than ten is entered for num then you might not notice the problem .
The program crash because the numbers will all be entered with the addition one extra which still fits in the array .
However , if is entered for num then the eleventh will be stored at index which is one off the end the array .
To fix this problem the loop should be written as : Another problem is the lack input validation .
malicious or mischievous user could enter as the values to enter ; the loop would then simply execute times and input data well past the end the array program may crash before looping times as numbers past the end the array could cause .
To address this problem we can validate that the input is within valid range : many numbers .

For example , on most systems signed short can only store up .

Entering larger value results in overflow which could store or negative value in .
Although the for loop will not run if is zero or negative the program would erroneously pass the if statement .
We explore this type error again in Chapter .

When initializing the array , the values for the various indexed variables are enclosed in braces and separated with commas .
For example , int ,

If you list fewer values than there are indexed variables , those values will be used to initialize the first few indexed variables , and the remaining indexed variables will be initialized to the array base type .
In this situation , indexed variables not provided with initializers are initialized to .
However , arrays with no initializers and other variables declared within function definition , including the main function program , are not initialized .
Although array indexed variables other may sometimes be automatically initialized to , you cannot and should not count on it .

If you initialize an array when it is declared , you can omit the size the array , and the array will automatically be declared to have the minimum size needed for the initialization values .
For example , the following declaration int ,

The syntax is shown below : varname is successively set to each element in the array .

This will output : When defining the variable that will iterate through the array we can use the same modifiers that are available when defining parameter for function .
The example we used above for variable is equivalent to .
If we change inside the loop it change the array .

We could define as pass by reference using and then changes to will be made to the array .
We could also use const to indicate that the variable be changed .
The example below increments every element in the array and then outputs them .
We used the auto datatype in the output loop to automatically determine the element inside the array .

This will output :
The for loop is especially convenient when iterating over vectors , which are introduced in Chapter , and iterating over containers , which are discussed in Chapter .

Describe the difference in the meaning int and the meaning .
What is the meaning the and in each case .

In the array declaration double ; state the following :
The array name The base c .
The declared size the array .
The range values that an index for this array can have One the indexed variables this array .

Suppose we expect the elements the array to be ordered so that .

However , to be safe we want our program to test the array and issue warning in case it turns out that some elements are out order .
The following code is supposed to output such warning , but it contains bug .

Write some code that will fill an array with values of int read in from the keyboard .
You need not write full program , just the code to do this , but do give the declarations for the array and for all variables .

Suppose you have the following array declaration in your program : int ; Also , suppose that in your implementation of , variables of int use bytes of memory .
When you run your program , how much memory will this array consume .
Suppose that when you run your program , the system assigns the memory address to the indexed variable .

What will be the address of the indexed variable .

We first discuss array indexed variables as arguments to functions .

Indexed Variables as Function Arguments An indexed variable can be an argument to function in exactly the same way that any variable can be an argument .
For example , suppose program contains the following declarations : int 

Chapter Arrays The indexed expression is evaluated in order to determine exactly which indexed variable is given as the argument .

Display contains an example of indexed variables used as function arguments .
The program shown gives five additional vacation days to each of three employees in small business .
The program is extremely simple , but it does illustrate how indexed variables are used as arguments to functions .
Notice the function .
This function has formal parameter called that is of int .
In the main body of the program , this function is called with the argument for various values of number .
Notice that there was nothing special about the formal parameter .
It is just an ordinary formal parameter of int , which is the base of the array vacation .
In Display the indexed variables are arguments .
The same remarks apply to arguments .
An indexed variable can be argument or argument .

However , formal parameter for an entire array is neither parameter nor parameter ; it is new of formal parameter referred to as an array parameter .
start with an example .

VideoNote Passing Arrays to Functions Chapter Arrays The function defined in Display has one array parameter ,  which will be replaced by an entire array when the function is called .
It also has one ordinary parameter that is assumed to be an integer value equal to the size of the array .
This function fills its array argument is , fills all the indexed with values typed in from the keyboard , and then the function outputs message to the screen telling the index of the last array index used .

The formal parameter int is an array parameter .
The square brackets , with no index expression inside , are what uses to indicate an array parameter .
An array parameter is not quite parameter , but for most practical purposes it behaves very much like parameter .
go this example in detail to see how an array argument works in this case .
For example , the following is an acceptable function call : int , This call to will fill the array score with five integers typed in at the keyboard .
Notice that the formal parameter is used in the function declaration and the heading of the function is given with square brackets , but no index expression .

Function Definition .

What happens to the array argument score in this function call .
Very loosely speaking , the argument score plugged in for the formal array parameter in the body of the function , and then the function body executed .

The formal parameter different of parameter from the ones we have seen before now .
The formal parameter merely placeholder for the argument score .
When the function called with score as the array argument , the computer behaves as if were replaced with the corresponding argument score .
When an array used as an argument in function call , any action that performed on the array parameter performed on the array argument , so the values of the indexed variables of the array argument can be changed by the function .
If the formal parameter in the function body changed example , with cin , then the array argument will be changed .

So far it looks like an array parameter simply parameter for an array .
That close to being true , but an array parameter slightly different from parameter .
To help explain the difference , review some details about arrays .

Recall that an array stored as contiguous chunk of memory .
For example , consider the following declaration for the array score : int ; When you declare this array , the computer reserves enough memory to hold five variables of type int , which are stored one after the other in the memory .
The computer does not remember the addresses of each of these five indexed variables ; it remembers only the address of indexed variable .
For example , when your program needs , the computer calculates the address of the address of .
The computer knows that located three int variables past .

Thus , to obtain the address of , the computer takes the address of and adds that represents the amount of memory used by three int variables ; the result the address of .

Arrays in memory .

Array argument Different array arguments can be plugged in for the same array parameter of the first indexed variable , the base type of the array determines how much memory each indexed variable , and the of the array  the number of indexed .
When an array used as an array argument to function , only the first of these three parts given to the function .
When an array argument plugged in for its corresponding formal parameter , all that plugged in the address of the first indexed variable .
The base type of the array argument must match the base type of the formal parameter , so the function also knows the base type of the array .
However , the array argument does not tell the function the of the array .
When the code in the function body executed , the computer knows where the array starts in memory and how much memory each indexed variable uses , you make special it does not know how many indexed variables the array has .
That why it critical that you always have another int argument telling the function the of the array .
That also why an array parameter not the same as parameter .
You can think of an array parameter as weak form of parameter in which everything about the array told to the function except for the of the These array parameters may seem little strange , but they have at least one very nice property as direct result of their seemingly strange definition .

This advantage best illustrated by again looking at our example of the function given in Display .
That same function can be used to fill an array of any  as long as the base type of the array int .
For example , suppose you have the following array declarations : int ,

The const Parameter Modifier When you use an array argument in function call , the function can change the values stored in the array .

However , in complicated function definition , you might write code that inadvertently changes one or more of the values stored in an array , even though the array should not be changed at all .
As precaution , you can tell the compiler that you do not If you have heard of pointers , this will sound like pointers , and indeed an array argument passed by passing pointer to its first index variable .
We will discuss this in Chapter .
If you have not yet learned about pointers , you can safely ignore this footnote .

To tell the compiler that an array argument should not be changed by your function , you insert the modifier const before the array parameter for that argument position .
An array parameter that modified with const called constant array parameter .

For example , the following function outputs the values in an array but does not change the values in the array : the declared of the array .

It new of argument known as an array argument .

When an array argument plugged in for an array parameter , all that given to the function the address in memory of the first indexed variable of the array argument one indexed by .
The array argument does not tell the function the size of the array .
Therefore , when you have an array parameter to function , you normally must also have another formal parameter of type int that gives the size of the array in the example .

An array argument is like argument in the following way : If the function body changes the array parameter , then when the function is called , that change is actually made to the array argument .

Thus , function can change the values of an array argument is , can change the values of its indexed .

Chapter Arrays The syntax for function declaration with an array parameter is as follows : syntax ,

For example , the following is version of the function that contains mistake that inadvertently changes the value of the array argument .
Fortunately , this version of the function definition includes the modifier const , so that an error message will tell us that the array is changed .
This error message will help to explain the mistake : is the declared size of the array .

If we had not used the const modifier in this function definition and if we made the mistake shown , the function would compile and run with no error messages .
However , the code would contain an infinite loop that continually increments and writes its new to the screen .

The problem with this incorrect version of is that the wrong item is incremented in the for loop .
The indexed variable is incremented , but it should be the index that is incremented .
In this incorrect version , the index starts with the and that is never changed .

When the indexed variable is incremented , that changes in the array , and since we included the modifier const , the computer will issue warning message .
That error message should serve as clue to what is wrong .

You normally have function declaration in your program in addition to the function definition .
When you use the const modifier in function definition , you must also use it in the function declaration so that the function heading and the function declaration are consistent .

Pitfall Inconsistent Use of const Parameters The const parameter modifier is an proposition .
If you use it for one array parameter of particular type , then you should use it for every other array parameter that has that type and that is not changed by the function .

Consider the definition of the function , which is given below along with the declaration of function used in the definition : double , int ; the of the elements in the first .

This code will generate an error message or warning message with most compilers .
The function does not change its parameter .

However , when the compiler processes the function definition for change the of its parameter .
This is because , when it is translating the function definition for , all the compiler knows about the function is the function declaration for  and the function declaration does not contain const to tell the compiler that the parameter will not be changed .
Thus , if you use const with the parameter in the function , then you should also use the modifier const with the parameter in the function The function declaration for should be as follows : double int , int ; Functions That Return an Array function may not return an array in the same way that it returns of type int or double .
There is way to obtain something more or less .

Chapter Arrays equivalent to function that returns an array .
The thing to do is to return pointer to the array .
However , we have not yet covered pointers .
We will discuss returning pointer to an array when we discuss the interaction of arrays and pointers in Chapter .
Until then , you have no way to write function that returns an array .

Case Study Production Graph In this case study we use arrays in the design of program .
We use both indexed variables and entire arrays as arguments to the functions for subtasks .

Problem Definition The Apex Plastic Spoon Manufacturing Company has commissioned us to write program that will display bar graph showing the productivity of each of its four manufacturing plants for any given week .
Plants keep separate production figures for each department , such as the teaspoon department , soup spoon department , plain cocktail spoon department , colored cocktail spoon department , and so forth .
Moreover , each plant has different number of departments .
For example , only one plant manufactures colored cocktail spoons .
The input is entered and consists of list of giving the production for each department in that plant .
The output will consist of bar graph in the following form : Plant Plant Plant Plant Each asterisk represents units of output .

We decide to read in the input separately for each department in plant .

Since departments cannot produce negative number of spoons , we know that the production figure for each department will be nonnegative .
Hence , we can use negative number as sentinel to mark the end of the production for each plant .

Since output is in units of , it must be scaled by dividing it by .

This presents problem since the computer must display whole number of asterisks .
It cannot display asterisks for units .
We will thus round to the nearest .
Thus , will be the same as and will produce two asterisks .
precise statement of the input and output is as follows .

Input There are four manufacturing plants numbered through .
The following input is given for each of the four plants : list of giving the production for each department in that plant .
The list is terminated with negative number that serves as sentinel value .

Each asterisk in the bar graph equals units .
The production of each plant is rounded to the nearest units .

Analysis of the Problem We will use an array called production , which will hold the total production for each of the four plants .
In , array indexes always start with .
But since the plants are numbered through , rather than through , we will not use the plant number as the array .
Instead , we will place the total production for plant number in the indexed variable .
The total output for plant number will be held in , the figures for plant will be held in , and so forth .

Since the output is in thousands of units , the program will scale the values of the array elements .
If the total output for plant number is units , then the value of will initially be set to .
This value of will then be scaled to so that the value of is changed to , and four asterisks will be output in the graph to represent the output for plant number .

The task for our program can be divided into the following subtasks : Read the input data for each plant and set the value of the indexed variable equal to the total production for that plant , where is the number of the plant .

The entire array production will be an argument for the functions that carry out these subtasks .
As is usual with an array parameter , this means we must have an additional formal parameter for the size of the array , which in this case is the same as the number of plants .
We will use defined constant for the number of plants , and this constant will serve as the size of the array production .
The main part of our program , together with the function declarations for the functions that perform the subtasks and the defined constant for the number of plants , is shown in Display .
Notice that , since there is no reason to change the array parameter to the function graph , we have made that array parameter constant parameter by adding the const parameter modifier .
The material in Display is the outline for our program , and if it is in separate file , that file can be compiled so that we can check for any syntax errors in this outline before we go on to define the functions corresponding to the function declarations shown .

Having compiled the file shown in Display , we are ready to design the implementation of the functions for the three subtasks .
For each of these three functions , we will design an algorithm , write the code for the function , and test the function before we go on to design the next function .

Algorithm Design for The function declaration and descriptive comment for the function data is shown in Display .
As indicated in the body of the main part of our program shown in Display , when is called , the formal array parameter will be replaced with the array production , and since the last plant number is the same as the number of plants , the formal parameter will be replaced by .
The algorithm for is straightforward : For equal to each of , through do the following : Read in all the data for plant whose number is .

Sum the numbers .

Set equal to that total .

The code is routine since all the work is done by the function , which we still need to design .
But before we move on to discuss the function , observe few things about the function .
Notice that we store the figures for plant number in the indexed variable with index ; this is because arrays always start with index , while the plant numbers start with .
Also , notice that we use an indexed variable for the argument to the function .
The function really does all the work for the function .

The function does all the input work for one plant .
It reads the production figures for that plant , sums the figures , and stores the total in the indexed variable for that plant .
But does not need to know that its argument is an indexed variable .
To function such as , an indexed variable is just like any other variable of type int .
Thus , will have an ordinary parameter of type int .
That means that Arrays in Functions Display Outline of the Graph Program .

The function reads in list of numbers ended with sentinel value , sums the numbers as it reads them in , and sets the value of its argument , which is variable of type int , equal this sum .

Display shows the function definitions for both and .
The functions are embedded in simple test program .

Testing Every function should be tested in program in which it is the only untested function .
The function includes call the function .

Therefore , we should test in driver program of its own .
Once has been completely tested , we can use it in program , like the one in Display , test the function .

When testing the function , we should tests with all possible kinds of production figures for plant .
We should plant has no production figures we did for plant in Display ; we should test for plant with only one production figure we did for plant in Display ; and we should test for plant with more than one production figure we did for plants and in Display .
We should test for both nonzero and zero production figures , which is why we included in the input list for plant in Display .

Algorithm Design for scale The function scale changes the value of each indexed variable in the array production so it shows the number of asterisks print out .
Since there should be one asterisk for every units of production , the value of each indexed variable must be divided by .
Then get whole number of asterisks , this number is rounded the nearest integer .
This method can be used scale the values in any array of any size , so the function declaration for scale , shown in Display and repeated here , is stated in terms of an arbitrary array of some arbitrary size : void , int .

Coding for scale The algorithm for scale translates into the code given next , where round is function we still need define .
The function round takes one argument of type double and returns type int is the integer nearest its argument ; is , the function round will round its argument the nearest whole number .

Sample Dialogue Enter production data for plant Enter of units produced by each department .

Append negative to the end of the list .

Append negative to the end of the list .

Append negative to the end of the list .

Append negative to the end of the list .

Notice that we divided by , not by the decimal .
If we had divided by , we would have performed integer division .
It is true that we want an integer for the final answer after rounding , but we want divided by to produce , not , when it is rounded to whole .

We now turn to the definition of the function round , which rounds its argument to the nearest integer .
The code for the function round , as well as that for scale , is given in Display .
The code for round may require bit of explanation .

The function round uses the predefined function floor from the library with the header file cmath .
The function floor returns the whole just below its argument .

In fact , for any that is greater than or equal to and strictly less than , that plus will be less than , and so floor applied to that plus will return .
Thus , round applied to any that is greater than or equal to and strictly less than will return .

Chapter Arrays Display The Function scale .

Enter numbers to scale : Values scaled to the of are : Arrays in Functions which is and is .
In fact , for any is greater than or equal to and less than or equal to , plus will be greater than .
Thus , round called with any is greater than or equal to and less than or equal to will return .

Thus , round works correctly for all arguments between and .

Clearly , there is nothing special about arguments between and .

similar argument applies to all nonnegative numbers .
So , round works correctly for all nonnegative arguments .

Testing scale Display contains demonstration program for the function scale , but the testing programs for the functions round and scale should be more elaborate than this simple program .
In particular , they should allow you to retest the tested function several times rather than just once .
We will not give the complete testing programs , but you should first test round is used by in driver program of its own , and then test scale in driver program .

The program to test round should test arguments are , arguments round up , and arguments round down like .
The program to test scale should test similar variety of values for the elements of the array .

The Function graph The complete program for producing the desired bar graph is shown in Display .
We have not taken you through the design of the function graph because it is quite straightforward .

Sample Dialogue This program displays graph showing production for each plant in the company .

Enter production data for plant Enter of units produced by each department .

Append negative to the end of the list .

Append negative to the end of the list .

Append negative to the end of the list .

Append negative to the end of the list .

Chapter Arrays el est Exe rc is es .
Write function definition for function called , which has formal parameter for an array of integers and increases the value of each array element by one .
Add any other formal parameters that are needed .

Consider the following function .

Write function named that takes as parameters an array of double and an int parameter named size and returns value of type int .
This function will test this array for being out of order , meaning that the array violates the following condition :

The function returns if the elements are not out of order ; otherwise , it will return the of the first element of the array that is out of order .

For example , consider the declaration .

If the array were sorted , the function would return .

In this section we discuss partially filled arrays and give brief introduction to sorting and searching of arrays .
This section includes no new about the language , but does include more practice with array parameters .

Partially Filled Arrays Often the exact size needed for an array is not known when program is written , or the size may vary from one run of the program to another .
One common and easy way to handle this situation is to declare the array to be of the largest size the program could possibly need .
The program is then free to use as much or as little of the array as is needed .

Partially filled arrays require some care .
The program must keep track of how much of the array is used and must not reference any indexed variable that has not been given value .
The program in Display illustrates this point .
The program reads in list of golf scores and shows how much each score differs from the average .
This program will work for lists as short as one score , as long as ten scores , and for any length in between .
The scores are stored in the array score , which has ten indexed variables , but the program uses only as much of the array as it needs .
The variable keeps track of how many elements are stored in the array .
The elements is , the are stored in positions through .

The details are very similar to what they would be if were the declared size of the array and the entire array were used .
In particular , the variable usually must be an argument to any function that manipulates the partially filled array .
Since the argument used can often ensure that the function will not reference an illegal array  this sometimes not eliminates the need for an argument that gives the declared size of the array .
For example , the functions and use the argument to ensure that only legal array indexes are used .
However , the function array needs to know the maximum declared size for the array so that it does not overfill the array .

Sample Dialogue This program reads golf and shows how much each differs from the .

Enter golf  Enter up to nonnegative whole numbers .

Mark the end of the list with negative number .

Do Not Skimp on Formal Parameters Notice the function in Display .
When is called , the declared array size is given as one of the arguments , as shown in the following function call from Display : You might protest that is globally defined constant and so could be used in the definition of without the need to make it an argument .
You would be correct , and if we did not use in any program other than the one in Display , we could get by without making an argument to .
However , is generally useful function that you may want to use in several different programs .
We do in fact also use the function in the program in Display , discussed in the subsection .
In the program in Display , the argument for the declared array size is different named global constant .
If we had written the global constant into the body of the function , we would not have been able to reuse the function in the program in Display .

For example , the array may contain the student numbers for all students in given course .
To tell whether particular student is enrolled , the array is searched to see if it contains the number .
The program in Display fills an array and then searches the array for values specified by the user .

real application program would be much more elaborate , but this shows all the essentials of the sequential search algorithm .
The sequential search algorithm is the most straightforward searching algorithm you could imagine : The program looks at the array elements in the order first to last to see if the target number is equal to any of the array elements .

In Display , the function search is used to search the array .
When searching an array , you often want to know more than simply whether or not the target value is in the array .
If the target value is in the array , you often want to know the of the indexed variable holding that target value , since the may serve as guide to some additional information about the target value .
Therefore , we designed the function search to return an giving the location of the target value in the array , provided the target value is , in fact , in the array .
If the target value is not in the array , search returns .
look at the function search in little more detail .

The function search uses while loop to check the array elements one after the other to see whether any of them equals the target value .
The variable Programming with Arrays .

Sample Dialogue Enter up to nonnegative whole numbers .

Mark the end of the list with negative number .

Search followed by : Enter number to search for : stored in array position .

Search followed by : Enter number to search for : not on the list .

Search followed by : End of program .

Even if we used in only one program , it can still be good idea to make the declared array size an argument to .
Displaying the declared size of the array as an argument reminds us that the function needs this information in critically important way .

In this section we describe function called sort that sorts partially filled array of numbers so that they are ordered from smallest to largest .

The procedure sort has one array parameter .
The array will be partially filled , so there an additional formal parameter called  which tells how many array positions are used .
Thus , the declaration and precondition for the function sort is void , int ; declared size of the array .

The function sort rearranges the elements in array so that after the function call is completed the elements are sorted as follows :
It is one of the easiest of the sorting algorithms to understand .

One way to design an algorithm is to rely on the definition of the problem .

In this case the problem is to sort an array from smallest to largest .
That means rearranging the values so that is the smallest , the next smallest , and so forth .
That definition yields an outline for the selection sort algorithm : Place the indexth smallest element in There are many ways to realize this general approach .
The details could be developed using two arrays and copying the elements from one array to the other in sorted order , but one array should be both adequate and economical .
Therefore , the function sort uses only the one array containing the values to be sorted .
The function sort rearranges the values in the array by interchanging pairs of values .
Let us go through concrete example so that you can see how the algorithm works .

Consider the array shown in Display .
The algorithm will place the smallest value in .
The smallest value is the value in .
So the algorithm interchanges the values of and .
The algorithm then looks for the next smallest element .
The value in is now the smallest element and so the next smallest element is the smallest of the remaining elements ,
In the example in Display , the next smallest element is in , so the algorithm interchanges the values of and .
This positioning of the second smallest element is illustrated in the fourth and fifth array pictures in Display .

The algorithm then positions the third smallest element , and so forth .

VideoNote Selection Sort Walkthrough Chapter Arrays Display Selection Sort .

The sorted portion of the array grows by adding elements one after the other from the elements in the unsorted end of the array .
Notice that the algorithm need not do anything with the value in the last indexed variable ,
That is because once the other elements are positioned correctly , must also have the correct value .
After all , the correct value for is the smallest value left to be moved , and the only value left to be moved is the value that is already in .

The definition of the function sort , included in demonstration program , is given in Display .

The function , shown in Display , is used to interchange the values of indexed variables .
For example , the following call will interchange the values of and :

Sample Dialogue This program sorts numbers from lowest to highest .

Enter up to nonnegative whole numbers .

Mark the end of the list with negative number .

In fact , computer scientists have devised scores of sorting algorithms .

Some of these algorithms are more efficient than others and some work only for particular types of data .
Bubble sort is simple and general sorting algorithm that is similar to selection sort .

If we use bubble sort to sort an array in ascending order , then the largest value is successively " toward the end of the array .
For example , if we start with an unsorted array consisting of the following integers : Initial array :

The remaining number at the beginning of the array need to be examined since it is the only number left and must be the smallest .
To design program based on bubble sort note that we are placing the largest item at , the second largest item at , the next at , etc .
This corresponds to loop that starts at of the array and counts down to of the array .
We need to include since that will contain the smallest element .
One way to implement the loop is with the following code , where variable corresponds to the target  The " part of bubble sort happens inside each iteration of this loop .
The bubble step consists of another loop that moves the largest number toward the in the array .
First , the largest number between and VideoNote Bubble Sort Walkthrough Chapter Arrays will be bubbled up to .
We start the bubbling procedure by comparing the number at with the number at .
If the number at is larger than the number at then the values are swapped so we end up with the largest number at .
If the number at is less than or equal to the number at then nothing happens .
Starting with the following unsorted array : Initial array :

The second step will compare the numbers at and , which is values and .
Since is larger than we swap the numbers resulting in the following : After step :

This ends the first iteration of the bubble sort algorithm .
We have bubbled the largest number to the end of the array .
The next iteration would bubble the second largest number to the second to last position , and so forth , where variable represents the target for the bubbled number .
If we use variable to reference the of the bubbled item then our loop code looks like this : Inside the loop we must compare the items at and .
The largest should be moved into .
The completed algorithm is shown below and complete example in Display .

Display Bubble Sort Program .

Chapter Arrays el est Exe rc is es .
Write program that will read up to ten nonnegative integers into an array called and then write the integers back to the screen .

For this exercise you need not use any functions .
This is just toy program and can be very minimal .

Write program that will read up to ten letters into an array and write the letters back to the screen in the reverse order .
For example , if the input is abcd .

Call the array .
For this exercise you need not use any functions .
This just toy program and can be very minimal .

Following the declaration for an alternative version of the function search defined in Display .
In order to use this alternative version of the search function , we would need to rewrite the program slightly , but for this exercise all you need to do to write the function definition for this alternative version of search .

Found on the wall of Computer Science department restroom allows you to declare arrays with more than one index .
In this section we describe these multidimensional arrays .

The following declares an array of characters called page .
The array page has two indexes : The first index ranges from to , and the second from to .

For example , and are three of the indexed variables for this array .
Note that each index must be enclosed in its own set of square brackets .
As was true of the arrays we have already seen , each indexed variable for multidimensional array variable of the base type .

An array may have any number of indexes , but perhaps the most common number of indexes two .
array can be visualized as display with the first index giving the row and the second index giving the column .
For example , the array indexed variables of the twodimensional array page can be visualized as follows :

In , array , such as page , actually an array of arrays .
The example array page actually array of size , whose base type array of characters of size .

Normally , this need not concern you , and you can usually act as if the array page actually an array with two indexes than an array of arrays , which harder to keep track .
There  however , at least one situation array looks very much like an array of arrays , namely , when you have function with an array parameter for array , which discussed in the next subsection .

Multidimensional Array Parameters The following declaration of array actually declaring array of size , whose base type array of characters of size : multidimensional array an array of arrays Chapter Arrays .

An array declaration , of the form shown , defines one indexed variable for each combination of array indexes .
For example , the second of the sample declarations defines the following six indexed variables for the array matrix : char ; Viewing array as an array of arrays will help you to understand how handles parameters for multidimensional arrays .
For example , the following function takes an array argument , like page , and prints it to the screen :

Notice that with array parameter , the size of the first dimension not given , so we must include an int parameter to give the size of this first dimension .
However , such number only comment ; the compiler ignores any such The size of the second dimension all other dimensions if there are more than given after the array parameter , as shown for the parameter const char Multidimensional Arrays Multidimensional Array Parameters When multidimensional array parameter given in function heading or function declaration , the size of the first dimension not given , but the remaining dimension sizes must be given in square brackets .
Since the first dimension size not given , you usually need an additional parameter of type int that gives the size of this first dimension .
Below an example of function declaration with array parameter : void , int ; If you realize that multidimensional array an array of arrays , then this rule begins to make sense .
Since the array parameter const char parameter for an array of arrays , the first dimension really the of the array and is treated just like an array for an ordinary , onedimensional array .
The second dimension is part of the description of the base type , which is an array of characters of size .

Programming Example Grading Program Display contains program that uses array , named grade , to store and then display the grade records for small class .
The class has four students and includes three quizzes .
Display illustrates how the array grade is used to store data .
The first array is used to designate student , and the second array is used to designate quiz .
Since the students and quizzes are numbered starting with rather than , we must subtract from the student number and subtract from the quiz number to obtain the indexed variable that stores particular quiz score .
For example , the score that student number received on quiz number is recorded in .

Our program also uses two ordinary arrays .
The array will be used to record the average quiz score for each of the students .
For example , the program will set equal to the average of the quiz scores received by student , equal to the average of the quiz scores received by student , and so forth .
The array will be used to record the average score for each quiz .
For example , the program will set equal to the average of all the student scores for quiz , will record the average .

Chapter Arrays quiz scores for each student into the array grade input code is not shown in this .
Computes the average score .

Each of the indexed variables , contains the score for student on quiz .
Each contains the average for student .
Each contains the average for quiz number .

Display illustrates the relationship between the arrays grade , and .
In that display , we have shown some sample data for the array grade .
This data , in turn , determines the values that the program stores in and in .
Display also shows these values , which the program computes for and .

The complete program for filling the array grade and then computing and displaying both the student and the quiz is shown in Display .
In that program we have declared array dimensions as global named constants .
Since the procedures are particular to this program and could not be reused elsewhere , we have used these globally defined constants in the procedure bodies , rather than having parameters for the size of the array dimensions .
Since it is routine , the display does not show the code that fills the array .

Pitfall Using Commas Between Array Indexes Note that in Display we wrote an indexed variable for the twodimensional array grade as with two pairs of square brackets .
In some other programming languages it would be written with one pair of brackets and commas as follows : this is incorrect in .
If you use , num in you are unlikely to get any error message , but it is incorrect usage and will cause your program to misbehave .

Chapter Arrays elf Ex er c ise .
What is the output produced by the following code .

Write code that will fill the array with numbers typed in at the keyboard .
The numbers will be input five per line , on four lines your solution need not depend on how the input numbers are divided into .

Write function definition for void function called echo such that the following function call will echo the input described in Exercise and will echo it in the same format as we specified for the input is , four lines of five numbers per : Chapter Summary An array can be used to store and manipulate collection of data that is all of the same type .

Always check the first and last iterations of loop that manipulates an array to make sure it does not use an that is illegally small or illegally large .

An array parameter is similar to parameter in that any change that is made to the formal parameter in the body of the function will be made to the array argument when the function is called .

Answers to Exercises The indexed variables for an array are stored next to each other in the memory so that the array occupies contiguous portion of memory .
When the array is passed as an argument to function , only the address of the first indexed variable one numbered is given to the calling function .
Therefore , function with an array parameter usually needs another formal parameter of type int to give the size of the array .

An array parameter that is modified with const is called constant array parameter .

Answers to Se Exer cises .
The statement int ; is declaration , where is the number of array elements .
The expression is an access into the array defined by the previous statement .
The access is to the element having , which is the fifth array element .

The array size is .

The array size is .

The indexed variables of are through sample , but this piece of code tries to fill through .

When is equal to , + is equal to , so + which is the same as , has an illegal .
The loop should stop with one less iteration .
To correct the code , change the first line of the for loop to .

The array will consume bytes of memory .
The address of the indexed .

The first one has an illegal .
The second has no indexed expression at all .
You cannot use an entire array as an argument to tripler , as in the second call .
The section Arrays as Function Arguments " discusses different situation in which you can use an entire array as an argument .

The loop steps through indexed variables through , but is an illegal for the array .

The correct version of the code is : int ,

If that is what is desired , the call is acceptable .

The following function calls are all incorrect : The first of these is incorrect because the second argument is too large .
The second is incorrect because it is missing final semicolon for other .
The third one is incorrect because it uses an indexed variable for an argument where it should use the entire array .

You cannot make the parameter in constant parameter because it may have the values of some of its indexed variables changed .

Practice Programs Practice Programs can generally be solved with short program that directly applies the programming principles presented in this chapter .

Write function named that takes as input an array of integers and an integer that specifies how many entries are in the array .
The function should return true if the array starts or ends with the digit .
Otherwise it should return false .
Test your function with arrays of different length and .

Chapter Arrays with the digit at the beginning of the array , end of the array , middle of the array , and missing from the array .

Write function named that takes as input an array of integers and an integer that specifies how many entries are in the array .
The function should return the number of in the array .
Test your function with arrays of different length and with varying number of .

Write function named swapFrontBack that takes as input an array of integers and an integer that specifies how many entries are in the array .
The function should swap the first element in the array with the last element in the array .
The function should check if the array is empty to prevent errors .

Test your function with arrays of different length and with varying front and back numbers .

The following code creates small phone book .
An array is used to store list of and another array is used to store the phone numbers that go with each name .
For example , Michael Myers ' phone number is and Ash Williams ' phone number is .
Write the function lookupName so the code properly looks up and returns the phone number for the input name .

Programming Projects Programming Projects require more than Practice Programs and can usually be solved many different ways .
Visit to complete many of these Programming Projects online and get instant feedback .

Projects through can be written more elegantly using structures or classes .
Projects through are meant to be written using multidimensional arrays and do not require structures or classes .
See Chapters and for information on defining classes and structures .

There are three versions of this project .

Version .
Write program that reads in the average monthly rainfall for city for each month of the year and then reads in the actual monthly rainfall for each of the previous months .
The program then prints out nicely formatted table showing the rainfall for each of the previous months as well as how much above or below average the rainfall was for each month .
The average monthly rainfall is given for the months January , February , and so forth , in order .
To obtain the actual rainfall for the previous months , the program first asks what the current month is and then asks for the rainfall figures for the previous months .
The output should correctly label the months .

There are variety of ways to deal with the month .
One straightforward method is to code the months as integers and then do conversion before doing the output .
large switch statement is acceptable in an output function .
The month input can be handled in any manner you wish , as long as it is relatively easy and pleasant for the user .

After you have completed this program , produce an enhanced version that also outputs graph showing the average rainfall and the actual rainfall for each of the previous months .
The graph should be similar to the one shown in Display , except that there should be two bar graphs for each month and they should be labeled as the average rainfall and the rainfall for the most recent month .
Your program should ask the user whether she or he wants to see the table or the bar graph and then should display whichever format is requested .
Include loop that allows the user to see either format as often as the user wishes until the user requests that the program end .

Chapter Arrays Version interactive and file .
For more elaborate version , also allow the user to request that the table and graph be output to file .
The file name is entered by the user .
This program does everything that the Version program does but has this added feature .
To read file name , you must use material presented in the optional section of Chapter VideoNote Solution to Programming Project .
Write function called that has partially filled array of characters as formal parameter and that deletes all repeated letters from the array .
Since partially filled array requires two arguments , the function will actually have two formal parameters : an array parameter and formal parameter of type int that gives the number of array positions used .
When letter is deleted , the remaining letters are moved forward to fill in the gap .
This will create empty positions at the end of the array so that less of the array is used .

Since the formal parameter is partially filled array , second formal parameter of type int will tell how many array positions are filled .
This second formal parameter will be parameter and will be changed to show how much of the array is used after the repeated letters are deleted .

For example , consider the following .

Programming Projects is no longer of any concern , since the partially filled array no longer uses You may assume that the partially filled array contains only lowercase letters .
Embed your function in suitable test program .

The standard deviation of list of is measure of how much the deviate from the average .
If the standard deviation is small , the are clustered close to the average .
If the standard deviation is large , the are scattered far from the average .
The standard deviation ,  of list of is defined as follows :

Define function that takes partially filled array of as its arguments and returns the standard deviation of the in the partially filled array .
Since partially filled array requires two arguments , the function will actually have two formal parameters : an array parameter and formal parameter of type int that gives the number of array positions used .
The in the array will be of type double .
Embed your function in suitable test program .

Write program that reads in list of integers into an array with base type int .
Provide the facility to either read this array from the keyboard or from file , at the option .
If the user chooses file input , the program should request file name .
You may assume that there are fewer than entries in the array .
Your program determines how many entries there are .
The output is to be list .
The first column is list of the distinct array elements ; the second column is the count of the number of occurrences of each element .
The list should be sorted on entries in the first column , largest to smallest .

For example , for the input the output should be Count .

The text discusses the selection sort .
We propose different " routine , the insertion sort .
This routine is in sense the opposite of the selection sort in that it picks up successive elements from the array and inserts each of these into the correct position in an already sorted subarray one end of the array we are .

The array to be sorted is divided into sorted subarray and subarray .
Initially , the sorted subarray is empty .
Each element of the subarray is picked and inserted into its correct position in the sorted subarray .

Write function and test program to implement the selection sort .

Thoroughly test your program .

Example and hints : The implementation involves an outside loop that selects successive elements in the subarray and nested loop that inserts each element in its proper position in the sorted subarray .

Initially , the sorted subarray is empty , and the subarray is all of the array :

The inside loop has nothing to do in this first case .
The array and subarrays look like this : sorted .

Insert this into the sorted subarray in its proper position .
These are out of order , so the inside loop must swap values in position and position .
The result is as follows : sorted .

Programming Projects Note that the sorted subarray has grown by one entry .

Repeat the process for the first subarray entry , finding place where can be placed so that the subarray remains sorted .
Since is already in is , it is larger than the largest element in the sorted inside loop has nothing to do .

The result is as follows : sorted .

This time the inside loop has to swap values until the value of is in its proper position .
This involves some swapping : sorted .

An array can be used to store large integers one digit at time .
For example , the integer could be stored in the array by setting to , to , to , and to .
However , for this exercise you might find it more useful to store the digits backward , that is , place in , in , in , and in .

In this exercise you will write program that reads in two positive integers that are or fewer digits in length and then outputs the sum of the two numbers .
Your program will read the digits as values of type char so that the number is read as the four characters , and .

After they are read into the program , the characters are changed to values of type int .
The digits will be read into partially filled array , and you might find it useful to reverse the order of the elements in the array after the array is filled with data from the keyboard .
It can be done Your program will perform the addition by implementing the usual addition algorithm .
The result of the addition is stored in an array of size , and the result is then written to the screen .
If the result of the addition is an integer with more than the maximum number of digits is , more than , then your program should issue message saying that it has encountered " You should be able to change the maximum length of the integers by changing only one globally defined constant .
Include loop that allows the user to continue to do more additions until the user says the program should end .

Write program that will read line of text and output list of all the letters that occur in the text together with the number of times each letter occurs in the line .
End the line with period that serves as sentinel value .

The letters should be listed in the following order : the most frequently occurring letter , the next most frequently occurring letter , and so forth .
Use two arrays , one to hold integers and one to hold letters .
You may assume that the input uses all lowercase letters .
For example , the input do be do bo .

Programming Projects Your program will need to sort the arrays according to the values in the integer array .
This will require that you modify the function sort given in Display .
You cannot use sort to solve this problem without changing the function .
If this is class assignment , ask your instructor if should be done with the keyboard and screen or if it should be done with files .
If it is to be done with files , ask your instructor for instructions on file names .

Write program to score poker hands into one of the following categories : nothing , one pair , two pairs , three of kind , straight order , with no , flush the same suit , for example , all , full house pair and three of , four of kind , straight flush straight and .
Use two arrays , one to hold the value of the card and one to hold the suit .
Include loop that allows the user to continue to score more hands until the user says the program should end .

Write program that will allow two users to play .
The program should ask for moves alternately from player and player .
The program displays the game positions as follows : The players enter their moves by entering the position number they wish to mark .
After each move , the program displays the changed board .
sample board configuration is as follows :
Write program to assign passengers seats in an airplane .
Assume small airplane with seat numbering as follows : The program should display the seat pattern , with an marking the seats already assigned .
For example , after seats , and are taken , the display should look like this :

Chapter Arrays After displaying the seats available , the program prompts for the seat desired , the user types in seat , and then the display of available seats is updated .
This continues until all seats are filled or until the user signals that the program should end .
If the user types in seat that is already assigned , the program should say that that seat is occupied and ask for another choice .

Write program that accepts input like the program in Display and that outputs bar graph like the one in that display except that your program will output the bars vertically rather than horizontally .
array may be useful .

We define each cell to have eight neighbor cells .
The neighbors of cell are the cells directly above , below , to the right , to the left , diagonally above to the right and left , and diagonally below to the right and left .

If an occupied has more than three neighbors , it dies of overcrowding .

dying for whatever reason may help cause birth , but newborn cannot resurrect that is dying , nor will death prevent the death of another , say , by reducing the local population .

Notes : Some configurations grow from relatively small starting configurations .
Others move across the region .
It is recommended that for text output Programming Projects you use rectangular array of char with columns and rows to store the LIFE successive generations .
Use an asterisk to indicate living  and use blank to indicate an empty .
If you have screen with more rows than that , by all means make use of the whole screen .

Suggestions : Look for stable configurations .
That is , look for communities that repeat patterns continually .
The number of configurations in the repetition is called the period .
There are configurations that are fixed , which continue without change .
possible project is to find such configurations .

Hints : Define void function named generation that takes the array we call world , an by array of char , which contains the initial configuration .
The function scans the array and modifies the cells , marking the cells with births and deaths in accord with the rules listed earlier .
This involves examining each in turn , either killing the  letting it live , or , if the is empty , deciding whether should be born .
There should be function display that accepts the array world and displays the array on the screen .
Some sort of time delay is appropriate between calls to generation and display .
To do this , your program should generate and display the next generation when you press Return .
You are at liberty to automate this , but automation is not necessary for the program .

Your program should first load all boy names and girl names from the file into separate arrays .
Search for the target name from the arrays , not directly from the file .

Your program should not be to create bar chart of exactly four integers , but should be able to graph an array of up to integers .
Scale the graph appropriately in the horizontal and vertical dimensions so the bar chart fits within by pixel area .
You can impose the constraint that all integers in the array are nonnegative .
Use the sentinel value of to indicate the end of the values to draw in the bar chart .

Chapter Arrays create the bar chart with values , and , your program would operate on the array : Test your program by creating several bar charts with different values and up to entries and view the resulting SVG files to ensure that they are drawn correctly .

common memory matching game played by young children is to start with deck of cards that contains identical pairs .
For example , given six cards in the deck , two might be labeled " two might be labeled " and two might be labeled " The cards are shuffled and placed face down on the table .
The player then selects two cards that are face down , turns them face up , and if they match they are left face up .
If the two cards do not match , they are returned to their original position face down .
The game continues in this fashion until all cards are face up .

Write program that plays the memory matching game .
Use cards that are laid out in square and are labeled with pairs of numbers from to .
Your program should allow the player to specify the cards that she would like to select through coordinate system .

For example , suppose the cards are in the following layout : All of the cards are face down except for the pair , which has been located at coordinates , and ,
To hide the cards that have been temporarily placed face up , output large number of newlines to force the old board off the screen .

Write function that " the cards in the array by repeatedly selecting two cards at random and swapping them .
Random Your swim school has two swimming instructors , Jeff and Anna .
Their current schedules are shown below .
An " denotes time slot that is occupied with lesson .

Programming Projects Jeff Monday .

Thursday .

Write program with capable of storing the schedules .
Create main menu that allows the user to mark time slot as busy or free for either instructor .
Also , add an option to output the schedules to the screen .
Next , add an option to output all time slots available for individual lessons when at least one instructor is .
Finally , add an option to output all time slots available for group lessons both instructors are .

Modify Programming Project by adding menu options to load and save the schedules from file .

One way to combat this problem is with randomized system .
In these systems , the user enters different information every time based on secret in response to randomly generated challenge .
Consider the following scheme in which the password consists of PIN number to .
Each digit is assigned random number that is , or .
The user enters the random numbers that correspond to their PIN instead of their actual PIN numbers .

For example , consider an actual PIN number of .
To authenticate the user would be presented with screen such as :

Chapter Arrays PIN : NUM : The user would enter instead of .
This divulge the password even if an attacker intercepts the entry because could correspond to other PIN numbers , such as or .
The next time the user logs in , different sequence of random numbers would be generated , such as : PIN : NUM : Your program should simulate the authentication process .
Store an actual PIN number in your program .
The program should use an array to assign random numbers to the digits from to .
Output the random digits to the screen , input the response from the user , and output whether or not the response correctly matches the PIN number .

The Social Security Administration maintains an actuarial life table that contains the probability that person in the United States will die .
The death probabilities from this table for are stored in the file and it is included on the website for the book .
There are three values for each row , the age , death probability for male , and death probability for female .
For example , the first five lines are : This says that year old female has chance of dying .

Write program that reads the data into arrays from the file .
Next , let the user enter his or her sex and age .
The program should simulate to what age the user will live by starting with the death probability for the current age and sex .
Generate number between ; if this number is less than or equal to the death probability then predict that the user will live to the current age .
If the number is greater than the death probability then increase the age by one and repeat the calculation with new number for the next probability value .

If the simulation reaches age then stop predict that the user will live to .
This program is merely simulation will give different results each time it is run , assuming you change the seed for the number generator .

Strings Vectors An Array Type for Strings Values Variables  with Strings Other Functions in  Copying past the end of using strcpy Input Output Conversions Robust Input The Standard Introduction to the Standard with the Programming Tip : More Versions of getline  Mixing cin variable ; getline Chapter Summary Answers to Exercises String Processing with the Programming Example : Palindrome Testing Converting between Objects Strings Converting Between Strings Numbers Vectors Vector Basics  Square Brackets Beyond the Vector Size Programming Tip : Vector Assignment Is Well Behaved Efficiency Issues Practice Programs Programming Projects Polonius : What do you read my lord .

Hamlet : Words , words , words .

William Shakespeare , Hamlet Introduction This chapter discusses two topics that use arrays or are related to arrays : strings vectors .
Although strings vectors are very closely related , this relationship is not always obvious , no one of these topics depends on the other .
The topics of strings vectors can be covered in either order .

Sections present two types whose values represent strings of characters , such as .
One type , discussed in Section , is just an array with base type char that stores strings of characters in the array marks the end of the with the null character .
This is the older way of representing strings , which inherited from the programming language .
These sorts of strings are called strings .
Although strings are an older way of representing strings , it is difficult to do any sort of processing in without at least passing contact with strings .
For example , quoted strings , such as , are implemented as strings in .

The standard includes more modern stringhandling facility in the form of the class .
The class is the second type that we will discuss in this chapter is covered in Section .

Vectors can be thought of as arrays that can grow in length while your program is running .
In , once your program creates an array , it cannot change the length of the array .
Vectors serve the same purpose as arrays except that they can change length while the program is running .

Prerequisites Sections , which cover strings , Section which covers vectors , are independent of each other .
If you wish to cover vectors before strings , that is fine .

Section on strings uses material from Chapters through , Sections , of Chapter .
Section on the class uses Section material from Chapters through Sections , of Chapter .
Section on vectors uses material from Chapters through Sections , of Chapter .

In this section we describe one way to represent strings of characters , which has inherited from the language .
In Section we describe class that is more modern way to represent strings .
Although the type described here may be bit " it is still widely used is an integral part of the language .

Values Variables One way to represent is as an array with base type char .
If the is , it is handy to represent it as an array of characters with six indexed variables : five for the five letters in " plus one for the character , which serves as an end marker .
The character ' is called the null character is used as an end marker because it is distinct from all the " characters .
The end marker allows your program to read the array one character at time know that it should stop reading when it reads the end marker .
stored in this way an array of characters terminated with is called .

We write ' with two symbols when we write it in program , but just like the character , the character ' is really only single character value .
Like any other character value , can be stored in one variable of type char or one indexed variable of an array of characters .

The Null Character , The null character , is used to mark the end of that is stored in an array of characters .
When an array of characters is used in this way , the array is often called variable .
Although the null character ' is written using two symbols , it is single character that fits in one variable of type char or one indexed variable of an array of characters .

In , literal  such as , is stored as  although you seldom need to be aware of this detail .

variable is just an array of characters .
Thus , the following array declaration provides us with variable capable of storing value with nine or fewer characters : char ; The is for the nine letters in the plus the null character ' to mark .

Chapter Strings and Vectors variable is partially filled array of characters .
Like any other partially filled array , variable uses positions starting at indexed variable through as many as are needed .
However , variable does not use an int variable to keep track of how much of the array is currently being used .
Instead , string variable places the special symbol ' in the array immediately after the last character of the string .
Thus , if contains the string , then the array elements are filled as shown here : variables vs .

The character ' is used as sentinel value to mark the end of the string .

If you read the characters in the string starting at indexed variable , proceed to , and then to , and so forth , you know that when you encounter the symbol , you have reached the end of the string .
Since the symbol ' always occupies one element of the array , the length of the longest string that the array can hold is less than the size of the array .

The thing that distinguishes variable from an ordinary array of characters is that variable must contain the null character ' at the end of the value .
This is distinction in how the array is used rather than distinction about what the array is .
variable is an array of characters , but it is used in different way .

Variable Declaration variable is the same thing as an array of characters , but it is used differently .
variable is declared to be an array of characters in the usual way .

Syntax char +

The + allows for the null character , which terminates any string stored in the array .
For example , the variable in the example can hold string that is ten or fewer characters long .

Initializing variables You can initialize variable when you declare it , as illustrated by the following .

When you initialize variable , you can omit the array size .
will automatically make the size of the variable more than the length of the quoted string .

The first of these two possible initializations places the null character ' in the array after the characters , and .
The second one does not put ' anywhere in the array .

Initializing Variable variable can be initialized when it is declared , as illustrated by the following example : char Be ; Initializing in this way automatically places the null character , in the array at the end of the string specified .

If you omit the number inside the square brackets , then the variable will be given size one character longer than the length of the string .
For example , the following declares to have nine and one for the null character : char Be ; variable is an array , so it has indexed variables that can be .

Chapter Strings and Vectors the value in to string of the same length consisting of all '

If the array loses the value , it will no longer behave like variable .
For example , the following will change the array so that it no longer contains string : char ; After this code is executed , the array will still contain the six letters in the , but will no longer contain the null character ' to mark the end of the string .
Many functions depend critically on the presence of ' to mark the end of the value .

As another example , consider the previous while loop that changed characters in the variable .
That while loop changes characters until it encounters .
If the loop never encounters , then it could change large chunk of memory to some unwanted values , which could make your program do strange things .
As safety feature , it would be wise to rewrite that while loop as follows , so that if the null character ' is lost , the loop will not inadvertently change memory locations beyond the end of the array : int .

You cannot variable in an assignment statement .
If you to test strings for equality , you will not get the result you expect .
The reason for these problems is that strings variables are arrays .

Assigning value Illegal .

Although you can the equal sign to assign value to variable when the variable is declared , you cannot do it anywhere else in your program .

Technically , of the equal sign in declaration , as in char ; is an initialization , not an assignment .
If you want to assign value to variable , you must do something else .

There are number of different ways to assign value to variable .
The easiest way is to the predefined function strcpy as shown : This will set the value of equal to .
Unfortunately , this version of the function strcpy does not check to make sure the copying does not exceed the size of the string variable that is the first argument .

Many , but not all , versions of also have safer version of strcpy .

This safer version is spelled strncpy an .
The function strncpy takes third argument that gives the maximum number of characters to copy .
For example : char ; will be copied from the variable , no matter how long the string in may be .

You also cannot the in an expression to test whether two strings are the same .
You can with strings , but it does not test for the strings being equal .
So if you to test two strings for equality , you are likely to get incorrect results , but no error To test whether two strings are the same , you can the predefined function strcmp .
For example : strings are NOT the ; else strings are the ; Note that the function strcmp works differently than you might guess .
The comparison is true if the strings do not match .
The function strcmp compares the characters in the arguments character at time .
If at any point the numeric encoding of the character from is less than the numeric encoding of the corresponding character from , the testing stops , Testing strings for equality Chapter Strings Vectors negative number is returned .
If the character from is greater than the character from , then positive number is returned .

The ordering relationship used for comparing characters is called lexicographic order .
The important point to note is that if both strings are all in uppercase or all in lowercase , then lexicographic order is just alphabetic order .

We see that strcmp returns negative value , positive value , or zero , depending on whether the strings compare lexicographically as less , greater , or equal .
If you strcmp as Boolean expression in an if or looping statement to test strings for equality , then the nonzero value will be converted to true if the strings are different , the zero will be converted to false .
Be sure that you remember this inverted logic in your testing for equality .
compilers that are compliant with the standard have safer version of strcmp that has third argument that gives the maximum number of characters to compare .

The functions strcpy strcmp are in the library with the header file , so to them you would insert the following near the top of the file :

However , when processing strings , you inevitably will some of the predefined string functions in the library .
So , when strings , you will normally give the following directive near the beginning of the file with your code : Other Functions in Display contains few of the most commonly used functions from the library with the header file .
To them , you insert the following near the top of the file : As you will see in Chapter , the definitions of strcpy strcmp , all other string functions in , are placed in the global namespace , not in the std namespace , so no directive is required .

Does not check to make sure is large enough to hold the value .

If Limit is chosen carefully , this is safer than the twoargument version of strcpy .

Not implemented in all versions of .

Does not check to see that is large enough to hold the result of the concatenation .

Returns an integer equal to the length of .

Returns value if is less than .
Returns value if is greater If Limit is chosen carefully , this is safer than the twoargument version of strcat .

Not implemented in all versions of .

If equals , this function returns , which converts to false .
Note that this is the reverse of what you might expect it to return when the strings are equal .

The order is lexicographic .

If Limit is chosen carefully , this is safer than the version of strcmp .
Not implemented in all versions of .

The function strlen is easy to understand and use .
For example , returns because there are six characters in .

The function strcat is used to concatenate two strings , that is , to form longer string by placing the two shorter strings .
The first argument must be variable .
The second argument can be anything that evaluates to value , such as quoted string .
The result is placed in the variable that is the first argument .
For example , consider the following : char ; This code will change the value of to rainin .
As this example illustrates , you need to be careful to account for blanks when concatenating strings .

If you look at the table in Display , you will see that safer , threeargument versions of the functions strcpy , strcat , and strcmp are available in many , but not all , versions of .
Also , note that these threeargument versions are spelled with an added letter : strncpy , strncat , and strncmp .

Arguments and Parameters variable is an array , so parameter to function is simply an array parameter .

As with any array parameter , whenever function changes the value of parameter , it is safest to include an additional int parameter giving the declared size of the variable .

On the other hand , if function only uses the value in argument but does not change that value , then there is no need to include another parameter to give either the declared size of the variable or the amount of the variable array that is filled .
The null character ' can be used to detect the end of the value that is stored in the variable .

This is dangerous because the strcpy function put any bounds on how much data to copy .
It will simply copy everything from the source string to the target string until the null character is encountered .
If the source is larger than the target then data will be copied past the memory allocated for the target string .
Here is simple example where we could have .

It could even open up your system to attack by malicious users .
This has been such serious problem that some compilers will not compile code that uses strcpy unless you override the warning .
Assuming your compiler does allow you to use strcpy , one way to fix the problem is to only copy the Cstring if it is less than five characters long .
Consider the following attempt to avoid exceeding the size of the .

This may seem reasonable since we are only creating an array of size and signed char can store values up to .
This version will work fine for small source strings .
But what if we input source string that is characters long .
This causes overflow and results in negative value copied into .
As result the program enters the if statement and erroneously copies the source data to the target array .
To avoid this problem we should make an int same size returned by , use strncpy to cap the maximum copy  or use the string class described in the next section .

Chapter Strings and Vectors st Exe cis .
Which of the following declarations are equivalent .

Assume that the code is embedded in complete program and that an include directive for is in the program file .

Suppose the function strlen returns the of its string was not already defined for you .
Give function definition for strlen .
Note that strlen has only one argument , which is string .
Do not add additional arguments ; they are not needed .

What is the maximum of string that can be placed in the string variable declared by the following declaration .

How many characters are in each of the following character and string constants .

Since character strings are just arrays of char , why does the text caution you not to confuse the following declaration and initialization .

For correct variables , the following loop reassigns all positions of the value , leaving the the same as before .
Assume this code fragment is embedded in an otherwise complete and correct program .
Answer the questions following this code fragment : int .

Chapter Strings and Vectors Input and Output strings can be output using the insertion operator .
In fact , we have already been doing so with quoted strings .
You can use variable in the same way ; for example , where is variable .

It is possible to fill variable using the input operator , but there is one thing to keep in mind .
As for all other types of data , all whitespace , tabs , and line are skipped when strings are read this way .

Moreover , each reading of input stops at the next space or line break .
For example , consider the following .

When embedded in complete program , this code produces dialogue like the following : Enter some input : Do bedo to you .

Dobedo END OF OUTPUT The variables and each receive only one word of the input : receives the value " because the input character following Do is blank ; receives " because the input character following be is blank .

If you want your program to read an entire line of input , you can use the extraction operator to read the line one word at time .
This can be tedious and it still will not read the blanks in the line .
There is an easy way to read an entire line of input and place the resulting string into variable : Just use the predefined member function getline , which is member function of every input stream as cin or file input .
The function getline has two arguments .
The first argument is variable to receive the input and the second is an integer that typically is the declared size of the variable .
The second argument tells the maximum number of array elements in the variable that getline will be allowed to fill with characters .
For example , consider the following .

Do be do to OF OUTPUT With the function , the entire line is read .
The reading ends when the line ends , even though the resulting string may be shorter than the maximum number of characters specified by the second argument .

When getline is executed , the reading stops after the number of characters given by the second argument have been filled in the array , even if the end of the line has not been reached .
For example , consider the following .

When embedded in complete program , this code produces dialogue like the following : Enter some input : dobedowap dobeEND OF OUTPUT Notice that four , not five , characters are read into the variable string , even though the second argument is .
This is because the null character ' fills one array position .
Every string is terminated with the null character when it is stored in variable , and this always consumes one array position .

The input and output techniques we illustrated for and cin work the same way for input and output with files .
The input stream cin can be replaced by an input stream that is connected to file .
The output stream can be replaced by an output stream that is connected to file .

Syntax , + One line of input is read from the stream , and the resulting string is placed in .
If the line is more than Characters long , then only the first on the line .

Chapter Strings and Vectors are read .

st Exe cis .
Consider the following code assume it is embedded in complete .

If the dialogue begins as follows , what will be the next line of output .

Enter some input : The time is now .

Consider the following code assume it is embedded in complete .

Enter line of input : May the hair on your toes grow long and curly .

Conversions and Robust Input The string " and the number are not the same things .
The first is sequence of characters ; the second is number .
In everyday life , we An Array Type for Strings write them the same way and blur this distinction , but in program this distinction cannot be ignored .
If you want to do arithmetic , you need , not .
If you want to add comma to the numeral for one thousand two hundred thirty four , then you want to change the string " to the string .
When designing numeric input , it is often useful to read the input as string of characters , edit the string , and then convert the string to number .
For example , if you want your program to read an amount of money , the input may or may not begin with dollar sign .
If your program is reading percentages , the input may or may not have percent sign at the end .
If your program reads the input as string of characters , it can store the string in variable and remove any unwanted characters , leaving only string of digits .
Your program then needs to convert this string of digits to number , which can easily be done with the predefined function atoi .

The function atoi takes one argument that is string and returns the returns the integer .
If the argument does not correspond to an int value , then atoi returns .
For example , returns , because the character ' is not digit .
You pronounce atoi as to " which is an Functions The functions atoi , atol , and atof can be used to convert string of digits to the corresponding numeric value .
The functions atoi and atoll convert strings to integers .
The only difference between atoi and atol is that atoi returns value of type int whereas atol returns value of type long .
The function atof converts string to is such that the conversion cannot be made , then the function returns zero .
For example int .

Chapter Strings and Vectors abbreviation of to " The function atoi is in the library with header file cstdlib , so any program that uses it must contain the following directive : If your numbers are too large to be values of type int , you can convert them from strings to values of type long .
The function atol performs the same conversion as the function atoi except that atol returns values of type long and thus can accommodate larger integer values systems where this is .

Display contains the definition of function called that reads line of input and discards all characters other than the digits ' through .
The function then uses the function atoi to convert the " string of digits to an integer value .
As the demonstration program indicates , you can use this function to read money amounts and it will not matter whether the user included dollar sign or not .
Similarly , you can read percentages and it will not matter whether the user types in percent sign or not .
Although the output makes it look as if the function clean simply removes some symbols , more than that is happening .
The value produced is true int value that can be used in program as number ; it is not string of characters .

The function shown in Display will delete any nondigits from the string typed in , but it cannot check that the remaining digits will yield the number the user has in mind .
The user should be given chance to look at the final value and see whether it is correct .
If the value is not correct , the user should be given chance to reenter the input .
In Display we have used the function in another function called , which will accept anything the user types and will allow the user to reenter the input until she or he is satisfied with the number that is computed from the input string .
It is very robust input procedure .
Programming Project at the end of this chapter asks you to define function similar to that reads in number of type double , as opposed to number of type int .
To write that function , it would be nice to have predefined function that converts string value to number of type double .
Fortunately , the predefined function atof , which is also in the returns the value of type double .
If the argument does not correspond to number of type double , then atof returns .
You pronounce atof as to " which is an abbreviation of to floating " Recall that numbers with decimal point are often called numbers because of the way the computer handles the decimal point when storing these numbers in memory .

Chapter Strings and Vectors .

Sample Dialogue Enter an and press Return : That string converts to the Again .

Discards all symbols except the digits .
Converts string to an and sets equal to the value of this .

Chapter Strings and Vectors The Standard string Class try to catch every sentence , every word you and say , and quickly lock all these sentences and words away my literary storehouse because they might come handy .

Anton Chekhov , The Seagull In Section , we introduced strings .
These strings were simply arrays of characters terminated with the null character .
In order to manipulate these strings , you needed to worry about all the details of handling arrays .

For example , when you want to add characters to string and there is not enough room the array , you must create another array to hold this longer string of characters .
In short , strings require the programmer to keep track of all the details of how the strings are stored memory .
This is lot of extra work and source of programmer errors .
The latest standard for specified that must now also have class string that allows the programmer to treat strings as basic data type without needing to worry about implementation details .
In this section we introduce you to this string type .

Introduction to Standard Class string The class string is defined library whose name is also , and definitions are placed std namespace .
So , order to use class string , your code must contain following something more or less : using namespace std ; + operator does concatenation The class allows you to treat values and expressions very much like values of simple type .
You can use operator to assign value to variable , and you can use + sign to concatenate two strings .
For example , suppose , and are objects of type and both and have values .
Then can be set equal to concatenation of value followed by value as follows : + There is no danger of being too small for its new value .
If sum of lengths of and exceeds capacity of , then more space is automatically allocated for .

As we noted earlier this chapter , quoted strings are really strings and so they are not literally of type .
However , provides automatic type casting of quoted strings to values of type .
So , you can use quoted strings as if they were literal values of type  and we most will often refer to quoted strings as if they were values of type .
For example , sets value of variable to object with same .

The class also has second constructor that takes one argument that is standard and so can be quoted .
This second constructor initializes object to value that represents same as its argument .
For example , phrase ; The first line declares variable phrase and initializes it to empty The second line declares noun to be of type and initializes it to value equivalent to .
Most programmers when talking loosely would say that  is initialized to " but there really is type conversion here .
The quoted " is  not value of type .
The variable receives value that has same characters as " same order as , but value is not terminated with null character .
In fact , theory at least , you do not know or care whether value of is even stored an array , as opposed to some other data structure .

There is an alternate notation for declaring variable and invoking constructor .
The following two lines are exactly equivalent :

Consider following line from Display : love  + adjective +   + + must do lot of work to allow you to concatenate strings this simple and natural fashion .
The constant love " is not an object of type constant like love " is stored as other words , as array of .
When sees love " as an argument to + it finds definition of + that applies to value such as .
There are overloadings of + operator that have on left and on right , as well as reverse of this positioning .
There is even version that has on both sides of + and produces object as value returned .
Of course , there is also overloading you expect , with type for both operands .

did not really need to provide all those overloading cases for +
If these overloadings were not provided , would look for constructor that could perform type conversion to convert love " to value for which + did apply .
In this case , constructor with one parameter would perform just such conversion .
However , extra overloadings are presumably more efficient .

The class is often thought of as modern replacement for strings .
However , you cannot easily avoid also using strings when you program with class .

Converting constants to type Chapter Strings and Vectors Display Program Using Class .

love fried ants .

The Class The class can be used to represent values that are strings of characters .
The class provides more versatile representation than strings discussed in Section .

The class is defined in library that is also named , and its definition is placed in std namespace .
So , programs that use class should contain following something more or less : using namespace std ; The class has default constructor that initializes the object to the empty and constructor that takes as an argument and initializes the object to value that represents the given as the argument .
For example : The Standard Class with the Class string You can use the insertion operator and cout to output string objects just as you do for data of other types .
This is illustrated in Display .
Input with the class string is bit more subtle .

The extraction operator and cin work the same for string objects as for other data , but remember that the extraction operator ignores initial whitespace and stops reading when it encounters more whitespace .

May the hair on your toes grow long and curly .

The variable receives the string .
Using the extraction operator and cin , you can only read in words ; you cannot read in line or other string that contains blank .
Sometimes this is exactly what you want , but sometimes it is not at all what you want .

If you want your program to read an entire of input into variable of type string , you can use the function getline .
The syntax for using getline with string objects is bit different from what we described for strings in Section .
You do not use ; instead , you make cin the first argument to , this version of getline is not member .

When embedded in complete program , this code produces dialogue like the following : Enter some input : Do bedo to you .

Do bedo to OF OUTPUT If there were leading or trailing blanks on the  then they too would be part of the string value read by getline .
This version of getline is in the This is bit ironic , since the class string was designed using more modern objectoriented techniques , and the notation it uses for getline is the old fashioned , less notation .
This is an accident of history .
This getline function was defined after the iostream library was already in use , so the designers had little choice but to make this getline function .

Chapter Strings and Vectors library .
You can use stream object connected to text file in place of cin to do input from file using getline .

You cannot use cin and to read in blank character .
If you want to read one character at time , you can use , which we discussed in Chapter .

The function reads values of type char , not of type  but it can be helpful when handling input .
Display contains program that illustrates both getline and used for input .

Sample Dialogue Enter your first and last name : Torres Your name in our records is : Torres , Our is Your records are our records .

Please suggest better  Our records go where no records dared to go before .

Our new will be : Our records go where no records dared to go before .

with Objects You can use the insertion operator with to output objects .
You can input with the extraction operator and cin .
When using for input , the code reads in delimited with whitespace .
You can use the function getline to input an entire of text into object .

Enter of input : is joy forever .

Consider the following code assume that it is embedded in .

Enter line of input : is joy forever .

This version stops reading when it encounters the marker .

There is version that allows you to specify different character to use as stopping signal .
For example , the following will stop when the first question mark is .

It makes sense to use getline as if it were void function , but it actually returns reference to its first argument , which is cin in the code above .
Thus , the following will read line of text into and of nonwhitespace characters into :

The first version of this function reads characters from the istream object given as the first argument cin in this , inserting the characters into the variable until an instance of the delimiter character is encountered .
The delimiter character is removed from the input and discarded .
The second version uses ' for the default value of delimiter ; otherwise , it works the same .

These getline functions return their first argument cin in this , but they are usually used as if they were void functions .

When this code reads the following input , you might expect the value of to be set to and the value of line to be set to value representing : Hello hitchhiker .

However , while is indeed set to the value of , line is set equal to the empty .

Using cin skips leading whitespace on the input , but leaves the rest of the line , in this case just , for the next input .
statement like cin ; VideoNote Example using cin and getline with the class Chapter Strings and Vectors always leaves something on the line for following getline to read if it is just the .
In this case , the getline sees the ' and stops reading , so getline reads an empty .
If you find your program appearing to mysteriously ignore input data , see if you have mixed these two kinds of input .
You may need to use either the function from Display or the function ignore from the library iostream .
For example , With these arguments , call to the ignore member function will read and discard the entire rest of the line up to and including the ' until it discards characters if it does not find the end of the line after .

There can be other baffling problems with programs that use cin with both and getline .
Moreover , these problems can come and go as you move from one compiler to another .
When all else fails , or if you want to be certain of portability , you can resort to input using .

These problems can occur with any of the versions of getline that we discuss in this chapter .

You can access the characters in string object in the same way that you access array elements , so string objects have all the advantages of arrays of characters plus number of advantages that arrays do not have , such as automatically increasing their capacity .
If is the name of string object , then gives access to the ith character in the string represented by .
This use of array square brackets is illustrated in Display .

Display also illustrates the member function length .
Every string object has member function named length that takes no arguments and returns the length of the string represented by the string object .
Thus , not only can string object be used like an array but the length member function makes it behave like partially filled array that automatically keeps track of how many positions are occupied .

When used with an object of the class string , the array square brackets do not check for illegal indexes .
If you use an illegal index is , an index that is greater than or equal to the length of the string in the , then the results are unpredictable but are bound to be bad .
You may just get strange behavior without any error message that tells you that the problem is an illegal index value .

There is member function named at that does check for illegal index values .
This member function behaves basically the same as the square brackets , except for two points : You use function notation with at , so instead The Standard string Class Display string Object Can Behave Like an Array .

Sample Dialogue Enter your first and last name : John Crichton Your last name is spelled : c Good John of , you use ; and the at member function checks to see if evaluates to an illegal index .
If the value of in is an illegal index , then you should get error message telling you what is wrong .
In the following two example code fragments , the attempted access is out of range , yet the first of these probably will not produce an error message , although it will be accessing nonexistent indexed variable : string .

Chapter Strings and Vectors .

You can change single character in the string by assigning char value to the indexed variable , such as .

For example , to change the third character in the string object to , you can use either of the following code fragments :

As in an ordinary array of characters , character positions for objects of type string are indexed starting with , so third character in string is in index position .

Display gives partial list of member functions of class string .
In many ways , objects of class string are better behaved than strings we introduced in Section .
In particular , operator on objects of class returns result that corresponds to our intuitive notion of strings being , it returns true if two strings contain same characters in same order , and returns false otherwise .

Similarly , comparison , compare objects using lexicographic ordering .

If strings consist of all letters and are both either all uppercase or all lowercase letters , then for this case lexicographic ordering is same as Example Remarks .

All are lexicographical comparisons .

Returns index of first occurrence of in .

Palindrome Testing palindrome is that reads same front to back as it does back to front .

The program in Display tests an input to see if it is palindrome .
Our palindrome test will disregard all spaces and punctuations and will consider and lowercase versions of letter to be same when deciding if something is palindrome .
Some palindrome examples are as follows : Able was ere saw Elba .

Love Me , Vol .

Madam , Adam .

man , plan , canal , Panama .

Rats live on no evil star .

The member function substr extracts substring of calling object , given position and length of desired substring .

Chapter Strings Vectors .

Sample Dialogue Enter candidate for palindrome test followed by pressing Return .

Madam , Adam .

Sample Dialogue Enter candidate for palindrome test followed by pressing Return .

Radar " is palindrome .

Sample Dialogue Enter candidate for palindrome test followed by pressing Return .

To do this , string that is the substring of , of length at each character position , is extracted .
If this string is not in the punct string , then the onecharacter string is concatenated to the string that is to be returned .

They do not misbehave as they do with the strings , as we discussed in Section st xer cis .

Enter line of input : Hello friend .

Converting Between string Objects Strings You have already seen that will perform an automatic type conversion to allow you to store string in variable of type string .
For example , the following will work fine :

To obtain the string corresponding to string object , you must perform an explicit conversion .

As we noted earlier in this chapter , the assignment operator does not work with strings .
So , just in case you thought the following might work , we should point out that it too is illegal .

Use stof , stod , stoi , or stol to convert string to float , double , int , or long , respectively .
Use to convert numeric type to string .
These functions are illustrated in the following .

In , once your program creates an array , it cannot change the length of the array .
Vectors serve the same purpose as arrays except that they can change length while the program is running .
Vectors are part of standard library known as the STL Template , which we cover in more detail in Chapter .

You need not read the previous sections of this chapter before covering this section .

Vector Basics Like an array , has base type , like an array , stores collection of values of its base type .
However , the syntax for type variable declaration are different from the syntax for arrays .

You declare variable for with base type int as follows : notation is template class , which means you can plug in any type for that will produce class for vectors with that base type .
You can think of this as specifying the base type for in the same sense as you specify base type for an array .
You can use any type , including class types , as the base type for .

Vector elements are indexed starting with , the same as arrays .
For example , the following changes the value of the ith element ;  answer  There  however , restriction on this use of the square brackets notation with vectors that unlike the same notation used with arrays .
You can use to change the value of the ith element .
However , you cannot initialize the ith element using ; you can only change an element that has already been given some value .
To add an element to an index position of for the first time , you would normally use the member function .

Declaring variable Chapter Strings Vectors You add elements to in order of positions , first at position , then position , then , so forth .
For example , the following gives initial values to elements , and of the .

The number of elements in called the size of the .
The member function size can be used to determine how many elements are in .
For example , after the previously shown code executed , returns .

You can write out all the elements currently in the as follows : endl ; The function size returns value of type unsigned int , not value of type int .
If you want to be very safe , you can always apply type cast to convert the returned unsigned int to an int or , in cases like this for loop , use loop control variable of type unsigned int as follows :

There constructor that takes one integer argument and will initialize the number of positions given as the argument .
For example , if you declare as follows : then the first ten elements are initialized to , and would return .
You can then set the value of the ith element using for values of equal to through .
In particular , the following could immediately follow the declaration :  Vectors Display Using Vector .

Sample Dialogue Enter list of positive numbers .

Place negative number at the end .

When you use the constructor with an integer argument , vectors of numbers are initialized to the zero of the number type .
If the base type class type , the default constructor used for initialization .

Chapter Strings and Vectors The definition given in the library  which places it in the std namespace .
Thus , file that uses vectors would the following .

Using Square Brackets Beyond the Vector Size If and greater than or equal to , then the element does not yet exist and needs to be created by using to add .

If it needs more capacity to store another element , its capacity is automatically increased .
Vectors are defined in the library , which places them in the std namespace .
Thus , file that uses vectors would the following something : using namespace .

Elements are added to using the member function , as illustrated below : Once an element position has received its first element , either with or with constructor initialization , that element position can then be accessed using square bracket notation , just like an array element .

Vector Assignment Is Well Behaved The assignment operator with vectors does an assignment to the on the side of the assignment operator capacity if needed and resetting the of the on the side of the assignment .
Thus , provided the assignment operator on the base type makes an independent copy of the element of the base type , then the assignment operator on the will make an independent copy .

Note that for the assignment operator to produce totally independent copy of the on the side of the assignment operator requires that the assignment operator on the base type make completely independent as the assignment operator on its base type .
Do not confuse the capacity of with the of .
The is the number of elements in  while the capacity is the number of elements for which there is memory allocated .
Typically , the capacity is larger than the  and the capacity is always greater than or equal to the .

Whenever runs out of capacity and needs room for an additional member , the capacity is automatically increased .
The exact amount of the increase is but always allows for more capacity than is immediately needed .
commonly used implementation scheme is for the capacity to double whenever it needs to increase .
Since increasing capacity is complex task , this approach of reallocating capacity in large chunks is more efficient than allocating numerous small chunks .

Size and Capacity The of is the number of elements in the .
The capacity of is the number of elements for which it currently has memory allocated .
For , the and capacity can be recovered with the member functions and .

You can completely ignore the capacity of and that will have no effect on what your program does .
However , if efficiency is an issue , you might want to manage capacity yourself and not simply accept the default behavior of doubling capacity whenever more is needed .
You can use the member function reserve to explicitly increase the capacity of .

Note that you can rely on to increase the capacity of  but it does not necessarily decrease the capacity of if the argument is smaller than the current capacity .

You can change the of using the member function resize .

For example , the following resizes to  If the previous was less than , then the new are initialized as we described for the constructor with an integer argument .
If the previous was greater than , then all but the first are lost .
The capacity is automatically increased if need be .
Using resize and reserve , you can shrink the and capacity of when there is no longer any need for some or some capacity .

st Exe cis .

Answers to Exercises Chapter Summary variable is same thing as an array of characters , but it is used in slightly different way .
string variable uses null character ' to mark end of string stored in array .

In particular , you cannot assign value to variable using equal  and you cannot compare values in two variables using operator .
Instead , you must use special functions to perform these tasks .

In particular , assignment equal  have their intuitive meaning when used with objects of class string .

Answe rs to est Exerci ses .
The following two are equivalent to each other not equivalent to any .

Chapter Strings Vectors .
If strlen were not already defined for you , you could use following definition : str contains string value terminated .

The maximum number of characters is five because sixth position is needed for null terminator .

The first of these places null character ' in array after characters ,
The second only assigns successive positions , but does not put ' anywhere .

To protect memory beyond end of array , change while condition as shown in .

The string , is too long for .
chunk of memory that belong to array will be overwritten .

Practice Programs .
Enter some input : The time is now .

OF OUTPUT .
The complete dialogue is as follows : Enter line of input : May hair on your toes grow long curly .

May OF OUTPUT .
OF OUTPUT .
string is joy OF OUTPUT .
The complete dialogue is Enter line of input : Hello friend .

Equal Remember , cin stops reading when it reaches whitespace character such as blank .

Hello Jello .
The program is legal .
The output is Note that changing does not change .
true independent is made with assignment 
The size is number of elements in  whereas capacity is number of elements for which there is memory allocated .
Typically , capacity is larger than size .

Practice Programs Practice Programs can generally be solved with short program that directly applies programming principles presented in this chapter .

Create Cstring variable that contains name , age , title .
Each field is separated by space .
For example , string might contain Programmer " or any other in same format .
Assume name , age , title have no spaces themselves .
Write program using only functions from cstring the class that can extract the name , age , title into separate variables .
Test your program with variety of names , ages , titles .

Chapter Strings Vectors .
Repeat Practice Program except use the class string to extract the fields , not the cstring functions .

Write program that inputs first and last name , separated by space , into string variable .
Use the string functions to output the first and last initial .

Embed your code into loop .
At the end of the loop ask the user if he or she would like to repeat the program .
Input the choice into char using cin .
If the character is ' then repeat the program , otherwise exit .

Beware of the pitfall with newlines when cin is mixed with getline .

Write function named that takes as input vector of integers .

The function should return true if the vector starts or ends with the digit .
Otherwise it should return false .
Test your function with vectors of different length and with the digit at the beginning of the vector , end of the vector , middle of the vector , and missing from the vector .

Write function named swapFrontBack that takes as input vector of integers .
The function should swap the first element in the vector with the last element in the vector .
The function should check if the vector is empty to prevent errors .
Test your function with vectors of different length and with varying front and back numbers .

Do Practice Program except change the program to use vectors of strings instead of arrays of strings .

Write program that inputs two variables , first and last , each of which the user should enter with his or her name .
First , convert both strings to all lowercase .
Your program should then create new that contains the full name in Pig Latin with the first letter capitalized for the first and last name .
The rules to convert word into Pig Latin are as follows : If the first letter is consonant , move it to the end and add " to the end .

If the first letter is vowel , add " to the end .

For example , if the user inputs " for the first name and " for the last name , then the program should create new with the text Onesjay " and print it .

Programming Projects Programming Projects require more than Practice Programs and can usually be solved many different ways .
Visit to complete many of these Programming Projects online and get instant feedback .

VideoNote Solution to Programming Project .
Write program that reads in sentence of up to characters and outputs the sentence with spacing corrected and with letters corrected for Programming Projects capitalization .
In other words , in the output sentence , all strings of two or more blanks should be compressed to single blank .
The sentence should start with an uppercase letter but should contain no other uppercase letters .
Do not worry about proper names ; if their first letters are changed to lowercase , that is acceptable .
Treat line break as if it were blank , in the sense that line break and any number of blanks are compressed to single blank .
Assume that the sentence ends with period and contains no other periods .
For example , the input the Answer to life , the Universe , and IS .

Write program that will read in line of text and output the number of words in the line and the number of occurrences of each letter .
Define word to be any of letters that is delimited at each end by either whitespace , period , comma , or the beginning or end of the line .
You can assume that the input consists entirely of letters , whitespace , commas , and periods .
When outputting the number of letters that occur in line , be sure to count and lowercase versions of letter as the same letter .

Output the letters in alphabetical order and list only those letters that do occur in the input line .
For example , the input line say Hi .

Give the function definition for the function with the following function .

You can assume that the user types in the input in normal everyday notation , such as , and does not use to type in the number .
Model your definition after the definition of the function given in Display so that your function reads the input as characters , edits the of characters , and converts the resulting to number of type double .
You will need to define function like .

Chapter Strings and Vectors that is more sophisticated than the one in Display , since it must cope with the decimal point .
This is fairly easy project .

For more difficult project , allow the user to enter the number in either the normal everyday notation , as discussed above , or in .

Your function should decide whether or not the input is in by reading the input , not by asking the user whether she or he will use .

Write program that reads name in the following format : first name , then middle name or initial , and then last name .
The program then outputs the name in the following format :

For example , the input Mary Average User should produce the output : User , Mary .

The input Mary .
User should also produce the output : User , Mary .

Your program should work the same and place period after the middle initial even if the input did not contain period .
Your program should allow for users who give no middle name or middle initial .
In that case , the output , of course , contains no middle name or initial .
For example , the input Mary User should produce the output User , Mary If you are using strings , assume that each name is at most characters long .
Alternatively , use the class .

Write program that reads in line of text and replaces all words with the word .
For example , the input string hate you , you dodo .

Programming Projects should produce the output love you , you love .

Of course , the output will not always make sense .
For example , the input string John will run home .

If the word starts with capital letter , it should be replaced by , not by .
You need not check capitalization , except for the first letter of word .
word is any string consisting of the letters of the alphabet and delimited at each end by blank , the end of the line , or any other character that is not letter .
Your program should repeat this action until the user says to quit .

Write program that reads in line of text and outputs the line with all the digits in all integer numbers replaced with .
For example , Input : My userID is and my digit pin is which is secret .

Output : My userID is and my digit pin is xxxx which is secret .

Note that if digit is part of word , then the digit is not changed to an .
For example , note that is NOT changed to johnxx .
Include loop that allows the user to repeat this calculation again until the user says she or he wants to end the program .

Write program that can be used to train the user to use less sexist language by suggesting alternative versions of sentences given by the user .
The program will ask for sentence , read the sentence into string variable , and replace all occurrences of masculine pronouns with pronouns .
For example , it will replace " with or .
Thus , the input sentence See an adviser , talk to him , and listen to him .

Be sure to preserve uppercase letters for the first word of the sentence .

The pronoun " can be replaced by ; your program need .

Chapter Strings and Vectors not decide between " and .
Allow the user to repeat this for more sentences until the user says she or he is done .

This will be long program that requires good deal of patience .
Your program should not replace the string " when it occurs inside another word , such as .
word is any string consisting of the letters of the alphabet and delimited at each end by blank , the end of the line , or any other character that is not letter .
Allow your sentences to be up to characters long .

Write sorting function that is similar to Display in Chapter except that it has an argument for vector of ints rather than an array .
This function will not need parameter like as in Display , since vector can determine the number used with the member function .

This sort function will have only this one parameter , which will be of vector type .
Use the selection sort algorithm was used in Display .

Redo Programming Project from Chapter , but this time use vectors instead of arrays .
You should do either Programming Project or before doing this one .
However , you will need to write your own sorting code for this project rather than using the sorting function from Programming Project or with no changes .

Your country is at war and your enemies are using secret code to communicate with each other .
You have managed to intercept message that reads as follows : The message is obviously encrypted using the secret code .
You have just learned that their encryption method is based upon the ASCII code .
Appendix shows the ASCII character set .
Individual characters in string are encoded using this system .
For example , the letter " is encoded using the number and " is encoded using the number .

Your secret code takes each letter of the message and encrypts it as follows : If + then Else For example , if the enemy uses then the message " would be encrypted as : Programming Projects Character ASCII code .

The ASCII codes for the unencrypted message are limited to the visible ASCII characters .

You only know that the key used is number between and .
Your program should try to decode the message using all possible keys between and .
When you try the valid key , the message will make sense .
For all other keys , the message will appear as gibberish .

Write program that inputs time from the console .
The time should be in the format AM " or .
Hours may be one or two digits , for example , AM " or .
Your program should include function that takes string parameter containing the time .
This function should convert the time into military time based on clock .

For example , AM " would output , PM " would output , and AM " would output .
The function may either write the time to the console or return string to be written to the console by the main function .

The XML Markup is common format used to structure and store data on the Web .
The following is small sample XML file that could be used to store names in an address book .
Type it in using text editor and save it to file named find it at the accompanying .

Chapter Strings and Vectors .
Elm Boundary The sample file contains four contacts .
The tag denotes the start of field and the tag denotes the end of the field .

Write program that reads in the file and outputs the names and addresses of everyone in Palmdale .
Your program output any of the tag information , just the address content .

Write program that reads in the address .

You may assume that each contact in the address file has the same structure and the same fields .
However , your solution should be able to handle an input file with any number of contacts and should not assume that the fields within each contact are in the same order .

Given the following header : VideoNote Solution to Programming Project target , string .

Programming Projects should return with the strings , and .

Write function that determines if two strings are anagrams .
The function should not be case sensitive and should disregard any punctuation or spaces .
Two strings are anagrams if the letters can be rearranged to form each other .
For example , plus two " is an anagram of plus string contains one , three , two , etc .
Test your function with several strings that are anagrams and .
You may use either the string class or string .

In many races competitors wear an RFID tag on their shoe or bib .
When the racer crosses sensor computer logs the number along with the current time .
Sensors can be placed along the course to accurately calculate the finish time or pace and also to verify that the racer crossed key checkpoints .
Consider such system in use for half marathon running race , which is miles .
In this problem there are only three sensors : at the  at the mile point , and at the finish line .

Here is sample data for three racers .
The first line is the gun time in the hour time format MM .
The gun time is when the race begins .
Subsequent lines are recorded by sensors and contain the sensor ID , followed by the number followed by the time stamp .
The time may be different than the gun time sometimes it takes racer little while to get to the starting line when there is large pack .

Write program that reads the log data into or .
The program should then allow user to enter number and it should output the overall finish place , race split times in for each split .

For more challenging version modify your program so that it works with an arbitrary number of sensors placed at different locations along the course instead of just locations .
You will need to specify the mile marker for each sensor .

Chapter Strings and Vectors .
Based on the log file described in Programming Project write program to detect cheating .

racer misses sensor , which is sign that the racer may have taken shortcut .

race split is suspiciously fast , which is sign that the racer may have hopped in vehicle .
In this case , race split faster than per mile can be considered suspicious .

The output should be list of suspected cheaters along with the reason for suspicion .

Pointers and Dynamic Arrays Pointers Pointer Variables Basic Memory Management Pitfall : Dangling Pointers Static Variables and Automatic Variables Programming Tip : Define Pointer Types Dynamic Arrays Array Variables and Pointer Variables Creating and Using Dynamic Arrays Pointer Arithmetic Chapter Summary Answers to Exercises Practice Programs Programming Projects Memory is necessary for all the operations of reason .

Blaise Pascal , PensÃ©es Introduction pointer is construct that gives you more control of the memory .

This chapter shows how pointers are used with arrays and introduces new form of array called dynamic array .
Dynamic arrays are arrays whose size is determined while the program is running , rather than being fixed when the program is written .

Prerequisites Section , which covers the basics of pointers , uses material from Chapters through .
It does not require any of the material from Chapters or .

Section , which covers dynamic arrays , uses material from Section , and Chapters through .
It does not require any of the material from Chapter .

Zen saying pointer is the memory address of variable .
Recall that the memory is divided into numbered memory locations and that variables are implemented as sequence of adjacent memory locations .
Recall also that sometimes the system uses these memory addresses as names for the variables .
If variable is implemented as , say , three memory locations , then the address of the first of these memory locations is sometimes used as name for that variable .
For example , when the variable is used as argument , it is this address , not the identifier name of the variable , that is passed to the calling function .

An address that is used to name variable in this way giving the address in memory where the variable is called pointer because the Pointers You have already been using pointers in number of situations .
As we noted in the previous paragraph , when variable is argument in function call , the function is given this argument variable in the form of pointer to the variable .
This is an important and powerful use for pointers , but it is done automatically for you by the system .
In this chapter , we show you how to write programs that manipulate pointers in any way you want , rather than relying on the system to manipulate the pointers for you .

Pointer Variables pointer can be stored in variable .
However , even though pointer is memory address and memory address is number , you cannot store pointer in variable of type int or double without type casting .
variable to hold pointer must be declared to have pointer type .
For example , the following declares to be pointer variable that can hold one pointer that points to variable of type double : double ; The variable can hold pointers to variables of type double , but it cannot normally contain pointer to variable of some other type , such as int or char .
Each variable type requires different pointer type .

In general , to declare variable that can hold pointers to other variables of specific type , you declare the pointer variable just as you would declare an ordinary variable of that type , but you place an asterisk in front of the variable name .
For example , the following declares the variables and so that they can hold pointers to variables of type int ; it also declares two ordinary variables , and , of type int : int , There must be an asterisk before each of the pointer variables .
If you omit the second asterisk in the previous declaration , then will not be pointer variable ; it will instead be an ordinary variable of type int .
The asterisk is the same symbol you have been using for multiplication , but in this context it has totally different meaning .

When discussing pointers and pointer variables , we usually speak of pointing rather than of addresses .
When pointer variable , such as , contains the address of variable , such as , the pointer variable is said to point to the variable or to be pointer to the variable .

Pointer variables , like and declared earlier , can contain pointers to variables like and .
You can use the operator to determine the address of variable , and you can then assign that address to pointer variable .
For example , the following will set the variable equal to pointer that points to the variable : Declaring pointer .

Addresses and Numbers pointer is an address , and an address is an integer , but pointer is not an integer .

insists that you use pointer as an address and that you not use it as number .
pointer is not value of type int or of any other numeric type .
You normally cannot store pointer in variable of type int .
If you try , most compilers will give you an error message or warning message .
Also , you cannot perform the normal arithmetic operations on pointers .
This is the same asterisk that we used when we declared , but now it has yet another meaning .
When the asterisk is used in this way , it is often called the dereferencing operator , and the pointer variable is said to be dereferenced .

Putting these pieces together can produce some surprising results .

Consider the following .

So when you set equal to , you are also setting equal to .

The symbol that is used to obtain the address of variable is the same symbol that you use in function declarations to specify parameter .

Recall that argument is implemented by giving the address of the argument to the calling function .

However , the usages are slightly different and we will consider them to be two different very closely usages of the symbol .

The and Operators The in front of pointer variable produces the variable it points to .
When used this way , the is called the dereferencing operator .

The operator in front of an ordinary variable produces the address of that variable ; that is , produces pointer that points to the variable .
The operator is called the operator .

For example , consider the declarations double ,  The following sets the value of so that points to the variable  produces the variable pointed to by  so after the assignment above , and refer to the same variable .
For example , the following sets the value of to , even though the name is never explicitly used : You can assign the value of one pointer variable to another pointer variable .
This copies an address from one pointer variable to another pointer variable .
For example , if is still pointing to , then the following will set so that it also points to :

When you add the asterisk , you are not dealing with the pointers and , but with the variables that the pointers are pointing to .
This is illustrated in Display .

Since pointer be used to refer to  your program manipulate variables even if the variables have no identifiers to name them .

The operator be used to create variables that have no identifiers to serve as their names .
These variables are referred to via pointers .
For example , the following creates of type and sets the pointer equal to the address of this is , points to this   This  be referred to as is , as the pointed to by .

For example , the following reads of type from the keyboard into this  adds to the  then outputs this .

You specify the type for this by writing the type name after the .
Variables that are created using the are called dynamic variables because they are created and destroyed while the program is running .
The program in Display demonstrates some simple operations on pointers and dynamic variables .

Display illustrates the working of the program in Display .
In Display , variables are represented as boxes and the of the is written inside the box .
We have not shown the actual numeric addresses in the pointer variables .
The actual numbers are not important .
What is important is that the number is the address of some particular .
So , rather than use the actual number of the address , we have merely indicated the address with an arrow that points to the with that address .
For example , in illustration in Display , contains the address of that has question mark written in it .

Chapter Pointers and Dynamic Arrays Sample Dialogue Hope you got the point of this example .

Pointer Variables If and are pointer variables , then the statement .

The Operator The creates of specified type and returns pointer that points to this .
For example , the following creates of type and leaves the pointer pointing to this 

It is possible to " the exception or install  but these topics are not covered until Chapter .

What unfortunate misinterpretation can occur the following declaration .

Give at least two uses of the .

Basic Memory Management special area of memory , called the freestore , is reserved for variables .
Any new created by program consumes some of the memory in the If your program creates too many variables , it consume all of the memory in the freestore .
If this happens , any additional calls to new fail .

The size of the freestore varies by computer and implementation of .

It is typically large , and modest program is not likely to use all the memory in the freestore .
However , even on modest programs it is good practice to recycle any freestore memory that is no longer needed .

The delete eliminates and returns the memory that the occupied to the freestore so that the memory can be reused .
Suppose that is pointer that is pointing to .
The following destroy the pointed to by and return the memory used by the to the freestore : delete  After this call to delete , the value of is undefined and should be treated like an uninitialized .

The delete Operator The delete eliminates and returns the memory that the occupied to the freestore .
The memory can then be reused to create new variables .
For example , the following eliminates the pointed to by the pointer  delete  After call to delete , the value of the pointer  like above , is undefined .
At that point , the value of the pointer is undefined , which means that you do not know where it is pointing , nor what the value is where it is pointing .
Moreover , if some other pointer was pointing to the that was destroyed , then this other pointer is also undefined .
These undefined pointer variables are called dangling pointers .
If is dangling pointer and your program applies the dereferencing to produce the expression , the result is unpredictable and usually disastrous .
Before you apply the dereferencing operator pointer variable , you should be certain that the pointer variable points to some variable .

Chapter Pointers and Dynamic Arrays Static Variables and Automatic Variables Variables created with the new are called variables , because they are created and destroyed while the program is running .
When compared with these variables , ordinary variables seem static , but the terminology used by programmers is bit more involved than that , and ordinary variables are not called static variables .

The ordinary variables we have been using in previous chapters are not really static .
If variable is local to function , then the variable is created by the system when the function is called and is destroyed when the function call is completed .
Since the main part of program is really just function called main , this is even true of the variables declared in the main part of your program .

We usually call these variables ordinary variables , but other books call them automatic variables .

There is one other category of variables , namely , global variables .
Global variables are variables that are declared outside of any function definition being outside of .
We discussed global variables briefly in Chapter .
As it turns out , we have no need for global variables and have not used them .

For example , the following defines type called IntPtr , which is the type for pointer variables that contain pointers to variables : typedef .

For example , the following defines the type name Kilometers to mean the same thing as the type name double : typedef double .

Kilometers distance ; Renaming existing types this way can occasionally be useful .
However , our main use of typedef be to define types for pointer variables .

There are two advantages to using defined pointer type names , such as IntPtr defined earlier .
First , it avoids the mistake of omitting an asterisk .

Remember , if you intend and to be pointers , then the following is mistake : Since the was omitted from the , the variable is just an ordinary int variable , not pointer variable .
If you get confused and place the on the int , the problem is the same but is more difficult to notice .
allows you to place the on the type name , such as int , so that the following is legal : Although this line is legal , it is misleading .
It looks like both and are pointer variables , but in fact only is pointer variable ; is an ordinary int variable .
As far as the compiler is concerned , the is attached to the identifier int may as well be attached to the identifier .
One correct way to declare both and to be pointer variables is int ,

IntPtr , The second advantage of using defined pointer type , such as IntPtr , is seen when you define function with parameter for pointer variable .
Without the defined pointer type name , you would need to include both an and an in the function declaration for the function , and the details can get confusing .
If you use type name for the pointer type , then parameter for pointer type involves no complications .

You define parameter for defined pointer type just like you define any other parameter .
sample : void .

Chapter Pointers and Dynamic Arrays Type Definitions You can assign name to type definition and then use the type name to declare variables .
This is done with the keyword typedef .

These type definitions are normally placed outside of the body of the main part of your program outside the body of other .

We will use type definitions to define names for pointer types , as shown in the example below .

Write definition for type called NumberPtr that will be the type for pointer variables that hold pointers to variables of type int .

Also , write declaration for pointer variable called that is of type NumberPtr .

You will also find out how to write programs with arrays .
array is an array whose size is not specified when you write the program , but is determined while the program is running .

Array Variables and Pointer Variables In Chapter we described how arrays are kept in memory .
At that point we had not learned about pointers , so we discussed arrays in terms of memory addresses .
But , memory address is pointer .
So , in an array variable is actually pointer variable that points to the first indexed variable of the array .

Given the following two variable declarations , and are the same kind of .

The fact that and are the same kind of variable is illustrated in Display .
Since is pointer that points to variable of type int the variable , the value of can be assigned to the pointer variable as follows : After this assignment , points to the same memory location that points to .

So , refer to the indexed variables ,

The square bracket notation you have been using for arrays applies to pointer variables as long as the pointer variable points to an array in memory .
After this assignment , you can treat the identifier as if it were an array identifier .

You can also treat the identifier as if it were pointer variable , but there is one important reservation .
You cannot change the pointer value in an array variable , such as .
You might be tempted to think the following is legal , but it is not : IntPtr ; is given some pointer value .

You cannot assign different address to .

Display illustrates the working of the program in Display .
As in Display , variables are represented as boxes and the value of the variable is written inside the box .
An arrow indicates pointer or reference to another memory location , in this case , the first element of the array .

Chapter Pointers and Dynamic Arrays Display Arrays and Pointer Variables .

Note that changes to the array .

For example , an array might hold list of student identification numbers , but the size of the class may be different each time the program is run .
With the kinds of arrays you have used thus far , you must estimate the largest possible size you may need Dynamic Arrays .

IntPtr  int .

Chapter Pointers and Dynamic Arrays Creating dynamic array for the array and hope that size is large enough .

First , you may estimate too low , and then your program will not work in all situations .
Second , since the array might have many unused positions , this can waste computer memory .
Dynamic arrays avoid these problems .
If your program uses dynamic array for student identification numbers , then the size of the class can be entered as input to the program and the dynamic array can be created to be exactly that size .

Dynamic arrays are created using the new .
The creation and use of dynamic arrays is surprisingly simple .
Since array variables are pointer variables , you can use the new to create dynamic variables that are arrays and treat these dynamic array variables as if they were ordinary arrays .

For example , the following creates dynamic array variable with ten array elements of type .

To obtain dynamic array of elements of any other type , simply replace with desired type .
To obtain dynamic array variable of any other size , simply replace with desired size .

There are also number of less obvious things to notice about this example .

First , pointer type that you use for pointer to dynamic array is same as pointer type you would use for single element of array .
For instance , pointer type for an array of elements of type is same as pointer type you would use for simple variable of type .
The pointer to array is actually pointer to first indexed variable of array .
In previous example , an entire array with ten indexed variables is created and pointer is left pointing to first of these ten indexed variables .

Also notice that when you call  size of dynamic array is given in square brackets after type , which in this example is type .

This tells computer how much storage to reserve for dynamic array .
If you omit square brackets and , computer will allocate enough storage for only one variable of type  rather than for an array of ten indexed variables of type .
As illustrated in Display , you can use an int variable in place of constant so that size of dynamic array can be read into program .

The program in Display sorts list of numbers .
This program works for lists of any size because it uses dynamic array to hold numbers .
The size of array is determined when program is run .
The user is asked how many numbers there will be , and then creates dynamic array of that size .
The size of dynamic array is given by variable size .

Notice delete statement , which destroys dynamic array variable in Display .
Since program is about to end anyway , we did not really need this delete statement ; however , if program went on to do other Dynamic Arrays .

Chapter Pointers and Dynamic Arrays .

This may or may not require some additional function definitions .
The implementation need not even know that sort will be called with dynamic array .
For example , you can use the implementation in Display suitable adjustments to parameter things with dynamic variables , you would want such delete statement so that the memory used by this dynamic array is returned to the freestore .
The delete statement for dynamic array is similar to the delete statement you saw earlier , except that with dynamic array you must an empty pair of square brackets , like so : delete  The square brackets tell that dynamic array variable is being eliminated , so the system checks the of the array and removes that many indexed variables .
If you omit the square brackets , you would be telling the computer to eliminate only one variable of type .
For example , delete  is not legal , but the error is not detected by most compilers .
The ANSI standard says that what happens when you do this is " That means the author of the compiler can have this do anything that is convenient for the compiler writer , not for .
Even if it does something useful , have no guarantee that either the next version of that compiler or any other compiler compile this code with will do the same thing .
The moral is simple : Always use the delete .

You create dynamic array with call to pointer , such as the pointer in Display .
After the call to  should not assign any other pointer value to this pointer variable , because that can confuse the system when the memory for the dynamic array is returned to the freestore with call to delete .

For example , if the dynamic array is an array of double , might use the following : typedef DoubleArrayPtr ; Declare pointer variable : Declare pointer variable of this defined type .

The pointer variable will point to the dynamic array in memory and will serve as the name of the dynamic array .

The can be given an variable or other expression .

In the example above , can be variable of type whose value is determined while the program is running .

For example , the indexed variables are written in the usual way : and so forth .
The pointer variable should not have any other pointer value assigned to it , but should be used like an array variable .

For example : delete  Dynamic arrays are created pointer variable .
When your program is finished dynamic array , should return the array memory to the freestore with call to delete .
Other than that , dynamic array can be used just like any other array .

est Exerc ise .
Write type definition for pointer variables that will be used to point to dynamic arrays .
The array elements are to be of type char .
Call the type CharArray .

Write code to fill this array with ten numbers typed in at the keyboard .

Suppose your program contains code to create array as in SelfTest Exercise , suppose the pointer variable has not had its value changed .
Write code to destroy this array return the memory it uses to the freestore .

What is the output of the following code fragment .
The code is assumed to be embedded in correct complete program .

What is the output of the following code fragment .
The code is assumed to be embedded in correct complete program .

There is kind of arithmetic can perform on pointers , but it is an arithmetic of addresses , not an arithmetic of numbers .
For example , suppose your program contains the following .

The expression + evaluates to the address of , + is the address of , so forth .
Notice that although the value of is an address an address is number , does not simply add to the number in .

If variable of type requires bytes memory contains the address , then evaluates to the memory address .

Of course , the type can be replaced by any other type then pointer addition moves in units of variables for that type .

This pointer arithmetic gives an alternative way to manipulate arrays .

For example , if is the size of the array pointed to by  then the following will output the contents of the array : + 

You may not perform multiplication or division of pointers .
All can do is add an integer to pointer , subtract an integer from pointer , or subtract two pointers of the same type .
When subtract two pointers , the result is the number of indexed variables between the two addresses .
Remember , for subtraction of two pointer values , these values must point into the same array .
It makes little sense to subtract pointer that points into one array from another pointer that points into different array .
You can use the increment decrement operators .
For example , will advance the value of so that it contains the address of the next indexed variable , will change so that it contains the address of the previous indexed variable .

est Exerc ise These exercises apply to the optional section on pointer arithmetic .

What is the output of the following code fragment .
The code is assumed to be embedded in correct complete program .

Dynamic Arrays Pointer Arithmetic Chapter Pointers Dynamic Arrays .
What is the output of the following code fragment .
The code is assumed to be embedded in correct complete program .

You can have multidimensional arrays .
You just need to remember that multidimensional arrays are arrays of arrays , or arrays of arrays of arrays , or so forth .
For example , to create array , you must remember that it is an array of arrays .
To create twodimensional array of integers , you first create array of pointers of type , which is the type for array of ints .
Then you create array of ints for each indexed variable of the array of pointers .

type definition may help to keep things straight .
The following is the variable type for an ordinary array of ints : typedef .

simple program to illustrate this is given Display .

Be sure to notice the use of delete Display .
Since the array is an array of arrays , each of the arrays created with new the for loop must be returned to the freestore manager with call to .

There must be one call to for each call to new created an array .

Chapter Pointers and Dynamic Arrays Sample Dialogue Enter the row and column dimensions of the array : Enter rows of integers each : Echoing the array : Chapter Summary pointer is memory address , so pointer provides way to indirectly name variable by naming the address of the variable the memory .

When program is finished with dynamic variable , the memory used by the dynamic variable can be returned to the freestore for reuse ; this is done with delete statement .

dynamic array is implemented as dynamic variable of an array type .

Answers to Self Test Exerci ses .
pointer is the memory address of variable .

To the unwary , or to the neophyte , this looks like two objects of type pointer to  is ,
Unfortunately , the binds to the identifier , not to the type is , not to the .
The result is this declaration declares to be an pointer , while is just an ordinary variable .

The new takes type for its argument .

It returns pointer to memory is , pointer to new dynamic , provided there is enough available memory in the freestore .
If there is not enough memory available in the freestore , your program ends .

In the programming language there is no syntax to pass variable by reference to function .
Instead variable is passed by pointer to be confusing , sometimes passing by pointer is referred to as pass by .
This Practice Program asks you to do the same thing as , which in .

Complete the function so it adds one to the integer referenced by ptrNum .
Write main function where an integer variable is defined , give it an initial value , call addOne , and output the variable .

Write program asks the user to input an integer named numDoubles .

Create dynamic array can store numDoubles doubles and make loop allows the user to enter double into each array entry .
Loop through the array , calculate the average , and output it .
Delete the memory allocated to your dynamic array before exiting .

This Practice Program requires you read the optional section about pointer arithmetic .
Complete the function isPalindrome so it returns and false if it is not .
The function uses the cstring library .

Programming Projects Programming Projects require more than Practice Programs and can usually be solved many different ways .
Visit to complete many of these Programming Projects online and get instant feedback .

Do Programming Project in Chapter using array .
In this version of the problem , use arrays to store the digits in each large Programming Projects integer .
Allow an arbitrary number of digits instead of capping the number of digits at .

Do Programming Project in Chapter .
In this version of the problem , return new array where all repeated letters are deleted instead of modifying the partially filled array .
forget to free the memory allocated for these returned arrays when the data is no longer needed .

Do Programming Project in Chapter using array .

In this version , your program will ask the user how many rows the plane has and will handle that many rows so not always assume the plane has rows as it did in Programming Project of Chapter .

Write function that takes string as an input parameter and reverses the string .
The function should use two pointers , and rear .
The pointer should initially reference the first character in the string , and the rear pointer should initially reference the last character in the string .
Reverse the string by swapping the characters referenced by and rear , then increment to point to the next character and decrement rear to point to the preceding character , and so on , until the entire string is reversed .
Write main program to test your function on various strings of both even and odd length .

You run four computer labs .
Each lab contains computer stations that are numbered as shown in the table below : Lab Number Computer Station Numbers .

Whenever user logs on , the user ' ID , lab number , and the computer station number are transmitted to your system .
For example , if user logs onto station in lab , then your system receives , as input data .
Similarly , when user logs off station , then your system receives the lab number and computer station number .

Write computer program that could be used to track , by lab , which user is logged onto which computer .
For example , if user is logged into station in lab and user is logged into station of lab , then your system might display the following : Lab Number Computer Stations : empty : empty : empty : empty : empty : empty : empty : empty : empty empty : empty : empty : empty empty : empty empty .

Chapter Pointers and Dynamic Arrays Create menu that allows the administrator to simulate the transmission of information by manually typing in the login or logoff data .
Whenever someone logs in or out , the display should be updated .
Also write search option so that the administrator can type in user ID and the system will output what lab and station number that user is logged into , or " if the user ID is not logged into any computer station .

You should use fixed array of length for the labs .
Each array entry points to array that stores the user login information for each respective computer station .

The structure is shown in the figure below .
This structure is sometimes called ragged array since the columns are of unequal length .

Lab Array VideoNote Solution to Programming Project Dynamic Arrays for Computer Stations .
One problem with arrays is that once the array is created using the new  the size cannot be changed .
For example , you might want to add or delete entries from the array as you can with vector .
This project asks you to create functions that use arrays to emulate the behavior of vector .

First , write program that creates of five strings .
Store five names of your choice into the .
Next , complete the following two functions : string , int , string ; This function should create new one element larger than dynamicArray , copy all elements from dynamicArray into the new  add the new onto the end of the new  increment size , delete dynamicArray , and return the new .

Programming Projects returned .
If found , create new one element smaller than dynamicArray .
Copy all elements except entryToDelete into the new  delete dynamicArray , decrement size , and return the new .

Test your functions by adding and deleting several names to the while outputting the contents of the .
You will have to assign the returned by addEntry or deleteEntry back to the variable in your main function .

What if had no facility for arrays .
It is possible to emulate them yourself with wrapper functions around onedimensional .
The basic idea is shown below .
Consider the following  int ; It can be visualized as .

This creates to emulate twodimensional and returns pointer to the .

Return value : pointer to large enough to hold of size rows columns .

Note that int ; would create an .

This stores val into the emulated at position ,
The function should print an error message and exit if the desired indices are invalid .

The function should print an error message and exit if the desired indices are invalid .

Create suitable test program that invokes all three functions .

Write program that outputs histogram of student grades for an assignment .
The program should input each grade as an integer Programming Projects and store the grade in vector in Chapter .
Grades should be entered until the user enters for grade .
The program should then scan through the vector and compute the histogram .
In computing the histogram , the minimum value of grade is but your program should determine the maximum value entered by the user .
Use dynamic array to store the histogram .
Output the histogram to the console .
For example , if the input is : Then the output should be : Number of : Number of : Number of :

Defining Classes Structures Structures for Diverse Data Pitfall : Forgetting Semicolon in Structure Definition Structures as Function Arguments Programming Tip : Use Hierarchical Structures Initializing Structures Classes Defining Classes and Member Functions Public and Private Members Programming Tip : Make All Member Variables Private Programming Tip : Define Accessor and Mutator Functions Programming Tip : Use the Assignment Operator with Objects Chapter Summary Answers to Exercises Programming Example : BankAccount Summary of Some Properties of Classes Constructors for Initialization Programming Tip : Always Include Default Constructor Pitfall : Constructors with No Arguments Member Initializers and Constructor Delegation in Abstract Data Types Classes to Produce Abstract Data Types Programming Example : Alternative Implementation of Introduction to Inheritance Derived Classes Defining Derived Classes Practice Programs Programming Projects time has " the Walrus said , talk of many things : Of sealing Introduction In Chapter you learned how to use classes and objects , but not how to define classes .
In this chapter we will show you how to define your own classes .

You can use the classes you define in the same way you use the predefined data types , such as int , char , and ifstream .
However , unless you define your classes the right way , they will not be as well behaved as the predefined data types .
Thus , we spend good deal of time explaining what makes for good class definition and give you some techniques to help you define your classes in way that is consistent with modern programming practices .

Before we introduce classes , we will first present structures known as .
When used in the way we present them here , structure is kind of simplified class and structures will prove to be to understanding classes .

Prerequisites This chapter uses material from Chapters through .

Thus , the definition of class should be data type definition that describes two things : what kinds of values the variables can hold and what the member functions are .
We will approach class definitions in two steps .
We will first tell you how to give type definition for structure .
structure the kind discussed can be thought of as an object without any member functions .
After you learn about structures , it will be natural extension to define classes .

Structures for Diverse Data Sometimes it is useful to have collection of values of different types and to treat the collection as single item .
For example , consider bank certificate of deposit , which is often called CD .
CD is bank account that does not allow withdrawals for specified number of months .
CD naturally has Structures three pieces of data associated with it : the account balance , the interest rate for the account , and the term , which is the number of months until maturity .

The first two items can be represented as values of type double , and the number of months can be represented as value of type int .
Display shows the definition of structure called CDAccount that can be used for this kind of account .
The definition is embedded in complete program that demonstrates this structure type definition .
As you can see from the sample dialogue , this particular bank specializes in CDs , so the term will always be or fewer months .
look at how this sample structure is defined and used .

The structure definition is as follows : struct CDAccount .

The keyword struct announces that this is structure type definition .
The identifier CDAccount is the name of the structure type .
The name of structure type is called the structure tag .
The tag can be any legal identifier not .
Although this convention is not required by the language , structure tags are usually spelled with mix of uppercase and lowercase letters , beginning with an uppercase letter .
The identifiers declared inside the braces , are called member names .
As illustrated in this example , structure type definition ends with both brace , and semicolon .

structure definition is usually placed outside of any function definition the same way that globally defined constant declarations are placed outside of all function .
The structure type is then available to all the code that follows the structure definition .

Once structure type definition has been given , the structure type can be used just like the predefined types int , char , and so forth .
For example , the following will declare two variables , named and , both of type CDAccount : CDAccount , structure variable can hold values just like any other variable can hold values .
structure value is collection of smaller values called member values .
There is one member value for each member name declared in the structure definition .
For example , value of the type CDAccount is collection of three member values : two of type double and one of type int .
The member values that together make up the structure value are stored in member variables , which we discuss next .

Each structure type specifies list of member names .
In Display the structure CDAccount has the three member names balance , Where to place structure definition Chapter Defining Classes to demonstrate the CDAccount structure type .

Each of these member names can be used to pick out one smaller variable that is part of the larger structure variable .
These smaller variables are called member variables .
Member variables are specified by giving the name of the structure variable followed by dot is , followed by and then the member name .
For example , if account is structure variable of type CDAccount declared in Display , then the structure variable account has the following three member variables : account .

The first two member variables are of type double , and the last is of type int .
These member variables can be used just like any other variables of those types .
For example , the member variables above can be given values with the following three assignment .

The result of these three statements is diagrammed in Display .
Member variables can be used in all the ways that ordinary variables can be used .

For example , the following line from the program in Display will add the value contained in the member variable account .
The only difference is that in the case of structures , the members are variables rather than functions .

Chapter Defining Classes Display Member Values .

CDAccount account ;

Reusing member names .

For example , it is perfectly legal to have the following two type definitions in the same program : struct FertilizerStock .

The dot operator and the structure variable specify which quantity is meant in each instance .

structure value can be viewed as collection of member values .
Viewed this way , structure value is many different values .
structure value can also be viewed as single value just happens to be made up of member .
Since structure value can be viewed as single value , structure values and structure variables can be used in the same ways that you use simple values and simple variables of the predefined types such as int .
In particular , you can assign structure values using the equal sign .
For example , if and oranges are structure variables of the type CropYield defined earlier , then the following is perfectly legal :

Forgetting Semicolon in Structure Definition When you add the final brace , to structure definition , it feels like the structure definition is finished , but it is not .
You must also place semicolon after that final brace .
There is reason for this , even though the reason is feature that we will have no occasion to use .
structure definition is more than definition .
It can also be used to declare structure variables .
You are allowed to list structure variable names between that final brace and that final semicolon .
For example , the following defines structure called WeatherData and declares two structure variables , and , both of type WeatherData : struct WeatherData .

However , as we said , we will always separate structure definition and the declaration of variables of that structure type , so our structure definitions will always have semicolon immediately after the final brace .

Chapter Defining Classes The Dot Operator The dot operator is used to specify member variable of structure variable .

Structures as Function Arguments Functions can return structures function can have parameters of structure type parameters of structure type .
The program in Display , for example , includes function named that has parameter with the structure type CDAccount .

structure type can also be the type for the value returned by function .

For example , the following defines function that takes three appropriate arguments and returns value of type CDAccount : CDAccount .

Use Hierarchical Structures Sometimes it makes sense to have structures whose members are themselves smaller structures .
For example , structure type called PersonInfo , which can be used to store height , weight , and birth date , can be defined as follows : struct Date .

If the structure variable has had its value set to record .

Starting at the left end , is structure variable of type PersonInfo .
To obtain the member variable with the name birthday , use the dot operator as follows : This member variable is itself structure variable of type Date .
Thus , this member variable has member variables itself .
member variable of the structure variable is obtained by adding dot and the member variable name , such as year , which produces the expression shown previously .

The is the name of the structure type .

Syntax struct .

Although we will not use this feature , you can combine member names of the same type into single list separated by commas .

For example , the following is equivalent to the previous structure definition : struct Automobile .

Automobile , The member variables are specified using the dot operator .

To give structure variable value , you follow it by an equal sign and list of the member values enclosed in braces .
For example , the following definition of structure type for date was given in the previous subsection : struct .

In this example , receives the first initializing value of , receives the second value of , and receives the third value of .

It is an error if there are more initializers than struct members .
If there are fewer initializer values than struct members , the provided values are used to initialize data members , in order .
Each data member without an initializer is initialized to zero value of an appropriate type for the variable .

st Exerc is .
Given the following structure and structure variable .

What is the error in the following structure definition .
What is the message your compiler gives for this error .
State what the error is , in your own words .

Initialize the members of , and , to the values and , respectively .

Here is an initialization of structure type .
Tell what happens with each initialization .
Note any problems with these initializations .

Write definition for structure type for records consisting of wage rate , accrued vacation is some whole number of , and status is either hourly or .
Represent the status as one of the two char values ' and .
Call the type EmployeeRecord .

Give function definition corresponding to the following function void ; with values read from the keyboard .

Give function definition corresponding to the following function ShoeType ; structure that is the same as its argument , with the reduced by .

Give the structure definition for type named StockRecord that has two member variables , one named of the type ShoeType given in Exercise and one named of type given in Exercise .

Chapter Defining Classes Classes care to belong to any club that will accept me as member .

Groucho Marx , The Groucho Letters Defining Classes and Member Functions member function class is data type whose variables are objects .
In Chapter we described an object as variable that has member functions as well as the ability to hold data Thus , within program , the definition of class should be data type definition that describes what kinds of values the variables can hold and also what the member functions are .
structure definition describes some of these things .
structure is defined type that allows you to define values of the structure type by defining member variables .
To obtain class from structure , all you need to do is add some member functions .

sample class definition is given in the program shown in Display .

The type DayOfYear defined there is class definition for objects whose values are dates , such as January or July .
These values can be used to record holidays , birthdays , and other special dates .
In this definition of DayOfYear , the month is recorded as an int value , with standing for January , standing for February , and so forth .
The day of the month is recorded in second int member variable .
The class DayOfYear has one member function called output , which has no arguments and outputs the month and day values to the screen .
look at the definition for the class DayOfYear in detail .

The definition of the class DayOfYear is shown near the top of Display .
For the moment , ignore the line that contains the keyword public .

This line simply says that the member variables and functions have no restriction on them .
We will explain this line later in this chapter .
The rest of the definition of the class DayOfYear is very much like structure definition , except that it uses the keyword class instead of struct and it lists the member function output well as the member variables month and .

Notice that the member function output is listed by giving only its function declaration .
The definitions for the member functions are given elsewhere .

The object is actually the value of the variable rather than the variable itself , but since we use the variable to name the value it holds , we can simplify our discussion by ignoring this nicety and talking as if the variable and its value were the same thing .

Chapter Defining Classes Sample Dialogue Enter date : Enter as number : Enter the of the  Enter your birthday : Enter as number : Enter the of the  date is , Your birthday is , Happy Unbirthday .

Calling member functions Member functions for classes that you define are called in the same way as we described in Chapter for predefined classes .
For example , the program in Display declares two objects of type DayOfYear in the following way : DayOfYear today ,

Encapsulation Combining number of items , such as variables and functions , into single package , such as an object of some class , is called encapsulation .

Defining member functions When member function is defined , the definition must the class name because there may be two or more classes that have member functions the same name .
In Display there is only one class definition , but in other situations you may have many class definitions , and each class may have member function called output .
The definition for the member function output of the class DayOfYear is shown in Display .
The definition is similar to an ordinary function definition , but there are some differences .

The heading of the function definition for the member function output is as follows : Classes The operator : is called the scope resolution operator , and it serves purpose similar to that of the dot operator .
Both the dot operator and the scope resolution operator are used to tell what member function is member of .

However , the scope resolution operator : is used class name , whereas the dot operator is used objects is , class .
The scope resolution operator consists of two colons no space between them .

The class name that precedes the scope resolution operator is often called type qualifier , because it specializes the function name to one particular type .

Look at the definition of the member function given in Display .
Notice that in the function definition of , we used the member names and by themselves without first giving the object and dot operator .
That is not as strange as it may at first appear .
At this point we are simply defining the member function output .

This definition of output will apply to all objects of type DayOfYear , but at this point we do not know the names of the objects of type DayOfYear that we will use , so we cannot give their names .
When the member function is called , as in ; all the member names in the function definition are specialized to the name .

Member Function Definition member function is defined the same way as any other function except that the and the scope resolution operator : are given in the function heading .

The class definition for the example class DayOfYear above is given in Display , where and are defined as the names of member variables for the class DayOfYear .
Note that and are not preceded by an object name and dot .

The Dot Operator and the Scope Resolution Operator Both the dot operator and the scope resolution operator are used member names to specify what thing they are members of .
For example , suppose you have declared class called DayOfYear and you declare an object called today as follows : DayOfYear today ; You use the dot operator to specify member of the object today .
For example , output is member function for the class DayOfYear in Display , and the following function call will output the data values stored in the object today : You use the scope resolution operator : to specify the class name when giving the function definition for member function .
For example , the heading of the function definition for the member function output would be as follows : Remember , the scope resolution operator : is used class name , whereas the dot operator is used an object of that class .

Below we have redefined the class DayOfYear from Display so that it now has one additional member function called input .
Write an appropriate definition for the member function input .

Public and Private Members The predefined types such as double are not implemented as classes , but the people who wrote your compiler did design some way to represent values of type double in your computer .
It is possible to implement the type double in many different ways .
In fact , different versions of do implement the type double in slightly different ways , but if you move your program from one computer to another with different implementation of the type double , your program should still work correctly .
Classes are types that you define , and the types that you define should behave as well as the predefined types .
You can build library of your own class type definitions and use your types as if they were predefined types .
For example , you could place each class definition in separate file and copy it into any program that uses the type .

Sometimes this ideal is not quite realized , but in the ideal world it should be realized , and at least for simple programs , it is realized even in the imperfect world that we live in .

Chapter Defining Classes Your class definitions should separate the rules for using the class and the details of the class implementation in as strong way as was done for the predefined types .
If you change the implementation of class example , by changing some details in the definition of member function in order to make function calls run , then you should not need to change any of the other parts of your programs .
In order to realize this ideal , we need to describe one more feature of class definitions .

Look back at the definition of the type DayOfYear given in Display .

The type DayOfYear is designed to hold values that represent dates such as birthdays and holidays .
We chose to represent these dates as two integers , one for the and one for the of the .
We might later decide to change the representation of the from one variable of type int to three variables of type char .
In this changed version , the three characters would be an abbreviation of the name .
For example , the three char values , and ' would represent the January .
However , whether you use single member variable of type int to record the or three member variables of type char is an implementation detail that need not concern programmer who uses the type DayOfYear .
Of course , if you change the way the class DayOfYear represents the  then you must change the implementation of the member function that is all you should need to change .
You should not need to change any other part of program that uses your class definition for DayOfYear .
Unfortunately , the program in Display does not meet this ideal .
For example , if you replace the one member variable named with three member variables of type char , then there will be no member variable named  so you must change those parts of the program that perform input and also change the statement .

With an ideal class definition , you should be able to change the details of how the class is implemented and the only things you should need to change in any program that uses the class are the definitions of the member functions .

In order to realize this ideal , you must have enough member functions so that you never need to access the member variables directly , but access them only through the member functions .
Then , if you change the member variables , you need change only the definitions of the member functions to match your changes to the member variables , and nothing else in your programs need change .
In Display we have redefined the class DayOfYear so that it has enough member functions to do everything we want our programs to do , and so the program does not need to directly reference any member variables .
If you look carefully at the program in Display , you will see that the only place the member variable names and are used is in the definitions of the member functions .

The program in Display has one new that is designed to ensure that no programmer who uses the class DayOfYear will ever Classes .

Chapter Defining Classes .

better definition of the member function input would ask the user to reenter the date if the user enters an incorrect date .

Sample Dialogue Enter date : Enter the as number : Enter the of the  date is ,
birthday is , Happy Birthday Johann Sebastian .

Notice the line in the definition of the class DayOfYear that contains the keyword private .

All the member variable names that are listed after this line are private members , which means that they cannot be directly accessed in the program except within the definition of member function .
If you try to access one of these member variables in the main part of your program or in the definition of some function that is not member function of this particular class , the compiler will give you an error message .
If you insert the keyword private and colon in the list of member variables and member functions , all the members that follow the label private : will be private members .
The variables that follow the label private : will be private member variables , and the functions that follow it will be private member functions .

All the member variables for the class DayOfYear defined in Display are private members .
private member variable may be used in the of any of the member functions , but nowhere else .
For example , this changed of the class DayOfYear , the following two assignments are no longer permitted in the main part of the .

Any reference to these private variables is illegal in the of member .
Since this new makes and private member variables , the following are also illegal in the main part of any program that declares today to be of type .

Once you make member variable private member variable , there is then no way to change its value to reference the member variable in any other except by using one of the member functions .
This is severe restriction , but it is usually wise restriction to impose .
Programmers find that it usually makes their code easier to understand and easier to update if they make all member variables private .

It may seem that the program in Display does not really disallow direct access to the private member variables , since they can be changed using the member function , and their values can be discovered using the member functions and While that is almost true for the program in Display , it might not be so true if we changed the implementation of how we represented the in our dates .
For example , suppose we change the type of DayOfYear to the following :

For example , the of the function might start as follows : if ' return ; if ' return ;

This approach would be rather tedious , but not difficult .

Also notice that the member functions and check to make sure the member variables and are set to legal values .

If the member variables and were public instead of private , then these member variables could be set to any values , including illegal values .
By making the member variables private and manipulating them only via member functions , we can ensure that the member variables are never set to illegal or meaningless values .
Like private member variable , private member function can be used in the of any other member function , but nowhere else , such as in the main part of program that uses the class type .
For example , the member function in Display is private member function .
The normal practice is to make member function private if you only expect to use that member function as helping function in the definitions of the member functions .

The keyword public is used to indicate public members the same way that the keyword private is used to indicate private members .
For example , for the class DayOfYear defined in Display , all the member functions except are public members all the member variables are private .
public member can be used in the main body of your program or in the of any function , even nonmember function .

You can have any number of occurrences of public and private in class Every time you insert the label public : the list of members changes from private to public .
Every time you insert the label private : the list of members changes back to being private members .
For example , the member function and the member variable in the following structure are private members , while the other four members are all public : class SampleClass .

If you list members at the start of your class and do not insert either public : or private : before these first members , then they will be private members .
However , it is good idea to always explicitly label each group of members as either public or private .

These objects can have both member variables and member functions .
The syntax for class is as follows .

Syntax class public :

Make All Member Variables Private When defining class , the normal practice is to make all member variables private .
This means that the member variables can only be accessed or changed using the member functions .
Much of this chapter is dedicated to explaining how and why you should define classes in this way .

Unfortunately , the predefined does not automatically apply to objects .
In Chapter we will show you how you can make the apply to the objects of the classes you define .
Until then , you will not be able to use the equality with objects can you use it with .

This can produce some complications .
When defining class , the preferred style is to make all member variables private .
Thus , in order to test two objects to see if they represent the same value , you need some way to access the values of the member variables something equivalent to the values of the member .
This allows you to test for equality by testing the values of each pair of corresponding member variables .
To do this in Display , we used the member functions and in the statement .

Member functions , such as and , that allow you to find out the values of the private member variables are called accessor functions .
Given the techniques you have learned to date , it is important to always include complete set of accessor functions with each class definition so that you can test objects for equality .
In Chapter we will develop more elegant method to test two objects for equality , but even after you learn that technique , it will still be handy to have accessor functions .

Member functions , such as set in Display , that allow you to change the values of the private member variables are called mutator functions .
It is important to always include mutator functions with each class definition so that you can change the data stored in an object .

Accessor and Mutator Functions Member functions that allow you to find out the values of the private member variables of class are called accessor functions .
Although this is not required by the language , the names of accessor functions normally include the word get .

Chapter Defining Classes Member functions that allow you to change the values of the private member variables of class are called mutator functions .
Although this is not required by the language , the names of mutator functions normally include the word set .

It is important to always include accessor and mutator functions with each class definition so that you can change the data stored in an object .

Redefine the member function so that it ends the program whenever it finds any illegal date .
Allow February to contain days , so you account for leap years .
Suppose your program contains the following class definition : class Automobile .

Suppose you change Exercise so that the definition of the class Automobile omits the line that contains the keyword private .
How would this change your answer to the question in Exercise .

In particular , explain why we do not just make everything public : and save difficulty in access .

How many private : sections are required in class .

For example , suppose the class DayOfYear is defined as shown in Display so that it has two private member variables named and  and suppose that the objects and tomorrow are declared as follows : DayOfYear 

Moreover , this is true even though the member variables named and are private members of the class DayOfYear .

Chapter Defining Classes Programming Example BankAccount Display contains class definition for bank account that illustrates all of the points about class definitions you have seen thus far .
This type of bank account allows you to withdraw your money at any time , so it has no term as did the type CDAccount that you saw earlier .
more important difference is that the class BankAccount has member functions for all the operations you would expect to use in program .
Objects of the class BankAccount have two private member variables : one to record the account balance and one to record the interest rate .

discuss some of features of the class BankAccount .

First , notice that the class BankAccount has private member function called fraction .
Since fraction is private member function , it cannot be called in the body of main or in the body of any function that is not member function of the class BankAccount .
The function fraction can only be called in the definitions of other member functions of the class BankAccount .
The only reason we have this private member function is to aid us in defining other member functions for the same class .
In our definition of the class BankAccount , we included the member function fraction so that we could use it in the definition of the function update .
The function fraction takes one argument that is percentage figure , like for , and converts it to fraction , like .
That allows us to compute the amount of interest on the account at the given percentage .
If the account contains and the interest rate is , then the interest is equal to times , which is .

When you call public member function , such as update , in the main body of your program , you must include an object name and dot , as in the following line from Display : One member function calling another However , when you call private member function any other member within the definition of another member function , you use only the member function name without any calling object or dot .
For example , the following definition of the member function includes call to shown in Display .

For example , the meaning of .

The member function set is overloaded .

Sample Dialogue Start of Test : initial statement : Account Interest with new  Account Interest after update : Account Interest : Account Interest .

Chapter Defining Classes stream arguments Like the classes we discussed earlier , the class BankAccount has member function that outputs the data information stored in the object .
In this program we are sending output to the screen .
However , we want to write this class definition so that it can be copied into other programs and used unchanged in those other programs .
Since some other program may want to send output to file , we have given the member function output formal parameter of type ostream so that the function output can be called with an argument that is either the stream or file output stream .
In the sample program we want the output to go to the screen , so the first function call to the member function output has the form ; Other calls to output also use as the argument , so all output is sent to the screen .
If you want the output to go to file instead , then you must first connect the file to an output stream , as we discussed in Chapter .
If the file output stream is called fout and is connected to file , then the following would write the data information for the object to this file rather than to the screen : Overloading member functions The value of an object of type BankAccount represents bank account that has some and pays some interest .
The and interest can be set with the member function set .
Notice that we have overloaded the member function named set so that there are two versions of set .
One version has three formal parameters , and the other has only two formal parameters .
Both versions have formal parameter of type double for the interest  but the two versions of set use different formal parameters to set the account .
One version has two formal parameters to set the  one for the dollars and one for the cents in the account .
The other version has only single formal parameter , which gives the number of dollars in the account and assumes that the number of cents is zero .
This second version of set is handy , since most people open an account with some " amount of money , such as and no cents .
Notice that this overloading is nothing .

Summary of Some Properties of Classes Classes have all of the properties that we described for structures plus all the properties associated with member functions .
The following is list of some points to keep in mind when using classes .

Classes have both member variables and member functions .

Normally , all the member variables of class are labeled as private members .

The name of member function for class may be overloaded just like the name of an ordinary function .

However , in structure can have private member variables and both public and private member functions .

Aside from some notational differences , structure can do anything st Exerc is .
Give definition for the function with the following function declaration .

The class BankAccount is defined in Display .

Give definition for the function with the following function declaration .

The class BankAccount is defined in Display .

Give definition for the function with the following function declaration .

The class BankAccount is defined in Display .

BankAccount ; has previously been given value is , its member variables have been given .

For example , after this function is defined , program could contain the .

Account balance Interest rate Constructors for Initialization You often want to initialize some or all the member variables for an object when you declare the object .
As we will see later in this book , there are other initializing actions you might also want to take , but initializing member variables is the most common sort of initialization .
includes special provisions for such initializations .
When you define class , you can define special kind of member function known as constructor .
You can define constructor the same way that you define any other member function , except for two points :
For example , if the class is named BankAccount , then any constructor for this class must be named BankAccount .

Moreover , no return type , not even void , can be given at the start of the function declaration or in the function header .

The class definition could be as follows .

Notice that the constructor is named BankAccount , which is the name of the class .
Also notice that the function declaration for the constructor BankAccount does not start with void or with any other type name .
Finally , notice that the constructor is placed in the public section of the class definition .
Normally , you should make your constructors public member functions .
If you were to make all your constructors private members , then you would not be able to declare any objects of that class type , which would make the class completely useless .

With the redefined class BankAccount , two objects of type BankAccount can be declared and initialized as follows : BankAccount , Assuming that the definition of the constructor performs the initializing action that we promised , the previous declaration will declare the object , set the value of to , and set the value of rate to .
Thus , the object is initialized so that it represents bank with balance of and an interest rate of .
Similarly , is initialized so that it represents bank with balance of and an interest rate of .
What happens is that the object is declared and then the constructor BankAccount is called with the three arguments , and .
Similarly , is declared and then the constructor BankAccount is called with the arguments , and .
The result is conceptually equivalent to the following you cannot write it this way in :

As the comments indicate , you cannot place those three lines in your program .

The first line can be made to be acceptable , but the two calls to the constructor BankAccount are illegal .
constructor cannot be called in the same way as an ordinary member function is called .
Still , it is clear what we want to happen when we write those three lines , and that happens automatically when you declare the objects and as follows : BankAccount , The definition of constructor is given in the same way as any other member function .
For example , if you revise the definition of the class BankAccount by adding the constructor just described , you need to also add the following definition of the .

Since the class and the constructor function have the same name , the name BankAccount occurs twice in the function heading : The BankAccount before the scope resolution operator : is the name of the class , and the BankAccount after the scope resolution operator is the name of the constructor function .
Also notice that no return type is specified in the heading of the constructor definition , not even the type void .
Aside from these points , constructor can be defined in the same way as an ordinary member function .

You can overload constructor name like , just as you can overload any other member function name , such as we did with in Display .
In fact , constructors usually are overloaded so that objects can be initialized in more than one way .

For example , in Display we have redefined the class BankAccount so that it has three versions of its constructor .
This redefinition overloads the constructor name BankAccount so that it may have three arguments we just , two arguments , or no arguments .

For example , suppose you give only two arguments when you declare an object of type BankAccount , as in the following example : BankAccount ,

On the other hand , if no arguments are given , as in the following example , then the is initialized to represent an with of and an interest rate of .
Notice that when the constructor has no arguments , you do not include any parentheses in the declaration .
The following is incorrect :

In some cases , you can omit mutator member functions such as set once you have good set of constructor definitions .
You can use the overloaded constructor in Display to create new the values of your choice .
However , invoking the constructor will create new  so if you want to change the existing member variables in the  then you should use mutator function .

Chapter Defining Classes : One year of simple interest has been added the account .

Notice that there are no parentheses .

Screen Output initialized as follows : Account Interest rate initialized as follows : Account Interest rate reset to the following : Account Interest rate Constructor constructor is member function of class that has the same name as the class .
constructor is called automatically when an object of the class is declared .
Constructors are used to initialize objects .
constructor must have the same name as the class of which it is member .

The constructor no parameters in Display deserves some extra discussion since it contains something we have not seen before .

For reference , we reproduce the defining of the constructor no parameters :

The new  which is shown on the first line , is the part that starts single colon .
This part of the constructor definition is called the initialization section .
As this example shows , the initialization section goes after the parentheses that ends the parameter list and before the opening brace of the function body .
The initialization section consists of colon followed by list of some or all the member variables separated by commas .
Each member variable is followed by its initializing value in parentheses .
This constructor definition is completely equivalent to the following way of writing the .

Notice that the initializing values can be given in terms of the constructor parameters .

Constructor Initialization Section Some or all of the member variables in class can be initialized in the constructor initialization section of constructor definition .
The constructor initialization section goes after the parentheses that end the parameter list and before the opening brace of the function body .
The initialization section consists of colon followed by list of some or all the member variables separated by commas .
Each member variable is followed by its initializing value in parentheses .
The example given below uses constructor initialization section and is equivalent to the threeparameter constructor given in Display .

Calling Constructor constructor is called automatically when an object is declared , but you must give the arguments for the constructor when you declare the object .
constructor can also be called explicitly in order to create new object for class variable .

Syntax an object declaration when you have .

constructor must have the same name as the class of which it is member .
Thus , in the syntax descriptions above , and are the same identifier .

Initializers can also be specified if the object is created as dynamic variable .

Chapter Defining Classes constructor is called automatically whenever you declare an object of the class type , but it can also be called again after the object has been declared .

This allows you to conveniently set all the members of an object .
The technical details are as follows .
Calling the constructor creates an anonymous object new .
An anonymous object is an object that is not named by any variable .
The anonymous can be assigned to the named is , to the class .
For example , the following line of code is call to the constructor that creates an anonymous of and interest rate of .
This anonymous is assigned to so that it too represents an of and an interest rate of : As you might guess from the notation , constructor behaves like function that returns an of its class type .
However , since call to constructor always creates new and call to set member function merely changes the of existing member variables , call to set may be more efficient way to change the of member variables than call to constructor .
Thus , for efficiency reasons or if you need to change the of member variables without creating new  you may wish to have both the set member functions and the constructors in your class definition .

If you give no constructor , the compiler will generate default constructor that does nothing .
This constructor will be called if class objects are declared .
On the other hand , if you give at least one constructor definition for class , then the compiler will generate no other constructors .
Every time you declare an of that type , will look for an appropriate constructor definition to use .
If you declare an without using arguments for the constructor , will look for default constructor , and if you have not defined default constructor , none will be there for it to find .

For example , suppose you define class as follows : class SampleClass Constructor that requires two arguments .

SampleClass and call the constructor for that .

The compiler interprets this declaration as including call to constructor with no arguments , but there is no definition for constructor with zero arguments .
You must either add two arguments to the declaration of or add constructor definition for constructor with no arguments .

constructor that can be called with no arguments is called default constructor , since it applies in the default case where you declare an without specifying any arguments .
Since it is likely that you will sometimes want to declare an without giving any constructor arguments , you should always include default constructor .
The following redefined version of SampleClass includes default constructor : class SampleClass .

If you redefine the class SampleClass in this manner , then the previous declaration of would be legal .

If you do not want the default constructor to initialize any member variables , you can simply give it an empty body when you implement it .
The following constructor definition is perfectly legal .
It does nothing when called except make the compiler .

Chapter Defining Classes .

After all , when you call function that has no arguments , you include pair of empty parentheses .
However , this is wrong for constructor .
Moreover , it may not produce an error message , since it does have an unintended meaning .
The compiler will think that this code is the function declaration for function called that takes no arguments and returns value of type .

Do not include parentheses when you declare an and want to use the constructor with no arguments .
The correct way to declare using the constructor with no arguments is as follows : However , if you explicitly call constructor in an assignment statement , you do use the parentheses .
If the definitions and declarations are as in Display , then the following will set the balance for to and set the interest rate to : Constructors with No Arguments When you declare an and want the constructor with zero arguments to be called , you do not include any parentheses .
For example , to declare an and pass two arguments to the constructor , you might do the following :

This feature allows you to set default values for member variables .
When an is created the member variables are automatically initialized to the specified values .
Consider the following definition and implementation of the Coordinate class : class Coordinate .

If we create Coordinate  then member variable will be set to and member variable will be set to by default .
These values can be overridden if we invoke constructor that explicitly sets the variable .
In the snippet below , the default values for and are set for , but for the default value is only set for because is explicitly set to the input .

related feature supported by is constructor delegation .
Simply put , this allows one constructor to call another constructor .
For example , we could modify the implementation of the default constructor so it invokes the constructor with two parameters : VideoNote Default Initialization of Member Variables .

es Exe rc is .
Suppose your program contains the following class definition with definitions of the member : class YourClass .

Which of the following are legal .

YourClass YourClass YourClass .

How would you change the definition of the class DayOfYear in Display so that it has two versions of an constructor .
One version should have two int formal parameters for the month and one for the and should set the private member variables to represent that month and day .
The other should have no formal parameters and should set the date represented to January .
Do this without using constructor initialization section in either constructor .

Virginia Woolf , Monday or Tuesday Abstract Data Types data type , such as the type int , has certain specified values , such as , and so forth .
You tend to think of the data type as being these values , but the operations on these values are just as important as the values .

Without the operations , you could do nothing of interest with the values .
The operations for the type int consist of + and few other operators and predefined library functions .
You should not think of data type as being simply collection of values .
data type consists of collection of values together with set of basic operations defined on those values .

data type is called an abstract data type if the programmers who use the type do not have access to the details of how the values and operations are implemented .
The predefined types , such as int , are abstract data types .
You do not know how the operations , such as + and , are implemented for the type int .
Even if you did know , you would not use this information in any program .

types , such as the structure types and class types , are not automatically ADTs .
Unless they are defined and used with care , programmerdefined types can be used in unintuitive ways that make program difficult to understand and difficult to modify .
The best way to avoid these problems is to make sure all the data types that you define are ADTs .
The way that you do this in is to use classes , but not every class is an ADT .
To make it an ADT you must define the class in certain way , and that is the topic of the next subsection .

Classes to Produce Abstract Data Types class is type that you define , as opposed to the types , such as int and char , that are already defined for you .
value for class type is the set of values of the member variables .
For example , value for the type BankAccount in Display consists of two numbers of type double .
For easy reference , we repeat the class definition only the : class BankAccount .

Chapter Defining Classes The programmer who uses the type BankAccount need not know how you implemented the definition of or any of the other member functions .
The function definition for the member function that we used is as .

The programmer who uses the class BankAccount need not be concerned with which implementation of update we used , since both implementations have the same effect .

Similarly , the programmer who uses the class BankAccount need not be concerned about how the values of the class are implemented .
We chose to implement the values as two values of type double .
If is an object of type BankAccount , the value of consists of the two values of type double stored in the following two member variables :

You want to think of the value of as the single entry Account Interest rate That is why our implementation of writes the class value in this format .

The fact that we chose to implement this BankAccount value as the two double values + and is an implementation detail .
We could instead have implemented this BankAccount value as the two int values and the dollars and cents part of the and the single value of type double .
The value is simply converted to fraction , which might be more useful way to implement percentage figure .
After all , in order to compute interest on the account we convert percentage to just such fraction .
With this alternative implementation of the class BankAccount , the public members would remain unchanged but the private members would change to the following : Abstract Data Types class BankAccount .

We would need to change the member function definitions to match this change , but that is easy to do .
For example , the function definitions for and one version of the constructor could be changed to the .

Similarly , each of the other member functions could be redefined to accommodate this new of storing the account and the interest rate .

Notice that even though the user may think of the account as single number , that does not mean the implementation has to be single number of type double .
You have just seen that it could , for example , be two numbers of type int .
The programmer who uses the type BankAccount need not know any of this detail about how the values of the type BankAccount are implemented .

These comments about the type BankAccount illustrate the basic technique for defining class so that it will be an abstract data type .
In order to define class so that it is an abstract data type , you need to separate the specification of how the type is used by programmer from the details of how the type is implemented .
The separation should be so complete that you can change the implementation of the class without needing to make any changes in any program that uses the class ADT .
One to ensure this separation is to follow these rules : How to write an ADT .

Chapter Defining Classes .
Make all the member variables private members of the class .

Make each of the basic operations that the programmer needs public member function of the class , and fully specify how to use each such public member function .

Make any helping functions private member functions .

Separate interface and implementation VideoNote Separate Interface and Implementation In Chapters and you will learn some alternative approaches to defining ADTs , but these three rules are one common to ensure that class is an abstract data type .

The interface of an ADT tells you how to use the ADT in your program .

When you define an ADT as class , the interface consists of the public member functions of the class along with the comments that tell you how to use these public member functions .
The interface of the ADT should be all you need to know in order to use the ADT in your program .

The implementation of the ADT tells how this interface is realized as code .
The implementation of the ADT consists of the private members of the class and the definitions of both the public and private member functions .

Although you need the implementation in order to run program that uses the ADT , you should not need to know anything about the implementation in order to write the rest of program that uses the ADT ; that is , you should not need to know anything about the implementation in order to write the main part of the program and to write any nonmember functions used by the main part of the program .
The situation is similar to what we advocated for ordinary function definitions in Chapters and .
The implementation of an ADT , like the implementation of an ordinary function , should be thought of as being in black box that you cannot see inside .

In Chapter you will learn how to place the interface and implementation of an ADT in files separate from each other and separate from the programs that use the ADT .
That programmer who uses the ADT literally does not see the implementation .
Until then , we will place all of the details about our ADT classes in the same file as the main part of our program , but we still think of the interface in the public section of the class and the implementation private section of the class definition and the member function as separate parts of the ADT .
We will strive to write our ADTs so that the user of the ADT need only know about the interface of the ADT and need not know anything about the implementation .
To be sure you are defining your ADTs this  simply make sure that if you change the implementation of your ADT , your program will still work without your needing to change any other part of the program .
This is illustrated in the next Programming Example .

The most obvious benefit you derive from making your classes ADTs is that you can change the implementation without needing to change the other parts of your program .
But ADTs provide more benefits than that .
If you make your classes ADTs , you can divide work among different programmers , Abstract Data Types with one programmer designing and writing the ADT and other programmers using the ADT .
Even if you are the only programmer working on project , you have divided one larger task into two smaller tasks , which makes your program easier to design and easier to debug .

Programming Example lternative Implementation of Class Display contains the alternative implementation of the ADT class BankAccount discussed in the previous subsection .
In this version , the data for bank account is implemented as three member values : one for the dollars part of the account balance , one for the cents part of the account balance , and one for the interest rate .

Notice that , although both the in Display and the in Display each have member variable called rate , the value stored is slightly different in the two implementations .
If the account pays interest at rate of , then in the in Display is basically the same as the one in Display , the value of is .
However , in the in Display , the value of would be .
This alternative  shown in Display , stores the interest rate as fraction rather than as percentage figure .
The basic difference in this new is that when an interest rate is set , the function fraction is used to immediately convert the interest rate to fraction .
Hence , in this new the private member function fraction is used in the definitions of constructors , but it is not needed in the definition of the member function update because the value in the member variable has already been converted to fraction .
In the old in Display and Display , the situation was just the reverse .
In the old  the private member function fraction was not used in the definition of constructors , but was used in the definition of update .

Although we have changed the private members of the class BankAccount , we have not changed anything in the public section of the class definition .

The public member functions have the same function declarations and they behave exactly as they did in the old version of the ADT class given in Display .
For example , although this new stores percentage such as as the fraction , the member function still returns the value , just as it would for the old in Display .
Similarly , the member function returns single value of type double , which gives the balance as number with decimal point , just as it did in the old in Display .
This is true even though the balance is now stored in two member variables of type int , rather than in single member variable of type double in the old .

The public interface is not changed Chapter Defining Classes an alternative of the class BankAccount .

Notice that the public members of .

BankAccount look and behave bank account : exactly the same as in Display class BankAccount .

Since the body of main is identical to that in Display  the screen output is also identical to that in Display .

In this implementation , cents ; fraction is instead used in the definition of .

Chapter Defining Classes .

Notice that there is an important difference between how you treat the public member functions and how you treat the private member functions .

If you want to preserve the interface of an ADT class so that any programs that use it need not change than changing the of the class and its member , then you must leave the public member function declarations unchanged .
However , you are free to add , delete , or change any of the private member functions .
In this example , we have added one additional private function called percent , which is the inverse of the function fraction .

The function fraction converts percentage to fraction , and the function returns , and returns .

Information Hiding We discussed information hiding when we introduced functions in Chapter .
We said that information hiding , as applied to functions , means that you should write your functions so that they could be used as black boxes , that is , so that the programmer who uses the function need not know any details about how the function is implemented .
This principle means that all the programmer who uses function needs to know is the function declaration and the accompanying comment that explains how to use the function .
The use of private member variables and private member functions in the definition of an abstract data type is another way to implement information hiding , but now we apply the principle to data values as well as to functions .

Changing private member functions Chapter Defining Classes st Ex er c is es .
When you define an ADT as class , should you make the member variables public or private .
Should you make the member functions public or private .

When you define an ADT as class , what items are considered part of the interface for the ADT .
What items are considered part of the implementation for the ADT .

Suppose your friend defines an ADT as class in the way we described in Section .
You are given the task of writing program that uses this ADT .
That is , you must write the main part of the program as well as any nonmember functions that are used in the main part of the program .
The ADT is very long and you do not have lot of time to write this program .

What parts of the ADT do you need to read and what parts can you safely ignore .

The word inheritance is just another name for the topic of derived classes .
When we say that one class was derived from another class , we mean that the derived class was obtained from the other class by adding features .
For example , suppose we define class for vehicles that has member variables to record the number of wheels and maximum number of occupants .
The class also has accessor and mutator functions .
Imagine that we then define class for automobiles that has member variables and functions just like the ones in the class of vehicles .
In addition , our automobile class would have added member variables for such things as the amount of fuel in the fuel tank and the license plate number and would also have some added member functions .
Instead of repeating the of the member variables and functions of the class of vehicles within the class of automobiles , we could use inheritance mechanism and let the automobile class inherit all the member variables and functions of the class for vehicles .

Inheritance allows you to define general class and then later define more specialized classes that add some new to the existing general class .

This saves work because the more specialized , or derived , class inherits all the properties of the general class and you , the programmer , need only program the new .
This section will first introduce the notion of inheritance and derived class and then we briefly describe how to create your own derived Introduction to Inheritance classes .
Details of inheritance are left to Chapter .
It may take while before you are completely comfortable with the idea of derived class , but you easily can learn enough about derived classes to start using them in some simple , and very useful , ways .

Derived Classes Consider the BankAccount class defined in Display .
This class keeps track of an amount and interest rate for bank generic that apply to any account .
If we would like to implement more specific types of bank accounts , then there is natural hierarchy for grouping the account types .
Display depicts part of this hierarchical arrangement for bank accounts , checking accounts , money market accounts , savings accounts , and Certificate of Deposit accounts .
In the hierarchy , BankAccount is the most general type of account ; more specific types of accounts are shown underneath .
An arrow points from specific account type to more general account type .
In addition to representing different types of bank accounts , each box also corresponds to class that we can implement in .

For example , checking account does everything bank account can do an amount and interest but in addition allows customers to make deposits and write checks .
Similarly , savings account does everything bank account can do but in addition allows customers to make deposits and withdrawals .
Unlike checking account , savings account may not allow customers to write checks .
Since both checking accounts and savings accounts are types of bank accounts they are shown in Display directly underneath the BankAccount class .
When we say that some class is derived class of some other class , it means that class has all the of class but it also has added .
The convention for indicating this relationship in diagram is to draw an an unfilled arrow from the specific to the more general class .
For example , in Display the CheckingAccount and SavingsAccount classes are derived classes of the BankAccount class .

Display Class Hierarchy Bank Account Checking Account Savings Account Money Market Account CD Account .

Chapter Defining Classes In , some class can be derived class of some other class , which in turn can be derived class of some other class , and so on .
For example , CD account is similar to savings account except the funds and any accrued interest must not be withdrawn until after " date .
If the funds are withdrawn prior to the maturity date , then there is penalty .
Due to these restrictions , CD account normally accrues interest at higher rate than savings account .
In the hierarchy , this is shown by deriving CDAccount from SavingsAccount .
Similarly , money market account is special type of checking account in which the customer normally has limit on the number of checks that can be written , along with higher minimum balances , but pays higher interest rate .
In the hierarchy , this is shown by deriving MoneyMarketAccount from CheckingAccount .

Derived classes are often discussed using the metaphor of inheritance and family relationships .
If class is derived class of class , then class is called child of class and class is called parent of class .
The parent class is also referred to as the base class .
The derived class is said to inherit the member functions of its parent class .
For example , every convertible inherits the fact that it has four wheels from the class of all automobiles .
This is why the topic of derived classes is often called inheritance .

Defining Derived Classes If we want to create class to represent savings account , we could start by making copy of the BankAccount class and renaming it to SavingsAccount .

We would need to add new member functions to deposit and withdraw funds .
While this approach would work , it would be very inefficient , because the SavingsAccount class would duplicate most of the functionality in the BankAccount class .
Not only does this waste memory space , it also becomes more difficult to make modifications .
For example , if we later decide to change the function to accrue interest daily instead of annually , then we would have two places to make the change : in the SavingsAccount class and also in the BankAccount class .
These problems can be solved by defining the SavingsAccount class as derived class of the BankAccount class .

The SavingsAccount class then can share member variables and functions defined in the BankAccount class .
We specify this relationship when defining the derived class by adding colon followed by the keyword and the name of the parent or base class : The colon separates the class SavingsAccount  BankAccount derived class , Savings Account , from the parent class , BankAccount .

We need to redefine all of the variables and functions relating to bank as storing the interest rate , dollars , cents , or defining the those members will be inherited from the BankAccount class and are automatically created when we construct SavingsAccount object .
For example , if we create SavingsAccount object , we could invoke the following functions : Invoking function in .

Invoking function in the parent class , BankAccount In this example , inheritance allowed us to reuse code defined in the parent class from the context of the derived class .
Moreover , if we later change one of as the new code automatically will be used from the context of its derived classes when the program is recompiled and linked .
An implementation of the SavingsAccount class along with main function to test the deposit and withdraw functions is given in Display .
For simplicity , we have left verification out of the deposit and withdraw functions , for example , checking for negative amounts , but you should be able to add them easily with some if statements .

Once the SavingsAccount class is defined we can go one step further and derive more specialized classes from the SavingsAccount .
For example , to define the CD account class we need new member variable to store the days until maturity and define functions to access this variable : class CDAccount  SavingsAccount  dollars , int cents , double rate , int ; constructors would normally go .

Once again , we only defined functions and data that specifically relate to CD accounts , in this case , storing and manipulating the number of days to maturity .
We need to redefine all of the variables and functions relating to bank accounts or savings accounts because those members will be inherited from the parent classes .
For example , once the functions in the CDAccount class are implemented , we could invoke the following functions from the CDAccount , SavingsAccount , or BankAccount classes given CDAccount object :

Chapter Defining Classes from Display should be inserted here except for the main class SavingsAccount  BankAccount  The colon indicates that the class SavingsAccount is derived from .

Note the preceding colon .

Screen Output Account Interest rate .

Account Interest rate .

Account Interest rate .

CDAccount Invoking function in BankAccount This short example has only scratched the surface of what is possible using inheritance .
Additional details are described in Chapter .
While it does take some effort to learn how to effectively design classes using inheritance , the effort will pay off in the long run .
You will end up writing less code that is easier to understand and maintain than code that does not use inheritance .

Chapter Defining Classes es Exe rc is .
How does inheritance support code reuse and make code easier to maintain .

Can derived class directly access by name private variable of the parent class .

Suppose the class SportsCar is derived class of class Automobile .

Suppose also that the class Automobile has public functions named accelerate and addGas .
Will an object of the class SportsCar have functions named accelerate and addGas .

Chapter Summary structure can be used to combine data of different types into single data value .

If it is public , it can be used outside of the class .
If it is private , it can be used only in the definition of another member function in the class .

constructor must have the same name as the class of which it is member .

The child or derived class inherits members from the parent class .

Answers to Exercises Answe rs to est Exer cises .

Many compilers give poor error messages .
Surprisingly , the error message from is quite informative .

Member variables not provided an initializer are initialized to zero of appropriate type .

The author of the code provides only two digits for the date initializer .
There should be four digits used for the because program using dates could fail in ways that vary from amusing to disastrous at the turn of the century .

Both the dot operator and the scope resolution operator are used with member names to specify the class or struct of which the member name is member .
If class DayOfYear is as defined in Display and today is an object of the class DayOfYear , then the member may be accessed with the dot operator :
When we give the definition of member function , the scope resolution operator is used to tell the compiler that this function is the one declared in the class whose name is given before the scope resolution operator .

This restricts any change of private variables to functions provided by the class author .
The class author is then in control of these changes to the private data , preventing inadvertent corruption of the class data .

The compiler warns if you have no public : members in class struct for that .

Chapter Defining Classes c .
In class , such section is by default private : section .

In struct , such section is by default public : section .

YourClass YourClass .

If you mean this to be declaration of an object called , then it is wrong .
It is correct function declaration for function called that takes zero arguments and that returns value of type YourClass , but that is not the intended meaning .
As practical matter , you can probably consider it illegal .
The correct way to declare an object called Answers to Exercises so that it will be initialized with the default .

The modified class definition is as .

Notice that we have omitted the member function set , since the constructors make set unnecessary .
You must also add the following function definitions delete the function definition for .

The member variables should all be private .
The member functions that are part of the interface for the ADT is , the member functions that are operations for the should be public .
You may also have auxiliary helping functions that are used only in the definitions of other member functions .
These auxiliary functions should be private .

All the declarations of private member variables are part of the implementation .
All the function declarations for private member functions are part of the implementation .
All member function definitions the function is public or are part of the implementation .

You need to read only the interface parts .
That is , you need to read only the function declarations for public members of the class are listed in the class as well as the explanatory comments for these function declarations .
You need not read any of the function declarations of the private member functions , the declarations of the private member variables , the definitions of the public member functions , or the definitions of the private member functions .

dollars , int cents , double 

Functions and data defined for the parent class can be made available in the derived class , eliminating the need to redefine the functions and data again in the derived class .
This enhances maintainability because there is now no duplication of code among multiple classes and hence only single location in the code that may be subject to change .
Additionally , inheritance provides clean way to isolate code that is only applicable to derived class .
Since such code only appears in the definition of the derived class , it is usually easier to read .

No , but derived class can indirectly access private member variable of the parent class through public function .

Yes , the derived class will have access to the same functions .
In Chapter we will discuss how we can make the functions do different things for an object of class SportsCar versus an object of class Automobile .

Practice Programs Practice Programs can generally be solved with short program that directly applies the programming principles presented in this chapter .

Use the same member variables as in Display but make them private .
Include member functions for each of the following : one to return the initial balance , one to return the balance at maturity , one to return the interest rate , and one to return the term .
Include constructor that sets all of the member variables to any specified values , as well as default constructor .
Embed your class definition in test program .

The new is in many ways similar to the second for the class BankAccount given in Display .
Your new for the class CDAccount will record the balance as two values of type int : one for the dollars and one for the cents .
The member variable for the interest rate will store the interest rate as fraction rather than as percentage .
For example , an interest rate of will be stored as the value of type double .
Store the term in the same way as in Display .

Define class for type called CounterType .
An object of this type is used to count things , so it records count that is nonnegative whole number .

Include default constructor that sets the counter to zero and constructor VideoNote Solution to Practice Program .

Chapter Defining Classes with one argument that sets the counter to the value specified by its argument .
Include member functions to increase the count by and to decrease the count by .
Be sure that no member function allows the value of the counter to become negative .
Also , include member function that returns the current count value and one that outputs the count to stream .
The member function for doing output will have one formal parameter of type ostream for the output stream that receives the output .
Embed your class definition in test program .

Programming Projects Programming Projects require more than Practice Programs and can usually be solved many different to complete many of these Programming Projects online and get instant feedback .

Write grading program for class with the following grading policies :
There are two quizzes , each graded on the basis of points .

There is one midterm exam and one final exam , each graded on the basis of points .

The final exam counts for percent of the grade , the midterm counts for percent , and the two quizzes together count for total of percent .
They should be Any grade of or more is an , any grade of or more less than is , any grade of or more less than is , any grade of or more less than is , and any grade below is an .

The program will read in the scores and output the record , which consists of two quiz and two exam scores as well as the average numeric score for the entire course and the final letter grade .
Define and use structure for the student record .
If this is class assignment , ask your instructor if should be done with the keyboard and screen or if it should be done with files .
If it is to be done with files , ask your instructor for instructions on file names .

The student record class should have member variables for all the input data described in Programing Project and member variable for the weighted average numeric score for the entire course as well as member to the function , member functions to retrieve the data from each of the Programming Projects member variables , void function that calculates the weighted average numeric score for the entire course and sets the corresponding member variable , and void function that calculates the final letter grade and sets the corresponding member variable .

Define class called Month that is an abstract data type for month .
Your class will have one member variable of type int to represent month for January , for February , and so .
Include all the following member functions : constructor to set the month using the first three letters in the name of the month as three arguments , constructor to set the month using an integer as an argument for January , for February , and so , default constructor , an input function that reads the month as an integer , an input function that reads the month as the first three letters in the name of the month , an output function that outputs the month as an integer , an output function that outputs the month as the first three letters in the name of the month , and member function that returns the next month as value of type Month .
The input and output functions will each have one formal parameter for the stream .
Embed your class definition in test program .

This time the month is implemented as three member variables of type char that store the first three letters of the name of the month .
Embed your definition in test program .

Modify the program so that everything that is output to the screen is also output to file .
This means that all output statements will occur twice : once with the argument cout and once with an argument .
If you are in class , obtain the file name from your instructor .
The input will still come from the keyboard .
Only the output will be sent to file .

My mother always took little red counter to the grocery store .
The counter was used to keep tally of the amount of money she would have spent so far on that visit to the store , if she bought all the items in her basket .
There was display , increment buttons for each digit , and reset button .
There was an overflow indicator that came up red if more money was Write and implement the member functions of class Counter that simulates and slightly generalizes the behavior of this grocery store .

Accounting for any carry when you increment should require no further action than adding an appropriate number to the private data member .
member function bool ; detects overflow .

Even though the display is an integer , in the simulation , the rightmost two digits are always thought of as cents and tens of cents , the next digit is dollars , and the fourth digit is tens of dollars .

Provide keys for cents , dimes , dollars , and tens of dollars .
Unfortunately , no choice of keys seems particularly mnemonic .
One choice is to use the keys asdfo : for cents , followed by digit to ; for dimes , followed by digits to ; for dollars , followed by digit to ; and for tens of dollars , again followed by digit to .
Each entry of asdf followed by to is followed by pressing the Return key .
Any overflow is reported after each operation .
Overflow can be requested by pressing the key .

Write rational number class .
This problem will be revisited in Chapter , where operator overloading will make the problem much easier .
For now we will use member functions add , sub , mul , div , and less that each carry out the operations + and .
For example , + will be written , and will be written .

Programming Projects Provide member functions add , sub , mul , and div that return rational value .
Provide function less that returns bool value .
These functions should do the operation suggested by the name .
Provide member function neg that has no parameters and returns the negative of the calling object .

Provide main function that thoroughly tests your class implementation .

The following formulas will be useful in defining functions .

Define class called Odometer that will be used to track fuel and mileage for an automotive vehicle .
Include private member variables to track the miles driven and the fuel efficiency of the vehicle in miles per gallon .
The class should have constructor that initializes these values to zero .
Include member function to reset the odometer to zero miles , member function to set the fuel efficiency , member function that accepts miles driven for trip and adds it to the total , and member function that returns the number of gallons of gasoline that the vehicle has consumed since the odometer was last reset .

Use your class with test program that creates several trips with different fuel efficiencies .

Use private member variables to store the day , month , and year along with an appropriate constructor and member functions to get and set the data .
Create public function that returns the day of the week .
All helper functions should be declared private .
Embed your class definition in suitable test program .

The The United States Postal Service printed bar code on every envelope that represented digit zip code using format called POSTNET format was deprecated in favor of new  OneCode , in .
The bar code consists of long and short bars as shown :

Chapter Defining Classes For this program , we will represent the bar code as string of digits .

The digit represents long bar , and the digit represents short bar .

Therefore , the bar code would be represented in our program as The first and last digits of the bar code are always .
Removing these leaves digits .
If these digits are split into groups of digits each , we have .

There will always be exactly two in each group of digits .
Each digit stands for number .
From left to right , the digits encode the values , and .
Multiply the corresponding value with the digit and compute the sum to get the final encoded digit for the zip code .
The table below shows the encoding for .

Bar Code Digits .

Zip + + + + Repeat this for each group of digits and concatenate to get the complete zip code .
There is one special value .
If the sum of group of digits is , then this represents the digit is necessary because with two digits per group it is not possible to represent .
The zip code for the sample bar code decodes to .
Although the POSTNET scheme may seem unnecessarily complex , its design allows machines to detect if errors have been made in scanning the zip code .

Write zip code class that encodes and decodes bar codes used by the The United States Postal Service on envelopes .
The class should have two constructors .
The first constructor should input the zip code as an integer , and the second constructor should input the zip code as bar code string consisting of and , as described above .
Although you have two ways to input the zip code , internally , the class should store the zip code using only one format may choose to store it as bar code string or as zip code .
The class should also have at least two public member functions , one to return the zip code as an integer , and the other to return the zip code in bar code format as string .
All helper functions should be Programming Projects declared private .
Embed your class definition in suitable test program .

Your program should print an error message if an invalid bar code is passed to the constructor .

Consider class Movie that contains information about movie .
The class has the following attributes : The movie name .

Implement the class with accessor and mutator functions for the movie name and MPAA rating .
Write function addRating that takes an integer as an input parameter .
The function should verify that the parameter is number between and , and if so , increment the number of people rating the movie that match the input parameter .
For example , if is the input parameter , then the number of people that rated the movie as should be incremented by .
Write another function , getAverage , that returns the average value for all of the movie ratings .
Finally , add constructor that allows the programmer to create the object with specified name and MPAA rating .
The number of people rating the movie should be set to in the constructor .

Test the class by writing main function that creates at least two movie objects , adds at least five ratings for each movie , and outputs the movie name , MPAA rating , and average rating for each movie object .

Winston Churchill , Radio Broadcast , February , Introduction This chapter teaches you more techniques defining functions and operators classes , including overloading common operators such as + and so that they can be used with the classes you define in the same way that they are used with the predefined types such as int and double .

Prerequisites This chapter uses material from Chapters through .

Common advice Until now we have implemented class operations , such as input , output , accessor functions , and so forth , as member functions of the class , but some operations , it is more natural to implement the operations as ordinary functions .
In this section , we discuss techniques defining operations on objects as nonmember functions .
We begin with simple example .

Programming Example An Equality Function In Chapter , we developed class called DayOfYear that records date , such as January or July , that might be holiday or birthday or some other annual event .
We gave progressively better versions of the class .

The final version was produced in Exercise of Chapter .
In Display , we repeat this final version of the class DayOfYear and have enhanced the class one more time by adding function called equal that can test two objects of type DayOfYear to see if their values represent the same date .

Chapter Friends , Overloaded Operators , and Arrays in Classes .

Omitted function and constructor definitions are as in Chapter , Exercises and , but those details are not needed for what we are doing here .

birthday is , Happy Birthday Johann Sebastian .

Suppose today and are two objects of type DayOfYear that have been given values representing some dates .
You can test to see if they represent the same date with the following Boolean expression : This call to the function equal returns true if today and represent the same date .
In Display this Boolean expression is used to control an statement .

The definition of the function equal is straight forward .
Two dates are equal if they represent the same and the same of the .

The definition of equal uses accessor functions and to compare the months and the days represented by the two objects .

Notice that we did not make the function equal member function .
It would be possible to make equal member function of the class DayOfYear , but equal compares two objects of type DayOfYear .
If you make equal member function , you must decide whether the calling object should be the first date or the second date .
Rather than arbitrarily choosing one of the two dates as the calling object , we instead treated the two dates in the same way .

We made equal an ordinary function that takes two dates as its arguments .

el est Exerc ise .
Write function definition for function called before that takes two arguments of the type DayOfYear , which is defined in Display .

The function returns bool value and returns true if the first argument represents date that comes before the date represented by the second argument ; otherwise , the function returns false ; for example , January comes before February .

Chapter Friends , Overloaded Operators , and Arrays in Classes Friend Functions If your class has full set of accessor functions , you can use the accessor functions to define function to test for equality or to do any other kind of computing that depends on the private member variables .
However , although this may give you access to the private member variables , it may not give you efficient access to them .
Look again at the definition of the function equal given in Display .
To read the  it must make call to the accessor function .
To read the  it must make call to the accessor function .
This works , but the code would be simpler and more efficient if we could just access the member variables .

simpler and more efficient definition of the function equal given in Display would be as .

illegal because the member variables and are private members of the class DayOfYear .

Private member variables private member cannot normally be referenced in the body of function unless the function is member function , and equal is not member function of the class DayOfYear .
But there is way to give nonmember function the same access privileges as member function .
If we make the function equal friend of the class DayOfYear , then the previous definition of equal will be legal .

friend function of class is not member function of the class , but friend function has access to the private members of that class just as member function does .
friend function can directly read the value of member variable and can even directly change the value of member variable , for example , with an assignment statement that has private member variable on one side of the assignment operator .
To make function friend function , you must name it as friend in the class definition .
For example , in Display we have rewritten the definition of the class DayOfYear so that the function equal is friend of the class .

You make function friend of class by listing the function declaration in the definition of the class and placing the keyword friend in front of the function declaration .

friend function is added to class definition by listing its function declaration , just as you would list the declaration of member function , except that you precede the function declaration by the keyword friend .

However , friend is not member function ; rather , it really is an ordinary function with extraordinary access to the data members of the class .
The friend is defined and called exactly like the ordinary function it is .
In particular , the function definition for equal shown in Display does Friend Functions Display Equality Function as Friend .

Note that the private member variables and can be accessed by name .

Chapter Friends , Overloaded Operators , and Arrays in Classes not the qualifier : in the function heading .
Also , the equal function is not called by using the dot operator .
The function equal takes objects of type DayOfYear as arguments the same way that any other nonmember function would take arguments of any other type .
However , friend function definition can access the private member variables and private member functions of the class by name , so it has the same access privileges as member function .

After all , friend functions have access to the private member variables and so do not need accessor or mutator functions .
This is not entirely wrong .
It is true that if you made all the functions in the world friends of class , you would not need accessor or mutator functions .
However , making all functions friends is not practical .

In order to see why you still need accessor functions , consider the example of the class DayOfYear given in Display .
You might use this class in another program , and that other program might very well want to do something with the part of DayOfYear object .
For example , the program might want to calculate how many months there remaining in the year .
Specifically , the main part of the program might contain the .

You have just seen that you definitely need to accessor functions in your class .
Other cases require mutator functions .
You may think that , because you usually need accessor and mutator functions , you do not need friends .
In sense , that is true .
Notice that you could define the function or not as friend and use accessor functions in Display .
In most situations , the only reason to make function friend is to make the definition of the function simpler and more efficient ; but sometimes , that is reason enough .

To make function friend of class , you must list the function declaration for the friend function in the class definition .
The function declaration is preceded by the keyword friend .
The function declaration may be placed in either the private section or the public section , but it will be public function in either case , so it is clearer to list it in the public section .

private : You need not list the friend functions first .
You can inter mix the order of these function declarations .

Example class FuelTank public : friend double .

friend function is defined and called the same way as an ordinary function .
You do not use the dot operator in call to friend function and you do not use type qualifier in the definition of friend function .

In fact , sometimes it is not clear whether you should make particular function friend of your class or member function of the class .
In most cases , you can make function either member function or friend and have it perform the same task in the same way .
There  however , places where it is better to use member function and places where it is better to use friend function even plain old function that friend , like the version of equal in Display .
simple rule to help you decide between member functions and nonmember functions is the following : Use member function if the task being performed by the function involves only one object .

For example , the function equal in Display Display involves two objects , so we made it nonmember function .

Whether you make nonmember function friend function or use accessor and mutator functions is matter of efficiency and personal taste .
As long as you have enough accessor and mutator functions , either approach will work .

The choice of whether to use member or nonmember function is not always as simple as the above two rules .
With more experience , you will discover situations in which it pays to violate those rules .
more accurate but harder to understand rule is to use member functions if the task is intimately related to single object ; use nonmember function when the task involves more than one object and the objects used symmetrically .
However , this more accurate rule is not , and the two simple rules given above will serve as reliable guide until you become more sophisticated in handling objects .

The value is implemented as single integer value that represents the amount of money as if it were converted to all pennies .
For example , would be stored as the value .
Since we use an integer to represent the amount of money , the amount is represented as an exact quantity .

We did not use value of type double because values of type double stored as approximate values and we want our money amounts to be exact quantities .

This integer for the amount of money as all is stored in member variable named .
We could use int for the type of the Friend Functions member variable , but with some compilers that would severely limit the amounts of money we could represent .
In some implementations of , only bytes are used to store the int The result of the implementation is that the largest value of type int is only slightly larger than , but cents represents only , which is fairly small amount of money .
Since we may want to deal with amounts of money much larger than , we have used long for the type of the member variable .

compilers that implement the int type in bytes usually implement the type long in bytes .
Values of type long are integers just like the values of the type int , except that the long implementation enables the largest allowable value of type long to be much larger than the largest allowable value of type int .
On most systems the largest allowable value of type long is billion or larger .
The two names long The class Money has two operations that are friend functions : equal and add are defined in Display .
The function add returns Money object whose value is the sum of the values of its two arguments .
function call of the form , returns true if the two objects and have values that represent equal amounts of money .

Notice that the class Money reads and writes amounts of money as we normally write amounts of money , such as or .
First , consider the member function input defined in Display .
That function first reads single character , which should be either the dollar sign or the minus sign .
If this first character is the minus sign , then the function remembers that the amount is negative by setting the value of the variable negative to true .
It then reads an additional character , which should be the dollar sign .
On the other hand , if the first symbol is not , then negative is set equal to false .
At this point the negative sign and the dollar sign have been read .
The function input then reads the number of dollars as value of type long and places the number of dollars in the local variable named dollars .
After reading the dollars part of the input , the function input reads the remainder of the input as values of type char ; it reads in three characters , which should be decimal point and two digits .

This is not done because of the way that some compilers treat leading zeros .
As explained in the Pitfall section entitled Zeros in Number " many compilers still in use do not read numbers with leading zeros as you would like them to , so an amount like may be read incorrectly if your code were to read the as See Chapter for details .
Display has description of data types as most recent compilers implement them .

Chapter Friends , Overloaded Operators , and Arrays in Classes .

If the amount is negative , both dollars and cents must be negative .

; the object so its value represents .

; the object so its value represents .

An amount of money , including dollar sign , has been in the input stream ins .
Notation negative amounts is .

Chapter Friends , Overloaded Operators , and Arrays in Classes .

Sample Dialogue Enter an amount of money : Your amount is My amount is One of us is richer .

Chapter Friends , Overloaded Operators , and Arrays in Classes The following assignment statement converts the two digits that make up the part of the input amount to single integer , which is stored in the local variable  + After this assignment statement is executed , the value of is the number of in the input amount .

The helping function takes an argument that is digit , such as , and converts it to the corresponding int value , such as .
We need this helping function because the member function input reads the two digits for the number of as two values of type char , which are stored in the local variables and .
However , once the digits are read into the computer , we want to use them as numbers .
Therefore , we use the function to convert digit such as ' to number such as .

The definition of the function is given in Display .
You can simply take it on faith that this definition does what it is supposed to do and treat the function as black box .
All you need to know is that returns , returns , and so forth .
However , it is not too difficult to see how this function works , so you may want to read the optional section that follows this one .
It explains the implementation of .

Once the local variables and are set to the number of and the number of in the input amount , it is easy to set the member variable .
The following assignment statement sets to the correct number of  +  However , this always sets to positive amount .
If the amount of money is  then the value of must be changed from positive to .
This is done with the following statement : The member function output calculates the number of and the number of from the value of the member variable It computes the number of and the number of using integer division by .
For example , if has value of , then the number of is , which is , and the number of is , which is .
Thus , would be the value output when the value of is .

The definition for the member function output needs to make special provisions for outputting amounts of money .
The result of integer division with numbers does not have standard definition and can vary from one implementation to another .
To avoid this problem , we have taken the absolute value of the number in before performing Friend Functions division .
To compute the absolute value we use the predefined function labs .

The function labs returns the absolute value of its argument , just like the function abs , but labs takes an argument of type long and returns value of type long .
The function labs is in the library with header file cstdlib , just like the function abs .
If your implementation of does not include labs , you can easily define the The definition of the function from Display is reproduced .

At first glance , the formula for the value returned may seem bit strange , but the details are not too complicated .
The digit to be for example , the parameter c , and the returned value will turn out to be the corresponding int this example ,
As we pointed out in Chapters and , values of type char are implemented as numbers .

Unfortunately , the number implementing the digit , for example , is not the number .
The type cast produces the number that implements the character c and converts this number to the type int .
This changes c from the type char to number of type int but , unfortunately , not to the number we want .
For example , is not , but is some other number .
We need to convert to the number corresponding to c example , to .
So see how we must adjust to get the number we want .

We know that the digits are in order .
So + is equal to ; + is equal to ; + is equal to , and so forth .
Knowing that the digits are in this order is all .

Leading Zeros in Number Constants .

However , this will cause problems .
In mathematics , the numerals and represent the same number .
However , some compilers use leading zero to signal different kind of numeral , so in the constants and are not necessarily the same number .
With some compilers , leading zero means that the number is written in base rather than base .
Since base numerals do not use the digit , the constant does not make sense in .
The constants through should work correctly , since they mean the same thing in base and in base , but some systems in some contexts will have trouble even with through .

The ANSI standard provides that input should default to being interpreted as decimal , regardless of the leading .
The GNU project compiler , and compiler do comply with the standard , and so they do not have problem with leading zeros .
Most compiler vendors track the ANSI standard and thus should be compliant with the ANSI standard , and so this problem with leading zeros should eventually go away .

You should write small program to test this on your compiler .

What is the difference between friend function for class and member function for the class .

Suppose you wish to add friend function to the class DayOfYear defined in Display .
This friend function will be named after and will take two arguments of the type DayOfYear .
The function returns true if the first argument represents date that comes after the date represented by the second argument ; otherwise , the function returns false .
For example , February comes after January .
What do you need to add to the definition of the class DayOfYear in Display .

Suppose you wish to add friend function for subtraction to the class Money defined in Display .
What do you need to add to the description of the class Money that we gave in Display .
The subtraction function should take two arguments of type Money and return value of type Money whose value is the value of the first argument minus the value of the second argument .

In order to write value of type Money to the screen , you call output with cout as an argument .
For example , if purse is an object of type Money , then to output the amount of money in purse to the screen , you write the following in your program : It might be nicer not to have to list the stream cout when you send output to the screen .

Rewrite the class definition for the type Money given in Display .
The only change is that this rewritten version overloads the function name output so that there are two versions of output .
One version is just like the one shown in Display ; the other version of output takes no arguments and sends its output to the screen .
With this rewritten version of the type Money , the following two calls are equivalent :

Note that since there will be two versions of the function output , you can still send output to file .
If outs is an output file stream that is connected to file , then the following will output the money in the object purse to the file connected to outs : Notice the definition of the member function input of the class Money given in Display .
If the user enters certain kinds of incorrect input , the function issues an error message and ends the program .
For example , if the user omits dollar sign , the function issues an error message .

However , the checks given there do not catch all kinds of incorrect input .

For example , negative amounts of money are supposed to be entered in the form , but if the user mistakenly enters the amount in the form , then the input will not issue an error message and the value of the Money object will be set to an incorrect value .
What amount will the member function input read if the user mistakenly enters .
How might you add additional checks to catch most errors caused by such misplaced minus sign .

Chapter Friends , Overloaded Operators , and Arrays in Classes .
The Pitfall section entitled Zeros in Number Constants " suggests that you write short program to test whether leading will cause your compiler to interpret input numbers as numerals .
Write such program .

The const Parameter Modifier parameter is more efficient than parameter .

parameter is local variable that is initialized to the value of its argument , so when the function is called there are two copies of the argument .

With parameter , the parameter is just placeholder that is replaced by the argument , so there is only one copy of the argument .

For parameters of simple types , such as int or double , the difference in efficiency is negligible , but for class parameters the difference in efficiency can sometimes be important .
Thus , it can make sense to use parameter rather than parameter for class , even if the function does not change the parameter .

If you are using parameter and your function does not change the value of the parameter , you can mark the parameter so that the compiler knows that the parameter should not be changed .
To do so , place the modifier const before the parameter type .
The parameter is then called constant parameter .
For example , consider the class Money defined in Display .
The Money parameters for the friend function add can be made into constant parameters as follows : class Money public : friend Money , const .

When you use constant parameters , the modifier const must be used in both the function declaration and in the heading of the function definition , so with the change in the class definition above , the function definition for add would begin as follows :

The remainder of the function definition would be the same as in Display .

Constant parameters are form of automatic error checking .
If your function definition contains mistake that causes an inadvertent change to the constant parameter , then the computer will issue an error message .

The parameter modifier const can be used with any kind of parameter ; however , it is normally used only for parameters for classes occasionally for certain other parameters whose corresponding arguments are .

When you have call to member function , the calling object behaves very much like parameter .
When you have call to member function , that function call can change the value of the calling object .

For example , consider the following , where the class Money is as in Display : const with .

When the object is declared , the of the member variable is initialized to .
The call to the member function input changes the of the member variable to new determined by what the user types in .
Thus , the call changes the of , just as if were argument .

The modifier const applies to calling objects in the same way that it applies to parameters .
If you have member function that should not change the of calling object , you can mark the function with the const modifier ; the computer will then issue an error message if your function code inadvertently changes the of the calling object .
In the case of member function , the const goes at the end of the function declaration , just before the final semicolon , as shown here : class Money public :

The modifier const should be used in both the function declaration and the function definition , so the function definition for output would begin as follows : void const .

Inconsistent Use of const Use of the const modifier is an proposition .
If you use const for one parameter of particular type , then you should use it for every other parameter that has that type and that is not changed by the function call ; moreover , if the type is class type , then you should also use the const modifier for every member function that does not change the of its calling object .

For example , consider the following definition of the function guarantee : VideoNote const Confusion .

The member function does not change the calling object price .
However , when the compiler processes the function definition for guarantee , it will think that does at least change the of price .
This is because when it is translating the function definition for guarantee , all that the compiler knows about the member function is the function declaration for  if the function declaration does not contain const , which tells the compiler that the calling object will not be changed , then the compiler assumes that the calling object will be changed .
Thus , if you use the modifier const with parameters of type Money , then you should also use const with all Money member functions that do not change the of their calling object .

In particular , the function declaration for the member function should include const .

In Display we have rewritten the definition of the class Money given in Display , but this time we have used the const modifier where appropriate .
The definitions of the member and friend functions would be the same as they are in Display , except that the modifier const must be used in function headings so that the headings match the function declarations shown in Display .

If you make mistake in your definition of the function so that it does change the constant parameter , then the computer will give an error message .

Parameters of class type that are not changed by the function ordinarily should be constant parameters , rather than parameters .

If you make mistake in your definition of the function so that it does change the calling object and the function is marked with const , then the computer will give an error message .
The const is placed at the end of the function declaration , just before the final semicolon .

The heading of the function definition should also have const so that it matches the function declaration .

Example class Sample .

Use of the const modifier is an proposition .
You should use the const modifier whenever it is appropriate for class parameter and whenever it is appropriate for member function of the class .
If you do not use const every time that it is appropriate for class , then you should never use it for that class .

Chapter Friends , Overloaded Operators , and Arrays in Classes the object so its value represents an amount with the and cents given by the arguments .
If the amount is negative , both dollars and cents must be negative .

An amount of money , including dollar sign , has been in the input stream ins .
Notation negative amounts is .

Give the complete definition of the member function that you would use with the definition of given in Display .

Why would it be incorrect to add the modifier const , as shown here , to the function declaration the member function input of the class given in Display .

What are the differences and the similarities between parameter and parameter .
Function declarations that illustrate these are .

What is the promise in each case .

Earlier in this chapter , we showed you how to make the function add friend of the class and use it to add two objects of type .

The function add is adequate adding objects , but it would be nicer if you could simply use the usual + operator to add values of type  as in the last line of the following .

Recall that an operator , such as + is really just function except that the syntax how it is used is slightly different from that of an ordinary function .

In an ordinary function call , the arguments are placed in parentheses after the function name , as in the following : With operator , the arguments are placed on either side of the operator , as shown here : cost + tax .

Chapter Friends , Overloaded Operators , and Arrays in Classes function can be overloaded to take arguments of different types .
An operator is really function , so an operator can be overloaded .
The way you overload an operator , such as + is basically the same as the way you overload function name .
In this section we show you how to overload operators in .

Overloading Operators You can overload operator + many other so it will accept arguments of class type .
The difference between overloading + operator and defining function add in Display involves only slight change in syntax .
The definition of overloaded operator + is basically same as definition of function add .
The only differences are you use name + instead of name add and you precede + with keyword operator .
In Display we have rewritten type to include overloaded operator + and we have embedded definition in small demonstration program .

The class  as defined in Display , also overloads so can be used to compare two objects of type .
If and are two objects of type Money , we want expression to return same value as following Boolean expression :

As shown in Display , this is value returned by overloaded .

You can overload most , but not all , operators .
The need not be friend of class , but you will often want it to be friend .
Check box entitled on Overloading Operators " for some technical details on when and how you can overload an .

Operator Overloading  such as + and so forth , is simply function is called using different syntax for listing its arguments .
With an  arguments are listed before and after  with function , arguments are listed in parentheses after function name .
An is written similarly to function  except includes reserved word before name .
The predefined operators , such as + and so forth , can be overloaded by giving them new for class type .

An may be friend of class although this is not required .
An example of overloading + as friend is given in Display .

Some comments from Display have been omitted to save space in this book , but they should be included in real program .

Chapter Friends , Overloaded Operators , and Arrays in Classes .

No other changes are needed in the member function definitions .
The bodies of the member function definitions are identical to those in Display Output Things seem normal .

el est Exe rc ise .
What is the difference between and function .

Suppose you wish to overload the so that it applies to the type Money defined in Display .
What do you need to add to the description of Money given in Display .

Suppose you wish to overload the so that it applies to the type Money defined in Display .
What do you need to add to the description of Money given in Display .

Is it possible using overloading to change the behavior of + on integers .

Rules on Overloading Operators When overloading an  at least one argument of the resulting overloaded must be of class type .

For example , you cannot change from binary to unary when you overload ; you cannot change from unary to binary when you overload it .

An overloaded has the same precedence as the ordinary version of the .
For example , always means , even if , and are objects and the operators + and have been overloaded the appropriate classes .

Some other operators , including and arrow_operator also must be overloaded in way that is different from what is described in this chapter .
The operators and arrow_operator are discussed later in this book .

Constructors for Automatic Type Conversion If your class definition contains the appropriate constructors , the system will perform certain type conversions automatically .
For example , if your program contains the definition the class Money given in Display , you could use the following in your program :

The the expression + is not the appropriate type .
In Display we only overloaded the + so that it could be used with two values type Money .
We did not overload + so that it could be used with value type Money and an integer .
The constant is an integer and is not type Money .
The constant can be considered to be type int or type long , but cannot be used as value type Money unless the class definition somehow tells the system how to convert an integer to value type Money .
The only way that the system knows that means is that we included constructor that takes single argument type long .
When the system sees the expression + it first checks to see if the + has been overloaded for the combination value type Money and an integer .
Since there is no such overloading , the system next looks to see if there is constructor that takes single argument that is an integer .
If it finds constructor that takes argument , it uses that constructor to convert the integer to value type Money .
The constructor with one argument type long tells the system how to convert an integer , such as , to value type Money .
The constructor says that should be converted to an object type Money whose member variable is equal to ; in other words , the constructor converts to an object type Money that represents .
For example , the type Money has no constructor that takes an argument type double , so the following is illegal and would produce an error message if you were to put it in program that declares and to be type Money : + To make this use + legal , you could change the definition the class Money by adding another constructor .
The function declaration for the constructor you need to add is the following : class Money .

Writing the definition for this new is Exercise .

These automatic type conversions by seem most common and compelling with overloaded numeric operators such as + and .

However , these automatic conversions apply in exactly the same way to arguments for ordinary functions , arguments for member functions , and arguments for other overloaded operators .

el est Exerc ise .
Give the definition for the discussed at the end the previous section .
The is to be added to the class Money in Display .

The definition begins as follows : Unary Operators In addition to the binary operators , such as + in , there are also unary operators , such as the when it is used to mean negation .
In the following statement , the unary is used to set the value variable equal to the negative the value the variable : The increment and decrement operators and are other examples unary operators .

You can overload unary operators as well as binary operators .
For example , you can redefine the type Money given in Display so that it has both unary and binary version the .
The redone class definition is given in Display .
Suppose your program contains this class definition and the following code : Money ,

The overloading definition will apply to the when it is used in prefix position , as in and .

The postfix versions and , as in and , are handled in different manner , but we will not discuss these postfix versions .
For example , consider the .

Overloading The operator is , the first operand is the output stream  and the second operand is the string value out .
You can change either of these operands .
If fout is an output stream of type ofstream and fout has been connected to file with call to open , then you can replace with fout and the string will instead be written to the file connected to fout .
Of course , you can also replace the string out " with another string , variable , or number .
Since the insertion operator is an operator , you should be able to overload it just as you overload operators such as + and .
This is true , but there are few more details to worry about when you overload the input and output operators and .

In our previous definitions of the class Money , we used the member function output to output values of type Money through .

This is adequate , but it would be nicer if we could simply use the insertion operator to output values of type Money as in the following : Money .

This is an improved version class Money of the class Money given in Display .

Chapter Friends , Overloaded Operators , and Arrays in Classes The two operands in this expression are and  and evaluating the expression should cause the value of to be written to the screen .

But if is an like + or , then the expression above should also return some value .
After all , expressions with other operands , such as + return values .

To obtain the answer to that question , we need to look at more complicated expression involving .

consider the following expression , which involves evaluating chain of expressions using :   in my .

The first thing evaluated is the subexpression : If things are to work out , then the subexpression had better return so that the computation can continue as follows :  in my ; And if things are to continue to work out , had better also return so that the computation can continue as follows :  in my ; returns stream This is illustrated in Display .
The should return its first argument , which is stream of type ostream .

Thus , the declaration the overloaded use with the class should be as follows : class Money .

Once we overloaded the insertion , we will no longer need the member function output and thus can delete output from Overloading Operators Display as an Operator .

Since there are no more operators , the process ends .

The definition of the overloaded is very similar to the member function output .
In outline form , the definition for the overloaded is as follows : This part is the same as the body of that is given in Display that is replaced with return .

Chapter Friends , Overloaded Operators , and Arrays in Classes and return reference Returning reference There is one thing left to explain in the previous function declaration and definition for the overloaded .
What is the meaning of the in the returned type .
The easiest answer is that whenever an returns stream , you must add an to the end of the name for the returned type .
That simple rule will allow you to overload the operators and .

However , although that is good working rule that will allow you to write your class definitions and programs , it is not very satisfying .
You do not need to know what that really means , but if we explain it , that will remove some of the mystery from the rule that tells you to add an .

When you add an to the name of returned type , you are saying that the returns reference .
All the functions and operators we seen thus far return values .
However , if the returned type is stream , you cannot simply return the value of the stream .
In the case of stream , the value of the stream is an entire file or the keyboard or the screen , and it may not make sense to return those things .
Thus , you want to return only the stream itself rather than the value of the stream .
When you add an to the name of returned type , you are saying that the returns reference , which means that you are returning the object itself , as opposed to the value of the object .

The extraction is overloaded in way that is analogous to what , the second argument will be the object that receives the input value , so the second parameter must be an ordinary parameter .
In outline form , the definition for the overloaded extraction is as follows : This part is the same as the body of given in Display that is replaced with return ins ; The complete definitions of the overloaded operators and are given in Display , where we rewritten the class Money yet again .
This time we rewritten the class so that the operators and are overloaded to allow us to use these operators with values of type Money .

Overloading and The input and output operators and can be overloaded just like any other operators .

The type for the value returned must the symbol added to the end of the type name .
The function declarations and beginnings of the function definitions are as shown on the next page .
See Display for an example .

DEFINITIONS ,

This is an improved version of the class Money that we gave in Display .

Although we have omitted some of the comments from Displays and , you should them .

Chapter Friends , Overloaded Operators , and Arrays in Classes .

Chapter Friends , Overloaded Operators , and Arrays in Classes .

See Displays , and for the copied from the file .

Screen Output copied from the file .

Objects of type Pairs can be used in any situation where ordered pairs are needed .
Your task is to write implementations of the overloaded and the overloaded so that objects of class Pairs are to be input and output in the form or .
You need not implement any constructor or other member , and you need not do any input format checking .

Following is the definition for class called Percent .
Objects of type Percent represent percentages such as or .
Give the definitions of the overloaded operators and so that they can be used for input and output with objects of the class Percent .
Assume that input always consists of an integer followed by the character , such as .

All percentages are whole numbers and are stored in the int member variable named value .
You do not need to define the other overloaded operators and do not need to define the constructor .
You only have to define the overloaded operators and .

; the to input values of type .

In this section we discuss few simple examples to give you an idea of the possibilities .

Arrays of Classes The base type of an array may be any type , including types that you define , such as structure and class types .
If you want each indexed variable to contain items of different types , make the array an array of structures .

For example , suppose you want an array to hold ten weather data points , where each data point is wind velocity and wind direction , south , east , or .
You might use the following type definition and array declaration : struct WindInfo .

The way to read an expression such as is left to right and very carefully .
First , is an array .
So , is the ith indexed variable of this array .
An indexed variable of this array is of type WindInfo , which is structure with two member variables named velocity and direction .
So , is the member variable named velocity for the ith array element .
Less formally , is the wind velocity for the ith data point .
Similarly , is the wind direction for the ith data point .

The ten data points in the array can be written to the screen with the following for loop :  endl ; Display contains the definition for class called Money .
Objects of the class Money are used to represent amounts of money in The United States currency .

The definitions of the member functions , member operations , and friend functions for this class can be found in Displays through and in the answer to Exercise .
You can have arrays whose base type is the type Money .
simple example is given in Display .
That program reads in list of five amounts of money and computes how much each amount differs from the largest of the five amounts .
Notice that an array whose base type is class is treated basically the same as any other array .
In fact , the program in Display is very similar to the program in Display , except that in Display the base type is class .

When an array of classes is declared , the default constructor is called to initialize the indexed variables , so it is important to have default constructor for any class that will be the base type of an array .
An array of classes is manipulated just like an array with simple base type like int or double .

For example , the difference between each amount and the largest amount is stored in an array named difference , as follows : Money .

Chapter Friends , Overloaded Operators , and Arrays in Classes is the definition for the class Money .

If the amount negative , then both dollars and cents should be negative .

; the object so its value represents .

; the object so its value represents .

Precedes each output value of type Money with dollar sign .

Sample Dialogue Enter amounts of money : The highest amount The amounts and their differences from the largest are : off by off by off by off by off by .

Chapter Friends , Overloaded Operators , and Arrays in Classes el est Exe rc ise .
Give type definition for structure called Score that has two member variables called and opponent .
Both member variables are of type int .
Declare an array called game that an array with ten elements of type Score .
The array game might be used to record the scores of each of ten games for sports team .

Write program that reads in five amounts of money , doubles each amount , and then writes out the doubled values to the screen .
Use one array with Money as the base type .
For example , suppose you are speed swimmer and want program to keep track of your practice times for various distances .
You can use the structure the type Data given to record distance and the times for each of ten practice tries swimming that distance : struct Data .

The structure , declared above , has two member variables : One , named  variable of type int record ; the other , named time , an array of ten values of type double hold times for ten practice tries at the specified .
To set the equal to , you can use the following :

The expression read left to right : structure ; the member variable named time .
Since an array , it makes sense to add an index .
So , the expression the ith indexed variable of the array .
If you use class rather than structure type , then you can do all your array manipulations with member functions and avoid such confusing expressions .
This illustrated in the following Programming Example .

You might use an object of type TemperatureList in program that does weather analysis .
The list of temperatures kept in the member variable list , which an array .
Since this array will typically be only partially filled , second member variable , called size , used to keep track of how much of the array used .
The value of size the number of indexed variables of the array list that are being used to store values .

An of type TemperatureList declared like an of any other type .
For example , the following declares to be an of type TemperatureList : TemperatureList ; This declaration calls the default constructor with the new , and so the initialized so that the member variable size has the value , indicating an empty list .

Once you have declared an such as , you can add an item to the list of temperatures  to the member array with call to the member function as follows : In fact , this the only way you can add temperature to the list , since the array list private member variable .
Notice that when you add an item with call to the member function , the function call first tests to see if the array list full and adds the value only if the array not full .

The class TemperatureList very specialized .
The only things you can do with an of the class TemperatureList are to initialize the list so it empty , add items to the list , check if the list full , and output the list .
To output the temperatures stored in the , the call would be as follows :  With the class TemperatureList you cannot delete temperature from .

You could define similar class lists of pressures or lists of distances or lists of any other data expressed as values of type double .
To save yourself the trouble of defining all these different classes , you could define single class that represents an arbitrary list of values of type double without specifying what the values represent .

Chapter Friends , Overloaded Operators , and Arrays in Classes is definition the class .
Values of this type are lists of Fahrenheit temperatures .

Temperatures are output one per line .

el est Exerc ise .
Change the class TemperatureList given in Display by adding member function called , which takes no arguments and returns the number of temperatures on the list .

Change the type TemperatureList given in Display by adding member function called , which takes one int argument that is an integer greater than or equal to and strictly less than .
The function returns value of type double , which is the temperature in that position on the list .
So , an argument of , returns the first temperature ; an argument of , it returns the second temperature , and so forth .
Assume that temperature will not be called an argument that specifies location on the list that does not currently contain temperature .

William Shakespeare , King Henry IV , Part III dynamic array can have base type that is class .
class can have member variable that is dynamic array .
You can combine the techniques you .

Chapter Friends , Overloaded Operators , and Arrays in Classes learned about classes and the techniques you learned about dynamic arrays in just about any way .
There are few more things to worry about when using classes and dynamic arrays , but the basic techniques are the ones that you have already used .
start an example .

Programming Example String Variable Class Constructors Size of string value In Chapter we showed you how to define array variables to hold strings .

In the previous section you learned how to define dynamic arrays so that the of the array can be determined when your program is run .
In this example we will define class called StringVar whose objects are string variables .
An object of the class StringVar will be implemented using dynamic array whose is determined when your program is run .
So objects of type StringVar will have all the advantages of dynamic arrays , but they will also have some additional features .
We will define member functions so that if you try to assign string that is too long to an object of type StringVar , you will get an error message .
The version we define here provides only small collection of operations for manipulating string objects .

In Programming Project you are asked to enhance the class definition by adding more member functions and overloaded operators .

Since you could use the standard class string , as discussed in Chapter , you do not really need the class StringVar , but it will be good exercise to design and code it .

The definition for the type StringVar is given in Display .
One constructor for the class StringVar takes single argument of type int .

This argument determines the maximum allowable length for string value stored in the object .
default constructor creates an object maximum allowable length of .
Another constructor takes an array argument that contains string of the kind discussed in Chapter .
Note that this means the argument to this constructor can be quoted string .
This constructor initializes the object so that it can hold any string whose length is less than or equal to the length of its argument , and it initializes the string value to copy of the value of its argument .
For the moment , ignore the constructor that is labeled Copy constructor .
Also ignore the member function named .
Although it may look like one , is not constructor .

We will discuss these two new of member functions in later subsections .

The meanings of the remaining member functions for the class StringVar are straight forward .

simple demonstration program is given in Display .
Two objects , and , are declared within the definition of the function conversation .
The object can contain any string that is or fewer characters long .
The object is initialized to the string value " and can have its value changed to any other string of length or less .

An object is declared as follows .

Sets the value of the object equal to the empty string .

; the object so it can accept string values of length less .
Sets the value of the object equal to the empty string .

char ; The array contains characters terminated with .

If there is not sufficient room , then as much as will fit is copied .

Chapter Friends , Overloaded Operators , and Arrays in Classes private : char ; to dynamic array that holds the string value .

Sample Dialogue What is your name .

Kathryn Janeway We Borg We will meet Kathryn Janeway End of demonstration Classes and Dynamic Arrays As we indicated at the beginning of this subsection , the class StringVar is implemented using dynamic array .
The implementation is shown in Display .
When an object of type StringVar is declared , constructor is called to initialize the object .
The constructor uses the new to create new dynamic array of characters for the member variable value .
The string value is stored in the array value as an ordinary string value , with ' used to mark the end of the string .
Notice that the size of this array is not determined until the object is declared , at which point the constructor is called and the argument to the constructor determines the size of the dynamic array .
As illustrated in Display , this argument can be variable of type int .
Look at the declaration of the object in the definition of the function conversation .
The argument to the constructor is the parameter .
Recall that parameter is local variable , so is variable .
Any int variable may be used as the argument to the constructor in this way .

The implementation of the member functions length , and the overloaded output all straightforward .
In the next few subsections we discuss the function and the constructor labeled Copy constructor .

They do not go away unless your program makes suitable call to delete .
Even if the dynamic variable was created using local pointer variable and the local pointer variable goes away at the end of function call , the dynamic variable will remain unless there is call to delete .
If you do not eliminate dynamic variables with calls to delete , they will continue to occupy memory space , which may cause your program to abort because it used up all the memory in the freestore .
Moreover , if the dynamic variable is embedded in the implementation of class , the programmer who uses the class does not know about the dynamic variable and cannot be expected to perform the call to delete .
In fact , since the data members normally private members , the programmer normally cannot access the needed pointer variables and so cannot call delete with these pointer variables .
To handle this problem , has special kind of member function called destructor .

destructor is member function that is called automatically when an object of the class passes out of scope .
This means that if your program contains local variable that is an object with destructor , then when the function call ends , the destructor is called automatically .
If the destructor is defined correctly , the destructor calls delete to eliminate all the dynamic variables created by the object .
This may be done with single call to delete or it may require several calls to delete .
You might also want your destructor to perform some other cleanup details as well , but returning memory to the freestore is the main job of the destructor .

VideoNote Arrays of Classes using Dynamic Arrays Chapter Friends , Overloaded Operators , and Arrays in Classes The member function is the destructor for the class StringVar shown in Display .
Like constructor , destructor always has the same name as the class it is member of , but the destructor has the tilde , at the beginning of its name you can tell that it is destructor and not .
Like constructor , destructor has no type for the value returned , not even the type void .
destructor has no parameters .
Thus , class can have only one destructor ; you cannot overload the destructor for class .

Otherwise , destructor is defined just like any other member function .

Notice the definition of the destructor given in Display .

Look at the function conversation in the sample program shown in Display .
The local variables name and both create dynamic arrays .
If this class did not have destructor , then after the call to conversation has ended , these dynamic arrays would still be occupying memory , even though they useless to the program .

This would not be problem here because the sample program ends soon after the call to conversation is completed ; but if you wrote program that made repeated calls to functions like conversation , and if the class StringVar did not have suitable destructor , then the function calls could consume all the memory in the freestore and your program would then end abnormally .

Destructor destructor is member function of class that is called automatically when an object of the class goes out of scope .
Among other things , this means that if an object of the class type is local variable for function , then the destructor is automatically called as the last action before the function call ends .
Destructors are used to eliminate any dynamic variables that have been created by the object so that the memory occupied by these dynamic variables is returned to the freestore .
Destructors may perform other cleanup tasks as well .
The name of destructor must consist of the tilde , followed by the name of the class .

Pointers as Parameters When parameter is of pointer type , its behavior can be subtle and troublesome .
Consider the function call shown in Display .
The parameter temp in the function sneaky is parameter , and hence it is local variable .
When the function is called , the of temp is set to the of the argument and the function body is executed .
Since temp is local variable , no changes to temp should go outside of the function sneaky .

In particular , the of the pointer variable should not be changed .
Yet the sample dialogue makes it look as if the of the pointer variable had changed .
Before the call to the function sneaky , the of was , and after the call to sneaky the of is .

Although the sample dialogue may make it look as if were changed , the of was not changed by the function call to sneaky .
Pointer has two things associated with it : pointer and the stored where points .
Now , the of is pointer is , memory .
After the call to sneaky , the variable contains the same pointer is , the same memory .
The call to sneaky has changed the of the variable pointed to by  but it has not changed the of itself .

If the parameter type is class or structure type that has member variables of pointer type , the same kind of surprising changes can occur with arguments of the class type .
However , for class types , you can avoid these surprise changes by defining copy constructor , as described in the next subsection .

The one parameter must be parameter , and normally the parameter is preceded by the const parameter modifier , so it is constant parameter .
In all other respects , copy constructor is defined in the same way as any other constructor and can be used just like other constructors .

Display The Function Call ;
Before call to sneaky :
Value of is plugged in for 

After call to sneaky :

Chapter Friends , Overloaded Operators , and Arrays in Classes Called when an object is declared For example , program that uses the class StringVar defined in .

The constructor used to initialize each of the three objects of type StringVar is determined by the type of the argument given in parentheses after the name .
The object line is initialized with the constructor that has parameter of type  the object motto is initialized by the constructor that has parameter of type const char .
Similarly , the object is initialized by the constructor that has one argument of type const .
When used in this way , copy constructor is being used just like any other constructor .

copy constructor should be defined so that the object being initialized becomes complete , independent copy of its argument .
So , in the declaration StringVar ; parameters Why copy constructor is needed the member variable is not simply set to the same value as line .

The definition of the copy constructor is shown in Display .
Note that in the definition of the copy constructor , new array is created and the contents of one array are copied to the other array .
Thus , in the previous declaration , is initialized so that its string value is equal to the string value of line , but has separate array .
Thus , any change that is made to has no effect on line .

As you have seen , copy constructor can be used just like any other constructor .
copy constructor is also called automatically in certain other situations .
Roughly speaking , whenever needs to make copy of an object , it automatically calls the copy constructor .
In particular , the copy constructor is called automatically in three circumstances : when class when function returns value of the class type , and whenever an argument of the class type is in " for parameter .
In this To see why you need copy constructor , see what would happen if we did not define copy constructor for the class StringVar .
Suppose we did not include the copy constructor in the definition of the class StringVar and suppose we used parameter in function definition , for .

Assuming there is no copy constructor , things proceed as follows : When the function is executed , the value of is copied to the local variable  so is set equal to .
But these are pointer variables , so during the function  and point to the same array , as follows : When the function ends , the destructor for StringVar is called to return the memory used by to the freestore .
The definition of the destructor contains the following statement : delete .

Thus , is undefined when the program reaches the statement   endl ; This statement is therefore undefined .
The statement may by chance give you the output you want , but sooner or later the fact that is undefined will produce problems .
One major problem occurs when the object is local variable in some function .
In this case the destructor will be called with when the function ends .
That destructor will be equivalent to delete .

Chapter Friends , Overloaded Operators , and Arrays in Classes But , as we just saw , the array pointed to by has already been deleted once , and now the system is trying to delete it second time .

Calling delete twice to delete the same array other variable created with produce serious system error that cause your program to crash .

Fortunately , we included copy constructor in our definition of the class StringVar , so the copy constructor is called automatically when the following function is executed : StringVar ;

If the destructor is called for and then called for  each to the destructor deletes different array .

When function returns value of class type , the copy constructor is called automatically to copy the value specified by the return statement .
If there is no copy constructor , then problems similar to what we described for value parameters will occur .

If class definition involves pointers and dynamically allocated memory using the  then you need to include copy constructor .
Classes that do not involve pointers or dynamically allocated memory do not need copy constructor .

Contrary to what you might expect , the copy constructor is not called when you set one equal to another using the assignment However , if you do not like what the default assignment does , you redefine the assignment in the way described in the subsection makes careful distinction between initialization three cases where the copy constructor is and assignment .
Initialization uses the copy constructor to create  the assignment takes an existing and modifies it so that it is an identical copy all but of the side of the assignment .

The one parameter must be parameter .
Normally , parameter is also constant parameter , that is , preceded by const parameter modifier .

The copy constructor for class is called automatically whenever function returns value of class type .
The copy constructor is also called automatically whenever an argument is in " for parameter of class type .
copy constructor also be used in same ways as other constructors .

Any class that uses pointers and should have copy constructor .

The Big Three The copy constructor , and destructor are called big three because experts say that if you need to define any of them , then you need to define all three .
If any of these is missing , compiler will create it , but it may not behave as you want .
So it pays to define them yourself .
The copy constructor and that compiler generates for you will work fine if all member variables are of predefined types such as int and double , but they may misbehave on classes that have class or pointer member variables .
For any class that uses pointers and  it is safest to define your own copy constructor , and destructor .

el est Exerc ise .
If class is named MyClass and it has constructor , what is constructor named .
If MyClass has destructor , what is destructor named .

Suppose you change definition of destructor in Display to following .
How would sample dialogue in Display change .

Chapter Friends , Overloaded Operators , and Arrays in Classes .
The following is first line of copy constructor definition for class StringVar .
The identifier StringVar occurs three times and means something slightly different each time .
What does it mean in each of three cases .

Answer these questions about destructors .

What is destructor what must name of destructor be .

When is destructor called .

What does destructor actually do .

Assignment Operator Suppose are declared as follows : VideoNote for Class StringVar ,

But this can cause problems with probably even cause problems for .

The member variable contains pointer , assignment statement sets this pointer equal to same value as .

Thus , both point to same place in memory .
If you change value in , you will therefore also change value in .
If you change value in , you will change value in .

In short , predefined assignment statement does not do what we would like an assignment statement to do with objects of type StringVar .
Using predefined version of assignment with class StringVar can only cause problems .
The way to fix this is to overload assignment so that it does what we want it to do with objects of class StringVar .

The assignment cannot be in way we have other operators , such as +
When you overload assignment  it must be member of class ; it cannot be friend of class .
To add an version of assignment to class StringVar , definition of StringVar should be changed to following : Classes Dynamic Arrays class StringVar .

Display The assignment is then used just as you always use assignment For example , consider following : In this call , is calling is argument to .

Notice that length of in on right side of assignment is checked .
If it is too long to fit in object on left side of assignment is calling , then only as many characters as will fit are copied to object receiving .
But suppose you do not want to lose any characters in copying process .
To fit in all characters , you can create  dynamic array for object on side of assignment .
You might try to redefine assignment as .

Chapter Friends , Overloaded Operators , Arrays in Classes .

So , the in is deleted the pointer .

The assignment has corrupted the object  this run of the program is probably ruined .

One way to fix this bug is to first check whether there is sufficient room in the dynamic array member of the object on the side of the assignment to delete the array only if extra space is needed .
Our final definition of the assignment does just such .

For many classes , the obvious definition overloading the assignment does not work correctly when the same object is on both sides of the assignment .
You should always check this case be careful to write your definition of the overloaded assignment so that it also works in this case .

el est Exe rc ise .

Same as part destructor .

Answers to Exercises Chapter Summary friend function of class is an ordinary function except that it has access to the private members of the class , just like the member functions do .

structure or class can have an array as member variable .

destructor is called automatically when an object of the class passes out of scope .

The main reason destructors is to return memory to the freestore so the memory can be reused .

If you define copy constructor , it will be called automatically whenever function returns of the class type whenever an argument is in " parameter of the class type .

Any class that uses pointers the have copy constructor .

However , it must be overloaded as member of the class ; it cannot be overloaded as friend .
Any class that uses pointers the overload the assignment use with that class .

Chapter Friends , Overloaded Operators , Arrays in Classes The previous Boolean expression says that is before , provided the month of is before the month of or that the months are the same the day of is before the day of .

friend function member function are alike in that they both can use any member of the class public or in their function definition .
However , friend function is defined used just like an ordinary function ; the dot is not used when you call friend function , no type qualifier is used when you define friend function .

member function , on the other hand , is called using an object name the dot .
Also , member function definition includes type qualifier consisting of the class name the scope resolution .

The modified definition of the class DayOfYear is shown below .
The part in color is .

The modified definition of the class Money is shown here .
The part in color is .

Answers to Exercises class Money .

And , of course , you can combine this enhancement with the enhancements from previous Exercises to produce one highly improved class Money .

If the user enters of , the function input will read the ' as the value of  the as the value of  the ' as the value of  the ' as the values of .
That means it will set equal to equal Answers to Exercises to so set the amount equal to value that represents plus , which is .
One way to catch this problem is to test if the value of is negative the value of be an absolute .
To do this , rewrite the error message portion as follows : if '

This code still will not give an error message for incorrect input with zero as in .
However , with the material we have learned thus far , test for this case , while certainly possible , would significantly complicate the code and make it harder to read .

If the compiler interprets input with leading as numeral , then with input data , the output be .
The output be if the compiler does not interpret data with leading as indicating base .

The only change from the version given in Display is that the modifier const is added to the function heading , so the definition is .

The member function input changes the value of its calling object , and so the compiler will issue an error message if you add the const modifier .

Similarities : Each parameter call protects the argument from change .

Differences : The makes copy of the argument , so it uses more memory than .

In the const int ; declaration , the const keyword promises the compiler that code written by the author will not change the value of .

Chapter Friends , Overloaded Operators , and Arrays in Classes In the int const ; declaration , the const keyword is promise to the compiler that code written by the author to implement function will not change anything in the calling object .

In the int ; declaration , the const keyword is promise to the compiler that code written by the class author will not change the argument plugged in for .

In function call , the arguments are given in parentheses after the function name .
With an  the arguments are given before and after the .
Also , you must use the reserved word in the declaration and in the definition of an overloaded .

The modified definition of the class Money is shown here .
The part in color is .

The modified definition of the class Money is shown here .
The part in color is have omitted some comments to save space , but all the comments shown in Display should be included in this definition .

You also must add the following definition of the well as the definition of the given in the previous : bool ,

Actually , this requirement prevents changing the effect of any on any type .

This definition simply discards any amount that is less than one cent .
For example , it converts to the integer , which represents the amount .
It is possible to define the constructor to instead do other things with any fraction of cent .

See answer .

This answer combines the answers to this and the previous Exercise .
The class definition would change to the following .

The constructor is named MyClass , the same name as the name of the class .

The destructor is named .

The dialogue would change to the following : What is your name .

Kathryn Janeway are Borg will meet again Kathryn Janeway cruel world .
The short life of this dynamic array is about to end .

cruel world .
The short life of this dynamic array is about to end .

End of demonstration Practice Programs .
The StringVar before the : is the name of the class .
The StringVar right after the : is the name of the member function .

name always begins with tilde , followed by the class name .

destructor is called when class object goes out of scope .

destructor actually does whatever the class author programs it to do .

Destructors may also do other cleanup tasks .

In the case of the assignment the copy constructor , if there are only types for data , the default copy mechanism is exactly what you want , so the default works fine .
In the case of the destructor , no dynamic memory allocation is done , so the default action is again what you want .

PrACTICE ProGRAMS Practice Programs can generally be solved with short program that directly applies the programming principles presented in this chapter .

Modify the definition of the class Money shown in Display so that all of the following are added : have each been to apply to following member function has been added to the class definition .

Chapter Friends , Overloaded Operators , Arrays in Classes .
Exercise asked you to overload the the for class Pairs .
Complete test this exercise .
Implement the default constructor the constructors with one two int parameters .

Overload binary + to add pairs according to the rule Overload analogously .

Overload on Pairs int according to the rule Write program to test all the member functions overloaded in your class definition .

Exercise asked you to overload the the for class Percent .
Complete test this exercise .
Implement the default constructor the constructor with one int parameter .
Overload the + to add subtract percents .
Also , overload the to allow multiplication of percent by an integer .

Write program to test all the member functions overloaded in your class definition .

Programming Projects Programming Projects require more than Practice Programs can usually be solved many different ways .
Visit to complete many of these Programming Projects online get instant feedback .

In Chapter we discussed vectors , which are like arrays that can grow in size .
Suppose that vectors were not defined in .
Define class called VectorDouble that is like class for vector with base type double .
Your class VectorDouble will have private member variable for array of doubles .
It will also have two member variables of type int ; one called for the size of the array of doubles ; one called count for the number of array positions currently holding values .

Programming Projects Your class should have all of the following : constructors : default constructor that creates array for elements , constructor with one int argument for the number of elements in the initial array , copy constructor .

To be equal , the values of count the count array elements must be equal , but the values of need not be equal .

Enforce suitable restrictions on the arguments to .

It can be made to work with square brackets , but we have not covered .
Define class for rational numbers .
rational number is number that can be represented as the quotient of two integers .
For example , so forth are all rational numbers .
Call the class Rational .

Include constructor with two arguments that can be used to set the member variables of an object to any legitimate values .
Also include constructor that has only single parameter of type int ; call this single parameter define the constructor so that the object will be initialized to the rational number .
Also include default constructor that initializes an object to is , to .

Overload the input output .
Numbers are to be input output in the form , so forth .
Note that the numerator , the denominator , or both may contain minus sign , so , and are also possible inputs .
Overload all of the following operators so that they correctly apply to the type  + and .
Also write test program to test your class .

Chapter Friends , Overloaded Operators , and Arrays in Classes : Two rational numbers and are equal if equals .
If and are positive rational numbers , is less than provided is less than .
You should include function to normalize the values stored so that , after normalization , the denominator is positive and the numerator and denominator are as small as possible .
For example , after normalization would be represented the same as .
You should also write test program to test .
Define class for complex numbers .
complex number is number of the form where , for our purposes , and are numbers of type double , and is number that represents the quantity .
Represent complex number as two values of type double .
Name the member variables real and imaginary .

Include constructor with two parameters of type double that can be used to set the member variables of an object to any values .
Also include constructor that has only single parameter of type double ; call this parameter and define the constructor so that the object will be initialized to .
Also include default constructor that initializes an object to is , to .
Overload all of the following operators so that they correctly apply to the type  + and .
You should write test program to test your class .

The product of two complex numbers is given by the following formula : + + + + In the interface file , you should define constant as .

Enhance the definition of the class StringVar given in Displays and .

Also write suitable test program and thoroughly test your class definition .

Define class called Text whose objects store lists of words .
The class Text will be just like class StringVar except that class Text will use dynamic array with base type StringVar rather than base type char and will mark end of array with StringVar object consisting of single blank , rather than using ' as end marker .
Intuitively , an object of class Text represents some text consisting of words separated by blanks .

Enforce restriction that array elements of type StringVar contain no blanks for end marker elements of type .

Your class Text will have member functions corresponding to all member functions of StringVar .
The constructor with an argument of type const char will initialize Text object in same way as described below for .
If argument contains symbol , that is considered an error and ends program with an error message .

The member function will read blank separated strings and store each string in one element of dynamic array with base type StringVar .
Multiple blank spaces are treated same as single blank space .
When outputting an object of class Text , insert one blank between each value of type StringVar .
You may either assume that no tab symbols are used or you can treat tab symbols same as blank ; if this is class assignment , ask your instructor how you should treat tab symbol .

Add enhancements described in Programming Project .
The overloaded version of extraction operator will fill only one element of dynamic array .

Using dynamic arrays , implement polynomial class with polynomial addition , subtraction , and multiplication .

Discussion : variable in polynomial does very little other than act as placeholder for coefficients .
Hence , only interesting thing .

Chapter Friends , Overloaded Operators , and Arrays in Classes about polynomials is array of coefficients and corresponding exponent .
Think about polynomial + + One simple way to implement polynomial class is to use an array of doubles to store coefficients .
The index of array is exponent of corresponding term .
Where is term in in previous example .
If term is missing , then it simply has zero coefficient .

There are techniques for representing polynomials of high degree with many missing terms .
These use sparse polynomial techniques .
Unless you already know these techniques , or learn very quickly , use them .

Provide default constructor , copy constructor , and parameterized constructor that enable an arbitrary polynomial to be constructed .
Also supply an overloaded and destructor .

Provide these operations : polynomial + polynomial .

Supply function to evaluate polynomial at value of type double .

You should decide whether to implement these functions as members , friends , or functions .

Write checkbook balancing program .
The program will read in following for all checks that were not cashed as of last time you balanced your checkbook : number of each check , amount of check , and whether or not it has been cashed .
Use an array with class base type .
The class should be class for check .
There should be three member variables to record check number , check amount , and whether or not check was cashed .

The class for check will have member variable of type Money defined in Display to record check amount .
So , you will have class used within Programming Projects class .
The class for check should have accessor and mutator functions as well as constructors and functions for both input and output of check .

In addition to checks , program also reads all deposits , as well as old and new .
You may want another array to hold deposits .
The new should be old plus all deposits , minus all checks that have been cashed .

The program outputs the total of the checks cashed , the total of the deposits , what the new should be , and how much this figure differs from what the bank says the new is .
It also outputs two lists of checks : the checks cashed since the last time you balanced your checkbook and the checks still not cashed .
Display both lists of checks in sorted order from lowest to highest check number .

If this is class assignment , ask your instructor if should be done with the keyboard and screen or if it should be done with files .

If it is to be done with files , ask your instructor for instructions on file names .

Define class called List that can hold list of values of type double .

Model your class definition after the class TemperatureList given in Display , but your class List will make no reference to temperatures when it outputs values .
The values may represent any sort of data items as long as they are of type double .
Include the additional features specified in Exercises and .
Change the member function names so that they do not refer to temperature .

Add member function called that takes no arguments and returns the last item on the list .
The member function does not change the list , and it should not be called if the list is empty .
Add another member function called that deletes the last element on the list .
The member function is void function .
Note that when the last element is deleted , the member variable size must be adjusted .
If is called with an empty list as the calling object , the function call has no effect .
Design program to thoroughly test your definition for the class List .

Define class called StringSet that will be used to store set of STL strings .
Use an array or vector to store the strings .
Create constructor that takes as an input parameter an array of strings for the initial values in the set .
Then write member functions to add string to the set , remove string from the set , clear the entire set , return the number of strings in the set , and output all strings in the set .
Overload the + so that it returns the union of two StringSet objects .
Also overload the so that it returns the intersection of two StringSet objects .
Write program to test all member functions and overloaded operators in your class .

Chapter Friends , Overloaded Operators , and Arrays in Classes .
This programming project requires you to complete Programming Project first .

The field of information retrieval is concerned with finding relevant electronic documents based upon query .
For example , given group of and displays them sorted by relevance to the query .
This technology requires way to compare document with the query to see which is most relevant to the query .

simple way to make this comparison is to compute the binary cosine coefficient .
The coefficient is value between and , where indicates that the query is very similar to the document and indicates that the query has no keywords in common with the document .
This approach treats each document as set of words .
For example , given the following sample document : This document would be parsed into keywords where case is ignored and punctuation discarded and turned into the set containing the words , ice , cream , milk , and , bars , are ,
An identical process is performed on the query to turn it into set of strings .
Once we have query represented as set of words and document represented as set of words , the similarity between and is computed by : Modify the StringSet from Programming Project by adding an additional member function that computes the similarity between the current StringSet and an input parameter of type StringSet .
The sqrt function is in the cmath library .

Create two text files on your disk named and .

Write some text content of your choice in each file , but make sure that each file contains different content .
Next , write program that allows the user to input from the keyboard set of strings that represents query .
The program should then compare the query to both text files on the disk and output the similarity to each one using the binary cosine coefficient .
Test your program with different queries to see if the similarity metric is working correctly .

The class should have public member functions addEntry and deleteEntry .
Make the array and size variables private .
This will require Programming Projects dding functions for getting and setting specific items in the array as well as returning the current size of the array .
Add destructor that frees up the memory allocated to the dynamic array .
Also , add copy constructor and overload the assignment operator so that the dynamic array is properly copied from the object on the side of the assignment to the object on the side .
Embed your class in suitable test program .

To combat election fraud , your city is instituting new procedure .

The ballot has letter associated with every selection voter may make .

sample ballot is shown .

VOTE FOR MAYOR .
Pincher , Penny .
Dover , Skip .
Perman , Sue .
PROPOSITION .
MEASURE .
MEASURE .

NO After submitting the ballot , every voter receives receipt that has unique ID number and record of the selections .
For example , voter who submits ballot for Sue Perman , Yes on Proposition , No on Measure , and Yes on Measure might receive receipt with ID  CDGH The next day the city posts all votes on its Web page sorted by ID number .

This allows voter to confirm their submission and allows anyone to count the vote totals for themselves .
sample list for the sample ballot is shown .

ADFH VideoNote Solution to Programming Project Chapter Friends , Overloaded Operators , and Arrays in Classes Write program that reads the posted list from file and outputs the percent of votes cast for each ballot item .
You may assume that the file does not have any header lines .
The first line will contain voter ID and string representing votes .
Define class named Voter that stores an record .
The class should have constructor that takes as input string of votes example , voter ID , and accessor that return the ID and vote for specific question .

Store each Voter instance in an array or vector .
Your program should iterate over the array to compute and output the percent of votes cast for each candidate , proposition , and measure .
It should then prompt the user to enter voter ID , iterate over the list again to find the object with that ID , and print his or her votes .

All changes should be internal to the class so the main function to test the class should run identically with either the old class or the new class that uses an array member variable .

Next , modify the main function so that instead of creating separate variables for each object , an array of at least four objects is created with sample data .
Loop through the array and output the name , MPAA rating , and average rating for each of the four movies .

Do Programming Project from Chapter except use Racer class to store information about each race participant .
The class should store the name , bib number , finishing position , and all of his or her split times as recorded by the RFID sensors .
You can choose appropriate structures to store this information .
Include appropriate functions to access or change the information , along with constructor .
Make an array or vector of Racer objects to store the entire race results .

The name should come from separate text file .
The information for this file is collected before the race when the participant registers for the event .
Listed below is sample file : Rodgers Shorter Benoit Separate Compilation and Namespaces Separate Compilation ADTs Reviewed Case Study : Class Compiled Separately Using Programming Tip : Defining Other Libraries Namespaces Namespaces and using Directives Creating Namespace Chapter Summary Answers to Exercises Qualifying Names Subtle Point About Namespaces Unnamed Namespaces Programming Tip : Choosing Name for Namespace Pitfall : Confusing the Global Namespace and the Unnamed Namespace Practice Programs Programming Projects From mine own library with volumes that prize above my dukedom .

William Shakespeare , The Tempest Introduction This chapter covers two topics that have to do with how you organize program into separate parts .
Section on separate compilation discusses how program can be distributed across number of files so that when some parts of the program change , only those parts need to be recompiled .

The separate parts can also be more easily reused in other applications .

Section discusses namespaces , which we introduced briefly in Chapter .
Namespaces are way of allowing you to reuse the names of classes , functions , and other items by qualifying the names to indicate different uses .

Namespaces divide your code into sections so that the different sections may reuse the same names with differing meanings .
Namespaces allow kind of local meaning for names that is more general than local variables .

Prerequisites This chapter uses material from Chapters through and through .

You can place the definition for class its associated function in files that are separate from the programs that use the class .
That way you can build up library of classes so that many programs can use the same class .
You can compile the class once and then use it in many different programs , just like you use the predefined libraries as those with header files iostream and .
Moreover , you can define the class itself in two files so that the specification of what the class does is separate from how the class is implemented .
If your class is defined following the guidelines we have been giving you and you change only the implementation of the class , then you need only recompile the file with the class implementation .
The other files , including the files with the programs that use the class , need not be changed or even recompiled .
In this section , we tell you how to carry out this separate compilation of classes .

All your class definitions should be ADTs .
In order to define class so that it is an ADT , you need to separate the specification of how the class is used by programmer from the details of how the class is implemented .
The separation should be so complete that you can change the implementation without needing to change any program that uses the class in any way .
The way to ensure this separation can be summarized in three rules :
Make all the member variables private members of the class .

Make each of the basic operations for the ADT either public member function of the class , friend function , an ordinary function , or an overloaded operator .
Group the class definition and the function and operator declarations together .
This group , along with its accompanying comments , is called the interface for the ADT .
Fully specify how to use each such function or operator in comment given with the class or with the function or operator declaration .

Make the implementation of the basic operations unavailable to the programmer who uses the abstract data type .
The implementation consists of the function definitions and overloaded operator definitions with any helping functions or other additional items these definitions .

In , the best way to ensure that you follow these rules is to place the interface and the implementation of the ADT class in separate files .
As you might guess , the file that contains the interface is often called the interface file , and the file that contains the implementation is called the implementation file .
The exact details of how to set up , compile , and use these files will vary slightly from one version of to another , but the basic scheme is the same in all versions of .
In particular , the details of what goes into the files are the same in all systems .
The only things that vary are what commands you use to compile and link these files .
The details about what goes into these files are illustrated in the next Case Study .

An ADT class has private member variables .
Private member variables private member present problem to our basic philosophy of placing the interface and the implementation of an ADT in separate files .

The public part of the class definition for an ADT is part of the interface for the ADT , but the private part is part of the implementation .
This is problem because will not allow you to split the class definition across two files .

Thus , some sort of compromise is needed .
The only sensible compromise , and the one we use , is to place the entire class definition in the interface file .

Since programmer who is using the ADT class cannot use any of the private members of the class , the private members will , in effect , still be hidden from the programmer .

Private members are part of the implementation .

All the classes that you define should be ADTs .
An ADT class is class that is defined following good programming practices that separate the interface and implementation of the class .

DigitalTime is class whose values are times of day , such as .
Only the public members of the class are part of the interface .
The private members are part of the implementation , even though they are in the interface file .

The label private : warns you that these private members are not part of the public interface .
Everything that programmer needs to know in order to use the ADT DigitalTime is explained in the comment at the start of the file and in the comments in the public section of the class definition .
This interface tells the programmer how to use the two versions of the member function named advance , the constructors , and the overloaded , and .
The member function named advance , the overloaded  and the assignment statement are the only ways that programmer can manipulate objects and values of this class .
As noted in the comment at the top of the interface file , this ADT class uses notation , so , for instance , PM is input and output as .
This and the other details you must know in order to effectively use the class DigitalTime are included in the comments given with the member functions .

We have placed the interface in file named suffix indicates that this is header file .
An interface file is always header file and therefore always ends with the suffix .
Any program that uses the class DigitalTime must contain an include directive like the following , which names this file : When you write an include directive , you must indicate whether the header file is predefined header file that is provided for you or is header file that you wrote .
If the header file is predefined , write the header file name in angular brackets , like .
If the header file is one that you wrote , then write the header file name in quotes , like .
This distinction tells the compiler where to look for the header file .
If the header file name is Separate Compilation Display Interface File for DigitalTime file : This is the INTERFACE for the class DigitalTime .

The values are input and output in .

If the header file name is in quotes , the compiler looks in the current directory or wherever header files are kept on your system .

Any program that uses our DigitalTime class must contain the previous directive that names the header file .
That is enough to Chapter Separate Compilation Namespaces allow you to compile the program but is not enough to allow you to run the program .
In order to run the program , you must write the definitions of the member functions the overloaded .
We have placed these function definitions in another file , which is called the implementation file .
Although it is not required by most compilers , it is traditional to give the interface file the implementation file the same name .
The two files do , however , end in different suffixes .
We have placed the interface for our ADT class in the file named the implementation for our ADT class in file named .
The suffix you use for the implementation file depends on your version of .
Use the same suffix for the implementation file as you normally use for files that contain programs .
If your program files end in , then you would use in place of .
If your program files end in , then your implementation files will end in instead of .
We are using since most compilers accept as the suffix for source code file .
The implementation file for our DigitalTime ADT class is given in Display .
After we explain how the various files for our ADT interact with each other , we will return to Display discuss the details of the definitions in this implementation file .

In order to use the ADT class DigitalTime in program , the program must contain the directive Compiling running the program Notice that both the implementation file the program file must contain this directive that names the interface file .
The file that contains the program is , the file that contains the main part of the is often called the application file or driver file .
Display contains an application file with very simple program that uses demonstrates the DigitalTime ADT class .

The exact details on how you run this complete program , which is contained in three files , depend on what system you are using .
However , the basic details are the same for all systems .
You must compile the implementation file , you must compile the application file that contains the main part of your program .
You do not compile the interface file , which in this example is the file given in Display .
You do not need to compile the interface file because the compiler thinks the contents of this interface file are already contained in each of the other two files .
Recall that both the implementation file the application file contain the directive Compiling your program automatically invokes preprocessor that reads this directive replaces it with the text in the file .
Thus , the compiler sees the contents of , so the file does not need to be compiled separately .

Chapter Separate Compilation and Namespaces .

Chapter Separate Compilation and Namespaces Display Application File Using DigitalTime file system may require some suffix .

Sample Dialogue Enter the time in notation : You minutes later the time will be hours and minutes after that the time will be only conceptual copying .
The compiler acts as if the contents of were copied into each file that has the directive .
However , if you look in that file after it is compiled , you will only find the directive ; you will not find the contents of the file .

Once the implementation file and the application file are compiled , you still need to connect these files so that they can work together .
This is called Separate Compilation linking the files and is done by separate utility called linker .
The details for how you call the linker depend on what system you are using .
After the files are linked , you can run your program .
On any system , the details quickly become routine .

Displays , and contain one complete program divided into pieces and placed in three different files .
You could instead combine the contents of these three files into one file and then compile and run this one file without all this fuss about directives and linking separate files .

Why bother with three separate files .
There are several advantages to dividing your program into separate files .
Since you have the definition and the implementation of the class DigitalTime in files separate from the application file , you can use this class in many different programs without needing to rewrite the definition of the class in each of the programs .
Moreover , you need to compile the implementation file only once , no matter how many programs use the class DigitalTime .

Since you have separated the interface from the implementation of your DigitalTime ADT class , you can change the implementation file and will not need to change any program that uses the ADT .
In fact , you will not even need to recompile the program .
If you change the implementation file , you only need to recompile the implementation file and to relink the files .
Saving bit of recompiling time is nice , but the big advantage is not having to rewrite code .

You can use the ADT class many programs without writing the class code into each program .
You can change the implementation of the ADT class and you need not rewrite any part of any program that uses the class .

Defining Class Separate Files : Summary You can define class and place the definition of the class and the implementation of its member functions separate files .
You can then compile the class separately from any program that uses the class , and you can use this same class any number of different programs .
The class and the program that uses the class are placed three files as follows :
Put the definition of the class header file called the interface file .

The name of this header file ends .
The interface file also contains the declarations for any functions and overloaded operators that define basic operations for the class but that are not listed the class definition .
Include comments that explain how all these functions and operators are used .

Why separate files .

Chapter Separate Compilation and Namespaces .
The definitions of all the functions and overloaded operators mentioned step they are members or friends or are placed another file called the implementation file .
This file must contain an directive that names the interface file described above .
This directive uses quotes around the file name , as the following example : The interface file and the implementation file traditionally have the same name , but end different suffixes .
The interface file ends .
The implementation file ends the same suffix that you use for files that contain complete program .
The implementation file is compiled separately before it is used any program .

When you want to use the class program , place the main part of the program any additional function definitions , constant declarations , and so another file called an application file .
This file also must contain an directive naming the interface file , as the following example : The application file is compiled separately from the implementation file .
You can write any number of these application files to use with one pair of interface and implementation files .
To run an entire program , you must first link the object code that is produced by compiling the application file and the object code that is produced by compiling the implementation file .
Most of the implementation details are straightforward , but there are two things that merit comment .
Notice that the member function name advance is overloaded so that it has two function definitions .
Also notice that the definition for the overloaded extraction operator uses two functions " called and and these two helping functions themselves use third helping function called .
discuss these points .

The class DigitalTime and has two member functions called advance .
One version takes single argument , which is an integer giving the number of minutes to advance the time .
The other version takes two arguments , one for number of hours and one for number of minutes , and advances the time by that number of hours plus that number of minutes .
Notice that the definition of the version of advance includes call to the version of advance .
Look at the definition of the version that is given Display .
First the time is Separate Compilation advanced by hours , and then the version of advance is used to advance the time by an additional minutes .

At first this may seem strange , but it is perfectly legal .
The two functions named advance are two different functions that , as far as the compiler is concerned , coincidentally happen to have the same name .
The situation is no different this regard than it would be if one of the two versions of the overloaded function advance had been called .

Now discuss the helping functions .
The helping functions and read the input one character at time and then convert the input to integer values that are placed the member variables hour and minute .
The functions and read the hour and minute one digit at time , so they are reading values of type char .
This is more complicated than reading the input as int values , but it allows us to perform error checking to see whether the input is correctly formed and to issue an error message if the input is not well formed .
These helping functions hour and use another helping function named , which is the same as the function we used our definition of the class Money Displays .
The function converts digit , such as , to number , such as .

Reusable Components An ADT class developed and coded into separate files is software component that can be used again and again number of different programs .
Reusability , such as the reusability of these ADT classes , is an important goal to strive for when designing software components .

reusable component saves effort because it does not need to be redesigned , recoded , and retested for every application .
reusable component is also likely to be more reliable than component that is used only two reasons .
First , you can afford to spend more time and effort on component if it will be used many times .
Second , if the component is used again and again , it is tested again and again .

Every use of software component is test of that component .
Using software component many times variety of contexts is one of the best ways to discover any remaining bugs the software .

Using We have given you method for placing program three files : two for the interface and implementation of class , and one for the application part of the program .
program can be kept in more than three files .
For example , program might use several classes , and each class might be kept in separate pair of files .

VideoNote Avoiding Multiple Definitions .

Chapter Separate Compilation and Namespaces .

This can easily lead to situation in which file , in effect , contains the definitions in more than once .
does not allow you to define class more than once , even if the repeated definitions are identical .
Moreover , if you are using the same header file in many different projects , it becomes close to impossible to keep track of whether you included the class definition more than once .
To avoid this problem , provides way of marking section of code to say you have already included this stuff once before , do not include it " The way this is done is quite intuitive , although the notation may look bit weird until you get used to it .
We will go through an example , explaining the details as we go .

The following directive " What this means is that the preprocessor puts on list to indicate that has been seen .
Defines is perhaps not the best word for this , since is not defined to mean anything but is merely put on list .
The important point is that you can use another directive to test whether or not has been defined and so test whether or not section of code has already been processed .
You can use any identifier in place of , but you will see that there are standard conventions for which identifier you should use .

The following directive tests to see whether or not has been defined : If has already been defined , then everything between this directive and the first occurrence of the following directive is skipped : equivalent way to state this , which may clarify the way the directives are spelled , is the following : If is not defined , then the compiler processes everything up to the next .

This may lead you to wonder whether there is directive as well as directive .
There is , and it has the obvious meaning , but we will have no occasion to use .

Now consider the following code : class Separate Compilation .

When the include directive is processed this second time , the directive says to skip everything up to and so the class is not defined again .

In Display we have rewritten the header file shown in Display , but this time we used these directives to prevent multiple definitions .

With the version of shown in Display , if file contains the following include directive more than once , the class DigitalTime will still be defined only once : Display Avoiding Multiple Definitions of Class file : This is the INTERFACE for the class DigitalTime .

The values are input and output in notation , as in for AM and for PM .

Chapter Separate Compilation and Namespaces You may use some other identifier in place of , but the normal convention is to use the name of the file written in all uppercase letters with the underscore used in place of the period .
You should follow this convention so that others can more easily read your code and so that you do not have to remember the flag name .
This way the flag name is determined automatically and there is nothing arbitrary to remember .

These same directives can be used to skip over code in files other than header files , but we will not have occasion to use these directives except in header files .

If you have collection of related functions that you want to make into library of your own design , you can place the function declarations and accompanying comments in header file and the function definitions in an implementation file , just as we outlined for ADT classes .
After that , you can use this library in your programs the same way you would use class that you placed in separate files .

Suppose that you are defining an ADT class and that you then use this class in program .
You want to separate the class and program parts into separate files as described in this chapter .
Specify whether each of the following should be placed in the interface file , implementation file , or application file :
The class definition declaration for function that is to serve as an ADT operation , but that is neither member nor friend of the class declaration for an overloaded operator that is to serve as an ADT operation , but that is neither member nor friend of the class definition for function that is to serve as an ADT operation , but that is neither member nor friend of the class definition for friend function that is to serve as an ADT operation .
The definition for member function definition for an overloaded operator that is to serve as an ADT operation , but that is neither member nor friend of the class definition for an overloaded operator that is to serve as an ADT operation and that is friend of the class .
The main part of your program Namespaces .
Which of the following files has name that ends in : the interface file for class , the implementation file for the class , or the application file that uses the class .

When you define class in separate files , there is an interface file and an file .
Which of these files needs to be compiled .

Suppose you define class in separate files and use the class in program .

Now suppose you change the class file .
Which of the following files , if any , need to be recompiled : the interface file , the file , or the application file .

Suppose you want to change the of the class DigitalTime given in Displays and .
Specifically , you want to change the way the time is recorded .
Instead of using the two private variables hour and minute , you want to use single int variable , which will be called minutes .
In this new  the private variable minutes will record the time as the number of minutes since the time is , since .
So is recorded as minutes , since it is minutes past midnight .
Describe how you need to change the interface and files shown in Displays and .
You need not write out the files in their entirety ; just indicate what items you need to change and how , in very general way , you would change them .

What is the difference between an ADT you define in and class you define in .

That which we call rose By any other name would smell as sweet .

William Shakespeare , Romeo and Juliet When program uses different classes and functions written by different programmers , there is possibility that two programmers will use the same name for two different things .
Namespaces are way to deal with this problem .

namespace is collection of name definitions , such as class definitions and variable declarations .

Namespaces and using Directives We have already been using the namespace that is named std .
The std namespace contains all the names defined in the standard library files .

Chapter Separate Compilation and Namespaces .

Your program does not know about names in the std namespace unless you specify that it is using the std namespace .
So far , the only way we know how to specify the std namespace any is with the following sort of using directive : using namespace std ; good way to see why you might want to this using directive is to think about why you might want to not it .
If you do not this using directive for the namespace std , then you can define cin and cout to have some meaning other than their standard meaning .

Every bit of code you write is in some namespace .
If you do not place the code in some specific namespace , then the code is in namespace known as the global namespace .
So far , we have not placed any code we wrote in any namespace , so all of our code has been in the global namespace .
The global namespace does not have using directive because you are always using the global namespace .
You could say that there is always an implicit automatic using directive that says you are using the global namespace .

Note that you can be using more than one namespace at the same time .
For example , we are always using the global namespace and we are usually using the std namespace .
What happens if name is defined in two namespaces and you are using both namespaces .
This results in an error compiler error or error , depending on the exact .

You can have the same name defined in two different namespaces , but if that is true , then you can only use one of those namespaces at However , this does not mean you cannot use the two namespaces in the same program .

You can use them each at different times in the same program .

For example , suppose and are two namespaces , and suppose is void function with no arguments that is defined in both namespaces but defined in different ways in the two namespaces .
The following is then legal : As you will see later in this chapter , there are ways to use two namespaces at the same time even if they contain the same name , but that is subtle point that does not yet concern us .

The first invocation would use the definition of given in the namespace , and the second invocation would use the definition of function given in the namespace .

Recall that block is list of statements , declarations , and possibly other code , enclosed in braces .
using directive at the start of block applies only to that block .
So the first using directive applies only in the first block , and the second using directive applies only in the second block .
The usual way of phrasing this is to say that the scope of the namespace is the first block , while the scope of the namespace is the second block .
Note that because of this scope rule , we are able to use two conflicting namespaces in the same program as in program that contains the two blocks we discussed in the previous .

When you use using directive in block , it is typically the block consisting of the body of function definition .
If you place using directive at the start of file we have usually done so , then the using directive applies to the entire file .
using directive should normally be placed near the start of file or the start of block .

Scope Rule for using Directives The scope of using directive is the block in which it appears precisely , from the location of the using directives to the end of the .
If the using directive is outside of all blocks , then it applies to all of the file that follows the using directive .

Creating Namespace In order to place some code in namespace , you simply place it in namespace grouping of the following form : namespace .

When you one of these groupings in your code , you are said to place .

Chapter Separate Compilation and Namespaces .

If you look again at Display , you see that the definition of the function greeting is also placed in namespace .
That is done with the following additional namespace grouping : namespace .

Note that you can have any number of these namespace groupings for single namespace .
In Display , we used two namespace groupings for namespace and two other groupings for namespace .

Every name defined in namespace is available inside the namespace grouping , but the names can be also be made available to code outside of the namespace .
That function declaration and function definition in the namespace can be made available with the using directive : using namespace as illustrated in Display .

Names in this block use definitions in namespaces , std , and the global namespace .

Names in this block use definitions in namespaces , std , and the global namespace .

Names out here use only definitions in namespace std and the global namespace .

Sample Dialogue Greetings from namespace .

Hello from namespace .

Big Global Hello .

Chapter Separate Compilation and Namespaces Sel es Exe cis .
Consider the program shown in Display .
Could we use the name greeting in place of .

In Exercise , we saw that you could not add definition for the following function the global : void .

Can namespace have more than one namespace grouping .

Qualifying Names Suppose you are faced with the following situation : You have two namespaces , and .
You want to use the function defined in and the function defined in namespace .
The complication is that both and define function .

What you need is way to say you are using in namespace and in namespace and nothing else in the namespaces and .
The following are called using declarations , and they are your answer : using ; using .

Note that you have seen the scope resolution operator , before .
For example , in Display we had the following function .

In this case the : means that we are defining the function advance for the class DigitalTime , as opposed to any other function named advance in any other class .
Similarly , using ; means we are using the function named as defined in the namespace , as opposed to any other definition of in any other namespace .

Now suppose that you intend to use the name as defined in the namespace , but you intend to use it only one time small number of .
You can then name the function other using the name of the namespace and the scope resolution operator as in the following : This form is often used when specifying parameter type .

In the function , the parameter is of type istream , where istream is defined as in the std namespace .
If this use of the type name istream is the only name you need from the std namespace if all the names you need are similarly qualified with , then you do not need using namespace .

The differences are as follows : using declaration using makes only one name in the namespace available to your code , while using directive using namespace makes all the names in namespace available .

However , using directive only potentially introduces the names in the namespace .

Point is pretty obvious .
Point has some subtleties .
For example , suppose the namespaces and both provide definitions for but have no other name conflicts .
Then the following will produce no problems :

Sel es Exe cis .
Write the function declaration for void function named wow .
The function wow has two parameters , the first of type speed as defined in the speedway namespace and the second of type speed as defined in the namespace .

Consider the following function declarations from the definition of the class Money in Display .

Unnamed Namespaces Our definition of the class DigitalTime in Displays and used three helping functions : and .
These helping functions are part of the implementation for the ADT class DigitalTime , so we placed their definitions in the implementation file .
However , this does not really hide these three functions .
We would like these functions to be local to the implementation file for the class DigitalTime .

In particular , we cannot define another function with the name or in an application program that uses the class DigitalTime .

This violates the principle of information hiding .
To truly hide these helping functions and make them local to the implementation file for DigitalTime , we need to place them in special namespace called the unnamed namespace .

Every compilation unit has an unnamed namespace .
namespace grouping for the unnamed namespace is written in the same way as any other namespace , but no name is given , as in the following example : namespace .

For example , Displays and show rewritten our version of the interface and implementation file for the class DigitalTime .
Note that the helping functions , minute , and are all the unnamed namespace and therefore are local to the compilation unit .
As illustrated Display , the names the unnamed namespace can be reused for something else outside the compilation unit .
In Display the function name is reused for another different function the application program .

Display Placing Class File file : This is the interface for the class DigitalTime .

The values are input and output notation , as for AM and for PM .

Another grouping for the namespace dtimesavitch is the implementation file .

Chapter Separate Compilation and Namespaces file system may require some .

If you look again at the implementation file Display , you will see that the helping functions , and are used outside the unnamed namespace without any namespace qualifier .
Any name defined the unnamed namespace can be used without qualification anywhere the compilation unit .

There is one unnamed namespace each compilation unit .
It is easily possible for compilation units to overlap .
For example , both the implementation file for class and an application program using the class would normally the header file for the class .
Thus , the header file is two compilation units and hence participates two unnamed namespaces .
As dangerous as this sounds , it will normally produce no problems as long as each compilation namespace makes sense when considered by itself .

For example , if name is defined the unnamed namespace the header file , it cannot be defined again the unnamed namespace either the implementation file or the application file .
So , name conflict is avoided .

This is different function than the one the implementation file Display .

pretend the hour has just changed .

You may write midnight as either or , but will always write it as .

Enter the hour as number to : You minutes later the time will be hours and minutes after that the time will be Programming Tip Choosing Name for Namespace It is good idea to your last name or some other unique string the names of your namespaces so as to reduce the chance that somebody else will use the same namespace name as you do .
With multiple programmers writing code for the same project , it is important that namespaces that are meant to be distinct really do have distinct names .
Otherwise , you can easily have multiple definitions of the same names the same scope .
That is why we included the name savitch the namespace dtimesavitch Display .

Each compilation unit has one unnamed namespace .
All the identifiers defined the unnamed namespace are local to the compilation unit .
You place definition the unnamed namespace by placing it namespace grouping with no namespace name , as shown the following : namespace .

You can use any name the unnamed namespace without qualifier anyplace .

Pitfall onfusing the Global Namespace and the Unnamed Namespace Do not confuse the global namespace with the unnamed namespace .
If you do not put name definition namespace grouping , then it is the global namespace .
To put name definition the unnamed namespace , you must put it namespace grouping that starts as follows , without name : namespace Both names the global namespace and names the unnamed namespace may be accessed without qualifier .
However , names the global namespace have global scope the program , while names an unnamed namespace are local to compilation unit .

This confusion between the global namespace and the unnamed namespace does not arise very much writing code , since there is tendency to think of names the global namespace as being  no " even though that is not technically correct .
However , the confusion can easily arise when discussing code .

Would the program Display behave any differently if you replaced the using directive using namespace .

In Display there are two groupings for the unnamed namespace : one for the helping function declarations and one for the helping function definitions .
Can we eliminate the grouping for the helping function declarations .

Chapter Summary In , abstract data types are implemented as classes with all member variables private and with the operations implemented as public member and nonmember functions and overloaded operators .

You can then compile the ADT class separately from any program that uses it and you can use this same ADT class any number of different programs .

Chapter Separate Compilation and Namespaces Answe rs to Self est Exer cises Parts , and go in the interface file ; parts through go in the implementation file .

The name of the interface file ends in .

Only the implementation file needs to be compiled .
The interface file does not need to be compiled .

Only the implementation file needs to be recompiled .
You do , however , need to relink the files .

You need to delete the private member variables hour and minute from the interface file shown in Display and replace them with the member variable minutes an .
You do not need to make any other changes in the interface file .
In the implementation file , you need to change the definitions of all the constructors and other member functions , as well as the definitions of the overloaded operators , so that they work for this new way of recording time .

You need not change any application files for programs that use the class .

However , since the interface file is changed well as the implementation , you will need to recompile any application files , and of course you will need to recompile the implementation file .

The short answer is that an ADT is simply class that you defined following good programming practices of separating the interface from the implementation .
Also , when we describe class as an ADT , we consider the nonmember basic operations such as overloaded operators to be part of the ADT , even though they are not technically speaking part of the class .

Answers to Exercises .
If you replace with greeting , then you will have definition for the name greeting in the global namespace .
There are parts of the program where all the name definitions in the namespace and all the name definitions in the global namespace are simultaneously available .
In those parts of the program , there would be two distinct definitions for void ;
Yes , the additional definition would cause no problems .
This is because overloading is always allowed .
When , for example , the namespaces and the global namespace are available , the function name greeting would be overloaded .
The problem in Exercise was that there would sometimes be two definitions of the function name greeting with the same parameter lists .

Yes , namespace can have any number of groupings .
For example , the following are two groupings for the namespace that appear in Display : namespace .

The program would behave exactly the same .

Hello from unnamed .
Hello from Sally .
Hello from unnamed .

Yes , you can eliminate the grouping for the helping function declarations , as long as the grouping with the helping function definitions occurs before the helping functions are used .
For example , you could remove the namespace with the helping function declarations and move the grouping with the helping function definitions to just before the namespace grouping for the namespace dtimesavitch .

Chapter Separate Compilation and Namespaces PrACTICE ProGRAMS Practice Programs can generally be solved with short program that directly applies the programming principles presented in this chapter .

One of the values of type DigitalTime is the object that calls the member function , and the other value of type DigitalTime is given as the first argument .
For example , consider the following code : DigitalTime , int hours ,  hours ,

Allow the time given by the first argument to be later in the day than the time of the calling object .
In this case , the time given as the first argument is assumed to be on the previous day .
You should also write program to test this revised ADT class .

Do Exercise in full detail .
Write out the complete ADT class , including interface and implementation files .
Also write program to test your ADT class .

VideoNote Solution to Practice Program Redo Practice Programs from Chapter , but this time define the Money ADT class in separate files for the interface and implementation so that the implementation can be compiled separately from any application .

Practice Programs .
This Practice Program explores how the unnamed namespace works .

Listed below are snippets from program to perform input validation for username and password .
The code to input and validate the username is in file separate from the code to input and validate the password .

File : namespace Authenticate .

Define the username variable and the function in the unnamed namespace so the code will compile .
The function should return true if username contains exactly eight letters .
Generate an appropriate header file for this code .

Repeat the same steps for the file , placing the password variable and the function in the unnamed namespace .
In this case , the function should return true if the input password has at least eight characters including at least one  File : namespace Authenticate .

Chapter Separate Compilation and Namespaces At this point you should have two functions named , each in different unnamed namespaces .
Place the following main function in an .

Test the program with several invalid usernames and passwords .

Programming Projects Programming Projects require more than Practice Programs and can usually be solved many different ways .
Visit to complete many of these Programming Projects online and get instant feedback .

Define your ADT class in separate files so that it can be compiled separately .

Define your ADT class in separate files so that it can be compiled separately .

Define your ADT class in separate files so that it can be compiled separately .
Put the main function in its own file separate from the ADT files .

Pointers and Linked Lists Nodes and Linked Lists Nodes nullptr Linked Lists Inserting Node at the Head of List Pitfall : Losing Nodes Searching Linked List Pointers as Iterators Inserting and Removing Nodes Inside List Pitfall : Using the Assignment Operator with Dynamic Data Structures Variations on Linked Lists Linked Lists of Classes Chapter Summary Answers to Exercises Practice Programs Programming Projects Stacks and Queues Stacks Programming Examples : Stack Queues Programming Examples : Queue If somebody there chanced to be Who loved me in manner true My heart would point him out to me And would point him out to you .

Gilbert and Sullivan , Ruddigore Introduction linked list list constructed using pointers .
linked list not fixed in size , but can grow and shrink while your program running .
This chapter shows you how to define and manipulate linked lists , which will serve to introduce you to new of using pointers .

Prerequisites This chapter uses material from Chapters through .

You saw that dynamic variables of an array type can be useful .
Dynamic variables of struct or class type can also be useful , but in different .

Dynamic variables that are either structs or classes normally have one or more member variables that are pointer variables which connect them to other dynamic variables .
For example , one such structure , which happens to contain shopping list , diagrammed in Display .

Nodes structure like the one shown in Display consists of items that we have drawn as boxes connected by arrows .
The boxes are called nodes and the arrows represent pointers .
Each of the nodes in Display contains string , an integer , and pointer that can point to other nodes of the same type .
Note that pointers point to the entire node , not to the individual items as or that are inside the node .

Nodes are implemented in as structs or classes .
For example , the struct type definitions for node of the type shown in Display , along with the type definition for pointer to such nodes , can be as follows : struct ListNode .

The order of the type definitions important .
The definition of ListNode must come first , since it used in the definition of ListNodePtr .

The box labeled head in Display not node , but pointer variable that can point to node .
The pointer variable head declared as follows : ListNodePtr head ; Even though we have ordered the type definitions to avoid some illegal forms of circularity , the definition of the struct type ListNode still blatantly circular .
The definition uses the type name ListNode to define the member variable link .
There nothing wrong with this particular circularity , and it allowed in .
One indication that this definition not logically inconsistent the fact that you can draw pictures , like Display , that represent such structures .

We now have pointers inside of structs and have these pointers pointing to structs that contain pointers , and so forth .
In such situations the syntax can sometimes get involved , but in all cases the syntax follows those few rules we have described for pointers and structs .
As an illustration , suppose the declarations are as above , the situation is as .

Chapter Pointers and Linked Lists diagrammed in Display , and you want to change the number in the first node from to .
One to accomplish this is with the following statement :
The variable head is pointer variable .
So , the expression containing " and the integer .
This node , referred to by , is struct , and the member variable of this struct , which contains value of type int , is called  and so .
The parentheses around are not optional .
You want the dereferencing operator to be performed before the dot operator .
However , the dot operator has higher precedence than the dereferencing operator , and so without the parentheses , the dot operator would be performed first that would produce an .
In the next paragraph , we will describe shortcut notation that can avoid this worry about parentheses .

has an operator that can be used with pointer to simplify the notation for specifying the members of struct or class .
The arrow operator arrow_operator combines the actions of dereferencing operator and dot operator to specify member of dynamic struct or object that is pointed to by given pointer .
For example , the assignment statement above for changing the number in the first node can be written more simply as ; This assignment statement and the previous one mean the same thing , but this one is the form normally used .

Look at the pointer member in the last node in the lists shown in Display .
This last node has the word NULL written where there should be pointer .
In Display we filled this position with the phrase " but marker " is not expression .
In programs we use the constant NULL as an end marker to signal the end of linked list .
NULL is special defined constant that is part of the language as part of the required .

NULL is typically used for two different often purposes .

It is used to give value to pointer variable that otherwise would not have any value .
This prevents an inadvertent reference to memory , since NULL is not Nodes and Linked Lists .

NULL the address of any memory location .
The second category of use is that of an end marker .
program can step through the list of nodes as shown in Display , and when the program reaches the node that contains NULL , it knows that it has come to the end of the list .

The constant NULL is actually the number , but we prefer to think of it and spell it as NULL .
That makes it clear that you mean this specialpurpose value that you can assign to pointer variables .
The definition of the identifier NULL is in number of the standard libraries , such as and , so you should use an include directive with either or other suitable when you use NULL .
No using directive is needed in order to make NULL available to your program code .
In particular , it does not require using namespace , although other things in your code are likely to require something like using namespace The details are as follows : The definition of NULL is handled by the preprocessor , which replaces NULL with .
Thus , the compiler never actually sees " and so there are no namespace issues , and no using directive is needed .

Chapter Pointers and Linked Lists The Arrow Operator arrow_operator The arrow operator arrow_operator specifies member of struct member of class that is pointed to by pointer variable .
The syntax is as follows : The above refers to member of the struct or object pointed to by the .
Which member it refers to is given by the .

For example , suppose you have the following .

NULL : double NULL ; The constant NULL can be assigned to pointer variable of any pointer type .

NULL NULL is special constant value that is used to give value to pointer variable that would not otherwise have value .
NULL can be assigned to pointer variable of any type .
The identifier NULL is defined in number of libraries , including the library with header file and the library with header file .
The constant NULL is actually the number , but we prefer to think of it and spell it as NULL .

Since NULL is the number , both are equally valid .
resolves this problem by introducing new  nullptr .
Use nullptr anywhere you would have used NULL for pointer .
For example , we can write : double nullptr ; nullptr nullptr is special value that is used the same way as NULL , but it can only be assigned to pointer .

Use nullptr to differentiate between null pointer and the number .

el est Exerc ise .
Suppose your program contains the following type .

Chapter Pointers and Linked Lists .
Suppose that your program contains the type definitions and code given in Exercise .
That code creates node that contains the string " and the .
What code would you add in order to set the value of the member variable next of this node equal to NULL .

Suppose that your program contains the type definitions and code given in Exercise .
Assuming that the value of the pointer variable has not been changed , how can you destroy the variable pointed to by and return the memory it uses to the freestore so that it can be reused to create new variables .

Given the following structure definition : struct .

Linked Lists Lists such as those shown in Display are called linked lists .
linked list is list of nodes in which each node has member variable that is pointer that points to the next node in the list .
The first node in linked list is called the  which is why the pointer variable that points to the first node is named .
Note that the pointer named is not itself the of the list but only points to the of the list .
The last node has no special  but it does have special property .
The last node has NULL as the value of its member pointer variable .
To test to see whether node is the last node , you need only test to see if the pointer variable in the node is equal to NULL .

Our goal in this section is to write some basic functions for manipulating linked lists .
For variety , and to simplify the notation , we will use simpler type of node than that used in Display .
These nodes will contain only an integer and pointer .
The node and pointer type definitions that we will use are as follows : struct Node .

As exercise , see how we might construct the start of linked list with nodes of this type .
We first declare pointer variable , called  that will point the of our linked list : NodePtr .

Notice that the pointer member of this is set equal NULL .
That is because this is the last in the list well as the first in the .
At this stage , our linked list looks like this : NULL Our list was built in purely ad hoc way .
To have larger linked list , your program must be able add nodes in systematic way .
We next describe one simple way insert nodes in linked list .

Inserting at the Head of List In this subsection we assume that our linked list already contains one or more nodes , and we develop function add another .
The first parameter for the insertion function will be parameter for pointer variable that points the of the linked list , that is , pointer variable that points the first in the linked list .
The other parameter will give the be stored in the new .
The function declaration for our insertion function is as follows : void  int ; Linked Lists as Arguments You should always keep one pointer variable pointing the of linked list .
This pointer variable is way the linked list .
When you write function that takes linked list as an argument , this pointer points the of the linked can be used as the linked list argument .

Chapter Pointers and Linked Lists To insert new into the linked list , our function will use the new operator create new .
The data is then copied into the new  and the new is inserted at the of the list .
When we insert nodes this way , the new will be the first in the list is , the rather than the last .
Since variables have no names , we must use local pointer variable point this .
If we call the local pointer variable , the new can be referred as .
The complete process can be summarized as follows : Pseudocode for Function .
Create new variable pointed by .

Place the data in this new .

Make the link member of this new point the of the original linked list .

Make the pointer variable named point the new .

Display contains diagram of this algorithm .
Steps and in the diagram can be expressed by these assignment statements :  The complete function definition is given in Display .

NULL Display Function Add at the Head of Linked List Function Declaration .

Function Definition .

Chapter Pointers and Linked Lists You will want to allow for the possibility that list contains nothing .
For example , shopping list might have nothing in it because there is nothing to buy this week .
list with nothing in it is called an empty list .
linked list is named by naming pointer that points to the of the list , but an empty list has no .
To specify an empty list , you use the pointer NULL .
If the pointer variable is supposed to point to the of linked list and you want to indicate that the list is empty , then you set the value of as follows : NULL ; Whenever you design function for manipulating linked list , you should always check to see if it works on the empty list .
If it does not , you may be able to add special case for the empty list .
If you cannot design the function to apply to the empty list , then your program must be designed to handle empty lists some other way or to avoid them completely .
Fortunately , the empty list can often be treated just like any other list .
For example , the function in Display was designed with nonempty lists as the model , but check will show that it works for the empty list as well .

Pitfall Losing Nodes You might be tempted to write the function definition for using the pointer variable to construct the new  instead of using the local pointer variable .
If you were to try , you might start the function as follows : new  At this point the new is constructed , contains the correct  and is pointed to by the pointer  all as it is supposed to be .
All that is left to do is to attach the rest of the list to this by setting the pointer member given below so that it points to what was formerly the first of the list : Display shows the situation when the new value is .
That illustration reveals the problem .
If you were to proceed in this way , there would be nothing pointing to the containing .
Since there is no named pointer pointing to it to chain of pointers ending with that , there is no way the program can reference this .

program cannot make pointer point to either of these nodes , nor can it access the in these nodes , nor can it do anything else to the nodes .

It simply has no way to refer to the nodes .

Such situation ties up memory for the duration of the program .
program that loses nodes is sometimes said to have " significant memory leak can result in the program running out of memory , causing abnormal termination .
Worse , memory leak in an Nodes and Linked Lists Display Lost Nodes .

To avoid such lost nodes , the program must always keep some pointer pointing to the of the list , usually the pointer in pointer variable like .

Searching Linked List Next we will design function to search linked list in order to locate particular .
We will use the same type , called  that we used in the previous subsections .
The function will return pointer that points to the first which contains that integer .
If no contains the integer , the function will return the pointer NULL .
This way , our program can test to see whether the integer is on the list by checking to see if the function returns pointer value that is not equal to NULL .
The function declaration and header comment for our function is as follows : NodePtr  int ; The pointer points to the of linked list .
The pointer variable in the last NULL .
If the list is empty , then is NULL .

If no contains the target , function returns NULL .

We will use local pointer variable , called here , to move through the list looking for the target .
The only way to move around linked list , or any other structure made up of nodes and pointers , is to follow the pointers .

So we will start with here pointing to the first and move the pointer from to following the pointer out of each .

Chapter Pointers and Linked Lists diagrammed in Display .
Since empty lists present some minor problems that would clutter our discussion , we will at first assume that the linked list contains at least one .
Later we will come back and make sure the algorithm works for the empty list as well .
This search technique yields the following algorithm : Pseudocode for search Function of the linked list .

The next is the one pointed to by the pointer member of the currently pointed to by .
The pointer member of the currently pointed to by is given by the expression To move to the next  we want to change so that it points to the that is pointed to by the pointer variable .

Hence , the following will move the pointer to the next in the list :  Putting these pieces together yields the following refinement of the algorithm pseudocode : Preliminary Version of the Code for the search Function  while target .

We test to see if is not pointing to the last by testing to see if the member variable link is not equal to NULL .

NULL We still must go back and take care of the empty list .
If we check our code , we find that there is problem with the empty list .
If the list is empty , then is equal to NULL and hence the following expressions are undefined :

Chapter Pointers and Linked Lists When is NULL , it is not pointing to any node , so there is no member named data nor any member named link .
Hence , we make special case of the empty list .
The complete function definition is given in Display .

Display Function to Locate Node in Linked List Function Declaration .

The pointer variable in the last node NULL .
If the list is empty , then head is NULL .

If no node contains the target , function returns NULL .

Function Definition .

An iterator can be an object of some iterator class or something simpler , such as an array index or pointer .
Pointers provide simple example of an iterator .
In fact , pointer is the prototypical example of an iterator .
The basic ideas can be easily seen in the context of linked lists .
You can use pointer as an iterator by moving through the linked list one node at time starting at the head of the list and cycling through all the nodes in the list .
The general outline is as follows : Do whatever you want with the node pointed to by  where head is pointer to the head node of the linked list and link is the name of the member variable of node that points to the next node in the list .

For example , to output the data in all the nodes in linked list of the kind we have been discussing , you could use  to : Node .

The definition of Node and are given in Display .

Inserting and Removing Nodes Inside List We next design function to insert at specified place in linked list .
If you want the nodes in some particular order , such as numeric order or alphabetical order , you cannot simply insert the at the beginning or end of the list .
We will therefore design function to insert after specified in the linked list .
We assume that some other function or program part has correctly placed pointer called pointing to some in the linked list .
We want the new to be placed after the pointed to by , as illustrated in Display .
The same technique works for nodes with any kind of data , but to be concrete , we are using the same type of nodes as in previous subsections .
The type definitions are given in Display .
The function declaration for the function we want to define is : void , int ; points to in linked list .

new is set up the same way it was in the function in Display .
The difference between this function and that one is that we now wish to insert the not at the head of the list , but after the Inserting in the middle of list Chapter Pointers and Linked Lists Display Inserting in the Middle of Linked List head pointed to by .
The way to do the insertion is shown in Display and is expressed as follows in code : link from the new to the list :  link from the list to the new 

Insertion at the ends Comparison to arrays Removing The order of these two assignment statements is critical .
In the first assignment we want the pointer value before it is changed .
The complete function is given in Display .

If you go through the code for the function insert , you will see that it works correctly even if the pointed to by is the last in the list .
However , insert will not work for inserting at the beginning of linked list .
The function given in Display can be used to insert at the beginning of list .

By using the function insert you can maintain linked list in numerical order or alphabetical order or other ordering .
You can " new into the correct position by simply adjusting two pointers .
This is true no matter how long the linked list is or where in the list you want the new to go .
If you instead used an array , much , and in extreme cases all , of the array would have to be copied in order to make room for new in the correct spot .

Despite the overhead involved in positioning the pointer , inserting into linked list is frequently more efficient than inserting into an array .

Removing from linked list is also quite easy .
Display illustrates the method .
Once the pointers before and discard have Nodes and Linked Lists Display Function to Add Node in the Middle of Linked List Function Declaration .

Function Definition .

Chapter Pointers and Linked Lists Display Removing .
osition the pointer discard so that it points to the to be deleted , and position the pointer before so that it points to the before the one to be deleted .

If you change the linked list pointed to by , then you will also change the linked list pointed to by , because they are the same linked list .

If points to linked list and you want to point to second , identical copy of this linked list , the assignment statement above will not work .
Instead , you must copy the entire linked list by .
Alternatively , you can overload the assignment so that it means whatever you want it to mean .
Write type definitions for the nodes and pointers in linked list .
Call the type NodeType and call the pointer type PointerType .
The linked lists will be lists of letters .

linked list is normally given by giving pointer that points to the first in the list , but an empty list has no first .
What pointer is normally used to represent an empty list .

Suppose your program contains the following type definitions and pointer variable declarations : struct .

Suppose points to of this type that is on linked list .
Write code that will make point to the next on this linked list .
Suppose your program contains type definitions and pointer variable declarations as in Exercise .
Suppose further that points to of type that is on linked list and is not the last on the list .
Write code that will delete the after the pointed to by .

After this code is executed , the linked list should be the same , except that there will be one less on the linked list .
Choose an answer and explain it .

For large array and large list holding the same type objects , inserting new at known location into the middle of linked list compared with insertion in an array is .
More efficient .
Less efficient c .

Dependent on the size of the two lists .

Chapter Pointers and Linked Lists Variations on Linked Lists In this subsection we give you hint of the many data structures that can be created using nodes and pointers .
We briefly describe two additional data structures , the doubly linked list and the binary tree .

An ordinary linked list allows you to move down the list in only one direction the .
in doubly linked list has two links , one link that points to the next and one that points to the previous .

Diagrammatically , doubly linked list looks like the sample list in Display .

The node class for doubly linked list could be as follows : struct .

Rather than single pointer to the node , doubly linked list normally has pointer to each of the two end nodes .
You can call these pointers front and back , although the choice of which is front and which is back is arbitrary .
The definitions of constructors and some of the functions in the doubly linked list class will have to change the singly linked to accommodate the extra link .

tree is data structure that is structured as shown in Display .
In particular , in tree you can reach any node from the top node by some path that follows the links .
Note that there are no cycles in tree .
If you follow the links , you eventually get to an " Note that each node has two links that point Display Doubly Linked List front back Nodes and Linked Lists Display Binary Tree root .

NULL to other nodes the value .
This sort of tree is called binary tree , because each node has exactly two links .
There are other kinds of trees with different numbers of links in the nodes , but the binary tree is the most common case .

tree is not form of linked list , but does use links in ways that are similar to how they are used in linked lists .
The definition of the node type for binary tree is essentially the same as what it is for doubly linked list , but the two links are usually named using some form of the words left and right .

The following is node type that can be used for constructing binary tree : struct TreeNode .

In Display , the pointer named root points to the root node .
The root node serves purpose similar to that of the head node in an ordinary linked list .
Any node in the tree can be reached from the root node by following the links .

The term tree may seem like misnomer .
The root is at the top of the tree and the branching structure looks more like root branching structure than tree branching structure .
The secret to the terminology is to turn the picture upside down .
The picture then does resemble the branching structure of tree and the root node is where the root would begin .

Chapter Pointers and Linked Lists nodes at the ends of the branches with both link instance variables set to NULL are known as leaf nodes , terminology that may now make some sense .

Although we do not have room to pursue the topic in this book , binary trees can be used to efficiently store and retrieve data .

Linked Lists of Classes VideoNote Walkthrough of Linked Lists of Classes In the preceding examples we created linked lists by using struct to hold the contents of node within the list .
It is possible to create the same data structures using class instead of struct .
The logic is identical except the syntax of using and defining class should be substituted in place of that for struct .

Displays and illustrate how to define Node class .
The data variables are declared private using the principle of information hiding , and public methods have been created to access the data value and next node in the link .
Display creates short list of five nodes by inserting new nodes Display Interface File for Node Class is the header file for .
This is the interface for node class that behaves similarly to the struct defined Display namespace linkedlistofclasses .

Chapter Pointers and Linked Lists .

The function is logically identical to the same function defined in Display except the constructor defined for the class is used to set the .

Matthew Linked lists have many applications .
In this section we give two samples of what they can be used for .
We use linked lists to give implementations of two structures known as stack and queue .
In this section we always use regular linked lists and not doubly linked lists .

Stacks stack is structure that retrieves in the reverse of the order in which the is stored .
Suppose you place the letters , and then ' in stack .

When you take these letters out of the stack , they will be removed in the order , and then .
This use of stack is diagrammed in Display .
As shown Display Stack .

Chapter Pointers and Linked Lists there , you can think of stack as hole in the ground .
In order to get something out of the stack , you must first remove the items on top of the one you want .
For this reason stack is often called data structure .

Stacks are used for many language processing tasks .
In Chapter we will discuss how the computer system uses stack to keep track of function calls .
However , here we will do only one very simple application .
Our goal in this example is to show you how you can use the linked list techniques to implement specific data structures ; stack is one simple example of the use of linked lists .
You need not read Chapter to understand this example .

Programming Example Stack The interface for our Stack class is given in Display .
This particular stack is used to store data of type char .
You can define similar stack to store data of any other type .
There are two basic operations you can perform on stack : adding an item to the stack and removing an item from the stack .
Adding an item is called pushing the item onto the stack , and so we called the member function that is the header file .
This is the interface for the class Stack , is class for stack of symbols .

Removing an item from stack is called popping the item off the stack , and so we called the member function that does this pop .

The names push and pop derive from another way of visualizing stack .
stack is analogous to mechanism that is sometimes used to hold plates in cafeteria .
The mechanism stores plates in hole in the countertop .
There is spring underneath the plates with its tension adjusted so that only the top protrudes above the countertop .
If this sort of mechanism were used as stack data structure , the data would be written on plates might violate some health laws , but still makes good .
To add to the stack , you put it on top of the other plates , and the weight of this new pushes down the spring .
When you remove  the below it pops into view .

Display shows simple program that illustrates how the Stack class is used .
This program reads word one letter at time and places the letters in stack .
The program then removes the letters one by one and writes them to Application program .

Chapter Pointers and Linked Lists .

It discards input remaining on the current input line up to characters or until return is entered .
It also discards the return at the end of the Sample Dialogue Enter word : straw Written backward that is : warts : Enter word : Written backward that is :

Implementation the screen .
Because data is removed from stack in the reverse of the order in which it enters the stack , the output shows the word written backward .

As shown in Display , our Stack class is implemented as linked list in which the head of the list serves as the top of the stack .
The member variable top is pointer that points to the head of the linked list .

Chapter Pointers and Linked Lists .

Writing the definition of the member function push is Exercise .

However , we have already given the algorithm for this task .
The code for the push member function is essentially the same as the function shown in Display , except that in the member function push we use pointer named in place of pointer named head .

An empty stack is just an empty linked list , so an empty stack is implemented by setting the pointer equal to NULL .
Once you realize that NULL represents the empty stack , the implementations of the default constructor and of the member function empty are obvious .

The definition of the copy constructor is bit complicated but does not use any techniques we have not already discussed .
The details are left to SelfTest Exercise .

The pop member function first checks to see if the stack is empty .
If the stack is not empty , it proceeds to remove the character in the stack .
It sets the local variable equal to the symbol on the stack .
That is done as follows : char ; After the symbol in the node is saved in the variable  the pointer .

The pointer is moved with the following statement : However , before the pointer is moved , temporary pointer , called .

The node can then be removed with the following call to delete : delete  Each node that is removed from the linked list by the member function pop is destroyed with call to delete .
Thus , all that the destructor needs to do is remove each item from the stack with call to pop .
Each node will then have its memory returned to the freestore .

Give the definition of the member function push of the class Stack described in Display .

Give the definition of the copy constructor for the class Stack described in Display .

Queues stack is data structure .
Another common data structure is queue , which handles data in fashion .
queue behaves exactly the same as line of people waiting for bank teller or other service .
The people are served in the order they enter the line .
The operation of queue is diagrammed in Display .

queue can be implemented with linked list in manner that is similar to our implementation of the Stack class .
However , queue needs pointer at both the head of the list and at the other the end of the linked list , since action takes place in both locations .
It is easier to remove node from the head of linked list than from the other end of the linked list .
So , our implementation will remove node from the head of the list we will now call the front of the and we will add nodes to the other end of the list , which we will now call the back of the list the back of the .

Queue queue is data structure ; that is , the data items are removed from the queue in the same order that they were added to the queue .

Display Queue .

Chapter Pointers and Linked Lists Programming Example Queue The interface for our queue class is given in Display .
This particular queue is used to store data of type char .
You can define similar queue to store data of any other type .
There are two basic operations you can perform on queue : adding an item to the end of the queue and removing an item from the front of the queue .

Display Interface File for Queue is the header file .
This is the interface for the class Queue , is class for queue of symbols .

Returns false otherwise .

Items are added at this end .

Display shows simple program that illustrates how the queue class is used .
This program reads word one letter at time and places the letters in queue .
The program then removes the letters one by one and writes them to the screen .
Because data is removed from queue in the order in which it enters the queue , the output shows the letters in the word in the same order that the user entered them .
It is good to contrast this application of queue with similar application using stack that we gave in Display .

It discards input remaining on the current input line up to characters or until return is entered .
It also discards the return at the end of the Chapter Pointers and Linked Lists Sample Dialogue Enter word : straw You entered : straw : Enter word : You entered :

Implementation As shown in Displays and , our queue class is implemented as linked list in which the head of the list serves as the front of the queue .
The member variable front is pointer that points to the head of the linked list .

Nodes are removed at the head of the linked list .
The member variable back is pointer that points to the node at the other end of the linked list .
Nodes are added at this end of the linked list .

An empty queue is just an empty linked list , so an empty queue is implemented by setting the pointers front and back equal to NULL .
The rest of the details of the implementation are similar to things we have seen before .

Chapter Pointers and Linked Lists .

el est Exe rc ise .
Give the definition of the copy constructor for the class Queue described in Display .

Give the definition of the destructor for the class Queue described in Display .

Chapter Summary node is struct or class object that has one or more member variables that are pointer variables .
These nodes can be connected by their member pointer variables to produce data structures that can grow and shrink in size while your program is running .

stack can be implemented using linked list .

queue can be implemented using linked list .

Answers to Self Test Exerci ses .

Sally Sally Answers to Exercises Note that and mean the same thing .
Similarly , and mean the same thing .

This is sufficient to delete the node from the linked list .

If you are inserting into list , you have about five operations , most of which are pointer assignments , regardless of the list size .
If you insert into an array , on the average you have to move about half the array entries to insert data .

For small lists , the answer is , about the same .

Practice Programs Practice Programs can generally be solved with short program that directly applies the programming principles presented in this chapter .

The following program creates linked list with three names :

Add code to the main function that :
Outputs in order all names in the list .

Deletes the node with " then outputs the modified list .

Deletes all in the list .

Your class should have appropriate member functions to set the name and the link to the node in the list .
You might also consider adding constructor that can set the name and link .

Programming Projects Programming Projects require more than Practice Programs and can usually be solved many different ways .
Visit to complete many of these Programming Projects online and get instant feedback .

Write void function that takes linked list of integers and reverses the order of its .
The function will have one parameter that is pointer to the head of the list .
After the function is called , this pointer will point to the head of linked list that has the same as the original list , but in the reverse of the order they had in the original list .

Note that your function will neither create nor destroy any .
It will simply rearrange .
Place your function in suitable test program .

Write function called that takes two arguments that are pointer variables that point to the heads of lists of values of type int .
The two lists are assumed to be sorted so that the number at the head is the smallest number , the number in the node is Programming Projects the smallest , and so forth .
The function returns pointer to the head of new list that contains all of the in the original two lists .

The in this longer list are also sorted from smallest to largest values .

Note that your function will neither create nor destroy any .
When the function call ends , the two pointer variable arguments should have the value NULL .

Design and implement class whose objects represent polynomials .
The polynomial anxn + +
Each node will contain an int value for the power of and an int value for the corresponding coefficient .

The class operations should addition , subtraction , multiplication , and evaluation of polynomial .
Overload the operators + and for addition , subtraction , and multiplication .

Evaluation of polynomial is implemented as member function with one argument of type int .
The evaluation member function returns the value obtained by plugging in its argument for and performing the indicated operations .
Include four constructors : default constructor , copy constructor , constructor with single argument of type int that produces the polynomial that has only one constant term that is equal to the constructor argument , and constructor with two arguments of type int that produces the polynomial whose coefficient and exponent are given by the two arguments .
Include member functions to input and output polynomials .

When the user inputs polynomial , the user types in the following : + +
For example , the polynomial + + can be input as + + It could also be input as + + + +

Chapter Pointers and Linked Lists If coefficient is negative , minus sign is used in place of plus sign , as in the following examples : + + + minus sign at the of the polynomial , as in the second of the two examples , applies only to the first coefficient ; it does not negate the entire polynomial .
Polynomials are output in the same format .
In the case of output , the terms with zero coefficients are not output .

To simplify input , you can assume that polynomials are always entered one per line and that there will always be constant term .
If there is no constant term , the user enters for the constant term , as in the following : + + In this project you will redo Programming Project from Chapter using list instead of an array .
As noted there , this is list of double items .
This fact may imply changes in some of the member functions .

The members are as follows : default constructor ; member function named to add double to the list ; test for full list that is function named ; and friend function overloading the insertion operator .

harder version of Programming Project would be to write class named List , similar to Project , but with all the following member functions : Default constructor , double , which returns the first item in the list double , which returns the last item in the list double , which returns the " item returns ; to make return the first item in the list , double , which inserts into the list after and increments the private : variable count .

You will need the following struct the list for the list nodes : struct node .

Incremental development is essential to all projects of any size , and this is no exception .
Write the definition for the List class , but do not implement any members yet .
Place this class definition in file .

Then " in file that contains int your file .
This will find syntax errors and many typographical errors that would cause untold difficulty if you attempted to implement members without this check .
Then you should implement and compile one member at time , until you have enough to write test code in your main function .

She on the following procedure to determine which suitor she would marry .
First , all of the suitors would be lined up one after the other and assigned numbers .
The first suitor would be number , the second number , and so on up to the last suitor , number .
Starting at the first suitor she would then count three suitors down the line of the three letters in her and the third suitor would be eliminated from winning her hand and removed from the line .
Eve would then continue , counting three more suitors , and eliminate every third suitor .
When she reached the end of the line she would continue counting from the beginning .

For example , if there were six suitors then the elimination process would proceed as follows : initial list of suitors , start counting from suitor eliminated , continue counting from suitor eliminated , continue counting from suitor eliminated , continue counting from suitor eliminated , continue counting from suitor eliminated , is the lucky winner Write program that creates circular linked list of nodes to determine which position you should stand in to marry the princess if there are suitors .
circular linked list is linked list where the link field of the last node in the list refers to the node that is the head of the list .
Your program should simulate the elimination process by deleting the node that corresponds to the suitor that is eliminated for each step in the process .
Consider the possibility that you may need to delete the " node in the list .

VideoNote Solution to Programming Project Chapter Pointers and Linked Lists Redo do for the first Programming Project from Chapter .

However , instead of dynamic array to store the list of user IDs for each computer station , use linked list .
The node for the lists should contain the station number and user ID of the person logged in on that station .
If nobody is logged on to computer station , then no entry should exist in the linked list for that computer station .

Modify or rewrite the Queue class through to simulate arrivals at the Department of Motor Vehicles counter .
As customers arrive , they are given ticket number starting at and incrementing with each new .
When service agent is free , the with the next ticket number is called .
This system results in FIFO queue of customers ordered by ticket number .
Write program that implements the queue and simulates customers entering and leaving the queue .
Input into the queue should be the ticket number and timestamp when the ticket was entered into the queue .
ticket and its corresponding timestamp is removed when service agent handles the next .
Your program should save the length of time the last three customers spent waiting in the queue .
Every time ticket is removed from the queue , update these times and output the average of the last three customers as an estimate of how long it will take until the next is handled .
If nobody is in the queue , output that the line is empty .

Code to compute timestamp based on the clock is given below .
The function returns the number of January , on most implementations of :

Sample execution is shown here : The line is empty .

Enter ' to simulate arrival , to help the next  or ' to quit .

Enter ' to simulate arrival , to help the next  or ' to quit .

Enter ' to simulate arrival , to help the next  or ' to quit .

Enter ' to simulate arrival , to help the next  or ' to quit .

The estimated wait for is .

Enter ' to simulate arrival , to help the next  or ' to quit .

The estimated wait for is .

Enter ' to simulate arrival , to help the next  or ' to quit .

Enter ' to simulate arrival , to help the next  or ' to quit .

The estimated wait for is .

The following figure is called graph .
The circles are called nodes , and the lines are called edges .
An edge connects two nodes .
You can interpret the graph as maze of rooms and passages .
The nodes can be thought of as rooms , and an edge connects one room to another .
Note that each node has at most four edges in the graph .

North Start .

Finish VideoNote Solution to Programming Project Chapter Pointers and Linked Lists Write program that implements the maze using nodes and pointers .

Each node in the graph will correspond to node in your code that is implemented in the form of class or struct .
The edges correspond to bidirectional links that point from one node to another .
Start the user in node .
The goal is to reach the finish in node .
The program should output possible moves in the north , south , east , or west direction .

Sample execution is shown here .

You You You You You You are in room of maze of twisty little passages , all alike .

In RPN , the operator comes after the operands instead of the normal format in which the operator is between the operands is called infix .
Starting with an empty stack , RPN calculator can be implemented with the following rules : number is input , push it on the stack .

Use the modified stack to implement RPN calculator .

Output an appropriate error message if there are not two operands on the stack when given an operator .
Here is sample input and output that is equivalent to + + Programming Projects The top of the stack is :
You should complete the Programming Project before attempting this one .
Write program that converts fully parenthesized mathematical infix expression into an equivalent postfix expression and then evaluates the postfix expression .
fully parenthesized expression is one in which parentheses surround every operator and its operands .
Starting with an empty stack of strings to store operators and an empty queue of strings to store the postfix expression , the conversion can be implemented with the following rules : is input , then ignore it .

When the final operator is popped from the stack , the queue contains the equivalent postfix expression .
Use your solution from Programming Project to evaluate it .
You will need to convert string object to an integer .
Use the function to convert the string to string , and then use the atoi function to convert the string into an integer .
Refer to Chapter for details .

Sample output is shown below for + translates to the postfix expression + The expression evaluates to .

Recursion Functions for Tasks Case Study : Vertical Numbers Closer Look at Recursion Pitfall : Infinite Recursion Stacks for Recursion Pitfall : Stack Overflow Recursion Versus Iteration Thinking Recursively Recursive Design Techniques Case Study : Binary Example of Recursive Thinking Programming Example : Recursive Member Function Functions for Values General Form for Recursive Function That Returns Value Programming Example : Another Powers Function Chapter Summary Answers to Exercises Practice Programs Programming Projects After lecture on cosmology and the structure of the solar system , William James was accosted by little old lady .

James , but wrong .
got better " said the little old lady .

Not wishing to demolish this absurd little theory by bringing to bear the masses of scientific evidence he had at his command , James decided to gently dissuade his opponent by making her see some of the inadequacies of her position .

To this the little old lady crowed triumphantly .
Ross , Constraints on Variables in Syntax Introduction You have encountered few cases of circular definitions that worked out satisfactorily .
The most prominent examples are the definitions of certain statements .
For example , the definition of while statement says that it can contain other statements .
Since one of the possibilities for these smaller statements is another while statement , there is kind of circularity in that definition .
The definition of the while statement , if written out in complete detail , will contain reference to while statements .
In mathematics , this kind of circular definition is called recursive definition .
In , function may be defined in terms of itself in the same way .
To put it more precisely , function definition may contain call to itself .
In such cases , the function is said to be recursive .
This chapter discusses recursion in and more generally discusses recursion as programming and technique .

Prerequisites Sections and use material only from Chapters through .
Section uses material from Chapters through and .

Jorge Luis Borges , The Garden of Forking Paths When you are writing function to solve task , one basic design technique is to break the task into subtasks .
Sometimes it turns out that at least one of the subtasks is smaller example of the same task .
For example , if the task is to search an array for particular value , you might divide this into the subtask of searching the first half of the array and the subtask of searching the second versions of the original task .
Whenever one subtask is smaller version of the original task to be accomplished , you can solve the original task using recursive function .
It takes little training to easily decompose problems this way , but once you learn the technique , it can be one of the quickest ways to design an algorithm , and , ultimately , function .
We begin with simple case study to illustrate this technique .

Recursion In , function definition may contain call to the function being defined .
In such cases , the function is said to be recursive .

Case Study Vertical Numbers In this case study we design recursive void function that writes numbers to the screen with the digits written vertically , so that , for example , would be written as Problem Definition .

Algorithm Design One case is very simple .
If  the number to be written out , is only one digit long , then just write out the number .
As simple as it is , this case is still important , so keep track of it .

Simple Case : If , then write the number to the screen .

Now consider the more typical case in which the number to be written out consists of more than one digit .
Suppose you want to write the number vertically so that the result is One way to decompose this task into two subtasks is the following : Output all the digits except the last digit like so : Output the last digit , which in this example is .

Subtask is smaller version of the original task , so we can implement this subtask with recursive call .
Subtask is just the simple case we listed earlier .

Thus , an outline of our algorithm for the function with parameter is given by the following pseudocode : endl ; Recursive subtask .

In order to convert this pseudocode into the code for function , all we need to do is translate the following two pieces of pseudocode into expressions : the number with the last digit removed and the last digit of Recursive Functions for Tasks These expressions can easily be translated into expressions using the integer division operators and as follows : number with the last digit removed last digit of For example , evaluates to , and evaluates to .

Several factors influenced our selection of the two subtasks we used in this algorithm .
One was that we could easily compute the argument for the recursive call to in that we used in the pseudocode .

The number with the last digit removed is easily computed as .
As an alternative , you might have been tempted to divide the subtasks as follows : Output the first digit of .

This is perfectly valid decomposition of the task into subtasks , and it can be implemented recursively .
However , it is difficult to calculate the result of removing the first digit from number , while it is easy to calculate the result of removing the last digit from number .

Another reason for choosing these sorts of decompositions is that one of the subcases does not involve recursive call .
successful definition of recursive function always includes at least one case that does not involve recursive call well as one or more cases that do involve at least one recursive .
This aspect of the recursive algorithm is discussed in the subsections that follow this case study .

Coding We can now put all the pieces together to produce the recursive function shown in Display .
In the next subsection we will explain more details of how recursion works in this example .

The argument is substituted for the parameter in the function definition , and the body of the function is executed .
After the substitution of for  the code to be executed is as follows : Recursive Functions for Tasks .

Since is not less than , the logical expression in the statement is false , so the else part is executed .
However , the else part begins with the following function call :

When execution reaches this recursive call , the current function computation is placed in suspended animation and this recursive call is executed .
When this recursive call is finished , the execution of the suspended computation will return to this point , and the suspended computation will continue from this point .

The recursive call ; is handled just like any other function call .
The argument is substituted for the parameter and the body of the function is executed .
After substituting for  there are two computations , one suspended and one active , as follows :

However , as you already saw , the else part begins with recursive call .
The argument for the recursive call is , which .

At this point there are two suspended computations waiting to resume and the computer begins to execute this new call , which is handled just like all the previous calls .
The argument is substituted for the parameter  and the body of the function is executed .
At this point , the computation looks like the following : if endl ; if digits endl ; long : else is more .

When the body of the function is executed this time , something different happens .
Since is less than , the Boolean expression in the statement is true , so the statement before the else is executed .
That statement is simply statement that writes the argument to the screen , and so the call writes to the screen and ends without any call .

When the call ends , the suspended computation that is waiting for it to end resumes where that suspended computation left off , as shown by the following : if .

That ends that computation , but there is yet another suspended computation waiting to resume .
When this last suspended computation resumes , the situation is as follows : Output the digit .

And , sure enough , the digits , and have been written to the screen one per line , in that order .

Output the digit Closer Look at Recursion The definition of the function uses recursion .
Yet we did nothing new different in evaluating the function call .
We treated it just like any of the function calls we saw in previous chapters .
We just substituted the argument for the parameter and then executed the code in the body of the function definition .
When we reached the call ; we simply repeated this process one more time .

The computer keeps track of calls in the following way .
When and begins to execute the code .
If it should encounter call , then it temporarily stops its computation .
This is because it must know the result of the call before it can proceed .
It saves all the information it needs to continue the computation later on and proceeds to evaluate the call .

When the call is completed , the computer returns to finish the outer computation .

The language places no restrictions on how calls are used in function definitions .
However , in order for function definition to be useful , it must be designed so that any call of the function must ultimately terminate with some piece of code that does not depend on recursion .
The function may call itself , and that call may call the function again .

How recursion works How recursion ends Chapter Recursion The process may be repeated any number of times .
However , the process will not terminate unless eventually one of the calls does not depend on recursion .
The general outline of successful recursive function definition is as .

One more cases in which the function accomplishes its task by using recursive calls to accomplish one more smaller versions of the task .

One more cases in which the function accomplishes its task without the use of any recursive calls .
These cases without any recursive calls are called base cases stopping cases .

Often , an statement determines which of the cases will be executed .
typical scenario is for the original function call to execute case that includes recursive call .
That recursive call may in turn execute case that requires another recursive call .
For some number of times each recursive call produces another recursive call , but eventually one of the stopping cases should apply .
Every call of the function must eventually lead to stopping case , else the function call will never end because of an infinite chain of recursive calls .
This is how we designed the function in Display .
When the function is called , that call produces recursive call with smaller argument .
This continues with each recursive call producing another recursive call until the argument is less than .
When the argument is less than , the function call ends without producing any more recursive calls and the process works its way back to the original call and then ends .

General Form of Recursive Function Definition The general outline of successful recursive function definition is as follows : One more cases that include one more recursive calls to the function being defined .
These recursive calls should solve " versions of the task performed by the function being defined .

These cases without any recursive calls are called base cases stopping cases .

Infinite Recursion In the example of the function discussed in the previous subsections , the series of recursive calls eventually reached call of the function that did not involve recursion is , stopping case was .

If , on the other hand , every recursive call produces another recursive call , then call to the function will , in theory , run forever .
This is called infinite recursion .
In practice , such function will typically run until the computer runs out of resources and the program terminates abnormally .
Phrased another way , recursive definition should not be all the way " Otherwise , like the explanation of the universe given at the start of this chapter , call to the function will never end , except perhaps in frustration .

Examples of infinite recursion are not hard to come by .
The following is syntactically correct function definition , which might result from an attempt to define an alternative version of the function .

If you embed this definition in program that calls this function , the compiler will translate the function definition to machine code and you can execute the machine code .
Moreover , the definition even has certain reasonableness to it .
It says that to output the argument to vertical , first output all but the last digit and then output the last digit .

However , when called , this function will produce an infinite sequence of recursive calls .
If you call , that execution will stop to execute the recursive call , which is equivalent to .
The execution of that recursive call will , in turn , stop to execute the recursive call .

Since the definition of has no stopping case , the process will proceed forever until the computer runs out of .

Write recursive void function that has one parameter which is positive integer and that writes out that number of asterisks ' to the screen all on one line .

Write recursive void function that has one parameter , which is positive integer .
When called , the function writes its argument to the screen backward .

That is , if the argument is , it outputs the following to the screen :
Write recursive void function that takes single int argument and writes the integers ,

Write recursive void function that takes single int argument and writes integers 
stack is very specialized kind of memory structure that is analogous to stack of paper .
In Recursive Functions for Tasks this analogy there is an inexhaustible supply of extra blank sheets of paper .

To place some information in the stack , it is written on one of these sheets of paper and placed on top of the stack of papers .
To place more information in the stack , clean of paper is taken , the information is written on it , and this new of paper is placed on top of the stack .
In this straightforward way , more and more information may be placed on the stack .

Getting information out of the stack is also accomplished by very simple procedure .
The top of paper can be read , and when it is no longer needed , it is thrown away .
There is one complication : Only the top of paper is accessible .

In order to read , say , the third from the top , the top two sheets must be thrown away .
Since the last that is put on the stack is the first taken off the stack , stack is often called memory structure .

Using stack , the computer can easily keep track of recursion .
Whenever function is called , new of paper is taken .
The function definition is copied onto this of paper , and the arguments are plugged in for the function parameters .
Then the computer starts to execute the body of the function definition .
When it encounters call , it stops the computation it is doing on that in order to compute the call .

But before computing the call , it saves enough information so that , when it does finally complete the call , it can continue the stopped computation .
This saved information is written on of paper and placed on the stack .
new of paper is used for the call .
The computer writes second copy of the function definition on this new of paper , plugs in the arguments for the function parameters , and starts to execute the call .
When it gets to call within the recursively called copy , it repeats the process of saving information on the stack and using new of paper for the new call .
This process is illustrated in the earlier subsection entitled Recursive " Even though we did not call it stack in that section , the illustrations of computations placed one on top of the other demonstrate the actions of the stack .

This process continues until some call to the function completes its computation without producing any more calls .
When that happens , the computer turns its attention to the top of paper on the stack .
This contains the partially completed computation that is waiting for the computation that just ended .
So , it is possible to proceed with that suspended computation .
When that suspended computation ends , the computer discards that of paper , and the suspended computation that is below it on the stack becomes the computation on top of the stack .
The computer turns its attention to the suspended computation that is now on the top of the stack , and so forth .
The process continues until the computation on the bottom is completed .
Depending on how many calls are made and how the function definition is written , the stack may grow and shrink in any fashion .
Notice that the sheets in the stack can only be accessed in fashion , but that is exactly what is needed to keep track of calls .
Each suspended version is waiting for the completion of the version directly above it on the stack .

This is just an analogy .
The computer uses portions of memory rather than pieces of paper .
The contents of one of these portions of memory of is called an activation frame .
These activation frames are handled in the manner we just discussed .
However , an activation frame contains enough information to allow the computer to act as if the frame contained Stack stack is memory structure .
The first item referenced or removed from stack is always the last item entered into the stack .

Stacks are used by computers to keep track of recursion for other .

Pitfall Stack Overflow There is always some limit to the size of the stack .
If there is long chain in which function makes call to itself , and that call results in another call , and that call produces yet another call , and so forth , then each call in this chain will cause another activation frame to be placed on the stack .
If this chain is too long , then the stack will attempt to grow beyond its limit .
This is an error condition known as stack overflow .
If you receive an error message that says stack overflow , it is likely that some function call has produced an excessively long chain of calls .
One common cause of stack overflow is infinite recursion .
If function is recursing infinitely , then it will eventually try to make the stack exceed any stack size limit .

Any task that can be accomplished using recursion can also be done in some other way without using recursion .
For example , Display contains nonrecursive version of the function given in Display .
The nonrecursive version of function typically uses loop of some sort in place of recursion .
For that reason , the nonrecursive version is usually referred to as an iterative version .
If the definition of the function vertical given in Display is replaced by the version given in Display , then the output will be the same .
As is true in this case , version of function can sometimes be much simpler than an iterative version .

recursively written function will usually run slower and use more storage than an equivalent iterative version .
Although the iterative version of vertical given in Display looks like it uses more storage and does more computing than the recursive version in Display , the two versions of actually use comparable storage and do comparable amounts of computing .
In fact , the recursive version may use more storage and run somewhat slower , because the computer must do good deal of work manipulating the stack in order to keep track of the recursion .
However , since the system does all this for you automatically , using recursion can sometimes make your job as programmer easier and can sometimes produce code that is easier to understand .
As you will see in the examples in this chapter and in the Exercises and Programming Projects , sometimes recursive definition is simpler and clearer ; other times , an iterative definition is simpler and clearer .

el est Exe cis es .
If your program produces an error message that says stack overflow , what is likely source of the error .

Write an iterative version of the function cheers defined in Exercise .

Write an iterative version of the function defined in Exercise .

Write an iterative version of the function defined in Exercise .

Trace the recursive solution you made to Exercise .

Trace the recursive solution you made to Exercise .

Anonymous General Form for Recursive Function That Returns Value The recursive functions you have seen thus far are all void functions , but recursion is not limited to void functions .
recursive function can return value of any type .
The technique for designing recursive functions that return value is basically the same as for void functions .
An outline for successful recursive function definition that returns value is as follows .

As was the case with void functions , the arguments for the recursive calls should Programming Example Another Powers Function In Chapter we introduced the predefined pow that computes powers .
For example , returns , so the following sets the variable equal to : double , The pow takes two arguments of type double and returns value of type double .
Display contains recursive definition for that is similar but that works with the type int rather than double .
This new is called power .
For example , the following will set the value of equal to , since is : int , Recursive Functions for Values Display The Recursive Function power .

Sample Dialogue to the power to the power to the power to the power Our main reason for defining the power to have simple example of recursive  but there are situations in which the power would be preferable to the pow .
The pow returns values of type double , which are only approximate quantities .
The power returns values of type int , which are exact quantities .
In some situations , you might need the additional accuracy provided by the power .

Chapter Recursion The definition of the power based on the following formula : equal to should be the same as the value of the expression , The definition of the power given in Display does return this value for , provided .
The case where equal to the stopping case .
If , then simply returns .

see what happens when the power called with some sample values .
First consider the following simple expression : When the called , the value of set equal to , the value of set equal to , and the code in the body of the definition executed .

Since the value of legal value , the statement executed .
Since this value of not greater than , the return statement after the else used , so the call returns .
Thus , the following would set the value of equal to : int ,

When the called , the value of set equal to , the value of set equal to , and the code in the body of the definition executed .

Since this value of greater than , the following return statement used to determine the value returned : return ,

At this point the computation of suspended , copy of this suspended computation placed on the stack , and the computer then starts new call to compute the value of .
As you have already seen , the value of .
After determining the value of , the computer replaces the expression with its value of and resumes the suspended computation .
The resumed computation determines the final value for from the return statement above as follows : which .

The value of , calculated as follows :

After calculating the value returned for the stopping case , it resumes the most recently suspended computation to determine the value of .
After that , the computer completes each of the other suspended computations , using each value computed as value to plug into another suspended computation , until it reaches and completes the computation for the original call ,
The details of the entire computation are illustrated in Display .

Sequence of recursive calls How the final value computed .

Redefine the power so that it also works for negative exponents .

In order to do this , you will also have to change the type of the value returned to double .
The declaration and header comment for the redefined version of power is as follows : double , int .

Anonymous Recursive Design Techniques When defining and using recursive functions you do not want to be continually aware of the stack and the suspended computations .
The power of recursion comes from the fact that you can ignore that detail and let the computer do the bookkeeping for you .
Consider the example of the power in Display .
The way to think of the definition of power is as follows : returns power , Since is equal to , this is the correct value to return , provided that the computation will always reach stopping case and will correctly compute the stopping case .
So , after checking that the recursive part of the definition is correct , all you need check is that the chain of recursive calls will always reach stopping case and that the stopping case always returns the correct value .

When you design recursive  you need not trace out the entire sequence of recursive calls for the instances of that in your program .

If the returns value , all that you need do is confirm that the following three properties are satisfied :
There is no infinite recursion .
Each stopping case returns the correct value for that case .

For the cases that involve recursion : If all recursive calls return the correct value , then the final value returned by the function is the correct value .

For example , consider the function power in Display :
There is no infinite recursion : The second argument to is decreased by in each recursive call , so any chain of recursive calls must eventually reach the case , which is the stopping case .
Thus , there is no infinite recursion .

Criteria for functions that return value Chapter Recursion .
Each stopping case returns the correct value for that case : The only stopping case is .
call of the form always returns , and the correct value for is .
So the stopping case returns the correct value .

For the cases that involve all recursive calls return the correct value , then the final value returned by the function is the correct value : The only case that involves recursion is when .
When , returns ,

all you need to check in order to be sure that the definition of power is correct .
However , you do not need to We gave you three criteria to use in checking the correctness of recursive function that returns value .
Basically , the same rules can be applied to recursive void function .
If you show that your recursive void function definition satisfies the following three criteria , then you will know that your void function performs correctly : Criteria for void functions .
There is no infinite recursion .

Each stopping case performs the correct action for that case .

For each of the cases that involve recursion : If all recursive calls perform their actions correctly , then the entire case performs correctly .

Case Study Example of Recursive Thinking In this case study we develop recursive function that searches an array to find out whether it contains specified value .
For example , the array may contain list of numbers for credit cards that are no longer valid .
store clerk needs to search the list to see if card is valid or invalid .
In Chapter we discussed simple method for searching an array by simply checking every array element .
In this section we will develop method that is much faster for searching sorted array .

The indexes of the array are the integers through .
In order to make the task of searching the array easier , we assume that the array is sorted .
Hence , we know the following :
For example , if we are searching for credit card number , then the array index may serve as record number .
Another array indexed by these same indexes may hold phone number or other information to use for reporting the suspicious card .
Hence , if the value is in the array , we will want our function to tell where that value is in the array .

Problem Definition We will design our function to use two parameters to return the outcome of the search .
One parameter , called  will be of type bool .

If the value is  then will be set to true .
If the value is  then another parameter , called  will be set to the index of the value If we use key to denote the value being searched for , the task to be accomplished can be formulated precisely as follows : Precondition : through are sorted in increasing order .

Postcondition : if key is not one of the values through , then false ; otherwise , key and true .

Algorithm Design Now let us proceed to produce an algorithm to solve this task .
It will help to visualize the problem in very concrete terms .
Suppose the list of numbers is so long that it takes book to list them all .
This is in fact how invalid credit card numbers are distributed to stores that do not have access to computers .
If you are clerk and are handed credit card , you must check to see if it is on the list and hence invalid .

Open the book to the middle and see if the number is there .
If it is not and it is smaller than the middle number , then work backward toward the beginning of the book .
If the number is larger than the middle number , you work your way toward the end of the book .
This idea produces our first draft of an algorithm : false ; far .

Since the searchings of the shorter lists are smaller versions of the very task we are designing the algorithm to perform , this algorithm naturally lends version Chapter Recursion itself to the use of recursion .
The smaller lists can be searched with recursive calls to the algorithm itself .

Our pseudocode is bit too imprecise to be easily translated into code .

The problem has to do with the recursive calls .
There are two recursive calls shown : search through ; and search + through ; More parameters refinement Stopping case version To implement these recursive calls , we need two more parameters .
recursive call specifies that subrange of the array is to be searched .
In one case it is the elements indexed by through .
In the other case it is the elements indexed by through .
The two extra parameters will specify the first and last indexes of the search , so we will call them first and these parameters for the lowest and highest indexes , instead of and , we can express the pseudocode more precisely as follows : To search through do the following : false ; far .

The recursive calls will use other values for first and last .
For example , the first recursive call would set first equal to and last equal to the calculated value .

As with any recursive algorithm , we must ensure that our algorithm ends rather than producing infinite recursion .
If the number is on the list , then there is no recursive call and the process terminates , but we need some way to detect when the number is not on the list .
On each recursive call , the value of first is increased or the value of last is decreased .

If they ever pass each other and first actually becomes larger than last , then we will know that there are no more indexes left to check and that the number is not in the array .
If we add this test to our pseudocode , we obtain complete solution as shown in Display .

Coding Now we can routinely translate the pseudocode into code .
The result is shown in Display .
The function search is an implementation of the recursive algorithm given in Display .
diagram of how the function performs on sample array is given in Display .

Display Pseudocode for Binary Search int .

To locate the value 

Chapter Recursion portion of the program contains some code to fill and sort the array .
The exact details are irrelevant to this .

Display Execution of the Function search is .

Chapter Recursion Solve more general problem Notice that the function search solves more general problem than the original task .
Our goal was to design function to search an entire .

Yet the function will let us search any interval of the by specifying the index bounds and .
This is common when designing recursive functions .
Frequently , it is necessary to solve more general problem in order to be able to express the recursive algorithm .
In this case , we only wanted the answer in the case where and are set equal to and .
However , the recursive calls will set them to values other than and .

Checking the Recursion In the subsection entitled Design " we gave three criteria that you should check to ensure that recursive void function definition is correct .
check these three things for the function search given in Display .

There is no infinite recursion : On each recursive call , the value of is increased or the value of is decreased .

Each stopping case performs the correct action for that case : There are two stopping cases : when and when .
consider each case .

Thus , both stopping cases are correct .

For each of the cases that involve recursion , if all recursive calls perform their actions correctly , then the entire case performs correctly : There are two cases in which there are recursive calls : when and when .

We need to check each of these two cases .

First suppose .
In this case , since the array is sorted , we know that if is anywhere in the array , then is one of the elements through .
Thus , the function need only search these elements , which is exactly what the recursive call ,    does .
So if the recursive call is correct , then the entire action is correct .

Next , suppose .
In this case , since the array is sorted , we know that if is anywhere in the array , then is one of the elements through .
Thus , the function need search only these elements , which is exactly what the recursive call Thinking Recursively .

So if the recursive call is correct , then the entire action is correct .

Thus , in both cases the function performs the correct action that the recursive calls perform the correct .

The function search passes all three of our tests , so it is good recursive function definition .

Efficiency The binary search algorithm is extremely fast compared to an algorithm that simply tries all array elements in order .
In the binary search , you eliminate about half the array from consideration right at the start .
You then eliminate quarter , then an eighth of the array , and so forth .
These savings add up to dramatically fast algorithm .
For an array of elements , the binary search will never need to compare more than elements to the .
simple serial search could compare as many as array elements to the and on the average will compare about array elements to the .
Moreover , the larger the array is , the more dramatic the savings will be .
On an array with elements , the binary search will need to compare only about array elements to the value , as compared to an average of for the simple serial search algorithm .

An iterative version of the function search is given in Display .
On some systems , the iterative version will run more efficiently than the recursive version .
The algorithm for the iterative version was derived by mirroring the recursive version .
In the iterative version , the local variables and mirror the roles of the parameters in the recursive version , which are also named and .
As this example illustrates , it often makes sense to derive recursive algorithm even if you expect to later convert it to an iterative algorithm .

Iterative version Function Declaration .

Function Definition void int , int , int .

Programming Example Recursive Member Function member function of class can be recursive .
Member functions can use recursion in the same way that ordinary functions do .
Display contains an example of recursive member function .
The class BankAccount used in that display is the same as the class named BankAccount that was defined in Display , except that we have overloaded the member function name update .
The of update has no arguments and posts one year of simple interest to the bank account balance .
The other of update takes an int argument that is some number of years .
This member function updates the account by posting the interest for that many years .
The of update is one parameter , called years ; and uses the following algorithm : If the number of years is , then case : call the other function named update one with no .

If the number of years is greater than , then case : make recursive call to post worth of interest , and then call the other function called update one with no to post one more worth of interest .

Two different functions with the same name void ; If outs is file output stream , then outs has already .

There is no infinite recursion : Each recursive call reduces the number of by until the number of eventually becomes , which is the stopping case .
So there is no infinite recursion .

Each stopping case performs the correct action that case : The one stopping case is when .
This case produces the correct action , since it simply calls the other overloaded member function called update , and we checked the correctness of that function in Chapter .

For the cases that involve recursion , if all recursive calls perform correctly , then the entire case performs correctly : The recursive is , correctly , because if the recursive call correctly posts worth of interest , then all that is needed is to post one additional worth of interest and the call to the overloaded version of update will correctly post one worth of interest .
Thus , if the recursive call performs the correct action , then the entire action for the case of will be correct .

In this example , we have overloaded update so that there are two different functions named update : one that takes no arguments and one that takes single argument .
Do not confuse the calls to the two functions named update .

These are two different functions that , as far as the compiler is concerned , just coincidentally happen to have the same name .
When the definition of the function update with one argument includes call to the version of update that takes no arguments , that is not recursive call .
Only the call to the version of update with the exact same function declaration is recursive call .
To see what is involved here , note that we could have named the version of update that takes no argument , instead of naming it , and then the definition of the recursive version of update would read as .

Recursion and Overloading Do not confuse recursion and overloading .
When you overload function name , you are giving two different functions the same name .
If the definition of one of these two functions includes call to the other , that is not recursion .
In recursive function definition , the definition of the function includes call to the exact same function with the exact same definition , not to some other function that coincidentally uses the same name .
It is not too serious an error if you confuse overloading and recursion , since they are both legal .
It is simply question of getting the terminology straight so that you can communicate clearly with other programmers and so that you understand the underlying processes .

Write recursive function definition for the following .

Write an iterative version of the member function that is described in Display .

Chapter Summary If problem can be reduced to smaller instances of the same problem , then recursive solution is likely to be easy to find and implement .

This may be required to allow for the proper recursive calls , since the smaller problems may not be exactly the same problem as the given task .
For example , in the binary search problem , the task was to search an entire array , but the recursive solution is an algorithm to search any portion of the array all of it or part of .

Answers to Self Test Exerci ses .

An error message that says stack overflow is telling you that the computer has attempted to place more activation frames on the stack than are allowed on your system .
likely cause of this error message is infinite recursion .

The recursions unwind ; the output while recursion was winding is .

Trace for Exercise : the code to be executed is .

The function is the factorial function , usually written .

Practice Programs Practice Programs can generally be solved with short program that directly applies the programming principles presented in this chapter .

Write recursive function definition for function that has one parameter of type int and that returns the nth Fibonacci number .
See Programming Project in Chapter for the definition of Fibonacci numbers .
Embed the function in program and test it .

Write recursive version of the function that was used in the sorting program in Display of Chapter .
Embed the function in program and test it .

Write recursive version of the search function in Display of Chapter .

There are people in room , where is an integer greater than or equal to .
Each person shakes hands once with every other person .
What is the total number of handshakes in the room .
Write recursive function to solve this problem , with the following header : where returns the total number of handshakes for people .

You will have to define suitable stopping condition .
Test your function with several palindromes and nonpalindromes .

Programming Projects Programming Projects require more than Practice Programs and can usually be solved many different ways .
Visit to complete many of these Programming Projects online and get instant feedback .

The formula for computing the number of ways of choosing different things from set of things is the following : VideoNote Solution to Practice Program .

Chapter Recursion The factorial function .
Embed the function in program and test it .

Write recursive function that has an argument that is an array of characters and two arguments that are bounds on array indexes .
The function should reverse the order of those entries in the array whose indexes are between the two bounds .
For example , the array is ' and the bounds are and , then after the function is run the array elements should be ' Embed the function in program and test it .
After you have fully debugged this function , define another function that takes single argument which is an array that contains string value and that reverses the spelling of the string value in the array argument .
This function will call to the recursive definition you did for the first part of this project .
Embed this second function in program and test it .

Write an iterative version of the recursive function in Programming Project .

Embed it in program and test it .

VideoNote Solution to Practice Program .
Write recursive function to sort an array of integers into ascending order using the following idea : Place the smallest element in the first position , then sort the rest of the array by recursive call .
This is recursive version of the selection sort algorithm discussed in Chapter .
The function to do the sorting must .
Towers of Hanoi : There is story about Buddhist monks who are playing this puzzle with stone disks .
The story claims that when the monks finish moving the disks from one post to second via the third post , time will end .

The task is to move the disks one at time from the first post to the second .
To do this , any disk can be moved from any post to any other post , subject to the rule that you can never place larger disk over smaller disk .
The third post is provided to make the solution possible .
Your task is to write recursive function that describes instructions for solution to Programming Projects this problem .
We have graphics available , so you should output sequence of instructions that will solve the problem .

Then by using the same technique that may you can move the disks from the third post to the second post , using the first disk as spare .
You have the puzzle solved .
You only have to decide what the nonrecursive case is , what the recursive case is , and when to output instructions to .
The game of It " consists of board with positive integers in row , except for the first column , which always contains .
These numbers represent the cost to enter each column .
Here is sample game board where is :

The number in each column represents the cost to enter that column .
You always start the game in the first column and have two types moves .
You can either move to the adjacent column or jump over the adjacent column to land two columns over .
The cost game is the sum the costs the columns visited .

In the board shown above , there are several ways to get to the end .

Starting in the first column , our cost so far is .
We could jump to , then jump to , then move to for total cost + +

However , cheaper path would be to move to , jump to , then jump to , for total cost + +

Write recursive solution to this problem that computes the lowest cost the game and outputs this value for an arbitrarily large game board represented as an array .
Your program have to output the actual sequence jumps , only the lowest cost this sequence .
After making sure that your solution works on small arrays , test it on boards larger and larger values to get feel for the scalability and efficiency your solution .

Suppose we can buy chocolate bars from the vending machine for each .

Inside every chocolate bar is coupon .
We can redeem coupons for chocolate bar from the machine .
We would like to know how many chocolate bars can be eaten , including those redeemed via coupon , if we have dollars .

For example , if we have , then we can initially buy chocolate bars .

This gives us coupons .
We can redeem coupons for additional chocolate bars .
These two additional chocolate bars have more coupons ,

Chapter Recursion so we now have total coupons when added to the left over from the original purchase .
This gives us enough to redeem for final chocolate bar .
As result we now have chocolate bars and leftover coupons .

Write recursive solution to this problem that inputs from the user the number dollars to spend on chocolate bars and outputs how many chocolate bars you can collect after spending all your money and redeeming as many coupons as possible .
Your recursive function will be based upon the number coupons owned .

For set items ,
For example , given the set , there are six permutations : Write recursive function that generates all the permutations set numbers .
The general outline solution is given here , but the implementation is up to you .
The program will require storing set permutations numbers that you can implement in many ways example , linked lists nodes , linked lists vectors , arrays , Your program should call the recursive function with sets several different sizes , printing the resulting set permutations for each .

One solution is to first leave out the th item in the set .
Recursively find all permutations using the set items .
If we insert the nth item into each position for all these permutations , then we get new set permutations that includes the th item .
The base case is when there is only one item in the set , in which case the solution is simply the permutation with the single item .

For example , consider finding all permutations ,
We leave the out and recursively find all permutations the set ,
This consists the .

Next we insert the into every position for these permutations .
For the first permutation , we insert the in the front , between and , and after .

For the second permutation , we insert the in the front , between and , and after .

Programming Projects .
The word ladder game was invented by Lewis Carroll in .
The idea is to begin with start word and change one letter at time until arriving at an end word .
Each word along the way must be an English word .

For example , starting from FISH you can make word ladder to MAST through the following ladder : FISH , WISH , WASH , MASH , MAST Write program that uses recursion to find the word ladder given start word and an end word , or determines if no word ladder exists .
Use the file that is available online with the source code for the book as your dictionary valid words .
This file contains words .
Your program does not need to find the shortest word ladder between words , any word ladder will do if one exists .

Inheritance Inheritance Basics Derived Classes Constructors in Derived Classes Pitfall : Use Private Member Variables from the Base Pitfall : Private Member Functions Are Effectively Not Inherited The protected Qualifier Redefinition Member Functions Redefining Versus Overloading Access to Redefined Base Function Polymorphism Late Binding Virtual Functions in Virtual Functions and Extended Type Compatibility Pitfall : The Slicing Problem Pitfall : Not Using Virtual Member Functions Pitfall : Attempting to Compile Definitions Without Definitions for Every Virtual Member Function Programming Tip : Make Destructors Virtual Inheritance Details Functions That Are Not Inherited Assignment Operators and Copy Constructors in Derived Classes Destructors in Derived Classes Chapter Summary Answers to Exercises Practice Programs Programming Projects With all appliances and means to boot .

William Shakespeare , King Henry IV , Part III Introduction programming is popular and powerful programming technique .
Among other things , it provides for new of abstraction known as inheritance .
This means that very general form of class can be defined and compiled .
Later , more specialized versions of that class can be defined and can inherit all the properties of the previous class .
Facilities for inheritance are available in all versions of .

Prerequisites Section uses material from Chapters to and to .
Sections and use material from Chapters and in addition to Chapters to , to , and Section .

Carl Gustav Jung , The Integration of the Personality One of the most powerful features of is the use of inheritance to derive one from another .
Inheritance is the process by which new known as derived created from another  called the base .

derived automatically has all the member variables and functions that the base has and can have additional member functions additional member variables .

In Chapter , we noted that saying that is derived from another means that has all the features of and some extra , added features as well .
When is derived from , we say that is the base and is the derived .
We also say that is the child and is the parent Some authors speak of subclass and superclass instead of derived and base .
However , we have found the terms derived and base to be less confusing .
We only mention this in an effort to help you to read other texts .

You would like to control and interrogate the status of these devices , door is open , thermostat set to from your computer .
This would be much easier to accomplish if there was consistent interface for these disparate devices .

Inheritance lets us do this while providing way to organize our code without duplication .

First , consider the general concept of device in the home automation system .
Every device must have model and serial number .
Perhaps every device also has way to query its status .
We could model this with Device that has variables for the model and serial number , and function for the status .
The idea is that this contains functions and properties that are common to every possible device .

Second , consider the garage door .
This is specific type of device in the automation system .
In addition to having model , serial number , and way to query its status like every other device , the garage door device also has specific function to open or close the door .
We can model the garage door with DoorDevice .
We will need to add an function to this .
The DoorDevice is also where we would know how to return the status of the device .
At the level of the generic Device we have the needed information to return the status of specific device because at that level we even know what kind of device we are working with .

While we need to add functions to DoorDevice for the status and to close the door , it would be nice if we have to duplicate the variables and code to manipulate the model and serial number that we wrote for the Device .

Similarly , the thermostat device will also have model , serial number , and way to query its status in addition to function to set the temperature .

We can define ThermostatDevice with functions to set the temperature and return the status of the device , but it would be nice if we again have to duplicate the variables and code to manipulate the model and serial number that we wrote for the Device .

We can solve this problem with inheritance .
In this case , DoorDevice " Device and ThermostatDevice " Device .
By defining DoorDevice and ThermostatDevice as derived classes from Device , then these classes the programmer specifies have access to the model and serial number defined in Device and we need to any code in the Device that deals with these variables .
At the same time we can add specific code that is unique to our derived classes .
The relationship between these classes is illustrated in Display .

Once the inheritance relationship is defined , then if we create an object of type DoorDevice or ThermostatDevice we will have access to functions and variables defined in Device .
For example , if thermostat is variable of type ThermostatDevice then we could access if model is .

Display Example Inheritance Hierarchy for Home Automation base or parent Device string model .

inherits model and serialNumber from Device derived or child ThermostatDevice An object of type DoorDevice or ThermostatDevice includes functions and variables defined in Device , such as model and serialNumber .

The function can be overridden .
If DoorDevice object is treated like Device object , then calling will invoke function , not function .
This is necessary when the Device know what to return as status and only the derived classes can return the information .

This saves us the work of redefining the code and variables from the Device .

We can specify the function to behave bit differently .
When we define the same function in both the base and derived classses then we will see later in the chapter that we have two options : redefine the function or override the function .
In this case we want to override the function .
If we had an object thermostat of type ThermostatDevice , but then treat thermostat instead like it is of type Device example , by passing thermostat to function where the parameter is defined to be of type , then invoking will call the definition associated with ThermostatDevice rather than the definition associated with Device .
This behavior is important in this case because the Device class know what to return as the status .
This topic is explored in more detail in section .

We discussed how CD account is more specialized version of savings account .
By deriving the class CDAccount from SavingsAccount , we automatically inherit all of the SavingsAccount public functions and variables when we create CDAccount object .
uses inheritance in predefined classes as well .
In using streams for file , the predefined class ifstream is derived from the class istream by adding member functions such as open and close .
The stream cin belongs to the class of all input streams is , the class , but it does not belong to the class of streams is , does not belong to , partly because it lacks the member functions open and close of the derived class ifstream .

Derived Classes Suppose we are designing program that has records for salaried employees and hourly employees .
There is natural hierarchy for grouping these classes .
These are all classes of people who share the property of being employees .

Employees who are paid an hourly wage are one subset of employees .

Another subset consists of employees who are paid fixed wage each month or each week .
Although the program may not need any type corresponding to the set of all employees , thinking in terms of the more general concept of employees can be useful .
For example , all employees have names and Social Security numbers , and the member functions for setting and changing names and Social Security numbers will be the same for salaried and hourly employees .

Within you can define class called Employee that includes all employees , whether salaried or hourly , and then use this class to define classes for hourly employees and salaried employees .
Displays and show one possible definition for the class Employee .

You can have an Employee object , but our reason for defining the class Employee is so that we can define derived classes for different kinds of employees .
In particular , the function will always have its definition changed in derived classes so that different kinds of employees can have different kinds of checks .
This is reflected in the definition of the function for the class Employee .
It makes little sense to print check for such an Employee .
We know nothing about this salary details .
Consequently , we implemented the function of the class Employee so that the program stops with an error message if is called for base class Employee object .
As you will see , derived classes will have enough information to redefine the function to produce meaningful employee checks .

class that is derived from the class Employee will automatically have all the member variables of the class Employee , ssn , and .
class that is derived from the class Employee will also have all the member functions of the class Employee , such as , and the other .

Chapter Inheritance Display Interface for the Base Class Employee is the header file .

This is usually expressed by saying that the derived class inherits the member variables and member functions .

The interface files with the class definitions of two derived classes of the class Employee are given in Displays and .
We have placed the class Employee and the two derived classes in the same namespace .
does not require that they be in the same namespace , but since they are related classes , it makes sense to put them there .

We will first discuss the derived class HourlyEmployee given in Display .

Note that the definition of derived class begins like any other class definition but adds colon , the reserved word public , and the name of the Inheritance Basics is the file :

You only list the declaration of an inherited member function if you want to change the definition of the function .

Display Interface for the Derived Class SalariedEmployee is the header file .

Chapter Inheritance base class to the first line of the class definition , as in the following Display : class  public automatically receives all the public member variables and member functions of the base class as .
We can also add additional member variables and member functions to the derived class .

The definition of the class does not mention the member variables name , ssn , and , but every object of the class has member variables named name , ssn , and .
These member variables are inherited from the class Employee .
The class declares two additional member variables named and hours .
Thus , every object of the class has five member variables named name , ssn , pay , and hours .
Note that the definition of derived class as only lists the added variables .
The variables defined in the base class are not mentioned .

Just as it inherits the variables of the class Employee , the class inherits all the functions from the class Employee .

So , the class inherits the functions , ssn , and from the class Employee .

In addition to the inherited variables and functions , derived class can add new variables and new functions .
The new variables and the declarations for the new functions are listed in the class definition .
For example , the derived class adds the two variables and hours , and it adds the new functions named , and .
This is shown in Display .
Note that you do not give the declarations of the inherited functions except for those whose definitions you want to change , which is the reason we list only the function from the base class Employee .
For now , do not worry about the details of the constructor definition for the derived class .
We will discuss constructors in the next subsection .

In the implementation file for the derived class , such as the tion of in Display , you give the definitions of all the added functions .
Note that you do not give definitions for the inherited functions unless the definition of the function is changed in the derived class , point we discuss next .

The definition of an inherited function can be changed in the definition of derived class so that it has meaning in the derived class that is different from what it is in the base class .
This is called redefining the inherited function .
For example , the function is redefined in the definition of the derived class .
To redefine .

Chapter Inheritance Display for the Derived Class HourlyEmployee .

But note that allows us to drop the const in the function when we redefine it in derived class .

SalariedEmployee is another example derived class the class Parent and Child Classes When discussing derived classes , it is common to use terminology derived from family relationships .
base class is often called parent class .

derived class is then called child class .
This makes the language inheritance very smooth .
For example , we can say that child class inherits member variables and member functions from its parent class .

This analogy is often carried one step further .
class that is parent is often called an ancestor class .
If class is an ancestor class , then class is often called descendant class .

These inherited member functions and inherited member variables are , with one exception , not mentioned in the the derived class , but they are automatically the derived class .
As explained in the text , you do mention an inherited member function in the the derived class if you want to change the the inherited member function .

The interface for the class SalariedEmployee is given in Display .
An object declared to be type SalariedEmployee has all the member functions and member variables Employee and the new given in the the class SalariedEmployee .
This is true even though the class SalariedEmployee lists none the inherited variables and only lists one function from the class Employee , namely , the function check , which will have its changed in SalariedEmployee .
The class SalariedEmployee , nonetheless , has the three member variables name , ssn , and , as well as the member variable salary .
Notice that you do not have to declare the member variables and member functions the class Employee , such as name and , in order for SalariedEmployee to have these .
The class SalariedEmployee gets these inherited automatically without the programmer doing anything .

Note that the class Employee has all the code that is common to the two classes HourlyEmployee and SalariedEmployee .
This saves you the trouble writing identical code two times , once for the class HourlyEmployee and once for the class SalariedEmployee .
Inheritance allows you to reuse the code in the class Employee .

Constructors in Derived Classes constructor in base class is not inherited in the derived class , but you can invoke constructor the base class within the derived class constructor , and that is all you need or normally want .
constructor for derived class uses constructor from the base class in special way .
constructor for the base class initializes all the data inherited from the base class .
Thus , constructor for derived class begins with an invocation constructor for the base class .

There is special syntax for invoking the base class constructor that is .

Chapter Inheritance illustrated by the constructor definitions for the class HourlyEmployee given in Display .
In what follows we have reproduced minor changes in the line breaks to make it fit the text one the constructor definitions for the class HourlyEmployee taken from that display : string , double .

The portion after the colon is the initialization section the constructor for the constructor .
The part , is an invocation the constructor for the base class Employee .
Note that the syntax for invoking the base class constructor is analogous to the syntax used to set member variables : The entry sets the value the member variable invokes the base class constructor Employee with the arguments and .
Since all the work is done in the initialization section , the body the constructor is empty .

Here we reproduce the other constructor for the class HourlyEmployee from Display .

In this constructor the default version the base class constructor is called to initialize the inherited member variables .
You should always include an invocation one the base class constructors in the initialization section derived class constructor .

If constructor for derived class does not include an version the base class constructor will be invoked automatically .
So , the following the default constructor for the class HourlyEmployee is equivalent to the version we just .

In the same sort thing holds .
Since HourlyEmployee is derived class the class Employee , every object the class HourlyEmployee can be used anywhere an object the class Employee can be used .
In particular , you can use an argument type HourlyEmployee when function requires an argument of type Employee .
You can assign an object of the class HourlyEmployee to variable of type Employee .
After all , an Employee is not necessarily an Of course , the same remarks apply to any base class and its derived class .
You can use an object of derived class anywhere that an object of its base class is allowed .

More generally , an object of class type can be used anywhere that an object of any of its ancestor classes can be used .
If class Child is derived from class Ancestor and class Grandchild is derived from class Child , then an object of class Grandchild can be used anywhere an object of class Child can be used , and the object of class Grandchild can also be used anywhere that an object of class Ancestor can be used .

derived class object has all the member variables of the base class .

When derived class constructor is called , these member variables need to be allocated memory and should be initialized .
This allocation of memory for the inherited member variables must be done by constructor for the base class , and the base class constructor is the most convenient place to initialize these inherited member variables .
That is why you should always include call to one of the base class constructors when you define constructor for derived class .
If you do not include call to base class constructor the initialization section of the definition of derived class , then the default constructor of the base class is called automatically .
Thus , if class is derived from class and class is derived from class , then when an object of the class is created , first constructor for the class is called , then constructor for is called , and finally the remaining actions of the constructor are taken .

Chapter Inheritance Constructors in Derived Classes derived class does not inherit the constructors of its base class .

However , when defining constructor for the derived class , you can and should include call to constructor of the base class the initialization section of the constructor .

If you do not include call to constructor of the base class , then the default constructor of the base class will automatically be called when the derived class constructor is called .

Pitfall Use of Private Member Variables from the Base Class An object of the class HourlyEmployee and inherits member variable called name from the class Employee and .

For example , the following code would set the value of the member variable name of the object joe to .

But you must be bit careful about how you manipulate inherited member variables such as name .
The member variable name of the class HourlyEmployee was inherited from the class Employee , but the member variable name is private member variable in the definition of the class Employee .
That means that name can be directly accessed only within the definition of member that is private in base class is not accessible by name in the definition of member function for any other class , not even in member function definition of derived class .
Thus , although the class HourlyEmployee does have member variable named name from the base class , it is illegal to directly access the member variable name in the definition any member function in the class definition HourlyEmployee .

For example , the following are the first few lines from the body the member function from Display .

You might have wondered why we needed to use the member function to set the value the member variable .

As the comment indicates , this will not work .
The member variable is private member variable in the class Employee , and although derived class like HourlyEmployee inherits the variable  it cannot access it directly .

It must use some public member function to access the member variable The correct way to accomplish the definition in the class HourlyEmployee is the way we did it in Display part which was displayed .

The fact that name and are inherited variables that are private in the base class also explains why we needed to use the accessor functions and in the definition check instead simply using the variable names name and .

You cannot mention private inherited member variable by name .
You must instead use public accessor and mutator member functions as and that were defined in the base class .
Accessor and mutator functions were covered The fact that private member variable base class cannot be accessed in the definition member function derived class often seems wrong to people .
After all , if you are an hourly employee and you want to change your name , nobody says , name is private member variable the class " After all , if you are an hourly employee , you are also an employee .
In Java , this is also true ; an object the class HourlyEmployee is also an object the class Employee .
However , the laws on the use private member variables and member functions must be as we described , or else their privacy would be compromised .
If private member variables class were accessible in member function definitions derived class , then anytime you wanted to access private member variable , you could simply create derived class and access it in member function that class , which would mean that all private member variables would be accessible to anybody who wanted to put in little extra effort .
This adversarial scenario illustrates the problem , but the big problem is unintentional errors , not intentional subversion .
If private member variables class were accessible in member function definitions derived class , then the member variables might be changed by mistake or in inappropriate ways .

Chapter Inheritance We will discuss one possible way to get around this restriction on private member variables the base class in the subsection entitled protected Qualifier " bit later in this chapter .

Note that private member functions are just like private variables in terms not being directly available .
But in the case member functions , the restriction is more dramatic .
private variable can be accessed indirectly via an accessor or mutator member function .
private member function is simply not available .
It is just as if the private member function were not inherited .

Private member functions should just be used as helping functions , and so their use should be limited to the class in which they are defined .
If you want member function to be used as helping member function in number inherited classes , then it is not just helping function , and you should make the member function public .

There is classification member variables and functions that allows them to be accessed by name in derived class but not anyplace else , such as in some class that is not derived class .
If you use the qualifier protected , rather than private or public , before member variable or member function class , then for any class or function other than derived class , the effect is the same as if the member variable were labeled private ; however , in derived class the variable can be accessed by name .

For example , consider the class HourlyEmployee that was derived from the base class Employee .
We were required to use accessor and mutator member functions to manipulate the inherited member variables in the definition .
If all the private member variables in the class Employee were labeled with the keyword protected instead private , the definition in the derived class Employee could be simplified to the .

In the derived class HourlyEmployee , the inherited member variables   and can be accessed by  provided they are marked as protected opposed to in the base class Employee .
However , in any class that is not derived from the class Employee , these member variables are treated as if they were marked private .

Member variables that are protected in the base class act as though they were also marked protected in any derived class .
For example , suppose you define derived class PartTimeHourlyEmployee the class HourlyEmployee .

The class PartTimeHourlyEmployee inherits all the member variables the class HourlyEmployee , including the member variables that HourlyEmployee inherits from the class Employee .
So , the class PartTimeHourlyEmployee will have the member variables   and .
If these member variables were marked protected in the class Employee , then they can be used by in the definitions functions the class PartTimeHourlyEmployee .
Except for derived classes derived classes derived classes , member variable that is marked protected is treated the same as if it were marked private .

We include discussion protected member variables primarily because you will see them used and should be familiar with them .
Many , but not all , programming authorities say it is bad style to use protected member variables .
They say it compromises the principle hiding the class implementation and that all member variables should be marked private .

If all member variables are marked private , the inherited member variables cannot be accessed by in derived class function definitions .
However , this is not as bad as its sounds .
The inherited private member variables can be accessed indirectly by invoking inherited functions that either read or change the private inherited variables .
Since authorities differ , you will have to make your own decision on whether or not to use protected members .

Protected Members If you use the qualifier protected , rather than private or public , before member variable class , then for any class or function other than derived class derived class derived class , the .

Chapter Inheritance situation is the same as if the member variable were labeled private .

However , in the definition member function derived class , the variable can be accessed by .
Similarly , if you use the qualifier protected before member function class , then for any class or function other than derived class derived class derived class , that is the same as if the member function were labeled private .

However , in the definition member function derived class the protected function can be used .

Inherited protected members are inherited in the derived class as if they were marked protected in the derived class .
In other words , if member is marked as protected in base class , then it can be accessed by in the definitions all descendant classes , not just in those classes directly derived from the base class .

est Exe rc is es .
Is the following program legal appropriate and .

This class should have an additional data field , crazy , that is type bool , one additional member that takes no arguments and returns value type bool , and suitable constructors .

You do not need to give any implementations , just the class definition .

Is the following legal definition the member in the derived class SmartBut discussed in Exercise .
Explain your answer .

Redefinition Member Functions In the definition the derived class HourlyEmployee , we gave the declarations for the new functions , and .
We also gave the declaration for only one the functions inherited from the class Employee .
The inherited functions whose declarations were not given as and are inherited unchanged .
They have the same in the class HourlyEmployee as they do in the base class Employee .
When you define derived class like HourlyEmployee , you list only the declarations for the inherited functions whose definitions you want to change to have different in the derived class .
If you look at the implementation the class HourlyEmployee , given in Display , you will see that we have redefined the inherited .
The class SalariedEmployee also gives new to the , as shown in Display .
Moreover , the two classes give different definitions from each other .

Chapter Inheritance Redefining an Inherited Function derived class inherits all the functions variables as that belong to the base class .
However , if derived class requires different implementation for an inherited  the may be redefined in the derived class .
When is redefined , you must list its declaration in the of the derived class even though the declaration is the same as in the base class .
If you do not wish to redefine that is inherited from the base class , then it is not listed in the of the derived class .

Display for the Derived Class SalariedEmployee is the file .

Display gives demonstration program that illustrates the use the derived classes HourlyEmployee and SalariedEmployee .

The functions , and are inherited unchanged from the class Employee .
The function is redefined .
The function was added to the derived class HourlyEmployee .

Sample Dialogue Check Mighty Joe hours .

Hours worked : Rate : Pay : Check Mr .
Big Shot Pay to the order Mr .
Big Shot The sum Dollars Check Stub NOT NEGOTIABLE Employee  Salaried Employee .
Regular Pay : Redefining Versus Overloading Do not confuse redefining definition in derived class with overloading name .
When you redefine definition , the new definition given in the derived class has the same number and Inheritance Basics types parameters .
On the other hand , if the in the derived class were to have different number parameters or parameter different type from the in the base class , then the derived class would have both functions .

For example , suppose we added with the following declaration to the definition the class HourlyEmployee : void , string .

This would be overloading the name .

On the other hand , both the class Employee and the class HourlyEmployee define with the following declaration : void ; In this case , the class HourlyEmployee has only one named , but the definition the the class HourlyEmployee is different from its definition the class Employee .
In this case , the has been redefined .

If you get redefining and overloading confused , you do have one consolation .

So , it is more important to learn how to use them than it is to learn to distinguish between them .
Nonetheless , you should learn the difference .

Signature signature is the name with the sequence types in the parameter list , not including the const keyword and not including the ampersand .
When you overload name , the two definitions the name must have different signatures using this definition If has the same name in derived class as in the base class but has different signature , that is overloading , not redefinition .

Some compilers may allow overloading on the basis const versus no const , but you cannot count on this and so should not do it .
For this reason , some definitions the const modifier , but this is cloudy issue that is best avoided until you become an expert .

Chapter Inheritance Access to Redefined Base Function VideoNote Inheritance Example Suppose you redefine so that it has different definition in the derived class from what it had in the base class .
The definition that was given in the base class is not completely lost to the derived class objects .
However , if you want to invoke the version of the given in the base class with an object in the derived class , you need some way to say the definition of this as given in the base class though am an object of the derived " The way you say this is to use the scope resolution operator with the name of the base class .
An example should clarify the details .

Consider the base class Employee and the derived class HourlyEmployee .

But , suppose you want to invoke the version of given in the definition of the base class Employee with the derived class object as the calling object .
You do that as follows : Of course , you are unlikely to want to use the version of given in the particular class Employee , but with other classes and other functions , you may occasionally want to use definition from base class with derived class object .
An example is given in Exercise .

est Exe rc is es .
The class SalariedEmployee inherits both of the functions and other from the base class Employee , yet only the declaration the is given in the definition of the class SalariedEmployee .
Why the declaration the given in the definition of SalariedEmployee .

Give definition for class TitledEmployee that is derived class of the base class SalariedEmployee given in Display .
The class Inheritance Details TitledEmployee has one additional member variable of type string called title .
It also has two additional member functions : which takes no arguments and returns string ; and , which is void that takes one argument of type string .
It also redefines the member .
You do not need to give any implementations , just the class definition .
However , do give all needed directives and all using namespace directives .
Place the class TitledEmployee in the namespace employeessavitch .

Give the definitions of the constructors for the class TitledEmployee that you gave as the answer to Exercise .
Also , give the redefinition of the member .
The should insert the title into the name .
Do not bother with directives or namespace details .

Common Saying This section presents some of the more subtle details about inheritance .
Most of the topics are relevant only to classes that use dynamic arrays or pointers and other dynamic data .

Functions That Are Not Inherited As general rule if Derived is derived class with base class Base , then all " functions in the class Base are inherited members of the class Derived .
However , there are some special functions that are , for all practical purposes , not inherited .
We have already seen that , as practical matter , constructors are not inherited and that private member functions are not inherited .
Destructors are also effectively not inherited .

In the case of the copy constructor , it is not inherited , but if you do not define copy constructor in derived class any class for that , will automatically generate copy constructor for you .
However , this default copy constructor simply copies the contents of member variables and does not work correctly for classes with pointers or dynamic data in their member variables .
Thus , if your class member variables involve pointers , dynamic arrays , or other dynamic data , then you should define copy constructor for the class .
This applies whether or not the class is derived class .

The assignment is also not inherited .
If the base class Base defines the assignment  but the derived class Derived does not the assignment  then the class Derived will have an assignment  but it will be the default assignment that creates .

Chapter Inheritance you do not ; it will not have anything to do with the base class assignment defined in Base .

It is natural that constructors , destructors , and the assignment are not inherited .
To correctly perform their tasks , they need information that the base class does not possess .
To correctly perform their functions , they need to know about the new variables introduced in the derived class .

Assignment Operators and Copy Constructors in Derived Classes Overloaded assignment operators and constructors are not inherited .

However , they can be , and in almost all cases must be , used in the definitions of overloaded assignment operators and copy constructors in derived classes .

When overloading the assignment in derived class , you normally use the overloaded assignment from the base class .
We will present an outline of how the code for doing this is written .
To help understand the code outline , remember that an overloaded assignment must be defined as function of the class .

If is class derived from  then the definition of the overloaded assignment for the class would typically begin with something like the .

The first line of code in the body of the definition is call to the overloaded assignment of the class .
This takes care of the inherited variables and their data .
The definition of the overloaded assignment would then go on to set the new variables that were introduced in the definition of the class .

similar situation holds for defining the copy constructor in derived class .
If is class derived from  then the definition of the copy constructor for the class would typically use the copy constructor for the class to set up the inherited variables and their data .
The code would typically begin with something like the .

The invocation of the base class copy constructor sets up the inherited variables of the class being created .
Note that since is of type  it is also of type  therefore , is legal argument to the copy constructor for the class .

Of course , these techniques do not work unless you have correctly functioning assignment and correctly functioning copy constructor Inheritance Details for the base class .
This means that the base class definition must include copy constructor and that either the default automatically created assignment must work correctly for the base class or the base class must have suitable overloaded definition of the assignment .

Destructors in Classes If base class has correctly functioning destructor , then it is relatively easy to correctly functioning destructor in class derived from the base class .

When the destructor for the derived class is invoked , it automatically invokes the destructor of the base class , so there is no need for the explicit writing of call to the base class destructor ; it always happens automatically .
The derived class destructor therefore need only worry about using delete on the variables any data they point that are added in the derived class .
It is the job of the base class destructor to invoke delete on the inherited variables .

If class is derived from class and class is derived from class , then when an of the class goes out of scope , first the destructor for the class is called , then the destructor for class is called , and finally the destructor for class is called .
Note that the order in which destructors are called is the reverse of the order in which constructors are called .

est Exerc is es .
You know that an overloaded assignment and copy constructor are not inherited .
Does this mean that if you do not an overloaded assignment or copy constructor for derived class , then that derived class will have no assignment and no copy constructor .

Suppose Child is class derived from the class Parent , and the class Grandchild is class derived from the class Child .
This question is concerned with the constructors and destructors for the three classes Parent , Child , and Grandchild .
When constructor for the class Grandchild is invoked , what constructors are invoked and in what order .
When the destructor for the class Grandchild is invoked , what destructors are invoked and in what order .

Give the definitions for the function , the copy constructor , the overloaded assignment  and the destructor for the following class .
This class is intended to be class for partially filled array .
The variable contains the number of array positions currently filled .
The other constructor definition is given to help you get started .

We tend to agree .
However , using protected makes for better practice assignment , and you should have some experience .
Define class called PartFilledArrayWMax that is derived class of the class PartFilledArray .
The class PartFilledArrayWMax has one additional variable named that holds the maximum value stored in the array .
Define accessor function named that returns the maximum value stored in the array .
Redefine the function and two constructors , one of which has an int argument for the maximum number of entries in the array .

Also copy constructor , an overloaded assignment  and destructor .

HENRY ADAMS , The Education of Henry Adams Polymorphism refers to the ability to associate multiple meanings to one function name .
As it has come to be used today , polymorphism refers to very particular way of associating multiple meanings to single function Polymorphism name .
That is , polymorphism refers to the ability to associate multiple meanings to one function name by means of special mechanism known as late binding .
Polymorphism is one of the key components of programming philosophy known as programming .
Late binding , and therefore polymorphism , is the topic of this section .

Late Binding virtual function is one that , in some sense , may be used before it is defined .

For example , graphics program may have several kinds of figures , such as rectangles , circles , ovals , and so forth .
Each figure might be an of different class .
For example , the Rectangle class might have variables for height , width , and center point , while the Circle class might have variables for center point and radius .
In programming project , all of them would probably be descendants of single parent class called , for example , Figure .
Now , suppose you want function to draw figure on the screen .
To draw circle , you need different instructions from those you need to draw rectangle .
So , each class needs to have different function to draw its kind of figure .
However , because the functions belong to the classes , they can all be called draw .
If is Rectangle and c is Circle object , then and can be functions implemented with different code .
All this is not news , but now we move on to something  functions defined in the parent class Figure .

Now , the parent class Figure may have functions that apply to all figures .

For example , it might have function called center that moves figure to the center of the screen by erasing it and then redrawing it in the center of the screen .
might use the function draw to redraw the figure in the center of the screen .
When you think of using the inherited function center with figures of the classes Rectangle and Circle , you begin to see that there are complications here .

To make the point clear and more dramatic , suppose the class Figure is already written and in use and at some later time we add class for brandnew kind of figure , say , the class Triangle .
Now , Triangle can be derived class of the class Figure , and so the function center will be inherited from the class Figure ; thus , the function center should apply to perform correctly all Triangles .

The function center uses draw , and the function draw is different for each type of figure .
The inherited function center nothing special is will use the definition of the function draw given in the class Figure , and that function draw does not work correctly for Triangles .
We want the inherited function center to use the function rather than the function .
But the class Triangle , and therefore the function , was not even written when the function center in the class was written and compiled .
How can the function center possibly work correctly for Triangles .
The compiler did not know anything about at .

Chapter Inheritance the time that center was compiled .
The answer is that it can apply provided draw is function .

When you make function  you are telling the compiler , do not know how this function is implemented .
Wait until it is used in program , and then get the implementation from the object " The technique of waiting until to determine the implementation of procedure is called late binding or dynamic binding .
Virtual functions are the way provides late binding .

We need an example to make this come alive to teach you how to use functions in your .
In order to explain the details of functions in , we will use simplified example from an application area other than drawing figures .

Virtual Functions in Suppose you are designing program for an automobile parts store .
You want to make the program versatile , but you are not sure you can account for all possible situations .
For example , you want to keep track of sales , but you cannot anticipate all types of sales .
At first , there will be only regular sales to retail customers who go to the store to buy one particular part .

However , later you may want to add sales with discounts , or sales with shipping charge .
All these sales will be for an item with basic price and ultimately will produce some bill .
For simple sale , the bill is just the basic price , but if you later add discounts , then some kinds of bills will also depend on the size of the discount .
Your program will need to compute daily gross sales , which intuitively should just be the sum of all the individual sales bills .

You may also want to calculate the largest and smallest sales of the day or the average sale for the day .
All these can be calculated from the individual bills , but the functions for computing the bills will not be added until later , when you decide what types of sales you will be dealing with .
To accommodate this , we make the function for computing the bill function .
All types of sales will be derived classes of the class Sale .
The class Sale corresponds to simple sales of single item with no added discounts or charges .
Notice the reserved word in the function declaration for the function bill .
Notice that the member function savings and the overloaded operator both use the function bill .

Since bill is declared to be function , we can later define derived classes of the class Sale and define their versions of the function bill , and the definitions of the member function savings and the overloaded operator , which we gave with the class Sale , will use the version of the function bill that corresponds to the object of the derived class .

For example , Display shows the derived class .
Notice that the class requires different definition for its version of the function .
Nonetheless , when the member function savings and the overloaded are used with an object of the class  they will use the version of the function definition for that was given is the interface for the class .

Consider the function call for objects and of the class .
The definition of the function savings for an object of the class is given in the implementation file for the base class  which was compiled before we ever even thought of the class Yet , in the function call , the line that calls the function knows enough to use the definition of the function given for the class .

In order to write programs , you can just assume it happens by magic , but the real explanation was given in the introduction to this section .
When you label function virtual , you are telling the environment , until this function is used in program , and then get the Display gives sample program that illustrates how the virtual function and the functions that use work in complete program .

Discounted item cheaper .

Savings There are number of technical details you need to know in order to use virtual functions in .
We list them .

If function will have different definition in derived class than in the base class and you want it to be virtual function , you add the keyword virtual to the function declaration in the base class .
You do not need to add the reserved word virtual to the function declaration in the derived class .
If function virtual in the base class , then it automatically virtual in the derived class .

The reserved word virtual added to the function declaration and not to the function definition .

You do not get virtual function and the benefits of virtual functions unless you use the keyword virtual .

Since virtual functions are so great , why not make all member functions virtual .
Almost the only reason for not always using virtual functions Polymorphism efficiency .
The compiler and the environment need to do much more work for virtual functions , and so if you label more member functions virtual than you need to , your programs will be less efficient .

Overriding When virtual function definition changed in derived class , programmers often say the function definition overridden .
In the literature , distinction sometimes made between the terms redefined and overridden .
Both terms refer to changing the definition of the function in derived class .
If the function virtual function , called overriding .
If the function not virtual function , called redefining .

This may seem like silly distinction to you , the programmer , since you do the same thing in both cases , but the two cases are treated differently by the compiler .

Polymorphism The term polymorphism refers to the ability to associate multiple meanings to one function name by means of late binding .
Thus , polymorphism , late binding , and virtual functions are really all the same topic .

est Exerc .
Suppose you modify the definitions of the class Sale by deleting the reserved word virtual .
How would that change the output of the program in Display .

Virtual Functions and Extended Type Compatibility We will discuss some of the further consequences of declaring class member function to be virtual and do one example that uses some of these features .

fairly strongly typed language .
This means that the types of items are always checked and an error message issued if there type mismatch ,

Chapter Inheritance such as type mismatch between an argument and formal parameter when there no conversion that can be automatically invoked .
This also means that normally the value assigned to variable must match the type of the variable , although in few cases will perform an automatic type cast so that it appears that you can assign value of one type to variable of another type .
For example , allows you to assign value of type char or int to variable of type double .
However , does not allow you to assign value of type double or float to variable of any integer type , short , int ,

However , as important as strong typing  this strong type checking interferes with the very idea of inheritance in programming .

Suppose you have defined class and class and have defined objects of type class and class .
You cannot always assign between objects of these types .
For example , suppose program or unit contains the following type declarations : class Pet .

Now concentrate on the data members , and .
In real application , they Anything that Dog also Pet .
It would seem to make sense to allow programs to consider values of type Dog to also be values of type Pet , and hence the following should be .

does allow this sort of assignment .
You may assign value , such as the value of vdog , to variable of parent type , such as  but you are not allowed to perform the reverse assignment .
Although the assignment above allowed , the value that assigned to the variable loses its Polymorphism field .
This called the slicing problem .
The following attempted access will produce an error message : class Pet has no member named You can argue that this makes sense , since once Dog moved to variable of type Pet it should be treated like any other Pet and not have properties peculiar to Dogs .
This makes for lively philosophical debate , but it usually just makes for nuisance when programming .
The dog named Tiny still Great Dane and we would like to refer to its  even if we treated it as Pet someplace along the line .

Fortunately , does offer us way to treat as Pet without throwing away the of the .
To do this , we use pointers to dynamic object instances .
Suppose we add the following declarations : Pet ;

Sample Dialogue  Tiny  Great Dane  Tiny  Great Dane Pitfall The Slicing Problem Although it is legal to assign derived class object to base class variable , assigning derived class object to base class object slices off data .
Any data members in the derived class object that are not also in the base class will be lost in the assignment , and any member functions that are not defined in the base class are similarly unavailable to the resulting base class object .

If we make the following declarations and .

Chapter Inheritance Pitfall Not Using Virtual Member Functions In order to get the benefit of the extended type compatibility we discussed earlier , you must use virtual member functions .
For example , suppose we had not used member functions in the example in Display .
Suppose that in place of .

The reason for this is that the expression has its type determined by the pointer type of .
It is pointer type for the type Pet , and the type Pet has no field named .

But was declared virtual by the base class , Pet .
So , when the compiler sees the call .

programming with dynamic variables is very different way of viewing programming .
This can all be bewildering at first .
It will help if you keep two simple rules in mind :
If the domain type of the pointer is base class for the domain type of the pointer , then the following assignment of pointers is allowed : Moreover , none of the data members or member functions of the dynamic variable being pointed to by will be lost .

Although all the extra fields of the dynamic variable are there , you will need virtual member functions to access them .

This means code little , then test little , then code little more , and test little more , and so forth .
However , if you try to compile classes with virtual member functions but do not implement each member , you may run into some very hard to understand error messages , even if you do not call the undefined member functions .

If any virtual member functions are not implemented before compiling , then the compilation fails with error messages similar to this : reference to virtual " Even if there is no derived class and there is only one virtual member , this kind of message still occurs if that function does not have definition .

What makes the error messages very hard to decipher is that without definitions for the functions declared virtual , there may be further error messages complaining about an undefined reference to default constructors , even if these constructors really are already defined .

Consider the following code , where is class with destructor that is not virtual : new .

Now , see what happens when destructor is marked as virtual .

The easiest way to describe how destructors interact with the virtual function mechanism is that destructors are treated as if all destructors had the same though they do not really have the same .
For example , suppose is derived class of the class and suppose the destructor in the class is marked virtual .
Now consider the following code : new .

When delete is invoked with  destructor is called .

Chapter Inheritance  the destructor for the class is called it in turn calls the destructor for the class .
If the destructor in the class had not been declared as virtual , then only the destructor in the class would be called .

Another point to keep in mind is that when destructor is marked as virtual , then all destructors of derived classes are automatically virtual or not they are marked .
Again , this behavior is as if all destructors had the same though they do .

Now we are ready to explain why all destructors should be virtual .
Suppose the class has member variable pB of pointer type , the constructor for the class creates dynamic variable pointed to by pB , and the destructor for the class deletes the dynamic variable pointed to by pB .
And suppose the destructor for the class is not marked virtual .
Also suppose that the class is derived from has member variable pD of pointer type , the constructor for the class creates dynamic variable pointed to by pD , and the destructor for the class deletes the dynamic variable pointed to by pD .
Consider the following code : new .

This will return to the freestore the memory for the dynamic variable pointed to by pB , but the memory for the dynamic variable pointed to by pD will never be returned to the freestore the program .

On the other hand , if the destructor for the base class were marked virtual , then when delete is applied to  the destructor for the class would be invoked the object pointed to is of type .

The destructor for the class Derive would delete the dynamic variable pointed to by pD and then automatically invoke the destructor for the base class  and that would delete the dynamic variable pointed to by pB .
So , with the base class destructor marked as virtual , all the memory is returned to the freestore .
To prepare for eventualities such as these , it is best to always mark destructors as virtual .

Why we assign base class object to derived class variable .

What is the problem with the assignment of derived class object to base class variable .

Suppose the base class and the derived class each have member function with the same signature .
When you have pointer to base class object Answers to Exercises and call function member through the pointer , discuss what determines which function is actually base class member function or the function .

Chapter Summary Inheritance provides tool for code reuse by deriving one class from another and by adding features to the derived class .

Virtual functions are what uses to achieve late binding .
Polymorphism , late binding , and virtual functions are really all the same topic .

You can plug in an object of derived class for parameter of the base class type .
An HourlyEmployee is an Employee .
SalariedEmployee is an Employee .

It is legal because and are marked protected in the base class Smart and so they can be accessed by name in derived class .
If and had been marked private , then this would be illegal .

The declaration for the function is not given in the definition of SalariedEmployee because it is not redefined in the class Employee .
It is inherited unchanged from the base class Employee .

If you do not define an overloaded assignment operator or copy constructor for derived class , then default assignment operator and default copy constructor will be defined for the derived class .
However , if the class involves pointers , dynamic arrays , or other dynamic data , then it is almost certain that neither the default assignment operator nor the default copy constructor will behave as you want them to .

The constructors are called in the following order : first Parent , then Child , and finally Grandchild .
The destructors are called in the reverse order : first Grandchild , then Child , and finally Parent .

Discounted item is not cheaper .

There would be no member to assign to the derived added members .

Although it is legal to assign derived class object to base class variable , this discards the parts of the derived class object that are not members of the base class .
This situation is known as the slicing problem .

If the base class function carries the virtual modifier , then the type of the object to which the pointer was initialized determines whose member function is called .
If the base class member function does not have the virtual modifier , then the type of the pointer determines whose member function is called .

Practice Programs Practice Programs can generally be solved with short program that directly applies the programming principles presented in this chapter .

Write program that uses the class SalariedEmployee in Display .

Your program is to define class called Administrator , which is to be derived from the class SalariedEmployee .
You are allowed to change in the base class to protected .
You are to supply the following additional data and function members : member variable of type string that contains the title as Director or Vice .

Chapter Inheritance member variable of type string that contains the company area of responsibility as Production , Accounting , or .

member variable of type string that contains the name of this immediate supervisor .

protected : member variable of type that holds the annual salary .
It is possible for you to use the existing salary member if you did the change recommended earlier .

member function called , which changes the supervisor name .

member function for reading in an data from the keyboard .

member function called print , which outputs the data to the screen .

An overloading of the member function with appropriate notations on the check .

Add temporary , administrative , permanent , and other classifications of employee to the hierarchy from Displays , and .
Implement and test this hierarchy .

user interface with menu would be nice touch for your test program .

VideoNote Solution to Practice Program .
Listed below are definitions of two classes that use inheritance , code for their implementation , and main function .
Put the code into appropriate files with the necessary include statements and preprocessor statements so that the program compiles and runs .
It should output has radius and area .

Chapter Inheritance retrieve the and  and an appropriately defined function that calculates the of the rectangle .

The following code added to main should output has has and .

Programming Projects Programming Projects require more than Practice Programs and can usually be solved many different ways .
Visit to complete many of these Programming Projects online and get instant feedback .

VideoNote Solution to Programming Project .
Give the definition of class named Doctor whose objects are records for doctors .
This class will be derived class of the class Employee given in Display .
Doctor record has the specialty as " so use type and office visit fee type .
Be sure your class has reasonable complement of constructors , accessor , and mutator member functions , an overloaded assignment  and copy constructor .

Write driver program to test all your functions .

Create base class called Vehicle that has the , number of cylinders in the engine , and owner Person , given .
Then create class called Truck that is derived from Vehicle and has additional properties : the load capacity in tons since it may contain fractional and towing capacity in pounds .
Be sure your classes have reasonable complement of constructors , accessor , and mutator member functions , an overloaded assignment  and copy constructor .
Write driver program that tests all your member functions .

The definition of the class follows .
The implementation of the class is part of this Programming Project .

Define Car class that is derived from the Vehicle class given in Programming Project .
Define class called SportsCar that is derived from Car class .
Be creative in choosing member variables and functions .

Give the definition of two classes , Patient and Billing , whose objects are records for clinic .
Patient will be derived from the class given in Programming Project .
Patient record has the from the class and primary physician , of type Doctor defined in Programming Project .
Billing object will contain Patient object , Doctor object , and an amount due of type double .
Be sure your classes have reasonable complement of constructors , accessor , and mutator member functions , an overloaded assignment  and copy constructor .
First write driver program to test all your member functions , and then write test program that creates at least two patients , at least two doctors , and at least two Billing records , then prints out the total income from the Billing records .

Consider graphics system that has classes for various , squares , triangles , circles , and so on .
For example , rectangle might have data members for   and center point , while square and circle might have only center point and an edge length or  respectively .

In system , these would be derived from common class , Figure .
You are to implement such system .

The class Figure is the base class .
You should add only Rectangle and Triangle classes derived from Figure .
Each class has stubs for member functions erase and draw .
Each of these member functions outputs message telling what function has been called and what the class of the calling object is .
Since these are just stubs , they do nothing more than output this message .
The member function center calls the erase and draw functions to erase and redraw the figure at the center .
Since you but will call the member functions erase and draw .
Also add an output message in the member function center that announces that center is being called .
The member functions should take no arguments .

There are three parts to this project :
Write the class definitions using no virtual functions .
Compile and test .

Compile and test .

Chapter Inheritance For real example , you would have to replace the definition of each of these member functions with code to do the actual drawing .
You will be asked to do this in Programming Project .

Use the following main function for all .

Flesh out Programming Project .
Give new for the various constructors and the member functions , and so that the draw functions actually draw figures on the screen by placing the character ' at suitable locations .
For the erase functions , you can simply clear the screen outputting blank lines or by doing something more .
There are lot of details in this problem , and you will have to make decisions about some of them on your own .

Banks have many different types of accounts , often with different rules for fees associated with transactions such as withdrawals .
Customers are allowed to transfer funds between accounts incurring the appropriate fees associated with withdrawal of funds from one account .

Write program with base class for bank account and two derived classes described representing accounts with different rules for withdrawing funds .
Also write function that transfers funds from one account any to another .
transfer is withdrawal from one account and deposit into the other .
Since the transfer can be done at any time with any type of account , the withdraw function in the classes must Programming Projects be virtual .
Write main program that creates three accounts from each and tests the transfer function .

For the classes , create base class called BankAccount that has the name of the owner of the account and the balance in the account as data members .
Include member functions deposit and withdraw with double for the amount as an and accessor functions getName and getBalance .
Deposit will add the amount to the balance the amount is and withdraw will subtract the amount from the balance the amount is nonnegative and less than or equal to the .
Also create class called MoneyMarketAccount that is derived from BankAccount .
In MoneyMarketAccount the user gets two free withdrawals in given period of time worry about the time for this .
After the free withdrawals have been used , withdrawal fee of is deducted from the balance per withdrawal .
Hence , the class must have data member to keep track of the number of withdrawals .
It also must override the withdraw definition .
Finally , create CDAccount class model Certificate of derived from BankAccount that in addition to having the name and balance also has an interest rate .
CDs incur penalties for early withdrawal of funds .
Assume that withdrawal of funds incurs penalty of of the annual interest earned on the account .
Assume the amount withdrawn plus the penalty are deducted from the account balance .
Again , the withdraw function must override the one in the base class .
For all three classes , the withdraw function should return an integer indicating the status ok or insufficient funds for the withdrawal to take .
For the purposes of this exercise , do not worry about other functions and properties of these accounts as when and how interest is .

They behave like wireless barcodes and can wirelessly broadcast an identification number to receiver .
One application of RFID chips is to use them to aid in the logistics of shipping freight .
Consider shipping container full of items .
Without RFID chips , human has to manually inventory all of the items in the container to verify the contents .

With an RFID chip attached to the shipping container , the RFID chip can electronically broadcast to human the exact contents of the shipping container without human intervention .

To model this application , write base class called ShippingContainer that has container ID number as an integer .
Include member functions to set and access the ID number .
Add virtual function called getManifest that returns an empty string .
The purpose of this function is to return the contents of the shipping container .

Chapter Inheritance Create derived called ManualShippingContainer that represents the manual method of inventorying the container .
In this method , human simply attaches textual description of all contents of the container .
For example , the description might be crates of apples .

Add function called setManifest that sets this string .
Override the getManifest function so that it returns this string .

Create second derived called RFIDShippingContainer that represents the RFID method of inventorying the container .
To simulate what the RFID chips would compute , create an add function to simulate adding an item and their quantity using the data structures of your choice .
For example , if the add function were invoked three times as follows : of ; Add one crate of pears of ; Add one crate of apples of ; Add one crate of pears At this point , the data structure should be storing list of two items : crate of apples and crate of pears .
The quantity of apples is the quantity of pears is .
Override the getManifest function so that it returns string of all items that is built by traversing the list of items .
In the example above , Programming Projects The ants behave according to the following model : Move .

Every time step , randomly try to move up , down , left , or right .
If the neighboring cell in the selected direction is occupied or would move the off the grid , then the stays in the current cell .

If an survives for three time steps , then at the end of the time step is ; after the will breed .
This is simulated by creating new in an adjacent , down , left , or cell that is empty .

If there is no empty cell available , then no breeding occurs .
Once an offspring is produced , an cannot produce an offspring until three more time steps have elapsed .

The doodlebugs behave according to the following model : Move .

Every time step , if there is an adjacent , down , left , or , then the will move to that cell and eat the .
Otherwise , the moves according to the same rules as the .
Note that cannot eat other doodlebugs .

If survives for eight time steps , then at the end of the time step it will spawn off new in the same manner as the .

If has not eaten an within the last three time steps , then at the end of the third time step it will starve and die .
The should then be removed from the grid of cells .

During one turn , all the doodlebugs should move before the ants do .

Write program to implement this simulation and draw the world using ASCII characters of " for an and " for .
Create named Organism that encapsulates basic data common to both ants and doodlebugs .
This should have virtual function named move that is defined in the derived classes of Ant and Doodlebug .
You may need additional data structures to keep track of which critters have moved .

Initialize the world with doodlebugs and ants .
After each time step , prompt the user to press Enter to move to the next time step .
You should see cyclical pattern between the population of predators and prey , although random perturbations may lead to the elimination of one or both species .

Listed below is code to play guessing game .
In the game two players to number .
Your task is to extend the program with objects function requires you include cstdlib Appendix .

Solution to Programming Project .

The implementation of can simply return .
Next , define named HumanPlayer derived from Player .
The implementation of should prompt the user to enter number and return the value entered from the keyboard .
Next , define named ComputerPlayer derived from Player .
The implementation of should randomly select number between and Appendix for information on random number .

Finally , construct main function that invokes , Player with two instances of HumanPlayer versus , an instance of HumanPlayer and ComputerPlayer versus , and two instances of ComputerPlayer versus .

The computer player in Programming Project does not play very well in the number guessing game , since it only makes random guesses .
Modify the program so that the computer plays more informed game .
The strategy is up to you , but you must add to the Player and omputerPlayer classes so that the , Player Programming Projects function can send the results of back to the computer player .
In other words , the computer must be told if its last was too or too  and it also must be told if its opponent ' last was too or too .
The computer then can use this information to revise its next .
Also , add any necessary functions to allow the computer player to play multiple consecutive games .

Start with the definition of the Queue class given in Section and modify it to store integers instead of characters .
special type of queue is priority queue .
priority queue behaves like regular queue except the remove function always extracts the item with the smallest value is the item with the highest .
Create PriorityQueue class that is derived from the Queue class with appropriate constructors .
Redefine the remove function in the PriorityQueue class to extract the item with the smallest value .
Test the PriorityQueue class by adding several numbers to riorityQueue object , then remove each one , printing the removed numbers as they are removed from the queue .

The following is an attempt to create class to represent information about pets : class Pet .

Rewrite this code using inheritance .
You should have Pet class with subclasses for Dog , Cat , and Bird .
Variables should be associated with the appropriate classes , defined as private when appropriate , and have appropriate functions to access the variables .
Rewrite the printDescription function as virtual function .
There should no longer be the need for switch statement or type variable .

Write main function that creates vector or array of pets that includes at least one bird , one dog , and one cat , and then loops through and outputs description of each one .

Exception Handling Basics Toy Example of Exception Handling Defining Your Own Exception Classes Multiple Throws and Catches Pitfall : Catch the More Specific Exception First Programming Tip : Exception Classes Can Be Trivial Throwing an Exception in Function Exception Specification Pitfall : Exception Specification in Derived Classes Techniques for Exception Handling When to Throw an Exception Pitfall : Uncaught Exceptions Pitfall : Nested Blocks Pitfall : Overuse of Exceptions Exception Class Testing for Available Memory Rethrowing an Exception Chapter Summary Answers to Exercises Practice Programs Programming Projects the exception that proves the rule .

Introduction One way to write program is to first assume that nothing unusual or incorrect will happen .
For example , if the program takes an entry off list , you might assume that the list is not empty .
Once you have the program working for the core situation where things always go as planned , you can then add code to take care of the exceptional cases .
In , there is way to reflect this approach in your code .
Basically , you write your code as if nothing very unusual happens .
After that , you use the facilities to add code for those unusual cases .
Exception handling is commonly used to handle error situations , but perhaps better way to view exceptions is as way to handle " After all , if your code correctly handles an " then it no longer is an error .

Perhaps the most important use of exceptions is to deal with functions that have some special case that is handled differently depending on how the function is used .
Perhaps the function will be used in many programs , some of which will handle the special case in one way and some of which will handle it in some other way .
For example , if there is division by zero in the function , then it may turn out that for some invocations of the function , the program should end , but for other invocations of the function something else should happen .
You will see that such function can be defined to throw an exception if the special case occurs , and that exception will allow the special case to be handled outside of the function .
That way , the special case can be handled differently for different invocations of the function .

In , exception handling proceeds as follows : Either some library software or your code provides mechanism that signals when something unusual happens .
This is called throwing an exception .
At another place in your program , you place the code that deals with the exceptional case .
This is called handling the exception .
This method of programming makes for cleaner code .

Of course , we still need to explain the details of how you do this in .

Prerequisites With the exception of one subsection that can be skipped , Section uses material only from Chapters to and to .
The Pitfall subsection of Section entitled Specification in Derived Classes " uses material from Chapter .
This Pitfall subsection can be skipped without loss of continuity .

The subsection of Section entitled for Available Memory " uses material from Chapter .
This subsection can be skipped without loss of continuity .

know it had to work for that case .

Computer Science student , appealing grade Exception handling is meant to be used sparingly and in situations that are more involved than what is reasonable to include in simple introductory example .
So , we will teach you the details of by means of simple examples that would not normally use exception handling .

This makes lot of sense for learning about exception handling , but do not forget that these first examples are toy examples , and in practice , you would not use exception handling for anything that simple .

Toy Example of Exception Handling For this example , suppose that milk is such an important food in our culture that people almost never run out of it , but still we would like our programs to accommodate the very unlikely situation of running out of milk .
The basic code , which assumes we do not run out of milk , might be as .

To take care of the special situation in which we run out of milk , we can add test for this unusual situation .
The complete program with this added test for the special situation is shown in Display .
The program in Display does not use exception handling .
Now , see how this program can be rewritten using the facilities .

Chapter Exception Handling Display Handling Special Case Without Exception Handling include using namespace std ;

Sample Dialogue Enter number of donuts : Enter number of glasses of  donuts , and No Milk .

End of program .

In Display , we have rewritten the program from Display using an exception .
This is only toy example , and you would probably not use an exception in this case .
However , it does give us simple example .
Although the program as whole is not simpler , at least the part between the words try and catch is cleaner , and this hints at the advantage of using exceptions .
Look Basics .

Sample Dialogue Enter number of donuts : Enter number of glasses of  donuts .

You have donuts for each glass of .

Chapter Exception Handling Sample Dialogue Enter number of donuts : Enter number of glasses of  donuts , and No Milk .

That code is basically the same as the code in Display , but rather than the big statement in color in Display this new has the following smaller if statement some simple nonbranching : throw donuts ; This if statement says that if there is no  then do something exceptional .
That something exceptional is given after the word catch .
The idea is that the normal situation is handled by the code following the word try , and that the code following the word catch is used only in exceptional circumstances .
We have thus separated the normal case from the exceptional case .
In this toy example , this separation does not really buy us too much , but in other situations it will prove to be very helpful .
look at the details .

The basic way of handling exceptions in consists of the threesome .
try block has the syntax try This try block contains the code for the basic algorithm that tells the computer what to do when everything goes smoothly .
It is called try block because you are not percent sure that all will go smoothly , but you want to Now if something does go wrong , you want to throw an exception , which is way of indicating that something went wrong .
The basic outline , when we add throw , is as follows : try Basics The following is an example of try block with throw statement included .

The value thrown , in this case donuts , is sometimes called an exception , and the execution of throw statement is called throwing an exception .
You can throw value of any type .
In this case , an int value is thrown .

If the try block is followed by suitable catch block , then flow of control is transferred to the catch block .
throw statement is almost always embedded in branching statement , such as anif statement .
The value thrown can be of any type .

Example throw .

Chapter Exception Handling As the name suggests , when something is " something goes from one place to another place .
In , what goes from one place to another is the flow of control well as the value .
When an exception is thrown , the code in the surrounding try block stops executing and another portion of code , known as catch block , begins execution .
This executing of the catch block is called catching the exception or handling the exception .

In Display , the appropriate catch block immediately follows the try block .
We repeat the catch block .

This catch block looks very much like function definition that has parameter of type int .
It is not function definition , but in some ways , catch block is like function .
It is separate piece of code that is executed when your encounters the following the preceding try : throw ; So , this throw statement is similar to function call , but instead of calling function , it calls the catch block and says to execute the code in the catch block .
catch block is often referred to as an exception handler , which is term that suggests that catch block has nature .

What is that identifier in the following line from catch block .

That identifier looks like parameter and acts very much like parameter .

So , we will call this the parameter .
The parameter is preceded by type name that specifies what kind of thrown value the catch block can catch .

The parameter gives you name for the thrown value that is caught , so you can write code in the catch block that does things with the thrown value that is caught .

We will discuss these two functions of the parameter in reverse order .
In this subsection , we will discuss using the parameter as name for the value that was thrown and is caught .
In the subsection entitled Throws and " later in this chapter , we will discuss which catch block exception will process value that is thrown .
Our Basics current example has only one catch block .
common name for parameter is , but you can use any legal identifier in place of .

see how the catch block in Display works .
When value is thrown , execution of the code in the try block ends and control passes to the catch block that are placed right after the try block .
The catch block from Display is reproduced .

When value is thrown , the thrown value must be of type int in order for this particular catch block to apply .
In Display , the value thrown is given by the variable donuts , and since donuts is of type int , this catch block can catch the value thrown .

Suppose the value of donuts is and the value of is , as in the second sample dialogue in Display .
Since the value of is not positive , the throw statement within the if statement is executed .
In that case , the value of the variable donuts is thrown .
When the catch block in Display catches the value of donuts , the value of donuts is plugged in for the parameter and the code in the catch block is executed , producing the following output : donuts , and No Milk .

If the value of donuts is positive , the throw statement is not executed .
In this case , the entire try block is executed .
After the last statement in the try block is executed , the statement after the catch block is executed .
Note that if no exception is thrown , then the catch block is ignored .

This makes it sound like setup is equivalent to an ifelse statement .
It almost is equivalent , except for the value thrown .
setup is similar to an statement with the added ability to send message to one of the branches .
This does not sound much different from an statement , but it turns out to be big difference in practice .

To summarize in more formal tone , try block contains some code that we are assuming includes throw statement .
The throw statement is normally executed only in exceptional circumstances , but when it is executed , it throws value of some type .
When an exception value like donuts in Display is thrown , that is the end of the try block .
All the rest of the code in the try block is ignored and control passes to suitable catch block .
catch block applies only to an immediately preceding try block .
If the exception is thrown , then that exception object is plugged in for the parameter , and the statements in the catch block are executed .
For example , if you look at the dialogues in Display , you will see that as soon as the user .

Chapter Exception Handling catch Parameter The parameter is an identifier in the heading of catch block that serves as placeholder for an exception that might be thrown .
When value is thrown in the preceding try block , that value is plugged in for the parameter .
You can use any legal identifier for parameter .

For now , we will assume that every try block is followed by an appropriate catch block .
We will later discuss what happens when there is no appropriate catch block .

Next , we summarize what happens when no exception is thrown in try block .
If no exception is thrown in the try block , then after the try block is completed , program execution continues with the code after the catch block .
In other words , if no exception is thrown , then the catch block is ignored .
Most of the time when the program is executed , the throw statement will not be executed , and so in most cases , the code in the try block will run to completion and the code in the catch block will be ignored completely .

The throw statement throws the exception .
The catch block catches the exception .
When an exception is thrown , the try block ends and then the code in the catch block is executed .
After the catch block is completed , the code after the catch is executed the catch block has not ended the program or performed some other special .

If no exception is thrown in the try block , then after the try block is completed , program execution continues with the code after the catch .

Syntax try Either some code with throw statement or function invocation that might throw an .

Se Te st Ex ercis .
What output is produced by the following code .

In the code given in Exercise , what is the throw statement .

What happens when throw statement is executed .
This is general question .
Tell what happens in general , not simply what happens in the code in Question or some other sample code .

In the code given in Exercise , what is the try .

In the code given in Exercise , what is the catch .

In the code given in Exercise , what is the parameter .

Defining Your Own Exception Classes throw statement can throw value of any type .
common thing do is define class whose objects can carry the precise kind of information you want thrown the catch .
An even more important reason for defining specialized exception class is so that you can have different type identify each possible kind of exceptional situation .

An exception class is just class .
What makes it an exception class is how used .
Still , it pays take some care in choosing an exception name and other details .
Display contains an example of program with exception class .
This is just toy program illustrate some details about exception handling .
It uses much too much machinery for such simple task , but it is an otherwise uncluttered example of some details .

Notice the throw statement , reproduced in what follows : throw ; The part is an invocation of constructor for the class NoMilk .

The constructor takes one int argument this case and creates an Multiple Throws and Catches try can potentially throw any number of exception values , and they can be of differing types .
In any one execution of the try  only one exception will be thrown thrown exception ends the execution of the try , but different types of exception values can be thrown on different occasions when the try is executed .
Each catch can only catch values of one type , but you can catch exception values of differing types by placing more than one catch after try .
For example , the program in Display has two catch blocks after its try .

Note that there is no parameter in the catch for DivideByZero .
If you do not need parameter , you can simply list the type with no parameter .

Do not take it as an example of good typical use of exception handling .

Although not done here , exception classes can have their own interface and implementation files and can be put in namespace .

This is another toy example .

Sample Dialogue Enter number of JemHadar warriors : How many Klingon warriors do you have .

End of program Sample Dialogue Enter number of JemHadar warriors : Cannot have negative number of JemHadar End of program .

Sample Dialogue Enter number of JemHadar warriors : How many Klingon warriors do you have .

End of program .

Chapter Exception Handling This case is discussed bit more in the Programming Tip section entitled Pitfall Catch the More Specific Exception First When catching multiple exceptions , the order of the catch blocks can be important .
When an exception value is thrown in try block , the following catch blocks are tried in order , and the first one that matches the type of the exception thrown is the one that is executed .

For example , the following is special kind of catch block that will catch thrown value of any .

The three dots do not stand for something omitted .
You actually type in those three dots in your program .
This makes good default catch block to place after all other catch blocks .
For example , we could add it to the catch blocks in Display as .

With this second ordering , an exception thrown of type NegativeNumber will be caught by the NegativeNumber catch block , as it should be .
However , if value of type DivideByZero were thrown , it would be caught by the block that starts .
So , the DivideByZero catch block could never be reached .
Fortunately , most compilers tell you if you make this sort of mistake .

It has nothing but its name , but that is useful enough .
Throwing an object of the class DivideByZero can activate the appropriate catch block , as it does in Display .

When using trivial exception class , you normally do not have anything you can do with the exception thrown once it gets to the catch block .
The exception is just being used to get you to the catch block .
Thus , you can omit the parameter .
For example , you might have function with code that throws an exception if there is an attempt to divide by zero , but you may not want to catch the exception in that function .
Perhaps some programs that use that function should simply end if the exception is thrown , and other programs that use the function should do something else .
So you would not know what to do with the exception if you caught it inside the function .
In these cases , it makes sense to not catch the exception in the function definition , but instead to have any program other that uses the function place the function invocation in try block and catch the exception in catch block that follows that try block .

Look at the program in Display .
It has try block , but there is no throw statement visible in the try block .
The statement that does the throwing in that program is throw .

Sample Dialogue Enter numerator : Enter denominator : Error : Division by zero .

This statement is not visible in the try block .
However , it is in the try block in terms of program execution , because it is in the definition of the function and there is an invocation of in the try block .

Exception Specification If function does not catch an exception , it should at least warn programmers that any invocation of the function might possibly throw an exception .
If there are exceptions that might be thrown , but not caught , in the function definition , then those exception types should be listed in an exception specification , which is illustrated by the following function declaration from Display : double top , int throw ; As illustrated in Display , the exception specification should appear in both the function declaration and the function definition .
If function has more than one function declaration , then all the function declarations must have identical exception specifications .
The exception specification for function is also sometimes called the throw list .

If there is more than one possible exception that can be thrown in the function definition , then the exception types are separated by commas , as illustrated here : void throw ,

Chapter Exception Handling All exception types listed in the exception specification are treated normally .

When we say the exception is treated normally , we mean it is treated as we have described before this subsection .
In particular , you can place the function invocation in try block followed by catch block to catch that type of exception , and if the function throws the exception does not catch it inside the , then the catch block following the try block will catch the exception .
If there is no exception specification throw at all even an empty , then it is the same as if all possible exception types were listed in the exception specification ; that is , any exception that is thrown is treated normally .

What happens when an exception is thrown in function but is not listed in the exception specification not caught inside the .
In that case , the program ends .
In particular , notice that if an exception is thrown in function but is not listed in the exception specification not caught inside the , then it will not be caught by any catch block , but instead your program will end .
Remember , if there is no specification list at all , not even an empty one , then it is the same as if all exceptions were listed in the specification list , and so throwing an exception will not end the program in the way described in this paragraph .

Keep in mind that the exception specification is for exceptions that outside " the function .
If they do not get outside the function , they do not belong in the exception specification .
If they get outside the function , they belong in the exception specification no matter where they originate .
If an exception is thrown in try block that is inside function definition and is caught in catch block inside the function definition , then its type need not be listed in the exception specification .
If function definition includes an invocation of another function and that other function can throw an exception that is not caught , then the type of the exception should be placed in the exception specification .

To say that function should not throw any exceptions that are not caught inside the function , you use an empty exception specification like so : void throw ; By way of summary : void throw , of type DivideByZero or OtherException are normally .
All other exceptions end the program not caught in the function body .

So , if is derived class of class and is in the exception specification , then thrown object of class will be treated normally , since it is an object of class and is in the exception specification .

If double is in the exception specification , that does not account for throwing an int value .
You would need to both int and double in the exception specification .

One final warning : Not all compilers treat the exception specification as they are supposed to .
Some compilers essentially treat the exception specification as comment , and so with those compilers , the exception specification has no effect on your code .
This is another reason to place all exceptions that might be thrown by your functions in the exception specification .
This way all compilers will treat your exceptions the same way .
Of course , you could get the same compiler consistency by not having any exception specification at all , but then your program would not be as well documented and you would not get the extra error checking provided by compilers that do use the specification .
With compiler that does process the exception specification , your program will terminate as soon as it throws an exception that you did not anticipate .
Put another way , when you redefine or override function definition , you cannot add any exceptions to the exception specification you can delete some exceptions if you .

This makes sense , since an object of the derived class can be used anyplace an object of the base class can be used , and so redefined or overwritten function must fit any code written for an object of the base class .

Warren Peace , The Tools So far , we have shown you lots of code that explains how exception handling works in , but we have not yet shown even one example of program that makes good and realistic use of exception handling .
However , now that you know the mechanics of exception handling , this section can go on to explain techniques .

When to Throw an Exception We have given some very simple code in order to illustrate the basic concepts of exception handling .
However , our examples were unrealistically simple .
more complicated but better guideline is to separate throwing an exception Programming Techniques for Exception Handling and catching the exception into separate functions .
In most cases , you should any throw statement within function definition , list the exception in the exception specification for that function , and place the catch clause in different function .
Thus , the preferred use of the triad is as illustrated here : void .

If you can easily handle problem in some other way , do not throw an exception .
Reserve throw statements for situations in which the way the exceptional condition is handled depends on how and where the function is used .
If the way that the exceptional condition is handled depends on how and where the function is invoked , then the .

Chapter Exception Handling When to Throw an Exception For the most part , throw statements should be used within functions and listed in an exception specification for the function .
Moreover , they should be reserved for situations in which the way the exceptional condition is handled depends on how and where the function is used .

If the way that the exceptional condition is handled depends on how and where the function is invoked , then the best thing to do is to let the programmer who invokes the function handle the exception .
In all other situations , it is almost always preferable to avoid throwing an exception .

In all other situations , it is almost always preferable to avoid throwing exceptions .

Pitfall Uncaught Exceptions Every exception that is thrown by your code should be caught someplace in your code .
If an exception is thrown but not caught anywhere , your program will end .

In rare cases , this may be useful , but if you are tempted to do this , you should suspect that there is nicer way to organize your program .
It is almost always better to place the inner blocks inside function definition and place an invocation of the function in the outer try or catch block maybe just eliminate one or more try blocks .

If you place try block and following catch blocks inside larger try block , and an exception is thrown in the inner try block but not caught in the inner blocks , then the exception is thrown to the outer try block for processing and might be caught there .

Throwing an exception allows you to transfer flow of control Programming Techniques for Exception Handling from anyplace in your program to almost anyplace else in your program .
In the early days of programming , this sort of unrestricted flow of control was allowed via construct known as goto .
Programming experts now agree that such unrestricted flow of control is very poor programming style .
Exceptions allow you to revert to these bad old days of unrestricted flow of control .

Exceptions should be used sparingly and only in certain ways .
good rule is the following : If you are tempted to include throw statement , then think about how you might write your program or class definition without this throw statement .
If you think of an alternative that produces reasonable code , then you probably do not want to include the throw statement .

For example , you might have an ArithmeticError exception class and then define an exception class DivideByZeroError that is derived class of ArithmeticError .
Since DivideByZeroError is an ArithmeticError , every catch block for an ArithmeticError will catch DivideByZeroError .
If you list ArithmeticError in an exception specification , then you have , in effect , also added DivideByZeroError to the exception specification , whether or not you list DivideByZeroError by name in the exception specification .

Testing for Available Memory In Chapter , we created new variables with code such as the following : struct .

This works fine as long as there is sufficient memory available to create the new .
But , what happens if there is not sufficient memory .
If there is not sufficient memory to create the  then exception is thrown .

The type is part of the language .
You do not need to define it .

Since new throw exception when there is not enough memory to create the  you can check for running out of memory as follows : try .

Rethrowing an Exception It is legal to throw an exception within catch block .
In rare cases , you may want to catch an exception and then , depending on the details , decide to throw the same or different exception for handling farther up the chain of blocks .

Se Te Ex rc ise .
What happens when an exception is never caught .

Can you nest try block inside another try block .

Chapter Summary Exception handling allows you to design and code the normal case for your program separately from the code that handles exceptional situations .

Alternatively , an exception can be thrown in function definition that does not include try block does not include catch block to catch that type of .
In this case , an invocation of the function can be placed in try block .

In this case , always list the catch block for more specific exception class before the catch block for more general exception class .

Answers to Self Test Exer cises .
Try block entered .

Exception thrown with equal to After catch block .

Answers to Exercises .
Try block entered .

Leaving try block .

After catch block .

When throw statement is executed , that is the end of the enclosing try block .
No other statements in the try block are executed , and control passes to the following catch .
When we say control passes to the following catch block , we mean that the value thrown is plugged in for the catchblock parameter , and the code in the catch block is executed .

End of program .

Trying after call .

End of program .

If an exception is not caught anywhere , then your program ends .

Yes , you can have try block and corresponding catch blocks inside another larger try block .
However , it would probably be better place the inner try and catch blocks in function definition and place an invocation of the function in the larger try block .

Chapter Exception Handling Practice Programs Practice Programs can generally be solved with short program that directly applies the programming principles presented in this chapter .

VideoNote Solution Practice Program .
function that returns special error code is often better implemented by throwing an exception instead .
This way , the error code cannot be ignored or mistaken for valid data .
The following class maintains an account .

Write test code that attempts withdraw and deposit invalid amounts and catches the exceptions that are thrown .

Programming Projects .
The Standard Template Library includes class named exception that is the parent class for any exception thrown by an STL function .
Therefore , any exception can be caught by this class .
The following code sets up block for STL .

Modify the code so that an exception is in the try block .
You could try accessing an invalid index in string using the at member function .

Programming Projects Programming Projects require more than Practice Programs and can usually be solved many different ways .
Visit complete many of these Programming Projects online and get instant feedback .

Write program that converts time time .
The following is sample dialogue : Enter time in notation : That is the same as PM Enter time in notation : That is the same as AM .

Chapter Exception Handling Enter time in notation : There is no such time as Try again : Enter time in notation : That is the same as PM End of program You will define an exception class called TimeFormatMistake .
If the user enters an illegal time , like or even gibberish like , then your program will throw and catch TimeFormatMistake .

Write program that converts dates from numerical format alphabetic example , or corresponds January .
The dialogue should be similar that in Programming Project .

You will define two exception classes , one called MonthError and another called DayError .
If the user enters anything other than legal month number from , then your program will throw and catch MonthError .
Similarly , if the user enters anything other than valid day number from either , or , depending on the , then your program will throw and catch DayError .
To keep things simple , always allow days for February .

VideoNote Solution Programming Project .
Write program that inputs numeric values from through and outputs textual histogram of the values using ' count the number of occurrences of each value .
The program should first ask the user how many numbers enter .
If the user enters value that does not consist of all digits or number outside the range , then an exception should be caught .
If not , throw an exception .
To convert string str an integer , use the following code : The atoi function is described in Chapter Here is sample dialogue : How many numbers enter .

Enter number : Enter number : Try again .

Programming Projects Enter number : Enter number : The number must be between .

Enter number : Enter number : Try again .

Here is the histogram of values :         
Define class named CheckedArray .
The objects of this class are like regular arrays but have range checking .
If is an object of the class CheckedArray and is an illegal index , then use of will cause your program to throw an exception of the class ArrayOutOfRangeError .
Defining the class ArrayOutOfRangeError is part of this project .
Note that , among other things , your CheckedArray class must have suitable overloading of operators , as discussed in Appendix .

Stacks were introduced in Chapters and .
Define stack class for storing stack of elements of type char .
stack object should be of fixed size ; the size is parameter to the constructor that creates the stack object .
When used in program , an object of the stack class will throw exceptions in the following situations : StackOverflowException if the application program tries to push data onto stack that is already full StackEmptyException if the application program tries to pop data off an empty stack Defining the classes StackOverflowException and StackEmptyException is part of this project .
Write suitable test program .

Give each function an argument that specifies the level .

Chapter Exception Handling at which it is to throw an exception .
The main function prompts for and receives input that specifies the calling depth at which an exception will be thrown .
The main function then calls the first function .
The main function catches the exception and displays the level at which the exception was thrown .
forget the case where the depth is , where main must both throw and catch the exception .

Rather , for compact code , use main function that calls another function that calls itself recursively .

Suppose you do this ; is the restriction on the calling depth necessary .

Programming Project in Chapter described technique to emulate array with wrapper functions around array .
If the indices of desired entry in the array were to instead throw an ArrayOutOfRangeError exception if either the row or column indices are invalid .
Your program should define the ArrayOutOfRangeError exception class .

Templates for Algorithm Abstraction for Functions Pitfall : Compiler Complications Programming Example : Generic Sorting Function Programming Tip : How to Define Pitfall : Using Template with an Inappropriate Type for Data Abstraction Syntax for Programming Example : An Array Chapter Summary Answers to Exercises Practice Programs Programming Projects All men are mortal .

Aristotle is man .

Therefore , Aristotle is mortal .

All cats are mischievous .

Garfield is cat .

Therefore , Garfield is mischievous .

Short Lesson on Syllogisms Introduction This chapter discusses templates .
This will allow you to design functions that can be used with arguments of different types and to define classes that are much more general than those you have seen before this chapter .

Prerequisites Section uses material from Chapters through and Sections , and of Chapter .
It does not use any material on classes .
Section uses material from Chapters through and through .

For example , consider the function , which we first discussed in Chapter .
For reference , we now repeat the function .

Notice that the function applies only to variables of type int .
Yet the algorithm given in the function body could just as well be used to swap the values in two variables of type char .
If we want to also use the function for Algorithm Abstraction with variables of type char , we can overload the function name .

But there is something inefficient and unsatisfying about these two definitions of the function : They are almost identical .
The only difference is that one definition uses the type int in three places and the other uses the type char in the same three places .
Proceeding in this way , if we wanted to have the function apply to pairs of variables of type double , we would have to write third almost identical function definition .

If we wanted to apply to still more types , the number of almost identical function definitions would be even larger .
This would require good deal of typing and would clutter up our code with lots of definitions that look identical .
We should be able to say that the following function definition applies to variables of any type : void .

That syntax is described in the next subsection .

This function template allows you to swap the values of any two variables , of any type , as long as the two variables have the same type .
The definition and the function declaration begin with the line This is often called the template prefix , and it tells the compiler that the definition or function declaration that follows is template and that is .

Chapter type parameter .
In this context , the word class actually means As we will see , the type parameter can be replaced by any type , whether the type is class or not .
Within the body of the function definition , the type parameter is used just like any other type .

The function template definition is , in effect , large collection of function definitions .
For the function template for shown in Display , there is , in effect , one function definition for each possible type name .

Each of these definitions is obtained by replacing the type parameter with type name .
For example , the function definition that follows is obtained by replacing with the type name .

Yet another definition is obtained by replacing the type parameter with char .
The one function template shown in Display overloads the function name so that there is slightly different function definition for every possible type .

The compiler will not literally produce definitions for every possible type for the function name , but it will behave exactly as if it had produced all those function definitions .
separate definition will be produced for each different type for which you use the template , but not for any types you do not use .
Only one definition is generated for single type regardless of the number of times you use the template for that type .
Notice that the function is called twice in Display : One time the arguments are of type int and the other time the arguments are of type char .

Consider the following function call from Display : When the compiler gets to this function call , it notices the types of the this case then it uses the template to produce function definition with the type parameter replaced with the type name int .
Similarly , when the compiler sees the function call , In fact , the ANSI standard provides that you may use the keyword typename instead of class in the template prefix .
Although we agree that using typename makes more sense than using class , the use of class is firmly established tradition , and so we use class for the sake of consistency with most other programmers and authors .

Output Original values are Swapped values are Original character values are Swapped character values are it notices the types of the this case then it uses the template to produce function definition with the type parameter replaced with the type name char .

Notice that you need not do anything special when you call function that is defined with function template ; you call it just as you would any Calling function template .

Chapter Templates other function .
The compiler does all the work of producing the function definition from the function template .

Notice that in Display we placed the function template before the main part of the program , and we used no template function .
You may may be able to place the function declaration and definition for function template in the same locations that you place function declarations and definitions for ordinary functions .
However , many compilers do not support template function declarations and do not support separate compilation of template functions .
When these are supported , the details can be messy and can vary from one compiler to another .
Your safest strategy is to not use template function declarations and to be sure the function template definition appears in the same file in which it is used and appears before the function template is used .

We said that function template definition should appear in the same file as the file that uses the template function is , the same file as the file that has an invocation of the template .
However , the function template definition can appear via directive .
You can give the function template definition in one file and then that file in file that uses the template function .
That is the cleanest and safest general strategy .

However , even that may not work on some compilers .
If it does not work , consult local expert .

Although we will not be using template function declarations in our code , we will describe them and give examples of them for the benefit of readers whose compilers support the use of these function declarations .

In the function template in Display , we used the letter as the parameter for the type .
This is traditional but is not required by the language .
The type parameter can be any identifier than .

is good name for the type parameter , but sometimes other names may work better .
For example , the function template for given in Display is equivalent to the following : void .

For example , function template with two type parameters named and would begin as follows : class Templates for Algorithm Abstraction However , most function templates require only one type parameter .
You cannot have unused template parameters ; that is , each template parameter must be used in your template function .

Pitfall Compiler Complications Many compilers do not allow separate compilation of templates , so you may need to include your template definition with your code that uses it .
As usual , at least the function declaration must precede any use of the template function .

Your safest strategy is not to use template function declarations and to be sure the function template definition appears in the same file in which it is used and appears before the function template is called .
However , the function template definition can appear via directive .
You can give the function template definition in one file and then that file in file that uses the template function .

Another common technique is to put your definition and implementation , all in the header file .
If you use this technique , then you would only have header file and no implementation file .
Finally , an alternate approach is to include the implementation file for your template class instead of the header file .

Some compilers have additional special requirements for using templates .

If you have trouble compiling your templates , check your manuals or check with local expert .
You may need to set special options or rearrange the way you order the template definitions and the other items in your files .

For example , the following is function declaration for function template : void ,

VideoNote Issues Compiling Programs with Templates .

The type name is substituted for the type parameter is in the example .
For instance , consider the following function call : When this function call is executed , the compiler uses the function definition obtained by replacing with the type name double .
separate definition will be produced for each different type for which you use the template but not for any types you do not use .
Only one definition is generated for specific type regardless of the number of times you use the template .

Exe rc ise .
Write function template named maximum .
The function takes two values of the same type as its arguments and returns the larger of the two arguments either value if they are .
Give both the function declaration and the function definition for the template .
You will use the operator in your definition .
Therefore , this function template will apply only to types for which is defined .
Write comment for the function declaration that explains this restriction .

We have used three kinds of absolute value function : abs , labs , and fabs .

These functions differ only in the type of their argument .
It might be better to have function template for the absolute value function .
Give function template for an absolute value function called absolute .
The template will apply only to types for which is defined , for which the unary negation operator is defined , and for which the constant can be used in comparison with value of that type .
Thus , the function absolute can be called with any of the number types , such as int , long , and double .
Give both the function declaration and the function definition for the template .

Define or characterize the template facility for .

In the template prefix what kind of is the parameter .

can be only types built into the language .

Algorithm Abstraction As we saw in our discussion of the function , there is very general algorithm for interchanging the value of two variables , and this more general algorithm applies to variables of any type .
Using function template , we were able to express this more general algorithm in .
This is very simple example of algorithm abstraction .
When we say we are using algorithm abstraction , we mean that we are expressing our algorithms in very general way so that we can ignore incidental detail and concentrate on the substantive part of the algorithm .

Function templates are one feature of that supports algorithm abstraction .

Programming Example Generic Sorting Function In Chapter we gave simple sorting algorithm to sort an array of values of type int .
The algorithm was realized in code as the function sort , which we gave in Display .
Here we repeat the definition of this function .

If you study this definition of the function sort , you will see that the base type of the array is never used in any significant way .
If we replace the base type of the array in the function header with the type double , then we would obtain sorting function that applies to arrays of values of type double .

Helping functions course , we also must adjust the helping functions so they apply to arrays of elements of type double .
So consider the helping functions that are called inside the body of the function sort .
The two helping functions are values and .

We already saw that can apply to variables of any type , provided we define it as function template in Display .
see if depends in any significant way on the base type of the array being sorted .
The definition of is repeated next so you can study its details .

The function also does not depend in any significant way on the base type of the array .
If we replaced the two highlighted instances of the type int with the type double , then we will have changed the function so that it applies to arrays whose base type is double .

To change the function sort so that it can be used to sort arrays with the base type double , we only needed to replace few instances of the type name int with the type name double .
Moreover , there is nothing special about the type double .
We can do similar replacement for many other types .
The only thing we need to know about the type is that the operator is defined for that type .
This is the perfect situation for function templates .
If we replace few instances of the type name int the functions sort and with type parameter , then the function sort can sort an array of values of any type provided that the values of that type can be compared using the operator .
In Display we have written just such function template .

Notice that the function template sort shown in Display can be used with arrays of values that are not numbers .
In the demonstration program in Display , the function template sort is called to sort an array of characters .

Characters can be compared using the operator .
Although the exact meaning of the operator applied to character values may vary somewhat from one Templates for Algorithm Abstraction .

When applied to two uppercase letters , the operator tests to see if the first comes before the second in alphabetic order .
Also , when applied to two lowercase letters , the operator tests to see if the first comes before the second in alphabetic order .
When you mix uppercase and lowercase letters , the situation is not so well behaved , but the program shown in Display deals only with uppercase letters .
In that program , an array of Chapter Templates .

Output Unsorted integers : In sorted order the integers are : Unsorted doubles : In sorted order the doubles are : Unsorted characters : In sorted order the characters are : uppercase letters is sorted into alphabetical order with call to the function sort .
We then created by replacing the base type of the array with the type parameter .
This is good general strategy for writing templates .
If you want to write function  first write version that is not at all but is just an ordinary function .
Completely debug the ordinary function and then convert the ordinary .

Chapter Templates function to by replacing some type names with type parameter .

There are two advantages to this method .
First , when you are defining the ordinary function you are dealing with much more concrete case , which makes the problem easier to visualize .
Second , you have fewer details to check at each stage ; when worrying about the algorithm itself , you need not concern yourself with syntax rules .

However , all the code in the function must make sense and must behave in an appropriate way .
For example , you cannot use the with the type parameter replaced by type for which the assignment operator does not .

Display shows function called search , which searches an array for specified integer .
Give function version of search that can be used to search an array of elements of any type .
Give both the function declaration and the function definition for the .
In Practice Program of Chapter you were asked to overload the abs function so that the name abs would work with several of the types that had been studied at the time .
Compare and contrast function overloading of the abs function with the use of templates for this purpose in Exercise .

The example in this Pitfall section uses arrays .
If you have not yet covered arrays , you should skip this Pitfall section and return after covering arrays .

Edward Bellamy , Looking Backward : As you saw in the previous section , function definitions can be made more general by using templates .
In this section , you will see that templates can also make class definitions more general .

Syntax for Class Templates The syntax for class templates is basically the same as that for function templates .
The following is placed before the template definition : The type parameter is used in the class definition just like any other type .

As with function templates , the type parameter represents type that can be any type at all ; the type parameter does not have to be replaced with class type .
As with function templates , you may use any identifier instead of .

For example , the following is class template .
An object of this class contains pair of values of type ; if is int , the object values are pairs of integers , if is char , the object values are pairs of characters , and so on .

Type parameter pair of values of type : class Pair .

The only difference is that the member function definitions are themselves templates .
For example , the following are appropriate definitions the member function and the constructor with two arguments : iostream and cstdlib :

Notice that the class name before the scope resolution operator is , not simply .

The name of class template may be used as the type function parameter .
For example , the following is possible declaration function with parameter pair of integers : int ; the sum of the two integers in .

For example , the following is the beginning of class template definition : class .

Member functions and overloaded operators are then defined as function templates .
For example , the definition of function definition the sample class template above could begin as follows :

Note that we specified the type , in this case int , that is to be filled in the type parameter .

You can even use class template within function template .
For example , rather than defining the specialized function given above , you could instead define function template as follows so that the function applies to all kinds of numbers : The operator + is defined values of type .

Chapter Templates Type Definitions You can specialize template by giving type argument to the name , as in the following example : The specialized name , like , can then be used just like any name .
It can be used to declare objects or to specify the type of formal parameter .

You can define new type name that has the same meaning as specialized template name , such as .
The syntax such defined type name is as follows : typedef .

PairOfInt , The type name PairOfInt can also be used to specify the type of .

Programming Example An Array Class Display contains the interface template whose objects are lists .

Since this definition is template , the lists can be lists of items of any type whatsoever .
You can have objects that are lists of values of type int , or lists of values of type double , or lists of objects of type string , or lists of items of any other type .

Display contains demonstration program that uses this template .
Although this program does not really do anything much , it does illustrate how the template is used .
Once you understand the syntax details , you can use the template in any program that needs list of values .
Display gives the implementation of the template .

To do this , we made the operator friend of the .
In order to have parameter that is of the same type as the  we used the expression for the parameter type .
When the type parameter is replaced by , for example , the type int , this list parameter will be of type .

Also note that that the implementation of the overloaded insertion operator has been placed in the header file rather than the implementation file .
This may seem unusual , but it is quite common when using friend functions or operators within template .
Although we are defining like it is member of GenericList , recall that friend functions really exist outside the and are part of the namespace .
The compiler will have an easy time finding the implementation of this way when the is included from other files .

Objects of type can be list of items any type for which the operators are defined .

list that hold up to max items all of type is declared as follows :

Chapter Templates bool const ; true if the list is full .

This is commonly done with overloaded friend templates .

Output Display .

safe solution to the compilation of this code is to the template class definition and the template function definitions before use , as we did .
In that case , only the file in Display needs to be compiled .
Be sure that you use the mechanism to prevent multiple file inclusion of all the files you are going to .

Also note that that the implementation of the overloaded insertion operator has been placed in the header file rather than the implementation file .
This may seem unusual , but it is quite common when using friend functions or operators within template .
Although we are defining like it is member of  recall that friend functions really exist outside the class and are part of the namespace .

The compiler will have an easy time finding the implementation of this way when the class is included from other files .

If you want to separate the implementation of the overloaded friend insertion operator from the header , then it requires little bit of extra work .
We must make forward declaration of the operator which in turn requires forward declaration of the class .

Display illustrates the required changes to while Display illustrates the changes to , which simply has the additional implementation .

Display for the Class Without version moves the implementation of the overloaded the file , but requires adding some forward declarations .

These must be defined here since is not member of the class .

Chapter Templates Display for the Class Without class The rest of this class is identical to Display except overloaded below has no implementation code and an additional .

Display Implementation of with Overloaded Operator is implementation file : is implementation of class template named .

Answers to Exercises Exerc ise Give definition for member function for class Give definition for constructor with zero arguments for class Give definition of template class called HeterogeneousPair that is like except that with HeterogeneousPair first and second positions may store values of different types .
Use two type parameters and ; all items in first position will be of type , and all items in second position will be of type .
The single mutator function in template class Pair should be replaced by two mutator functions called and in template class HeterogeneousPair .
Similarly , single accessor function in template class Pair should be replaced by two accessor functions called and in template class HeterogeneousPair .

Is following true or false .

Friends are used exactly same for template and nontemplate classes .

Chapter Summary Using function templates , you can define functions that have parameter for type .

Answers to Exerci ses .
Function Declaration : first , The is defined for type .

Definition :

Any type , whether primitive type by or type defined by user class or struct type , an enum type , or defined array type , or int , float , double ,

The function declaration and function definition are given here .
They are basically identical to those for versions given in Display except that two instances of int are changed to BaseType in parameter list .

Function Declaration : int BaseType , int , BaseType .

Definition : int BaseType , int , Answers to Exercises .

Function overloading only works for types for which an overloading provided .
Overloading may work for types that automatically convert to some type for which an overloading provided but may not do what you expect .

The template solution will work for any type that defined at the time of invocation , provided that the requirements for definition of are satisfied .

There are no natural candidates the default initialization values , so this objects without giving any constructor arguments .

Practice Programs Practice Programs can generally be solved with short program that directly applies the programming principles presented in this chapter .

Write function template function that has parameters partially filled array and value of the base type of the array .
If the value in the partially filled array , then the function returns the of the indexed variable that contains the value .
If the value not in the array , the function returns .
The base type of the array type parameter .

Notice that you need two parameters to give the partially filled array : one the array and one the number of indexed variables used .
Also , write suitable test program to test this function template .

Write template version of the iterative binary search from Display .

Specify and discuss the requirements on the template parameter type .

Write template version of the recursive binary search from Display .

Specify and discuss the requirements on the template parameter type .

Programming Projects Programming Projects require more than Practice Programs and can usually be solved many different ways .
Visit to complete many of these Programming Projects online and get instant feedback .

This more general version has the added feature that you can step through the items on the list in order .
One item always the current item .
You can ask the current item , change the current item to the next item , change the current item to the previous item , start at the beginning of the list by making the item on the list the current item , and ask the nth item on the list .
To do this , you will add the following members : an additional member variable that records the on the list of the current item , member function that returns the current item as value , member function that makes the next item the current item , member function that makes the previous item the current item , member function that makes the item on the .

Chapter Templates list the current item , and member function that returns the nth item on the list given as an argument .
For example , an empty list has no item , and there no item after the last item in any list .
Be sure to test the empty list and handle it appropriately .
Be sure to test the beginning and end of the list and handle these cases appropriately .
Write suitable test program to test this class template .

Write template function that has parameters list of items and possible item on the list .
If the item on the list , then the function returns the of the occurrence of that item .
If the item not on the list , the function returns .
The on the list , the next , and so forth .
The type of the items on the list type parameter .
Use the class template GenericList that you defined in Project .
Write suitable program to test this function template .

It would help if you did the nontemplate version ; in other words , it would help if you did Programming Project in Chapter , if you have not already done it .

Display gives template function sorting an array using the selection sort algorithm .
Write similar template function sorting an array , but this time use the insertion sort algorithm as described in Programming Project of Chapter .
If you have not already done it , it would be good idea to do the nontemplate version ; in other words , it would be good idea to do Programming Project from Chapter .

Stacks are covered in Chapter ; dynamic arrays are covered Write template version of stack class .
Use type parameter the type of data that is stored in the stack .
Use dynamic arrays to allow the stack to grow to hold any number of items .

Write template version of class that implements priority queue .

Queues are discussed in Chapter and priority queues are discussed in Chapter .
To summarize , priority queue is essentially list of items Programming Projects that is always ordered by priority .
Each item that is added to the list requires an associated priority value .
For this problem , make the priority an integer where is the highest priority and larger values are lower in priority .
Removing an item from the queue removes the item with the highest priority .

The add function of the priority queue should take generic type and then an integer priority .
In the following example , the generic type is char and we have added three items to the .

Test your queue on data with priorities in various orders example , ascending , descending ,
You can implement the priority queue by storing the items using of your choice example , vector , array , linked list , or GenericList described in this and then performing linear search for the with the lowest integer value in the remove function .
In future courses you may study data structure called heap that affords more efficient way to implement priority queue .

Write class that implements set of items .
set is collection of items in which no occurs more than once .
Internally , you may represent the set using the data structure of your choice example , list , vector , arrays ,
However , the class should externally support the following functions : new to set .
If is already in set then nothing happens .

Determine if an is member of set .

The caller of this function is responsible for deallocating memory .

Test your class by creating different sets of different data types example , strings , integers , or other .
If you add objects to your set , then you may need to overload operators for class so your set class can properly determine membership .

VideoNote Solution to Programming Project Chapter Templates .
This project requires that you complete Programming Project from this chapter Programming Project from Chapter .
Programming Project asked you to write program to find all permutations of set .
Modify program so that it generates permutations given an instance of set class defined in Programming Project .
You may wish to also use your set class to help simplify implementation of permutation algorithm itself .

The algorithm requires that you store set of lists .
allows you to create set of lists with your set class .
For example , will define set containing vector of type .
Be careful to place space between last two , or compiler may get confused .
The code without space will likely produce compiler error unless you are using or higher .

Your program should print all permutations of sets of several different sizes comprised of several different types of data example , set of three integers , set of four strings , or set of five .

In this chapter we used only single template class type parameter .
allows you to specify multiple type parameters .
For example , following code specifies that class accepts two type parameters : class class .

The data type for keys values should be specified separately using type parameters .
The map forms basis for simple database .
For example , to map from employee ID numbers to employee names , we might use integers for data type of keys strings for data type of names .
The class should have functions to :
Add new pair to map .
Set an existing pair to new given .
Delete pair from map given .
Check if pair exists in map given Retrieve for pair given Use any data type you wish to implement map .
Write main function that tests class by exercising all of functions with sample data .

Standard Template Library Iterators using Declarations Iterator Basics Programming Tip : Use auto to Simplify Variable Declarationss Pitfall : Compiler Problems Kinds of Iterators Constant Mutable Iterators Reverse Iterators Other Kinds of Iterators Containers Sequential Containers Pitfall : Iterators Removing Elements Programming Tip : Type Definitions in Containers Chapter Summary Answers to Exercises Container Adapters stack queue Associative Containers set map Programming Tip : Use Initialization , Ranged for , auto with Containers Efficiency Generic Algorithms Running Times Notation Container Access Running Times Nonmodifying Sequence Algorithms Container Modifying Algorithms Set Algorithms Sorting Algorithms Practice Programs Programming Projects Libraries are not made ; they grow .

Augustine Birrell Introduction There is large collection of standard data structures for holding data .
Since they are so standard it makes sense to have standard portable implementations for them .
The Standard Template Library includes libraries for such data structures .
Included in STL are implementations of stack , queue , many other standard data structures .
When discussed in context of STL , these data structures are usually called container classes because they are used to hold collections of data .
In Chapter we presented preview of the STL by describing the vector template class , which is one of the container classes in the STL .
In this chapter we will present an overview of some of the basic classes included in the STL .
We do not have room to give comprehensive treatment of the STL here , but we will present enough to get you started using some basic STL container classes .

The STL was developed by Alexander Stepanov and Meng Lee at HewlettPackard and was based on research by Stepanov , Lee , and David Musser .
It is collection of libraries written in the language .
Although the STL is not part of the core language , it is part of the standard and so any implementation of that conforms to the standard would include the STL .

As practical matter , you can consider the STL to be part of the language .

As its name suggest , the classes in the STL are template classes .
typical container class in the STL has type parameter for the type of data to be stored in the container class .
The STL container classes make extensive use of iterators , which are objects that facilitate cycling through the data in container .
An introduction to the concept of an iterator was given in Section , where we discussed pointers used as iterators .
You will find it helpful to read that section before reading this chapter .
If you have not already done so , you should also read Section , which covers the vector template class of the STL .

The STL also includes implementations of many important generic algorithms , such as searching and sorting algorithms .
The algorithms are implemented as template functions .
After discussing the container classes , we will describe some of these algorithm implementations .

The STL differs from other libraries , such as for example , in that the classes and algorithms are generic , which is another way of saying they are template classes and template functions .

Iterators are generalization of pointers .
Other container template classes , which we introduce in Section , use iterators in the same way .
So , all you learn about iterators in this section will apply across wide range of containers and does not apply solely to vectors .
This reflects one of the basic tenets of the STL philosophy : The semantics , naming , and syntax for iterator usage should be uniform across different container types .
We begin with review and discussion of the using declarations , which we will use extensively when discussing iterators and the STL .

Suppose is function defined in the namespace .

The following using declaration allows you to use the identifier and have it mean the versions of defined in the namespace : using ; Within the scope of this using declaration an expression such as means the same thing as ; that is , within the scope of this using declaration the identifier always indicates the version of defined in , as opposed to any definition of defined in any other namespace .

When discussing iterators we will often apply the : operator to another level .
You will often see expressions such as the following : using .

Chapter Standard Template Library .

What is the type iterator .
It is defined in the definition of the class .
Which class .

The one defined in the namespace std .
At this point we are concerned only with explaining using You may object that this is all big about nothing .
There is no class defined in any namespace other than the namespace std .

That may or may not be true , but there could be class named defined in some other namespace either now or in the future .
You may object further that you never heard of defining type within class .
We have not covered such definitions , but they are possible and they are common in the STL .
So , you must know how to use such types , even if you do not define such types .

In summary , consider the using directive using ; Within the scope of this using directive the identifier iterator means the type named iterator that is defined in the class , which in turn is defined in the std namespace .

Iterator Basics An iterator is generalization of pointer , and in fact is typically even implemented using pointer , but the abstraction of an iterator is designed to spare you the details of the implementation and give you uniform interface to iterators that is the same across different container classes .
Each container class has its own iterator types , just like each data type has its own pointer type .
But just as all pointer types behave essentially the same for dynamic variables of their particular data type , so too does each iterator type behave the same , but each iterator is used only with its own container class .

An iterator is not pointer , but you will not go far wrong if you think of it use it as if it were pointer .
Like pointer variable , an iterator variable is located at one data entry in the container .
You manipulate iterators using the following overloaded that apply to iterator .

Prefix postfix increment  for advancing the iterator to the next data item .

Prefix postfix decrement  for moving the iterator to the previous data item .

Equal unequal  to test whether two iterators point to the same data location .

dereferencing operator , so that if is an variable , then gives access to the data located at to .
This access may be , or allow both reading changing of the data , depending on the particular container class .

However , the template class is an example of container whose iterators have all these more .

container class has member functions that get the process started .
After all , new variable is not located at any data in the container .
Many container classes , including the template class , have the following member functions that return objects that point to special data elements in the data structure : data item in the container c .

The is completely analogous to NULL used to test when pointer has passed the last node in linked list of the kind discussed in Chapter .
The is thus an that is located at no data item , but that is kind of end marker or sentinel .

For many container classes , these tools allow you to write for loops that cycle through all the elements in container object c , as follows : is an variable of the type for the container object c .

the big picture .
Now look at the details in the concrete setting of the template container class .

Display illustrates the use of iterators with the template class .

Keep in mind that each container type in the STL has its own types , although they are all used in the same basic ways .
The iterators we want for of ints are of type : Another container class is the list template class .
Iterators for lists of ints are of type : In the program in Display , we specialize the type name so that it applies to iterators for vectors of ints .
The type name that we want in Display is defined in the template class so if we specialize the template class to ints want the type for , we want the type .

Chapter Standard Template Library Display Iterators Used with Vector .

Sample Dialogue Here is what is in the container : Setting entries to : Container now contains : Since the definition places the name in the std namespace , the entire using declaration is using .

Recall that container is of type .

can be thought of as linear arrangement of its data elements .

There is first data element , second data element , so forth .

An is an object that can be located at one of these elements .
If is located at , say , then moves so it is located at .
This allows an to move through the from the first element to the last element , but it needs to find the first element and needs to know when it has seen the last element .

You can tell if an is at the same location as another using the .
Thus , if you have an pointing to the first , last , or other element , you could test another to see if it is located at the first , last , or other element .

If and are two iterators , then the comparison is true when and only when and are located at the same element .
If and were pointers , this would be true if they pointed to the same  is just the negation and so is true when and are not located at the same element .

The member function is used to position an iterator at the first element in container .
For vectors , and many other container classes , the member function returns an iterator located at the first element .

The member function returns sentinel value that can be checked .

The value is special value that serves as sentinel value .
It is not an ordinary iterator , but you can compare to an iterator .
The value is analogous to the value NULL used to mark the end linked list the kind discussed in Chapter .

The following for loop from Display uses this exact technique with the named .

The dereferencing is overloaded for STL container iterators so that produces the element at location .
In particular , for container , produces the element located at the iterator .
So , the statement above outputs the element located at the iterator the entire for loop outputs all the elements in the container .

The dereferencing always produces the element located at the iterator .
In some situations , produces access , which does not allow you to change the element .
In other situations , it gives you access to the element will let you change the element .
For vectors , will allow you to change the element located at  as illustrated by the following for loop from Display :

Declaring an iterator can be really verbose :

Compiler Problems Some compilers have problems with iterator declarations .
You can declare an iterator in different ways .
For example , we have been the .

An iterator is generalization the notion pointer , the , behave the same for iterators as they do for pointers .
The basic outline how an iterator can cycle through all the elements in container is   type is the data type the item to be stored .
The member function returns an iterator located at the first element .
The member function returns value that serves as sentinel value one location past the last element in the container .

Alternatively , if your code only uses single type iterator , you could use the .

Your compiler should accept any these alternatives .
However , we have found that some compilers will accept only certain them .
If one form does not work with your compiler , try another .

For some STL container classes , produces access , which does not allow you to change the element .
For other STL container classes , it gives you access to the element will let you change the element .

est Exe cis es .

If is an iterator for object , what is .

Suppose is ints .
Write for loop that outputs all the elements , except for the first element .

Kinds Iterators Different containers have different kinds iterators .
Iterators are classified according to the kinds operations that work on them .
Vector iterators are the most general form ; that is , all the operations work with iterators .
So , we will again use the container to illustrate iterators .
In this case we use to illustrate the iterator decrement random access .
Display shows another program object named container an iterator .

Sample Dialogue The third entry The third entry The third entry Back to .

As you would expect , moves the iterator to the previous location .
The decrement operator the same as the increment operator , but it moves the iterator in the opposite direction .

The increment and decrement operators can be used in either prefix or postfix notation .
In addition to changing  they also return .
The details of the returned are completely analogous to what happens with the increment and decrement operators on int variables .
In prefix notation , first the variable changed and the changed returned .

In postfix notation , the returned before the variable changed .
We prefer not to use the increment and decrement operators as expressions that return and use them only to change the variable .

Chapter Standard Template Library The following lines from Display illustrate that with iterators you have random access to the elements of  such as  third entry third entry third entry .

Random access means you can go in one step directly to any particular element .

We have already used as form of random access to .
It simply the square bracket operator that standard with arrays and vectors .
What new that you can use this same square bracket notation with an iterator .
The expression way to obtain access to the element indexed by .

The expressions and + are completely equivalent .
By analogy to pointer arithmetic Chapter , + names the location two places at the third location .
The expression + returns an iterator .

The expression + dereferences that iterator .
Of course , you can replace with different nonnegative integer to obtain pointer pointing to different element .

Be sure to note that neither nor + changes the of the iterator in the iterator variable .
The expression + returns another iterator at another location , but it leaves where it was .

Also note that the meaning of and + depends on the location of the iterator in .
For example , + means two locations beyond the location of  wherever that may be .

For example , suppose the previously discussed code from Display were replaced with the following the added : third entry third entry .

The output of these three couts would no longer be The third entry The third entry The third entry but would instead be The third entry The third entry The third entry The moves from location to location and so + now an iterator at location , not location .

The following are the main kinds of iterators : Forward iterators : works on the iterator .

Bidirectional iterators : both and work on the iterator .

Random access iterators : and random access all work with the iterator .

We now know enough about iterators to make sense of how iterators are classified .
The main kinds of iterators are Forward iterators : works on the iterator .

Bidirectional iterators : both and work on the iterator .

Random access iterators : and random access all work with the iterator .

Note that these are increasingly strong categories : Every random access iterator also bidirectional iterator , and every bidirectional iterator also forward iterator .
As we will see , different template classes have different kinds of iterators .
The iterators for the template class are random access iterators .

Note that the names forward iterator , bidirectional iterator , and random access iterator refer to kinds of iterators , not type names .
The actual type names will be something like , which in this case happens to be random access iterator .

SELF Exer cis .
Suppose the contains the letters , and ' in that .

Chapter Standard Template Library Constant and Mutable Iterators The categories forward iterator , bidirectional iterator , and random access iterator each subdivide into two categories : constant and mutable , depending on how the dereferencing operator behaves with the iterator .
With constant iterator the dereferencing operator produces version of the element .
With constant iterator  you can use , for example , to assign it to variable or output it to the screen , but you cannot change the element in the by , for example , assigning it to .
With mutable iterator  can be assigned value and that will change the corresponding element in the The iterators are mutable , as shown by the following lines from Display .

If has only constant iterators , you cannot obtain mutable iterator for the .
However , if has mutable iterators and you want constant iterator for the  you can have it .
You might want constant iterator as kind of error checking if you intend that your code not change the elements in the .
For example , the following will produce constant iterator for named 

However , every iterator of type named iterator will be constant iterator .

Reverse Iterators Sometimes you want to cycle through the elements in in reverse order .

Fortunately , there an easy way to do what you want .

The member function returns an iterator located at the last element .

The member function returns sentinel that marks the " of the elements in the reverse order .
Note that for an iterator of type iterator , the increment operator moves backward through the elements .

In other words , the meanings of and are interchanged .
The program in Display demonstrates reverse iterator .

Reverse Iterators reverse iterator can be used to cycle through all elements of  provided that the has bidirectional iterators .
The general scheme as .

Chapter Standard Template Library Display Reverse Iterator to demonstrate reverse iterator .

Sample Dialogue Forward : Reverse : The type also has constant version , which is named .

Other Kinds of Iterators There are other kinds of iterators that we will not cover in this book .
Briefly , two kinds of iterators you may encounter are an input iterator , which is essentially forward iterator that can be used with input streams , and an Containers output iterator , which is essentially forward iterator that can be used with output streams .
For more details , you will need to consult more advanced reference .

est Exer cis es .
Suppose the contains the letters , and ' in that .

Mark Twain , head Wilson The container classes of the STL are different kinds of data structures for holding data , such as lists , queues , and stacks .
Each is template class with parameter for the particular type of data to be stored .
So , for example , you can specify list to be list of ints , or doubles , or strings , or any class or struct type you wish .
Each container template class may have its own specialized accessor and mutator functions for adding data and removing data from the container .
Different container classes may have different kinds of iterators .
For example , one container class may have bidirectional iterators while another container class may have only forward iterators .
However , whenever they are have the same meaning for all STL container classes .

Chapter Standard Template Library Display Two Kinds of Lists slist : singly linked list .

Sequential Containers sequential container arranges its data items into list so that there is first element , next element , and so forth up to last element .
The linked lists we discussed in Chapter are examples of kind of list .
The lists we discussed in Chapter are sometimes called singly linked lists because there is only one link from one location to another .
The STL has no container corresponding to such singly linked lists , although some implementations do offer an implementation of them , typically under the name slist .
The simplest list that is part of the STL is the doubly linked list , which is the template class named list .
The difference between these two kinds of lists is illustrated in Display .

The lists in Display contain the three integer values , and in that order .
The types for the two lists are and .
That display also indicates the location of the iterators and .
We have not yet told you how you can enter the integers into the lists .

In Display we have drawn our singly and doubly linked lists as nodes and pointers of the form discussed in Chapter .
The STL class list and the nonstandard class slist might might be implemented in this way .

So , you simply think in terms of locations for the data may or may not be and iterators .
You can think of the arrows in Display as indicating the directions for is and is up in Display .

We wanted to present the template class slist to help give context for the sequential containers .
It corresponds to what we discussed most in Chapter , and it is the first thing that comes to the mind of most programmers when you mention linked lists .
However , since the template class slist is not standard , we will discuss it no more .
If your implementation offers the template class slist and you want to use it , the details are similar to those we will describe for list , except that the decrement operators and are not defined for slist .

simple program using the STL template class list is given in Display .
The function adds an element to the end of the list .
Notice that for the list template class , the dereferencing operator gives you access to the data for reading and for changing the data .
Also notice that with the list template class and all the template classes and iterators of the STL , all definitions are placed in the std namespace .

Chapter Standard Template Library .

Sample Dialogue List contains : Setting all entries to : List now contains : Note that Display would compile and run exactly the same if we replace and with vector and , respectively .
This uniformity of usage is key of the STL syntax .

There are , however , differences between vector and container .

One of the main differences is that vector container has random access iterators while has only bidirectional iterators .
For example , if you start with Display , which uses random access , and replace all occurrences of vector and with and , respectively , and then compile the program , you will get compiler error .
sample of some member functions is given in Display .

Other containers , such as stacks and queues , can be obtained from these using techniques discussed in the subsection entitled Adapters stack and " All these sequence template classes have destructor that returns storage for recycling .

Deque , pronounced " or " stands for ended " deque is kind of super queue .
With queue you add data at one end of the data sequence and remove data from the other end .
With deque Containers Display STL Basic Sequential Containers Template Iterator Type Names Kind of Iterators Library Header File slist .

Depends on implementation and may not be available .

Not member of slist .

Not member of slist .

Not member of slist .

Not member of vector .

Each also has destructor that returns all storage for recycling and assignment you can add data at either end and remove data from either end .
The template class deque is template class for deque with parameter for the type of data stored .

Sequential Containers sequential container arranges its data items into list so that there is first element , next element , and so forth up to last element .
The sequential container template classes that we have discussed are slist , list , vector , and deque .

Pitfall Iterators and Removing Elements When you add or remove an element to or from container , that can affect other iterators .
In general , there is no guarantee that the iterators will be located at the same element after an addition or deletion .
Some containers do , however , guarantee that the iterators will not be moved by additions or deletions , except of course if the iterator is located at an element that is removed .

The template classes vector and deque make no such guarantee .

We have already seen that STL container classes may contain the type names iterator , and hence must contain their type definitions behind the .
There are typically other type definitions as well .

All the template classes we have discussed so far have the defined types and .
The type is the type of the elements stored in the container .
For example , is another name for int .
Another defined type is , which is an unsigned integer type that is the return type for the member function .
As we noted in Chapter , the for the vector template class is unsigned int , although most compilers will be happy if you think of the type as just plain int .

What is major difference between vector and list .

Which of the template classes slist , list , vector , and deque have the member function .

Which of the template classes slist , list , vector , and deque have random access iterators .

Which of the template classes slist , list , vector , and deque can have mutable iterators .

Container Adapters stack and queue Container adapters are template classes that are implemented on top of other classes .
For example , the stack template class is by default implemented on top of the deque template class , which means that buried in the implementation of the stack is deque , which is where all the data resides .
However , you are shielded from this implementation detail and see stack as simple data structure .

Warning Other container adapter classes are the queue and template classes .
Stacks and queues were discussed in Chapter .
priority queue is like queue with the additional property that each entry is given priority when it is added to the queue .
If all entries have the same priority , then entries are removed from priority queue in the same manner as they are removed from queue .
If items have different priorities , the items are removed before items .
We will not be discussing priority queues in any detail , but mention it for those who may be familiar with the concept .

Although an adapter template class has default container class on top of which it is built , you may choose to specify different underlying container , for efficiency or other reasons depending on your application .

For example , any sequential container may serve as the underlying container for stack and any sequential container other than vector may serve as the underlying container for queue .
The default underlying data structure is the deque for both the stack and the queue .
For queue , the default underlying container is vector .
If you are happy with the default underlying container type , then container adapter looks like any other template container class to you .
For example , the type name for the stack template class using the default underlying container is for stack of ints .
If you wish to specify that the underlying container is instead the vector template class , you would use , as the type name .
We will always use the default underlying container .

If you do specify an underlying container , be warned that compilers prior to cannot compile code with two symbols in the type expression without space in between them .
Use , with space between the last two .
Do not use ,
compilers do not need space between the two symbols .

The member functions and other details about the stack template class are given in Display .
For the queue template class these details are given in Display .
simple example of using the stack template class is given in Display .

Stack Adapter Template Details Type name or , for stack of elements of type .

Library header : which places the definition in the std namespace .

Defined types :

Note that pop is void function .
It does not return the element removed .

The stack template class also has default constructor , copy constructor , as well as constructor that takes an object of any sequential container class and initializes the stack to the elements in the sequence .
It also has destructor that returns all storage for recycling and assignment operator .

Queue Adapter Template Details Type name or , for queue of elements of type .

For efficiency reasons , the cannot be vector type .

Library header : which places the definition in the std namespace .

Defined types :

Sample Member Functions Member Function .

Note that pop is void function .
It does not return the element removed .

The queue template class also has default constructor , copy constructor , as well as constructor that takes an object of any sequential container class and initializes the stack to the elements in the sequence .
It also has destructor that returns all storage for recycling and assignment operator .

The member function pop removes one element , but does not return that element .
So , we needed to use top to read the element we remove .

Sample Dialogue Enter line of text : straw Written backward that is : warts est Exer cises .
What kind of iterators , bidirectional , or random does the template adapter class have .

What kind of iterators , bidirectional , or random does the queue template adapter class have .

If is , what is the type of the returned value of .

Associative Containers set and map Associative containers are basically very simple databases .
They store data , such as structs or any other type of data .
Each data item has an associated value known as its key .
For example , if the data is struct with an employee ' record , the key might be the employee ' Social Security number .
Items are retrieved on the basis of the key .
The key type and the type for data to be stored need not have any relationship to one another , although they often are related .
very simple case is when the each data item is its own key .
For example , in set every element is its own key .

The set template class is , in some sense , the simplest container you can imagine .
It stores elements without repetition .
The first insertion places an element in the set .
Additional insertions after the first have no effect , so no element appears more than once .
Each element is its own key ; basically , you .

Chapter Standard Template Library just add or delete elements and ask if an element is in the or not .
Like all STL classes , the template class was written with efficiency as goal .
In order to work efficiently , object stores its values in sorted order .
You can specify the order used for storing elements as follows : Ordering should be ordering relation that takes two arguments of type and returns bool is the type of elements stored .
If no ordering is specified , then the ordering is assumed to be the relational operator .
Some basic details about the template class are given in Display .
simple example that shows how to use some of the member functions of the template class is given in Display .

is essentially function given as of ordered pairs .
For each value first that appears in pair , there is at most one value second such that the pair , is in the .
The template class implements objects in the STL .
For example , if you want to assign unique number to each string name , you could declare object as follows : For string values known as keys , the object can associate unique int value .

An alternate way to think of is as an associative array .
traditional array maps from numerical index to value .
For example , would store the number at index .
An associative array allows you to define your own indices using the data type of your choice .
For example , would associate the integer with the string .
For convenience , the square bracket operator is defined to allow you to use an notation to access  although you also can use the insert or find methods if you want .

Like object , object stores its elements in sorted order by its key values .
You can specify the ordering on keys as third entry in the angular brackets .
If you do not specify an ordering , default ordering is used .
The restrictions on orderings you can use is the same as those on the orderings allowed for the template class .
Note that the ordering is on key values only .
The second type can be any type and need not have anything to do with any ordering .
As with the object , the sorting of the stored entries in object is done for reasons of efficiency .

The ordering must be strict weak ordering .
Most typical orderings used to implement the operator is strict weak ordering .
For those who want the details : strict .

The Ordering is used to sort elements for storage .
If no Ordering is given , the ordering used is the binary operator .

Library header : which places the definition in the std namespace .

Defined types 

Iterators : iterator , and .
All iterators are bidirectional and those not including are mutable .
Adding or deleting elements does not affect iterators , except for an iterator located at the element removed .

Sample Member Functions Member Function Meaning copy of Element in the .
If Element is already in the  this has no effect .

If Element is not in the  this has no effect .

If Element is not in the  is returned .

The template class also has default constructor , copy constructor , as well as other specialized constructors not mentioned here .
It also has destructor that returns all storage for recycling and assignment operator .

Chapter Standard Template Library Display Program Using the Template Class .

Sample Dialogue The contains : Removing .

The easiest way to add and retrieve data from map is to use the operator .
Given map object , the expression will return reference to the data element associated with .
If no exists in the map for  then new will be created with the default value for the data element .

For objects of type string , the default value is an empty string .

The operator can be used to add new to the map or to replace an existing .
For example , the statement newData ; will create new association between and newData .
Note that care must be taken to ensure that map entries are not created by mistake .
For example , if you execute the statement ; with the intention of retrieving the value associated with but mistakenly enter value for that is not already in the map , then new will be made for with the default value and assigned into .

Some basic details about the map template class are given in Display .
In order to understand these details , you first need to know something about the pair template class .

The STL template class has objects that are pairs of values such that the first element is of type and the second is of type .
If aPair is an object of type , then is the first element , which is of type , and is the second element , which is of type .

The member variables first and second are public member variables , so no accessor or mutator functions are needed .

The header file for the pair template is .
So , to use the pair template class , you need the following , or something like it , in your file : using .

In either case , when we access this using an iterator , will refer to the " while will refer to the data value .
simple example that shows how to use some of the member functions of the template class is given in Display .

We will mention two other associative containers , although we will not give any details about them .
The template classes multiset and multimap are essentially the same as and  respectively , except that multiset allows repetition of elements and multimap allows multiple values to be associated with each value .

Chapter Standard Template Library Display Template Class Template Class Details Type name , or , for that associates elements of type KeyType to elements of type .

The Ordering is used to sort elements by value for efficient storage .

If no Ordering is given , the ordering used is the binary operator .

Library header : places the definition in the std namespace .

Defined types  for the type of the values , for the type of the values mapped to , and .

All iterators are bidirectional .
Those iterators not including are neither constant nor mutable , but something in between .
For example , if is of type iterator , then you change the value but not the value of type .
Perhaps it is best , at least at first , to treat all iterators as if they were constant .

Adding or deleting elements does not affect iterators , except for an iterator located at the element removed .

Sample Member Functions Member Function Meaning Element in the .
Element is of type ,

Returns value of type ,

Removes the element with the .

Returns if there is no such element .

If the does not already contain such an object , then default object of type is inserted and returned .

The template class also has default constructor , copy constructor , as well as other specialized constructors not mentioned here .
It also has destructor that returns all storage for recycling and assignment operator .

Sample Dialogue Entry for Hot planet is in the .

The iterator will output the in order sorted by the key .
In this case the output will be listed alphabetically by planet .

Iterating through all  Home .

Chapter Standard Template Library Largest planet in our solar system The Red Planet Hot planet winds Dwarf planet Has rings Tilts on its side Atmosphere of sulfuric acid Programming Tip Initialization , Ranged for , and auto VideoNote and Containers with Containers Several features introduced in make it easier to work with collections .

In particular , you can initialize your container objects using the uniform initializer list format , which consists of initial data in curly braces .
You can also use auto and the ranged for loop to easily iterate through container .

Consider the following two initialized collection .

We can iterate through each container conveniently using ranged for loop and auto : for for .

In fact , the STL implementations strive to be optimally efficient .
For example , the and elements are stored in sorted order so that algorithms that search for the elements can be more efficient .

Each of the member functions for each of the template classes has maximum running time .
These maximum running times are using what is called notation , which we discuss in Section .

These are in the subsection entitled Access Running When using more advanced references or even later in this chapter , you will be told the guaranteed maximum running times for certain functions .

est Exer cis es .
How many elements will be in the after the following code is .

What value is returned if ' is not in .

We cannot give you comprehensive description of them all here , but will present large enough sample to give you good feel for what is contained in the STL and to give you sufficient detail to start using these template functions .

These template functions are sometimes called generic algorithms .
The term algorithm is used for reason .
Recall that an algorithm is just of instructions for performing task .
An algorithm can be presented in any language , including programming language like .
But when using the word algorithm , programmers typically have in mind less formal presentation given in English or pseudocode .
As such , it is often thought of as an abstraction of the code defining function .
It gives the important details but not the fine details of the coding .

The STL specifies certain details about the algorithms underlying the STL template functions and that is why they are sometimes called generic algorithms .

These STL function templates do more than just deliver value in any way that the implementers wish .
The function templates in the STL come with minimum requirements that must be satisfied by their implementations if they are to satisfy the standard .
In most cases , they must be implemented with guaranteed running time .
This adds an entirely new to the idea of function interface .
In the STL , the interface not only tells programmer what the function does and how to use the functions ; the interface also tells how rapidly the task will be done .
In some cases , the standard even specifies the .

Chapter Standard Template Library particular algorithm that is used , although not the exact detail of the coding .

Moreover , when it does specify the particular algorithm , it does so because of the known efficiency of the algorithm .
The key new is specification of an efficiency guarantee for the code .
In this chapter we will use the terms generic algorithm , generic function , and STL function template to all mean the same thing .

In order to have some terminology to discuss the efficiency of these template functions or generic algorithms , we present some background on how the efficiency of algorithms is usually measured .

Running Times and Notation If you ask programmer how fast his or her program is , you might expect an answer like " However , the speed of program cannot be given by single number .
program will typically take longer amount of time on larger inputs than it will on smaller inputs .
You would expect that program to sort numbers would take less time to sort ten numbers than it would to sort one thousand numbers .
Perhaps it takes two seconds to sort ten numbers , but ten seconds to sort one thousand numbers .
How , then , should Running Time seconds numbers .

That need not be true .
Perhaps it takes much less time if the list is already sorted or almost sorted .
In that case , is defined to be the time taken by the " list , that is , the time taken on that list of numbers which makes the program run the longest .
This is called the running time .
In this chapter we will always mean running time when we give running time for an algorithm or for some code .

The time taken by program or algorithm is often given by formula , such as + + or .
If the running time is + then on inputs of size the program will run for + time units .

Following is some code for searching an array with elements to determine whether particular value target is in the array : int ; bool .

We would like an estimate that does not depend on which computer we use , either because we do not know which computer we will use or because we might use several different computers to run the program at different times .
One possibility is to count the number of " but it is not easy to decide what step is .
In this situation the normal thing to do is to count the number of operations .
The term operations is almost as vague as the term step , but there is at least some agreement in practice about what qualifies as an .

Let us say that , for this code , each application of any of the following will count as an  and .
The computer must do other things besides carry out these operations , but these seem to be the main things that it is doing and we will assume that they account for the bulk of the time needed to run this code .
In fact , our analysis of time will assume that everything else takes no time at all and that the total time for our program to run is equal to the time needed to perform these operations .
Although this is an idealization that clearly is not completely true , it turns out that this simplifying assumption works well in practice and so is often made when analyzing program or algorithm .

Even with our simplifying assumption , we still must consider two cases : Either the value target is in the array or it is not .
Let us first consider the case when target is not in the array .
Since we are assuming that target is not in the array , the loop will be executed times , one for each element of the array .
Each time the loop is executed , the following operations are  and This adds six operators for each of loop iterations .
Finally , after iterations , the Boolean expression is again checked and to be false .
This adds final .

Chapter Standard Template Library three operations , If we tally all these operations , we get total of + operations when the target is not in the array .
We will leave it as an exercise for you to confirm that if the target is in the array , then the number of operations will be + or less .
Thus , the running time is + operations for any array of elements and any value of target .

We just determined that the running time for our search code is + operations .
But operations is not traditional unit of time , like nanoseconds , seconds , or minutes .
If we want to know how long the algorithm will take on some particular computer , we must know how long it takes that computer to perform one .
If an can be in nanosecond , then the time will be + nanoseconds .
If an can be in second , the time will be + seconds .
If we use slow computer that takes seconds to perform an  the time will be + seconds .
In general , if it takes the computer c nanoseconds to perform one  then the actual running time will be approximately + nanoseconds .
To get the running time expressed in nanoseconds , you must multiply by some constant that depends on the particular computer you are using .

Our estimate of + is only accurate to constant " There is standard notation for these sorts of estimates and we discuss this notation next .

Estimates on running time , such as the one we just went through , are normally expressed in something called notation .

Under these circumstances , we say the code program or runs in time +
This is usually read as of + We need not know what the constant c will be .
In fact , it will undoubtedly be different for different computers , but we must know that there is one such c for any reasonable computer system .
If the computer is very fast , then the c might be less than ,
If the computer is very slow , the c might be very ,
Moreover , since changing the units , say from nanosecond to second , only involves constant multiple , there is no need to give any units of time .

Be sure to notice that estimate is an estimate .
We always approximate by taking numbers on the high side , rather than the low side , of the true count .
Also notice that when performing estimate , we need not determine very exact count of the number of operations .

We only need an estimate that is correct to constant " If our estimate is twice as large as the true number , that is good enough .

Because of short circuit evaluation , is not evaluated , so we actually get two , not three operations .
However , the important thing is to obtain good upper bound .

If we add in one extra that is not significant .

In our sample case , this parameter was the number of array elements to be searched .
Not surprisingly , it takes longer to search larger number of array elements than it does to search smaller number of array elements .
BigO running time estimates are always expressed as function of the size of the problem .
In this chapter all our algorithms will involve range of values in some container .
In all cases will be the number of elements in that range .

For example , all of the following are : + + + + All of the following are : + + + + + + estimates are admittedly crude , but they do contain some information .
They will not distinguish between running time of + and running time of , but they do let us distinguish between some running times and so determine that some algorithms are faster than others .

Look at the graphs in Display ; notice that all the graphs for functions that are eventually fall below the graph for the function algorithm could be faster than an algorithm for the problem size you are handling , programmers have found that in practice algorithms perform better than algorithms for most practical applications that are intuitively " Similar remarks apply to any other two different running times .

Some terminology will help with our descriptions of generic algorithm running times .
Linear running time means running time of aN +
linear running time is always an running time .
Quadratic running time means running time with highest term .
quadratic running time is always an running time .
We will also occasionally have logarithms in formulas .
Those normally are given without any base , since changing the base is just constant multiple .
If you see log  think log base of  but it would not be wrong to think log base of .
Logarithms are very functions .
So , running time is very fast .
Sometimes is written as lg .

Container Access Running Times Now that we know about notation , we can express the efficiency of some of the accessing functions for container classes that we discussed in Section " Insertions at the back of vector , Chapter Standard Template Library .

For set or map , finding is , where is the number of elements in the container .

est Exe cis es .
Show that running time aN + is an running time .
Show that for any two bases and for logarithms , if and are both greater than , then there is constant c such that loga .
Thus , there is no need to specify base in .

good simple and typical example is the generic find function .

The generic find function is similar to the find member function of the set template class but is different find function ; in particular , the generic find function takes more arguments than the find function we discussed when we presented the set template class .
The generic find function searches container to locate particular element , but the generic find can be used with any of the STL sequential container classes .
Display shows sample use of the generic find function used with the class .

The function in Display would behave exactly the same if we replaced with throughout , or if we replaced with any other sequential container class .
That is one of the reasons why the functions are called generic .
One definition of the find function works for wide selection of containers .

If the find function does not find the element it is looking for , it returns its second iterator argument , which need not be equal to some as it is in Display .
Sample Dialogue shows the situation when find does not find what it is looking for .

Chapter Standard Template Library .

Sample Dialogue Enter line of text line of text .

You entered the following before you entered your first : lin You entered the following after that : of text .

End of demonstration .

Sample Dialogue Enter line of text will not .

You entered the following before you entered your first : will not .

You entered the following after that : If find does not find what it is looking for , it .

End of demonstration .

Does find work with absolutely any container classes .

To start with , it takes iterators as arguments , and some containers , such as stack , do not have iterators .
To use the find function , the container must have iterators , the elements must be stored in linear sequence so that the Generic Algorithms operator moves iterators through the container , and the elements must be comparable .
In other words , the container must have forward iterators some stronger kind of iterators , such as bidirectional .

When presenting generic function templates , we will describe the iterator type parameter by the name of the required kind of iterator as the type parameter name .
So ForwardIterator should be replaced by type that is type for some kind of forward iterator , such as the iterator type in list ,  or other container template class .
Remember , bidirectional iterator is also forward iterator , and random access iterator is also bidirectional iterator .
So the type name ForwardIterator can be used with any iterator type that is bidirectional or random access iterator type as well as plain old forward iterator type .
In some cases , when we specify ForwardIterator you can use an even simpler iterator kind ; namely , an input iterator or output iterator , but since we have not discussed input and output iterators , we do not mention them in our function template declarations .

Remember the names forward iterator , bidirectional iterator , and random access iterator refer to kinds of iterators , not type names .
The actual type names will be something like , which in this case happens to be random access iterator .

Display gives sample of some nonmodifying generic functions in the STL .
The display uses notation that is common when discussing container iterators .
The iterator locations encountered in moving from an iterator first to , but not equal to , an iterator last is called the range ,
For example , the following for loop outputs all the elements in the range , endl ; Note that when two ranges are given they need not be in the same container or even in the same type of container .
For example , for the search function , the ranges , and , may be in the same or different containers .

The movement from some iterator first , often , up to but not including some location last , often , is so common it has come to have special name , range ,
For example , the following outputs all elements in the range .

Chapter Standard Template Library Display Some Nonmodifying Generic Functions These all work for forward iterators , which means they also work for bidirectional and random access iterators .
Returns second if target is not found .

Otherwise , returns false .

, to see if , is subrange of ,

Returns if match is not found .

The actual return type is an integer type that we have not discussed , but the returned value should be assignable to variable of type int .

The function search searches for subsequence , while the find and functions search for single value .
How do you decide whether to use find or when searching for single element .
One returns an iterator and the other returns just Boolean value , but that is not the biggest difference .
The function requires that the range being searched be sorted ascending order using and run in time ; the find function does not require that the range be sorted but it guarantees only linear time .
If you have or can have the elements in sorted order , you can search for them much more quickly by using .

Note that with the function you are guaranteed that the implementation will use the binary search algorithm , which was discussed in Chapter .
The importance of using the binary search algorithm is that it guarantees very fast running time ,
If you have not read Chapter and have not otherwise heard of binary search , just think of it as very efficient search algorithm that requires that the elements be sorted .
Those are the only two points about binary search that are relevant to the material in this chapter .

est Exer cis es Replace all occurrences of the identifier vector with the identifier list in Display .
Compile and run the program .

Suppose is an object of the class .
Use the search generic function to write some code to determine whether or not contains the number immediately followed by .
You need not give complete program , but do give all necessary include and using Container Modifying Algorithms Display contains descriptions of some of the generic functions in the STL which change the contents of container in some way .

Remember that when you add or remove an element to or from container , that can affect any of the other iterators .
There is no guarantee that the iterators will be located at the same element after an addition or deletion unless the container template class makes such guarantee .
Of the template classes we have seen , list and slist guarantee that their iterators will not be moved by additions or deletions , except of course if the iterator is located at an element that is removed .
The template classes vector and deque make no such guarantee .
Some of the function templates in Display guarantee the values of some specific iterators and those guarantees you can , of course , count on , no matter what the container is .

Chapter Standard Template Library Display Some Modifying Generic Functions .

The name of the iterator type parameter tells the kind of iterator for which the function works .

Remember that these are minimum iterator requirements .
For example , ForwardIterator works for forward iterators , bidirectional iterators , and random access iterators .

There is then an iterator in this such that the values not equal to target are in ,

est Exe cis es .
Can you use the template function with list container .

Can you use the copy template function with vector containers , even though copy requires forward iterators and vector has random access iterators .

Algorithms Display shows sample of the generic set operation functions defined in the STL .
Note that these generic algorithms assume the containers store their elements in sorted order .
The containers set , map , multiset , and multimap do store their elements in sorted order , so all the functions in Display apply to these four template class containers .
Other containers , such as vector , do not store their elements in sorted order and these functions should not be used with such containers .
The reason for requiring that the elements be sorted is so that the algorithms can be more efficient .

These operations work for sets , maps , multisets , multimaps other but do not work for all containers .
For example , they do not work for vectors , lists , or deques unless their contents are sorted .
For these containers to work , the elements in the container must be stored in sorted order .
These operators all work for forward iterators , which means they also work for bidirectional and random access iterators .
Otherwise , returns false .

Chapter Standard Template Library void , sorted set difference of the two ranges , and ,

est Exe cis .
The mathematics course version of set does not keep its elements in sorted order and it has union operator .
Why does the template function require that the containers keep their elements in sorted order .

Sorting Algorithms Display gives the declarations and documentation for two template functions , one to sort range of elements and one to merge two sorted ranges of elements .
Note that the sorting function sort guarantees run time of log .
Although it is beyond the scope of this book , it can be shown that you cannot write comparisonbased sorting algorithm that is faster than log .
So this guarantees that the sorting algorithm is as fast as is possible , up to constant multiple .

Display Some Generic Sorting Algorithms void first , RandomAccessIterator ; the elements in the range , into ascending order .

Sorting uses the operator , and so the operator must be defined .

Answers to Exercises Chapter Summary An iterator is generalization of pointer .
Iterators are used to move through the elements in some range of container .
The operations , and dereferencing are usually defined for an iterator .

The main kinds of iterators are Forward iterators : works on the iterator .

Bidirectional iterators : both and work on the iterator .

Random access iterators : and random access all work with the iterator .

With mutable iterator  can be assigned value .

stack is container .

queue is container .

set is simple collection of elements .
map allows storing and retrieving by key values .

The multiset class allows repetitions of entries .
The multimap class allows single key to be associated with multiple data items .

Answers to Exerci ses .

major difference is that container has random access iterators whereas list has only bidirectional iterators .

They all can have mutable iterators .

The stack template adapter class has no iterators .

The queue template adapter class has no iterators .

One is mapping from to " and the other is mapping from to the default string , which is blank .

Yes they can be of any type , although there is only one type for each set object .
The type parameter in the template class is the type of elements stored .

If ' is in , then returns an iterator located at the element .

Just note that aN + + as long as .

This is mathematics , not  will mean equals not assignment .

First note that loga .

To see this first identity , just note that if you raise to the power loga  you get  and if you raise to the power , you also get .

If you set , you get loga .

The programs should run exactly the same .

Yes , random access iterator is also forward iterator .

The template function requires that the containers keep their elements in sorted order to allow the function template to be implemented in more efficient way .

Practice Programs Practice Programs can generally be solved with short program that directly applies the programming principles presented in this chapter .

Write program in which you declare deque to store values of type double , read in ten double numbers , and store them in the deque .
Then call the generic sort function to sort the numbers in the deque and display the results .

Write program that uses the map template class to compute histogram of positive numbers entered by the user .
The key should be the number that is entered , and the value should be counter of the number of times the key has been entered far .
Use as sentinel value to signal the end of user input .
For example , if the user inputs : then the program should output the following necessarily in this : The The The The number number number number occurs times .

VideoNote Solution to Practice Program Chapter Standard Template Library Given variable of type string set to arbitrary text , write program that uses the stack template class of type char to reverse the string .

You have list of student followed by the course number by that the student is enrolled in .
The listing is in no particular order .
For example , if student is in and while student is in and then the list might look like this : Write program that reads data in this format from the console .
If the ID is then stop inputting data .
Use the map template class to map from an integer student to of type string that holds each class that the student is enrolled in .

After all data is input , iterate through the map and output the student ID and all classes stored in the for that student .
The should be list of classes organized by student ID .

If you using or higher then forget that you need space between the characters when defining the map of vectors .

Programming Projects Programming Projects require more than Practice Programs and can usually be solved many different ways .
Visit to complete many of these Programming Projects online and get instant feedback .

Write program that allows the user to enter any number of student names and their scores .
The program should then display the student names and scores according to the ascending order of scores .
Use the template class and the generic sort function from the STL .
Note that you will need to define structure or class type for data consisting of one student name and score .
You will also need to overload the operator for this structure or class .

prime number is an integer greater than and divisible only by itself and .

An integer is divisible by an integer if there is another integer such that .
The Greek mathematician Eratosthenes : gave an algorithm , called the Sieve of Eratosthenes , for finding all prime numbers less than some integer .
The algorithm works like this : Begin with list of integers through .
The number is the first prime .

We cross these off the list .
Then the first number after that was not crossed off is the next prime .

The multiples Programming Projects of are not primes .
Cross the multiples of off the list .
Note that is already gone , cross off , is already gone , cross off , etc .
The first number not crossed off is the next prime .
The algorithm continues on in this fashion until we reach .
All the numbers not crossed off the list are primes .

Use container for the integers .
Use an array of bool initially set to all true to keep track of integers .

Change the entry to false for integers that are crossed off the list .

We can improve our solution in several ways : program does not need to go all the way to .

Try this and test your program .
Argue that to get all the primes between and the minimum limit is the square root of .

Suppose you have collection of student records .
The records are structures of the following type : struct StudentInfo .

The records are maintained in .
Write program that prompts for and fetches data and builds vector of student records , then sorts the vector by name , calculates the maximum and minimum grades and the class average , then prints this summarizing data along with class roll with grades .

Continuing Programming Project , write function that separates the students in the vector of StudentInfo records into two vectors , one containing records of passing students and one containing records of failing are asked to do this in two ways , and to give some estimates .

You could generate second vector of passing students and third vector of failing students .
This keeps duplicate records for at least some of the time , so do it that way .
You could create vector of failing students and function .
Then you failing student records , then erase .

Chapter Standard Template Library is member the failing student records from the original vector .
Write the program this way .

You are potentially erasing members from the middle of vector .
You have to move lot operation .
Give estimate of the running time for this program .

Consider how the time efficiency of erase for list affects the for the program .
Rewrite this program using list instead of vector .
Remember that list provides neither indexing nor random access and its iterators are only bidirectional , not random access .

Use the generic function to compute the intersection of and .

Here is an example of to intersect with and store the result in , where all sets are sets of strings :

VideoNote Solution to Programming Project .
In this project you are to create database of books that are stored using vector .
Keep track of the author , title , and publication date of each book .

Your program should have main menu that allows the user to select from the following : Add author , title , and date ; Print an alphabetical list of the books sorted by author ; and Quit .

You must use class to hold the data for each book .
This class must hold three string fields : one to hold the name , one for the publication date , and another to hold the title .
Store the entire database of books in vector in which each vector element is book class object .

To sort the data , use the generic sort function from the library .

Note that this requires you to define the operator to compare two objects of type Book so that the author field from the two books are compared .

Programming Projects sample of the behavior might look as follows .
Your need not look identical , this is just to give you an idea of the functionality .

Select from the following choices :

Add new book .

Print listing sorted by author .

Quit Enter title : More Than Human Enter author : Sturgeon , Theodore Enter date : Select from the following choices :

Add new book .

Print listing sorted by author .

Quit Enter title : Problem Solving with Enter author : Savitch , Walter Enter date : Select from the following choices :

Add new book .

Print listing sorted by author .

Quit The books entered so far , sorted alphabetically by author are : Savitch , Walter .
Problem Solving with .

Select from the following choices :

Add new book .

Print listing sorted by author .

Quit Enter title : At Home in the Universe Enter author : Kauffman Enter date :

Chapter Standard Template Library Select from the following choices :

Add new book .

Print listing sorted by author .

Quit The books entered so far , sorted alphabetically by artist are : Kauffman , At Home in the Universe , Savitch , Walter .
Problem Solving with .

When creating containing lists , make sure to place space between the last two if you are using compiler earlier than .
For example , defines where elements are linked lists containing elements of type int .
The code without space will produce .
You have collected file of movie ratings where each movie is rated from to .
The first line of the file is number that identifies how many ratings are in the file .
Each rating then consists of two lines : the name of the movie followed by the numeric rating from to .
Here is sample rating file with four unique movies and seven ratings : Harry Potter and the Order of the Phoenix Harry Potter and the Order of the Phoenix The Bourne Ultimatum Harry Potter and the Order of the Phoenix The Bourne Ultimatum Glitter Write program that reads file in this format , calculates the average rating for each movie , and outputs the average along with the number of reviews .

Here is the desired output for the sample data : Glitter : review , average of Harry Potter and the Order of the Phoenix : reviews , average of Programming Projects The Bourne Ultimatum : reviews , average of : review , average of Use map or multiple maps to calculate the output .
Your should index from string representing each name to integers that store the number of reviews for the movie and the sum of the ratings for the movie .

Consider text file of names , with one name per line , that has been compiled from several different sources .
sample follows : Brooke Trout Dinah Soars Jed Dye Brooke Trout Jed Dye Paige Turner There are duplicate names in the file .
We would like to generate an invitation list but want to send multiple invitations to the same person .

Write program that eliminates the duplicate names by using the set template class .
Read each name from the file , add it to the set , and then output all names in the set to generate the invitation list without duplicates .

Do Programming Project from Chapter except use Racer class to store information about each race participant .
The class should store the name , bib number , finishing position , and all of his or her split times as recorded by the RFID sensors .
You can choose appropriate structures to store this information .
Include appropriate functions to access or change the information , along with constructor .

Use map to store the race data .
The map should use the bib number as the key and the value should be the Racer object that corresponds to the bib number .
With the map you need to search for bib number anymore , you can directly access the splits and final position based on the bib number .

If you using or higher then forget that you need space between the characters when defining the map of vectors .

Keywords The following keywords should not be used for anything other than their predefined purposes in the language .
In particular , do not use them for variable names or for functions .
In addition to the following keywords listed , identifiers containing double underscore are reserved for use by implementations and standard libraries and should not be used in your programs .

Precedence of Operators All the operators in given box have the same precedence .
Operators in higher boxes have higher precedence than operators in lower boxes .
Unary operators and the assignment operator are executed right to left when operators have the same precedence .
For example , means .
Other operators that have the same precedences are executed left to right .
For example , + + means + +

The ASCII Character Set Only the printable characters are shown .
Character number is the blank .

The function declaration gives the number and types of arguments as well as the type of the value returned .
In most cases , the function declarations give only the type of the parameter and do not give Arithmetic Functions Function Declaration Description .

Appendix Input and Output Member Functions Form of Function Call Description .

The is string fstream .

; Returns true if the previous operation as on the stream has failed .

; Returns true if the program has attempted to read beyond the last character in the file connected to the input stream .

Otherwise , it returns false .

; Reads one character from the input stream and sets the equal to this character .
Does not skip over whitespace .

If the line is more than Characters long , only the first are read .
The declared size of the should be fstream or iostream .

; Reads one character from the input stream and returns that character .
But the character read is not removed from the input stream ; the next read will read the same character .

Writes the value of the to the output stream .

; Places the value of in the input stream so that that value is the next input value read from the stream .
The file connected to the stream is not changed .

; Specifies the number of digits output after the decimal point for values sent to the output stream .

Sets the field width for the next value output to the stream .

See Display for the list of possible flags .

See Display for the list of possible flags .

If the value returned is value of type int , you must perform an explicit or implicit typecast to obtain char .

Function Declaration Description .

Returns true if its argument is an or lowercase letter .
It may also return true for other arguments .
The details are implementation dependent .
Otherwise , returns false .

Returns true if its argument is printable character that does not satisfy isalnum and is not whitespace .

Appends the value of the to .

Changes the value of the to .

Returns the NULL pointer if the Pattern is not found .

Returns the NULL pointer if Character is not found .

Returns the NULL pointer if Character is not found .

Returns an integer that is less than zero , zero , or greater than zero according to whether is less than , equal to , or greater than , respectively .
The ordering is lexicographic ordering .

is predefined integer constant that is in cstdlib .
The value of is dependent but will be at least .

Reinitializes the random number generator .
The argument is the seed .
Calling srand multiple times with the same argument will cause rand or random you to produce the same sequence of pseudorandom numbers .

If rand or random is called without any previous call to srand , the sequence of numbers produced is the same as if there had been call to srand with an argument of .

You can think of the argument type as int with the restriction that it must Appendix Trigonometric Functions These functions use radians , not degrees .

Function Declaration Description .

Inline Functions When member function definition is short , you can give the function definition within the definition of the class .
You simply replace the member function declaration with the member function definition ; however , since the definition is within the class definition , you do not include the class name and scope resolution operator .
For example , the class Pair defined below has inline function definitions for its two constructors and for the member function : class Pair .

Note that there is no semicolon needed after the closing brace in an inline function definition , though it is not incorrect to have semicolon there .

Inline function definitions are treated differently by the compiler and so they usually run more efficiently , although they consume more storage .

With an inline function , each function call in your program is replaced by compiled version of the function definition , so calls to inline functions do not have the overhead of normal function call .

If you want to use in an expression on the side of an assignment  then the must be defined to return reference , which is indicated by adding to the returned type .

Appendix Objects are declared and used as follows : Pair .

The this Pointer When defining member functions for class , you sometimes want to refer to the calling object .
The this pointer is predefined pointer that points to the calling object .
For example , consider class like the following : class Sample public :

Notice that this is not the name of the calling object , but is the name of pointer that points to the calling object .
The this pointer cannot have its value changed ; it always points to the calling object .

As the comment before the previous sample use of this indicates , you normally have no need for the pointer this .
However , in few situations it is handy .

One place where the this pointer is commonly used is in the assignment .
For example , consider the following class : Overloading the assignment Appendix class public :

The definition of overloaded assignment uses this pointer .

The definition above does have problem in one case : If same object occurs on both sides of assignment , then array member will be deleted .
To avoid problem , you can use pointer to test special case as follows : version with bug .

In section of Chapter entitled Assignment " we overloaded assignment for string class called StringVar .
In that section , we did not need pointer because we had member variable called that we could use to test whether or not same object was used on both sides of assignment .
With class discussed above , we have no such alternative because there is only one member variable .
In case , we have essentially no alternative but to use pointer .

For example , in Display of Chapter we overloaded + as friend .
We did by labeling friend inside class definition , as follows : amounts of money in The United States currency .

We then defined overloaded + outside class definition shown in Display .

It is also possible to overload + other as member operators .
To overload + as member  class definition would instead begin as follows : amounts of money in The United States currency .

Money ,  cost +

The first argument to + is an unqualified  and so it is member variable of calling object .

Overloading an as member variable can seem strange at first , but it is easy to get used to new .
Many experts advocate always overloading operators as member operators rather than as friends .
That is more in spirit of programming .
However , there is big disadvantage to overloading binary as member .
When you overload binary as member  two arguments are This is because Money has constructor with one argument of type long , and so value will be considered long value that is automatically converted to value of type Money .

However , if you overload + as member  then you cannot reverse two arguments to +
The following is illegal : + This is because cannot be calling object .
Conversion of long values to type Money works arguments but not calling objects .

On other hand , if you overload + as friend , then following is perfectly legal : +

Index SYMBOLS + addition  alert escape sequence , ampersand symbol ,  parameters , memory locations and , pointers , arrow_operator arrow  assignment  arithmetic operators and , dynamic data structures and , inheritance and , objects used with , overloading , pointers and , variables and , vectors , asterisk symbol , dereferencing operator , multiplication operator , pointer variable declaration , backslash , backslash escape sequence , Boolean and operator , comparison greater than or , Boolean not operator , Boolean or operator , braces , programming layout , conditional statements and , local variable declaration , loop body execution , nested statements and , structure member names , colon symbol , derived class separation , inheritance and , scope resolution operator , comma for separation in declarations , comment symbols , comparison equal to , comparison greater than operator , comparison less than equal to operator , comparison less than or equal to operator , comparison not equal to operator , decrement operators , direction arrows , directive notation , division operator , dot operator , double quote escape ,  double quotes for string characters , equal sign , extraction operator , factorial function , increment operators , insertion operator , new instruction , instruction , null character , parentheses , arguments , Index arithmetic order , Boolean expressions , controlling expressions , predefined functions and , return statements , type casting and , predefined function header files , real backslash escape , remainder operator , semicolons , end of declarations , for statements , structure definitions ,  single quotes for constant characters , square brackets , arrays using , multidimensional arrays and , variable declaration and , vectors using , + string concatenation ,

See also Procedural Blocks , branching statements as , functions and , local variables and , nested , scope , statement , bool values , data type , Index int , converting to , functions returning , Boolean expressions , and used in , arithmetic operations to , branching mechanisms , complete evaluation , data values , evaluating , int value conversion , looping mechanisms using , not  or  parentheses for , precedence rules , evaluation , subexpressions , values , truth tables , Braces , Branching mechanisms , and for , blocks , Boolean expressions , braces used for , break statements , flow of control using , comparison operators for , compound statements , controlling expression , flow of control using , statements , indenting , local variables , menus , multiway , nested statements , or operator for , function calls in , string of inequalities from , switch statements , break statements , branching mechanisms , flow of control using , loop mechanisms , looping mechanisms , nested loops using , switch statements , Bubble sort , Bug ,
See also Debugging Bytes , programming , arithmetic operators , assignment statements , asterisk symbol , backslash use , braces , branching mechanisms , cin statements , comments , compilers and , compiling , compound statements , constants , cout statements , data types , debugging , declaration of variables , direction arrows  directives , expressions , flow of control , increment and decrement operators , indentation , input , instructions , language , line breaks , loop mechanisms , function , names and , object code , output , programmer role , return statement , running , spacing , statements , user role , variables , programming , auto , constructor delegation in , conversion between strings and numbers , data values , decltype , member initialization in , nullptr in , Index strings , library , arguments , arrays , declaration of , equality used for , extraction operator used for , functions , getline function , initializing , insertion operator used for , null character  number conversions , parameters , predefined functions , robust input , strcat function , strcmp function , strcpy function , string object conversion , values , variables , parameters , for , arguments , combined with , function calls , memory locations  pointers , parameters , arguments for , combined with , classes  dynamic arrays  local variables as , Calls , absolute value functions , arguments  parameters , parameters , constructors , functions , header files  directives , loop body as , nested loops  predefined functions , procedural abstraction  functions , return statements  function , catch block , parameter , Central processing unit , char data type , Characters , blank spaces  data values , default arguments , editing text files , eof function for , functions , get function for , isspace function , member functions , function for , predefined functions , put function for , putback function for , stream parameters and , toupper and tolower for , values returned , whitespace , Child class , Chips , computer processors and , cin statements , Classes , abstract data types , adapter , ancestor , arrays and , base , programming and , parameters and , child , constructors for , containers , copy constructors for , Index defining , derived , destructors for , dot operator for , dynamic arrays and , encapsulation , exceptions , file and , friend functions , hierarchies , inheritance and , linked lists of , member functions of , member variables , programming and , objects and , overloading operators , parent , private members used in , public members used in , redefining functions , scope resolution operator for , streams and , string , stringvar , structures compared to , templates for , close function , Coding , array programs , procedural abstraction and , recursion programs , Colon , Comma separation in declarations , Comments , programming and , Compact discs , Comparison operators , and operator for , equal , greater than , greater than or equal , less than , less than or equal , not equal , or operator for , string class and , string of inequalities from , Compiler programs , interface for , programming , compiling process , error messages , directive , directive , language translation using , line breaks , linking code , object code , separate compilation , spacing , syntax error , testing , Complete evaluation , Compound statements , Computer systems , compilers , hardware , devices , languages for , linkers , mainframe , memory , network , operating systems , personal , processor , programs , software , Concatenation , strings , const modifier , array declaration using , array parameters , programming using , friend functions and , inconsistent use of , Constant array parameters , Constant iterators , Constant parameters , Constants , data types , declared , enumerated types , friend functions and , functions and , global named , naming , numbers , leading zeros in , single quotes ' for , string class conversion , Index Constructors , arrays and , calling , classes and , copy , default , dynamic arrays , inheritance and , initialization of objects , member functions as , no arguments and , overloaded , size of arrays and , string class and , vectors and , Container modifying algorithms , Containers , access running times , adapter classes , associative , auto , using with , deque , doubly linked lists , efficiency of , initializing , map class , class , queue class , ranged for , using with , sequential , set class , singly linked lists , stack class , templates for , type definitions in , Controlling expression , Copy constructors , loops , cout statements , debugging with , direction arrows , program output using , streams , as variable declaration and , Dangling pointers , Data , computer programs and , Data abstractions , templates for , Data types , arithmetic operators and , bool , Boolean , char , character , compatibility of , constants as , double , enumerated , expressions and , float , notation , int , integer , long , names for declaration , numeric , Op shorthand notation , short , string class and , templates for , variables as , Debugging , assert macro for , bugs , code , common errors , cout statement for , error messages , functions , localizing errors , logic errors , loops , error , retesting changes , errors , second opinions and , syntax errors , testing programs for , tracing variables , warning messages , Decimal notation , Declaration , arrays , cin statements for , comma for separation in , const modifier and , cout statements for , variables , double variable type , Index functions , illegal ranges , indexed variables , initializing in , int variable type , memory and , multidimensional arrays , postconditions , preconditions , functions , semicolon for end of , square brackets used for , streams , type names and , variables , vectors , Declared size , decltype , Decrement operators , Default arguments , Default constructors , delete operator , Deque , Dereferencing operator , Derived classes , operators used for , colon for separation of , constructors used in , copy constructors used in , defining , destructors used in , exception specification in , implementation of , inheritance and , redefining functions , Descendants , Destructors , dynamic arrays , inheritance and , polymorphism and , virtual , Digital video discs , function implementation , Direction arrows , Directives , Diskettes , Division operator , loop statements , break statement for , execution of , infinite , syntax of , Dot operator , double , arithmetic operators and , decimal notation for , exponent notation for , notation of , numeric data type , output values from , scientific notation of , variable type , Double quotes " for string characters , numbers , Doubly linked lists , Drivers , function testing using , Dynamic arrays , array variables and , and , parameters and , classes and , constructors for , copy constructors for , creating and using , delete  destructors for , linked lists and , multidimensional , new  pointer arithmetic and , pointer variables and , size of , square brackets used for , stringvar class , variables , Echoing input , Empty statements , Encapsulation , directive , endl instruction , eof function , equal function , Equal to comparison , Index Errors , arrays and , bugs , commas between index variables , common , compiler , constant parameters for , debugging , file , index variables out of range , localizing , logic , messages , polymorphism and , syntax , testing for , tracing variables , virtual member functions and , warning messages compared to , Escape sequences , Exceptions , parameter , catch block used for , class hierarchies , classes defined for , derived classes and , functions , throwing in , handler , handling , memory , testing for , multiple , nested blocks , overuse of , programming techniques for , rethrowing , specification , throw list , throw statement used for , throwing exceptions , trivial , try block used for , mechanism in , uncaught , Executable statements .
See Executing programs , exit function , loop termination , Exponent notation , Expressions ,
See also Arithmetic operators ; expressions External file name , Extraction operator , fabs function , factorial function , fail function , Files , abstract data types , appending , application , character and , close function used for , computer memory and , end of , eof function used for , error messages , exit function used for , external name , extraction operator for , fail function used for , implementation , include directives used for , insertion operator for , interface , member functions , memory storage and , names and , namespaces and , open function used for , opening successfully , permanent storage , as , reading , separate compilation of , streams and , text editing , writing , data structure , notation , Flags , Flash drives , float data type , notation , Flow of control , Boolean expressions for , branching mechanisms , Index programming and , comparison operators for , compound statements , enumerated types , increment and decrement operators , loop mechanisms , for statements , arrays using , empty statements , multistatement body , numeric calculations using , semicolons and , variables and , Formal parameters .
See Forward iterators , Freestore , friend functions , accessor functions and , const parameter modifier , constant parameters , implementation , equal , leading zeros in number constants , Money class , example for , nonmember functions , as , private members , access to , syntax , Function body , Function declaration , Function definition , Function headers ,
See also arguments and , arithmetic , array size and , arrays as arguments , arrays in , library , string , parameters , calls , case study : Production Graph , character , const parameter modifier , debugging , declaration , default arguments , definition , implementation , driver programs for , equal , factorial , flags and , formatting output using , friend , graph , indexed variables as , inheritance and , inline , local variables and , manipulators , member , member functions accessor , mutator , names , nonmember , not inherited , overloading names , overriding , parameters , polymorphism and , predefined , procedural abstraction and , random number generator , recursive , redefining functions , return statements , returning an array , scale , signature , stream , string , Index stub , subtasks , tasks , recursion for , testing , throwing exceptions in , design for , trigonometric , type casting , value returned , virtual , void , Generic algorithms , notation , container access running times , container modifying , nonmodifying sequence , running times , set , sorting , templates for , get function , getline function , Global named constants , Global scope , Global variables , graph function , Greater than comparison , Greater than or equal to comparison , Handling exceptions , Hard disks , Hardware computer systems and , devices , main memory , processor , secondary memory , Header files , predefined functions , Hierarchy of structures , languages , Identifiers , variables , statements , Boolean expressions for , braces used with , branching mechanisms , comparison operators for , compound statements and , dangling else problem , indenting , multiway branches , nested , directive , ifstream , Implementation files , ADT , Implementation phase , directive , programming and , directive notation for , file , header files and , directive and , manipulator functions and , output and , predefined functions and , preprocessors for , separate compilation and , Increment operators , Indentation , programming and , Indenting branching , Index of arrays , Indexed variables , arguments to functions , as , arrays and , commas between , declaration of , functions and , illegal range of , initializing , multidimensional arrays , square brackets used for , Infinite loop statements , Infinite recursion , Information hiding ,
See also Procedural Inheritance , ancestor class , operators used for , base class , child class , class hierarchy , colon used for , constructors used in , Index copy constructors used in , derived classes and , descendants , destructors and , function signature , functions not inherited , member functions , parent class , polymorphism and , private members and , protected qualifier , redefining functions , Initialization , arrays , strings , constructors for , declaration and , objects , structures , variables , Inline functions , Input , character data , cin statements for , computer hardware devices , echoing , for , get function , loops , design for ending , member functions for , character and , put function , putback function , reading files , streams , Input iterators , arguments and , programming and , strings , character , cin statements , cout statements , decimal points for formatting numbers , designing , double statements , end of files , escape sequences , files , flags , formatting , functions , getline function , directive , manipulators , namespaces , function , instruction , predefined character functions , streams , string class for , using directive , Insertion operator , int , arithmetic operators and , array declaration using , Boolean expressions and , enumerated types , numeric data type , unsigned type , value conversion , variable declaration , vector declaration using , Integers , data values , type casting by division , variables , Interface files , ADT , flag , flag , flag , flag , flag , iostream library , isalpha function , isdigit function , islower function , isspace function , isupper function , Index Iterators , auto , variable declaration using , bidirectional , compiler problems , constant , for , dereferencing operator for , forward , for , input , loop mechanisms and , mutable , operators for , output , pointers as , random access , recursion compared to , recursive program version , reverse , templates for , types of , using directives for , vectors and , Languages , assembly , programming , compilers for translation of , computer programs and , linker programs for , machine , program translation of , data structure , Late binding , Leaf nodes , length function , Less than comparison , Less than or equal to comparison , Lexicographic order , Line breaks , programming , Linear running time , Linked lists ,
See also Containers arguments , as , operators used with , classes and , data structures , as , doubly , dynamic data structures in , head of , inserting nodes in , losing nodes , middle , Node class , nodes and , pointers and , queues and , removing nodes from , searching , singly , stacks , Linker programs , List loop , Local variables , block scope , parameters as , functions and , global constants and , global scope , global variables and , inadvertent , namespaces and , scope of , Logic errors , long data type , Loop mechanisms , technique for , body , Boolean expressions for , braces for execution of , break statement for , debugging , decrement operators , design choices , statements , ending input loops , termination , flags , flow of control using , for statements , increment operators , infinite , iteration , list termination , nested , procedural abstraction and , Index products obtained using , semicolons and , sentinel value , sums obtained using , uninitialized variables and , while statements , zero times body execution , language , Machine language , function , Main memory , Mainframe computer systems , Manipulator functions , map class , Member functions , at , accessor functions and , BankAccount class examples of , blank spaces and , strings , character and , classes and , constructors , definition of , dot operator used for , eof , exit , fail , get , getline , inheritance and , length , mutator functions and , character and , objects and , private , protected , public , put , putback function , recursion and , redefinition of , scope resolution operator used for , stream using , string class use of , Member names , structures , Member values , structures , Member variables , structures , Memory , addresses , array declaration and , array parameters , bits , bytes , parameters and , computer hardware components , delete operator for , dynamic variables , files , freestore , locations , main , management , pointers for , random access , secondary , sequential access of , storage as , variables and , Menus , program choices using , switch statements for , Messages , errors , Monitor , computer output device , Multidimensional arrays , commas between indexes , declarations for , delete operator and , dynamic , indexed variables and , parameters , size of , square brackets used for , example of , Multiplication operator , Mutable iterators , Mutator functions , Names , constants , data types , external file , files , formal parameters , functions and , Index global constants , identifiers , overloading functions , pointer types , procedural abstractions , streams , typedef function , variables , Namespaces , classes and , creating , file and , global , local variables and , names for , output and , qualifying names , stream and , unnamed , using directives for , Nesting , blocks , braces used for , break statement in , dangling else problem , function calls and , statements , indenting statements , loops , multiway branches , procedural abstraction and , scope of the block for , statements , blocks , Network computer systems , new  dynamic arrays and , pointers using , function , instruction , programming and , endl used in place of , input and , member functions and , output and , Node class , Nodes , arrow used with , binary trees and , doubly linked lists , head of lists , inserting at , inserting to lists , leaf , linked lists and , lost , middle of lists , inserting and removing , NULL constant used in , pointer variables and , removing from lists , root , searching linked lists using , structures , trees and , Nonmember functions , Nonmodifying sequence algorithms , Not equal to comparison , Not , Null character , NULL constant , Null statements , nullptr , in programming , Number formatting , decimal points for , string conversions , Numeric calculations ,
See also Arithmetic operators for loop statements for , loop design for , products , sums , Numeric data values , Object code , programming , classes , encapsulation , inheritance , polymorphism , program design using , Objects , used with , classes and , constructors for , file and , initialization of , member functions , public and private , streams and , Index error , ofstream , Op  open function , Operating systems , computer software for , Operators , arithmetic , Boolean expressions , comparison , decrement , extraction , increment , insertion , overloading , precedence , unary , Or , Output , computer hardware devices , cout statements , decimal points for formatting numbers , double statements , escape sequences , flags , formatting functions , insertion for , manipulators , for , streams , writing files , Output iterators , Overloading , array index , constructors , extraction , function names , insertion , operators , recursion compared to , type conversion and , unary operators , Overriding functions , Parameters , arguments and , array , arrays and , string , character , const modifier , constant , constant array , formal , friend functions and , function arguments and , function calls using , function declarations using , function subtasks using , local variables and , memory locations , mixed lists , multidimensional arrays , names , pointers , procedural abstraction and , functions , size of arrays and , stream versatility , Parent class , Parentheses , Partially filled arrays , Personal computer , Pointer variables , Pointers , addresses , ampersand symbol and , arithmetic performed on , arrow used with , assignment and , asterisk used for , automatic variables , parameters for , parameters , dangling , Index declaration of , delete  dereferencing for , destructors and , dynamic arrays and , dynamic variables and , freestore , iterators , used as , linked lists and , memory management for , names , new  nodes , NULL constant assigned to , queues and , stacks and , static variables , structures containing , this , trees and , typedef function , variables and , Polymorphism , destructors made virtual for , errors , late binding , overriding functions , virtual functions and , pop function , Postconditions , pow function , Precedence rules , Preconditions , Predefined functions , abs , absolute values , arguments , string , calls , character data , fabs , header files and , directives , isspace , parentheses and , pow , random number generation using , sqrt , srand , strcmp , conversions , strncpy , toupper and tolower , type casting using , using directive , value returned , class , private members , and , accessor functions and , classes using , friend function access to , inheritance and , mutator functions and , public members and , phase , Procedural abstraction , algorithm design for , black box analogy , case study : Buying Pizza , case study : Supermarket Pricing , coding , functions calling functions , functions returning values , information hiding , nested loops and , parameter names and , postconditions , preconditions , problem analysis , program testing , pseudocode for , subfunctions using , Processor , computer component , Programmer role , functions , arguments and , body , bool values , returning , branching statements and , parameters , calls , declaration , Index definitions , headers , parameters , return statements , spacing and line breaks in , syntax of , value returned , Programming ,

See also programming ; programming abstract data types , algorithms , implementation phase , phase , program design for , software life cycle , Programs , algorithms for , compiler , computer software as , debugging , design of , for programming , executing , languages for , implementation design phase , language translation and , linker , logic errors , object code design phase , errors , running , source code , syntax error , testing , protected members , Pseudocode , public members , accessor functions and , classes using , mutator functions and , put function , putback function , Quadratic running time , queue class , Queues , Random access iterators , Random access memory , Random number generation , Ranged for , using with containers , Reading files , Recursion , base cases , case study : Binary Search , case study : Vertical Numbers , checking program for , design techniques , efficiency of , ending , function definition , functions , infinite , iteration compared to , iterative version of , data structure , member functions as , overloading compared to , returning values , stacks for , tasks , functions for , tracing recursive calls , values , functions for , void functions and , Remainder operator , reserve function , resize function , Rethrowing exceptions , return statements , programming and , functions and , parentheses for , functions , void functions using , Returning values , see Value returned Reverse iterators , Robust input , strings , Root node , Running programs , Running times , errors , scale function , Scientific notation , Scope , block , global , local , variables , Scope resolution operator , Searching arrays , Searching linked lists , Secondary memory , Selection sort , Semicolons , Index Sentinel value , loop design and , Sequential access , memory and , Sequential containers , set algorithms , set class , setf function , setprecision manipulator , setw manipulator , short data type , evaluation , Single quotes ' for constant characters , numbers , Size of , array parameters , arrays , capacity compared to , const modifier for , constructors and , declared , dynamic arrays , function arguments and , multidimensional arrays , partially filled arrays , resize function , vectors , Software , abstract data types , computer operating systems , life cycle , programs , reusable components , Sorting algorithms , Sorting arrays , Source code , Spacing , programming , character and , function definition and , sqrt function , Square brackets , srand function , Stack class , Stacks , empty , implementation of , data structure , linked lists as , overflow , pointers and , pop function , recursion and , Standard Template Library ,
See also Templates Statements , programming instructions , cin , cout , direction arrows , directives , executable , directive , new , return , semicolon , Static variables , std namespace , Stepwise refinement , Storage , memory as , strcat function , strcmp function , strcpy function , Streams , appending to file , arguments to functions , as , character and , cin as , classes and , cout as , declaring , default arguments , fail function , file names and , files and , flags and , formatting functions , ifstream , manipulator functions for , member functions and , namespaces and , objects and , ofstream , output , formatting using , parameters , using directives and , variables as , string class , library , characters , comparison operators and , concatenation , constants converted to , data types and , default constructor for , double quotes " for characters , getline function , using , Index lexicographic ordering of , member functions , string conversion , palindrome testing program example , variable declaration , whitespace characters and , String functions , String values , strings , dynamic arrays , implementation , size of , String variables , stringvar class , strlen function , strncat function , strncmp function , strncpy function , Structures , braces for , classes compared to , diverse data of , dot operator for , functional arguments , as , hierarchy of , initializing , linked lists and , member names , member values , member variables , nodes as , pointer variables for , semicolons for , value , Stubs , function testing using , Subexpressions , Subtasks , assert macro , parameters , debugging functions , functions for , procedural abstraction , testing functions , void functions , Subtraction operator , switch statements , break statements , menus , multiway branching , Syntax , class templates for , errors , variable declaration and , Tasks , recursive functions for , Templates , algorithm abstraction , class syntax , containers , data abstractions , function definition , generic algorithms , iterators , Standard Template Library , type definitions , Terminal , computer output device , Testing programs , boundary values , compiling and running programs , debugging and , drivers , error messages , functions , input , logic errors , procedural abstraction and , program testing , errors , scale function , stubs , syntax errors , warning messages , Text files , editing , this pointer , Throw list , throw statement , Throwing exceptions , design , toupper and tolower functions , Tracing recursive calls , Tracing variables , Trees , data structures as , Trigonometric functions , Trivial exceptions , values ,
See also Boolean Truth tables , blocks , mechanism , arrays , Type casting , Type name , variables , typedef function , Unary operators , Uninitialized variables , unsigned int type , User role , using directive , Index Value returned , bool statements , character data , predefined functions , functions , recursion , return statements , toupper and tolower , functions for , Values , recursive functions for , Variables , arithmetic operators for , arrays and , assignment statements , asterisk used for , automatic , blocks and , strings , cin statements , class members , cout statements , data types , declaration of , dereferencing operator for , dynamic , dynamic arrays and , equal for , for statements for , function and , global , identifiers , operators for , indexed , initializing , integers as , local , loop mechanisms and , memory locations , naming , new for , null character and , pointers , scope , square brackets used for , static , streams as , string , syntax for , tracing , type name , uninitialized , values , vectors , Vectors , assignment for , function , capacity of , constructor , declaring variables , efficiency of , indexed variables , iterators for , reserve function , size of , square brackets used for , unsigned int type , variable values , Virtual functions , polymorphism and , void functions , definition , calls , recursion and , return statements in , syntax , Warning messages , while loop statements , braces for execution of , break statement for , increment and decrement operators , infinite , nested , syntax of , zero times body execution , Whitespace characters , width function , Workstation , Writing abstract data types , Writing files , Zero times loop body execution , Zeros leading in number , Credits Cover , Corbis Figure , Alamy Figure , Alamy Figure , Alamy Chapter , pg .
As soon as an Analytical Engine exists , it Chapter , pg .
It can do whatever we know how to order it to perform .
It can follow ; but it has no power of anticipating any analytical relations or truths .
Its province is to assist us in making available what we are already acquainted " Ada Augusta , Chapter , pg .

computer terminal is not some clunky old television with typewriter in front of it .
It is an interface where the mind and the body can connect with the universe and move bits of it " Douglas Adams , Mostly Harmless fifth volume in The Chapter , pg .
Dijkstra , Notes on Structured Programming Chapter , pg .
not her " Overheard at cocktail party Chapter , pg .
" Lewis Carroll , Through the .

CREDITs depends good deal on where you want to get " said the " Lewis Carroll , Alice in Wonderland Chapter , pg .
Vincent Millay , Letter to Arthur Darison Ficke , October , Traditional Carnival Call Chapter , pg .
glory for " know what you mean by '  Alice said .
Humpty Dumpty smiled contemptuously , course you till tell you .
mean nice argument for '  mean nice '  Alice objected .

Hamlet : Words , words , William Shakespeare , Hamlet Chapter , pg .

That which we call rose By any other name would smell as " William Shakespeare , Romeo and Juliet Chapter , pg .
James , but wrong .
got better " said the little old lady .

CREDITs the inadequacies of her position .
James , and very good " replied the little old lady , have an answer to it .
And it is this : the first turtle stands on the back of second , far larger , turtle , who stands directly under " what does this second turtle stand " persisted James patiently .
To this the little old lady crowed triumphantly .
turtles all the way "
Ross , Constraints on Variables in Syntax begins to relate word for word the story of the Thousand and One Nights , establishing the risk of coming once again to the night when she must repeat it , and thus to " Jorge Luis Borges , The Garden of Forking Paths Chapter , pg .
know it had to work for that " Computer Science Student , Appealing Grade Chapter , pg .
Aristotle is man .
Therefore , Aristotle is mortal .

All cats are mischievous .
Garfield is cat .
Therefore , Garfield is " Short Lesson on Syllogisms Chapter , pg .

Chapter Random Number Generation ,
