Complete Tips Secrets for Professionals Complete Tips Secrets for Professionals pages of professional hints and tricks Free Programming Books Disclaimer This is an free book created for educational purposes and is not with or .

All trademarks and registered trademarks are the property of their respective owners Contents About .

Covariant result version of the base example , static type checking .
Covariant smart pointer result .

Chapter : Arithmitic Metaprogramming .

Images may be copyright of their respective owners unless otherwise speciﬁed This book creation is not aﬃliated with nor Stack Overﬂow , and all terms and trademarks belong to their respective company owners The information presented in this book is not guaranteed to be correct nor accurate , use at your own risk Send feedback and corrections to Complete Tips Secrets for Professionals Chapter : Getting started with Version Standard Release Date TBD TBD Section : Hello .

Analysis examine each part of this code in detail : is preprocessor directive that includes the content of the standard header ﬁle iostream .

These deﬁnitions are included in the std namespace , explained below .

The standard streams provide ways for programs to get input from and output to an external system usually the terminal .

By convention , the main is called upon execution of the program .
There must be only one main in program , and it must always return number of the int type .

Here , the int is what is called the return type .
The value returned by the main is an exit code .

By convention , program exit code of or is interpreted as success by system that executes the program .
Any other return code is associated with an error .

If no return statement is present , the main thus , the program returns by default .
In this example , we need to explicitly write return .

All other functions , except those that return the void type , must explicitly return value according to their return type , or else must not return at all .

Here , we use : to show we want to use from the std namespace .

For more information refer to Scope Resolution Operator Microsoft Documentation .

The standard library deﬁnes the operator to perform data insertion for certain data types into output streams .
This allows stream insertions to be chained :  prints " to the console .

Inserting manipulator into stream changes the state of the stream .

The stream manipulator does two things : ﬁrst it inserts the character and then it ﬂushes the stream buﬀer to force the text to show up on the console .
This ensures that the data inserted into the stream actually appear on your console .

The semicolon notiﬁes the compiler that statement has ended .
All statements and class deﬁnitions require an semicolon .

Section : Comments comment is way to put arbitrary text inside source code without having the compiler interpret it with any functional meaning .
Comments are used to give insight into the design or method of program .

There are two types of comments in : Comments The double sequence will mark all text until newline as .

Comments The sequence is used to declare the start of the comment block and the sequence is used to declare the end of comment .
All text between the start and end sequences is interpreted as comment , even if the text is otherwise valid syntax .
These are sometimes called " comments , as this comment syntax is inherited from predecessor language ,

Block comments can also start and end within single line .
For example : void argument int , argument int ; Importance of Comments As with all programming languages , comments provide several beneﬁts : Explicit documentation of code to make it easier to Explanation of the purpose and functionality of code Details on the history or reasoning behind the code Placement of , project notes , special thanks , contributor credits , etc .

However , comments also have their downsides : They must be maintained to reﬂect any changes in the code Excessive comments tend to make the code less readable The need for comments can be reduced by writing clear , code .
simple example is the use of explanatory names for variables , functions , and types .
Factoring out logically related tasks into discrete functions goes with this .

Comment markers used to disable code Complete Tips Secrets for Professionals During development , comments can also be used to quickly disable portions of code without deleting it .
This is often useful for testing or debugging purposes , but is not good style for anything other than temporary edits .
This is often referred to as .

Similarly , keeping old versions of piece of code in comment for reference purposes is frowned upon , as it clutters ﬁles while oﬀering little value compared to exploring the history via versioning system .

Section : The standard compilation process Executable program code is usually produced by compiler .

Using compiler to translate code is called compilation .

inherits the form of its compilation process from its " language ,
Below is list showing the four major steps of compilation in :
The preprocessor copies the contents of any included header ﬁles into the source code ﬁle , generates macro code , and replaces symbolic constants deﬁned using with their values .

The expanded source code ﬁle produced by the preprocessor is compiled into assembly language appropriate for the platform .

The assembler code generated by the compiler is assembled into appropriate object code for the platform .

The object code ﬁle generated by the assembler is linked together with the object code ﬁles for any library functions used to produce an executable ﬁle .

Note : some compiled code is linked together , but not to create ﬁnal program .
Usually , this " code can also be packaged into format that can be used by other programs .
This of packaged , usable code " is what programmers refer to as library .

Many compilers may also merge or certain parts of the compilation process for ease or for additional analysis .
Many programmers will use diﬀerent tools , but all of the tools will generally follow this generalized process when they are involved in the production of program .

The link below extends this discussion and provides nice graphic to help .

Functions can accept arguments or values and return single value .
To use function , function call is used on argument values and the use of the function call itself is replaced with its return value .

Every function has type signature the types of its arguments and the type of its return type .

Functions are inspired by the concepts of the procedure and the mathematical function .

Note : functions are essentially procedures and do not follow the exact deﬁnition or rules of mathematical functions .

Functions are often meant to perform speciﬁc task .
function must be declared and deﬁned before it is called elsewhere in program .

Note : popular function deﬁnitions may be hidden in other included ﬁles for convenience and reuse across many .
This is common use of header ﬁles .

Complete Tips Secrets for Professionals Function Declaration function declaration is declares the existence of function with its name and type signature to the compiler .

The syntax is as the following : In the example above , the int function declares the following to the compiler : The return type is int .

The name of the function is .

The number of arguments to the function is : The ﬁrst argument is of the type int .

The ﬁrst argument will be referred to in the contents by the name .

The argument name is optional ; the declaration for the function could also be the following : int ; Omitting the function arguments ' name is also permitted .

Per the rule , function with certain type signature can only be declared or deﬁned once in an .

If function returns nothing , its return type is written as void .
If it takes no parameters , the parameter list should be empty .

Function Call function can be called after it has been declared .
For example , the following program calls with the value of .

Here , is the syntax for function call .

Function Deﬁnition function is similar to declaration , except it also contains the code that is executed when the function is called within its body .

Complete Tips Secrets for Professionals .

Both functions are called by the same name , but the actual function that is called depends directly on the amount and type of the parameters in the call .
In most cases , the compiler can compute which function to call .

In some cases , the type must be explicitly stated .

Default Parameters Default values for function parameters can only be speciﬁed in function declarations .

Default arguments must be placed in the latter arguments of the function .

The most common example is that of operators .

Certain special character sequences that will be reduced to function calls by the compiler , such as , + and and many more .
These special characters are normally associated with usage or are used for aesthetics .

handles these character sequences with special syntax ; but , in essence , each occurrence of an operator is reduced to function call .
For example , the following expression : Complete Tips Secrets for Professionals .

All operator function names start with operator .

While in immediate predecessor , operator function names cannot be assigned diﬀerent meanings by providing additional deﬁnitions with diﬀerent type signatures , in , this is valid .

Section : Visibility of function prototypes and declarations In , code must be declared or deﬁned before usage .
For example , the following produces compile time .

The prototype must specify the return type , the name of the function , and the argument list variable types , but the names of the arguments are NOT required .

One common way to integrate this into the organization of source ﬁles is to make header ﬁle containing all of the prototype declarations :

These can be trickier to resolve as the compiler report the error until the ﬁnal linking stage , and it know which to jump to in the code to show the error .

Section : Preprocessor The preprocessor is an important part of the compiler .

It edits the source code , cutting some bits out , changing others , and adding other things .

In source ﬁles , we can preprocessor directives .
These directives tells the preprocessor to perform speciﬁc actions .
directive starts with on new .
Example : ZERO The ﬁrst preprocessor directive you will meet is probably the .

The language , which also uses the preprocessor , does not have as many header ﬁles as the language , but in you can use all the header ﬁles .

The next important directive is probably the directive .
This tells the preprocessor that as it goes along the ﬁle , it should replace every occurrence of with .
It can also make things similar to functions , but that probably counts as advanced .

The is not needed , but if you deﬁne as nothing , then outside preprocessor directives , all occurrences of will vanish .

This actually is useful , because of the and directives .
The format for these would be the following : code .

Chapter : Templates declaration export declaration until declaration declaration extern declaration since .

is piece of code with some free parameters that will become concrete class , function , or variable when all parameters are speciﬁed .
Parameters can be types , values , or themselves templates .
is , which becomes concrete container type when the element type is speciﬁed ,

Section : Basic Class Template The basic idea of class is that the parameter gets substituted by type at compile time .
The result is that the same class can be reused for multiple types .
The user speciﬁes which type will be used when variable of the class is declared .
Three examples of this are shown in : using .

Section : Function Templates Templating can also be applied to functions well as the more traditional with the same eﬀect .

In both these case the argument used to replace the types of the parameters ; the result works just like normal function the parameters match the type the compiler applies the standard .

One additional property of functions that the compiler can infer the parameters based on the parameters passed to the function .

In this case the parameters are two different types .

The compiler unable to deduce the type of because there are contradictions .
As result this compile time error .

This feature allows us to simplify code when we combine structures and functions .
There common pattern in the standard library that allows us to make structure using helper function .

Create object explicitly defining the types Create object using the types of the paramters .

In this code both and are the same type .

Note : This not designed to shorten the code .
This designed to make the code more robust .
It allows the types to be changed by changing the code in single place rather than in multiple locations .

Section : Variadic data structures It often useful to deﬁne classes or structures that have variable number and type of data members which are deﬁned at compile time .
The canonical example , but sometimes it necessary to deﬁne your own custom structures .
Here an example that deﬁnes the structure using compounding than inheritance as with .
Start with the general deﬁnition , which also serves as the for recrusion termination in the later specialisation :
struct DataStructure ; This already allows us to deﬁne an empty structure , data , albeit that very useful yet .

Next comes the recursive case specialisation : typename .
struct , Rest .

First , note that this specialisation whose requirement that at least one variadic parameter exists , whilst not caring about the speciﬁc makeup of the pack Rest .
Knowing that exists allows the deﬁnition of its data member , first .
The rest of the data recursively packaged as .
The constructor initiates both of those members , including recursive constructor call to the rest member .

To understand this better , we can work through an example : suppose you have declaration , data .
The declaration ﬁrst matches against the specialisation , yielding structure with int first and rest data members .
The rest deﬁnition again matches this specialisation , creating its own float first and rest members .
Finally this last rest matches against the deﬁntion , producing an empty structure .

So we get method to it needed in the specialisation as the structure has no data to : typename .
struct , Rest .

As you can see this get member function itself templated this time on the index of the member that needed usage can be things like , similar to .
The actual work done by static function in helper .
The reason we deﬁne the required functionality directly in get because we will shortly we would need to specialise on but it possible to specialise template member function without specialising the containing class template .
Note also the use of auto here makes our lives signiﬁcantly simpler as otherwise we would need quite complicated expression for the return type .

So on to the helper class .
This time we will need an empty forward declaration and two specialisations .
First the declaration :  typename struct  Now the .
In this case we just return the first .

In the ﬁrst case , the type is deduced as reference to , and the type of is lvalue reference to , while in the second case the type of is deduced as and the type of as rvalue reference to .

Note : It is worth noticing that in the ﬁrst case , is the same as , but not in the second .

In order to perfectly to another function it is an lvalue or rvalue reference , one must use : template .

Partial template specialization is only available for template : Common .

As shown above , partial template specializations may introduce completely diﬀerent sets of data and function members .

When partially specialized template is instantiated , the most suitable specialization is selected .
For example , deﬁne template and two partial specializations :  typename , typename .

Section : Template Specialization You can deﬁne implementation for speciﬁc instantiations of template .

For example if you have : template Some generic implementation .

Section : Alias .

Alias templates cannot be specialized .
However , that functionality can be obtained indirectly by having them refer to nested type in struct : struct typedef type ;

Section : Explicit instantiation An explicit instantiation deﬁnition creates and declares concrete class , function , or variable from  without using it just yet .
An explicit instantiation can be referenced from other translation units .
This can be used to avoid deﬁning in header ﬁle , if it will only be instantiated with ﬁnite set of arguments .

Because and are explicitly instantiated in , the linker will be able to ﬁnd them even though the is not deﬁned in the header .
If these explicit instantiation declarations were not present , linker error would likely occur .
See Why can templates only be implemented in the header ﬁle .

If an explicit instantiation deﬁnition is preceded by the extern keyword , it becomes an explicit instantiation declaration instead .
The presence of an explicit instantiation declaration for given specialization prevents the implicit instantiation of the given specialization within the current translation unit .
Instead , reference to that specialization that would otherwise cause an implicit instantiation can refer to an explicit instantiation deﬁnition in the same or another TU .

Section : parameter Apart from types as parameter we are allowed to declare values of constant expressions meeting one of the following criteria : integral or enumeration type , to object or to function , lvalue reference to object or lvalue reference to function , to member ,

Like all parameters , parameters can be explicitly speciﬁed , defaulted , or derived implicitly via Template Argument Deduction .

Example of parameter usage : Complete Tips Secrets for Professionals .

Section : Declaring arguments with auto Prior to , when writing parameter , you had to specify its ﬁrst .
So common pattern became writing something like : 

The solution is to simplify this idiom and simply allow auto :

nice motivating example can come from trying to combine the empty base optimization with custom deleter for .
Diﬀerent API deleters have diﬀerent return types , but we don ' care we just want something to work for any function : struct FunctionDeleter .

This is what parameters are created for .
Very simple parameter examples : struct ;

Section : Default parameter Just like in of the function arguments , parameters can have their default values .
All parameters with default have to be declared at the end of the parameter list .
The basic idea is that the parameters with default can be omitted while instantiation .

Simple example of default parameter usage :  struct .

Chapter : Metaprogramming In Metaprogramming refers to the use of macros or templates to generate code at .

In general , macros are frowned upon in this role and templates are preferred , although they are not as generic .

Template metaprogramming often makes use of computations , whether via templates or constexpr functions , to achieve its goals of generating code , however computations are not metaprogramming per se .

Section : Calculating Factorials Factorials can be computed at using metaprogramming techniques .

In the above code , we evaluate the metafunction by instantiating the with the parameters we want to pass , and using : to get the result of the evaluation .

Complete Tips Secrets for Professionals The metafunction itself relies on recursively instantiating the same metafunction with smaller values .
The specialization represents the terminating condition .
Template metaprogramming has most of the restrictions of functional programming language , so recursion is the primary " construct .

Since metafunctions execute at compile time , their results can be used in contexts that require compiletime values .
For example : Automatic arrays must have deﬁned size .
And the result of metafunction is constant , so it can be used here .

Limitation : Most of the compilers allow recursion depth beyond limit .
For example , compiler by default limits recursion depeth to levels .
In case of , programmer can set recursion depth using option .

Since , the : template can be used for this kind of template computation :

Since , many restrictions for constexpr functions have been dropped and they can now be written much more .

Section : Iterating over parameter pack Often , we need to perform an operation over every element in variadic template parameter pack .
There are many ways to do this , and the solutions get easier to read and write with .
Suppose we simply want to print every element in pack .
The simplest solution is to recurse :

With , we get two powerful new in our arsenal for solving this problem .
The ﬁrst is .

Since , the standard provides the class template template 
class  template .

While this comes standard in , this can be implemented using .

Section : Tag Dispatching simple way of selecting between functions at compile time is to dispatch function to an overloaded pair of functions that take tag as one the argument .
For example , to implement , we can dispatch on the iterator category : namespace details .

The arguments of the overloaded functions are unused function parameters .
The actual implementation does not matter is completely .
Their only purpose is to allow the compiler to select an overload based on which tag class is called with .

In this example , advance uses the metafunction which returns one of the classes , depending on the actual type of Iter .
object of the then lets the compiler select one of the diﬀerent overloads of .

Note : while if constexpr may simplify the implementation of advance in particular , is not suitable for open implementations unlike tag dispatching .

Complete Tips Secrets for Professionals Section : Detect Whether Expression is Valid It is possible to detect whether an operator or function can be called on type .
To test if has an overload of .

For detecting if an operator , such as is deﬁned , the syntax is almost the same : struct 

Section : Manual distinction of types when given any type When implementing SFINAE using , is often useful to have access to helper templates that determines if given type matches set of criteria .

To help us with that , the standard already provides two types analog to true and false which are and .

The following example show how to detect if type is pointer or not , the mimic the behavior of the standard helper : struct 

The ﬁrst declaration of is the default case , and inherits from .
The default case should always inherit from since is analogous to .

The second declaration specialize the for pointer without caring about what is really .
This version inherits from .

The third declaration real simply remove any unnecessary information from this case we remove const and volatile and then fall backs to one of the two previous declarations .

Since is  to access its value you need to either : Use ,

Complete Tips Secrets for Professionals It is good habit to provides helper templates " that let you directly access the value : constexpr bool ;

With and higher calculations at compile time can much easier .
For example calculating the of given number at compile time will following :

Keyword constexpr is responsible for calculating function in compilation time , then and only then , when all the requirements for this will met more at constexpr keyword for example all the arguments must known at compile time .

Note : In constexpr function must compose only from one return statement .

Advantages : Comparing this to the standard way of compile time calculation , this method is also useful for runtime calculations .
It means , that if the arguments of the function are not known at the compilation time .

possible to write generic function example which accepts various numerical types and arbitrary argument count by .
This function declares min for two arguments and recursively for more .

Chapter : Iterators Section : Overview Iterators are Positions Iterators are means of navigating and operating on sequence of elements and are generalized extension of pointers .
Conceptually it is important to remember that iterators are positions , not elements .
For example , take the following sequence : The sequence contains three elements and four positions Elements are things within sequence .
Positions are places where meaningful operations can happen to the sequence .
For example , one inserts into position , before or after element , not into an element .
Even deletion of an element is done by ﬁrst ﬁnding its position , then deleting it .

From Iterators to Values To convert from position to  an iterator is dereferenced : auto ; position auto ;

In all the sequences and containers found in the standard library , will return an iterator to the ﬁrst position , and will return an iterator to one past the last position the last .
Consequently , the names of these iterators in algorithms are oftentimes labelled first and last :

Some situations where this view is particularly useful are : insert operations will insert elements into the position indicated by the iterator , erase operations will return an iterator corresponding to the same position as the one passed in , an iterator and its corresponding reverse iterator are located in the same between elements Invalid Iterators An iterator becomes invalidated if , in the course of an its position is no longer part of sequence .

An invalidated iterator cannot be dereferenced until it has been reassigned to valid position .

Each algorithm is diﬀerent in the way they treat iterators .

Navigating with Iterators As we know , iterators are for navigating sequences .
In order to do that an iterator must migrate its position throughout the sequence .
Iterators can advance forward in the sequence and some can advance .

Note , second argument of should be reachable from the ﬁrst , in other words should be less or equal than .

Even though you can perform arithmetic operators with iterators , not all operations are deﬁned for all types of iterators .
So it is recommended to use special functions in case you are not sure what is iterator type example , in template function accepting .

Iterator Concepts The standard describes several diﬀerent iterator concepts .
These are grouped according to how they behave in the sequences they refer to .
If you know the concept an iterator models , you can be assured of the behavior of that iterator regardless of the sequence to which it belongs .
They are often described in order from the most to least restrictive the next iterator concept is step better than its : Input Iterators  Can be dereferenced only once per position .
Can only advance , and only one position at time .

Forward Iterators  An input iterator that can be dereferenced any number of times .

Bidirectional Iterators  forward iterator that can also advance backwards one position at time .

Random Access Iterators  bidirectional iterator that can advance forwards or backwards any number of positions at time .

Contiguous Iterators  random access iterator that guaranties that underlying data is contiguous in memory .

Algorithms can vary depending on the concept modeled by the iterators they are given .
For example , although can be implemented for forward iterators , more eﬃcient variant that requires random access iterators could be provided .

Iterator traits Iterator traits provide uniform interface to the properties of iterators .
They allow you to retrieve value , diﬀerence , pointer , reference types and also category of iterator : Complete Tips Secrets for Professionals .

Section : Vector Iterator begin returns an iterator to the ﬁrst element in the sequence container .

If the object is const , both begin and end return .
If you want to be returned even if your is not const , you can use cbegin and cend .

Complete Tips Secrets for Professionals .

Output : Section : Reverse Iterators If we want to iterate backwards through list or we can use .
reverse iterator is made from bidirectional , or random access iterator which keeps as member which can be accessed through .

To iterate backwards use and as the iterators for the end of the collection , and the start of the collection respectively .

For instance , to iterate backwards .

In the visualization where iterators mark positions between elements , the relationship is simpler :

Section : Stream Iterators Stream iterators are useful when we need to read sequence or print formatted data from container : Data stream .
Any number of various whitespace characters will be OK .

The example program will print to standard output .

This code would output the numbers through , one on each line like this : Complete Tips Secrets for Professionals .

The ﬁrst pointer is given the value of the pointer , which is the address of the ﬁrst element in the .
The sizeof operator when on returns the size of the in bytes .

Divided by the size of an element this gives the number of elements in the .
We can use this to ﬁnd the address of the block after the .

It is initialized with the address of the ﬁrst element we .

Here the dereference operator returns the value at the address in .

Section : Write your own iterator common pattern in other languages is having function that produces " of objects , and being able to use to loop over .

We can model this in as .

We store the generated element early so we can more easily detect if we are already at the end .

As the of an end generator iterator is never used , we can create range of generator iterators by only copying the : once .
default constructed generator iterator compares equal to itself , and to all other .

Chapter : Returning several values from There are many situations where is useful to return several values from  for example , if you want to input an item and return the price and number in stock , this functionality could be useful .
There are many ways to do this in , and most involve the STL .
However , if you wish to avoid the STL for some reason , there are still several ways to do this , including and arrays .

Section : Using : The type : can bundle any number of values , potentially including values of diﬀerent types , into single .

Retrieving values from the returned can be cumbersome , requiring the use of the : template  auto auto auto auto auto .

If you want to return of lvalue references instead of of values , use in place of .

Section : Structured Bindings introduces structured bindings , which makes it even easier to deal with multiple return types , as you do not need to rely upon or do any manual .

This also helps to reduce the number of extraneous variables created in the scope of the returned values .

Complete Tips Secrets Professionals Section : Using Output Parameters Parameters can be used returning one or more values ; those parameters are required to be pointers or references .

We can provide consumer that will be called with the multiple relevant values :

You can adapt returning into continuation passing style via :

This number has to be known at .

It also provides useful member functions like at which safe member access function with bound checking , and size which allows you to return the size of the without calculation .

Section : Using Output Iterator Several values of the same can be returned by passing an output iterator to the function .
This particularly common generic functions the algorithms of the standard .

Example :  typename void from , to , OutputIterator .

The standard string class provides simple , safe and versatile alternative to using explicit arrays of chars when dealing with text and other sequences of characters .
The string class part of the std namespace and was standardized in .

Section : Tokenize Listed from least expensive to most expensive at :

The : uses the stream ' extraction operator iteratively .
If the input delimited this able to expand on the option by eliminating its diﬃculties , allowing inline tokenization thereby supporting the generation of const , and by adding support for multiple delimiting .

Live Example .
The uses to iteratively tokenize .
It provides for more ﬂexible delimiter deﬁnition .
For example , commas and :

See the Example for more details .

Section : Conversion to In order to get const access to the data of you can use the string ' member function .

Keep in mind that the pointer only valid as long as the object within scope and remains unchanged , that means that only const methods may be called on the object .

The member function can be used to obtain modiﬁable , which can be used to manipulate the object ' data .

modiﬁable can also be obtained by taking the address of the ﬁrst character :
Within , this guaranteed to yield , string .
Note that even if empty , whereas undeﬁned if empty .

const const .

introduces , which simply range of const chars , implementable as either .

Note that cannot modify its underlying .

It oﬀers useful subset of the functionality that : does , although some of the functions behave .

In , sequences of characters are represented by specializing the class with native Complete Tips Secrets for Professionals character type .
The two major collections deﬁned by the standard library are : and : is built with elements of type is built with elements of type .

Please note that do not imply encoding , gives no indication of in bytes .
For instance , is commonly implemented as type typically contains encoded under Windows in versions prior to Windows as type encoded using under Linux .
This is in contrast with the newer types , which were introduced in are guaranteed to be large enough to hold any or " more precisely , code respectively .

Section : Lexicographical comparison Two can be compared lexicographically using the , Complete Tips Secrets for Professionals .

All these functions use the underlying method to perform the comparison , return for convenience boolean values .
The operation of these functions may be interpreted as follows , regardless of the actual implementation : If each character pair matches , then returns true , otherwise returns false .

If or one character pair match , returns true , otherwise it returns false .

Note : The term character pair means the corresponding characters in both strings of the same positions .
For better understanding , if two example strings are , their lengths are respectively , then character pairs of both strings means each pairs where ,
If for any where the corresponding character does not exist , that is , when is greater than or equal to or , it would be considered as the lowest value .

Here is an example of using .

The steps are as follows :
Compare the ﬁrst characters , move on .

Compare the second characters , move on .

Compare the third characters , move on .

The range is now exhausted , while the range still has characters .

Complete Tips Secrets for Professionals Section : Trimming characters at This example requires the headers ,

To trim sequence or means to remove all leading trailing elements matching certain predicate .
We ﬁrst trim the trailing elements , because it involve moving any elements , then trim the leading elements .
Note that the generalizations below work for all types of .

Section : String replacement Replace by position To replace portion of : you can use the method replace from .

Replace occurrences of with another Replace only the ﬁrst occurrence of replace with with in   const replace , const .

Section : Splitting Use to split string .

Section : Checking if is preﬁx of another .

We can still use the version of , but we need to ﬁrst check that the ﬁrst is at .

Section : Conversion to point types : containing number can be into an integer type , or ﬂoating point type , using conversion functions .

Note that all of these functions stop parsing the input as soon as they encounter character , so " will be into .

However , use of these functions is discouraged because they return if they fail to parse the .
This is bad because could also be valid result , if for example the input was , so it is impossible to determine if the conversion actually failed .

The newer family of functions convert to integer or types , and throw exceptions if they could not parse their input .
You should use these functions if possible : Complete Tips Secrets for Professionals .

Furthermore , these functions also handle octal and hex strings unlike the family .
The second parameter is pointer to the ﬁrst unconverted character in the input illustrated , and the third parameter is the base to use .

Section : Converting between character encodings Converting between encodings is easy with most compilers are able to deal with it in manner through headers .

Complete Tips Secrets for Professionals .

Find Find Find Find occurrence of characters absence of characters last occurrence of characters last absence of characters These functions can allow you to search for characters from end of  as well as ﬁnd negative case .

Note : Be aware that above functions do not search for substrings , but rather for characters contained in search .
In this case , last occurrence of ' was found at other characters .

Section : What are namespaces .

namespace is collection of entities , classes , whose names are preﬁxed by name of namespace .
When writing code within namespace , named entities belonging to that namespace need not be preﬁxed with namespace name , but entities outside of must use fully qualiﬁed name .
The fully qualiﬁed name has format .
Example : namespace Example .

Namespaces are useful for grouping related deﬁnitions together .
Take analogy of shopping mall .
Generally shopping mall is split up into several stores , each store selling items from speciﬁc category .
One store might sell electronics , while another store might sell shoes .
These logical separations in store types help shoppers ﬁnd items looking for .
Namespaces help programmers , shoppers , ﬁnd functions , classes , variables looking for by organizing them in logical manner .
Example : Complete Tips Secrets for Professionals .

Section : Argument Dependent Lookup When calling function without an explicit namespace qualiﬁer , compiler can choose to call function within namespace if one of parameter types to that function is also in that namespace .
This is called Dependent , or ADL : namespace Test .

When does ADL not occur ADL does not occur if normal unqualiﬁed lookup ﬁnds class member , function that has been declared at block .

Section : Extending namespaces .

Section : directive The keyword ' has three ﬂavors .
Combined with keyword ' you write : If you want to write : in front of every stuﬀ in namespace Foo , you can use using namespace Foo ; to import every single thing out of Foo .

word of caution : using namespaces in header ﬁles is seen as bad style in most cases .
If this is done , namespace is imported in every ﬁle that includes header .
Since there is no way of " namespace , this can lead to namespace pollution or unexpected symbols in global or , worse , conﬂicts .
See this example for an illustration of problem : namespace Foo class .

Section : Making namespaces Creating namespace is really easy : namespace foo namespace Foo .

Section : Namespace alias namespace can be given an alias , another name for the same using the namespace syntax .
Members of the aliased namespace can be accessed by qualifying them with the name of the alias .
In the following example , the nested namespace is inconvenient to type , so the function qux locally declares an alias .
Members of that namespace can then be accessed simply using .

inline namespace includes the content of the inlined namespace in the enclosing namespace , so namespace Outer .

Section : Aliasing long namespace This is usually used for renaming or shortening long namespace references such referring to components of library .

Chapter : File ﬁle is done via streams .
The key abstractions are : for reading text .

Formatted input uses .

Formatted output uses .

Streams use , for details of the formatting and for translation between external encodings and the internal encoding .

More on streams : Library Section : Writing to ﬁle There are several ways to write to ﬁle .
The easiest way is to use an output ﬁle stream together with the .

You should always check if ﬁle has been opened successfully when .
Failures can  the ﬁle exist , ﬁle the right access rights , ﬁle is already in use , disk errors occurred , drive disconnected .

Checking can be done as follows : Try to read the file .

If you want to open ﬁle with characters in path on Windows currently you can use wide character path argument : Open the file ' on Windows .

If you know how the is formatted , you can use the stream extraction operator .
assume you have ﬁle named which contains the following  John Doe Jane Doe .

The stream extraction operator extracts every character and stops if it ﬁnds character that be stored or if it is special character : For string types , the operator stops at whitespace or at newline .

For numbers , the operator stops at character .

This means that the following version of the ﬁle will also be successfully read by the previous code : John Doe Jane Doe The stream extraction operator always returns the stream given to it .
Therefore , multiple operators can be chained together in order to read consecutively .
However , stream can also be used as Boolean expression shown in the while loop in the previous .
This is because the stream classes have conversion operator for the type bool .
This operator will return true as long as the stream has no errors .
If stream goes into an error state example , because no more can be , then the operator will return false .

Therefore , the while loop in the previous code will be exited after the input ﬁle has been read to its end .

If you wish to read an entire ﬁle as string , you may use the following code : Opens .

Section : Opening modes When creating ﬁle stream , you can specify an opening mode .
An opening mode is basically setting to control how the stream opens the ﬁle .

An opening mode can be provided as second parameter to the constructor of ﬁle stream or to its member .

It is to be noted that you have to set or if you want to set other ﬂags as they are not implicitly set by the iostream members although they have correct default value .

If you specify an opening mode , then the following default modes are used : ifstream in ofstream out fstream in and out Complete Tips Secrets for Professionals The ﬁle opening modes that you may specify by design are : Mode Meaning For Description append Output Appends at the end of the ﬁle .

For example on Windows the end of line sequence is CRLF .

Section : Reading an ASCII ﬁle into .

The method returns pointer to streambuf that can be pushed into via the .

Another possibility in Eﬀective STL by Scott is :

NOTE : the extra parentheses around the ﬁrst argument to the string constructor are essential to prevent the most vexing parse problem .

Last but not least :

Section : Writing ﬁles with locale settings If you need to write ﬁle using diﬀerent locale settings to the default , you can use and to do that for speciﬁc ﬁle stream : Guidance for use : You should always apply local to stream before opening the ﬁle .

Once the stream has been imbued you should not change the locale .

Reasons for Restrictions : Imbuing ﬁle stream with locale has undeﬁned behavior if the current locale is not state independent or not pointing at the beginning of the ﬁle .

streams are not state independent .
Also ﬁle stream with locale may try and read the BOM marker from the ﬁle when it is opened ; so just opening the ﬁle may read characters from the ﬁle and it will not be at the beginning .

Explicitly switching to the classic " locale is useful if your program uses diﬀerent default locale and you want to ensure ﬁxed standard for reading and writing ﬁles .
With " preferred locale , the example writes Complete Tips Secrets for Professionals .

Section : Checking end of ﬁle inside loop condition , bad practice .

It does NOT indicate that the next read will be the end of .

Further references : discards leading whitespace from an input stream : returns true if an error has occurred on the associated stream Section : Flushing stream File streams are buﬀered by default , as are many other types of streams .
This means that writes to the stream may not cause the underlying ﬁle to change immediately .
In oder to force all buﬀered writes to take place immediately , you can ﬂush the stream .
You can do this either directly by invoking the method or through the stream manipulator :

Contrary , if is done infrequently , applications should consider ﬂushing frequently in order to avoid getting stuck in the stream object .

Section : Reading ﬁle into container In the example below we use and to read items from the ﬁle .

In the above example we are simply iterating through the ﬁle reading one " at time using .
This same aﬀect can be achieved using the : which is an input iterator that reads one " at time from the stream .
Also most containers can be constructed using two iterators so we can simplify the above code to :

We can extend this to read any object types we like by simply specifying the object we want to read as the template like this : Unfortunately there is no built in type that reads line using So here we build simple helper class to do it .
That will convert back to string when used in string context .

The ﬁlesystem library was originally developed as and ﬁnally merged to ISO as of .

Section : Closing ﬁle Explicitly closing ﬁle is rarely necessary in , as ﬁle stream will automatically close its associated ﬁle in its destructor .
However , you should try to limit the lifetime of ﬁle stream object , so that it does not keep the ﬁle handle open longer than necessary .
For example , this can be done by putting all ﬁle operations into an own scope .

Calling explicitly is only necessary if you want to reuse the same fstream object later , but want to keep the ﬁle open in .

Section : Class basics class is type .
class is introduced with the class , struct or union keyword .
In colloquial usage , the term " usually refers only to classes .

class is collection of class members , which can be : member variables called , member functions called , member types or typedefs .

For example , the following code snippets are identical : struct Vector .

Section : Access speciﬁers There are three keywords that act as access speciﬁers .
These limit the access to class members following the speciﬁer , until another speciﬁer changes the access level again : Keyword Description Everyone has access protected Only the class itself , derived classes and friends have access private Only the class itself and friends have access public When the is deﬁned using the class keyword , the default access speciﬁer is private , but if the is deﬁned .

Note that the friend keyword can be used to add access exceptions to functions or types for accessing protected and private members .

The public , protected , and private keywords can also be used to grant or limit access to base class subobjects .

See the Inheritance example .

Section : Inheritance can have inheritance relations .

If inherits from , this means that has as parent .
We say that is derived from , and is the base .

There are forms of inheritance for : public private protected Note that the default inheritance is the same as the default visibility of members : public if you use the struct keyword , and private for the class keyword .

even possible to have class derive from struct vice .
In this case , the default inheritance is controlled by the child , so struct that derives from class will default to public inheritance , and class that derives from struct will have private inheritance by default .

Complete Tips Secrets for Professionals .

Note that although protected inheritance is allowed , the actual use of it is rare .
One instance of how protected inheritance is used in application is in partial base class specialization referred to as .

When OOP was relatively  inheritance was frequently said to model an " relationship .
That is , inheritance is correct only if an instance of the derived class is also an instance of the base class .

This was later reﬁned into the Liskov Substitution Principle : inheritance should only be used an instance of the derived class can be substituted for an instance of the base class under any possible circumstance Complete Tips Secrets for Professionals .

For example , Stack class could inherit privately from Vector class .

Private inheritance bears much greater similarity to aggregation than to inheritance .

Protected inheritance is almost never used , and no general agreement on what sort of relationship it embodies .

Section : Friendship The friend keyword is used to give other classes and functions access to private and protected members of the class , even through they are deﬁned outside the scope .

If we we get any error since is now initializing indirect virtual base .

Also note that when creating variable object , most derived class is , so is responsible for constructor and thus value of : is , not it would be if we were creating object of type .

It is useful when solving the diamond : virtual inheritance normal inheritance and both inherit from , and inherits from and , so there are instances of in .
This results in ambiguity when accessing of through , as the compiler has no way of knowing from which class do you want to access that one which inherits , or the one that is inherited .

Virtual inheritance solves this problem : Since virtual base resides only in most derived object , there will be only one instance of in .

Section : Private inheritance : restricting base class interface Private inheritance is useful when it is required to restrict the interface of the .

To access variables and functions of an object of class , the .

But in fact , it tries to access the of and then dereference it .
In the example above , this would result in compiler error because of two facts : First , is pointer and does not have .
Second , is an integer and , thus , be dereferenced .

The uncommonly used solution to this problem would be to explicitly control the precedence :

It is for ﬁrst dereferencing the pointer and then accessing it .

The : is the scope  used in the same manner as accessing of namespace .
This is because static class is considered to be in that class ' scope , but considered of instances of that class .

Section : Member Types and Aliases class or struct can also deﬁne type aliases , which are type aliases contained within , and treated as .

As with normal type aliases , each type alias is allowed to refer to any type deﬁned or aliased before , but not after , its deﬁnition .
Likewise , typedef outside the class deﬁnition can refer to any accessible typedefs within the class deﬁnition , provided it comes after the class deﬁnition .

In this manner , we minimise the amount of code that needs to be modiﬁed when the underlying implementation is changed , such that the type name only needs to be changed in one location .

This can also be combined with decltype , if one so desires .

In this situation , changing the implementation of will automatically change the typedef for us , due to decltype .
This minimises the number of modiﬁcations necessary when we want to change helper , which minimises the risk of human error .

If the typename is only used once or twice internally and zero times externally , for example , no need to provide an alias for it .
If used hundreds or thousands of times throughout project , or if it has long enough name , then it can be useful to provide it as typedef instead of always using it in absolute terms .
One must balance forwards compatibility and convenience with the amount of unnecessary noise created .

This can also be used with template classes , to provide access to the template parameters from outside the class .

This is commonly used with containers , which will usually provide their element type , and other helper types , as member type aliases .
Most of the containers in the standard library , for example , provide the following helper types , along with any other special types they might need .

They commonly use the name type for their type alias .

Section : Nested class or struct can also contain another deﬁnition inside itself , which is called ; in this situation , the containing class is referred to as the .
The nested class deﬁnition is considered to be member of the enclosing class , but is otherwise separate .

Prior to , nested classes only had access to type names , static members , and enumerators from the enclosing class ; all other members deﬁned in the enclosing class were .

As of , nested classes , and members thereof , are treated as if they were friends of the enclosing class , and can access all of its members , according to the usual access rules ; if members of the nested class require the ability to evaluate one or more members of the enclosing class , they must therefore be passed an instance : class Outer .

Friends of nested class are not automatically considered friends of the enclosing class ; if they need to be friends of the enclosing class as well , this must be declared separately .
Conversely , as the enclosing class is not automatically considered friend of the nested class , neither will friends of the enclosing class be considered friends of the nested class .

lamdba can be seen as special unnamed struct .

class is also allowed to have static members , which can be either variables or functions .
These are considered to Complete Tips Secrets for Professionals be in the class ' scope , but treated as normal members ; they have static storage duration exist from the start of the program to the , tied to particular instance of the class , and only one copy exists for the .

When deﬁning the member variables , the keyword static is omitted .

; Static member functions can be deﬁned inside or outside the class deﬁnition , as with normal member functions .

As of , static member variables of LiteralType types that can be constructed at compile time , according to constexpr can also be declared as constexpr ; if so , they must be initialised within the class deﬁnition .

Only single copy of each static member variable exists the variable is declared or , in which case one copy per .

Static member variables have the same linkage as the class , whether the class has external or internal linkage .
Local classes and unnamed classes allowed to have static .

Section : Multiple Inheritance .

Note : this can lead to ambiguity if the same names are used in multiple inherited classs or structs .

Ambiguity in Multiple Inheritance Multiple inheritance may be helpful in certain cases but , sometimes odd sort of problem encounters while using multiple inheritance .

For example : Two base classes have functions with same name which is not overridden in derived class and if you write code to access that function using object of derived class , compiler shows error because , it cannot determine which function to call .
Here is code for this type of ambiguity in multiple inheritance .

They can be , aﬀecting how they see the instance called upon ; the function will see the instance as having the speciﬁed , if any .
Which version is called will be based on the .
If there is no version with the same as the instance , then version will be called if available .

: is class template that manages the lifetime of dynamically stored object .
Unlike for , the dynamic object is owned by only one instance of : at any time , Creates dynamic int with value of owned by unique pointer ; Only the variable holds pointer to dynamically allocated int .
When unique pointer that owns an object goes out of scope , the owned object is deleted ,

To use : and : with , use their array specializations : Creates to an int with value .

easy to add it manually to code : 

Unlike the dumb smart pointer , can also be instantiated with vector allocation .
Earlier examples were for scalar allocations .
For example to have dynamically allocated integer Complete Tips Secrets for Professionals .

This template specialized version calls constructors and destructors appropriately .
Using vectored version of or vector itself is personal choice .

In versions prior to , was available .
Unlike it is allowed to copy , upon which the source will lose the ownership of the contained pointer and the target receives it .

The class template : deﬁnes shared pointer that is able to share ownership of an object with other shared pointers .
This contrasts to : which represents exclusive ownership .

The sharing behavior is implemented through technique known as reference counting , where the number of shared pointers that point to the object is stored alongside it .
When this count reaches zero , either through the destruction or reassignment of the last :  the object is automatically destroyed .

The smart pointer works just like raw pointer .
This means , you can use to dereference them .
The regular arrow_operator operator works as well : Finally , when the last aliased goes out of scope , the destructor of our is called .

Warning : Constructing might throw exception when extra data for shared ownership semantics needs to be allocated .
If the constructor is passed regular pointer it assumes to own the object pointed to and calls the deleter if an exception is thrown .
This means will not leak object if allocation of fails .
However , it is advisable to use or , which enable the implementation to optimize the memory allocation .

Allocating using .

It is possible to create arrays for using new .

For example , to allocate an array of integers , we can write the code as , Specifying : is mandatory here to make sure that the allocated memory is correctly cleaned up using .

If we know the size at compile time , we can do it this way : struct .

With , gained special support for types .
It is no longer necessary to specify the .

Both own the object of type  but points to its member .
This means that if goes out of scope or is reassigned , the underlying object will still be alive , ensuring that does not dangle .

Important : only knows about itself all other that were created with the alias constructor .
It does not know about any other pointers , including all other created with reference to the same .

This means that weak pointers do not alter the reference therefore do not prevent an deletion if all of the shared pointers are reassigned or destroyed .

In the following example instances of : are used so that the destruction of tree object is not .

As child nodes are added to the root children , their : member parent is set to the root node .

The member parent is declared as weak pointer as opposed to shared pointer such that the root reference is not incremented .
When the root node is reset at the end of , the root is destroyed .
Since the only remaining : references to the child nodes were contained in the collection children , all child nodes are subsequently destroyed as well .

Due to control block implementation details , allocated memory may not be released until reference counter reference counter both reach zero .

Instead , you need to deﬁne your own deleter .
The examples here use the structure which should be .

The deleter must be callable with pointer argument , therefore can be .

This not only provides you with safe , zero overhead you use automatic memory management , you also get exception safety .

Note that the deleter is part of the type for  the implementation can use the empty base optimization to avoid any change in size for empty custom deleters .
So while , solve the same problem in similar way , the former type is still only the size of pointer while the latter type has to hold two pointers : both the the function pointer .
When having free function custom deleters , it is preferable to wrap the function in an empty type .

In cases where reference counting is important , one could use instead of an .
The always stores deleter , this erases the type of the deleter , which might be useful in APIs .
The disadvantages of using over higher memory cost for storing the deleter performance cost for maintaining the reference .

Here , the purpose of auto is to handle all free functions , whether they return void .

NOTE : has been deprecated in will be removed in .
You should only use this if you are forced to use or earlier are willing to be careful .
It is recommended to move to in Complete Tips Secrets for Professionals combination with to replace : behavior .

Before we had , before we had move semantics , we had .

As with all smart pointers , automatically cleans resources .

The transfer of ownership happened in the " constructor .
An example implementation might be : template class .

Section : Casting : pointers It is not possible to directly use , and on : to retrieve pointer sharing ownership with the pointer being passed as argument .
Instead , the functions , and .

Note that is not available in and , as it was only proposed by and adopted into Library Fundamentals TS in February .
However , it can be implemented as follows : template To , typename Section : Writing smart pointer : is smart pointer that behaves like value .
When copied , it copies its contents .
When created , it creates its contents .

This smart pointer can be useful for pImpl cases , where we want but we also want to expose the contents of the pImpl outside of the implementation ﬁle .

With  it can even handle virtual base classes that know how to produce instances of their derived and turn them into .

Section : Getting referring to enables you to get valid instance to .

By deriving your class from the class template  you inherit method that returns instance to .

If you use on an object not owned by  such as local automatic object or global object , then the behavior is undeﬁned .

Using from constructor is equivalent to using it on an object not owned by  because the objects is possessed by the after the constructor returns .

Chapter : Function Overloading See also separate topic on Overload Resolution Section : What is Function Overloading .

Function overloading is having multiple functions declared in the same scope with the exact same name exist in the same place as diﬀering only in their signature , meaning the arguments they accept .

Suppose you are writing series of functions for generalized printing capabilities , beginning with .

Section : Return Type in Function Overloading .

Complete Tips Secrets for Professionals Section : Member Function Overloading Functions within class can be overloaded for when they are accessed through reference to that class ; is most commonly used to overload for const , but can be used to overload for volatile const volatile , too .
This is because all member functions take as hidden parameter , which the cv qualiﬁers are applied to .
This is most commonly used to overload for const , but can also be used for volatile const volatile .

This is necessary because member function can only be called if it is at least as as the instance called on .
While instance can call both const members , const instance can only call const members .
This allows function to have diﬀerent behaviour depending on the calling , allows the programmer to disallow functions for an undesired by not providing version with that .

This allows code to specify whether it modiﬁes state by taking unmodiﬁed parameters as modiﬁed parameters without , making code both safer more readable .

If there is some member that you really need to modify , such as locking , you can declare it as mutable : class .

Chapter : vector is dynamic array with automatically handled storage .
The elements in vector can be accessed just as eﬃciently as those in an array with the advantage being that vectors can dynamically change in size .

In terms of storage the vector data is placed in dynamically allocated memory thus requiring some minor overhead ; conversely use automatic storage relative to the declared location thus do not have any overhead .

Section : Accessing Elements There are two primary ways of accessing elements in access Complete Tips Secrets for Professionals iterators access : This can be done either with the subscript operator , or the member function .

Both return reference to the element at the respective position in the : so that it can be read as well as modiﬁed the is not .

Accessing elements where or size is undeﬁned behavior for , while throws exception .

Note : The examples below use initialization for clarity , but the operators can be used with all versions marked .

Because the method performs bounds checking can throw exceptions , it is slower than .
This makes preferred code where the semantics of the operation guarantee that the is in bounds .
In any case , accesses to elements of vectors are done in constant time .
That means accessing to the ﬁrst element of the has the same cost of accessing the second element , the third element so on .

For example , consider this loop .

Here we know that the variable is always in bounds , so it would be waste of CPU cycles to check that is in bounds for every call to .

The member functions allow easy reference access to the ﬁrst last element of the  respectively .
These positions are frequently used , the special accessors can be more readable than their alternatives using .

The example above creates with sequence of numbers from to .
Then it pops the elements of the out until the is empty to prevent undeﬁned behavior .
Then the of the numbers in the is calculated displayed to the user .

The method returns pointer to the raw memory used by the : to internally store its elements .

If does , have to in .
It also assumes that the empty .

Iterators : Iterators are explained in more detail in the example over " and the article Iterators .
In short , they act similarly to pointers to the elements of the 

It can be used to check whether an iterator reached the end of the  Complete Tips Secrets for Professionals .

It is consistent with the standard that iterators actually be , but most standard libraries do not do this .
Not doing this both improves error messages , catches code , and can be used to instrument the iterators with debugging checks in builds .
Then , in release builds , the class wrapping around the underlying pointer is optimized away .

You can persist reference or pointer to an element of for indirect access .
These references or pointers to elements in the remain stable and access remains deﬁned unless you elements or before the element in the  or you cause the capacity to change .
This is the same as the rule for invalidating iterators .

See Vector Size and Capacity .

The erase method , which removes range of elements , is often used as part of the idiom .
That is , ﬁrst moves some elements to the end of the  and then erase chops them oﬀ .
This is relatively ineﬃcient operation for any indices less than the last of the because all elements after the erased segments must be relocated to new .
For speed critical applications that require eﬃcient removal of arbitrary elements in container , see .

Deleting elements by .

Note some points for the preceding loop : iterator pointing to the same element .

Put altogether , the line says : take the reverse iterator  have erase the element pointed by its regular iterator ; take the resulting iterator , construct reverse iterator from  and assign to the reverse iterator .

Deleting all elements using does not free up memory of the remains .
To reclaim space , use :

You can iterate over : in several ways .
For each of the following sections , is deﬁned as follows :

.

Enforcing const elements Since the and methods allow you to obtain constant iterator for  even if the is .
constant iterator allows you to read but not modify the contents of the which is useful to enforce const correctness :

Note on Eﬃciency Since the class : is basically class that manages dynamically allocated contiguous array , the same principle explained here applies to vectors .
Accessing the content by index is much more eﬃcient when following the order principle .
Of course , each access to the also puts its management content into the cache as well , but as has been debated many times here and , the diﬀerence in performance for iterating over : compared to raw array is negligible .
So the same principle of eﬃciency for raw arrays in also applies for .

Section : The Exception To So Many , So Many Rules The standard speciﬁes that specialization of is provided , which optimizes space by packing the bool values , so that each takes up only one bit .
Since bits addressable in , this means that several requirements on are not placed on : The data stored is not required to be contiguous , so be passed to API which expects bool array .

Rather they return proxy object that simulates reference to bool by overloading its assignment operators .
As an example , the following code may not be valid for , because dereferencing an iterator does not return reference :

The implementation of is dependent on both the compiler and architecture .
The specialisation is implemented by packing Booleans into the lowest addressable section of memory .
Here , is the size in bits of the lowest addressable memory .
In most modern systems this is byte or bits .
This means that one byte can store Boolean values .
This is an improvement over the traditional implementation where Boolean is stored in byte of memory .

Note : The below example shows possible bitwise values of individual bytes in traditional vs .
This will not always hold true in all architectures .
It is , however , good way of visualising the optimization .
In the below examples byte is represented as ,

Traditional storing Boolean .

This is signiﬁcant improvement on memory usage .
If you need to pass to an API , you may need to copy the values to an array , or ﬁnd better way to use the API , if memory and performance are at risk .

Section : Inserting Elements .

Appending an element at the end of by constructing the element in .

Note that : does not have member function due to performance reasons .
Adding an element at the beginning causes all existing elements in the to be moved .
If you want to frequently insert elements at the beginning of your container , then you might want to use or instead .

Inserting an element at any position of .

Section : Using : as array There are several ways to use : as array example , for compatibility with .
This is possible because the elements in are stored contiguously .

In contrast to solutions based on previous standards , the member function may also be applied to empty vectors , because it cause undeﬁned behavior in this case .

Before , you would take the address of the ﬁrst element to get an equivalent pointer , if the empty , these both methods are .

Note : If the is empty , and are undeﬁned and cannot be used .

When storing the base address of the data , note that many operations as , resize , can .

Section : Finding an Element in : The function , deﬁned in the header , can be used to ﬁnd an element in .

It returns an iterator to the ﬁrst element in the range that compares equal to the .

If the element in question is not found , returns if the is .

If you need to perform many searches in large  then you may want to consider sorting the ﬁrst , before using the algorithm .

To ﬁnd the ﬁrst element in that satisﬁes condition , can be used .
In addition to the two parameters given to , accepts third argument which is function object or function pointer to predicate function .
The predicate should accept an element from the container as an argument and return value convertible to bool , without modifying the container :

Complete Tips Secrets for Professionals .

This is more general solution , for example , because can also be an array .
However , also this solution allow you to append to itself .

If the order of the elements in the receiving matter , considering the number of elements in each can avoid unnecessary copy .

Section : Matrices Using Vectors Vectors can be used as by deﬁning them as of vectors .

with rows and columns with each cell initialised as can be deﬁned as :

of vectors is convenient way to represent but not the most eﬃcient : individual vectors are scattered around memory and the data structure cache friendly .

Also , in proper  the length of every row must be the same the case for of .
The additional ﬂexibility can be source of errors .

Complete Tips Secrets for Professionals Section : Using Sorted Vector for Fast Element Lookup The header provides number of useful functions for working with sorted vectors .

An important prerequisite for working with sorted vectors is that the stored values are comparable with .

An unsorted can be sorted by using the function :  add some code here to fill with some elements , Sorted vectors allow eﬃcient lookup using the function .
Unlike , this performs an eﬃcient binary search on the .
The downside is that only gives valid results for sorted input ranges : search the for the first with value .

In this case , the increased cost of the sorting can pay oﬀ against the reduced cost of inserting new at the end of the and not in the middle .

If your contains multiple of the same value , will try to return an iterator to the ﬁrst of the searched value .
However , if you need to insert new after the last of the searched value , you should use the function as this will cause less shifting around of  If you need both the upper bound and the lower bound iterators , you can use the function to .

To reduce its  we can copy the contents of to new .
The new will have the minimum that is needed to store all of the original .
If the reduction of the original was signiﬁcant , then the reduction for the new is likely to be signiﬁcant .
We can then swap the original with the one to retain its minimized 

Note : The member function is request and guarantee to reduce .

Section : Vector and Vector is simply the number of in the 
Current is queried by member function .
Convenience function returns true if is .

Adding to increases by .

Removing from decreases by .

Vector has an upper limit on its  but you are likely to run out of RAM before reaching .

While simply how many the currently has , for how many memory for .
That useful , because too frequent of too large sizes can be expensive .

Current queried by member function .
Capacity always greater or equal to .

Vector partly manages automatically , when you add may decide to grow .
Implementers like to use or for the grow factor ratio would be the ideal value but impractical due to being rational .
On the other hand usually do not automatically shrink .
For example :  possibly not to be ; some starter value , likely .

Iterators and pointers pointing into an : can become invalid , but only when performing certain operations .
Using invalid will result in undeﬁned behavior .

Complete Tips Secrets for Professionals Operations which invalidate include : Any insertion operation which changes the of the will invalidate all .

Section : Find max and min Element and Respective Index in Vector To ﬁnd the largest or smallest stored in  you can use the methods and , respectively .
These methods are deﬁned in header .

Output : The minimum and maximum in can be retrieved at the same time by using the method .

Section : Functions Returning Large Vectors In , compilers are required to implicitly move from local variable that being returned .
Moreover , most compilers can perform copy elision in many cases and elide the move altogether .
As result of this , returning large objects that can be moved cheaply no longer requires special handling : Complete Tips Secrets for Professionals .

Before , copy elision was already allowed and implemented by most compilers .
However , due to the absence of move semantics , in legacy code or code that has to be compiled with older compiler versions which implement this optimization , you can ﬁnd vectors being passed as output arguments to prevent the unneeded .

In , possible to deﬁne operators such as + and arrow_operator for types .
For example , the header deﬁnes + to concatenate strings .
This done by deﬁning an function using the Complete Tips Secrets for Professionals .

Section : Arithmetic operators You can overload all basic arithmetic operators : + Overloading for all operators the same .
Scroll down for explanation Overloading outside of .

Note : + should return by  as returning reference make sense returns new nor would returning const should generally not return by .
The ﬁrst argument passed by  why .
You modify the original object foo + bar ; modify foo after all ,
You make const , because you will have to be able to modify the object + Passing by would be an option , but then you will have to make temporary copy of the passed object .
By Complete Tips Secrets for Professionals passing by  the compiler does for you .

The ﬁrst argument is reference want to modify , but not const , because then you be able to modify .
The argument should not be modiﬁed , so for performance reason is passed by by const reference is faster than by .

Section : Array subscript You can even overload the array subscript .

You should always of the implement versions , const version , because if the object is const , should not be able to modify the object returned by .

The arguments are passed by instead of by because passing by reference is faster than by  const so that the change the index accidentally .

The operators return by reference , because by design you can modify the object return ,

The conversion must be deﬁned in : const return something Note : the is const to allow const objects to be converted .

Section : Complex Numbers Revisited The code below implements very simple complex number type for which the underlying ﬁeld is automatically promoted , following the type promotion rules , under application of the four basic operators , with member of diﬀerent ﬁeld another or some scalar .

Complete Tips Secrets for Professionals .

Complete Tips Secrets for Professionals .

Complete Tips Secrets for Professionals .

We then overload lhs , rhs for the types we want on the right and left .

The library overloads , returning temporary object .
It also overloads to call lhs , rhs .

We simply have to create the proper token and do an of the proper signature , and everything hooks up and works .

For more example , suppose you want to have multiplication of elements of :

This code can be extended to work on tuples or pairs or arrays , or even variable length containers if you decide what to do if the lengths match .

You could also an type and get lhs rhs .

Writing and product operators are also obvious uses .

The use of can be extended to support other delimiters , like +
The delimeter precidence determines the precidence of the named  which may be important when translating physics equations over to with minimal use of extra .

With slight change in the library above , we can support operators and extend prior to the standard being updated , or write monadic .
It could also have stateful named  where we .

Section : Unary operators You can overload the unary operators : and and Overloading is the same for both types and .
Scroll down for explanation .

Note : The preﬁx operator returns reference to itself , so that you can continue operations on it .
The ﬁrst argument is reference , as the preﬁx operator changes the object , that ' also the reason why it const be able to modify .

The postﬁx operator returns by value temporary previous , and so cannot be reference , as would be reference to temporary , which would be garbage value at the end of the function , because the temporary variable goes out of .
It also cannot be const , because you should be able to modify directly .

The ﬁrst argument is reference to the " object , because if were const , you be able to modify  and if reference , you change the original value .

It is because of the copying needed in postﬁx operator overloads that  better to make habit to use preﬁx instead of postﬁx in for loops .
From the for loop perspective , usually functionally equivalent , but there might be slight performance advantage to using preﬁx , especially with " classes with lot of members to copy .
Example of using preﬁx in for loop : for .

Section : Comparison operators You can overload all comparison  Complete Tips Secrets for Professionals .

Scroll down for explanation .

The obviously return bool , indicating true or false for the corresponding operation .

All of the take their arguments by , because the only thing that does do is compare , so they modify the objects .
Passing by is faster than by value , to make sure that the modify  is .

Note that the inside the are deﬁned as const , the reason for is that without the functions being const , comparing const objects would not be possible , as the compiler know that the modify anything .

Section : Assignment The assignment is one of the most important because allows you to change the status of variable .

If you do not overload the assigment for your , is automatically generated by the compiler : the assignment performs , ie by invoking assignment on all members , so that one object is copied to the other , member at time .
The assignment should be overloaded when the simple memberwise assignment is not suitable for your , for example if you need to perform deep copy of an object .

Overloading the assignment is easy , but you should follow some simple steps .

Test for .
This check is important for two reasons : is needless copy , so does not make sense to perform  the next step will not work in the case of .

Complete Tips Secrets for Professionals .
Clean the old data .
The old data must be replaced with new .
Now , you can understand the second reason of the previous step : if the content of the object was destroyed , will fail to perform the copy .

Copy all members .
If you overload the assigment for your or your struct , is not automatically generated by the compiler , so you will need to take charge of copying all members from the other object .

The returns by itself by reference , because allows chaining .

Note : other is passed by , because the object being assigned should not be changed , passing by reference is faster than by value , to make sure than modify accidentally , is const .

The assignment can only to be overloaded in the , because the left value is always the itself .
Deﬁning as free function have guarantee , is disallowed because that .

When you declare in the , the left value is implicitly the itself , so there is no problem with that .

Section : Function call You can overload the function call .

Overloading the bitwise NOT is fairly simple .
Scroll down for explanation Complete Tips Secrets for Professionals .

Note : returns by  because has to return new modiﬁed , not reference to the would be reference to the temporary object , which would have garbage in as soon as the is .
Not const either because the calling code should be able to modify afterwards .

Inside the you have to make temporary object , because you modify  as would modify the original object , which be the case .

Section : Bit shift for The are commonly used as "  The way they do is similar if you wanted to overload them " outside the , except that specifying the arguments are not the same type : Return type is the stream you want to overload from example , passed by reference , to allow chaining :
Example : would be the same as the return type is the type you want to allow overloading from .
Example : const .

Parameter Details Speciﬁes how all variables are captured .
If omitted , variables are inaccessible within the .
The defaultcapture must precede the .

Speciﬁes how local variables are made accessible within the .
Variables without preﬁx are captured by .
Variables preﬁxed with are captured by reference .
Within class method , can used to make all its members accessible by reference .
variables are inaccessible , unless the list is preceded by .

Speciﬁes the arguments the lambda function .

Specifying mutable makes them nonmutable const .
Changes to those variables are retained between calls .

For example : noexcept or .

For example , if the always throws attributes an exception then can used .

Required when the return type arrow_operator cannot determined by the compiler .

code block containing the implementation the lambda function .

lambda expression provides concise way to create simple function objects .
lambda expression is prvalue whose object is called closure object , which behaves like function object .

The name expression ' originates from lambda calculus , which is mathematical formalism invented in the by Alonzo Church to investigate questions about logic and computability .
Lambda calculus formed the basis LISP , functional programming language .
Compared to lambda calculus and LISP , lambda expressions share the properties being unnamed , and to capture variables from the surrounding context , but they lack the ability to operate on and return functions .

lambda expression is often used as an argument to functions that take callable object .
That can simpler than creating named function , which would only used when passed as the argument .
In such cases , lambda expressions are generally preferred because they allow deﬁning the function objects inline .

lambda consists typically three parts : capture list , an optional parameter list and body , all which can empty : An empty lambda , which does and returns nothing .

Capture list is the capture list .
By default , variables the enclosing scope cannot accessed by lambda .
Capturing variable makes it accessible inside the lambda , either as copy or as reference .
Captured variables become part .

If the lambda takes no arguments , these .

These two lambdas are .

The parameter list can use the placeholder type auto instead actual types .
By doing so , this argument behaves like template parameter function template .
Following lambdas are equivalent when you want to sort .

Calling lambda lambda object is closure , which can called using the with other function .

An example to illustrate the usefulness of lambdas Before : Generic functor used for comparison .

Section : Specifying the return type For lambdas with single return statement , or multiple return statements whose expressions are of the same type , the compiler can deduce the return type : Returns bool , because  is comparison which yields Boolean result .

Section : Capture by If you specify the name in the capture list , the lambda will capture by .
This means that the generated closure type for the lambda stores of the variable .
This also requires that the type be .

This is because the closure type puts the lambda body in declaration of const .

The const applies to accesses to member variables of the closure type , and captured variables that are members of .

But lambda cannot be recursive , has no way to invoke itself .
lambda has no name and using this within the body of lambda refers to captured this the lambda is created in the body of member  otherwise is an .
So how do we solve this problem .

Use : We can have lambda capture to constructed .

This works , but should be used sparingly .
slow using type erasure now instead of direct , fragile or returning will break since the lambda refers to the original , and work with generic lambdas .

Using two smart .

This adds lot of indirection is , but can be , and all copies share state .
It does let you return the lambda , and is otherwise less fragile than the above solution .

Use With the help of short utility struct , we can solve all of these problems : Complete Tips Secrets for Professionals .

The is concept from the lambda calculus that lets you have recursion without being able to name yourself until you are deﬁned .
This is exactly the problem lambdas have .

You create lambda that takes " as its ﬁrst argument .
When you want to recurse , you pass the arguments to recurse .

The then returns object that calls that with its arguments , but with suitable " object the as its ﬁrst argument .
It forwards the rest of the arguments you call the with to the lambda as well .

In short : auto recurse , some .

Section : Default capture By default , local variables that are not explicitly speciﬁed in the capture list , cannot be accessed from within the .

lambda expression evaluated in class ' member is implicitly friend of that class : class Foo private : int .

Such lambda is not only friend of that class , has the same access as the class is declared within has .

Lambdas can capture the this pointer which represents the object instance the outer was called on .
This is done by adding this to the capture list : class Foo .

So an implicit is applied to such members .

Be aware that this is captured by  but not the of the type .
It is captured by the of this , which is pointer .

If the lambda out lives the lifetime of the object that created  the lambda can become invalid .

This also means that the lambda can modify this without being declared mutable .
It is the pointer which is const , not the object being pointed to .
That is , unless the outer member was itself const .

Also , be aware that the default capture clauses , and , will also capture this implicitly .
And they capture it by the of the pointer .
Indeed , it is an error to specify this in the capture list when default is given .

Lambdas can capture of the this object , created at the time the lambda is created .
This is done by adding to the capture list : class Foo .

Section : Capture by If you precede local name with an , then the variable will be captured by .
Conceptually , this means that the closure type will have variable , initialized as to the corresponding variable from outside of the scope .
Any use of the variable in the lambda body will refer to the original variable : Declare variable .

Of course , capturing by means that the lambda must not escape the scope of the variables it captures .

Complete Tips Secrets for Professionals So you could call functions that take  but you must not call that will store the lambda beyond the scope of your references .
And you must not return the lambda .

Section : Generic .

Here , is deduced based on the ﬁrst argument , while will always be int .

Generic can take arguments by reference as well , using the usual rules for auto and .
If generic parameter is taken as , this is forwarding reference to the passed in argument and not an rvalue reference : auto auto .

Here we are creating visitor , but no polymorphic one ; auto is used for the same reason you might use auto in loop .

Section : Using for inline parameter pack unpacking Parameter pack unpacking traditionally requires writing helper function for each time you want to do it .

In this toy .

The wants to create and unpack parameter pack of indexes .
In order to do so , it must call helper function .
Every time you want to unpack parameter pack you created , you end up having to create custom helper function to do it .

You can unpack parameter packs into of invocations of lambda , like this : using ,

To go back to the toy example at the top , rewrite it .

Live example to play with .

Section : Generalized capture .

Generalized capture uses auto type deduction for the variable ' type .
It will declare these captures as values by default , but they can be references as .

Of course , that is only useful if you do not intend to access those variables after the lambda has completed its work .

Section : Conversion to function pointer If lambda ' capture list is empty , then the lambda has an implicit conversion to function pointer that takes the .

Calling this function pointer behaves exactly like invoking on the lambda .
This function pointer is in no way reliant on the source lambda closure ' existence .
It therefore may outlive the lambda closure .

This feature is mainly useful for using lambdas with APIs that deal in function pointers , rather than function objects .

Complete Tips Secrets for Professionals .

Section : Porting lambda functions to using functors Lambda functions in are syntactic sugar that provide very concise syntax for writing functors .
As such , equivalent functionality can be obtained in much more by converting the function into .

Section : For for loops can be used to iterate over the elements of range , without using numeric or .

If the values stored in the range are expensive to copy , you may want to use const auto .
You are also not required to use auto ; you can use an appropriate typename , so long as it is implicitly convertible from the value type .

If you need access to the iterator , for cannot help you without some eﬀort , at .

Any type which has and functions which can found via argument dependent lookup , based on type .
This is useful for creating range type without having to modify type itself : namespace Mine .

Before the loop initialization statement is executed exactly once .
After each cycle , the iteration execution part is executed .

for loop is deﬁned as .

You can enter of multiple variables of one type , such as int ,
These variables are only valid in the scope of the loop .
Variables deﬁned before the loop with the same name are hidden during execution of the loop .

You can enter multiple statements in the iteration execution part , such as ,

The rough equivalent of for loop , rewritten as while loop is : body of the loop ; using ' will skip to increment part below .

But for readability reasons , it is best practice to only perform operations directly relevant to the loop .

declared in the initialization statement is visible only inside the scope of the for loop and is released upon termination of the loop .

forget that the which was declared in the initialization statement can be modiﬁed during the loop , as well as the checked in the condition .

Example of loop which counts from to :

Explanation of the code fragments : is Boolean condition that checks whether is less than or equal to .
If it is true , the loop executes .
If it is false , the loop ends .

By leaving all statements empty , you can create an inﬁnite .

The next common example of iterating over all elements from an STL collection , without using the header .

Section : While loop while loop executes statements repeatedly until the given condition evaluates to false .
This control statement is used when is not known , in advance , how many times block of code is to be executed .

For example , to print all the numbers from up to , the following code can be used : Complete Tips Secrets for Professionals .

Note that since , the ﬁrst statements can be combined .
The rest is the same To create an inﬁnite loop , the following construct can be .

There is another variant of while loops , namely the construct .
See the loop example for more information .

Section : loop loop is very similar to while loop , except that the condition is checked at the end of each cycle , not at the start .
The loop is therefore guaranteed to execute at least once .

The following code will print , as the condition will evaluate to false at the end of the ﬁrst iteration : int .

Note : Do not forget the semicolon at the end of , which is needed in the construct .

In contrast to the loop , the following will not print anything , because the condition evaluates to false at the beginning of the ﬁrst iteration : int .

trivial loop is also occasionally used to write macros that require their own scope which case the trailing semicolon is omitted from the macro deﬁnition and required to be provided by the .

Section : Loop Control statements  Break and Continue Loop control statements are used to change the ﬂow of execution from its normal sequence .
When execution leaves scope , all automatic objects that were created in that scope are destroyed .
The break and continue are loop control statements .

The break statement terminates loop without any further consideration .

More straightforward implementation are usually easier to read and understand .
For example , Complete Tips Secrets for Professionals .

However , is not permitted to do the same with loop ; instead , declare the variable before the loop , and enclose both the variable and the loop within local scope if you want the variable to go out of .

Section : over Using loops , you can loop over of given container or other range by generating proxy object that qualiﬁes for for loops .

Complete Tips Secrets for Professionals .

Chapter : Section : Accessing elements An : takes , pairs as input .

Complete Tips Secrets for Professionals .

In an , elements can be accessed directly by giving the key as an index : Note that using the on the will actually insert new with the queried key into the .
This means that you cannot use it on const , even if the key is already stored in the .
To prevent this insertion , check if the element exists example by using or use as described below .

Note that will throw an exception if the container does not contain the requested element .

In both containers : and , elements can be accessed using iterators :

If the insertion was successful , the iterator points to the newly inserted element , and the bool is true .

If there was already an element with the same key , the insertion fails .
When that happens , the iterator points to the element causing the conﬂict , and the bool is is false .

If an element is .

Complete Tips Secrets for Professionals .

Otherwise behaves in the same way as :  int runs ; auto , get iterator to the inserted the next will be before , so is inserted before ' Section : Searching in : or in : There are several ways to search key in : or in .

To get the iterator of the ﬁrst occurrence of key , the function can be used .
It returns if the key does not .

Another way to ﬁnd whether an in : or in : is using the .

For , can return values greater than since there can be several values associated with .

If you only care whether some  find is strictly better : documents your intent and , for multimaps , can stop once the ﬁrst matching has been found .

In the case of , there could be several elements having the same key .
To get this range , the function is used which returns : having iterator lower bound and upper .

Section : Initializing : or : and : both can be initialized by providing pairs separated by comma .
pairs could be provided by either , or can be explicitly created by ,
As : does not allow duplicate keys and comma operator performs right to left , the on right would be .

In the above example , is the key type , and is .

The key acts as an index in the .
Each key must be unique , and must be ordered .

If your type does not specify any ordering , or you want to override the default ordering , you may provide .

If StrLess comparator returns false for two keys , they are considered the same even if their actual contents diﬀer .

Multimap allows multiple pairs with the same key to be stored in the .
Otherwise , its interface and creation is very similar to the regular .

Section : Deleting elements Removing all elements : Complete Tips Secrets for Professionals .

Complete Tips Secrets for Professionals Section : Creating : with types as key In order to be able to use class as the key in  all that is required of the key is that be copiable and assignable .
The ordering within the is deﬁned by the third argument to the template the argument to the constructor , if .
This defaults to , which defaults to the operator , but no requirement to use the defaults .
Just write comparison operator as functional .

Strict Weak Ordering This is mathematical term to deﬁne relationship between two objects .

Its deﬁnition is : Two objects and are equivalent if both , and , are false .
Note that an object is always the irreﬂexivity equivalent to itself .

In terms of this means if you have two objects of given type , you should return the following values when compared with the operator .

Parameter other func args Details Takes ownership of other , other own the thread anymore Function to call in seperate thread Arguments for func Complete Tips Secrets for Professionals Section : Creating In , threads are created using the class .
thread is separate ﬂow of execution ; is analogous to having helper perform one task while you simultaneously perform another .
When all the code in the thread is executed , terminates .
When creating thread , you need to pass something to be executed on .
few things that you can pass to thread : Free functions Member functions Functor objects Lambda expressions Free function example executes function on separate thread .

Compared to is considered less powerful but easier to use when you just want to run function asynchronously .

When that future gets destroyed it waits until the thread completes , making your code eﬀectively single threaded .

This easily overlooked when you need the return value : square , already completed at this point , because the returning future got destroyed works without launch policy , so , compiles .
When you do that the system gets to decide if it wants to create thread or not .
The idea was that the system chooses to make thread unless it already running more threads than it can run eﬃciently .
Unfortunately implementations commonly just choose not to create thread in that situation , ever , so you need to override that behavior with which forces the system to create thread .

Beware of race conditions .

More on async on Futures and Promises Complete Tips Secrets for Professionals Section : Basic Synchronization Thread synchronization can be accomplished using mutexes , among other synchronization primitives .
There are several mutex types provided by the standard library , but the simplest .
To lock mutex , you construct lock on it .
The simplest lock type : void .

Section : Create simple thread pool threading primitives are still relatively low level .
They can be used to write higher level construct , like thread pool :

You create threads by running starts .

The use of merely because there no equivalent that stores types .
Writing custom one of those would probably be faster than using .

Section : Ensuring thread always joined When the destructor for invoked , call to either or must have been made .
If thread has not been joined or detached , then by default will be called .
Using RAII , this generally simple enough to accomplish : class .

Complete Tips Secrets for Professionals This also provides exception safety ; if we had created our thread normally and the work done in performing other calculations had thrown an exception , would never have been called on our thread and our process would have been terminated .

Section : Operations on the current thread namespace which has functions to do interesting things on the current thread from function it called from .

Function Description Returns the id of the thread Sleeps for speciﬁed amount of time Sleeps until speciﬁc time yield Reschedule running threads , giving other threads priority .

Section : Using Condition Variables condition variable is primitive used in conjunction with mutex to orchestrate communication between threads .
While it is neither the exclusive or most eﬃcient way to accomplish this , it can be among the simplest to those familiar with the pattern .

This allows the code to safely examine shared state before deciding whether or not to proceed with acquisition .

Below is sketch that uses , and few others to make things interesting .

Section : Thread operations When you start thread , it will execute until it is ﬁnished .

Often , at some point , you need to the thread may already be wait for the thread to ﬁnish , because you want to use the result for example .

Section : storage storage can be created using the keyword .
variable declared with the speciﬁer is said to have thread storage duration .

Each thread in program has its own copy of each variable .

variable with function scope will be initialized the ﬁrst time control passes through its deﬁnition .
Such variable is implicitly static , unless declared extern .

variable with namespace or class scope will be initialized as part of thread startup .

variables are destroyed upon thread termination .

member of class can only be if it is static .
There will therefore be one copy of that variable per thread , rather than one copy per , pair .

Section : Reassigning thread objects We can create empty thread objects and assign work to them later .

If we assign thread object to another active , joinable thread , will automatically be called before the thread is replaced .

Value categories for expressions can aﬀect function overload resolution .

Value categories determines two properties about an expression .
One property is whether the expression has identity .
An expression has identity if it refers to an object that has variable name .
The variable name may not be involved in the expression , but the object can still have one .

The other property is whether it is legal to implicitly move from the value .
Or more speciﬁcally , whether the expression , when used as function parameter , will bind to parameter types or not .

deﬁnes value categories which represent the useful combination of these properties : lvalue with identity but not movable , xvalue with identity that are moveable , and prvalue without identity that are moveable .
does not have expressions which have no identity and cannot be moved from .

deﬁnes two other value categories , each based solely on one of these properties : glvalue with and rvalue that can be moved .
These act as useful groupings of the prior categories .

This graph serves as an illustration : Section : rvalue An rvalue expression is any expression which can be implicitly moved from , regardless of whether it has identity .

More precisely , rvalue expressions may be used as the argument to function that takes parameter of type is the type of .
Only rvalue expressions may be given as arguments to such function parameters ; if expression is used , then overload resolution will pick any function that does not use an rvalue reference parameter .
And if none exist , then you get an error .

The category of rvalue expressions includes all xvalue and prvalue expressions , and only those expressions .

The standard library function exists to explicitly transform expression into an rvalue .
More speciﬁcally , it turns the expression into an xvalue , since even if it was an prvalue expression before , by passing it as parameter to , it gains identity parameter and becomes an xvalue .

Consider the following : Complete Tips Secrets for Professionals .

However , the category of the expression is not an rvalue it is an , so it cannot call that constructor overload .
Instead , it calls the const overload , the copy constructor .

Line changes things .
The return of is , where is the base type of the parameter passed in .

function call return is an rvalue reference is an rvalue expression an , so it may call the move constructor of .
After line , has been moved from contents are now .

Line passes temporary to the assignment operator of .
This has an overload which takes .
The expression is an rvalue expression , so it may call that overload .
Thus , the temporary is moved into  replacing the undeﬁned contents with speciﬁc contents .

Line creates named rvalue reference called that refers to .
This is where categories get confusing .

See , while is an rvalue reference to , the category of the expression is not an rvalue .
It is an lvalue expression .
Because of this , one cannot call the move constructor of with the expression .
Line therefore copies the of into .

To move it , we would have to employ again .

Section : xvalue An xvalue expression is an expression which has identity and represents an object which can be implicitly moved from .
The general idea with xvalue expressions is that the object they represent is going to be destroyed soon the " and therefore implicitly moving from them is ﬁne .

These  but are not limited to : Expressions that represent temporary objects , such as .

function call expression that does not return reference Complete Tips Secrets for Professionals literal string literal those are , such has , true , or ' lambda expression The addressof operator cannot be applied on these expressions .

Section : lvalue An lvalue expression is an expression which has identity , but cannot be implicitly moved from .
Among these are expressions that consist of variable name , function name , expressions that are dereference operator uses and expressions that refer to lvalue references .

The typical lvalue is simply name , but lvalues can come in other ﬂavors as .

Section : glvalue glvalue expression is any expression which has identity , regardless of whether it can be moved from or not .
This category includes lvalues that have identity but be moved and xvalues that have identity , and can be moved , but excludes prvalues without .

If an expression has name ,

Chapter : Preprocessor The preprocessor is simple text that is run before the actual compilation of the code .
Used to extend and ease the use of the later language , it can be used for :
Including other ﬁles using .
Deﬁne macro using c .
Conditional Compilation Complete Tips Secrets for Professionals Section : Include Guards header ﬁle may be included by other header ﬁles .
source ﬁle that includes multiple headers may therefore , indirectly , include some headers more than once .
If such header ﬁle that is included more than once contains deﬁnitions , the compiler detects violation of the One Deﬁnition Rule .

Multiple inclusion is prevented using , which are sometimes also known as header guards or macro guards .
These are implemented using the preprocessor , directives .

However , include guards also cause some problems for developers , as it is necessary to ensure the macros are unique within all headers used in project .
Speciﬁcally , if two headers use as their include guard , the ﬁrst of those headers included in compilation unit will eﬀectively prevent the others from being included .
Particular challenges are introduced if project uses number of libraries with header ﬁles that happen to use include guards in common .

It is also necessary to ensure that the macros used in include guards do not conﬂict with any other macros deﬁned in header ﬁles .

Most implementations also support the once directive which ensures the ﬁle is only included once within single compilation .
This is de facto standard directive , but it is not part of any ISO standard .
For example : once .

Projects which use once are more diﬃcult to port to compilers that support it .

number of coding guidelines and assurance standards for speciﬁcally discourage any use of the preprocessor other than to header ﬁles or for the purposes of placing include guards in headers .

Section : Conditional logic and handling In nutshell , conditional logic is about making available or unavailable for compilation using macro deﬁnitions .

Complete Tips Secrets for Professionals Three prominent are : diﬀerent app proﬁles .

Basic , Premium and Pro versions of with slightly diﬀerent features .

Example : approach for removing ﬁles : and other windows system files .

For example this command gcc processes in the same way as it would and were added to the top of .

Ensuring macro is deﬁned : If macro deﬁned and its value is compared or checked , the preprocessor almost always silently assumes the value to be .
There are few ways to work with this .
One approach is to assume that the default settings are represented as , and any changes .

Another approach is make all deﬁnitions and defaults explicit .
This can be achieved using combination of and directives : please not already included .

An consists of two parts : the list , and the execution of the list .

Example : LIST .

Source : See also : If deﬁning seamingly irrelevant before using LIST is not to your liking , you can pass macro name as an .

Macros are categorized into two main groups : macros and macros .
Macros are treated as Complete Tips Secrets for Professionals token substitution early in the compilation process .
This means that large sections of code can be abstracted into preprocessor macro .

Macro names are usually written in all caps , to make them easier to diﬀerentiate from normal code .
This requirement , but is merely considered good style by many programmers .

When an macro is encountered , expanded as simple operation , with the name being replaced with its deﬁnition .
When macro is encountered , both its name and its parameters are expanded .

Due to this , macro parameters are often enclosed within parentheses , as in above .
This is to prevent any bugs that can occur during macro expansion , speciﬁcally bugs caused by single macro parameter .

Also note that due to this simple expansion , care must be taken with the parameters passed to macros , to prevent unexpected side eﬀects .
If the parameter is modiﬁed during evaluation , it will be modiﬁed each time it is used in the expanded macro , which usually what we want .
This is true even the macro encloses the parameters in parentheses to prevent expansion from breaking anything .

As programmers normally terminate lines with semicolon , macros that are intended to be used as standalone lines are often designed to " semicolon ; this prevents any unintended bugs from being caused by an extra semicolon .

In this example , the inadvertent double semicolon breaks the block , preventing the compiler from matching the else to the .
To prevent this , the semicolon is omitted from the macro deﬁnition , which will cause it to " the semicolon immediately following any usage of it .

Normally , macro deﬁnition ends at the end of the line .
If macro needs to cover multiple lines , however , backslash can be used at the end of line to indicate this .
This backslash must be the last character in the line , which indicates to the preprocessor that the following line should be concatenated onto the current line , treating them as single line .
This can be used multiple times in row .

In the case of more complex macros , it can be useful to give them their own scope to prevent possible Complete Tips Secrets for Professionals name collisions or to cause objects to be destroyed at the end of the macro , similar to an actual function .
common idiom for this is do while , where the macro is enclosed in block .
This block is generally not .

In the case of variadic parameter , diﬀerent compilers will handle the trailing comma diﬀerently .

Some compilers , such as Visual Studio , will silently swallow the comma without any special syntax .
Other compilers , such as GCC , require you to place immediately before .
Due to this , it is wise to conditionally deﬁne variadic macros when portability is concern .

Those macros must not be or undeﬁned by user .

The following macros are predeﬁned by the standard : contains the line number of the line this macro is used on , and can be changed by the directive .

Its value is the standard version the compiler is fully conformant with ,

is deﬁned to if the implementation is hosted , or if it is freestanding .

contains literal , which is the alignment used for call to operator .

Additionally , the following macros are allowed to be predeﬁned by implementations , and may or may not be present : has meaning , and is usually deﬁned only when compiling ﬁle as , to has meaning , and its value is usually the version , similarly to how is the version .

It contains the name of the function it is used in , as static character array in an format .

On top of those standard predeﬁned macros , compilers can have their own set of predeﬁned macros .
One must refer to the compiler documentation to learn those .
: gcc Microsoft Visual clang Intel Compiler Some of the macros are just to query support of some feature : if compiled by compiler extern code has to be decorated library header declarations here .

It can only be used with the Macros having arguments .

Compiler concatenate two strings and the ﬁnal argument will be string literal with newline character at its end .

Preprocessor will ignore the spaces before or after the macro argument .
So below print statement will give us the same result .

This will be converted to string by preprocessor .

It is not part of any ISO standard .
For example : once .

Projects which use once must be modiﬁed to be .

With some compilers particularly those that employ precompiled headers once can result in considerable speedup of the compilation process .
Similarly , some preprocessors achieve speedup of compilation by tracking which headers have employed include guards .
The net beneﬁt , when both once and include guards are employed , depends on the implementation and can be either an increase or decrease of compilation times .

Hence it is very common to ﬁnd them combined in Windows Applicants .

Section : Preprocessor error messages Compile errors can be generated using the preprocessor .
This is useful for number of reasons some of which include , notifying user if they are on an unsupported platform or an unsupported compiler .

Return Error if gcc version is or earlier .

Return Error if compiling on an Apple computer .

code that results from substituting types to instantiate template or class template is not hard compile error , it is only treated as deduction failure .

Deduction failures on instantiating templates or class template specializations remove that candidate from Complete Tips Secrets for Professionals the set of consideration as if that failed candidate did not exist to begin with .

Only substitution failures in the immediate context are considered deduction failures , all others are considered hard errors .

Section : is that maps any types to void .
The primary purpose of is to .

For example , check if has member that takes no arguments :  struct  struct ,  How does this work .
When try to instantiate , that will cause the compiler to try to look for the best specialization for ,
We have two options : the primary , and this secondary one which involves having to instantiate that underlying expression : If does have member , then whatever that returns gets converted to void , and the Complete Tips Secrets for Professionals specialization is preferred to the primary based on the partial ordering rules .
So will be true If have such member it requires more than one , then substitution fails for the specialization and we only have the primary to fallback on .
Hence , is false .

simpler case :  struct  struct , 

You may notice common pattern of void argument .
We can factor this out : struct details  struct   struct ,

The previous examples may now be rewritten using as : using .

There are proposals for std traits similar to .

The utility of was discovered by Walter Brown .
He gave wonderful presentation on it at CppCon .

Section : is convenient utility to use boolean conditions to trigger SFINAE .
It is deﬁned as : Complete Tips Secrets for Professionals .

Here , call to would fail due to ambiguity .
But the second overload is not intended to be used for .

Due to SFINAE , this is not hard error , this candidate is simply removed from the overload set .
As result , only has one single viable candidate which is then called .

When to use it worth keeping in mind that : is helper on top of SFINAE , but not what makes SFINAE work in the ﬁrst place .
consider these two alternatives for implementing functionality similar to ,

Assuming that is written appropriately , these two declarations should be exactly equivalent with respect to SFINAE .
Which is the easiest to write , and which is the easiest to review and understand at glance .

Now consider how we might want to implement arithmetic helpers that avoid signed integer overﬂow in favour Complete Tips Secrets for Professionals of wrap around or modular behaviour .

These are two possible alternatives : handle signed types arrow_operator handle unsigned types by just doing amount .

strength of : is how it plays with refactoring and API design .
If is meant to reﬂect whether is valid then just using the expression as it appears for can be more concise , although that could depend on whether would be used in several places or not .
Contrast that with which reﬂects its intention much more clearly than when its implementation leaks into the declaration of .

Section : To generalize on SFINAE there are experimental traits ,

With parameters typename Default , Op and typename .
Args : alias of or depending of the validity of : alias of or nonesuch depending of validity of .

The ordering between overloads can instead be selected using inheritance ,

Instead of testing for the thing that needs to be , and also testing the negation of all the other versions conditions , we instead test just for what we need , preferably in decltype in trailing return .

This might leave several option well formed , we diﬀerentiate between those using , similar to tags et .
This works because direct match is better that base  which is better that base of base  etc .

However , can extend to any number of choices , and is bit more clear in intent .

Section : trailing decltype in function templates .

If call with an argument with which can invoke , then have two viable functions for .
The ﬁrst is preferred since the conversion from to is better implicit conversion sequence than the conversion from to .

If call with an argument from which cannot invoke , then the ﬁrst function instantiation leads to substitution failure is no .
As result , that candidate is removed from the overload set .
The second function is unconstrained , so it is selected and we instead go through ,
If that one is undeﬁned , then we have hard compile error with stack on the line val .

Section : Motivational example When you have variadic pack in the parameters list , like in the following code snippet : void .
oﬀers and which solve this problem .
For example : SFINAE constraints on all of the parameters in .

One of them is to use .

Alternatively , one may also implement by hand the behavior of and in rather way .
In the following example demonstrate the implementations and combine them with to produce two alias : and , which do exactly what they are supposed to semantically .
This may provide more scalable solution .

Implementation of and First emulate and using customized and respectively : Helper for prior to .

struct : Then the implementation is quite .

Eventually some .

using typename ; Usage The usage is also : SFINAE constraints on all of the parameters in .

That type would have to follow the Rule of Five , but all users of that resource do not need to write any of the ﬁve special member functions and can simply default all of them .

Using the Person class introduced in the Rule of Three example , we can create object for cstrings : class cstring .

The term rule of zero was introduced by .
Martinho Fernandes Complete Tips Secrets for Professionals Section : Rule of Five introduces two new member functions : the move constructor and the move assignment .

For all the same reasons that you want to follow the Rule of Three in , you usually want to follow the Rule of Five in : If class requires ONE of ﬁve member functions , and if move semantics are desired , then it most likely requires ALL FIVE of them .

Note , however , that failing to follow the Rule of Five is usually not considered an error , but missed optimisation opportunity , as long as the Rule of Three is still followed .
If no move constructor or move assignment is available when the compiler would normally use one , it will instead use copy semantics if possible , resulting in less eﬃcient operation due to unnecessary copy operations .
If move semantics desired for class , then it has no need to declare move constructor or assignment .

Same example as for the Rule of Three : class .

Extending from the Rule of Three to the Rule of Five is important for performance reasons , but is not strictly necessary in most cases .
Adding the copy constructor and assignment ensures that moving the type will not leak memory will simply fall back to copying in that , but will be performing copies that the caller probably did not anticipate .

Section : Rule of Three The Rule of Three states that if type ever needs to have copy constructor , copy assignment  or destructor , then it must have all three .

The reason for the rule is that class which needs any of the three manages some resource handles , dynamically allocated memory , and all three are needed to manage that resource consistently .
The copy functions deal with how the resource gets copied between objects , and the destructor would destroy the resource , in accord with RAII principles .

Consider type that manages string resource : class .

First , will be constructed .
Then will be copied from .
However , the copy constructor will copy each component of the type .
Which means that and both point to the same string .

When main ends , destructors will be called .
First destructor will be called ; it will delete the string .
Then destructor will be called .
However , the string is already deleted .
Calling delete on memory that was already deleted yields undeﬁned behavior .

To avoid this , it is necessary to provide suitable copy constructor .
One approach is to implement reference counted system , where diﬀerent instances share the same string data .
Each time copy is performed , the shared reference count is incremented .
The destructor then decrements the reference count , only releasing the memory if the count is zero .

Or we could implement value semantics and deep copying .

Swapping the contents of and copy gives ownership to copy of the original .
Destruction of copy , as the function returns , releases the previously owned by .

It typically happens via circuitous route through various code systems , where the location of the assignment simply has two pointers or references and has no idea that they are the same object .

Any copy assignment you write must be able to take into account .

The typical way to do so is to wrap all of the assignment logic in condition like .

Note : It is important to think about and ensure that your code behaves correctly when it happens .

However , is very rare occurrence and optimizing to prevent it may actually pessimize the normal case .
Since the normal case is much more common , pessimizing for may well reduce your code eﬃciency be careful using .

As an example , the normal technique for implementing the assignment is the copy and swap idiom .
The normal implementation of technique does not bother to test for though is expensive because copy is .
The reason is that pessimization of the normal case has been shown to be much more costly it happens more .

Move assignment operators must also be protected against .
However , the logic for many such operators is based on , which can handle swapping the same memory just ﬁne .
So if your move assignment logic is nothing more than series of swap operations , then you do not need protection .

If is not the case , you must take similar measures as above .

Chapter : RAII : Resource Acquisition Is Initialization Section : Locking .

That is the wrong way to implement the locking and unlocking of the mutex .
To ensure the correct release of the mutex with requires the programer to make sure that all the ﬂows resulting in the exiting of the function result in call to .
As shown above is brittle processes as it requires any maintainers to continue following the pattern manually .

Using an appropriately crafted class to implement RAII , the problem is trivial : Complete Tips Secrets for Professionals .

That is , when the goes out of scope , the mutex is guaranteed to be unlocked .
It doesn ' matter if the reason it went out of scope is an exception or an early return all cases are handled ; regardless of the control ﬂow , we have guaranteed that we will unlock correctly .

Thanks to int , we can implement action which executes only on success thrown exception in .
Previously bool just allows to detect if any stack unwinding is running .

Success Thanks to int , we can implement action which executes only on failure exception in .
Previously bool just allows to detect if any stack unwinding is running .

Failure Section : For cases we don ' want to write special classes to handle some resource , we may write generic class : class final .

Chapter : Exceptions Section : Catching exceptions block is used to catch exceptions .
The code in the try section is the code that may throw an exception , and the code in the catch handles the exception .

To rethrow managed , the Standard Library has the function that .

This creates an object on the heap and would require you to catch the pointer and manage the memory yourself .
This can cause memory leaks .

One reason why catching by reference is good practice is that it eliminates the need to reconstruct the object being passed to the catch block propagating through to other catch .
Catching by reference also allows the exceptions to be handled polymorphically and avoids object slicing .
However , if you are rethrowing an throw , see example , you can still get object slicing because the throw ; statement makes copy of the as whatever type is .

If you are sure that you are not going to do anything to change the add information or modify the , catching by const reference allows the compiler to make optimizations and can improve performance .

But this can still cause object splicing seen in the example .

Warning : Beware of throwing unintended exceptions in catch blocks , especially related to allocating extra memory or resources .
For example , constructing , or their subclasses might throw due to memory running out copying the string , streams might throw during logging with respective masks set , etc .

Complete Tips Secrets for Professionals Section : Custom You throw raw values as exceptions , instead use one of the standard classes or make your own .

Having your own class inherited from : is good way to go about it .
custom class which directly inherits from :

The underlying memory is in possession of the Except object .
Callers must not attempt to free the memory .

As you are not only just throwing dumb error message , also some other values representing the error exactly was , your error handling becomes much more eﬃcient and meaningful .

an class that you handle error messages nicely You can inherit from this class too :

You can override it if you have further agenda .

Section : introduces int replace the limited bool to .

Note that for constructors and destructors , the behavior is diﬀerent as the catch an exception anyway caught one if there is no other throw in the catch .

The function is allowed to have function try like any other function , but function try will not catch exceptions that occur during the construction of static variable or the destruction of any static variable .

Section : Nested exception During exception handling there is common use case when you catch generic exception from function as ﬁlesystem error or data transfer and throw more speciﬁc exception which indicates that some operation could not be performed as being unable to publish photo on .

This allows exception handling to react to speciﬁc problems with high level operations and also allows , having only error an  the programmer to ﬁnd place in the application where an exception occurred .
Downside of this solution is that exception callstack is truncated and original exception is lost .
This forces developers to manually text of original exception into newly created one .

Nested exceptions aim to solve the problem by attaching exception , which describes the cause , to high Complete Tips Secrets for Professionals .

Section : Function Try Blocks In constructor The only way to catch in initializer .

Complete Tips Secrets for Professionals .

Chapter : behavior Section : Size of integral types The following types are deﬁned as integral types : char Signed integer types Unsigned integer types and bool With the of , which is split between and , and , which is entirely implementationdeﬁned and has no minimum size , the minimum size requirements of these types are given in section of the standard , and shall be detailed below .

Size of char All versions of the standard specify , in , that sizeof yields for unsigned char , signed char , and char is implementation deﬁned whether the char type is signed or .

char is large enough to represent diﬀerent values , to be suitable for storing code units .

Size of signed and unsigned integer types The standard speciﬁes , in , that in the list of standard signed integer types , consisting of signed char , short int , int , long int , and long long int , each type will provide at least as much storage as those preceding it in the list .
Furthermore , as speciﬁed in , each of these types has corresponding standard unsigned integer type , unsigned char , unsigned short int , unsigned int , unsigned long int , and unsigned long long int , which has the same size and alignment as its corresponding signed type .
Additionally , as speciﬁed in , char has the same size and alignment requirements as both signed char and unsigned char .

Prior to , long long and unsigned long long were not oﬃcially part of the standard .
However , after their introduction to , in , many compilers supported long long as an extended signed integer type , and unsigned long long as an extended unsigned integer type , with the same rules as the types .

The standard thus guarantees that :

Instead , each type has minimum range of values it can support , which is , as speciﬁed in , inherited from the standard , in .
The minimum size of each type can be roughly inferred from this range , by determining the minimum number of bits required ; note that for any given platform , any actual supported range may be larger than the minimum .
Note that for signed types , ranges correspond to complement , not the more commonly used complement ; this is to allow wider range of platforms to comply with the standard .

Type Minimum range Minimum bits required unsigned signed short unsigned short signed int unsigned int signed unsigned signed .

Minimum range signed unsigned Minimum bits required to to As each type is allowed to be greater than its minimum size requirement , types may diﬀer in size between implementations .
The most notable example of this is with the data models and , where systems as have ints and longs , and systems as have ints and longs .
Due to this , integer types cannot be assumed to have ﬁxed width across all platforms .

If integer types with ﬁxed width are required , use types from the header , but note that the standard makes it optional for implementations to support the types , and .

Size of and The sizes of and are , as speciﬁed in , with the stipulations given in : is large enough to represent any code unit , and has the same size , signedness , and alignment as ; it is thus required to be at least bits in size .

Size of bool The size of bool is implementation deﬁned , and may or may not be .

Size of , as speciﬁed in , is distinct type , whose range of values can represent every distinct code unit of the largest extended character set among the supported locales .
It has the same size , signedness , and alignment as Complete Tips Secrets for Professionals one of the other integral types , which is known as its underlying type .
This size is , as speciﬁed in , and may be , for example , at least , or bits ; if system supports Unicode , for example , is required to be at least bits exception to this rule is Windows , where is bits for compatibility .
It is inherited from the standard , ISO , with only minor rewording .

Depending on the implementation , the size of is often , but not always , or bits .
The most common examples of these are : In Unix and systems , is , and is usually used for .

In Windows , is , and is used for .

On system which only has support , is bit .

If Unicode support is desired , it is recommended to use for , for , or for , instead of using .

Data Models As mentioned above , the widths of integer types can diﬀer between platforms .
The most common models are as follows , with sizes speciﬁed in bits : int pointer Model Out of these models : Windows used .

Note , however , that these models speciﬁcally mentioned in the standard itself .

Section : Char might be unsigned or signed The standard specify if char should be signed or unsigned .
Diﬀerent compilers implement it diﬀerently , or might allow to change it using command line switch .

Section : Ranges of numeric types The ranges of the integer types are .
The header provides the template which provides the minimum maximum values of all fundamental types .

The values satisfy guarantees provided by the standard through the headers .

Complete Tips Secrets for Professionals equals , which is greater than or equal to .

equals , which is less than or equal to .

For types , is the maximum ﬁnite value while is the minimum positive normalized value .

Additional members are provided for types , which are also but satisfy certain guarantees provided by the standard through the header .

The member gives the number of decimal digits of precision .

The member is the minimum negative such that to the power is normal .

The member is the maximum such that to the power is ﬁnite .

If the member is true , the type conforms to IEC IEEE , its range is therefore determined by that standard .

Section : Value representation of ﬂoating point types The standard requires that long double provides at least as much precision as double , which provides at least as much precision as float ; that long double can represent any value that double can represent , while double can represent any value that float can represent .
The details of the representation are , however ,

For ﬂoating point type , speciﬁes the radix used by the representation of .

If is true , then the representation of matches one of the formats deﬁned by IEC IEEE .

Section : Overﬂow when converting from integer to signed integer When either signed or unsigned integer is converted to signed integer type , its value is not representable in the destination type , the value produced is .
Example : Suppose that on this implementation , the range of signed char is to the range of unsigned char is to Complete Tips Secrets for Professionals .

If the underlying type is not explicitly speciﬁed for an unscoped enumeration type , it is determined in an manner .

Therefore , in the above code , could be int , unsigned int , or short , but not long long , to give few examples .

Note that an enum has the same size returned by as its underlying type .

Section : Numeric value of pointer The result of casting pointer to an integer using is , but .

refers to for the deﬁnition standard , an unsigned integer type with the property that any valid pointer to void can be converted to this type , then converted back to pointer to void , the result will compare equal to the original pointer .

While , for the majority of modern platforms , you can assume ﬂat address space that arithmetic on is equivalent to arithmetic on char , entirely possible for an implementation to perform any transformation when casting void to as long the transformation can be reversed when casting back from to void .

Technicalities Complete Tips Secrets for Professionals On System systems , types are required , otherwise they are optional .

Within the meaning of the standard , functions objects ; it guaranteed by the standard that can hold function pointer .
Anyway POSIX conformance requires that : All function pointer types shall have the same representation as the type pointer to void .
Conversion of function pointer to void shall not alter the representation .
void value resulting from such conversion can be converted back to the original function pointer type , using an explicit cast , without loss of information .

: When typedef names diﬀering only the absence or presence of the initial are deﬁned , they shall denote corresponding signed unsigned types as described ; an implementation providing one of these corresponding types shall also provide the other .

Section : Number of bits byte In , byte is the space occupied by char object .
The number of bits byte is given by , which is deﬁned climits and required to be at least .
While most modern systems have bytes , and POSIX requires to be exactly , there are some systems where is greater than single byte may be comprised of , or bits .

Chapter : Special Member Functions Section : Default Constructor default constructor is type of constructor that requires no parameters when called .
It is named after the type it constructs and is member function of it all constructors .

Under some circumstances , the developer provides no constructors and there are no other disqualifying , the compiler implicitly provides an empty default constructor : class ; note : members need to be default constructible themselves .

To prevent implicit default constructor creation , common technique is to declare it as private no .

The intention is to cause compile error when someone tries to use the constructor either results an Access to private error or linker error , depending on the .

To be sure default constructor similar to the implicit is deﬁned , developer could write an empty one explicitly .

In , developer can also use the delete keyword to prevent the compiler from providing default constructor .

You can determine whether type has default constructor is primitive using .

Under most circumstances , user provides no destructor , and there are no other disqualifying , the Complete Tips Secrets for Professionals .

But approach has some problems .
It fails the strong exception guarantee if  already cleared the resources owned by and cannot recover .
duplicating lot of the logic of copy construction in copy assignment .
And we have to remember the check , which usually just adds overhead to the copy operation , but is still critical .

To satisfy the strong exception guarantee and avoid code duplication so with the subsequent move assignment , we can use the idiom : class person .

If that operation  we do anything in and remains untouched .
Next , we swap the members between and rhs , and then rhs goes out of scope .
works too less eﬃcient with an extra allocation and , but if the unlikely scenario , we slow down the typical use case to account for it .

If class is movable but not copyable , there is no need to delete the , since assignment will simply be due to the deleted copy constructor .

Section : Implicit Move and Copy Bear in mind that declaring destructor inhibits the compiler from generating implicit move constructors and move assignment operators .
If you declare destructor , remember to also add appropriate deﬁnitions for the move operations .

Furthermore , declaring move operations will suppress the generation of copy operations , so these should also be added the objects of class are required to have copy .

Chapter : Random number generation Section : True random generator To generate true random values that can be used for cryptography has to be used as generator .

However may be implemented in terms of an number engine if source .

Detecting such implementations should be possible via the entropy member function return zero when the generator is completely , but many popular libraries and always return zero , even when using external randomness .

Section : Generating number number generator generates values that can be guessed based on previously generated values .

In other words : it is deterministic .
Do not use number generator in situations where true random number is required .

This code creates random number generator , and distribution that generates integers in the range with equal likelihood .
It then counts how many times each was generated .

The template parameter of speciﬁes the type of integer that should be generated .
Use to generate ﬂoats or doubles .

Section : Using the generator for multiple distributions The random number generator can be used for multiple distributions .

The distribution will generate value between and , but almost always generates , because the chance to generate is .

Chapter : References Section : Deﬁning reference References behaves similarly , but not entirely like const pointers .
reference is deﬁned by suﬃxing an ampersand to type .

References must be initialized correctly at the time of deﬁnition , and cannot be modiﬁed afterwards .
The following piece of codes causes compile .

You also cannot bind directly reference to nullptr , unlike .

Note that is not stable .

container with iterators can be sorted using the algorithm :

However , they do have sort member functions which implement sorting algorithm that works with their own iterator types .

Their member sort functions always sort the entire  so they cannot sort elements .
However , since and have fast splicing operations , you could extract the elements to be sorted from the  sort them , then stuﬀ them back where they were quite eﬃciently like  void mylist , start ,

Output : If entries with equal keys are possible , use instead in the following .

Output Complete Tips Secrets for Professionals .

Section : Sorting sequence containers by overloaded less operator If no ordering function is passed , will order the elements by calling on pairs elements , have already build in comparison operators .

We can overload this operator to make the default sort call work on types .

Section : Sorting sequence containers with specifed ordering If the values in container have certain operators already overloaded , can be used with specialized functors to sort in either ascending or descending order :

Chapter : Regular expressions Returns whether the entire character sequence was matched by the regex , optionally capturing into match object Returns whether portion the character sequence was matched by the regex , optionally capturing into match object Returns the input character sequence as modiﬁed by regex via replacement format string Initialized with character sequence deﬁned by iterators , of capture indexes to iterate over , and regex .
Dereferencing returns the currently indexed match of the regex .
Incrementing moves to the next capture index or if currently at the last index , resets the index and hinds the next occurrence of regex match in the character sequence Initialized with character sequence deﬁned by iterators and regex .
Dereferencing returns the portion of the character sequence the entire regex currently matches .
Incrementing ﬁnds the next occurrence of regex match in the character sequence Signature Complete Tips Secrets for Professionals .

Regular Expressions , introduced in , may optionally support return of matched strings or another textual syntax deﬁning how to replace matched patterns in strings operated upon .

Section : Basic and Examples .

Section : Example When processing of captures has to be done iteratively is good choice .
Dereferencing returns .
This is great for conditional captures or captures which interdependence .
say that we want to tokenize some code .
Given : enum TOKENS NUMBER , ADDITION , SUBTRACTION , MULTIPLICATION , Complete Tips Secrets for Professionals DIVISION , EQUALITY ,

notable gotcha with regex iterators is that the regex argument must be an , an will not work : Visual Studio Bug .

Section : Anchors provides only anchors : which asserts the start of the string which asserts the end of the string which asserts character or the beginning or end of the string which asserts character .

An important note here is that the anchor does not consume any characters .

Section : Example .

Section : Example provides tremendous tool for extracting elements of Comma Separated Value ﬁle .
Aside from the advantages of iteration , this iterator is also able to escaped commas where other methods .

notable gotcha with regex iterators is , that the regex argument must be an .
An will not work .

Section : Quantiﬁers Let ' say that given const string as phone number to be validated .
We could start by requiring numeric with zero or more quantiﬁer : or one or more quantiﬁer : But both of those really fall short if contains an invalid numeric string like : Let ' use or more quantiﬁer to ensure that getting at least digits : This will guarantee that we will get at least phone number of digits , but could also contain numeric string .

It ' important to note that the lazy quantiﬁer matches as few characters as possible , so the only way this character will be matched is if there are already characters that been matched by .

Now , how would we make the area code optional and only accept country code if the area code was present .

In this ﬁnal regex , the requires digits .
These digits are optionally preceded by either or digits .

Note that we did not append the lazy quantiﬁer : the .
Instead making the group match at most once , preferring not to match .
Causing mismatch if didn ' include the area code like :

In conclusion of the quantiﬁer topic , like to mention the other appending quantiﬁer that you can use , the possessive quantiﬁer .
Either the lazy quantiﬁer or the possessive quantiﬁer can be appended to any quantiﬁer .

The possessive quantiﬁer ' only function is to assist the regex engine by telling  greedily take these characters and don ' ever give them up even if causes the regex to fail .
This for example doesn ' make much sense : Because an like : wouldn ' be matched as will always match characters even if matching would allowed the regex to succeed .

With the possessive quantiﬁer the regex starts where the possessive quantiﬁer left oﬀ , the ' character , and the regex engine tries to adjust the to allow to match ; when can ' the regex just fails , no tracking is done to see if earlier adjustment could allowed match .

The parent class : Let ' start with the polymorphic class : class public : virtual virtual virtual .

You can deﬁne polymorphic behavior introduced member functions with the keyword virtual .
Here and will obviously be implemented diﬀerently for square than for circle .
When the function is invoked on an object , function corresponding to the real class of the object will be determined at runtime .

It makes no sense to deﬁne for an abstract .
This is why the function is followed .

This means that the function is pure virtual function .

polymorphic class should always deﬁne virtual destructor .

You may deﬁne non virtual member functions .
When these function will be invoked for an object , the function will be chosen depending on the class used at .
Here is deﬁned in this way .

class that contains at least one pure virtual function is an abstract class .
Abstract classes cannot be instantiated .
You may only have pointers or references of an abstract class type .

Derived classes Once polymorphic base class is deﬁned you can derive .
For example : class Square  public Point .

Some explanations : You can deﬁne or override any the virtual functions the parent class .
The fact that function was virtual in the parent class makes it virtual in the derived class .
No need to tell the compiler the keyword virtual again .
But recommended to add the keyword override at the end the function declaration , in order to prevent subtle bugs caused unnoticed variations in the function signature .

If all the pure virtual functions the parent class are deﬁned you can instantiate objects for this class , else it will also become an abstract class .

You are not obliged to override all the virtual functions .
You can keep the version the parent if it suits your need .

Example instantiation .

Most the time , you would not need to know which is the real type the object , as the virtual functions allow you to manipulate your object independently its type :  If you need any downcast , your design would be perfect .

However , you may need sometimes to downcast .
typical example is when you want to invoke non virtual function that exist only for the child class .

Consider for example circles .
Only circles have diameter .
So the class would be deﬁned as  class Circle : public for  see example on defining polymorphic class Point .

But very risky : if appears to anything else than Circle the behavior your code will be undeﬁned .

So rather than playing Russian roulette , you should safely use .
This is speciﬁcally for polymorphic classes .

Section : Polymorphism Destructors If class is intended to be used polymorphically , with derived instances being stored as base , its base class ' destructor should be either virtual or protected .
In the former case , this will cause object destruction to check the vtable , automatically calling the correct destructor based on the dynamic type .
In the latter case , destroying the object through base class is disabled , and the object can only be deleted when explicitly treated as its actual type .

Chapter : Perfect Forwarding Section : Factory functions Suppose we want to write factory function that accepts an arbitrary list arguments and passes those arguments unmodiﬁed to another function .
An example such function is , which is used to safely construct new and return that owns the .

The language rules regarding variadic templates and rvalue references allows us to write such function .

The compiler will expand this parameter pack to the correct number arguments at the call site .
These arguments are then passed to constructor using .
This function is required to preserve the the arguments .

The speciﬁer final can only be used with ' member function and be applied to member functions Like final , there is also an speciﬁer caller ' which prevent overriding virtual functions in the derived class .

The speciﬁers override and final may be combined together to have desired eﬀect : class  public Base .

Section : Using override with virtual in and later The speciﬁer override has special meaning in onwards , if appended at the end function signature .
This signiﬁes that function is Overriding the function present in base class The Base class function is virtual Complete Tips Secrets for Professionals There is no run time signiﬁcance this speciﬁer as is mainly meant as an indication for compilers The example below will demonstrate the change in behaviour with our without using override .

The reasoning behind this is that the derived class may deﬁne additional members which are not yet initialized the constructor or already destroyed the destructor , and calling its member functions would be unsafe .
Therefore during construction and destruction objects , the dynamic type considered to be the or class and not class .

Section : Pure functions We can also specify that function pure , by to the declaration .
Classes with one or more pure functions are considered to be abstract , and cannot be instantiated ; only derived classes which deﬁne , or inherit deﬁnitions for , all pure functions can be instantiated .

In this case , Complete Tips Secrets for Professionals .

There are couple reasons why we might want to do this : If we want to create class that itself be instantiated , but prevent its derived classes from being instantiated , we can declare the destructor as pure .
Being the destructor , it must be deﬁned anyways , if we want to be able to deallocate the .
And as the destructor most likely already to prevent memory leaks during polymorphic use , we incur an unnecessary performance hit from declaring another function .
This can be useful when making interfaces .

Chapter : Undeﬁned Behavior What undeﬁned behavior .
According to the ISO Standard , it for which this This means that when program encounters UB , it allowed to do whatever it wants .
This often means crash , but it may simply do nothing , make demons ﬂy out of your nose , or even appear to work properly .

Needless to say , you should avoid writing code that invokes UB .

Although this most often causes segmentation fault , it undeﬁned and anything can happen .

This results in undeﬁned behavior , because uninitialised .

It often , incorrectly , claimed that this because the value , or value was in that memory location .
However , it the act of accessing the value of in the above example that gives undeﬁned behaviour .
In practice , printing value " common symptom in this case , but that only one possible form of undeﬁned behaviour .

Although highly unlikely in practice it reliant on speciﬁc hardware the compiler could equally well electrocute the programmer when compiling the code sample above .
With such compiler and hardware support , such response to undeﬁned behaviour would markedly increase average programmer understanding of the true meaning of undeﬁned behaviour which that the standard places no constraint on the resultant behaviour .

Note that static variable always : static .

pointer must point to an element within the  or one past the .

Section : Deleting object via pointer to base class that .

In section the standard says that if delete called on an object whose static type does not have destructor : if the static type of the object to be deleted diﬀerent from its dynamic type , the static type shall be base class of the dynamic type of the object to be deleted and the static type shall have destructor or the behavior undeﬁned .

This the case regardless of the question whether the class added any data members to the base class .

Section : Extending the or Namespace The standard generally forbids extending the std namespace : The behavior of program undeﬁned if it adds declarations or deﬁnitions to namespace std or to namespace within namespace std unless otherwise speciﬁed .

The same goes for posix : The behavior of program undeﬁned if it adds declarations or deﬁnitions to namespace posix or to namespace within namespace posix unless otherwise speciﬁed .

Consider the following :

Nothing in the standard forbids algorithm one of the headers it deﬁning the same deﬁnition , and so this code would violate the One Deﬁnition Rule .

So , in general , this forbidden .
There are speciﬁc exceptions allowed , though .
Perhaps most usefully , it allowed to add specializations for user deﬁned types .
So , for example , suppose your code has class .

Section : Invalid pointer arithmetic The following uses of pointer arithmetic cause undeﬁned behavior : Addition or subtraction of an integer , if the result does not belong to the same object as the pointer .

Any pointer arithmetic where either pointee type does not match the dynamic type of the object pointed to .
According to the standard , particular , pointer to base class Complete Tips Secrets for Professionals .

Note : main is the only exception to the rule .
If main have return statement , the compiler automatically inserts return ; for you , so it can be safely left out .

Section : Accessing dangling reference It is illegal to access reference to an object that has gone out of scope or been otherwise destroyed .

This program has undeﬁned behavior , although it may appear to work and print in some cases .

Section : Shifting by an invalid number of positions For the shift operator , the right operand must be nonnegative and strictly less than the bit width of the promoted left operand .
Otherwise , the behavior is undeﬁned .

If the argument to delete was not returned by new is an array , the behavior is undeﬁned .

An object can only be deallocated by if it was allocated by new is an array .
If the argument to was not returned by new is not an array , the behavior is undeﬁned .

If the argument to free was not returned by malloc , the behavior is undeﬁned .

If during the evaluation of an expression , the result is not mathematically deﬁned not in the range of representable values for its type , the behavior is undeﬁned .

This is one of the more nasty ones , as it usually yields reproducible , behavior so developers may be tempted to rely heavily on the observed behavior .

Complete Tips Secrets for Professionals .

Sometimes compilers may exploit an undeﬁned behavior optimize .

Unlike redeﬁnition of class within the same translation unit , this problem is not required to be diagnosed by the compiler .

Section : Modifying const object Any attempt to modify const object results in undeﬁned behavior .
This applies to const variables , members of .

compiler will usually inline the value of const object , so possible that this code compiles prints .

Compilers can also place const objects ' values in memory , so segmentation fault may occur .
In any case , the behavior is undeﬁned the program might do anything .

The following program conceals far more subtle error :

In this code , getFoo creates singleton of type const its member is initialized to .
Then is called the value of .

Despite its name , does nothing particularly evil ; all it does is call setter through .
But that pointer points to const object even though was not used .
This pointer was obtained through constructor .
const object does not become const until its initialization is complete , so this has type , not const , within the constructor .

Complete Tips Secrets for Professionals .

Therefore , undeﬁned behavior occurs even though there are no obviously dangerous constructs in this program .

Section : Returning from function .

Section : Overﬂow during conversion to from ﬂoating point type If , during the conversion of : an integer type to ﬂoating point type , ﬂoating point type to an integer type , ﬂoating point type to shorter ﬂoating point type , the source value is outside the range of values that can be represented in the destination type , the result is undeﬁned behavior .
Example : double ;  probably cannot hold numbers that large , so this is UB .

The initialisation of in the above example was formally deprecated for removal from future version of the in .
number of compilers before might issue warning about this suspicious .
After , compilers typically warn about deprecated conversion .

The above example is illegal , results in compiler diagnostic , in later .
similar example may be .

There are some exceptions to this strict aliasing rule : An object of class type can be accessed as though it were of type that is base class of the actual class type .

Any type can be accessed as char unsigned char , but the reverse is not true : char array cannot be accessed as though it were an arbitrary type .

signed integer type can be accessed as the corresponding unsigned type vice versa .

related rule is that if member function is called on an object that does not actually have the same type as the deﬁning class of the function , derived class , then undeﬁned behavior occurs .
This is true even if the function does not access the object .

Section : Invalid conversion for pointers to members When is used to convert to , the member pointed to must belong to class that is base class or derived class of .
Otherwise the behavior is undeﬁned .
See to base conversion for pointers to members Section : Destroying an object that has already been destroyed .

Section : Access to nonexistent member through pointer to member When accessing member of an object through pointer to member , if the object does not actually contain the member denoted by the pointer , the behavior is undeﬁned .

See to derived conversion .

Section : Floating point overﬂow If an arithmetic operation that yields ﬂoating point type produces value that is not in the range of representable values of the result type , the behavior is undeﬁned according to the standard , but may be deﬁned by other standards the machine might conform to , such as IEEE .

Section : Calling Virtual Members From Constructor Or Destructor The Standard states : Member functions can be called from constructor of an abstract class ; the eﬀect of making virtual call to pure virtual function directly or indirectly for the object being created from such constructor is undeﬁned .

More generally , some authorities ,
Scott Meyers , suggest never calling virtual functions from constructors and dstructors .

Complete Tips Secrets for Professionals Consider the following example , modiﬁed from the above link : class transaction .

This implicitly calls the constructor of , which ﬁrst calls the constructor of transaction .
When the constructor of transaction is called though , the object is not yet of the type , but rather only of the type transaction .

Consequently , the call in to , do what might seem to be the intuitive thing namely call .

If is pure virtual , as in this example , the behaviour is undeﬁned .

If is virtual , will be called .

Section : Function call through mismatched function pointer type In order to call function through function pointer , the function type must exactly match the .

Chapter : Value and Reference Semantics Section : Deﬁnitions type has value semantics if the observable state is functionally distinct from all other objects of that type .

This means that if you copy an  you have new  and modiﬁcations of the new will not be in any way visible from the old .

Most basic types have value semantics : int .

type is said to have reference semantics if an instance of that type can share its observable state with another to , such that manipulating one will cause the state to change within another .

pointers have value semantics with regard to which they point to , but they have reference semantics with regard to the state of the they point .

Section : Deep copying and move support If type wishes to have value semantics , and it needs to store objects that are dynamically allocated , then on copy operations , the type will need to allocate new of those objects .
It must also do this for copy assignment .

This kind of copying is called .
It eﬀectively takes what would have otherwise been reference semantics and turns it into value semantics : struct ;

Move semantics allow type like to avoid truly copying its referenced data .
If the user uses the value in way that provokes move , the " from can be left empty of the data it referenced : Complete Tips Secrets for Professionals .

Chapter : Overload resolution Section : Categorization of argument to parameter cost Overload resolution partitions the cost of passing an argument to parameter into one of four diﬀerent categorizes , called .
Each sequence may include zero , one or several conversions Standard conversion sequence void ;

The general principle is that Standard conversion sequences are the cheapest , followed by user deﬁned conversion sequences , followed by ellipsis conversion sequences .

special case is the list initialization sequence , which does not constitute conversion initializer list is not an expression with .
Its cost is determined by deﬁning it to be equivalent to one of the other three conversion sequences , depending on the parameter type and form of initializer list .

Section : Arithmetic promotions and conversions Converting an integer type to the corresponding promoted type is better than converting it to some other integer .

Therefore , in order to ensure that there will be no ambiguity when calling function with either integral or arguments of any standard type , total of eight overloads are needed , so that for each possible argument type , either an overload matches exactly or the unique overload with the promoted argument type will be selected .

Both are Exact Matches , but takes reference to less than does , so it has the better standard conversion sequence and is the best viable function .

The solution here is to always constrain these constructors .
As result , the copy constructor is invoked which is what we wanted .

Section : Exact match An overload without conversions needed for parameter types or only conversions needed between types that are .

For the purposes of overload resolution , the type of  is considered to match exactly with the type to , and the function type is considered to match exactly with the function pointer type , even though both Complete Tips Secrets for Professionals .

An inaccessible function might be selected by overload .

Section : Steps of Overload Resolution The steps of overload resolution are :
Find candidate functions via name lookup .
Unqualiﬁed calls will perform both regular unqualiﬁed lookup as well as lookup .

Filter the set of candidate functions to set of viable functions .

Pick the best viable candidate .

Chapter : Move Semantics Section : Move semantics Move semantics are way of moving to another in .
For this , we empty the old and place everything it had in the new .

An rvalue reference where is the is not much diﬀerent than normal reference , now called lvalue .
But they act as diﬀerent types , and so , we can make constructors or functions that take type or the other , which will be necessary when dealing with move semantics .

The reason why we need two diﬀerent types is to specify two diﬀerent behaviors .
Lvalue reference constructors are related to copying , while rvalue reference constructors are related to moving .

To move an  we will use .

There are several ways of doing this which are discussed below .

Important to note is that the use of creates just an rvalue reference .
In other words the statement does not change the content of  while auto does .

introduced core language and standard library support for moving an .
The idea is that when an is temporary and wants logical copy , then its safe to just pilfer resources , such as dynamically allocated buﬀer , leaving logically empty but still destructible and copyable .

The core language support is mainly the rvalue reference type builder , is an rvalue reference to , indicating special support for move constructor , which is supposed to eﬃciently move resources from the speciﬁed other  instead of actually copying those resources , and special support for move assignment auto arrow_operator which also is supposed to move from the source .

The standard library support is mainly the function from the header .
This function produces an rvalue reference to the speciﬁed  indicating that it can be moved from , just as if it were temporary .

For container actual copying is typically of complexity , where is the number of items in the container , while moving is , constant time .
And for an algorithm that logically copies that container times , this can reduce the complexity from the usually impractical to just linear .

Complete Tips Secrets for Professionals In his article That Never Change " in Dr .
Dobbs Journal in September , Andrew Koenig presented an interesting example of algorithmic ineﬃciency when using style of programming where variables are immutable after initialization .
With this style loops are generally expressed using recursion .
And for some algorithms such as generating Collatz sequence , the recursion requires logically copying container : Based on an example by Andrew Koenig in his Dr .
Dobbs Journal article .

In concrete numbers , with and Visual compilers the above invocation of resulted in Collatz sequence of items and item copy , plus in copy constructor calls .

All of these item copy can be removed by simply moving vectors whose values are not needed anymore .

To do this necessary to remove const and reference for the type arguments , passing the vectors by value .

The function returns are already automatically optimized .
For the calls where vectors are passed , and not used again further on in the function , just apply to move those buﬀers rather than actually copying them : using .

The algorithm is necessarily still in the length of the Collatz sequence produced , but this is quite dramatic improvement :

With some language support could perhaps use moving and still express and enforce the immutability of .

Alas , as of does not support that .
For code the no use after move can be enforced via of the relevant name as an incomplete struct , as with struct result ; above , but this is ugly and not likely to be understood by other programmers ; also the diagnostics can be quite misleading .

Summing up , the language and library support for moving allows drastic improvements in algorithm complexity , but due the incompleteness , at the cost of forsaking the code correctness guarantees and code clarity that const can provide .

For completeness , the instrumented class used to measure the number of item copy due to copy constructor invocations : class Item class .

To create copy constructor , that is , to make function that copies an and creates new  we normally would choose the syntax shown above , we would have constructor for that takes an reference to another of type  and we would copy the manually inside the method .

Complete Tips Secrets for Professionals Alternatively , we could have written default ; which automatically copies over all members , making use of its copy constructor .

To create move constructor , however , we will be taking an rvalue reference instead of an lvalue reference , like here .

As move semantics are designed to allow ' state from the original instance , it is important to consider how the original instance should look like after this stealing .
In this case , if we would not change the value to zero we would have doubled the amount of dollars into play .

Thus we have move constructed an object from an old .

While the above is simple example , it shows what the move constructor is intended to do .
It becomes more useful in more complex cases , such as when resource management is involved .

Section : Move assignment Similarly to how we can assign value to an object with an lvalue reference , copying it , we can also move the values from an object to another without constructing new .
We call this move assignment .
We move the values from object to another existing object .

Complete Tips Secrets for Professionals .

So , if you have access to the static function and decorate it correctly , then you can point to the function like any normal function outside class : typedef int ; Fn is function that accepts an int and returns an int Note that is of type .

Point to function Call it Point to the other function Call it Section : Pointers to functions To access function of class , you need to have " to the particular  as either the Complete Tips Secrets for Professionals itself , or pointer or reference to it .
Given class  you can point to various of its members with , IF you get the syntax correct .
Of course , the pointer has to be declared to be of the same type as what you are pointing .

Given class  you can point to various of its members with , IF you get the syntax correct .
Of course , the has to be declared to be of the same type as what you are pointing .

Point to within any Use to fetch from Point to within any Use to fetch from Complete Tips Secrets for Professionals .

The syntax of requires some extra syntactic elements : To deﬁne the type of the  you need to mention the base type , as well as the fact that it is inside class : int .

If you have class or reference and want to use it with , you need to use the to the .

If you have to class and want to use it with , you need to use the to the arrow_operator

Section : Pointers to static variables static variable is just like an ordinary variable , except with scope : It is inside class , so it needs its name decorated with the class name ; It has accessibility , with public , protected or private .

So , if you have access to the static variable and decorate it correctly , then you can point to the variable like any normal variable outside class : class .

Section : Basic Pimpl idiom .

The pImpl contains the state of .
Instead of the description of state being exposed in the header ﬁle , it be only exposed within the implementation .

The " implementation of is in the pImpl .

Danger : Note that for this to work with  must be implemented at point in ﬁle where the Impl is fully visible .

Chapter : To wrap any element that is callable .

Section : used with Think about situation where we need to callback with arguments .

Section : Binding : to callable types This example show some ways of using : to call lambda Complete Tips Secrets for Professionals Function call be made : with right arguments argumens with different order , types and count .

Live Output : Test stored functions with arguments : called with arguments : result is  called with arguments : result is  called with arguments : result is  called with arguments : result is  lambda called with arguments : result is  Section : Storing arguments in Some programs need so store arguments for future calling of some .

Complete Tips Secrets for Professionals .

Output : called .

Because : has , it must copy or move the given callable into itself .
But since it can take callables of an arbitrary type , it will frequently have to allocate memory dynamically to do this .

Some implementations have object , where small types pointers , member pointers , or functors with very little will be stored directly in the object .
But even this only works if the type is noexcept move constructible .
Furthermore , the standard does not require that all implementations provide one .

parameter would be the preferred solution for SortMyContainer , but let us assume that this is not possible or desirable for whatever reason .
SortMyContainer does not need to store pred beyond its own call .
And yet , pred may well allocate memory if the functor given to it is of some size .

But SortMyContainer does not need to own the callable ; just referencing it .
So using here is overkill ; it may be eﬃcient , but it may not .

There is no standard library type that merely references callable .
So an alternate solution will have to be found , or you can choose to live with the overhead .

Also , has no eﬀective means to control where the memory allocations for the object come from .
Yes , it has constructors that take an allocator , but implementations do not implement them .

The constructors that take an allocator no longer are part of the type .
Therefore , there is no way to manage the allocation .

Calling is also slower than calling the contents directly .
Since any instance could hold any callable , the call through must be indirect .
The overhead of calling is on the order of virtual call .

Chapter : const keyword const initial ; Declares const variable ; cannot be changed const  Declares reference to const variable const ; Declares .
The pointer can change , but the underlying data member cannot be changed through the pointer const ; Declares const pointer .
The pointer cannot be reassigned to point to something else , but the underlying data member can be changed const const ; Declares const .

Section : Avoiding duplication of code in const and getter methods .

In methods that diﬀers only by const qualiﬁer can be overloaded .
Sometimes there may be need of two versions of getter that return reference to some member .

Let Foo be class , that has two methods that perform identical operations and returns reference to an object of type Bar : class Foo .

The only diﬀerence between them is that one method is and return reference can be use to modify and the second is const and returns const reference .

To avoid the code duplication , there is temptation to call one method from another .
However , we can not call method from the const one .
But we can call const method from one .
That will require as to use ' to remove the const qualiﬁer .

The solution is : struct Foo .

Since we call const method from , the object itself is , and casting away the const is allowed .

Examine the following more complete example : class Student .

In const member  the this pointer is eﬀectively const MyClass instead of MyClass .
This means that you cannot change any member variables within the  the compiler will emit warning .
So setMyInt could not be declared const .

You should almost always mark member functions as const when possible .
Only const member functions can be called on const MyClass .

This is because static method belongs to class and is not called on object ; therefore it can never modify internal variables .
So declaring static methods as const would be redundant .

Section : Const local variables .

It is especially convenient when dealing with long type .

Section : auto and proxy objects Sometimes auto may behave not quite as was expected by programmer .
It type deduces the expression , even when type deduction is not the right thing to do .

As an example , when proxy objects are used in the .

When modiﬁes the container , this could end up dangling , referring to an element that no longer exists .

In cases like this you can declare variable with auto and initialize it by casting to the type you want to be deduced : auto ; but at that point , simply replacing auto with bool makes more sense .

Another case where proxy objects can cause problems is expression templates .
In that case , the templates are sometimes not designed to last beyond the current for eﬃciency sake , and using the proxy object on the next causes undeﬁned behavior .

Section : auto and Expression Templates .

By using auto , creating dangling reference .
Instead of mult had returned , then the code would deﬁnitely .

Section : auto , const , and references The auto keyword by itself represents type , similar to or char .
It can be modiﬁed with the const keyword and the symbol to represent const type or reference type , respectively .
These modiﬁers can be combined .

In this example , is type type will be inferred as , so each iteration of the for loop copies string from the into .

If the body of the loop modiﬁes as by calling " and , only this copy will be modiﬁed , not the original member of .

On the other hand , if is declared with it will be reference type to be , so on each iteration of the loop it will be assigned reference to string in the .

Complete Tips Secrets for Professionals .

When using auto with for loops , it is generally good practice to use const if the loop body will not modify the structure being looped over , since this avoids unnecessary copies .

Section : Trailing return type auto is used in the syntax for trailing return .

This is good solution for large objects that have been dynamically allocated and are already managed by pointers .
However , this solution does not work well for small or primitive types such as  which are rarely ever dynamically allocated or managed by pointers .

In this example , struct Person is deﬁned .
It is possible for person to have pet , but not necessary .
Therefore , the pet member of Person is declared with an : wrapper .

Here we return either the fraction , but if it is not deﬁned be we instead return the empty .

more complex case : Range , class .

It returns either an empty if it was not found , or an containing an tothe element if it was .

This lets you take the and give default behavior when you actually need value .
By doing it this way , the behavior " decision can be pushed back to the point where it best made and immediately Complete Tips Secrets for Professionals .

Section : Introduction Optionals known as Maybe are used to represent type whose contents may or may not be present .

They are implemented in as the : class .
For example , an object of type may contain some value of type int , or it may contain no value .

Optionals are commonly used either to represent value that may not exist or as return type from function that can fail to return meaningful result .

Other approaches to There are many other approach to solving the problem that : solves , but none of them are quite complete : using pointer , using sentinel , or using ,

Optional vs Pointer In some cases , we can provide pointer to an existing object or nullptr to indicate failure .
But this limited to those cases where already exist  as value type , can also be used to return new without resorting to memory allocation .

Optional vs Sentinel common idiom to use special value to indicate that the value meaningless .
This may be or for integral types , or nullptr for pointers .
However , this reduces the space of valid values cannot diﬀerentiate between valid and meaningless and many types do not have natural choice for the sentinel value .

Optional vs , Another common idiom to provide pair , where one of the elements bool indicating whether or not the value meaningful .

This relies upon the value type being in the case of error , which not possible for some types and possible but undesirable for others .
An , in the case of error , does not need to construct anything .

Section : Using optionals to represent the failure of function Before , function typically represented failure in one of several ways : null pointer was returned .

Calling function Delegate on an App instance that did not have delegate would return nullptr .

This good solution for that have been dynamically allocated or are large and managed by pointers , but good solution for small that are typically and passed by copying .

speciﬁc value of the return type was reserved to indicate failure .

Calling function unsigned , Vertex on two vertices that are not connected may return zero to indicate this fact .

The value was paired together with bool to indicate the returned value was meaningful .

Calling function , with string argument that not an integer would return with an undeﬁned int and bool set to false .

In this example , John given two pets , Fluﬀy and Furball .
The function then called to retrieve John ' pet Whiskers .
Since John does not have pet named Whiskers , the function fails and Complete Tips Secrets for Professionals .

Chapter : Copy Elision Section : Purpose of copy elision There are places in the standard where an object copied or moved in order to initialize an object .
Copy elision called return value an optimization whereby , under certain speciﬁc circumstances , compiler permitted to avoid the copy or move even though the standard says that it must happen .

Consider the following .

The standard very clear that this how the code interpreted .

Copy elision rule that permits compiler to ignore the creation of the temporary and its subsequent .
That  the compiler can take the initializing expression for the temporary and initialize the return value from it directly .
This obviously saves performance .

However , it does have two visible eﬀects on the user :
The type must have the constructor that would have been called .
Even if the compiler elides the , the type must still be able to have been .

of constructors are not guaranteed in circumstances where elision can happen .

What will calling func do .
Well , it will never print , since the temporary an rvalue and moveable type .
So will it print .

Without the copy elision rule , this would be required to always print .
But because the copy elision rule exists , the move constructor may or may not be called ; it .

And therefore , you cannot depend on the calling of constructors in contexts where elision possible .

Because elision an optimization , your compiler may not support elision in all cases .
And regardless of whether the compiler elides particular case or not , the type must still support the operation being elided .
So if copy construction elided , the type must still have copy constructor , even though it will not be called .

Section : Guaranteed copy elision Normally , elision an optimization .
While virtually every compiler support copy elision in the simplest of cases , having elision still places particular burden on users .
Namely , the type being elided must still have the operation that was elided .

This might be useful in cases where mutex that privately held by some system , yet an external user might want to have scoped lock to it .

This also not legal , because : cannot be copied or moved .
Even though virtually every compiler will elide the , the standard still requires the type to have that operation available .

mandates elision by eﬀectively redeﬁning the very meaning of certain expressions so that no takes place .

Under wording , that code says to create temporary and then use the temporary to into the return value , but the temporary copy can be elided .
Under wording , that does not create temporary at all .

In , any prvalue expression , when used to initialize an object of the same type as the expression , does not generate temporary .
The expression directly initializes that object .
If you return prvalue of the same type as the return value , then the type need not have constructor .
And therefore , under rules , the above code can work .

The wording works in cases where the type matches the type being initialized .
So given above , this will also not require : Since the result of is prvalue expression being used to initialize an object of the same type , no copying or moving will happen .
That expression never creates temporary ; it is used to directly initialize .
There is no elision because there is no to be elided elide .

The term copy elision " is therefore something of misnomer , but that is the of the feature as it is proposed for standardization .
It does not guarantee elision at all ; it eliminates the altogether , redeﬁning so that there never was to be elided .

This feature only works in cases involving prvalue expression .
As such , this uses the usual elision .

While this is valid case for copy elision , rules do not eliminate the in this case .
As such , the type must still have constructor to use to initialize the return value .
And since does not , this is still compile error .
Implementations are allowed to refuse to elide copies when passing or returning an object of type .
This is to allow moving such objects around in registers , which some ABIs might mandate in their calling conventions .

Copy elision permits this expression to directly create the object in str , rather than using .

This is useful optimization for cases where constructor is declared explicit .
For example , we could have written the above as , but only because string has an implicit constructor that converts from const to string .
If that constructor was explicit , we would be forced to use temporary to call the explicit constructor .
Copy elision saves us from having to do needless .

Section : Return value elision If you return prvalue expression from function , and the prvalue expression has the same type as the .

Section : Named return value elision If you return an lvalue expression from function , and this lvalue : represents an automatic variable local to that function , which will be destroyed after the return the automatic variable is not function parameter and the type of the variable is the same type as the return type If all of these are the case , then the from the lvalue can be .

Chapter : Bit Operators .

Using this , when the binary value for and the binary value for are together we get the binary value of : int int The bit wise XOR does not change the value of the original values unless speciﬁcally assigned to using the bit wise .

Note : The following example is often shown as an example of nice trick .
But should not be used in production code are better ways to achieve the same .

You might note that shifting value to the left time is also the same .

Possible output : While some compilers will yield results that seem expected , it should be noted that if you left shift signed number so that the sign bit is aﬀected , the result is undeﬁned .
It is also undeﬁned if the number of bits you wish to shift by is negative number or is larger than the number of bits the type on the left can hold ,

Complete Tips Secrets for Professionals Why The right bit wise shift will shift the bits of the left hand value the number speciﬁed on the right ; it should be noted that while the operation of right shift is standard , what happens to the bits of right shift on signed negative number is implementation deﬁned and thus cannot be guaranteed to be portable , example : int ; int ; the value of will be depend on the compiler .

Chapter : Fold Expressions Section : Unary Folds Unary folds are used to fold parameter packs over speciﬁc .
There are kinds of unary folds : Unary Left Fold .

Section : Binary Folds Binary folds are basically unary folds , with an extra argument .

There are kinds of binary folds : Binary Left Fold op .

void  Ts .

lot of compilers will allow this and might issue warning , but the will be ; this compiler extension and cannot be guaranteed across compilers .

Unions are specialized struct within which all members occupy overlapping memory .

Complete Tips Secrets for Professionals .

Chapter : Unnamed types Section : Unnamed classes Unlike named class or struct , unnamed classes and structs must be instantiated where they are deﬁned , and cannot have constructors or destructors .

Section : Anonymous Union Member names of an anonymous union belong to the scope of the union declaration an must be distinct to all other names of this scope .
The example here has the same construction as example Anonymous Members using " but standard conform .

If you are thinking about caching of expensive computation , you should probably use this keyword .

If you have lock example , data ﬁeld which locked and unlocked inside const method , this keyword also what you could use .

You should not use this keyword to break logical of an object .

Example with caching : class .

Bit ﬁelds tightly pack and structures to reduce size .
This appears painless : specify the number of bits for members , and compiler does the work of bits .
The restriction inability to take the address of bit ﬁeld member , since it stored .

The cost of bit ﬁelds slower access , as memory must be retrieved and bitwise operations applied to extract or modify member values .
These operations also add to executable size .

Section : Declaration and Usage .

Here , each of these two ﬁelds will occupy bit in memory .
It speciﬁed by  expression after the variable names .

Base of bit ﬁeld could be any integral int to .
Using unsigned recommended , otherwise surprises may come .

If more bits are required , replace " with number of bits required .
For example : struct Date .

If is : can be initialized in the following ways : struct int ; An aggregate Using aggregate initialization with brace elision .

If pos is not within the range of the container , runtime segmentation violation error can occur .
This method provides element access equivalent to classic arrays and thereof more eﬃcient than .

The complexity is constant .

The complexity is constant .

Chapter : Singleton Design Pattern Section : Lazy Initialization This example has been lifted from the section See this article for simple design for lazy evaluated with guaranteed destruction singleton : Can any one provide me sample of Singleton in .

The classic lazy evaluated and correctly destroyed singleton .

See this article that discusses some threading implications to singletons : Singleton instance declared as static variable of GetInstance method See this article that explains why double checked locking will not work on : What are all the common undeﬁned behaviours that programmer should know about .

Section : Static singleton .

There are times with multiple static objects where you need to be able to guarantee that the singleton will not be destroyed until all the static objects that use the singleton no longer need it .

In this case can be used to keep the singleton alive for all users even when the static destructors are being called the end of the program : class .

Section : Singeton The standards guarantees that the initialization of function scope objects are initialized in synchronized manner .
This can be used to implement singleton with lazy initialization .

Chapter : The ISO Standard In , the there was ﬁrst publication of the standard making an internally standardized language .
From that time , has evolved resulting in diﬀerent dialects of .
On this page , you can ﬁnd an overview of all diﬀerent standards and their changes compared to the previous version .
The details on how to use these features is described on more specialized pages .

Section : Current Working Drafts All published ISO standards are available for sale from the ISO store .
The working drafts of the standards are publicly available for free though .

The diﬀerent versions of the standard : Proposed referred as or : March working draft .

referred as : November working draft referred as : February working draft Section : The standard is feature complete and has been proposed for standardization .
In compilers with experimental support for these features , it is usually referred to as .

Language Extensions Fold Expressions declaring template arguments with auto Guaranteed copy elision Template parameter deduction for constructors Structured bindings Compact nested namespaces New attributes : Default message for Initializers in if and switch Complete Tips Secrets for Professionals Inline variables if constexpr Order of expression evaluation guarantees Dynamic memory allocation for data Library Extensions and for associative containers ﬁle system library with the header .

Parallel versions of most of the standard algorithms the .

Addition of mathematical special functions in the header .

Moving nodes between , and Section : The standard is major extension to the standard .
Below you can ﬁnd an overview of the changes as they have been grouped on the isocpp FAQ with links to more detailed documentation .

Language Extensions General Features auto decltype statement Initializer lists Uniform initialization syntax semantics Rvalue references move semantics Lambdas noexcept to prevent exception propagation constexpr nullptr null pointer literal Copying rethrowing exceptions Inline namespaces literals Classes Control of default move copy Delegating constructors member initializers Inherited constructors Override controls : override Override controls : ﬁnal Explicit conversion operators Other Types enum class long long longer integer Extended integer types Generalized unions Complete Tips Secrets for Professionals Generalized PODs Templates Extern templates Template aliases Variadic templates Local types as template arguments Concurrency Concurrency memory model Dynamic initialization destruction with concurrency storage Miscellaneous Language Features What is the value of for .

Suﬃx return type syntax Preventing narrowing brackets assertions Raw string literals Attributes Alignment features Library Extensions General Garbage collection ABI tuple Type traits function bind Regular Expressions Time utilities Random number generation Scoped allocators Containers Algorithms Algorithms improvements Container improvements containers Concurrency Threads Mutual exclusion Locks Condition variables Complete Tips Secrets for Professionals Atomics Futures promises async Abandoning process Section : The standard is often referred to as bugﬁx for .
It contains only limited list of changes of which most are extensions to the new in .
Below you can ﬁnd an overview of the changes as they have been grouped on the isocpp FAQ with links to more detailed documentation .

Language Extensions Binary literals Generalized return type deduction Generalized lambda captures Generic lambdas Variable templates Extended constexpr The attribute Digit separators Library Extensions Shared locking literals for : types Type transformation aliases Deprecated Removed was deprecated in removed from is deprecated Section : is the ﬁrst standardized version of .
As it was developed as an extension to , many of the which set apart from are added .

Classes , Derived classes , virtual member functions , const member functions Function overloading , Operator overloading References new delete templates namespaces exceptions speciﬁc casts Complete Tips Secrets for Professionals Library Extensions The Standard Template Library Section : The standard mainly addresses defect reports of the standard .
Apart from these defects , it only adds one new .

Language Extensions Value initalization Section : is the upcoming standard of , currently in development , based upon the standard .
progress can be tracked on the oﬃcial ISO cpp website .

The following are simply what has been accepted for the next release of the standard , targeted for .

Language Extensions No language extensions have been accepted for now .

Library Extensions No library extensions have been accepted for now .

Chapter : Literals Section : literal for Despite you can write in like : int ; here comes famous example with implementation for .

Those following duration user literals are declared in the namespace , where both literals are inline namespaces .
Access to these operators can be gained with using namespace , using namespace , using namespace .

Complete Tips Secrets for Professionals .

Access to these operators can be gained with using namespace , using namespace , using namespace .

Those following user literals are declared in the namespace , where both literals are inline namespaces .
Access to these operators can be gained with using namespace , using namespace , using namespace .

Chapter : Enumeration Section : Iteration over an enum There is no to iterate over enumeration .

But there are several ways for enum with only consecutive values : enum  

Section : Scoped enums introduces what are known as scoped enums .
These are enumerations whose members must be qualiﬁed with .
Scoped enums are declared using the enum class syntax .
For example , to store the colors in rainbow : enum class rainbow RED , ORANGE , YELLOW , GREEN , BLUE , INDIGO , VIOLET .

So int is invalid .

Scoped enums also allow you to specify the underlying type , which is the type used to represent member .
By default is int .
In game , you may store the piece as enum class piece  char ,

An example can be found here : Blind fruit merchant example Section : Basic Enumeration Declaration Standard enumerations allow users to declare useful name for set of integers .
The names are collectively referred to as enumerators .
An enumeration and its associated enumerators are deﬁned as follows : enum myEnum , An enumeration is type , one which is distinct from other types .
In this case , the name of this type is myEnum .

Objects of this type are expected to assume the value of an enumerator within the enumeration .

The enumerators declared within the enumeration are constant values of the type of the enumeration .
Though the enumerators are declared within the type , the scope operator : is not needed to access the name .
So the name of the ﬁrst enumerator is .

The scope operator can be optionally used to access an enumerator within an enumeration .

Enumerators are assigned integer values starting from and increasing by for each enumerator in an enumeration .
So in the above case , has the value , while has the value .

Enumerators can also be assigned speciﬁc value by the user ; this value must be an integral constant expression .

Enumerators who ' values are not explicitly provided will have their value set to the value of the previous enumerator +

In fact useful feature of switch statements with enumerations is that if no default statement is included for the switch , and not values of the enum have been utilized , the compiler will issue warning .

Section : type erases down to few operations .
One of the things it requires is that the stored value be copyable .

This causes problems in few contexts , like lambdas storing unique ptrs .
If you are using the in context where copying matter , like thread pool where you dispatch tasks to threads , this requirement can add overhead .

In particular , is callable object that is .
You can store in , but that is pretty and obscure way to create callable class .

This demonstrates how you could write simple type .
omitted the copy constructor would involve adding clone method to as .

To make this , want to add in small buﬀer optimization , so it does not store every callable on the heap .

Adding SBO would require , some within the  with deleter that can be set to not return the memory to the , and in the .

Section : Erasing down to Regular type with manual vtable thrives on what is known as Regular type at least .

Regular type is type that can be constructed and and via copy or move , can be destroyed , and can be compared .
It can also be constructed from no arguments .
Finally , it also has Complete Tips Secrets for Professionals support for few other operations that are highly useful in various std algorithms and containers .

This is the root paper , but in would want to add support .

will use the manual vtable approach to type erasure here .

Such regular type can be used as key for or that accepts anything regular for key , like : would be basically map from anothing regular , to anything copyable .

Unlike any , my does no small object optimization nor does it support getting the original data back .

Getting the original type back hard .

Small object optimization requires that we store an aligned storage buﬀer within the , and carefully tweak the deleter of the to only destroy the object and not delete it .

would start at and teach it how to sometimes store the data in buﬀer , and then in the heap if no room in the buﬀer .

Section : Basic mechanism Type erasure is way to hide the type of an object from code using it , even though it is not derived from common base .
In doing so , it provides bridge between the worlds of static polymorphism ; at the place of use , the exact type must be known at compile time , but it need not be declared to conform to an interface at and dynamic polymorphism and virtual functions ; at the place of use , the exact type need not be known at compile time , but must be declared to conform to an interface at .

The following code shows the basic mechanism of type erasure .

Note that this is not template , but normal function that only needs to be declared in header ﬁle , and can be deﬁned in an implementation ﬁle templates , whose deﬁnition must be visible at the place of .

At the deﬁnition of the concrete type , nothing needs to be known about Printable , it just needs to conform to an interface , as with templates : struct 

Section : Erasing down to contiguous of Not all type erasure involves virtual inheritance , allocations , placement  even function pointers .

What makes type erasure type erasure is that it describes , and takes any type that supports that behavior and wraps it up .
All information that in that set of behaviors is "

An takes its incoming range container type and erases everything except the fact it is contiguous buﬀer of .

It can take , an initializer list based , something else you make up that supports it and .

In this case , the data we can extract from the thing we are erasing , together with our " state , means we have to allocate memory write custom functions .

Complete Tips Secrets for Professionals An improvement would be to use data and size in an context .

Section : Type erasing type erasure with This example uses and .

The syntax we end up with is : auto .

This creates function pointer type , and factory for said function pointers , given an : using typename ; class .

We want to be able to more than one method at time .
So we bundle them up in  and write helper wrapper to stick the into static storage on basis and maintain pointer to them .

We could specialize this for cases where the is small example , and use direct pointers stored in those cases for eﬃciency .

Now we start the .
use to make the declaration of bit easier .

Note that using can make things hairy , as we use the for lookup step .
This can be ﬁxed , but would make this example longer than it already is .
So always initialize an method from lambda , from parametarized on lambda .

; public : Any , SFINAE testing that one of the matches this  friend auto self , we don ' use the value of the  because each has unique and we check that one of the in the .

The term ' is general computing term meaning an area of memory from which portions can be allocated deallocated independently of the memory provided by the stack .

In the Standard refers to area as the Free Store which is considered more accurate term .

Areas of memory allocated from the Free Store may live longer than the original scope in which it was allocated .

Data too large to be stored on the stack may also be allocated from the Free Store .

Raw memory can be allocated deallocated by the delete keywords .

Array allocation is not compatible with allocation , mixing the two will lead to heap corruption .
Allocating an array also allocates memory to track the size of the array for later deletion in an way .

From on , the use of smart pointers is recommended for indicating ownership .

added : to the STL , changing the recommendation to favor : or : instead of using naked delete .

Section : Placement There are situations when we don ' want to rely upon Free Store for allocating memory we want to use custom memory allocations using .

For these situations we can use Placement New , where we can tell ' to allocate memory from preallocated memory location For example ; char ; In example , the memory pointed by is byte allocated to ' via integer variable .

The beneﬁt of kind of memory allocation is the fact that programmers control the allocation .
In the example above , since is allocated on stack , we don ' need to make an explicit call to .

Same behavior can be achieved for dynamic allocated memory also .
For example ; char .

In case however , we need to explicitly calldelete to release the memory .

Section : Set all bits ;

Section : Checking bit The value of the bit can be obtained by shifting the to the right times then performing bitwise AND on .

The naive way requires one iteration per bit : unsigned ; unsigned ; accumulates the total of set in .

The method was ﬁrst proposed by Peter Wegner CACM well known since it appears in Programming Language by Brian .
Kernighan Dennis .

This requires arithmetic operations , one of which is .

Section : Clearing bit bit can be cleared using the bitwise AND operator .

Section : Bit Manipulation Application : Small to Capital Letter One of several applications of bit manipulation is converting letter from small to capital or vice versa by choosing and proper bit operation .
For example , the letter has this binary representation while its capital counterpart has .
They diﬀer solely in the bit in parenthesis .
In this case , converting the letter from small to capital is basically setting the bit in parenthesis to one .
To do so , we do the following : convert small letter to captial letter .

The result is Chapter : Arrays Arrays are elements of the same type placed in adjoining memory locations .
The elements can be individually referenced by unique identiﬁer with an added index .

This allows you to declare multiple variable values of speciﬁc type and access them individually without needing to declare variable for each .

Section : Array initialization An array is just block of sequential memory locations for speciﬁc type of variable .
Arrays are allocated the same way as normal variables , but with square brackets appended to its name that contain the of elements that ﬁt into the array memory .

The following example of an array uses the typ int , the variable name  and the of elements that the array has space for : int .

In this case , deﬁning the length in .

Output : support special syntax for indexing .
Instead such an is viewed as an of arrays of arrays , and so , and the ordinary single index notation is used for each level .
In the example above refers to row of  where is index .
Then this row can be indexed in turn ,

Since provide support for dynamic size arrays , other than dynamic allocation , dynamic size matrix is often implemented as class .
Then the raw matrix indexing notation has some cost , either by exposing the implementation that .

program that declares an ; where is determined , can compile with certain compilers that support variadic length arrays as language extension .
But VLAs are not supported by standard .

This example shows how to manually allocate dynamic size via ,

As part of function down in call hierarchy this code not be exception safe , since an exception before the after the cause memory leak .
One way to address that issue is to automate the cleanup via .
But generally better way to address it is to just use : what is there for .

idiom for size , will accept pointer as argument and will then generally yield an incorrect result .

Up till as of this had no core language or standard library utility to obtain the size of an  but this can be implemented by passing the by reference to function template , as shown above .
Fine but important point : the template size parameter is , somewhat inconsistent with the signed function result type , in order to accommodate the compiler which sometimes insists on for template matching .

With and later one may instead use , which is specialized for arrays .

Section : Expanding dynamic size by using .

can even be expanded at run time , via .

Internally this is usually achieved by the doubling its buﬀer size , its capacity , when larger buﬀer is needed .

And more generally the sum of this sequence exceed .

Compared to the dynamic size raw example , this code does not require the user to supply the number of items up front .
Instead the is just expanded as necessary , for each value speciﬁed by the user .

Section : dynamic size matrix using : for storage .

Unfortunately as of no dynamic size matrix class in the standard library .
Matrix classes that support dynamic size are however available from number of party libraries , including the Boost Matrix library within the Boost .

If you want dependency on Boost or some other library , then one poor dynamic size matrix in is just like , where is .
It has the advantage of providing the same indexing notation as for ﬁxed size raw matrix , but bit ineﬃcient because it dynamic allocation for each row , and bit unsafe because possible to inadvertently resize row .

Output : above code is not industrial grade : designed to show the basic principles , and serve the needs of students learning .

For example , one may deﬁne overloads to simplify the indexing notation .

commonly used to allow functions or data structures to know of and modify memory without having to copy the memory referred to .
Pointers are usable with both primitive or types .

Pointers make use of the "  of "  and " arrow_operator operators .
The ' and ' operators are used to access the memory being pointed at , and the operator is used to get an address in memory .

Section : Pointer Operations There are two operators for pointers : operator : Returns the memory address of its operand .

: Returns the value of the variable located at the address speciﬁed by its operator .

The asterisk is used in declaring pointer for simple purpose of indicating that it is pointer .
confuse this with the dereference operator , which is used to obtain the value located at the speciﬁed address .
They are simply two diﬀerent things represented with the same sign .

Section : Pointer basics Note : in all the following , the existence of the constant nullptr is assumed .
For earlier versions , replace nullptr with NULL , the constant that used to play similar role .

Creating pointer variable pointer variable can be created using the speciﬁc syntax ,

When variable is of pointer , it just contains memory address .
The memory address is the location at which data of the underlying is stored .

The diﬀerence is clear when comparing the of variable with the of pointer to the same .

Moreover , they can take the value nullptr which represents null memory location .
pointer equal to nullptr contains an invalid memory location and hence it does not refer to valid data .

You can get the memory address of variable of given by preﬁxing the variable with the address of operator .
The value returned by is pointer to the underlying which contains the memory address of the variable is valid data as long as the variable does not go out of .

Accessing the content of pointer As taking an address requires , as well accessing the content requires the usage of the dereference operator , as preﬁx .
When pointer is dereferenced , it becomes variable of the underlying , reference to .
It can then be read and modiﬁed , if not const .

In such scenario , and correctly issue the warnings : warning : address of stack memory associated with local variable ' returned warning : address of local variable ' returned .

Section : Pointer Arithmetic Increment Decrement pointer can be incremented or decremented and .
Incrementing pointer advances the pointer value to the element in the array one element past the currently pointed to element .
Decrementing pointer moves it to the previous element in the array .

Pointer arithmetic is not permitted if the that the pointer points to is not complete .

If pointer to the end element is incremented , then the pointer points to one element past the end of the array .

Such pointer cannot be dereferenced , but it can be decremented .

Incrementing pointer to the element in the array , or decrementing pointer to the ﬁrst element in an array yields undeﬁned behavior .

pointer to object can be treated , for the purposes of pointer arithmetic , as though it were an array of .

Addition Subtraction Integer values can be added to pointers ; they act as incrementing , but by speciﬁc number rather than by .

Integer values can be subtracted from pointers as well , acting as pointer decrementing .
As with , the pointer must point to complete .

Pointer Diﬀerencing The diﬀerence between two pointers to the same can be computed .
The two pointers must be within the same array object ; otherwise undeﬁned behavior results .

Given two pointers and in the same array , if is the ith element in the array , and is the jth element , then shall be .
The of the result is , from .

Chapter : Explicit conversions An expression can be explicitly converted or cast to type using ,

also supports cast notation , and cast notation ,

Section : casting casting can be considered eﬀort ' casting and is named so as it is the only cast which could be used in .
The syntax for this cast is .

Whenever this cast is used , it uses one of the following casts .

Functional casting is very similar , though as few restrictions as the result of its syntax :
As result , only types without spaces can be cast to .

better to use new cast , because more readable and can be spotted easily anywhere inside source code and errors will be detected in , instead in .

As this cast can result in unintended  it is often considered dangerous .

Complete Tips Secrets for Professionals Section : Casting away constness pointer to const object can be converted to pointer to object using the keyword .
Here we use to call function that is not .
It only accepts argument even though it never writes through the .

Section : to derived conversion pointer to base class can be converted to pointer to derived class using .

If the source type is polymorphic , can be used to perform base to derived conversion .
It performs check and failure is recoverable instead of producing undeﬁned behaviour .
In the pointer case , null pointer is returned upon failure .
In the reference case , an exception is thrown upon failure of type class derived from .

The result is implementation deﬁned and typically yields the numeric address of the byte in memory that the pointer pointers to .

Typically , long or unsigned long is long enough to hold any pointer value , but this is not guaranteed by the standard .

If the types and exist , they are guaranteed to be long enough to hold hence any pointer to object .
However , they are not guaranteed to be long enough to hold function pointer .

Similarly , can be used to convert an integer type into pointer type .
Again the result , but pointer value guaranteed to be unchanged by round trip through an integer type .
The standard does not guarantee that the value zero converted to null pointer .

Section : Conversion by explicit constructor or explicit conversion function conversion that involves calling an explicit constructor or conversion function be done implicitly .
We can request that the conversion be done explicitly using .
The meaning the same as that of direct initialization , except that the result temporary .

This use of can occasionally be useful , such as in the following examples : When passing arguments to an ellipsis , the " argument type not statically known , so no implicit .

It can also convert between enumeration types .

The conversion from an unscoped enumeration type to an arithmetic type an implicit conversion ; it possible , but not necessary , to use .

When scoped enumeration type converted to an arithmetic type : If the enum ' value can be represented exactly in the destination type , the result that value .

Otherwise , if the destination type an integer type , the result unspeciﬁed .

Otherwise , if the destination type ﬂoating point type , the result the same as that of converting to the underlying type and then to the ﬂoating point type .

Note that value might be unequal to all enumerators .

Example : enum Scale .

The types pointed to must match .

If the operand null pointer to member value , the result also null pointer to member value .

Otherwise , the conversion only valid if the member pointed to by the operand actually exists in the destination class , or if the destination class base or derived class of the class containing the member pointed to by the operand .
If the conversion not valid , the behaviour .

Section : to In , cannot be implicitly converted to where an object type .
Instead , should be used to perform the conversion explicitly .
If the operand actually points to object , the result points to that object .

Even if the operand does not point to object , as long as the operand points to byte whose address properly .

The result of is  except that pointer .

Use of is considered dangerous because reading or writing through pointer or reference obtained using may trigger behaviour when the source and destination types are unrelated .

Chapter : RTTI : Type Information Section : Use as function , which helps you to cast down through an inheritance hierarchy Complete Tips Secrets for Professionals .

If you must do some work on some derived classes and  but received the base class  then write like this : class public : virtual ; class  public .

Section : The typeid keyword The typeid keyword is unary operator that yields type information about its operand if the type is polymorphic class type .
It returns an lvalue of type const .
are ignored .

Section : When to use which cast in Use for converting within an inheritance hierarchy .

Use for reinterpreting of bit patterns .
Use with extreme caution .

Use for casting away .
Avoid this unless you are stuck using API .

Chapter : Standard Library Algorithms Section : class Iterator bool Iterator first , Iterator last ; class Iterator , class Compare bool Iterator first , Iterator last , Compare cmpFun ; Eﬀects : Sift the data sequence of the range , into the next lexicographically higher permutation .
If cmpFun is provided , the permutation rule is customized .

Parameters : the beginning of the range to be permutated , inclusive last the end of the range to be permutated , exclusive Return Value : Returns true if such permutation exists .

Otherwise the range is swaped to the lexicographically smallest permutation and return false .

Complexity : is the distance from first to last .

Example :

Parameters : first , last the range to apply to .

Return value : and .

Complexity : Applies exactly last first times .

Section : Deﬁned in header InputIterator , class InputIterator , class  class Eﬀects : performs fold operation using function on range , starting with init as accumulator value .

Eﬀectively equivalent of :

In version is used in place of , so accumulate over container is equivalent of sum of container elements .

Parameters :  last the range to apply to .

Return value : Accumulated value of applications .

Complexity : where is the distance from to last , is complexity of function .

Example : Simple .

This function should not modify inputs Return Iterator to the minimum in the range Complexity Linear in one less than the number elements compared .

Parameters iterator pointing to the beginning the range iterator pointing to the end the range Return An iterator that points to the ﬁrst within the range the predicate function returns true for .
The iterator points to if is not found Example .

Output item not First item : First Item : First Item : Section : Using To Find The Median Other The algorithm takes three iterators : an iterator the beginning , nth position , and end .
Once the function returns , the nth will be the nth smallest .

For the sake this example , deﬁne the median sequence length as the that would be in Complete Tips Secrets for Professionals position .
For example , the median sequence length is the smallest  and so is the median sequence length .

Section : template InputIterator , class typename count  InputIterator  const ; Eﬀects Counts the number elements that are Parameters iterator pointing the beginning the range iterator pointing the end the range The occurrence this value in the range will be counted Return The number elements in the range that are .

Output There There There There Section : template InputIterator , class typename  InputIterator  UnaryPredicate ; Eﬀects Counts the number of elements in range for which speciﬁed predicate function true Parameters iterator pointing the beginning of the range iterator pointing the end of the range Return The number of elements within the speciﬁed range for which the predicate function returned true .

function pointer count odd number in the half of the , functor count numbers greater than ,

Output  even  odd  Chapter : Friend keyword classes encapsulate their functionality , hiding their implementation while providing clean , documented interface .
This allows redesign or change so long as the interface unchanged .

In more complex scenario , multiple classes that rely on each others ' implementation details may be required .

Friend classes and functions allow these peers access each others ' details , without compromising the encapsulation and information hiding of the documented interface .

Section : Friend function class or structure may declare any function it ' friend .
If function friend of class , it may access all .

Section : Friend method Methods may declared as friends as well as .

whole class may be declared as friend .
Friend class declaration means that any member of the friend may access private and protected members of the declaring class : class Accesser .

It ' main purpose is to avoid unnecessary temporaries and optimize loop calculations using single pass when performing operations on numerical .
Expression templates were initially devised in order to circumvent the ineﬃciencies of naïve operator overloading when implementing numerical Array or Matrix types .
An equivalent in the latest version of his book , Programming .

Before actually diving into expression templates , you should understand why you need them in the ﬁrst place .
To illustrate this , consider the very simple Matrix class given below : template , COL , class Matrix .

As illustrated above , being able to overload provides you with notation which mimics the natural mathematical notation for matrices .

To understand why , you have to consider what happens when you write an expression such as + + c .

In other words , the loop inside is executed twice , whereas it could have been easily performed in single pass .
This also results in temporaries being created , which further degrades performance .
In essence , by adding the ﬂexibility to use notation close to its mathematical counterpart , you have also made the class highly ineﬃcient .

For example , without operator overloading , you could implement far more eﬃcient summation using single pass : COL , COL , COL , const , COL ,

The previous example however has its own disadvantages because it creates far more convoluted interface for the class would have to consider methods such as , and so .

Instead let us take step back and see how we can adapt operator overloading to perform in more eﬃcient way The problem stems from the fact that the expression + + c is evaluated too " before you have had an opportunity to build the entire expression tree .
In other words , what you really want to achieve is to evaluate + + c in one pass and only once you actually need to assign the resulting expressing to .

This is the core idea behind expression templates : instead of having evaluate immediately the result of adding two instances , it will return an template " for future evaluation once the entire expression tree has been built .

For example , here is possible implementation for an expression template corresponding to the summation of types : template LHS , typename class MatrixSum .

As you can see , no longer returns an evaluation " of the result of adding instances would be another , but instead an expression template representing the addition operation .

The most important point to keep in mind is that the expression has not been evaluated yet .
It merely holds references to its operands .

In fact , nothing stops you from instantiating the expression template as follows :

As you can see , another beneﬁt of using an expression template , is that you have basically managed to evaluate the sum of and and assign it to in single pass .

Also , nothing stops you from combining multiple expression templates .
For example , + + c would result in the following expression template :

Finally , the last piece of the puzzle is to actually plug your expression template into the class .
This is essentially achieved by providing an implementation for , which takes the expression template as an argument and evaluates it in one pass , as you did " before : template , COL , class .

Chapter : Scopes Section : Global variables To declare single instance of variable which is accessible in diﬀerent source ﬁles , it is possible to make it in the global scope with keyword extern .
This keyword says the compiler that somewhere in the code there is deﬁnition for this variable , so it can be used everywhere and all will be done in one place of memory .

Complete Tips Secrets for Professionals Section : Simple block scope The scope of variable in block .

Complete Tips Secrets for Professionals .

For , this is done .

has mandatory ﬁrst parameter , the condition , that is bool constexpr .
It might have second parameter , the message , that is string literal .
From , the second parameter is optional ; before that , mandatory .

It is used when : In general , veriﬁcation at is required on some type on constexpr value template function needs to verify certain properties of type passed to it One wants to write test cases for : template metafunctions constexpr functions macro metaprogramming Note that does not participate in SFINAE : thus , when additional overloads specializations are possible , one should not use it instead of template metaprogramming techniques .
It might be used in template code when the expected overload specialization is already found , but further veriﬁcations are required .
In such cases , it might provide more concrete error than relying on SFINAE for this .

Chapter : precedence Section : Logical and operators : has precedence over , this means that parentheses are placed to evaluate what would be evaluated together .

Complete Tips Secrets for Professionals .

Section : Arithmetic operators Arithmetic operators in have the same precedence as they do in mathematics : Multiplication and division have left that they will be evaluated from left to and they have higher precedence than addition and subtraction , which also have left associativity .

We can also force the precedence of expression using parentheses .
Just the same way as you would do that in normal mathematics .

By adding these parentheses , no confusion exist about the intent of the writer .

Chapter : constexpr constexpr is keyword that can be used to mark value as constant expression , function as potentially usable in constant expressions , or an if statement as having only one of its branches selected to be compiled .

Section : constexpr variables variable declared constexpr is implicitly const and its value may be used as constant expression .

Comparison with constexpr is replacement for based expressions .
With constexpr the compiletime evaluated expression is replaced with the result .

However , the compiler would have to do more work .

For example :

But constexpr would correctly give .

constexpr produces compile time constant , which cannot be changed .
You may argue that const may also not be changed .

With most compilers the second statement will fail work with GCC , for .
The of any array , as you might know , has to be constant expression .
The second variable is assigned some value that is decided at runtime though you know it is , for the compiler it is not .

This means that const may or may not be true constant .
You cannot guarantee or enforce that particular const value is absolutely .
You may use but it has its own pitfalls .

The if constexpr statement can be used to conditionally compile code .
The condition must be constant expression .
The branch not selected is discarded .
discarded statement inside template is not instantiated .
For example : Complete Tips Secrets for Professionals .

For example , could not be used to conditionally compile code depending on the value of template parameter .
On the other hand , if constexpr cannot be used to discard syntactically invalid code , while can .

Section : constexpr functions function that is declared constexpr is implicitly inline and calls to such function potentially yield constant expressions .
For example , the following function , if called with constant expression arguments , yields constant expression too :

Similarly , of array will also not be constant expression , if function Sum is not constexpr .

Interesting thing about constexpr functions is that you may also use it like ordinary .

You need not to write two functions .

It also means that if you try to assign such call to variable , it compile : Complete Tips Secrets for Professionals .

The reason is simple : constexpr must only be assigned constant .
However , the above function call makes Sum is , but is declaring itself to be .

The constexpr function must also return constant .
Following will not compile :

Hence , the call to , will be constant expression resulting to .

Chapter : Date and time using header Section : Measuring time using The can be used to measure the time elapsed during some part of execution .

Section : Find number of days between two dates This example shows how to ﬁnd number of days between two dates .
date is speciﬁed by of month , and additionally .

Program calculates number of days in years since .

Section : Avoid qualifying nested type name .

The trailing return type is looked up the scope of the class , while leading return type is looked up the enclosing namespace scope and can therefore require " qualiﬁcation .

Section : Lambda expressions can only have trailing return type ; the leading return type syntax is not applicable to lambdas .

Chapter : Function Template Overloading Section : What is valid function template overloading .

function template can be overloaded under the rules for function overloading name , but diﬀerent parameter and addition to that , the overloading is valid if Complete Tips Secrets for Professionals The return type is diﬀerent , or The template parameter list is diﬀerent , except for the naming of parameters and the presence of default For normal function , comparing two parameter types is is easy for the compiler , since it has all informat .
But type within template may not be determined yet .
Therefore , the rule for when two parameter types equal is approximative here and says that the types and values need to match and the spelling of dependent types and expressions needs to be the same precisely , they need to conform to the , except that template parameters may be renamed .
However , if under such diﬀerent spellings , two values within the types deemed diﬀerent , but will always instantiate to the same values , the overloading is invalid , but no diagnostic is required from the compiler .

But the following is invalid , with no diagnostic required void + void Section : undeﬁned reference to ' This linker error happens , if the linker ﬁnd used symbol .
Most of the  this happens if used library is not linked against .

Variables Not compiling : Complete Tips Secrets for Professionals .

Most of the this error occurs if the needed header is not included .

Section : fatal error : such ﬁle or directory The compiler ﬁnd ﬁle source ﬁle uses .

For the details on these patterns , you can check out the design patterns documentation .

Section : Adapter Pattern Convert the interface of class into another interface clients expect .
Adapter lets classes work together that otherwise because of incompatible interfaces .
Adapter motivation is that we can reuse existing software if we can modify the interface .

Adapter pattern relies on object composition .

Client calls operation on Adapter object .

Adapter calls Adaptee to carry out the operation .

Complete Tips Secrets for Professionals .

The Adapter lets the LegacyRectangle responds to request on by inheriting BOTH classes .

The LegacyRectangle class does not have the same methods as  but the can take the method calls and turn around and invoke method on .

Adapter design pattern translates the interface for one class into compatible but diﬀerent interface .
So , this is similar to the proxy pattern in that wrapper .
But the interface for the adapter class and the original class may be diﬀerent .

As seen in the example above , this adapter pattern is useful to expose diﬀerent interface for an existing API to allow it to work with other code .
Also , by using adapter pattern , we can take heterogeneous interfaces , and transform them to provide consistent API .

Bridge pattern has structure similar to an object adapter , but Bridge has diﬀerent intent : It is meant to separate an interface from its implementation so that they can be varied easily and independently .
An adapter is meant to change the interface of an existing object .

Section : Observer pattern Observer intent is to deﬁne dependency between objects so that when one object changes state , all its dependents are notiﬁed and updated automatically .

The subject and observers deﬁne the relationship .
The observers are dependent on the subject such that when the state changes , the observers get notiﬁed .
Depending on the notiﬁcation , the observers may also be updated with new .

Here is the example from the book Patterns " by Gamma .

Complete Tips Secrets for Professionals .

Digital time is Analog time is Here are the summary of the .

Objects or AnalogClock use the interfaces or either to subscribe as observers or unsubscribe themselves from being observers ; 

Each subject can have many .

All observers need to implement the interface .
This interface just has one method , that .
In addition to the and methods , the concrete subject implements method that is used to update all the current observers whenever state changes .
But in this case , all of them are done in the parent class , void and void .

The Concrete object may also have methods for setting and getting its state .

Concrete observers can be any class that implements the interface .
Each observer subscribe with concrete subject to receive update ;

The two objects of Pattern are loosely coupled , they can interact but with little knowledge of each other .

Variation : Signal and Slots Signals and slots is language construct introduced in Qt , which makes it easy to implement the pattern while avoiding boilerplate code .
The concept is that controls known as can send signals containing event information which can be received by other controls using special functions known as slots .
The slot in Qt must be class member declared as such .
The system ﬁts well with the way Graphical User Interfaces are designed .
Similarly , the system can be used for asynchronous sockets , pipes , serial devices , event notiﬁcation or to associate timeout events with appropriate object instances and methods or functions .
No code need be written , because Meta Object Compiler automatically generates the needed infrastructure .

The language also supports similar construct although with diﬀerent terminology and syntax : events play the role of signals , and delegates are the slots .
Additionally , delegate can be local variable , much like function pointer , while slot in Qt must be class member declared as such .

Section : Factory Pattern Factory pattern decouples object creation and allows creation by name using common .

Section : Builder Pattern with Fluent API The Builder Pattern decouples the creation of the object from the object itself .
The main idea behind is that an object does not have to be responsible for its own creation .
The correct and valid assembly of complex object may be complicated task in itself , so this task can be delegated to another class .

Inspired by the Email Builder in , decided to make version here .
An Email object is not necessarily very complex object , but it can demonstrate the pattern .

For older versions of , one may just ignore the operation and remove the from the conversion this will create temporary .

The builder ﬁnishes its work when it releases the built email by the .
In this example , the builder is temporary object and returns the email before being destroyed .
You could also use an explicit operation like instead of the conversion .

Pass the builder around great feature the Builder Pattern provides is the ability to use several actors to build an object together .
This is done by passing the builder to the other actors that will each one give some more information to the built object .

This is specially powerful when you are building some sort of query , adding ﬁlters and other speciﬁcations .

Design variant  Mutable object You can change the design of this pattern to ﬁt your needs .
give one variant .

In the given example the object is immutable , properties be modiﬁed because there is no access to them .
This was desired feature .
If you need to modify the object after its creation you have to provide some setters to it .
Since those setters would be duplicated in the builder , you may consider to do it all in one class builder class needed .
Nevertheless , would consider the need to make the built object mutable in the ﬁrst place .

Complete Tips Secrets for Professionals Chapter : Optimization in Section : Introduction to performance and are well known as languages largely due to the heavy amount of code customization , allowing user to specify performance by choice of structure .

When optimizing it is important to benchmark relevant code and completely understand how the code will be used .

Common optimization mistakes  Premature optimization : Complex code may perform worse after optimization , wasting time and eﬀort .

First priority should be to write correct and maintainable code , rather than optimized code .

Optimization for the wrong use case : Adding overhead for the might not be worth the slowdown for the other : Compilers do this very eﬃciently and can even hurt the compilers ability to further optimize the code Typical optimization goals are : To do less work To use more eﬃcient To make better use of hardware Optimized code can have negative side eﬀects , including : Higher memory usage Complex code diﬃcult to read or maintain Compromised API and code design Section : Empty Base Class Optimization An object cannot occupy less than byte , as then the members of an array of this type would have the same address .

also true that derived class cannot be smaller than any of its base classes .
However , when the base class is empty , its size is not necessarily added to the derived class : class Base ; class  public Base .

If empty base class optimization is performed no padding is , then , that is , no additional allocation is done for the empty base .
This is possible with multiple base classes as well , multiple bases cannot have the same type , so no issues arise from .

Note that this can only be performed if the ﬁrst member of diﬀers in type from any of the base classes .

This includes any direct or indirect common bases .
If the same type as one of the bases common , at least allocating single byte is required to ensure that no two distinct objects of the same type have the same address .

Complete Tips Secrets for Professionals Section : Optimizing by executing less code The most straightforward approach to optimizing is by executing less code .
This approach usually gives ﬁxed without changing the time complexity of the code .

Even though this approach gives you clear speedup , this will only give noticable improvements when the code is called lot .

Removing useless code .

Doing code only once , lookup ; Slow .

Complete Tips Secrets for Professionals .

Section : Using containers Optimizing by using the right data structures at the right time can change the of the code .

By using container which uses diﬀerent implementation for storing its elements container instead of , we can transform our implementation to complexity .
As side eﬀect , we will call the comparison operator for less , as it only has to be called when the inserted string should end up in the same bucket .

Small object optimization is technique which is used within low level data structures , for instance the Complete Tips Secrets for Professionals referred to as String .
meant to use stack space as buﬀer instead of some allocated memory in case the content is small enough to ﬁt within the reserved space .

By adding extra memory overhead and extra calculations , it tries to prevent an expensive heap allocation .
The beneﬁts of this technique are dependent on the usage and can even hurt performance if incorrectly used .

Example very naive way of implementing string with this optimization would the following :

As you can see in the code above , some extra complexity has been added in order to prevent some new delete .

On top of this , the class has larger memory footprint which might not be used except in couple of cases .

Often it is tried to encode the bool  within the pointer with bit manipulation to reduce the size of single instance bit : Could reduce size by .
An optimization which is only possible when its known what the alignment rules of the platform is .

As this optimization adds lot of complexity , it is not recommended to use this optimization on every single class .
It will often be encountered in commonly used , data structures .
In common standard library implementations one can ﬁnd usages in .

As this optimization only prevents memory allocations when the stored data is smaller than the buﬀer , it will only give beneﬁts if the class is often used with small data .

ﬁnal drawback of this optimization is that extra eﬀort is required when moving the buﬀer , making the moveoperation more expensive than when the buﬀer would not be used .
This is especially true when the buﬀer contains type .

Chapter : Compiling Building Programs written in need to be compiled before they can be run .
There is large variety of compilers available depending on your operating system .

Section : Compiling with GCC Assuming single source ﬁle named , the command to compile link an executable is as follows without optimization is useful for initial development debugging , although is oﬃcially recommended for newer GCC .

Alternatively , use optimization ﬂags from the groups more experimental directly .
The following example builds with optimization , plus one ﬂag from the optimization level : app To produce optimized executable use in production on the machine with the same , use : app Either of the above will produce binary ﬁle that can be run with on Windows on Linux , Mac OS , etc .

The ﬂag can also be skipped .
In this case , GCC will create default output executable on Windows on systems .
To compile ﬁle without linking it , use the option : Complete Tips Secrets for Professionals .

Of particular note are with an emphasis on debugging experience recommended for the standard optimizations , including ones disregarding strict standards .

The ﬂag enables warnings for many common errors should always be used .
To improve code quality it is often encouraged also to use other warning ﬂags which are not automatically enabled by Wextra .

If the code expects speciﬁc standard , specify which standard to use by including the ﬂag .
Supported values correspond to the year of ﬁnalization for each version of the ISO standard .
As of GCC , valid values for the ﬂag are ,
Values separated by forward slash are equivalent .

To compile with all extensions enabled , the value may be used , where XX is any of the years used by the values listed above .

The default standard will be used if none is speciﬁed .
For versions of GCC prior to , the default is ; in GCC greater , the default is .

Note that due to bugs in GCC , the ﬂag must be present at compilation linking for GCC to support the standard threading functionality introduced with , such as .
Omitting it when using threading functions may result in no warnings but invalid results on some platforms .

Linking with libraries : Use the option to pass the library name : If the library is not in the standard library path , add the path with option : Multiple libraries can be linked together : If one library depends on another , put the dependent library before the independent library : Or let the linker determine the ordering itself via : this has signiﬁcant performance : Complete Tips Secrets for Professionals Section : Compiling with Visual Studio Hello World .
Download install Visual Studio Community .
Open Visual Studio Community .
Click File arrow_operator New arrow_operator Project .
Click Templates arrow_operator Visual arrow_operator Console Application then name the project MyFirstProgram .

Click Ok .
Click Next in the following window .

Complete Tips Secrets for Professionals .

You should get the following console output  Section : Online Compilers Various websites provide online access to compilers .
Online feature set vary signiﬁcantly from site to site , but usually they allow to do the following : Paste your code into web form in the browser .

Select some compiler options and compile the code .

Collect compiler program output .

Complete Tips Secrets for Professionals Online compiler website behavior is usually quite restrictive as they allow anyone to run compilers and execute arbitrary code on their server side , whereas ordinarily remote arbitrary code execution is considered as vulnerability .

Online compilers may be useful for the following purposes : Run small code snippet from machine which lacks compiler , tablets ,

Ensure that code compiles successfully with diﬀerent compilers and runs the same way regardless the compiler it was compiled with .

Learn or teach basics of .

Learn modern features and in near when compiler is not available on local machine .

Spot bug in your compiler by comparison with large set of other compilers .
Check if compiler bug was ﬁxed in future versions , which are unavailable on your machine .

Solve online judge problems .

What online compilers should not be used for : Develop applications using .
Usually online compilers do not allow to link with libraries or download build artifacts .

Perform intensive computations .
computing resources are limited , so any program will be killed after few seconds of execution .
The permitted execution time is usually enough for testing and learning .

Attack compiler server itself or any hosts on the net .

Examples : Disclaimer : documentation are not aﬃliated with any resources listed below .
Websites are listed alphabetically .

Editing code after compiling with source code warning or error does not work so well .

Provides both GCC and Clang compilers for use .

Does not allow you to edit compiler command line , but some options are available via GUI controls .

Very useful when you need to inspect what your code compiles into by diﬀerent compilers .
GCC , Clang , MSVC , Intel compiler , ELLCC , and Zapcc are present , with one or more of these compilers available for the ARM , Atmel AVR , MIPS , PowerPC , and architecutres .
Compiler command line arguments may be edited .

Provides both GCC and Clang for use , but allow you to edit the compiler command line .

Complete Tips Secrets for Professionals For programmers coming from GCC or Clang to Visual Studio , or programmers more comfortable with the command line in general , you can use the Visual compiler from the command line as well as the IDE .

If you desire to compile your code from the command line in Visual Studio , you ﬁrst need to set up the command line environment .
This can be done either by opening the Visual Studio Command Command Native Tools Command Native Tools Command Prompt or similar provided by your version of Visual , or at the command prompt , by navigating to the VC subdirectory of the install directory Files Visual Studio , where is the version number as for , or for and running the VCVARSALL batch with parameter speciﬁed here .

Note that unlike GCC , Visual Studio provide for the linker via the compiler , but instead provides the linker as separate program , which the compiler calls as it exits .
Any linking options speciﬁed to cl will be translated into options for link , and any ﬁles not processed by cl will be passed directly to link .
As this is mainly simple guide to compiling with the Visual Studio command line , arguments for link will not be described at this time ; if you need list , see here .

Note that arguments to cl are , while arguments to link are not .

For anyone unfamiliar with this variable , it expands to the current working directory .
From the command line , it will be the directory you were in when you ran cl , and is speciﬁed in the command prompt by default your command prompt is , for example , then is Assuming single source named in the current folder , the command to compile and link an unoptimised executable for initial development and is either of the : cl .

Performs linking with .

Generates executable .

Performs linking with " and .

Generates executable .

You can also use wildcards , as one would .

Performs linking with , and every additional object file generated .

All object files will be in the current folder .

Generates executable .

To rename or relocate the executable , use one of the following : cl name Complete Tips Secrets for Professionals .

Both and pass their parameter call it to link as , appending the appropriate extension or to " as necessary .
While both and are to my knowledge identical in functionality , the latter is preferred for Visual Studio .

Note that while the space between and the speciﬁed folder name is optional , there cannot be space between and the speciﬁed folder name .

Similarly , to produce an optimised executable use in , use : cl Optimise for executable size .

Passes the option " Code to LINK , telling it to call CL during the linking phase to perform additional optimisations .
If linking is not performed at this time , the generated object files should be linked with .

Can be used with other CL optimisation options .

Finally , to produce optimized executable use in production on the machine with the speciﬁed , choose the appropriate command prompt or VCVARSALL parameter for the target platform .

This tells cl to exit without calling link , and produces an object ﬁle , which can later be linked with other ﬁles to .

Performs linking with " and .

Generates executable .

LINK will output DLL , in addition to an LIB and EXP file for use when linking .

To use the DLL in other programs , pass its associated LIB to CL or LINK when compiling those programs .

For anyone more familiar with systems , cl , link , and other Visual Studio command line tools can accept parameters speciﬁed with hyphen as instead of slash as .
Additionally , Windows recognises either slash or backslash as valid path separator , so paths can be used as well .

This makes it easy to convert simple compiler command lines from or to cl , or vice versa , with minimal changes .

Complete Tips Secrets for Professionals app cl app Of course , when porting command lines that use more complex or options , you need to look up equivalent commands in the applicable compiler documentations on resource sites , but this makes it easier to get things started with minimal time spent learning about new .

In case you need speciﬁc language for your code , speciﬁc release of MSVC was required .
From Visual Update on it is possible to choose the version of the standard to compile with via the ﬂag .
Possible values are and will follow .

Note : In older versions of this compiler , speciﬁc feature ﬂags were available however this was mostly used for previews of new .

Section : Compiling with Clang As the Clang is designed for being compatible with GCC , most programs that can be compiled via GCC will compile when you swap by in the build scripts .
If no is given , will be used .

Windows users who are used to MSVC can swap with .
By default , clang tries to be compatible with the highest version of MSVC that has been installed .

In the case of compiling with visual studio , can be used by changing the Platform toolset in the project properties .

In both cases , clang is only compatible via its , though it also tries to generate binary compatible object ﬁles .
Users of should note that the compatibility with MSVC is not complete yet .

To use clang or , one could use the default installation on certain Linux distributions or those bundled with IDEs XCode on .
For other versions of this compiler or on platforms which have this installed , this can be download from the oﬃcial download page .

If using CMake to build your code you can usually switch the compiler by setting the and environment variables like this : mkdir build cd build cmake .

See also introduction to Cmake .

Section : The compilation process When you develop program , the next step is to compile the program before running it .
The compilation is the process which converts the program written in human readable language like , etc into machine code , directly understood by the Central Processing Unit .
For example , if you have source code ﬁle named and you execute the compile command , prog There are main stages involved in creating an executable ﬁle from the source ﬁle .

Complete Tips Secrets for Professionals .
The expanded source code ﬁle produced by the preprocessor is compiled into the assembly language for the platform .

The assembler code generated by the compiler is assembled into the object code for the platform .

The object code ﬁle produced by the assembler is linked together with the object code ﬁles for any library functions used to produce either library or an executable ﬁle .

Preprocessing The preprocessor handles the preprocessor directives , like and .
It is agnostic of the syntax of , which is why it must be used with care .

It works on one source ﬁle at time by replacing directives with the content of the respective ﬁles is usually just , doing replacement of macros , and selecting diﬀerent portions of text depending of , and directives .

The preprocessor works on stream of preprocessing tokens .
Macro substitution is deﬁned as replacing tokens with other tokens operator enables merging two tokens when it make .

After all this , the preprocessor produces single output that is stream of tokens resulting from the transformations described above .
It also adds some special markers that tell the compiler where each line came from so that it can use those to produce sensible error messages .

Some errors can be produced at this stage with clever use of the and directives .

By using below compiler ﬂag , we can stop the process at preprocessing stage .

The compiler parses the pure source code without any preprocessor and converts it into assembly code .
Then invokes underlying in that assembles that code into machine code producing actual binary ﬁle in some , COFF ,
This object ﬁle contains the compiled code binary of the symbols deﬁned in the input .
Symbols in object ﬁles are referred to by name .

Object ﬁles can refer to symbols that are not deﬁned .
This is the case when you use declaration , and provide deﬁnition for it .
The compiler mind this , and will happily produce the object ﬁle as long as the source code is .

Compilers usually let you stop compilation at this point .
This is very useful because with it you can compile each source code ﬁle separately .
The advantage this provides is that you need to recompile everything if you only change single ﬁle .

The produced object ﬁles can be put in special archives called static libraries , for easier reusing later on .

at this stage that " compiler errors , like syntax errors or failed overload resolution errors , are reported .

In order to stop the process after the compile step , we can use the option : Complete Tips Secrets for Professionals Assembling The assembler creates object code .
On UNIX system you may see ﬁles with suﬃx on to indicate object code ﬁles .
In this phase the assembler converts those object ﬁles from assembly code into machine level instructions and the ﬁle created is relocatable object code .
Hence , the compilation phase generates the relocatable object program and this program can be used in diﬀerent places without having to compile again .

To stop the process after the assembly step , you can use the option : Linking The linker is what produces the ﬁnal compilation output from the object ﬁles the assembler produced .
This output can be either shared library while the name is similar , they have much in common with static libraries mentioned or an executable .

It links all the object ﬁles by replacing the references to undeﬁned symbols with the correct addresses .
Each of these symbols can be deﬁned in other object ﬁles or in libraries .
If they are deﬁned in libraries other than the standard library , you need to tell the linker about them .

At this stage the most common errors are missing deﬁnitions or duplicate deﬁnitions .
The former means that either the deﬁnitions exist .
The latter is obvious : the same symbol was deﬁned in two diﬀerent object ﬁles or libraries .

Download and install here .
If on Windows , be careful to select ﬁle for which the name contains mingw , the other ﬁles install any compiler .

Open and click on new : Complete Tips Secrets for Professionals .

Select application " and click :
Click , select , click , select name for your and choose folder to save it in , click " and then click .

Now you can edit and compile your code .
default code that prints " in the console is already there .
To compile run your program , press one of the three buttons in the toolbar : Complete Tips Secrets for Professionals To compile without running , press run , press  to run without compiling again , press .

Compiling and running the default " code gives the following result : Chapter : Type Traits Section : Type Properties Complete Tips Secrets for Professionals Type properties compare the modiﬁers that can be placed upon diﬀerent variables .
The usefulness of these type traits is not always obvious .

Note : The example below would only oﬀer an improvement on compiler .
It is simple proof of concept , rather than complex example .

Fast divide by four .

Is signed : This will evaluate as true for all signed types .

Is Unsigned : Will evaluate as true for all unsigned types .

The header contains set of classes and helpers to transform and check properties of types at .

These traits are typically used in templates to check for user errors , support generic programming , and allow for optimizations .

Most type traits are used to check if type fulﬁls some criteria .
These have the following form : Complete Tips Secrets for Professionals .

This gives the trait the following members : Constants static constexpr bool true if fulﬁls the criteria foo , false otherwise Functions operator bool Returns .

Types Name Deﬁnition bool type The trait can then be used in constructs such as or .
An example with .

For example , is .

Section : Type relations with , Complete Tips Secrets for Professionals The , type relation is used to compare two types .
It will evaluate as boolean , true if the types are the same and false if otherwise .

This is actually demonstrated in the ﬁrst example when comparing however this is not entirely clear .

When combined with static assert the : can be valuable tool in enforcing proper usage of templated classes and functions .

function that only allows input from an and choice of two structs .

There are number of diﬀerent type traits that compare more general types .

Is Pointer : Evaluates as true for all pointers .

Chapter : Section : Compare operators Parameters of these operators are lhs and rhs tests if both elements on lhs and rhs are equal .
The return is true if both AND lhs .

The return is true if either .

Pair allows us to treat two objects as one object .
Pairs can be easily constructed with the help of template function .

However , keywords lose their special meaning inside attributes .

Section : asm The asm keyword takes single operand , which must be string literal .
It has an meaning , but is typically passed to the assembler , with the output being incorporated into the translation unit .

The asm statement is deﬁnition , not an expression , so it may appear either at block scope or namespace scope global .
However , since inline assembly cannot be constrained by the rules of the language , asm may not appear inside constexpr function .

Section : keywords void .
When used as function return type , the void keyword speciﬁes that the function does not return .

When used for parameter list , void speciﬁes that the function takes no parameters .

The virtual keyword declares virtual function or virtual base class .

Can appear before or after the virtual keyword .

The this pointer is pointer accessible only within the nonstatic member functions of class , struct , or union type .
It points to the object for which the member function is called .
Static member functions do not have this pointer .

Instead , when nonstatic member function is called for an object , the address of the object is passed by the compiler as hidden argument to the function .
For example , the following function call : can be interpreted this .

To implement exception handling in , you use try , throw , and catch expressions .

First , use try block to enclose one or more statements that might throw an exception .

throw expression signals that an exceptional , an occurred in try block .
You can use an object of any type as the operand of throw expression .
Typically , this object is used to communicate information about the error .
In most cases , we recommend that you use the class or one of the derived classes that are deﬁned in the standard library .
If one of those is not appropriate , we recommend that you derive your own exception class from .

To handle exceptions that may be thrown , implement one or more catch blocks immediately following try block .
Each catch block speciﬁes the type of exception it can handle .

In some circumstances , it is more convenient to grant access to functions that are not members of class or to all members in separate class .
Only the class implementer can declare who its friends are .
function or class cannot declare itself as friend of any class .
In class deﬁnition , use the friend keyword and the of function or other class to grant it access to the private and protected members of your class .
In deﬁnition , type parameter can be declared as friend .

If you declare friend function that was not previously declared , that function is exported to the enclosing nonclass scope .

friend function is function that is not member of class but has access to the private and protected functions are not considered class members ; they are normal external functions that are given special access privileges .

friend function is declared by the class that is granting access .
The friend declaration can be placed anywhere in the class declaration .
It is not aﬀected by the access control keywords .

Section : typename .
When followed by qualiﬁed  typename speciﬁes that it is the of type .
This is often required in templates , in particular , when the nested speciﬁer is dependent type other than the current instantiation .
In this example , depends on the template parameter , so in order to the nested type type , we need to preﬁx the entire qualiﬁed with typename .
For more deatils , see Where and why do have to put the " and " keywords .

Introduces type parameter in the declaration of template .
In this context , it is interchangeable with class .

When applied to constructor , prevents that constructor from being used to perform implicit conversions .

If the operand is an expression , it is not evaluated .
The size is constant expression of type .

If the operand is type , it must be parenthesized .

It is illegal to apply sizeof to function type .

It illegal to apply sizeof to an incomplete type , including void .

If sizeof applied to reference type or , it equivalent to .

When sizeof applied to class type , it yields the number of bytes in complete object of that type , including any padding bytes in the middle or at the end .
Therefore , sizeof expression can never have value of .
See layout of object types for more details .

The char , signed char , and unsigned char types have size of .
Conversely , byte deﬁned to be the amount of memory required to store char object .
It does not necessarily mean bits , as some systems have char objects longer than bits .

If expr an expression , equivalent to where the type of expr .

unary operator that determines whether the evaluation of its operand can propagate an exception .
Note that the bodies of called functions are not examined , so can yield false negatives .

When declaring function , speciﬁes whether or not the function can propagate an exception .
Alone , it declares that the function cannot propagate an exception .
With parenthesized argument , it declares that the function can or cannot propagate an exception depending on the truth value of the argument .

Complete Tips Secrets for Professionals void void void void void void .

In this example , we have declared that , and cannot propagate exceptions .
When the speciﬁer omitted , it equivalent to , so we have implicitly declared that and may propagate exceptions , even though exceptions cannot actually be thrown during the execution of .

Whether or not function part of the type : that  in the example above , and have diﬀerent types from , and .
Therefore , also signiﬁcant in function pointers , template arguments , and so on .

Section : ODR violation via overload resolution Even identical tokens for inline functions , ODR can be violated if lookup of names refer to the same entity .

Section : Multiply deﬁned function The most important consequence of the One Deﬁnition Rule that functions external linkage should only be deﬁned once in program , although they can be declared multiple times .
Therefore , such functions should not be deﬁned in headers , since header can be included multiple times from diﬀerent translation units .

In this program , the function deﬁned in the header , which included twice : once from and once from .
Each translation unit therefore contains its own deﬁnition of .
Note that the guards in do not prevent this from happening , since and both separately .
The most likely result of trying to build this program error identifying as having been multiply deﬁned .

To avoid such errors , one should declare functions in headers and deﬁne them in the corresponding ﬁles , some exceptions other .

Section : Inline functions function declared inline may be deﬁned in multiple translation units , provided that all deﬁnitions are identical .
It also must be deﬁned in every translation unit in which it used .
Therefore , inline functions should be deﬁned in headers and there no need to mention them in the implementation ﬁle .

The program will behave as though there single deﬁnition of the function .

Complete Tips Secrets for Professionals .

Both the and translation units contain deﬁnitions of  but this program since inline .

function deﬁned within class deﬁnition may be member function or friend implicitly inline .

Therefore , if class deﬁned in header , member functions of the class may be deﬁned within the class deﬁnition , even though the deﬁnitions may be included in multiple translation .

Chapter : Unspeciﬁed behavior Section : Value of an enum If scoped enum is converted to an integral type that is too small to hold its value , the resulting value is unspeciﬁed .

Example : enum ,

Section : Evaluation order of function arguments If function has multiple arguments , it is unspeciﬁed what order they are evaluated in .
The following code could .

In , the order of evaluation of function arguments remains unspeciﬁed .

However , each function argument is completely evaluated , and the calling object is guaranteed evaluated before .

Section : Result of some conversions The result of from one function pointer type to another , or one function reference type to another , is unspeciﬁed .
Example : int ; auto ; has unspecified value .

Section : Space occupied by reference reference is not an object , and unlike an object , it is not guaranteed to occupy some contiguous bytes of memory .

The standard leaves it unspeciﬁed whether reference requires any storage at all .
number of features of the language conspire to make it impossible to portably examine any storage the reference might occupy : If sizeof is applied to reference , it returns the size of the referenced type , thereby giving no information about whether the reference occupies any storage .

Arrays of references are illegal , so it is not possible to examine the addresses of two consecutive elements of hypothetical reference of arrays in order to determine the size of reference .

If the address of reference is taken , the result is the address of the referent , so we cannot get pointer to the reference itself .

If class has reference member , attempting to extract the address of that member using offsetof yields undeﬁned behavior since such class is not class .

If class has reference member , the class is no longer standard layout , so attempts to access any data used to store the reference results in undeﬁned or unspeciﬁed behavior .

In practice , in some cases reference variable may be implemented similarly to pointer variable and hence Complete Tips Secrets for Professionals .

Section : state of most standard library classes All standard library containers are left in valid but unspeciﬁed state after being moved from .

Section : Result of some pointer comparisons If two pointers are compared , the result is unspeciﬁed in the following cases : int  int  const bool int ; const bool const bool .

If value is converted to pointer to object type , but is not properly aligned for , the resulting pointer value is unspeciﬁed .
Example : Complete Tips Secrets for Professionals .

Section : Order of initialization of globals across TU Whereas inside Translation Unit , order of initialization of global variables is speciﬁed , order of initialization across Translation Units is unspeciﬁed .

So program with following ﬁles .

Chapter : Floating Point Arithmetic Section : Floating Point Numbers are Weird .

Two things happen that make this .

The program as written never concludes .

If we rewrite the loop logic to check instead , the loop terminates , but the ends up being something diﬀerent from .
On machines , it will often sum up to about instead .

The reason that this happens is that Floating Point Numbers represent Approximations of their assigned values .

The classical example is the following .

Though what we the programmer see is three numbers written in , what the compiler the underlying see are binary numbers .
Because , and require perfect division by is quite easy in system , but impossible in numbers have to be stored in imprecise formats , similar to how the number has to be stored in the imprecise form .

Chapter : Argument Dependent Name Lookup Section : What functions are found Functions are found by ﬁrst collecting set of classes " and namespaces " that one ore more of the following , depending on the argument type .
First , let us show the rules for classes , enumeration and class template specialization names .

If is nested class , member enumeration , then the surrounding class of it .

If is an enumeration may also be class , the innermost namespace of it .

If is class may also be , all its base classes and the class itself .
The innermost namespace of all associated classes .

If is is also , the classes and namespaces associated with the template type arguments , the namespace of any template template argument and the surrounding class of any template template argument , if template argument is member template .

Now there are few rules for builtin types as well If is pointer to array of , the classes and namespaces associated with .
Example : void ; includes the namespaces and classes associated with next .

If is function type , the classes and namespaces associated with parameter and return types .
Example : would includes the namespaces and classes associated with .

If is pointer to member , the classes and namespaces associated with the member type apply to both Complete Tips Secrets for Professionals .

All functions and templates within all associated namespaces are found by argument dependent lookup .
In addition , friend functions declared in associated classes are found , which are normally not visible .
Using directives are ignored , however .

All of the following example calls are valid , without qualifying by the namespace name in the call .

Chapter : Section : Create pointers This is an advanced example .

You can use variant for light weight type erasure .

Now if we have types each with method : struct void os ; struct .

Section : Basic : use This creates tagged that can store either an int or string .

If we are certain we know what it is , we can it : auto .

Variants guarantee no dynamic memory allocation than which is allocated by their contained .
Only one of the types in is stored there , and in rare cases exceptions while assigning and no safe way to back the can become empty .

Variants let you store multiple value types in one variable safely and eﬃciently .
They are basically smart , unions .

Section : Constructing This does not cover allocators .

Whenever case is ended in switch , the code of the next case will executed .
This last one can be prevented by using the statement .
As this fallthrough behavior can introduce bugs when not intended , several compilers and static analyzers give warning on this .

Complete Tips Secrets for Professionals From on , standard attribute was introduced to indicate that the warning is not needed when the code is meant to fall through .
Compilers can safely give warnings when case is ended without break or and has at least one statement .

Section : The attribute can be used to indicate that the return value of function be ignored when you do function call .
If the return value is ignored , the compiler should give warning on this .
The attribute can be added to : function deﬁnition Adding the attribute to has the same behaviour as adding the attribute to every single function which returns this .

Section : and introduced way of deprecating functions via attributes .

This if often linked to preprocessor conditions where this might be used or might not be used .
As compilers can give warnings on unused variables , this is way of suppressing them by indicating intent .

typical example of variables which are needed in debug builds while unneeded in production are return values indicating success .
In the debug builds , the condition should be asserted , though in production these asserts have been removed .

If these functions used during compilation , compiler might give warning on them .
Ideally you would like to guard them with the same preprocessor tags as the caller , though as this might become complex the attribute is more maintainable alternative .

It can be used for function to indicate that the function does not return to the caller by either executing return statement , or by reaching the end if body is important to note that this does not apply to void functions , since they do return to the caller , they just do not return any .
Such function may end by calling or , or by throwing an exception .
It is also worth noting that such function can return by executing longjmp .

For instance , the function below will always either throw an exception or call , so it is good candidate for : void .

The following library functions have this attribute : Chapter : Proﬁling Section : Proﬁling with gcc and gprof The GNU gprof proﬁler , gprof , allows you to proﬁle your code .
To use it , you need to perform the following steps :
Build the application with settings for generating proﬁling information .
Generate proﬁling information by running the built application .
View the generated proﬁling information with gprof In order to build the application with settings for generating proﬁling information , we add the ﬂag .
So , for example , we could use gcc app or gcc app and so forth .

Once the application , say app , is built , execute it as usual : This should produce ﬁle called .

To see the proﬁling results , now run gprof app that we provide both the application as well as the generated .

Of course , you can also pipe or redirect : Complete Tips Secrets for Professionals .

The result of the last command should be table , whose rows are the functions , and whose columns indicate the of calls , total time spent , self time spent is , time spent in the function excluding calls to .

Section : Generating callgraph diagrams with For more complex applications , ﬂat execution proﬁles may be diﬃcult to follow .
This is why many proﬁling tools also generate some form of annotated callgraph information .

You can use it by running your proﬁler for : compile with profiling flags run to generate profiling data translate profiling data to text , create image gprof dot Section : Proﬁling CPU Usage with gcc and Google Perf Tools Google Perf Tools also provides CPU proﬁler , with slightly friendlier interface .

Install Google Perf Tools .
Compile your code as usual .
Add the libprofiler proﬁler library to your library load path at runtime Complete Tips Secrets for Professionals .
Use pprof to generate ﬂat execution proﬁle , or callgraph diagram For example : compile code main run with profiler where : indicates the output ﬁle for proﬁling data indicates the proﬁler sampling frequency ; Use pprof to the proﬁling data .

You can generate ﬂat call proﬁle as text : pprof PROFILE : pprof Using local file .

Using local file .

Total : samples longRunningFoo rand rand main rand Complete Tips Secrets for Professionals .
Covariant result version of the base example , static type checking .

Covariant result version of the base example , static type checking .

Section : Member Functions class or struct can have member functions as well as member variables .
These functions have syntax mostly similar to standalone functions , and can be deﬁned either inside or outside the class deﬁnition ; if deﬁned outside the class deﬁnition , the name is preﬁxed with the class ' name and the scope operator .

These functions are allowed to access member variables other member functions , regardless of either the variable or access modiﬁers .
They can also be written , accessing member variables calling member functions declared before them , as the entire class deﬁnition must be parsed before the compiler can begin to compile class .

Inside the class , can be freely accessed by any member function ; outside the class , access to it is regulated by member functions , using to read it and to modify it .

This prevents unintentional modiﬁcations to the variable , as separate functions are used to read and write it .

Complete Tips Secrets for Professionals .

This is due to name resolution rules : During name lookup , once the correct name is found , we stop looking , even if we clearly found the correct version of the entity with that name as with ; due to this , overloading the function in the derived class prevents name lookup from discovering the overloads in the base class .
To avoid this , can be used to " names from the base class into the derived class , so that they will be available during name lookup .

Output : Output : Output : Output : If derived class imports names with , but also declares functions with the same signature as .

Section : Virtual Member Functions Member functions can also be declared virtual .
In this case , if called on pointer or reference to an instance , they will not be accessed directly ; rather , they will look up the function in the virtual function table list of for virtual functions , more commonly known as the vtable or , and use that to call the version appropriate for the dynamic type .
If the function is called directly , from variable of class , no lookup is performed .

Complete Tips Secrets for Professionals .

Note that while is , and is , calling on either of the two calls instead of ; this is because the vtable for updates the entry to instead point to .
Conversely , note how passing an instance to always results in being called , even when the passed instance is  this is because of something known as data slicing , where passing instance into parameter by value renders the portion of the instance that instance inaccessible .

When member function is deﬁned as virtual , all derived class member functions with the same signature override it , regardless of whether the overriding function is speciﬁed as virtual or not .

As of , intent to override can be made explicit with the keyword override .
This tells the compiler that the programmer expects it to override base class function , which causes the compiler to omit an .

This also has the beneﬁt of telling programmers that the function is both  and also declared in at least one base class , which can make complex classes easier to parse .

When function is declared  and deﬁned outside the class deﬁnition , the speciﬁer must be included in the function declaration , and not repeated in the deﬁnition .

Complete Tips Secrets for Professionals .

Section : Const Correctness of the primary uses for this is const correctness .
This is the practice of guaranteeing that only function that need to modify an object have write access to that object directly or .
This prevents unintentional modiﬁcations , making code less errorprone .
It also allows any function that need to modify state to be able to take either const or object , without needing to rewrite or overload the function .

This , in turn , allows parameters to be declared const when they need to be modiﬁed , which allows functions to take either const or objects without complaining , and can propagate outwards in this manner .

Due to this , getters are frequently const , as are any other functions that need to modify logical state .

If class is const correct , any function that const can safely be assumed to change state , and any function that is const can safely be assumed not to change state .

Chapter : Recursion in Section : Using tail recursion and recursion to solve the Fibonnaci sequence The simple and most obvious way to use recursion to get the Nth term of the Fibonnaci sequence is this .

This can be replaced with simple tail recursion .

Section : Recursion with memoization Recursive functions can get quite expensive .
If they are pure functions that always return the same value when called with the same arguments , and that neither depend on nor modify external , they can be made considerably faster at the expense of memory by storing the values already calculated .

The following is an implementation of the Fibonacci sequence with .

For this version , the caller is required to maintain the with the stored values .
This has the advantage that the function is now reentrant , and that the caller can remove values that are no longer needed , saving memory .
It has the disadvantage that it breaks encapsulation ; the caller can change the output by populating the with incorrect values .

Complete Tips Secrets for Professionals Chapter : Callable Objects Callable objects are the collection of all structures which can be used as function .
In practice , this are all things you can pass to the STL function or which can be used in the constructor of , this includes : Function pointers , Classes with , Classes with implicit conversions , References to functions , Pointers to member functions , Pointers to member data , lambdas .
The callable objects are used in many STL algorithms as predicate .

Section : Function Pointers Function pointers are the most basic way of passing functions around , which can also be used in .

For the purpose of callable objects , function pointer can be deﬁned .

The deﬁnition of can look like :  typename begin , end , Predicate .

Chapter : Section : When used in an expression out or in , sets the precision parameter of the stream out or in to exactly .
Parameter of this function is integer , which is new for precision .

Section : When used in an expression out sets the ﬁll character of the stream out to c .

Note : The current ﬁll character may be obtained with .

Complete Tips Secrets for Professionals .

Section : When used in an expression out or in , sets all format ﬂags of the stream out or in as speciﬁed by the mask .

List of all  dec use decimal base for integer oct use octal base for integer hex use hexadecimal base for integer basefield useful for masking operations adjustfield .
Useful for masking operations scientific generate ﬂoating point types using scientiﬁc notation , or hex notation if combined with ﬁxed fixed generate ﬂoating point types using ﬁxed notation , or hex notation if combined with scientiﬁc floatfield .
Useful for masking operations boolalpha insert and extract bool type in alphanumeric format showbase generate preﬁx indicating the numeric base for integer output , require the currency indicator in monetary showpoint generate character unconditionally for number output showpos generate + character for numeric output skipws skip leading whitespace before certain input operations unitbuf ﬂush the output after each output operation uppercase replace certain lowercase letters with their uppercase equivalents in certain output output operations .

Sometimes we need to set the width of the output ﬁeld , usually when we need to get the output in some structured and proper layout .

The syntax for :

Chapter : Side by Side Comparisons of classic examples solved via vs vs vs Section : Looping through container In , looping through sequence container c can be done using indexes as follows : While simple , such writings are subject to common semantic errors , like wrong comparison operator , or wrong .

Here the only parameters are the container c , and variable to hold the current .

In such implementation , the expression auto , forces and to be of the same type , while is never incremented , nor dereferenced .
So the for loop only works for containers deﬁned by pair .
The standard relaxes this constraint by changing the implementation .

Chapter : The This Pointer Section : this Pointer All member functions have hidden parameter , pointer to an instance of the class , named this ; this parameter is silently inserted at the beginning of the parameter list , and handled entirely by the compiler .
When member of the class is accessed inside member function , is silently accessed through this ; this allows the compiler to use single member function for all instances , and allows member function to call other member functions polymorphically .

In constructor , this can safely be used to or access any ﬁeld that has already been initialised , or any ﬁeld in parent class ; conversely , or accessing any ﬁelds that yet been initialised , or any ﬁelds in derived class , is unsafe to the derived class not yet being constructed , and thus its ﬁelds neither being initialised nor .
It is also unsafe to call virtual member functions through this in the constructor , as any derived class functions will not be considered to the derived class not yet being constructed , and thus its constructor not yet updating the .

Also note that while in constructor , the type of the object is the type which that constructor constructs .
This holds true even if the object is declared as derived type .
For example , in the below example , and are type CtorThisBase inside , and type CtorThis inside , even though their canonical type is CtorThisDerived .
As the classes are constructed around the base class , the instance gradually goes through the class hierarchy until is instance of its intended type .

In the good constructor , for : CtorThisBase is fully constructed by the time the CtorThis constructor is entered .
Therefore , is in valid state while initialising  and can thus be accessed .

Therefore , is in valid state while initialising , and can thus be accessed .

Therefore , is in valid state while initialising  and can thus be accessed .

In the bad constructor , for : is initialised after is reached .
Therefore , is in an invalid state while initialising , and accessing causes undeﬁned behaviour .

CtorThisDerived is not constructed until after CtorThis is constructed .
Therefore , is in an invalid state while initialising  and accessing causes undeﬁned behaviour .

The object is still CtorThis until leaves , and will not be updated to use .

, regardless of whether is intended to call that or .

Section : Using the this Pointer to Access Member Data .

Section : Using the this Pointer to Between Member Data and Parameters .

To see the output of above code  Section : this Pointer this can also be , the same as any other pointer .
However , due to the this parameter not being listed in the parameter list , special syntax is required for this ; the are listed after the parameter list , but .

When this is const const , the function is unable to write to member variables through it , whether implicitly or explicitly .
The sole exception to this is mutable member variables , which can be written regardless of .
Due to this , const is used to indicate that the member function change the logical state way the object appears to the outside , even if it does modify the physical state way the object looks under the .

Logical state is the way the object appears to outside observers .
It directly tied to physical state , and indeed , might not even be stored as physical state .
As long as outside observers see any changes , the logical state is constant , even if you ﬂip every single bit in the object .

Physical state , also known as bitwise state , is how the object is stored in memory .
This is the , the raw and that make up its data .
An object is only physically constant if its representation in memory never changes .

Note that bases constness on logical state , not physical state .

Complete Tips Secrets for Professionals .

Note that while you technically could use on this to make it , you really , REALLY , and should use mutable instead .
is liable to invoke undeﬁned behaviour when used on an object that actually is const , while mutable is designed to be safe to use .
It is , however , possible that you may run into this in extremely old code .

An exception to this rule is deﬁning accessors in terms of const accessors ; as the object is guaranteed to not be const if the version is called , no risk of UB .

As with regular pointers , if this is volatile const , it is loaded from memory each time it is accessed , instead of being cached .
This has the same eﬀects on optimisation as declaring any other pointer Complete Tips Secrets for Professionals .

Note that if an instance is , the only member functions it is allowed to access are member functions whose this pointer is at least as as the instance itself : instances can access any member functions .

This is one of the key tenets of const correctness .

Similarly to this , we can also apply to .
are used to choose between normal and rvalue reference semantics , allowing the compiler to use either copy or move semantics depending on which are more appropriate , and are applied to instead of this .

Note that despite using reference syntax , this itself is still pointer .
Also note that actually change the type of ; just easier to describe and understand their eﬀects by looking at them as if they did .

Accessed on temporary The nameless one member function cannot have overloads both with and without ; the programmer has to choose between one or the other .
Thankfully , can be used in conjunction with , allowing const .

An inline function can be multiply deﬁned without violating the One Deﬁnition Rule , and can therefore be deﬁned in header with external linkage .
Declaring function inline hints to the compiler that the function should be inlined during code generation , but does not provide guarantee .

The inline function is nowhere to be seen , its body gets inlined into the caller ' body .
Had add not been inlined , function would be called .
The overhead of calling function such as creating new frame , copying arguments , making local variables , jump locality of reference and there by cache , etc .

Section : inline function declaration inline int , int .

Placeholder Placeholder Section : Assignment Operator The Assignment Operator is when you replace the data with an already object with .

This time , it is used to initialize an already object .
This means it copies all the from the object you are assigning it to  without actually initializing the object that is being copied onto .
Now Let ' take look at the same code as before but modify the assignment constructor to be copy constructor .

This code will be similar as above two .
Let ' take this .

Since we initialize it previously .
And then next we call the assignment on since it was already initialized ; Chapter : Client server examples Section : Hello TCP Client This program is complimentary to Hello TCP Server program , you can run either of them to check the validity of each other .
The program ﬂow is quite common with Hello TCP server , so make sure to take look at that too .

Here ' the code .

Note : there is no call as there was in Hello TCP Server why .

Section : Hello TCP Server Let me start by saying you should ﬁrst visit Guide to Network Programming and give it quick read , which explains most of this stuﬀ bit more verbosely .
be creating simple TCP server here which will say World " to all incoming connections and then close them .
Another thing to note is , the server will be communicating to clients iteratively , which means one client at time .
Make sure to check out relevant man pages as they might contain valuable information about each function call and structures .

run the server with port , so take an argument for port number as well .
get started with code .

The following runs as Detecting   Enter the number of host address to bind with : Chapter : Header Files Section : Basic Example The following example will contain block of code that is meant to be split into several source ﬁles , as denoted by filename comments .

Source Files Note how this header contains only declaration of function .

Complete Tips Secrets for Professionals The guard is implemented by checking if unique preprocessor token is defined , and only including the header if it been included once before .

Without inclusion of the header file , this source file would not compile .

The Compilation Process Since header ﬁles are often part of compilation process workﬂow , typical compilation process making use of the ﬁle convention will usually do the following .

Assuming that the header ﬁle and source code ﬁle is already in the same directory , programmer would execute the following commands : Compiles the source file object file Links the object file containing the to the compiled , object version of and then produces the final executable Alternatively , if one wishes to compile to an object ﬁle ﬁrst , and then link only object ﬁles together as the ﬁnal step : Complete Tips Secrets for Professionals Section : Templates in Header Files Templates require generation of code : templated function , for example , will be eﬀectively turned into multiple distinct functions once templated function is parameterized by use in source code .

This means that template function , member function , and class deﬁnitions cannot be delegated to separate source code ﬁle , as any code that will use any templated construct requires knowledge of its deﬁnition to generally generate any derivative code .

Thus , templated code , if put in headers , must also contain its deﬁnition .

This prevents the instance from being modiﬁed unintentionally , making code less errorprone , and documents whether the code is intended to change the state or not .
It also allows instances to be treated as const whenever they need to be modiﬁed , or deﬁned as const if they need to be changed after initialisation , without losing any functionality .

This is done by giving member functions const , and by making parameters const , except in the case that they need write access .

Calling modifying function on const instance .

Due to the nature of const correctness , this starts with the class ' member functions , and works its way outwards ; if you try to call member function from const instance , or from instance being treated as const , the compiler will give you an error about it losing .

Section : Const Correct Class Design In class , all member functions which change logical state have this as const , indicating that they modify the object from any mutable ﬁelds , which can freely be modiﬁed even in const ; if const function returns reference , that reference should also be const .
This allows them to be called on both constant and instances , as const is capable of binding to either or const .
This , in turn , allows functions to declare their parameters as const when they need to be modiﬁed , without losing any functionality .

Furthermore , in const correct class , all function parameters will be const correct , as discussed in Const Correct Function Parameters , so that they can only be modiﬁed when the function explicitly needs to modify them .

First , look at this : Assume class Field , with member function .

Section : Const Correct Function Parameters In function , all parameters are marked as const unless the function directly or indirectly modiﬁes them , preventing the programmer from inadvertently changing something they mean to change .
This allows the function to take both const and instances , and in turn , causes the this to be of type const when member function is called , where is the class ' type .

Section : Const Correctness as Documentation One of the more useful things about const correctness is that it serves as way of documenting code , providing certain guarantees to the programmer and other users .
These guarantees are enforced by the compiler due to constness , with lack of constness in turn indicating that code provide them .

Therefore , they shall not modify any member variables of the instance they are called on , except mutable variables .

Shall not call any other functions that would modify any member variables of the instance , except mutable variables .

Complete Tips Secrets for Professionals Conversely , any member function which const can be assumed to have intent to modify the instance , and : May or may not modify logical state .

May or may not call other functions which modify logical state .

This can be used to make assumptions about the state of the object after any given member function is called , even without seeing the deﬁnition of that .

It may or may not call or .

It may or may not call or .

Any function with one or more parameters which are const can be assumed to have intent to read those parameters , and : Shall not modify those parameters , or call any member functions that would modify them .

Shall not pass those parameters to any other function which would modify them call any member functions that would modify them .

Conversely , any function with one or more parameters which const can be assumed to have intent to modify those parameters , and : May or may not modify those parameters , or call any member functions which whould modify them .

May or may not pass those parameters to other functions which would modify them call any member functions that would modify them .

This can be used to make assumptions about the state of the parameters after being passed to any given function , even without seeing the deﬁnition of that function .

However , due to this requiring the programmer to very speciﬁcally tell the compiler that they intend to ignore constness , and being inconsistent across compilers , it generally safe to assume that const correct code will refrain from doing so unless otherwise speciﬁed .

If one thread writes to an atomic object while another thread reads from it , the behavior memory model for details In addition , accesses to atomic objects may establish synchronization and order memory accesses as speciﬁed by .

The standard library provides specializations of the template for the following types :
One full specialization for the type bool and its typedef name deﬁned that treated as except that it has standard layout , trivial default constructor , trivial destructors , and supports aggregate initialization syntax : Typedef name Full specialization specializations and typedefs for integral types , as follows : Typedef name Full specialization long Complete Tips Secrets for Professionals .

Chapter : Data Structures in Section : Linked List implementation in Creating List Node class listNode .

Complete Tips Secrets for Professionals .

Chapter : Refactoring Techniques Refactoring refers to the modiﬁcation of existing code into an improved version .
Although refactoring is often done while changing code to add features or ﬁx bugs , the term particularly refers improving code without necessarily adding features or ﬁxing bugs .

Section : Goto Cleanup In code bases which used to be , one can ﬁnd the pattern goto cleanup .
As the goto command makes the workﬂow of function harder to understand , this is often avoided .
Often , it can be replaced by return statements , Complete Tips Secrets for Professionals .

Chapter : Streams Section : String streams is class whose objects look like an output stream is , you can write to them via , but actually store the writing results , and provide them in the form of stream .

This mainly useful when we have class for which stream serialization has been deﬁned , and for which we want string form .
For example , suppose we have some class class .

Section : Printing collections with iostream Basic printing : allows to print contents of an STL container to any output stream without explicit loops .

Implicit type cast : allows to cast container ' content type implicitly .
For example , let ' tune : to print .

Generation and transformation , and functions provide very powerful tool for data manipulation .

As in the section about reading text ﬁles , almost all these considerations may be applied to native arrays .
For example , let ' print squared values from native array : int .

struct Tuple ; parameter pack parameter accepting zero or more arguments .
If has at least one parameter pack variadic .

Section : Expansion of parameter pack The pattern .

The code above invoked with , prints hello Chapter : Literals Traditionally , literal an expression denoting constant whose type and value are evident from its spelling .
For example , literal , while not since one must see its declaration to know its type and read previous lines of code to know its value .

However , also added literals , which are not literals in the traditional sense but can be used as shorthand for function calls .

Section : this Within member function of class , the keyword this pointer to the instance of the class on which the .

The type of this depends on the of the member function : if const , then the type of this within const , so this cannot be used to modify data members from within const member function .
Likewise , this inherits volatile qualiﬁcation from the function it appears in .

Notes Letters in the integer literals are : and represent the same number There are no negative integer literals .
Expressions such as apply the unary minus to the value represented by the literal , which may involve implicit type conversions .

In prior to not in , unsuﬃxed decimal values that do not ﬁt in long int are allowed to have the type unsigned long int .

When used in controlling expression of or , all signed integer constants act as if they have type Complete Tips Secrets for Professionals .

keyword denoting null pointer constant .
It can be converted to any pointer or type , yielding null pointer of the resulting type .

Chapter : Flow Control Section : case Introduces case label of switch statement .
The operand must be constant expression and match the switch condition in type .
When the switch statement is executed , it will jump to the case label with operand equal to the condition , if any .

Section : switch According to the standard , The switch statement causes control to be transferred to one of several statements depending on the value of condition .

The keyword switch is followed by parenthesized condition and block , which may contain case labels and an optional default label .
When the switch statement is executed , control will be transferred either to case label with value matching that of the condition , if any , or to the default label , if any .

The condition must be an expression or declaration , which has either integer or enumeration type , or class type with conversion function to integer or enumeration type .

Section : catch The catch keyword introduces an exception handler , that is , block into which control will be transferred when an exception of compatible type is thrown .
The catch keyword is followed by parenthesized exception declaration , which is similar in form to function parameter declaration : the parameter name may be omitted , and the ellipsis .
The exception handler will only handle the exception if its declaration is .

When throw occurs in an expression with an operand , its eﬀect is to throw an  which is copy of .

The try block is followed by one or more catch blocks .
If an propagates out of the try block , each of the corresponding catch blocks after the try block has the opportunity to handle the  if the types match .

Section : Conditional Structures : if , if and else : it used to check whether the given expression returns true or false and acts as such : Complete Tips Secrets for Professionals if statement the condition can be any valid expression that returns something that be checked against for example : if code here evaluate that true is true and execute the code in the brackets if code here always skip the code since false is always false the condition can be anything , function , variable , or comparison for example evaluate the function , if it returns true , the if will execute the code the return of the function after passing the argument var this will evaluate the return of the experssion which will be true if equal and false if unequal is boolean type , it will evaluate for its value , if an integer , any non zero value will be true , if we want to check for multiple expressions we can do it in two ways  using binary operators  if will be true only if both and are true operators are outside the scope here if if or is true using : for simple switch either if or else .

Section : Jump statements  break , continue , goto , exit .

The break instruction : Using break we can leave loop even if the condition for its end is not fulﬁlled .
It can be used to end an inﬁnite loop , or to force it to end before its natural end The syntax is .

The continue instruction : The continue instruction causes the program to skip the rest of the loop in the present iteration as if the end of the Complete Tips Secrets for Professionals .

The goto instruction : It allows making an absolute jump to another point in the program .
You should use this feature carefully since its execution ignores any type of nesting limitation .
The destination point is identiﬁed by label , which is then used as The syntax is goto label ;

Complete Tips Secrets for Professionals .

The exit function : exit is function deﬁned in cstdlib .
The purpose of exit is to terminate the running program with an speciﬁc exit code .
Its prototype is : void exit exit .

If return has an operand , the operand is converted to the return type , and the converted value is returned to the caller .

Introduces the deﬁnition of class type .

In the declaration of template template parameter , the keyword class precedes the name of the parameter .
Since the argument for template template parameter can only be class template , the use of class here is redundant .
However , the grammar of requires it .

In the declaration or deﬁnition of an enum , declares the enum to be scoped enum .

Introduces the deﬁnition of an enumeration type .

In , enum may optionally be followed by class or struct to deﬁne scoped enum .
Furthermore , both scoped and unscoped enums can have their underlying type explicitly speciﬁed by  following the enum name , where refers to an integer type .

Introduces an opaque enum declaration , which declares an enum without deﬁning it .
It can either redeclare previously declared enum , or an enum that has not been previously declared .

An enum ﬁrst declared as scoped cannot later be declared as unscoped , or vice versa .
All declarations of an enum must agree in underlying type .

When an unscoped enum , the underlying type must be explicitly speciﬁed , since it cannot be inferred until the values of the enumerators are known .

Introduces the deﬁnition of union type .

It is whether char is signed has range of at least to , or unsigned has range of at least to ,

An unsigned integer type with the same size and alignment as , which is therefore large enough to hold code unit .

An unsigned integer type with the same size and alignment as , which is therefore large enough to .

Section : void An incomplete type ; it is not possible for an object to have type void , nor are there arrays of void or references to void .
It is used as the return type of functions that do not return anything .

Moreover , function may redundantly be declared with single parameter of type void ; this is equivalent to declaring function with no parameters .
This syntax is allowed for compatibility with function declarations have diﬀerent meaning than in .

The type to has the property that any object pointer can be converted to it and back and result in the same pointer .
This feature makes the type suitable for certain kinds of interfaces , for example for generic contexts in APIs .

Any expression may be converted to an expression of type void ; this is called .

Section : An integer type large enough to represent all characters of the largest supported extended character set , also known as the set .

This type can also be written as long int .

In all other cases , yields both the type and the value category of the expression , as follows : If is an lvalue of type , then is .

If is an xvalue of type , then is .

If is prvalue of type , then is .

This includes the case with extraneous parentheses .

Section : const type speciﬁer ; when applied to type , produces the version of the type .
See const keyword for .

Section : volatile type qualiﬁer ; when applied to type , produces the version of the type .
Volatile qualiﬁcation plays the same role as const qualiﬁcation in the type system , but volatile does not prevent objects from being modiﬁed ; instead , it forces the compiler to treat all accesses to such objects as side eﬀects .

In the example below , if were not volatile , the compiler could optimize the function so that it performs only the ﬁnal write , which would be incorrect if is greater than .
The volatile qualiﬁcation forces it to treat all writes as diﬀerent side eﬀects and hence perform all of them .

Section : signed keyword that is part of certain integer type names .

When used alone , int is implied , so that signed , signed int , and int are the same type .

When combined with char , yields the type signed char , which is diﬀerent type from char , even if char is also signed .

When combined with short , long , or long long , it is redundant , since those types are already signed .

Section : unsigned type speciﬁer that requests the unsigned version of an integer type .

When used alone , int is implied , so unsigned is the same type as unsigned int .

The type unsigned char is diﬀerent from the type char , even if char is unsigned .
It can hold integers up to at least .

It cannot be combined with bool , or .

Chapter : type deduction Section : Template parameter deduction for constructors Prior to , template deduction cannot deduce the class type for you in constructor .
It must be explicitly speciﬁed .
Sometimes , however , these types can be very cumbersome or the case of impossible to name , so we got proliferation of type factories ,

Type deduction using the auto keyword works almost the same as Template Type Deduction .

The diﬀerences are outlined below : auto auto auto auto .

See remarks for more information .

If it deduce the of , the code is rejected .

allows , in addition to the usages of auto allowed in , the following :
When used as the return type of function without trailing return type , speciﬁes that the return type should be deduced from the return statements in the body , if any .

In and earlier , the auto keyword had completely diﬀerent meaning as storage class speciﬁer that was inherited from .

Section : Template Type Deduction Template Generic Syntax .

In this case type deduction works this way .
The compiler ignores the reference part if it exists in expr .
The compiler then type against ParamType to determing .

In this case type deduction is the same as in case if the expr is an rvalue .
If expr is an lvalue , both and ParamType are deduced to be lvalue references .

If expr is reference the reference part is ignored .
If expr is const that is ignored as well .
If it is volatile that is also ignored when deducing type .

Output hello world Wrong type Chapter : Memory Model .

An optimizing compiler may decide to reorder the program in similar way .

Such reordering cannot change the behavior of program running in single thread because thread cannot interleave the calls to and .
On the other hand in setting one thread may see part of the writes performed by the other thread where it may happen that may see and garbage in or or both .

The Memory Model allows the programmer to specify which reordering operations are permitted and which are not , so that program would also be able to behave as expected .
The example above can be rewritten in way like .

Here performs operation .
This not only stores the value true into  but also tells the compiler that it cannot move this operation before write operations that are sequenced before it .

The function does an operation .
It reads the current value of and also forbids the compiler from placing read operations that are sequenced after it to happen before the .

These operations also cause the compiler to put whatever hardware instructions are needed to inform the CPU to refrain from the unwanted reorderings .

Because the is to the same memory location as the , the memory model stipulates that if the operation sees the value written by the operation , then all writes performed by thread prior to that will be visible to loads that thread executes after its .
That is if sees , then it is guaranteed to see and .

Note that the compiler and the CPU are still allowed to write to before writing to  and similarly the reads from these variables in can happen in any order .

If the load operation sees the value written by the store then the store happens before the load , and so do the fences : the release fence happens before the acquire fence making the writes to and that precede the release fence to become visible to the : statement that follows the acquire fence .

fence might be beneﬁcial if it can reduce the overall number of acquire , release or other synchronization operations .

Chapter : Build Systems , like , has long and varied history regarding compilation workﬂows and build processes .
Today , has various popular build systems that are used to compile programs , sometimes for multiple platforms within one build system .
Here , few build systems will be reviewed and analyzed .

Section : Generating Build Environment with CMake CMake generates build environments for nearly any compiler or IDE from single project deﬁnition .
The following examples will demonstrate how to add CMake ﬁle to the World " code .

CMake ﬁles are always named " and should already exist in every root directory possibly in basic ﬁle looks .

See it live on Coliru .

This ﬁle tells CMake the project name , what ﬁle version to expect , and instructions to generate an executable called " that requires .

Generate build environment for your installed from the command line : cmake .

Build the application with : cmake .

This generates the default build environment for the system , depending on the OS and installed tools .
Keep source code clean from any build artifacts with use of " builds : mkdir build cd build cmake .

CMake can also abstract the platform basic commands from the previous example : cmake build cmake chdir build cmake .

To generate makeﬁles for Visual nmake : cmake Makefiles "

GNU Make is one speciﬁc program that falls under the Make family .
Make remains popular among and operating systems , including those derived from the Linux kernel , Mac OS , and BSD .

GNU Make is especially notable for being attached to the GNU Project , which is attached to the popular operating system .
GNU Make also has compatible versions running on various ﬂavors of Windows and Mac OS .
It is also very stable version with historical signiﬁcance that remains popular .
It is for these reasons that GNU Make is often taught alongside and .

Basic rules To compile with make , create Makeﬁle in your project directory .
Your Makeﬁle could be as simple as : Makeﬁle Set some variables to use in our command First , we set the compiler to be Then , we say that we want to compile with recommended warnings and some extra ones .

Compile with warnings , and output to the file This target should reverse the target .
If you call make with an argument , like , the corresponding target gets called .

Otherwise , get an error of : missing separator .

To run this from the , do the following : cd make ls app Makefile Complete Tips Secrets for Professionals Hello World .

Recompiling would take more time .

With the following directory .

This new ensures that you only recompile changed ﬁles , minimizing compile time .

Documentation For more on make , see the oﬃcial documentation by the Free Software Foundation , the stackoverﬂow documentation and elaborate answer on stackoverﬂow .

Complete Tips Secrets for Professionals Section : Building with SCons You can build the World " code , using Scons software construction tool .

First , create called SConstruct that SCons will look for with this exact name by .
For now , the should be in directory right along your .
Write in the new the line Now , from the terminal , run scons .
You should see something like scons scons : Reading SConscript files .

The and Glob classes will help you further conﬁgure what to build .
, the SConstruct , builds the executable hello , using all ﬁles in src .
Its is and it speciﬁes the standard .

Introduction The Autotools are group of programs that create GNU Build System for given software package .
It is suite of tools that work together to produce various build resources , such as be used with GNU .
Thus , Autotools can be considered de facto build system generator .

Some notable Autotools programs include : Autoconf In general , Autotools is meant to generate the script and to allow the following command to build well as most packages the simple : make make install As such , Autotools also has relationship with certain package managers , especially those that are attached to operating systems that conform to the POSIX .

Section : Ninja Introduction Complete Tips Secrets for Professionals The Ninja build system is described by its project website as small build system with focus on " Ninja is designed to have its ﬁles generated by build system generators , and takes approach to build systems , in contrast to build system managers like CMake or Meson .

Ninja is primarily written in and Python , and was created as an alternative to the SCons build system for the Chromium project .

Introduction NMAKE is utility developed by Microsoft to be used primarily in conjunction with Microsoft Visual Studio the Visual command line tools .

NMAKE is build system that falls under the Make family of build systems , but has certain distinct features that diverge from Make programs , such as supporting path syntax itself diﬀers from .

Chapter : Concurrency With OpenMP This topic covers the basics of concurrency in using OpenMP .
OpenMP is documented in more detail in the OpenMP tag .

Parallelism or concurrency implies the execution of code at the same time .

Section : OpenMP : Parallel Sections This example illustrates the basics of executing sections of code in parallel .

As OpenMP is compiler feature , it works on any supported compilers without including any libraries .
You may wish to include if you want to use any of the openMP API features .

Sample Code :

Outputs This example produces possible outputs and is dependent on the operating system and hardware .
The output also illustrates race condition problem that would occur from such an implementation .

OUTPUT OUTPUT begin begin Section : OpenMP : Parallel Sections This example shows how to execute chunks of code in parallel :

Output begin forever begin forever begin forever begin forever As execution order is not guaranteed , you may observe any of the above output .

Section : OpenMP : Parallel For Loop .

Splits element vector into Thread Qty .

Complete Tips Secrets for Professionals .

Continue process Only when all threads completed their allocated loop job take extra care to not modify the size of the vector used in parallel for loops as allocated range indices update automatically .

Section : OpenMP : Parallel Gathering Reduction This example illustrates concept to perform reduction or gathering using : and OpenMP .

Supposed we have scenario where we want multiple threads to help us generate bunch of stuﬀ , int is used here for simplicity and can be replaced with other data types .

This is particularly useful when you need to merge results from slaves to avoid segement faults or memory access violations and do not wish to use libraries or custom sync container libraries .

Hint the compiler to parallelize this of code .

Have fun with Master Chapter : Type Inference This topic discusses about type inferencing that involves the keyword auto type that is available from .

Section : Data Type : Auto .

However , the auto keyword does not always perform the expected type inference without additional hints for or const or constexpr unsigned int ,

These sequences are used when implementing class or function templates which beneﬁt from positional access .
The standard library also contains " types which create ascending sequences of integer values just from the number of elements .

Section : Turn into function parameters can be used to pass multiple values around .
For example , it could be used to store sequence of parameters into some form of queue .
When processing such tuple its elements need to be turned into function call .

The function itself is entirely independent of the number of arguments .

Section : Create parameter pack consisting of integers : itself is about holding sequence of integers which can be turned into parameter pack .

Section : Turn sequence of indices into copies of an element Expanding the parameter pack of indices in comma expression with value creates copy of the value for each of the indices .
Sadly , gcc and clang think the index has no eﬀect and warn about it can be silenced by casting the index to .

Chapter : Resource Management One of the hardest things to do in and is resource management .
Thankfully , in , we have many ways to go about designing resource management in our programs .
This article hopes to explain some of the idioms and methods used to manage allocated resources .

Section : Resource Acquisition Is Initialization Resource Acquisition Is Initialization is common idiom in resource management .
In the case of dynamic memory , it uses smart pointers to accomplish resource management .
When using RAII , an acquired resource is immediately given ownership to smart pointer or equivalent resource manager .
The resource is only accessed through this manager , so the manager can keep track of various operations .
For example , automatically frees its corresponding resource when it falls out of scope or is otherwise deleted .

Because of these weird copy semantics , be used in containers , among other things .
The reason it does this is to prevent deleting memory twice : if there are two with ownership of the same resource , they both try to free it when destroyed .
Freeing an already freed resource can generally cause problems , so it is important to prevent it .
However , has method to avoid this while not transferring ownership when .

Section : Mutexes Thread Safety Problems may happen when multiple threads try to access resource .
For simple example , suppose we have thread that adds one to variable .
It does this by ﬁrst reading the variable , adding one to it , then storing it back .

Suppose we initialize this variable to , then create two instances of this thread .
After both threads ﬁnish , intuition suggests that this variable should have value of .
However , the below table illustrates what might go wrong : Thread Thread Time Step Read from variable Time Step Read from variable Time Step Add plus to Time Step Add plus to Time Step Store into variable Time Step Store into variable As you can see , at the end of the operation , is in the variable , instead of .
The reason is that Thread read the variable before Thread was done updating it .

mutex of mutual is resource management object designed to solve this type of problem .
When thread wants to access resource , it " the resource ' mutex .
Once it is done accessing the resource , the thread " the mutex .
While the mutex is acquired , all calls to acquire the mutex will not return until the mutex is released .
To better understand this , think of mutex as waiting line at the supermarket : the threads go into line by trying to acquire the mutex and then waiting for the threads ahead of them to ﬁnish up , then using the resource , then stepping out of line by releasing the mutex .
There would be complete pandemonium if everybody tried to access the resource at once .

Section : Changing the default sort of set set and multiset have default compare methods , but in some cases you may need to overload them .

Let ' imagine we are storing string values in set , but we know those strings contain only numeric values .
By default the sort will be lexicographical string comparison , so the order match the numerical sort .
If you want to apply sort equivalent to what you would have with values , you need functor to overload the compare method :

Output will be : Default sort on  Custom sort on  Lambda sort on  In the example above , one can ﬁnd diﬀerent ways of adding compare operations to the , each of them is useful in its own context .

Default sort This will use the compare operator of the key template .
Often , the key will already provide good default for the function .
Unless this function is specialized , it uses the of the object .
This is especially useful when other code also tries to use some ordering , as this allows consistency over the whole code base .

Writing the code this way , will reduce the eﬀort to update your code when the key changes is API , like : class containing members which changes to class containing members .
By updating the in the class , all occurrences will get updated .

As you might expect , using the default sort is reasonable default .

Custom sort Adding custom sort via an object with compare operator is often used when the default comparison comply .
In the example above this is because the strings are referring to integers .
In other cases , often used when you want to compare pointers based upon the object they refer to or because you need diﬀerent constraints for comparing : comparing by the value of .

When creating compare operator , this should be stable sorting .
If the result of the compare operator changes after insert , you will have undeﬁned behavior .
As good practice , your compare operator should only use the constant members , const functions .

As in the example above , you will often encounter classes without members as compare operators .
This results in default constructors and copy constructors .
The default constructor allows you to omit the instance at construction time and the copy constructor is required as the takes copy of the compare operator .

Complete Tips Secrets for Professionals Lambda sort Lambdas are shorter way to write function objects .
This allows writing the compare operator on less lines , making the overall code more readable .

The disadvantage of the use of lambdas is that each lambda gets speciﬁc type at compile time , so will be diﬀerent for each compilation of the same compilation unit as over multiple compilation units included via header .
For this reason , its recommended to use function objects as compare operator when used within header ﬁles .

This construction is often encountered when : is used within the local scope of function instead , while the function object is preferred when used as function arguments or class members .

Other sort options As the compare operator of : is template argument , all callable objects can be used as compare operator and the examples above are only speciﬁc cases .
The only restrictions these callable objects have are : They must be copy constructable They must be callable with arguments of the type of the key .

Please note that if you ask to delete an element from multiset , and is present multiple times , all the equivalent values will be deleted .

Section : Inserting values in Three diﬀerent methods of insertion can used with sets .

First , simple insert of the value .
This method returns pair allowing the caller to check whether the insert really occurred .

Second , an insert by giving hint of where the value will be inserted .
The objective is to optimize the insertion time in such case , but knowing where value should be inserted is not the common case .
Be careful in that case ; the way to give hint diﬀers with compiler versions .

Finally you can insert range of values by giving starting and an ending pointer .
The starting one will be included in the insertion , the ending one is excluded .

Nevertheless , another possibility exists , which is .

Section : Searching values in and There are several ways to search given value in : or in : To get the iterator of the ﬁrst occurrence of key , the function can be used .
It returns if the key does not exist .

They do not aﬀect the type of the declaration , but typically modify the way in which the entity is stored .

Section : extern The extern storage class speciﬁer can modify declaration in one of the three following ways , depending on context :
It can be used to declare variable without deﬁning .
Typically , this is used in header ﬁle for variable that will be deﬁned in separate implementation ﬁle .

function can also be declared extern , but this has no eﬀect .
It is usually used as hint to the reader that function declared here is deﬁned in another translation unit .
For example : void ; typically forward declaration ; defined later in this TU extern void ; typically not forward declaration ; defined in another TU In the above code , if were changed to extern and to , would not aﬀect the correctness or semantics of the program at all , but would likely confuse the reader of the code .

Complete Tips Secrets for Professionals Section : register storage class speciﬁer that hints to the compiler that variable will be heavily used .
The word " is related to the fact that compiler might choose to store such variable in CPU register so that can be accessed in fewer .

Both local variables and function parameters may be declared register .
Unlike , does not place any restrictions on what can be done with register variable .
For example , is valid to take the address of register variable , but this may prevent the compiler from actually storing such variable in register .

The keyword register is unused and reserved .
program that uses the keyword register is .

Section : static The static storage class speciﬁer has three diﬀerent meanings .

Section : auto Declares variable to have automatic storage duration .
It is redundant , since automatic storage duration is already the default at block scope , and the auto speciﬁer is not allowed at namespace scope .

Section : mutable speciﬁer that can be applied to the declaration of , data member of class .

meaning for mutable was added in .
When follows the parameter list of lambda , suppresses the implicit const on the lambda ' function call operator .
Therefore , mutable lambda can modify the values of .

Chapter : Alignment All types in have an alignment .
This is restriction on the memory address that objects of that type can be created within .
memory address is valid for an object ' creation if dividing that address by the object ' alignment Complete Tips Secrets for Professionals is whole number .

Type alignments are always power of two .

Section : Controlling alignment The alignas keyword can be used to force variable , class data member , declaration or deﬁnition of class , or declaration or deﬁnition of an enum , to have particular alignment , if supported .
It comes in two forms : where is constant expression , gives the entity the alignment  if supported .

If multiple alignas speciﬁers are applied to the same entity , the strictest one applies .

Valid alignments are always powers of two , and must be greater than zero .
Compilers are required to support all valid alignments up to the alignment of the type .
They may support larger alignments than this , but support allocating memory such objects limited .
The upper limit on alignments implementation dependent .

features direct support in operator allocating memory types .

Section : Querying the alignment of type The alignment requirement of type can be queried using the alignof keyword as unary operator .

Possible output The alignment requirement of  If applied to an array , it yields the alignment requirement of the element type .
If applied to reference type , it yields the alignment requirement of the referenced type .
If it multiply deﬁned , the linker will merge all deﬁnitions into single object in the ﬁnal program .

Section : Deﬁning static data member in the class deﬁnition static data member of the class may be fully deﬁned within the class deﬁnition if it declared inline .
For example , the following class may be deﬁned in header .
Prior to , it would have been necessary to provide ﬁle to contain the deﬁnition of : so that it would be deﬁned only once , but in the multiple deﬁnitions of the inline variable : all refer to the same object .

Chapter : Linkage speciﬁcations extern extern declaration linkage speciﬁcation tells the compiler to compile declarations in way that allows them to be linked together with declarations written in another language , such as .

Section : Signal handler operating system Since signal handler will be by the kernel using the calling convention , we must tell the compiler to use .

The deﬁnition of separately compiled and distributed with the header in object form .

program can , but the compiler will not know that the function deﬁned as symbol , and will probably try to look it with mangled name , and fail to locate it .
Even if it can ﬁnd the deﬁnition of in the library , not all platforms use the same calling conventions and , and the compiler will use the calling convention when calling , which likely to cause segmentation fault if expecting to be with the calling convention .

The way to remedy this problem to wrap almost all the declarations in the header in an extern " block .

Chapter : Curiously Recurring Template Pattern pattern in which class inherits from class template with itself as one of its template parameters .
CRTP usually used to provide static polymorphism in .

CRTP powerful , static alternative to virtual functions and traditional inheritance that can be used to give types properties at compile time .
It works by having base class template which takes , as one of its template parameters , the derived class .
This permits it to legally perform of its this pointer to the derived class .

Of course , this also means that CRTP class must always be used as the base class of some other class .

say you have set of containers that all support the functions and .

The only static cast inside the function in the class allows the compiler to drastically optimize the code and no virtual table look up happens at runtime .

Limitations : Because the class templated and diﬀerent two diﬀerent DynArrays it not possible to store pointers to their classes in an array as one could generally do with normal inheritance where the class not dependent on the derived .

Complete Tips Secrets for Professionals .

Section : Importing names individually from namespace Once using is used to introduce the name from the namespace std into the scope of the main function , the .

Section : Redeclaring members from class to avoid name hiding If occurs at class scope , it is only allowed to redeclare member of class .
For example , using : is not allowed at class scope .

Often , the name redeclared is one that would otherwise be hidden .
For example , in the below code , only refers to and compilation error will occur .
The function is hidden .

As special case , at class scope can refer to the constructors of direct class .

performs the forwarding explicitly , while , using the feature of inheriting constructors , does so implicitly .

Section : Basic typedef syntax typedef declaration has the same syntax as variable or function declaration , but it contains the word typedef .

The presence of typedef causes the declaration to declare instead of variable or function .

The rule that typedef declarations have the same syntax as ordinary variable and function declarations can be used to read and write more complex declarations .

Section : Declaring multiple types with typedef The typedef keyword is speciﬁer , so it applies separately to each declarator .
Therefore , each declared refers to the that that would have in the absence of typedef .

The syntax of using is very simple : the to be deﬁned goes on the left hand side , and the deﬁnition goes on the right hand side .
No need to scan to see where the is .

It is simply an alternative syntax for accomplishing the same thing .

Unlike typedef , using can be templated .

Complete Tips Secrets for Professionals Chapter : Layout of object types Section : Class types By , we mean that was deﬁned using the class or struct keyword not enum struct or enum .

Even an empty class still occupies at least one byte of storage ; it will therefore consist purely of padding .
This ensures that if points to an object of an empty class , then + is distinct address and points to distinct object .
However , it is possible for an empty class to have size of when used as base class .
See empty base optimisation .

If class type has members base classes with types , the size must be at least + +
However , depending on the alignment requirements of the members and base classes , the compiler may be forced to insert padding .

If padding is inserted in an object due to alignment requirements , the size will be greater than the sum of the sizes of the members and base classes .
With alignment , size will typically be the smallest multiple of which is larger than the size of all members base classes .
Each member memN will typically be placed at an address which is multiple of , and will typically be the largest alignof out of all members ' alignofs .
Due to this , if member with smaller alignof is followed by member with larger alignof , there is possibility that the latter member will not be aligned properly if placed immediately after the Complete Tips Secrets for Professionals former .
In this case , padding known as an alignment member will be placed between the two members , such that the latter member can have its desired alignment .
Conversely , if member with larger alignof is followed by member with smaller alignof , no padding will usually be necessary .
This process is also known as .

Due to classes typically sharing the alignof of their member with the largest alignof , classes will typically be aligned to the alignof of the largest type they directly or indirectly contain .

If strict alignment is forced with alignas , padding will be used to force the type to meet the speciﬁed alignment , even when it would otherwise be smaller .
For example , with the deﬁnition below , will have three possibly padding bytes inserted at the end so that its total size is .
It is not possible for class with an alignment of to have size of because it would be impossible to make an array of that class , so the size must be up " to multiple of by inserting padding bytes .

Padding shall be inserted as needed .

If two members of class have the same access speciﬁer , then the one that comes later in declaration order is guaranteed to come later in the object representation .
But if two members have diﬀerent access speciﬁers , their relative order within the object is unspeciﬁed .

It is unspeciﬁed what order the base class subobjects appear in within an object , whether they occur consecutively , and whether they appear before , after , or between member subobjects .

Section : Arithmetic types Narrow character types The unsigned char type uses all bits to represent binary number .
Therefore , for example , if unsigned char is bits  then the possible bit patterns of char object represent the diﬀerent values ,
The number is guaranteed to be represented by the bit pattern .

The signed char type has no padding bits , if signed char is bits  then it has bits of capacity to represent number .

Note that these guarantees do not apply to types other than narrow character types .

Integer types The unsigned integer types use pure binary system , but may contain padding bits .
For example , it is possible for unsigned to be bits but only be capable of storing integers between and , inclusive .
The other bits would be padding bits , which should not be written to directly .

The signed integer types use binary system with sign bit and possibly padding bits .
Values that belong to the common range of signed integer type and the corresponding unsigned integer type have the same representation .
For example , if the bit pattern of an unsigned object represents the value , then it also represents the value when interpreted as object .

It is whether complement , complement , or representation is used , since all three systems satisfy the requirement in the previous paragraph .

Floating point types Complete Tips Secrets for Professionals The value representation of ﬂoating point types is .
Most commonly , the and double types conform to IEEE and are and bits , for example , would have bits of precision which would follow exponent bits and sign .
However , the standard does not guarantee anything .
Floating point types often have , which cause errors when they are used in calculations .

Section : Arrays An array type has no padding in between its elements .
Therefore , an array with element type is just sequence of objects laid out in memory , in order .

multidimensional array is an array of arrays , and the above applies recursively .
For example , if we have the declaration ; then is an array of arrays of ints .
Therefore , which consists of the three elements ,

Chapter : incompatibilities This describes what code will break in compiler .

Section : Reserved Keywords The ﬁrst example are keywords that have special purpose in : the following is legal in , but not .

Section : Weakly typed pointers In , pointers can be cast to , which needs an explicit cast in .
The following is illegal in , but legal in .

Chapter : is container that supports fast insertion and removal of elements from anywhere in the container .
Fast random access is not supported .
It is implemented as list and essentially does not have any overhead compared to its implementation in .
Compared to this container provides more space eﬃcient storage when bidirectional iteration is not needed .

Complete Tips Secrets for Professionals .

Output : frogurt , is , also , frogurt , is , also , frogurt , is , also , Mo , Mo , Mo , Section : Methods Method name Deﬁnition assigns values to the container assign assigns values to the container returns the associated allocator access front access the ﬁrst element returns an iterator to the element before beginning returns constant iterator to the element before beginning begin returns an iterator to the beginning cbegin returns const iterator to the beginning end returns an iterator to the end cend returns iterator to the end Complete Tips Secrets for Professionals Capacity empty checks whether the container is empty returns the maximum possible number of elements Modiﬁers clears the contents inserts elements after an element constructs elements after an element erases an element after an element inserts an element to the beginning constructs an element at the beginning removes the ﬁrst element resize changes the number of elements stored swap swaps the contents Operations merge merges two sorted lists moves elements from another remove removes elements satisfying speciﬁc criteria removes elements satisfying speciﬁc criteria reverse reverses the order of the elements unique removes consecutive duplicate elements sort sorts the elements clear Chapter : Optimization When compiling , the compiler will often modify the program to increase performance .
This is permitted by the rule , which allows any and all transformations that do not change observable behavior .

Section : Inline Inline expansion known as is compiler optimisation that replaces call to function with the body of that function .
This saves the function call overhead , but at the cost of space , since the function may be duplicated several times .

Complete Tips Secrets for Professionals Section : Empty base optimization The size of any object or member subobject is required to be at least even if the type is an empty class type is , class or struct that has no data , in order to be able to guarantee that the addresses of distinct objects of the same type are always distinct .

However , base class subobjects are not so constrained , and can be completely optimized out from the object .

This is achieved by storing one of the required data members , begin , end , or capacity pointer for the .

Reference : cppreference Chapter : Semaphore Semaphores are not available in as of now , but can easily be implemented with mutex and condition variable .

This example was taken from : has no semaphores .
How to synchronize threads .

Section : Semaphore class in action The following function adds four threads .
Three threads compete for the semaphore , which is set to of one .

slower calls , allowing one of the waiting threads to proceed .

The result is that immediately starts spinning , causing the usage to remain below .
The other threads in turn on the condition variable until is called .

In this topic , you can ﬁnd the diﬀerent structures which are provided by the standard library to solve these issues .

Section : generalization of , works with any type of BasicLockable structure .

It throws in case cannot complete its task .

Section : Object locking for access .

Often you want to lock the entire object while you perform multiple operations on .
For example , if you need to examine or modify the object using iterators .
Whenever you need to call multiple member functions is generally more eﬃcient to lock the whole object rather than individual member functions .

For example : class .

Chapter : Debugging and Tools Techniques lot of from developers is spent debugging .
This topic is meant to assist with this task and give inspiration for techniques .
expect an extensive list of issues and solutions ﬁxed by the tools or manual on the mentioned tools .

Section : Static analysis Static analysis is the technique in which on checks the code for patterns linked to known bugs .
Using this technique is less consuming than code review , though , its checks are only limited to those programmed in the tool .

Checks can the incorrect behind the till advanced graph algorithms which determine if variable is not initialized .

Compiler warnings Enabling static analysis is easy , the most simplistic version is already in your compiler :

If you enable these options , you will notice that each compiler will ﬁnd bugs the others and that you will get errors on techniques which might be valid or valid in speciﬁc context .

So unlike code review , you are ﬁghting tool which understands your code , tells you lot of useful bugs and sometimes disagrees with you .
In this last case , you might have to suppress the warning locally .

As the options above enable all warnings , they might enable warnings you want .

Complete Tips Secrets for Professionals .

Where compiler warnings assist you during development , they slow down compilation quite bit .
That is why you might not always want to enable them by default .
Either you them by default or you enable some continuous integration with the more expensive checks all of .

External tools If you decide to have some continuous integration , the use of other tools such stretch .
tool like has an list of checks which covers wide range of issues , some examples : Actual bugs Prevention of slicing Asserts with side eﬀects Readability checks Misleading indentation Check identiﬁer naming Modernization checks Use nullptr Performance checks Find unneeded copies Find ineﬃcient algorithm calls The list might not be that large , as Clang already has lot of compiler warnings , however will bring you one step closer to high quality code base .

Other tools Other tools with similar purpose exist , like : the visual studio static analyzer as external tool clazy , Clang compiler plugin for checking Qt code Conclusion lot static analysis tools exist for , both in the compiler as external tools .
Trying them out take that much for easy setups and they will ﬁnd bugs you might miss in code review .

Section : Segfault analysis with GDB .

Start it from the beginning .

So the only variable being used at this line is pointer .
Lets examine its content typing print .

At this line , we know that we are trying to dereference NULL pointer .

Section : Clean code Debugging starts with understanding the code you are trying to debug .

Regardless of the coding styles you prefer and use , having consistent coding style will help you understanding the code .

Looking at the code above , one can identify couple of improvements to improve readability and debuggability : The use of separate functions for separate actions The use of separate functions allow you to skip over some functions in the debugger if you interested in the details .
In this speciﬁc case , you might not be interested in the creation or printing of the data and only want to step into the sorting .

Another advantage is that you need to read less code memorize while stepping through the code .
You now only need to read lines of code in in order to understand it , instead of the whole function .

The third advantage is that you simply have less code to look at , which helps trained eye in spotting this bug within seconds .

Using consistent The use of consistent formatting and constructions will remove clutter from the code making it easier to focus on the code instead of text .
lot of discussions have been fed on the ' formatting style .
Regardless of that style , having single consistent style in the code will improve familiarity and make it easier to focus on the code .

As formatting code is time consuming task , it is recommended to use dedicated tool for this .
Most IDEs have at least some kind of support for this and can do formatting more consistent than humans .

You might note that the style is not limited to spaces and newlines as we no longer mix the and the member functions to get of the container .

Point attention to the important parts of your code .

Regardless of the style you determine to choose , the above code contains couple of markers which might give you hint on what might be important : Complete Tips Secrets for Professionals comment stating optimized , this indicates some fancy techniques Some early returns in indicate that we are doing something special Conclusion Having clean code will help you understanding the code and will reduce the time you need to debug it .
In the second example , code reviewer might even spot the bug at ﬁrst glance , while the bug might be hidden in the Chapter : Futures and Promises Promises and Futures are used to ferry single object from one thread to another .

object is set by the thread which generates the result .

object can be used to retrieve  to test to see if is available , or to halt execution until the is available .

Section : Async operation classes : performs an asynchronous operation .

Section : and : The following example sets to be consumed by another .

Section : Deferred async example This code implements version of , but it behaves as if async were always called with the deferred launch policy .
This function also does not have special behavior ; the returned can be destroyed without ever acquiring its .

The thread starts running immediately .
We can either detach it , or have join it at the end of the scope .
When the function call to ﬁnishes , the result is ready .

Note that this is slightly diﬀerent from where the returned : when destructed will actually block until the thread is ﬁnished .

Section : and If constraints for : and : are not met an exception of type is thrown .

The error code member in the exception is of type and values are as below , along with some test cases : enum class ; the task is no longer shared , the answer was already retrieved , the answer was stored already , access to in state .

Note : In the example is launched with policy .
This is to avoid new being created in every call .
In the case of our example , the calls to are made out of order , the they synchronize at the calls for .

The default policy is , meaning the implementation determines the policy for creating new .

Chapter : More undeﬁned behaviors in More examples on how can go wrong .

Continuation from Undeﬁned Behavior Section : Referring to members in initializer lists Referring to members in initializer lists before the constructor has started executing can result in undeﬁned behavior .
This results since not all members are constructed at this time .
From the standard draft : For an object with constructor , referring to any member or base class of the object before the constructor begins execution results in undeﬁned behavior .

Chapter : Mutexes Section : Mutex Types oﬀers selection of mutex classes : oﬀers simple locking functionality .

Section : uses deadlock avoidance algorithms to lock one or more mutexes .
If an exception is thrown during call .

Complete Tips Secrets for Professionals allows for exclusive ownership of mutexes .

Section : Strategies for lock classes : When creating , there are three diﬀerent locking strategies to choose from : and .

Section : is simple , synchronization structure that is used to protect data which is accessed by .

When is destroyed , mutexes are released in the reverse order .

Chapter : Unit Testing in Unit testing is level in software testing that validates the behavior and correctness of units of code .

In , of code " often refer to either classes , functions , or groups of either .
Unit testing is often performed using specialized frameworks " or libraries " that often use syntax or usage patterns .

This topic will review diﬀerent strategies and unit testing libraries or frameworks .

Section : Google Test Google Test is testing framework maintained by Google .
It requires building the gtest library and linking to your testing framework when building test case ﬁle .

Minimal Example .

Scenario : vectors can be sized and resized Given : with some items When : more is reserved Then : the changes but not the Complete Tips Secrets for Professionals Chapter : Recursive Mutex Section : Recursive mutex allows the same thread to recursively lock resource up to an unspeciﬁed limit .

There are very few justiﬁcations for this .
Certain complex implementations might need to call an overloaded copy of function without releasing the lock .

The keyword decltype can be used to get the type of variable , function or an expression .

Section : Basic Example This example just illustrates how this keyword can be used .

Then the type of variable now automatically becomes float .

say we have 

It works on keys and their maps .
Key as the names goes , helps to have uniqueness in the map .
While the mapped value is just content that is associated with the key .
The data types of this key and map can be any of the predeﬁned data type or .

Section : Declaration and Usage As already mentioned you can declare an unordered map of any type .
have unordered map named ﬁrst with string and integer type .

Section : Some Basic Functions .

Compare with for equality .

Decide whether or is larger .

deﬁne Simple Quotation Mark  as digit separator , in numbers and literals .
This can make it easier for human readers to parse large numbers .

long long long long long long long long decn hexn octn binn .

Single quotes mark are ignored when determining its value .

Example : The literals , and all have the same value .

The literals and have the same value .

The position of the single quotes is irrelevant .
All the following are equivalent : long long long long long long long long .

In detail the parameters can be seen as variables before the function call and inside the function , where the visible behaviour and accessibility to these variables diﬀers with the method used to hand them over .

Additionally , the reusability of variables and their respective values after the function call also is explained by this topic .

Section : Call by value Upon calling function there are new created on the program stack .
These include some information Complete Tips Secrets for Professionals about the function and also space for the parameters and the return value .

When handing over parameter to function the value of the used variable is copied into the memory location of the function parameter .
This implies that now there two memory locations with the same value .
Inside of the function we only work on the parameter memory location .

After leaving the function the memory on the program stack is popped which erases all data of the function call , including the memory location of the parameters we used inside .
Thus , the values changed inside the function do not aﬀect the outside values .

In this code we create inside the main function .

Upon calling the functions there are two new created : and where shares the name with the outer variable it does not share the memory location .
The behaviour of and is identical .

The following graphic symbolizes what is happening on the stack and why there is no change in varibale .
The graphic is not fully accurate but emphazises the example .

It is called by value " because we do not hand over the but only the values of these .

Section : user input and standard output .

Manipulators are special helper functions that help controlling input and output streams using operator or operator .

They all can be included by .

Have no eﬀect on input streams .

The width property resetting to when some functions are called list .

Have no eﬀect on streams .

Output :    USD  USD .

Output : The number in fixed : The number in scientific : The number in hexfloat : The number in default : Parsing Complete Tips Secrets for Professionals .

Have no eﬀect on streams .

Complete Tips Secrets for Professionals .

For more information see the link above .

Section : Output stream manipulators inserts null character ' to output stream .
More formally this declaration looks like template charT , class ,

It causes immediately producing .

Section : Input stream manipulators consumes leading whitespaces input stream .

Complete Tips Secrets for Professionals .

Containers vectors , lists , maps , etc .
Using Templates , containers contain collections of primitives .

Section : Containers Flowchart Choosing which Container to use can be tricky , so simple ﬂowchart to help decide which Container is right for the job .

This ﬂowchart was based on Mikael post .
This little graphic the ﬂowchart is from Megan Hopkins .

These are example of using template metaprogramming processing arithmitic operations compile time .

This example shows an eﬃcient way of calculating using template metaprogramming .

This one also handles negative exponents : template  int .

Sarid Chapters and aaronsnoswell Chapter Abhinav Gauniyal Chapter Abyx Chapter Adam Trhon Chapter Adhokshaj Mishra Chapter ADITYA Chapter Ajay Chapters , and alain Chapter Alejandro Chapter Alexey Guseynov Chapter Alexey Voytenko Chapters and Chapters , and amchacon Chapter Ami Tavory Chapters , and Chapter anatolyg Chapters and anderas Chapters , and Andrea Chua Chapters , and Andrea Corbelli Chapters , and AndyG Chapters and Chapter anotherGatsby Chapters and Antonio Barreto Chapter AProgrammer Chapter Aravind Chapter ArchbishopOfBanterbury Chapters , and Artalus Chapter asantacreu Chapter Asu Chapter Ates Goral Chapter Bakhtiar Hasan Chapter Baron Chapter Chapters , Barry , and bcmpinc Chapter Ben Chapter Ben Steﬀan Chapter Benjy Kessler Chapter BigONotation Chapter Bim Chapters and Chapters , Brian , and II Chapter CaﬀeineToCode Chapters and callyalater Chapters , and Complete Tips Secrets for Professionals Candlemancer caps celtschk Chachmu Cheers and hth .

Mark Gardner MasterHD MathSquared Matt Matthew Brien Matthieu .

Chapters and Chapters , and Chapters , and Chapters and Chapter Chapter Chapter Chapters , and Chapters , and Chapter Chapter Chapter Chapters and Chapters and Chapters , and Chapter Chapters and Chapter Chapters , and Chapters , and Chapters , and Chapter Chapter Chapters and Chapters , and Chapter Chapters and Chapters , and Chapter Chapter Chapter Chapter Chapter Chapters , and Chapter Chapters and Chapter Chapter Chapter Chapters and Chapters and Chapters and Chapters , and Chapters , and Chapter Chapter Chapters , and Chapter Chapter Chapter Chapter Chapters and Chapter Chapter Complete Tips Secrets for Professionals Maxito Meena Alfons merlinND Meysam Michael Gaskill Mike MikeMB Mikitori mindriot Misgevolution MKAROL mkluwe MotKohn Motti mpromonet MSalters MSD mtb mtk Muhammad Aladdin .

Naor Hadar Nathan Osman Naveen Mittal Neil .

Nemanja Boric Niall Nicholas Nicol Bolas Nikola Vasilev Nitinkumar Ambekar nnrales NonNumeric Null nwp Omnifarious Oz .

Pankaj Kumar Boora patmanpato Patryk Obara paul Paul Beckingham Pavel Strakhov PcAF Perette Barella Peter phandinhlan Pietro Saccardi plasmacel pmelanson Podgorskiy Praetorian Pyves Chapter Chapter Chapter Chapter Chapters , and Chapter Chapter Chapter Chapter Chapters and Chapter Chapter Chapter Chapter Chapters , and Chapters and Chapters and Chapter Chapter Chapter Chapter Chapter Chapters and Chapter Chapters , and Chapter Chapter Chapters , and Chapters , and Chapter Chapters , and Chapters , and Chapter Chapter Chapter Chapters , and Chapter Chapter Chapter Chapter Chapters and Chapter Chapters and Chapter Chapter Chapters and Chapters and Chapter Chapters , and Chapter Chapter Chapter Chapter Chapter Chapters and Chapter Complete Tips Secrets for Professionals Qchmqs Quirk .
Martinho Fernandes ralismark RamenChef Ravi Chandra Reuben Thomas Richard Dally rockoder rodrigo Roland RomCoo Ronen Ness rtmh Rushikesh Deshpande Ryan Haining Saint SajithP Samer Tufail Sean Sergey Serikov Shoe sigalor silvergasp SingerOfTheFall SirGuy Skipper Skywrath Smeeheey Snowhawk stackptr Stephen sth Stradigos strangeqargo .
