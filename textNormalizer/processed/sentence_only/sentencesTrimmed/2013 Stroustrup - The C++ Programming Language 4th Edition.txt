San Francisco New York .

Mexico City Many of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks .
Where those designations appear in this book , and the publisher was aware of trademark claim , the designations have been printed with initial capital letters or in all capitals .

The author and publisher have taken care in the preparation of this book , but make no expressed or implied warranty of any kind and assume no responsibility for errors or omissions .
No liability is assumed for incidental or consequential damages in connection with or arising out of the use of the information or programs contained herein .

The publisher offers excellent discounts on this book when ordered in quantity for bulk purchases or special sales , which may include electronic versions custom covers and content particular to your business , training goals , marketing focus , and branding interests .
For more information , please contact : The United States Corporate and Government Sales For sales outside the United States , please contact : International Sales Visit us on the Web : Library of Congress Data Stroustrup , Bjarne .

The programming language Bjarne edition .

programming .

Copyright by Pearson Education , Inc .

All rights reserved .
Printed in the United States of America .
This publication is protected by copyright , and permission must be obtained from the publisher prior to any prohibited reproduction , storage in retrieval system , or transmission in any form or by any means , electronic , mechanical , photocopying , recording , or likewise .
To obtain permission to use material from this work , please submit written request to Pearson Education , Permissions Department , One Lake Street , Upper Saddle River , New Jersey , or you may fax your request to .

This book was typeset in Times and Helvetica by the author .

: Te xt printed in the United States on recycled paper at Edwards Brothers Malloy in Ann Arbor , Michigan .

Second printing , June Contents Contents iii Preface Preface to the Fourth Edition .
Notes to the Reader .
Tour of : The Basics .
Tour of : Abstraction Mechanisms .
Tour of : Containers and Algorithms .
Tour of : Concurrency and Utilities .
Types and Declarations .
Pointers , Arrays , and References .
Structures , Unions , and Enumerations .
Select Operations .
Exception Handling .
Source Files and Programs .
Construction , Cleanup , Copy , and Move .
Special Operators .
Derived Classes .

Type Information .
Generic Programming .

Matrix Design .
Standard Library Summary .
STL Containers .
STL Algorithms .
STL Iterators .
Memory and Resources .
Regular Expressions .

Threads and Tasks .

Wheeler feels like new .
That is , can express my ideas more clearly , more simply , and more directly in than could in .
Furthermore , the resulting programs are better checked by the compiler and run faster .

In this book , aim for completeness .
describe every feature and component that professional programmer is likely to need .

Rationale : What kinds of problems is it designed to help solve .
What principles underlie the design .
What are the fundamental limitations .

Speciﬁcation : What is its deﬁnition .
The level of detail is chosen for the expert programmer ; the aspiring lawyer can follow the many references to the ISO standard .

Examples : How can it be used well by itself and in combination with other features .
What are the key techniques and idioms .
What are the implications for maintainability and performance .

The use of has changed dramatically over the years and so has the itself .
From the point of view of programmer , most of the changes have been improvements .
The current ISO standard , usually called is simply far better tool for writing quality software than were previous versions .

What kinds of programming styles and techniques does modern support .
What and features support those techniques .
What are the basic building blocks of elegant , correct , maintainable , and efﬁcient code .
Those are the key questions answered by this book .
Many answers are not the same as you would ﬁnd with , or vintage : progress happens .

is programming emphasizing the design and use of , lightweight abstractions .
It is particularly suited for applications , such as those found in software infrastructures .
rewards the programmer who takes the time to master vi Preface techniques for writing quality code .
is for someone who takes the task of programming seriously .
Our civilization depends critically on software ; it had better be quality software .

There are billions of lines of deployed .
This puts premium on stability , so and code still works and will continue to work for decades .
However , for all applications , you can do better with modern ; if you stick to older styles , you will be writing and code .
The emphasis on stability also implies that code you write today will still work couple of decades from now .
All code in this book conforms to the ISO standard .

This book is aimed at three .

programmers who want to know what the latest ISO standard has to .

programmers who wonder what provides beyond , and .

People with background in application languages , such as Java , Python , and Ruby , looking for something to the machine " something more ﬂexible , something offering better checking , or something offering better performance .

Naturally , these three groups are not disjoint professional software developer masters more than just one programming .

This book assumes that its readers are programmers .
If you ask , or " then this book is not for you ; instead , recommend my Programming : Principles and Practice Using to get started with programming and .
Furthermore , Karen Blixen , Notes to the Reader Hurry Slowly .

The Structure of This Book Introduction ; Basic Facilities ; Abstraction Mechanisms ; The Standard Library ; Examples and References .

The Design of Programming Styles ; Type Checking ; Compatibility ; Language , Libraries , and Systems .

Learning Programming in ; Suggestions for Programmers ; Suggestions for Programmers ; Suggestions for Java Programmers .

History Timeline ; The Early Years ; The Standard ; The Standard ; What is Used for .

References The Structure of This Book pure tutorial sorts its topics so that no concept is used before it has been introduced ; it must be read linearly starting with page one .
Conversely , pure reference manual can be accessed starting at any point ; it describes each topic succinctly with references and to related topics .
pure tutorial can in principle be read without prerequisites it carefully describes all .
pure reference can be used only by someone familiar with all fundamental concepts and techniques .

This book combines aspects of both .
If you know most concepts and techniques , you can access it on or even on basis .
If not , you can start at the beginning , but try not to get bogged down in details .
Use the index and the .

The book is heavily both to itself and to the ISO standard .
Experienced programmers can read the quick " of to gain the overview needed to use the book as reference .
This book consists of four parts : Part Introduction : Chapter is guide to this book and provides bit of background .
Chapters give quick introduction to the language and its standard library .

Part II Basic Facilities : Chapters describe types and the basic facilities for constructing programs out of them .

Part III Abstraction Mechanisms : Chapters describe abstraction mechanisms and their use for and generic programming .

Part IV Chapters provide an overview of the standard library and discussion of compatibility issues .

You are encouraged to skim through it , read what appears interesting , and return to it after reading other parts of the book .
Please do not feel obliged to read it all carefully before proceeding .

The following chapters provide an overview of the major concepts and features of the programming language and its standard library : Chapter Tour of : The Basics describes model of memory , computation , and error handling .

Chapter Tour of : Abstraction Mechanisms presents the language features supporting data abstraction , programming , and generic programming .

Chapter Tour of : Containers and Algorithms introduces strings , simple , containers , and algorithms as provided by the standard library .

Chapter Tour of : Concurrency and Utilities outlines the utilities related to resource management , concurrency , mathematical computation , regular expressions , and more .

This whirlwind tour of facilities aims to give the reader taste of what offers .
In particular , it should convince readers that has come long way since the ﬁrst , second , and third editions of this book .

It introduces the notions of type , object , scope , and storage .
It presents the fundamentals of computation : expressions , statements , and functions .
Modularity as supported by namespaces , source ﬁles , and exception handling is also discussed : Chapter Types and Declarations : Fundamental types , naming , scopes , initialization , simple type deduction , object lifetimes , and type aliases Section Basic Facilities Chapter Pointers , Arrays , and References Chapter Structures , Unions , Enumerations Chapter Statements : Declarations as statements , selection statements , iteration statements , while , goto , comments Chapter Expressions : desk calculator example , survey of operators , constant expressions , implicit type conversion .

Chapter Select Operations : Logical operators , the conditional expression , increment decrement , free store , lambda expressions , explicit Chapter Functions : Function declarations deﬁnitions , inline functions , constexpr functions , argument passing , overloaded functions , postconditions , pointers to functions , macros Chapter Exception Handling : Styles of error handling , exception guarantees , resource management , enforcing invariants , throw catch , vector implementation Chapter Namespaces : namespace , modularization interface , composition using namespaces Chapter Source Files Programs : Separate compilation , linkage , using header ﬁles , program start termination assume that you are familiar with most of the programming concepts used in Part .
For example , explain the facilities for expressing recursion iteration , but do not go into technical details or spend much time explaining how these concepts are useful .

The exception to this rule is exceptions .
Many programmers lack experience with exceptions or got their experience from languages as where resource management exception handling are not integrated .
Consequently , the chapter on exception handling presents the basic philosophy of exception handling resource management .
It goes into some detail about strategy with focus on the Acquisition Is Initialization " technique .

The chapters fall into three rough categories : classes , class hierarchies , templates .

The ﬁrst four chapters concentrate of the classes themselves : Chapter Classes : The notion of type , class , is the foundation of all abstraction mechanisms .

Chapter Construction , Cleanup , Copy , Move shows how programmer can deﬁne the meaning of creation initialization of objects of class .
Further , the meaning of copy , move , destruction can be speciﬁed .

Chapter Operator Overloading presents the rules for giving meaning to operators for types with an emphasis on conventional arithmetic logical operators , such as +

Chapter Special Operators discusses the use of operator for purposes , such as for subscripting , for function objects , for Notes to the Reader Chapter Classes can be organized into hierarchies : Chapter Derived Classes presents the basic language facilities for building hierarchies out of classes the fundamental ways of using them .
We can provide complete separation between an interface abstract its implementations ; the connection between them is provided by virtual functions .

The model for access control , protected , is presented .

Chapter Class discusses ways of using class hierarchies effectively .
It also presents the notion of multiple inheritance , that is , class having more than one direct base class .

Chapter Type Information presents ways to navigate class hierarchies using data stored in objects .
We can use to inquire whether an object of base class was deﬁned as an object of derived class use the typeid to gain minimal information from an object as the name of its .

Many of the most ﬂexible , efﬁcient , useful abstractions involve the parameterization of types algorithms with other types algorithms : Chapter Templates presents the basic principles behind templates their use .
Class templates , function templates , template aliases are presented .

Chapter Generic Programming introduces the basic techniques for designing generic programs .
The technique of lifting an abstract algorithm from number of concrete code examples is central , as is the notion of concepts specifying generic requirements on its arguments .

Chapter Specialization describes how templates are used to generate classes functions , specializations , giv en set of template arguments .

Chapter Instantiation focuses on the rules for name binding .

Chapter Templates explains how templates class hierarchies can be used in combination .

Chapter Metaprogramming explores how templates can be used to generate programs .

Templates provide mechanism for generating code .

Chapter Matrix Design gives longish example to show how language features can be used in combination to solve complex design problem : the design of an Ndimensional matrix with element types .

The language features supporting abstraction techniques are described in the context of those techniques .
The presentation technique in Part III differs from that of Part II in that assume that the reader knows the techniques described .

In particular , they are meant to be read in any order and can be used as manual for the library components : Chapter Overview gives an overview of the standard library , lists the headers , and presents language support and diagnostics support , such as exception and .

Chapter STL Containers presents the containers from the iterators , containers , and algorithms framework the , including vector , map , and .

Chapter STL Iterators presents iterators and other utilities from the STL , including , and function .

Chapter Memory and Resources presents utility components related to memory and resource management , such as array , bitset , pair , tuple , allocators , and the garbage collector interface .

Chapter Utilities presents minor utility components , such as time utilities , type traits , and various type functions .

Chapter Strings documents the string library , including the character traits that are the basis for the use of different character sets .

Chapter Regular Expressions describes the regular expression syntax and the various ways of using it for string matching , including for matching for simple replacement , and for general traversal of stream of characters .

Chapter Streams documents the stream library .
It describes formatted and unformatted input and output , error handling , and buffering .

Chapter Locales describes class locale and its various facets that provide support for the handling of cultural differences in character sets , formatting of numeric values , formatting of date and time , and more .

Chapter Numerics describes facilities for numerical computation as complex , valarray , random numbers , and generalized numerical .

Chapter Concurrency presents the basic memory model and the facilities offered for concurrent programming without locks .

Chapter Threads and Tasks presents the classes providing concurrent programming as thread , and and the support for concurrency as future and .

Chapter The Standard Library documents the standard library and as incorporated into the standard library .

Chapter Compatibility discusses the relation between and and between Standard called ISO and the versions of that preceded it .

Consequently , avoid clever or algorithms .
trivial algorithm is typically better suited to illustrate an aspect of the language deﬁnition or point about program structure .
For example , use Shell sort where , in real code , quicksort would be better .
Often , reimplementation with more suitable algorithm is an exercise .
In real code , call of library function is typically more appropriate than the code used here to illustrate language features .

Te xtbook examples necessarily give warped view of software development .
By clarifying and simplifying the examples , the complexities that arise from scale disappear .
see no substitute for writing realistically sized programs in order to get an impression of what programming and Notes to the Reader Chapter programming language are really like .
This book concentrates on the language features and the facilities .
These are the basic techniques from which every program is composed .

The rules and techniques for such composition are emphasized .

The selection of examples reﬂects my background in compilers , foundation libraries , and simulations .
The emphasis reﬂects my interest in systems programming .
Examples are simpliﬁed versions of what is found in real code .
The simpliﬁcation is necessary to keep programming language and design points from getting lost in details .
My ideal is the shortest and clearest example that illustrates design principle , programming technique , language construct , or library feature .

There are no " examples without counterparts in real code .
For purely examples , use variables named and , types called and , and functions called and .

Where possible , the language and library features are presented in the context of their use rather than in the dry manner of manual .
The language features presented and the detail in which they are described roughly reﬂect my view of what is needed for effective use of .
The purpose is to give you an idea of how feature can be used , often in combination with other features .
An understanding of every detail of language feature or library component is neither necessary nor sufﬁcient for writing good programs .
In fact , an obsession with understanding ev ery little detail is prescription for awful overelaborate and overly clever code .
What is needed is an understanding of design and programming techniques together with an appreciation of application domains .

assume that you have access to online information sources .
The ﬁnal arbiter of language and rules is the ISO standard .

References to parts of this book are of the form , section , subsection and standard ,
Italics are used sparingly for emphasis , string literal is not , for ﬁrst occurrences of important concepts , and for comments in code examples .

To sav few trees and to simplify additions , the hundreds of exercises for this book have been moved to the Web .

The language and library used in this book are " as deﬁned by the standard .
Therefore , the examples should run on every implementation .
The major program fragments in this book were tried using several implementations .
Examples using only recently adopted into compile on every implementation .
However , see no point in mentioning which implementations failed to compile which examples .
Such information would soon be out of date because implementers are working hard to ensure that their implementations correctly accept every feature .
See Chapter for suggestions on how to cope with older compilers and with code written for compilers .

use freely wherever ﬁnd them most appropriate .
For example , prefer initializers and using for type aliases .
In places , that usage may startle " Howev er , being startled is often good way to start reviewing material .
On the other hand , use just because they are  ideal is the most elegant expression of the fundamental ideas and that may very well be using something that has been in or even in for ages .

Obviously , if you have to use compiler , because some of your customers have not yet upgraded to the current , you have to refrain from using novel .
However , please assume that old ways " are better or simpler just because they are old and familiar .

In that , programming language performs two related tasks : it provides vehicle for the programmer to specify actions to be executed by the machine , and it provides set of concepts for the programmer to use when thinking about what can be done .
The ﬁrst purpose ideally requires language that is to the machine " so that all important aspects of machine are handled simply and efﬁciently in way that is reasonably obvious to the programmer .
The language was primarily designed with this in so that the concepts of solution can be expressed directly and concisely .
The facilities added to to create , such as function argument checking , const , classes , constructors and destructors , exceptions , and templates , were primarily designed with this in mind .
Thus , is based on the idea of providing both .

This was initially achieved by applying ideas from Simula to .
Over the years , further application of these simple ideals resulted in far more general , efﬁcient , and ﬂexible set of facilities .
The result supports synthesis of programming styles that can be simultaneously efﬁcient and elegant .

The design of has focused on programming techniques dealing with fundamental notions such as memory , mutability , abstraction , resource management , expression of algorithms , error handling , and modularity .
Those are the most important concerns of systems programmer and more generally of programmers of and systems .

By deﬁning libraries of classes , class hierarchies , and templates , you can write programs at much higher level than the one presented in this book .
For example , is widely used in ﬁnancial systems , for game development , and for scientiﬁc computation .
For applications programming to be effective and convenient , we need libraries .
Using just the bare language makes almost all programming quite painful .
true for every language .
Conversely , giv en suitable libraries just about any programming task can be pleasant .

My standard introduction of used to .

is programming language with bias toward systems programming .

This is still true .
What has changed over the years is an increase in the importance , power , and ﬂexibility of abstraction .

is programming language pro viding direct and efﬁcient model of hardware combined with facilities for deﬁning lightweight abstractions .

is language for developing and using elegant and efﬁcient abstractions .

By programming language mean language designed to support wide variety of uses .
has indeed been used for an incredible variety of uses microcontrollers to huge distributed commercial , but the key point is that is not deliberately specialized for any giv en application area .
No language is ideal for every application and every programmer , but the ideal for is to support the widest possible range of application areas well .

In particular , the implementation of software infrastructure , device drivers , communications stacks , virtual machines , operating systems , operations systems , programming environments , and foundation is mostly systems programming .
The importance of the toward systems programming " qualiﬁcation in characterization of is that has not been simpliﬁed by ejecting the facilities aimed at the use of hardware and systems resources in the hope of making it more suitable for other application areas .

Of course , you can also program in ways that completely hide hardware , use expensive abstractions , every object on the free store and every operation virtual , use inelegant styles , or use essentially no abstractions assembly .
However , many languages can do that , so those are not distinguishing characteristics of .

The Design and Evolution of book as outlines the ideas and design aims of in greater detail , but two principles should be .

Leave no room for language below for assembly code in rare .
If you can write more efﬁcient code in language then that language will most likely become the systems programming language of choice .

If programmers can reasonable code to simulate language feature or fundamental abstraction and provide even slightly better performance , someone will do so , and many will imitate .
Therefore , language feature and fundamental abstraction must be designed not to waste single byte or single processor cycle compared to equivalent alternatives .
This is known as the principle .

These are Draconian principles , but essential in some obviously not contexts .
In particular , the principle repeatedly led to simpler , more elegant , and more powerful facilities than were ﬁrst envisioned .
The STL is an example , Chapter , Chapter , Chapter .
These principles have been essential in the effort to raise the level of programming .

Please look at an individual language feature as solution , but as one building brick from varied set which can be combined to express solutions .

The general ideals for design and programming can be expressed .

Express ideas directly in code .

Express independent ideas independently in code .

Represent relationships among ideas directly in code .

Combine ideas expressed in code freely where and only where combinations make sense .

Express simple ideas simply .

These are ideals shared by many people , but languages designed to support them can differ dramatically .
fundamental reason for that is that language embodies set of engineering tradeoffs reﬂecting differing needs , tastes , and histories of various individuals and communities .
answers to the general design challenges were shaped by its origins in systems programming back to and BCPL , its aim to address issues of program complexity through abstraction back to , and its history .

Generic programming However , the emphasis is on the support of effective combinations of those .
The best maintainable , most readable , smallest , fastest , solution to most nontrivial problems tends to be one that combines aspects of these styles .

As is usual with important terms in the computing world , wide variety of deﬁnitions of these terms are popular in various parts of the computing industry and academia .
For example , what refer to as " others call technique " or " prefer to use technique " for something more limited and .
feel uncomfortable with the word " as pretentious and original having implied claims of exclusivity .

My ideal is language facilities that can be used elegantly in combination to support continuum of programming styles and wide variety of programming techniques .

Procedural programming : This is programming focused on processing and the design of suitable data structures .
It is what was designed to support Algol , and Fortran , as well as many other .
support comes in the form of the types , operators , statements , functions , structs , unions , etc .
With minor exceptions , is subset of .
Compared to , provides further support for procedural programming in the form of many additional language constructs and stricter , more ﬂexible , and more supportiv type system .

Data abstraction : This is programming focused on the design of interfaces , hiding implementation details in general and representations in particular .
supports concrete and abstract classes .
The facilities for deﬁning classes with private implementation details , constructors and destructors , and associated operations directly support this .
The notion of an abstract class provides direct support for complete data hiding .

programming : This is programming focused on the design , implementation , and use of class .
In addition to allowing the deﬁnition lattices of classes , provides variety of features for navigating class lattices and for simplifying the deﬁnition of class out of existing ones .
Class provide polymorphism , and encapsulation ,

Generic programming : This is programming focused on the design , implementation , and use of general algorithms .
Here , means that an algorithm can be designed to accept wide variety of types as long as they meet the requirements on its arguments .

The template is main support for generic programming .
Templates provide parametric polymorphism .

Just about anything that increases the ﬂexibility or efﬁciency of classes improves the support of all of those styles .
Thus , could be has called class oriented .

Each of these styles of design and programming has contributed to the synthesis that is .

Focusing exclusively on one of these styles is mistake : except for toy examples , doing so leads to wasted development effort and suboptimal , verbose , poorly performing , unmaintainable , code .

The former misses the fact that all the styles mentioned have contributed something signiﬁcant to the synthesis ; the latter denies the validity of the synthesis .
The styles mentioned are not distinct alternatives : each contributes techniques to more expressive and effective style of programming , and provides direct language support for their use in combination .

From its inception , the design of aimed at synthesis of programming and design styles .

Even the earliest published account of presents examples that use these different styles in combination and presents language features aimed at supporting such .

Classes support all of the mentioned styles ; all rely on the user representing ideas as userdeﬁned types or objects of types .

access control supports data abstraction and programming by making clear distinction between interface and implementation .

Member functions , constructors , destructors , and assignment provide clean functional interface to objects as needed by data abstraction and programming .
They also provide uniform notation as needed for generic programming .
More general overloading had to wait until and uniform initialization until .

Function declarations provide speciﬁc statically checked interfaces to member functions as well as freestanding functions , so they support all of the mentioned styles .

At the time , lacked prototypes " but Simula had function declarations as well as member functions .

Generic functions and parameterized types from functions and classes using support generic programming .
Templates had to wait until .

Base and derived classes provide the foundation for programming and some forms of data abstraction .
Virtual functions had to wait until .

Inlining made the use of these facilities affordable in systems programming and for building and space efﬁcient libraries .

These early features are general abstraction mechanisms , rather than support for disjoint programming styles .
provides much better support for design and programming based on lightweight abstraction , but the aim of elegant and efﬁcient code was there from the very beginning .

The developments since provide much better support for the synthesis of the programming styles originally considered and signiﬁcantly improve their integration .

The fundamental object in has identity ; that is , it is located in speciﬁc location in memory and can be distinguished from other objects with the same value by comparing addresses .
Expressions denoting such objects are called lvalues .
However , even from the earliest days of ancestors there have also been objects without identity for which an address cannot be safely stored for later .
In , this notion of rvalue has been developed into notion of value that can be moved around cheaply ,
Such objects are the basis of techniques that resemble what is found in functional programming the notion of objects with identity is viewed with .
This nicely complements the techniques and language features , lambda developed primarily for .
Stroustrup : Operator Overloading in .
IFIP Conference on System Implementation Languages : Experience Assessment .

Stroustrup : An Extensible Facility for .
Summer USENIX Conference .

Stroustrup : Multiple Inheritance for .
EUUG Spring Conference .

Stroustrup and .
Shopiro : Set of Classes for Style Programming .

USENIX Conference .

Santa Fe , New Mexico .

Stroustrup : Parameterized Types for .
USENIX Conference , Denver .

Stroustrup : The Programming Language .

Stroustrup : History of :
ACM History of Programming Languages conference .
ACM Sigplan Notices .

Stroustrup : The Design and Evolution of .

Stroustrup : The Programming Language , Third Edition .
Hardcover Edition .

Stroustrup : and : Siblings , and : Case for Compatibility , and and : Case Studies in Compatibility .
The Users Journal .

Stroustrup : Evolving language in and for the real world :

Stroustrup : Programming Principles and Practice Using .

Stroustrup : The FAQ .

Stroustrup : The Concepts " Decision .

Stroustrup and .
Sutton : Concept Design for the STL .

Stroustrup : Software Development for Infrastructure .

Sutton and .
Stroustrup : Design of Concept Libraries for .

SLE Conference on Software Language .

Tanenbaum : Modern Operating Systems , Third Edition .
Upper Saddle River , New Jersey .

Research Version , Tenth Edition .
Bell Laboratories , Murray Hill , New Jersey .

Josuttis : Templates : The Complete Guide .

Veldhuizen : Templates are Turing Complete .
Indiana University Computer Science Technical .

ACM Transactions on Mathematical Software , Vol .

Manning Publications Co .

Wilson and Paul Lu : Parallel Programming Using .

The MIT Press .

Woodward and .
Bond : Algol Users Guide .
Her Stationery Ofﬁce .

The Basics Hello , Types , Variables , and Arithmetic ; Constants ; Tests and Loops ; Pointers , Arrays , and Loops .

Types Structures ; Classes ; Enumerations .

Modularity Separate Compilation ; Namespaces ; Error Handling .

Advice Introduction The aim of this chapter and the next three is to give you an idea of what is , without going into lot of details .
This chapter informally presents the notation of , model of memory and computation , and the basic mechanisms for organizing code into program .
These are the language facilities supporting the styles most often seen in and sometimes called procedural programming .
Chapter follows up by presenting abstraction mechanisms .
Chapter and Chapter give examples of facilities .

The assumption is that you have programmed before .
If not , please consider reading textbook , such as Programming : Principles and Practice Using , before continuing here .
Even if you have programmed before , the language you used or the applications you .

There is only one nullptr shared by all pointer types : nullptr ; nullptr ; pointer to Link to int nullptr ; error  nullptr is pointer not an integer It is often wise to check that pointer argument that is supposed to point to something , actually points to something : the number of occurrences of in .

The deﬁnition of assumes that the is string , that is , that the pointer points to array of char .

In older code , or NULL is typically used instead of nullptr .
However , using nullptr eliminates potential confusion between integers as or and pointers as .

set of types and operations is rich , but deliberately .
They directly and efﬁciently reﬂect the capabilities of conventional computer hardware .
However , they provide the programmer with facilities to conveniently write advanced applications .
Instead , augments the types and operations with sophisticated set of abstraction mechanisms out of which programmers can build such highlevel facilities .
The abstraction mechanisms are primarily designed to let programmers design and implement their own types , with suitable representations and operations , and for programmers to simply and elegantly use such types .
Types built out of the types using abstraction mechanisms are called types .
They are referred to as classes and enumerations .
Most of this book is devoted to the design , implementation , and use of types .
The rest of this chapter presents the simplest and most fundamental facilities for that .
Chapter is more complete description of the abstraction mechanisms and the programming styles they support .

Chapter and Chapter present an overview of the standard library , and since the standard library mainly consists of types , they provide examples of what can be built using the language facilities and programming techniques presented in Chapter and Chapter .

variable of Vector can be deﬁned like this : Vector  However , by itself that is not of much use because pointer point to anything .
To be useful , we must give some elements to point to .
For example , we can construct Vector like .

The in indicates that we pass by reference , that way , can modify the vector passed to it .

The new allocates memory from an area called the free store known as dynamic memory and heap ;

In particular , user of Vector has to know every detail of representation .
The rest of this chapter and the next gradually improve Vector as an example of language features and techniques .

Chapter presents the vector , which contains many nice improvements , and Chapter presents the complete vector in the context of other facilities .

use vector and other components as examples .

reinvent components , such as vector and string ; use them .

However , tighter connection between the representation and the operations is needed for to have all the properties expected of " In particular , we often want to keep the representation inaccessible to users , so as to ease use , guarantee consistent use of the data , and allow us to later improve the representation .
To do that we have to distinguish between the interface to be used by and its implementation has access to the otherwise inaccessible .
The language mechanism for that is called class .
class is deﬁned to have set of members , which can be data , function , or members .
The interface is deﬁned by the public members of class , and private members are accessible only through that interface .
For example : Section Classes class Vector .

The number of elements in the can vary from Vector object to Vector object , and Vector object can have different number of elements at different times .
However , the Vector object itself is always the same size .
This is the basic technique for handling varying amounts of information in : handle referring to variable amount of data " on the free store allocated by 

Here , the representation of Vector members and is accessible only through the example from simpliﬁes .

So , the constructor , replaces from .
Unlike an ordinary function , constructor is guaranteed to be used to initialize objects of its class .
Thus , deﬁning constructor eliminates the problem of uninitialized variables for class .

In particular , it states that it needs an integer to do that .
That integer is used as the number of elements .
The constructor initializes the Vector members using member initializer list : That is , we ﬁrst initialize with pointer to elements of obtained from the free store .
Then , we initialize to .

Access to elements is provided by subscript function , called .
It returns reference to the appropriate element .

The function is supplied to give users the number of elements .

Obviously , error handling is completely missing , but return to that in .
Similarly , we did not provide mechanism to back " the array of doubles acquired by  shows how to use destructor to elegantly do that .

Note that enumerators , are in the scope of their enum class , so that they can be used repeatedly in different enum classes without confusion .
For example , is red which is different from .

Enumerations are used to represent small sets of integer values .
They are used to make code more readable and less than it would have been had the symbolic enumerator names not been used .

The class after the enum speciﬁes that an enumeration is strongly typed and that its enumerators are scoped .
Being separate types , enum classes help prevent accidental misuses of constants .
In particular , we cannot mix and values : red ; error  which red .

By default , an enum class has only assignment , initialization , comparisons , deﬁned .
However , an enumeration is so we can deﬁne operators for it : Section Enumerations .

also offers less strongly typed " enum .

The key to managing this is to clearly deﬁne the interactions among those parts .
The ﬁrst most important step is to distinguish between the interface to part its implementation .
At the language level , represents interfaces by declarations .
declaration speciﬁes all needed to use function or .
For example : the square root function takes returns .

We must deﬁne functions , but not because it is part of the standard library .
Howev er , that makes no real difference : library is simply some code we happen to use " written with the same language facilities as we use .

The deﬁnitions of those types functions are in separate source ﬁles compiled separately .
This can be used to organize program into set of code fragments .
Such separation can be used to minimize compilation times to strictly enforce separation of logically distinct parts of program minimizing the chance of .
library is often separately compiled code fragments ,

Typically , we place the declarations that specify the interface to module in ﬁle with name indicating its intended use .

The code in shares the Vector interface information presented in , but the two ﬁles are otherwise independent can be separately compiled .
Graphically , the program fragments can be represented like this : Vector interface deﬁne Vector : Strictly speaking , using separate compilation isn ' language issue ; it is an issue of how best to take advantage of particular language implementation .
However , it is of great practical importance .
The best approach is to maximize modularity , represent that modularity logically through language features , then exploit the modularity physically through ﬁles for effective separate compilation , Chapter .

For example , might want to experiment with my own complex number type ,

By putting my code into the namespace , make sure that my names do not conﬂict with the names in namespace std .
The precaution is wise , because the standard library does provide support for complex arithmetic ,

The simplest way to access name in another namespace is to qualify it with the namespace name ,
The  is deﬁned in the global namespace , that is , not local to deﬁned namespace , class , or function .
To gain access to names in the namespace , we can use : using namespace std ; Namespaces are primarily used to organize larger program components , such as libraries .
They simplify the composition of program out of separately developed parts .

However , provides few features to help .
The major tool is the type system itself .
Instead of painstakingly building up our applications from the types , char , int , statements , if , while , we build more types that are appropriate for our applications , string , map , algorithms ,
Such higher level constructs simplify our programming , limit our opportunities for mistakes , you are unlikely to try to apply tree traversal to dialog , Section Error Handling and increase the chances of catching such errors .
The majority of constructs are dedicated to the design and implementation of elegant and efﬁcient abstractions , types and algorithms using .
One effect of this modularity and abstraction particular , the use of is that the point where error can be detected is separated from the point where it can be handled .
As programs grow , and especially when libraries are used extensively , standards for handling errors become important .

What ought to be done when we try to access an element that is out of range for the vector from .

The writer of Vector know what the user would like to hav done in this case writer of Vector typically even know in which program the vector will be .

The user of Vector cannot consistently detect the problem the user could , the access happen in the ﬁrst .

The solution is for the Vector implementer to detect the attempted access and then tell the user about it .
The user can then take appropriate action .
For example , can detect an attempted access and throw an out_of_range

Therefore , the providing handler for out_of_range will be entered .
The out_of_range type is deﬁned in the standard library and is in fact used by some container access functions .

Use of the mechanisms can make error handling simpler , more systematic , and more readable .
See Chapter for further discussion , details , and examples .

Had we formally speciﬁed subscript operator , we would have said something like index must be in the " and that was in fact what we tested in our .
Whenever we deﬁne function , we should consider what its preconditions are and if feasible test them ,

However , operates on objects of type Vector and nothing it does makes any sense unless the members of Vector have " values .
In particular , we did say points to an array of sz doubles " but we only said that in comment .
Such statement of what is assumed to be true for class is called class invariant , or simply an invariant .
It is the job of constructor to establish the invariant for its class that the member functions can rely on and for the member functions to make sure that the invariant holds when they exit .
Unfortunately , our Vector constructor only partially did its job .
It properly initialized the Vector members , but it failed to check that the arguments passed to it made sense .
Consider : Vector ; This is likely to cause chaos .

You deﬁne your own classes to be used as exceptions and have them carry arbitrary information from point where an error is detected to point where it be handled .

Often , function has no way of completing its assigned task after an exception is thrown .

Then , an exception simply means doing some minimal local cleanup and rethrowing the exception .

The notion of invariants underlies ' notions of resource management supported by constructors and destructors ,

If an error be found at compile time , it is usually preferable to do so .
That ' what much of the type system and the facilities for specifying the interfaces to types are for .
Howev er , we also perform simple checks on other properties that are known at compile time and report failures as compiler error messages .
For example : are too ; check integer This will write integers are too small does not hold , that is , an int on this system does not have at least bytes .
We call such statements of expectations assertions .

The mechanism be used for anything that be expressed in terms of constant expressions ,

In general , prints as compiler error message is not true .

The most important uses of come when we make assertions about types used as parameters in generic programming ,

For assertions , see .

Those are the parts of that underlie all programming techniques and styles supported by .

Experienced and programmers , please note that this foundation does not closely correspond to the or subsets of is ,

All will become clear in time ;

Classes Concrete Types ; Abstract Types ; Virtual Functions ; Class Hierarchies .

Copy and Move Copying Containers ; Moving Containers ; Resource Management ; Suppressing Operations .

Templates Parameterized Types ; Function Templates ; Function Objects ; Variadic Templates ; Aliases .

Advice Introduction This chapter aims to give you an idea of ' support for abstraction and resource management without going into lot of detail .
It informally presents ways of deﬁning and using new types .
In particular , it presents the basic properties , implementation techniques , and language facilities used for concrete classes , abstract classes , and class hierarchies .
Templates are introduced as mechanism for parameterizing types and algorithms with types and algorithms .
Computations on and types are represented as functions , sometimes generalized to template functions and function objects .
These are the language facilities supporting the programming styles known as programming and generic programming .
The next two chapters follow up by presenting examples of facilities and their use .

The assumption is that you have programmed before .
If not , please consider reading textbook , such as Programming : Principles and Practice Using , before continuing here .
Even you have programmed before , the language you used or the applications you .

Huge hierarchies , with hundreds of classes , that are both deep and wide are common .
As semirealistic classic example , consider shapes on screen : Shape Circle Triangle Smiley arrows represent inheritance relationships .
For example , Circle is derived from Shape .
To represent that simple diagram in code , we must ﬁrst specify that deﬁnes the general properties of all shapes : Section Class Shape .

Templates are mechanism , so their use incurs no overhead compared to code "

In particular , they are extensively used for parameterization of both types algorithms in the standard library ,
For example , we can write function that calculates the sum of the element values of any container like this : Tour of : Abstraction Mechanisms Chapter Container , typename .

Note how the types of the template arguments for are deduced from the function arguments .
Fortunately , we do not need to explicitly specify those types .

This is simpliﬁed version of the .

For example : class const .

Similarly , more systematic description of the standard library starts in Chapter .

Doing this allows me to give better examples in the following chapters .
As in Chapter Chapter , you are strongly encouraged not to be distracted or discouraged by an incomplete understanding of details .
The purpose of this chapter is to give you taste of what is to come to convey basic understanding of the most useful library facilities .

The speciﬁcation of the standard library is almost two thirds of the ISO standard .
Explore it , prefer it to alternatives .
Much though have gone into its design , more still into its implementations , much effort will go into its maintenance extension .

The facilities described in this book are part of every complete implementation .
In addition to the components , most implementations offer user interface " systems , Web interfaces , database interfaces , etc .
Similarly , most application development execution environments .
Here , do not describe such systems libraries .

The intent is to provide description of as deﬁned by the standard to keep the examples portable , except where speciﬁcally noted .
Naturally , programmer is encouraged to explore the more extensive facilities available on most systems .

language support , for allocation type ; see .

The standard library very minor modiﬁcations to minimize violations of the type ; see Chapter .

Strings and streams support for international character sets and ; see Chapter , Chapter , and Chapter .
streams is an extensible framework to which users can add their own streams , buffering strategies , and character sets .

framework of containers as vector and and algorithms as , and ; see , Chapters .
This framework , conventionally called the STL , is extensible so users can add their own containers and algorithms .

Support for numerical computation as standard mathematical functions , complex numbers , vectors with arithmetic operations , and random number ; see and Chapter .

Support for regular expression matching ; see and Chapter .

Support for concurrent programming , including threads and locks ; see and Chapter .

The concurrency support is foundational so that users can add support for new of concurrency as libraries .

Utilities to support template metaprogramming , type traits ; generic programming , pair ; and general programming , clock ;

containers , such as array , bitset , and tuple .

Essentially , the standard library provides the most common fundamental data structures together with the fundamental algorithms used on them .

For example : This makes the standard string and available .

For example : make the standard string facilities accessible .

However , in this book , use the standard library almost exclusively and it is good to know what it offers .
So , preﬁx every use of standard library name with .
Nor do the appropriate headers in every example .

Here is selection of headers , all supplying declarations in namespace std : array duration , fstream , ifstream , ofstream future , promise istream , ostream , cin , cout Tour of : Containers and Algorithms Chapter map , multimap , allocator , regex , smatch Chapter string , Chapter set , multiset istrstream , ostrstream thread , pair vector This listing is far from complete ; see for more information .

The string type provides variety of useful string operations , such as concatenation .

Here , is initialized to character sequence .
You can concatenate string , string literal , string , or character to string .
The standard string has move constructor so returning even long strings by value is efﬁcient .

In many applications , most common form of concatenation is adding something to end of string .
This is directly supported by operation .

The two ways of adding end of string are semantically equivalent , but prefer latter because it is more explicit about what it does , more concise , possibly more efﬁcient .

string is mutable .
In addition , subscripting substring operations are supported .
The string is described in Chapter .
Among other useful features , it provides ability manipulate substrings .
For example : Section Strings .

The operation returns string that is copy of substring indicated by its arguments .

The ﬁrst argument is an index into string , second is length of desired substring .
Since indexing starts from , gets value Stroustrup .

The operation replaces substring with value .
In this case , substring starting at with length is Niels ; it is replaced by nicholas .
Finally , replace initial character with its uppercase equivalent .
Thus , ﬁnal value of is Nicholas Stroustrup .
Note that replacement string need not be same size as substring that it is replacing .

Naturally , strings can be compared against each other against string literals .

The string library is described in Chapter .
The most common techniques for implementing string are presented in String example .

The input operations are typed extensible handle types .
This section is very brief introduction use of iostreams ; Chapter is reasonably complete description of iostream library facilities .

Other forms of user interaction , such as graphical , are handled through libraries that are not part of ISO standard therefore not described here .

Further , it is easy deﬁne output of type .
The operator is used as an output operator on objects of Tour of : Containers Algorithms Chapter type ostream ; is standard output stream cerr is standard stream for reporting errors .

By default , values written are converted sequence of characters .
For example , output decimal number , we can .

Like ostreams , istreams deal with character string representations of types can easily be extended cope with types .

The operator used as an input operator ; cin standard input stream .
The type of operand of determines what input accepted what target of input operation .

This reads number , such as , from standard input into integer variable ﬂoatingpoint number , such as , into variable .

Often , we want read sequence of characters .
convenient way of doing that read into string .

If you type in Eric response   Eric .

By default , whitespace character , such as space , terminates read , so if you enter Eric Bloodaxe pretending be king of York , response still :  Eric .

You can read whole line terminating newline using function .

With this program , input Eric Bloodaxe yields desired output :  Eric Bloodaxe .

The standard strings have nice property of expanding hold what you put in them ; you hav precalculate maximum size .
So , if you enter couple of megabytes of semicolons , program will echo pages of semicolons back at you .

For example , consider simple type Entry that we might use represent entries in telephone .

output takes its output stream as its ﬁrst argument returns it as its result .
See for details .

The corresponding input more complicated because it has check for correct formatting deal with .

For example , when used as condition , means we succeed at reading from .

An ifstream is an istream that can be attached to ﬁle , and an ofstream is an ostream that can be attached to ﬁle .
The second argument is used to delimit output values .

Actually , this program is longer than it needs to be .
We read the strings into  then we them , and then we write them out , eliminating duplicates .
more elegant solution is not to Tour of : Containers and Algorithms Chapter store duplicates at all .
This can be done by keeping the strings in  which does not keep duplicates and keeps its elements in order .
That way , we could replace the two lines using with one using and replace with the simpler .

Here , we " to delete if or if .
On the other hand , ensures that its object is properly destroyed whichever way we exit throwing an exception , by executing return , or by off the .
Ironically , we could have solved the problem simply by not using pointer not using .

Unfortunately , overuse of of pointers seems to be an increasing problem .

However , when you really need the semantics of pointers , is very lightweight mechanism with no space or time overhead compared to correct use of pointer .
Its further uses include passing allocated objects in out of .

is handle to an individual object an in much the same way that vector is handle to sequence of objects .
Both control the lifetime of other objects both rely on move semantics to make return simple efﬁcient .

The is similar to except that are copied rather than moved .

The for an object share ownership of an object that object is destroyed when the last of its is destroyed .

Note that or may spawn task holding copy of fp or in some other way store copy that outlives .
Thus , provides form of garbage collection that respects the resource management of the objects .
This is neither cost free nor exorbitantly expensive , but does make the lifetime of the shared object hard to predict .
Use only if you actually need shared ownership .

Given  we can implement complete naked  policy for many programs .
However , these pointers " are still conceptually pointers therefore only my second choice for resource management after containers other types that manage their resources at higher conceptual level .
In particular , do not in themselves provide any rules for which of their owners can read write the shared object .
Data races other forms of confusion are not addressed simply by eliminating the resource management issues .

Where do we use pointers " as rather than resource handles with operations designed speciﬁcally for the resource as vector or .
Unsurprisingly , the answer .

When we share an object , we need pointers to refer to the shared object , so becomes the obvious choice there is an obvious single .

When we refer to polymorphic object , we need pointer because we know the exact type of the object referred to or even its , so becomes the obvious choice .

shared polymorphic object typically requires .

We do not need to use pointer to return collection of objects from function ; container that is resource handle will do that simply efﬁciently .

All modern programming languages provide support for this .
The support provided by the standard library is portable variant of what has been used in for more than years is almost universally supported by modern hardware .
The support is primarily aimed at supporting concurrency rather than directly providing sophisticated concurrency models ; those can be supplied as libraries built using the facilities .

The standard library directly supports concurrent execution of multiple threads in single address space .
To allow that , provides suitable memory model set of atomic operations .
However , most users will see concurrency only in terms of the standard library libraries built on top of that .
This section brieﬂy gives examples of the main concurrency support facilities : threads , mutexes , operations , futures .

These features are built directly upon what operating systems offer do not incur performance penalties compared with those .

thread is the representation of task in program .
task to be executed concurrently with other tasks is launched by constructing in with the task as its argument .
task is function or function .

The ISO Standard Implementations ; The Basic Source Character Set .

Types Fundamental Types ; Booleans ; Character Types ; Integer Types ; Types ; Preﬁxes Sufﬁxes ; void ; Sizes ; Alignment .

Declarations The Structure of Declarations ; Declaring Multiple Names ; Names ; Scope ;

Objects Values Lvalues Rvalues ; Lifetimes of Objects .

Advice The ISO Standard The language and standard library are deﬁned by their ISO standard :
In this book , references to the standard are of the form .
In cases where the text of this book is considered imprecise , incomplete , or possibly wrong , consult the standard .
But expect the standard to be tutorial or to be easily accessible by .

Strictly adhering to the language and library standard by itself guarantee good code or even portable code .
The standard say whether piece of code is good or bad ; it simply says what programmer can and cannot rely on from an implementation .
It is easy to write perfectly awful programs , and most programs rely on features that the standard does not guarantee to be portable .
They do so to access system interfaces and Types and Declarations Chapter hardware features that cannot be expressed directly in or require reliance on speciﬁc implementation details .

Many important things are deemed by the standard .
This means that each implementation must provide speciﬁc , behavior for construct and that behavior must be documented .
For example : unsigned char ; well deﬁned : char has at least bits and can always hold unsigned char ; truncation if char has only bits The initialization of well deﬁned because char must be at least bits .
However , the behavior of the initialization of because the number of bits in char .
If the char has only bits , the value will be truncated to .

Most features relate to differences in the hardware used to run program .

Other behaviors are unspeciﬁed ; that  range of possible behaviors are acceptable , but the implementer not obliged to specify which actually occur .
Usually , the reason for deeming something unspeciﬁed that the exact behavior unpredictable for fundamental reasons .
For example , the exact value returned by new unspeciﬁed .
So the value of variable assigned to from two threads unless some synchronization mechanism has been employed to prevent data race .

When writing programs , it usually necessary to rely on behavior .
Such behavior the price we pay for the ability to operate effectively on large range of systems .
For example , would have been much simpler if all characters had been bits and all pointers bits .
However , and character sets are not uncommon , and machines with and pointers are in wide use .

To maximize portability , it wise to be explicit about what features we rely on and to isolate the more subtle examples in clearly marked sections of program .
typical example of this practice to present all dependencies on hardware sizes in the form of constants and type deﬁnitions in some header ﬁle .
To support such techniques , the standard library provides .
Many assumptions about features can be checked by stating them as static assertions .
For example : too ; Undeﬁned behavior nastier .
construct deemed undeﬁned by the standard if no reasonable behavior required by an implementation .
Typically , some obvious implementation technique will .

Plausible outcomes of this code fragment include overwriting unrelated data and triggering hardware .
An implementation not required to choose among plausible outcomes .

Where powerful optimizers are used , the actual effects of undeﬁned behavior can become quite unpredictable .
If set of plausible and easily implementable alternatives exist , feature deemed Section The ISO Standard unspeciﬁed or rather than undeﬁned .

It worth spending considerable time and effort to ensure that program does not use something deemed unspeciﬁed or undeﬁned by the standard .
In many cases , tools exist to help do this .

hosted implementation includes all the facilities as described in the standard and in this book .

freestanding implementation may provide fewer facilities , as long as the following are provided : Freestanding Implementation Headers Types Implementation properties Integer types Start and termination Dynamic memory management Type identiﬁcation Exception handling Initializer lists Other support , Type traits Atomics Freestanding implementations are meant for code running with only the most minimal operating system support .
Many implementations also provide option for not using exceptions for really minimal , programs .

This can cause problems for people who use in an environment with different character .

ASCII contains punctuation characters and operator symbols as , and that are not available in some character sets .

We need notation for characters that do not have convenient character representation as newline and character with value .

ASCII contain characters as , and that are used for writing languages other than English .

To use an extended character set for source code , programming environment can map the extended character set into the basic source character set in one of several ways , for example , by using universal character names .

That is , the programmer must specify that entities named   and exist and that they are of types for , + and , respectively , are meaningful .

Every name in program has type associated with it .
This type determines what operations can be applied to the name is , to the entity referred to by the and how .

Because is declared to be an int , it can be assigned to , used as an operand for + etc .
On the other hand , is declared to be function that takes an int as its argument , so it can be called given the interger .

This chapter presents fundamental types and declarations .
Its examples just demonstrate language features ; they are not intended to do anything useful .
More extensive and realistic examples are saved for later chapters .
This chapter simply provides the most basic elements from programs are constructed .
You must know these elements , plus the terminology and simple syntax that go with them , in order to complete real project in and especially to read code written by others .
However , thorough understanding of every detail mentioned in this chapter is not requirement for understanding the following chapters .
Consequently , you may prefer to skim through this chapter , observing the major concepts , and return later as the need for understanding more details arises .

The integral and are called types because they must be deﬁned by users rather than being available for use without previous declaration , the way fundamental types are .
In contrast , fundamental types , pointers , and references are collectively referred to as types .
The standard library provides many types , Chapter .

The integral and types are provided in variety of sizes to give the programmer choice of the amount of storage consumed , the precision , and the range available for computations .
The assumption is that computer provides bytes for holding characters , words for holding and computing integer values , some entity most suitable for computation , and addresses for referring to those entities .
The fundamental types together with pointers and arrays present these notions to the programmer in reasonably manner .

For most applications , we could use bool for logical values , char for characters , int for integer values , and double for values .
The remaining fundamental types are variations for optimizations , special needs , and compatibility that are best ignored until such needs arise .

Boolean is used to express the results of logical operations .

common use of bool is as the type of the result of function that tests some condition .
For example : bool ; bool  int return ;

If you prefer to use the syntax to prevent narrowing , yet still want to convert an int to bool , you can be explicit : Types and Declarations Chapter .

prefer if over if because it more directly expresses the notion is valid " and also because it is shorter .
The shorter form leaves fewer opportunities for mistakes .

provides variety of character types that reﬂect that often bewildering .

char is used for the character set and is usually bits .

The size of is and large enough to hold the largest character set supported by the locale .

These are six distinct types the fact that the sufﬁx is often used to denote aliases ;

On each implementation , the char type will be identical to that of either signed char or unsigned Section Character Types char , but these three names are still considered separate types .

char variable can hold character of the character set .
For example : char ; Almost universally , char has bits so that it can hold one of different values .
Typically , the character set is variant of , for example ASCII , thus providing the characters appearing on your keyboard .
Many problems arise from the fact that this set of characters is only partially standardized .

Serious variations occur between character sets supporting different natural languages and between character sets supporting the same natural language in different ways .
Here , we are interested only in how such differences affect the rules of .
The larger and more interesting issue of how to program in multilingual , environment is beyond the scope of this book , although it is alluded to in several places , Chapter .

It is safe to assume that the implementation character set includes the decimal digits , the alphabetic characters of English , and some of the basic punctuation characters .
It is not safe to assume .

There are no more than characters in an character set , some sets provide .

There are no more alphabetic characters than English provides European languages provide more , and .

The alphabetic characters are contiguous leaves gap between ' and .

Every character used to write is available , some national character sets do not provide , and .

char ﬁts in byte .
There are embedded processors without byte accessing hardware for which char bytes .
Also , one could reasonably use Unicode encoding for the basic chars .

Whenever possible , we should avoid making assumptions about the representation objects .
This general rule applies even to characters .

Each character has an integer value in the character set used by the implementation .
For example , the value ' in the ASCII character set .
Here loop that outputs the the integer value any character you care to .

The possibility converting char to an integer raises the question : char signed or unsigned .

The values represented by an byte can be interpreted as the values to or as the values to .
No , not to as one might expect : the standard leaves open the possibility hardware and that eliminates one value ; thus , use nonportable .
Unfortunately , the choice signed or unsigned for plain char implementationdeﬁned .
provides two types for which the answer deﬁnite : signed char , which can hold at least the values to , and unsigned char , which can hold at least the values to .

Values outside that range stored in plain char can lead to subtle portability problems .
See if you need to use more than one type char or if you store integers in char variables .

Note that the character types are integral types so that arithmetic and bitwise logical operations apply .

The character literal ' converted to its integer value and added .
The resulting int then converted to char and written to .
Plain an int , so if had left out the , the output would have been something like , and so on , rather than , and so on .

This opens the possibility for some nasty surprises and implementation dependencies .
For example : char ;  hexadecimal int  What will be the value .
Unfortunately , the answer undeﬁned .
On an implementation with bytes , the answer depends on the meaning the ones " char bit pattern when extended into an int .
On machine where char unsigned , the answer .
On machine where char signed , the answer .
In this case , the compiler might warn about the conversion the literal to the char value .
Howev er , does not offer general mechanism for detecting this kind problem .
One solution to avoid plain char and use the speciﬁc char types only .
Unfortunately , some functions , such as , take plain chars only .

char must behave identically to either signed char or an unsigned char .
Howev er , the three .

The type character literal char .
character literal can be implicitly converted to its integer value in the character set the machine on which the program to run .
For example , if you are running on machine using the ASCII character set , the value '
The use character literals rather than decimal notation makes programs more portable .

few characters have standard names that use the backslash ,  as an escape character : Name ASCII Name Name Newline Horizontal tab HT Vertical tab VT Backspace BS Carriage return CR Form feed FF Alert BEL Backslash Question mark .

Single quote  Double quote .

For example , we can set aside uninitialized storage for some type like .

As can be seen from these examples , declaration can do more than simply associate type with Most of these declarations are also deﬁnitions .
deﬁnition is declaration that supplies all that is needed in program for the use of an entity .
In particular , if it takes memory to represent something , that memory is set aside by its deﬁnition .
different terminology deems declarations parts of an interface and deﬁnitions parts of an implementation .
When taking that view , we try to compose interfaces out of declarations that can be replicated in separate ﬁles ; deﬁnitions that set aside memory do not belong in interfaces .

Assuming that these declarations are in the global scope , we have : char ch ; set aside memory for char and initialize it to auto ; set aside memory for an int initialized to const ; set aside memory for pointer to char .

In this , standard differs from early versions of and that allowed ﬁrst two examples by considering int to be type when none was speciﬁed .
This int " rule was source of subtle errors and much confusion .

Some types have names composed out of multiple keywords , such as long long and volatile int .

Some type names even look much like names , such as return type of call ;

The volatile speciﬁer is described in .

The speciﬁer is described in .

The declaration simply contains list of declarators .
For example , we can declare two integers like this : int , int ; int ; Section Declaring Multiple Names Operators apply to individual names only and not to any subsequent names in same declaration .

The ﬁrst character must be letter .

The underscore character , is considered letter .
imposes no limit on number of characters in .
However , some parts of an implementation are not under control of compiler writer particular , and those parts , unfortunately , sometimes do impose limits .
Some environments also make it necessary to extend restrict set of characters accepted in an identiﬁer .
Extensions , allowing character in yield nonportable programs .
keyword , such as new int , cannot be used as of entity .

Examples of names are : hello DEFINED foO bAr HorseSense CLASS Examples of character sequences that cannot be used as identiﬁers are : fool class if Nonlocal names starting with an underscore are reserved for special facilities in the implementation and the environment , so such names should not be used in application programs .
Similarly , names starting with double underscore an underscore followed by an uppercase letter , are reserved .

When reading program , the compiler always looks for the longest string of characters that could make up name .
Hence , is single name , not the name var followed by the number .

Also , elseif is single name , not the keyword else followed by the keyword if .

Uppercase and lowercase letters are distinct , so Count and count are different names , but it is often unwise to choose names that differ only by capitalization .
In general , it is best to avoid names that differ only in subtle ways .
For example , in some fonts , the uppercase " and zero can be hard to tell apart , as can the lowercase " uppercase " and one .
Consequently , lO , ll , and are poor choices for identiﬁer names .
Not all fonts have the same problems , but most have some .

Names from large scope ought to have relatively long and reasonably obvious names , such as vector , and .
Howev er , code is clearer if names used only in small scope have short , conventional names such as , and .
Functions , classes , and namespaces can be used to keep scopes small .
It is often useful to keep frequently used names relatively short and reserve really long names for infrequently used entities .

For example , is better than ev en if the phone numbers happen to be stored in vector .
Do not encode type information in name , pcname for name icount for count an as is sometimes done in languages with dynamic weak type .

Encoding types in names lowers the abstraction level of the program ; in particular , it prevents generic programming relies on name being able to refer to entities of different .

The compiler is better at keeping track of types than you are .

If you want to change the type of name , use to hold the , have to change every use of the name the type encoding becomes .

Any system of type abbreviations you can come up with will become overelaborate and cryptic as the variety of types you use increases .

Choosing good names is an art .

Try to maintain consistent naming style .
For example , capitalize names of types and start names of entities with lowercase letter example , Shape and .

Also , use all capitals for macros you must use macros ; for example , and never for even for .
Use underscores to separate words in an identiﬁer ; is more readable than numberOfElements .
Howev er , consistency is hard to achieve because programs are typically composed of fragments from different sources and several different reasonable styles are in use .
Be consistent in your use of abbreviations and acronyms .

Note that the language and the standard library use lowercase for types ; this can be seen as hint that they are part of the standard .

Local  name declared in function or lambda is called local name .
Its extends from its point of declaration to the end of the block in which its declaration occurs .
block is section of code delimited by pair .
Function and lambda parameter names are considered local names in the outermost block of their function or lambda .

Class  name is called member name class member if it is deﬁned in class outside any function , class , enum class , or other namespace .
Its extends from the opening of the class declaration to the end of the class declaration .

Namespace  name is called namespace member name if it is deﬁned in namespace outside any function , lambda , class , enum class , or other namespace .
Its extends from the point of declaration to the end of its namespace .
namespace name may also be accessible from other translation units .

Global  name is called global name if it is deﬁned outside any function , class , enum class , or namespace .
The of global name extends from the point of declaration to the end of the ﬁle in which its declaration occurs .
global name may also be accessible from other translation units .
Technically , the global namespace is considered namespace , so global name is an example of namespace member name .

Statement  name is in statement if it is deﬁned within the part of , or .
Its extends from its point of declaration to the end of its statement .
All names in statement are local names .

Function  label is in from its point of declaration until the end of the function .

declaration of name in block can hide declaration in an enclosing block or global name .

That is , name can be redeﬁned to refer to different entity within block .
After exit from the block , the name resumes its previous meaning .

However , human reader can easily fail to notice that name has been hidden known as .
Because such errors are relatively rare , they can be very difﬁcult to ﬁnd .
Consequently , name hiding should be minimized .

Using names such as and for global variables or for local variables in large function is asking for trouble .

hidden global name can be referred to using the resolution operator ,

There is no way to use hidden local name .

The of name that is not class member starts at its point of declaration , that is , after the complete declarator and before the initializer .
This implies that name can be used even to specify its own initial value .

It is possible to use single name to refer to two different objects in block without using the : operator .
For example : int .

Names introduced in are local to that statement statement .
This allows us to use conventional names for loop variables repeatedly in function .

This contains no name clashes .

declaration is not allowed as the only statement on the branch of an .

An initializer can one of four syntactic .

Of these , only the ﬁrst can be used every context , and strongly recommend its .
It is clearer and less than the alternatives .
However , the ﬁrst form for is new , so the other three forms are what you ﬁnd older code .
The two forms are what you .
Old habits die hard , so sometimes when initializing simple variable with simple value .
For example : int ; char ; However , anything much more complicated than that is better done .
Initialization , initialization , does not allow narrowing .

An integer cannot be converted to another integer that cannot hold its value .
For example , char to int is allowed , but not int to char .

value cannot be converted to another type that cannot hold its value .
For example , ﬂoat to double is allowed , but not double to ﬂoat .

value cannot be converted to an integer type .

An integer value cannot be converted to type .

There is no advantage to initialization , and one trap , when auto to get the type determined by the initializer .
The trap is that if the initializer is , we may not want its type deduced .

It is possible to deﬁne class so that an object can be initialized by of values and alternatively be constructed given couple of arguments that are not simply values to be stored .
The classical example is of integers : is of element with the value .

For integral types , the default value is suitable representation of zero .
For pointers , the default value is nullptr .
For types , the default value is determined by the constructors .

For types , there can be distinction between direct initialization implicit conversions are and copy initialization they are ; see .

Initialization of particular kinds of objects is discussed where .

Classes :

containers : Missing Initializers For many types , including all types , it is possible to leave out the initializer .
If you do that and that has unfortunately been common the situation is more complicated .
If you like the complications , just initialize consistently .
The only really good case for an uninitialized variable is large input buffer .
For example : constexpr int ; char .

Avoid such of buffers where you can , and leave such buffers uninitialized unless you know , from that the optimization compared to an initialized array is signiﬁcant .

If no initializer is speciﬁed , global , namespace , local static , or static member called static is initialized to of the appropriate .

member of an array or class is default initialized if the array or structure is .

More complicated objects can require more than one value as an initializer .
This is primarily handled by initializer .

For initialization of arrays , see .
For structures , see .
For types with constructors , see or .
For constructors , see .

In cases above , is redundant .
However , some to add it to emphasize that set of values are used to initialize set of member variables .

In some cases , argument lists can also be used ,

The deduction done here is very simple : auto and simply report type an expression already known to compiler .

Instead , we can let variable have type its initializer .

Aliases are used when we want to insulate our code from details of the underlying machine .
The indicates that we want it to represent integer .
Having written our code in terms of , rather than " we can port our code to machine with by redeﬁning the single occurrence of in our code to use longer integer : using long ; The sufﬁx is conventional for aliases .
The , other such aliases can be found in .
Note that naming type after its representation rather than its purpose is not necessarily good idea .

The using keyword can also be used to introduce template alias .
For example : using ,

Pointers ; nullptr .

Arrays Array Initializers ; String Literals .

Pointers into Arrays Navigating Arrays ; Multidimensional Arrays ; Passing Arrays .

Pointers and const .

Pointers and Ownership .

References Lvalue References ; Rvalue References ; References to References ; Pointers and References .

Advice Introduction This chapter deals with basic language mechanisms for referring to memory .
Obviously , we can refer to an object by name , but in objects " That is , they reside at speciﬁc address in memory , and an object can be accessed if you know its address and its type .
The language constructs for holding and using addresses are pointers and references .

For example : char ; holds address of  is operator or graphically :   The fundamental operation on pointer is dereferencing , that is , referring to object pointed to unary .
For example : char ; holds address of  is operator char ; is dereference operator The object pointed to by is  and value stored in is , so value of assigned to is .

It is possible to perform some arithmetic operations on pointers to array elements .

The implementation of pointers is intended to map directly to addressing mechanisms of machine on which program runs .
Most machines can address byte .
Those that tend to have hardware to extract bytes from words .
On other hand , few machines can directly address an individual bit .
Consequently , smallest object that can be independently allocated and pointed to using pointer type is char .
Note that bool occupies at least as much space as char .
To store smaller values more compactly , you can use bitwise logical operations , in structures , or bitset .

The , meaning " is used as sufﬁx for type name .
Unfortunately , pointers to arrays and pointers to functions need more complicated notation : pi ; pointer to int ppc ; pointer to pointer to char ; array of pointers to ints int ; pointer to function taking argument ; returns an int ; function taking argument ; returns pointer to int See for an explanation of declaration syntax and for complete grammar .

Pointers to functions can be useful ; they are discussed in .
Pointers to class members are presented in .

You can read Section pointer to any type of object can be assigned to variable of type , but pointer to function or pointer to member cannot .
In addition , can be assigned to another , can be compared for equality and inequality , and can be explicitly converted to another type .
Other operations would be unsafe because compiler cannot know what kind of object is really pointed to .
Consequently , other operations result in errors .
To use , we must explicitly convert it to pointer to speciﬁc type .

In general , it is not safe to use pointer that has been converted to type that differs from the type of the object pointed to .
For example , machine may assume that every double is allocated on an boundary .
If so , strange behavior could arise if pointed to an int that allocated that way .
This form of explicit type conversion is inherently unsafe and ugly .
Consequently , the notation used , was designed to be ugly and easy to ﬁnd in code .

The primary use for is for passing pointers to functions that are not allowed to make assumptions about the type of the object and for returning untyped objects from functions .
To use such an object , we must use explicit type conversion .

Functions using pointers typically exist at the very lowest level of the system , where real hardware resources are manipulated .
For example : allocate bytes from my special heap Occurrences of at higher levels of the system should be viewed with great suspicion because they are likely indicators of design errors .
Where used for optimization , can be hidden behind interface .

Pointers to functions and pointers to members cannot be assigned to .

It can be assigned to any pointer type , but not to other types : nullptr ; nullptr ; int nullptr ; error  is not pointer There is just one nullptr , which can be used for every pointer type , rather than null pointer for each pointer type .

For example : gets the value nullptr No object is allocated with the address , and bit is the most common representation of nullptr .
Zero is an int .
Howev er , the standard conversions allow to be used as constant of pointer or type .

It has been popular to deﬁne macro NULL to represent the null pointer .
For example : NULL ; using the macro NULL However , there are differences in the deﬁnition of NULL in different implementations ; for example , NULL might be or .
In , NULL is typically , which makes it illegal in : NULL ; error  assign to an Using nullptr makes code more readable than alternatives and avoids potential confusion when function is overloaded to accept either pointer or an integer .

For example : ﬂoat ; an array of three ﬂoats :

Access out of the range of an array is undeﬁned and usually disastrous .
In particular , range checking is neither guaranteed nor common .

The number of elements of the array , the array bound , must be constant expression .
If you need variable bounds , use ,

An array is fundamental way of representing sequence of objects in memory .
If what you want is simple sequence of objects of given type in memory , an array is the ideal solution .
For every other need , an array has serious problems .

There is no array assignment , and the name of an array implicitly converts to pointer to its ﬁrst element at the slightest provocation .
In particular , avoid arrays in interfaces , as function arguments ; because the implicit conversion to pointer is the root cause of many common errors in code and code .
If you allocate an array on the free store , be sure to its pointer once only and only after its last use .
most easily and most reliably done by having the lifetime of the array controlled by resource handle , string , or .
If you allocate an array statically or on the stack , be sure never to it .
Obviously , programmers cannot follow these pieces of advice because lacks the ability to encapsulate arrays , but that make the advice bad in the context of .

One of the most widely used kinds of arrays is array of char .
the way stores strings , so array of char is often called string .
string literals follow that convention , and some functions , and ; rely on it .
Often , or const is assumed to point to sequence of characters .

For example : char , When an array is declared without speciﬁc size , but with an initializer list , the size is calculated by counting the elements of the initializer list .

If size is explicitly speciﬁed , it is an error to give surplus elements in an initializer list .

You cannot initialize one array with another ev en of exactly the same , and there is no array assignment : error  no array assignment Similarly , you pass arrays by value .

When you need assignment to collection of objects , use , an array , or valarray instead .

An array of characters can be conveniently initialized by string literal .

For example : The type of string literal is of the appropriate number of const " so " is of type const .

In and in older code , you could assign string literal to .

It would obviously be unsafe to accept that assignment .
It was source of subtle errors , so please grumble too much if some old code fails to compile for this reason .
Having string literals immutable is not only obvious but also allows implementations to do signiﬁcant optimizations in the way string literals are stored and accessed .

If we want string that we are guaranteed to be able to modify , we must place the characters in .

Whether two identical string literals are allocated as one array or as two is implementationdeﬁned .

The empty string is written as pair of adjacent double quotes , and has the type const .
The one character of the empty string is the terminating .

The backslash convention for representing nongraphic characters can also be used within string .
This makes it possible to represent the double quote and the escape character backslash within string .
The most common such character by far is the newline character ,

For example : at end of ; The escape character , is the ASCII character BEL known as , which causes sound to be emitted .

It is not possible to have " newline in string literal : is not string ; The compiler will concatenate adjacent strings , so could equivalently have been initialized by the single string ; It is possible to have the null character in string , but most programs will not suspect there are characters after it .
For example , the string " will be treated as " by standardlibrary functions such as and ; see .

logical and in most cases quite simple .
However , if we need lot of backslashes and lot of quotes in string literals , this simple technique becomes unmanageable .
In particular , in regular expressions backslash is used both as an escape character and to introduce characters Pointers , Arrays , and References Chapter representing character classes .
This is convention shared by many programming languages , so we just change it .
Therefore , when you write regular expressions for use with the standard regex library , the fact backslash is an escape character becomes notable source of errors .
Consider how to write the pattern representing two words separated by backslash : string ; hope got right To prevent the frustration and errors caused by this clash of conventions , provides raw string literals .
raw string literal is string literal where backslash is just backslash double quote is just double so our example becomes : string ; pretty sure got right Raw string literals use the " notation for sequence of characters ccc .
The initial is there to distinguish raw string literals from ordinary string literals .
The parentheses are there to allow double quotes .
For example : So , how do we get the character sequence " into raw string literal .
Fortunately ,  rare problem , but and " is only the default delimiter pair .
We can add delimiters before the and after the in .
For example : The character sequence after the must be identical to the sequence before the .
This way we can cope with arbitrarily complicated patterns .

Unless you work with regular expressions , raw string literals are probably just curiosity one more thing to , but regular expressions are useful and widely used .
Consider example : Are the ﬁve backslashes correct or not .

With examples like  even experts easily become confused , and raw string literals provide signiﬁcant service .

In contrast to nonraw string literals , raw string literal can contain newline .
For example : string counts ; is equivalent to string ; Larger Character Sets string with the preﬁx , such as , is string of wide characters .
Its type is const .
Similarly , string with the preﬁx LR , such as , is raw string of wide characters of type const .
Such string is terminated by ' character .

This sounds excessive , but there are three major encodings of Unicode : and .
For each of these three alternatives , both raw and " strings are supported .
All three UTF encodings support all Unicode characters , so which you use depends on the system you need to ﬁt into .

Essentially all Internet applications , browsers and rely on one or more of these encodings .

is encoding : common characters ﬁt into byte , less frequently used characters some estimate of into bytes , and rarer characters into or bytes .
In particular , the ASCII characters ﬁt into byte with the same encodings in as in ASCII .
The various Latin alphabets , Greek , Cyrillic , Hebrew , Arabic , and more ﬁt into bytes .

string is terminated by , string by , and string by .

We can represent an ordinary English character string in variety of ways .
Consider ﬁle name using backslash as the separator : implementation character set string .

Obviously , the real purpose of Unicode strings is to be able to put Unicode characters into them .

For example : Printing string appropriately gives you The ofﬁcial vowels in Danish are : and .

The hexadecimal number after the is Unicode code point .
Such code point is independent of the encoding used and will in fact have different representations bits in in different encodings .
For example , lowercase letter is the hexadecimal value in , the hexadecimal value in , and the hexadecimal value in .
These hexadecimal values are referred to as universal character names .

The order of the us and Rs and their cases are signiﬁcant : RU and Ur are not valid string preﬁxes .

The name of an array can be used as pointer to its initial element .
For example : Pointers , Arrays , and References Chapter .

This is important for many algorithms ,
However , since such pointer does not in fact point to an element of the array , it may not be used for reading or writing .
The result of taking the address of the element before the initial element or beyond element is undeﬁned and should be avoided .

The same value is passed to the function in both calls .
The snag is that it is impossible to avoid the implicit conversion .
In other words , there is no way of declaring function so that the array is copied when the function is called .
Fortunately , there is no implicit or explicit conversion pointer to an array .

The implicit conversion of the array argument to pointer means that the size of the array is lost to the called function .
However , the called function must somehow determine the size to perform relies on zero to indicate ; returns the number of characters up to and not including the terminating .
This is all pretty .
The vector , array , and string suffer this problem .
These library types give their number of elements as their without having to count elements each time .

Access can be achieved either through pointer to an array plus an index or through pointer to an element .

There is no inherent reason why one version should be faster than the other .
With modern compilers , identical code should be usually generated for both examples .
Programmers can choose between the versions on logical and aesthetic grounds .

Subscripting array is deﬁned in terms of the pointer operations + and .
For every array and integer within the range of  we hav : It usually surprises people to ﬁnd that .

Such cleverness has no place in production code .
These equivalences are pretty and do not hold for containers , such as array and vector .

The result of applying the arithmetic operators + or to pointers depends on the type of the object pointed to .
When an arithmetic operator is applied to pointer of type , is assumed to point to an element of an array of objects of type ; points to the next element of that array , larger than the integer value of .
For example :

This shows that on my implementation , is and is .

Subtraction of pointers is deﬁned only when both pointers point to elements of the same array the language has no fast way of ensuring that is the .
When subtracting pointer another pointer , the result is the number of array elements in the sequence .
One can add an integer to pointer or subtract an integer pointer ; in both cases , the result is pointer value .
If that value does not point to an element of the same array as the original pointer or one beyond , the result of using that value is undeﬁned .

Complicated pointer arithmetic is usually unnecessary and best avoided .
Addition of pointers makes no sense and is not allowed .

Arrays are not because the number of elements of an array is not guaranteed to be stored with the array .
This implies that to traverse an array that does not contain terminator the way strings do , we must somehow supply the number of elements .

Most advantages of the array and few of the disadvantages can be obtained through the use of the container array ,

Some implementations offer optional range checking for arrays .
However , such checking can be quite expensive , so it is often used only as development aid than being included in production .
If you are not using range checking for individual accesses , try to maintain consistent policy of accessing elements only in ranges .
That is best done when arrays are manipulated through the interface of container type , such as vector , where it is harder to get confused about the range of valid elements .

In particular , there is no single object in memory that is the matrix ma only the elements are stored .
The dimensions and exist in the compiler source only .
When we write code , it is our job to remember them somehow and supply the dimensions where needed .
For example , we might print ma like .

Fortunately , most mistakes are caught by the compiler .
For example : int ; error  comma not allowed in constant expression .

Instead , an array is passed as pointer to its ﬁrst element .
For example : void .

The function could equivalently have been written as .

When used as function argument , the ﬁrst dimension of an array is simply treated as pointer .
Any array bound speciﬁed is simply ignored .
This implies that if you want to pass sequence of elements without losing size information , you should not pass array .
Instead , you can place the array inside class as member is done for or deﬁne class that acts as handle is done for and .

If you insist on using arrays directly , you will have to deal with bugs and confusion without getting noticeable advantages in return .
Consider deﬁning function to manipulate matrix .
If the dimensions are known at compile time , there is no .

The ﬁrst dimension of an array is irrelevant to ﬁnding the location of an element ; it simply states how many elements , of the appropriate type , are present .
For example , look at the layout of ma above and note that by knowing only that the second dimension is , we can locate for any .
The ﬁrst dimension can therefore be passed as an .

Fortunately , the argument declaration is illegal because the second dimension of multidimensional array must be known in order to ﬁnd the location of an element .
However , the expression is interpreted as , although that is unlikely to be what the programmer intended .
correct solution .

Note the use of for the last call ; would do because it is equivalent , but would be type error .
This kind of subtle and messy code is best hidden .
If you must deal directly with multidimensional arrays , consider encapsulating the code relying on it .
In that way , you might ease the task of the next programmer to touch the code .
Providing multidimensional array type with proper subscripting operator saves most users from having to worry about the layout of the data in the array ,

The standard vector suffer from these problems .

Basically , role is to enable and ensure evaluation , whereas primary role is to specify immutability in interfaces .
This section is primarily concerned with the second role : interface speciﬁcation .

Many objects hav their values changed after .

Symbolic constants lead to more maintainable code than using literals directly in code .

Many pointers are often read through but never written through .

Most function parameters are read but not written to .

To express this notion of immutability after initialization , we can add const to the deﬁnition of an object .

To declare pointer itself , rather than the object pointed to , to be constant , we use the declarator operator instead of plain .

This is particularly useful for function arguments .
By declaring pointer argument const , the function is prohibited from modifying the object pointed to .
For example : const , char ; ﬁnd ﬁrst occurrence of c in , char ; ﬁnd ﬁrst occurrence of c in The ﬁrst version is used for strings where the elements be modiﬁed and returns pointer to const that does not allow modiﬁcation .
The second version is used for mutable strings .

You can assign the address of variable to pointer to constant because no harm can come from that .
However , the address of constant cannot be assigned to an unrestricted pointer because this would allow the object ' value to be changed .
For example : Pointers , Arrays , and References Chapter .

Memory acquired by new .

In this case , obviously must manage the lifetime of the object it creates on the free store , but in general keeping track of what needs to be deleted in large program requires simple and consistent strategy .

It is usually good idea to immediately place pointer that represents ownership in resource handle class , such as vector , string , and .
That way , we can assume that every pointer that is not within resource handle is not an owner and must not be deleted .
Chapter discusses resource management in greater detail .

The type of the pointer determines what can be done to the data through the pointer .
Using pointer differs from using the name of an object in few .

We use different syntax , for example , instead of obj and rather than .

We can make pointer point to different objects at different times .

We must be more careful when using pointers than when using an object directly : pointer may be nullptr or point to an object that the one we expected .

These differences can be annoying ; for example , some programmers ﬁnd ugly compared to .
Worse , managing pointer variables with varying values and protecting code against the possibility of nullptr can be signiﬁcant burden .
Finally , when we want to overload an operator , say + we want to write rather than .
The language mechanism addressing these problems is called reference .
Like pointer , reference is an alias for an object , is usually implemented to hold machine address of an object , and does not impose performance overhead compared to pointers , but it differs from pointer in .

You access reference with exactly the same syntax as the name of an object .

reference always refers to the object to which it was initialized .

There is no " and we may assume that reference refers to an object .

reference is an alternative name for an object , an alias .
The main use of references is for specify in particular .
For example : class vector .

The ﬁrst two are both called lvalue references .

Here , does not increment the reference rr ; rather , is applied to the to which rr refers , that is , to .
Consequently , the value of reference cannot be changed after initialization ; it always refers to the object it was initialized to denote .
To get pointer to the object denoted by reference rr , we can write .
Thus , we cannot have pointer to reference .
Furthermore , we cannot deﬁne an array of references .
In that sense , reference is not an object .

The obvious implementation of reference is as pointer that is dereferenced each time it is used .
It do much harm to think about references that way , as long as one remembers that reference an object that can be manipulated the way pointer is : Section Lvalue References ii :  rr : In some cases , the compiler can optimize away reference so that there is no object representing that reference at run time .

Initialization of reference is trivial when the initializer is an lvalue object whose address you can take ; see .
The initializer for " must be an lvalue of type .

The initializer for const need not be an lvalue or even of type .
In such cases : First , implicit type conversion to is applied if necessary .

References to variables and references to constants are distinguished because introducing temporary for variable would have been highly ; an assignment to the variable would become an assignment to the temporary .
No such problem exists for references to constants , and references to constants are often important as function arguments .

reference can be used to specify function argument so that the function can change the value of an object passed to it .

The semantics of argument passing are deﬁned to be those of initialization , so when called , argument aa became another name for .
To keep program readable , it is often best to avoid functions that modify their arguments .
Instead , you can return value from the function explicitly : Pointers , Arrays , and References Chapter .

The notation giv clue to the reader that value is being modiﬁed , the way does .
Consequently , reference arguments should be used only where the name of the function gives strong hint that the reference argument is modiﬁed .

This is mostly used to deﬁne functions that can be used on both the and sides of an assignment .
Map is good example .
For example : class class Map simple map class .

Similarly , return the value by reference because it too might be of type that is expensive to copy .

use const reference for because want to modify it and because might want to use literal or temporary object as an argument .
return the result by reference because the user of might very well want to modify the found value .
For example : Section Lvalue References int count the number of occurrences of each word on input .

Finally , the resulting table of different words in the input , each with its number of occurrences , is printed .
For example , given the input aa bb bb aa aa bb aa aa this program will produce aa : bb : The for loop works for this because deﬁned and , just as is done for the map .

lvalue reference refers to an object , to which the user of the reference can write .

const lvalue reference refers to constant , which is immutable from the point of view of the user of the reference .

An rvalue reference refers to temporary object , which the user of the reference can typically modify , assuming that the object will never be used again .

We want to know if reference refers to temporary , because if it does , we can sometimes turn an expensive copy operation into cheap move operation ,
An object as string or that is represented by small descriptor pointing to potentially huge amount of information can be simply and cheaply moved if we know that the source going to be used again .
The classic example is return value where the compiler knows that local variable returned will never again be used .

An rvalue reference can bind to an rvalue , but not to an lvalue .
In that , an rvalue reference is exactly opposite to an lvalue reference .

Both const lvalue reference and an rvalue reference can bind to an rvalue .
However , the purposes will be fundamentally .

We use rvalue references to implement read " for optimization of what would otherwise have required copy .

We use const lvalue reference to prevent modiﬁcation of an argument .

An object referred to by an rvalue reference is accessed exactly like an object referred to by an lvalue reference or an ordinary variable name .

There are two kinds of enumerations : enum classes , for which the enumerator names , are local to the enum and their values do not implicitly convert to other types " for which the enumerator names are in the same scope as the enum and their values implicitly convert to integers In general , prefer the enum classes because they cause fewer surprises .

An enumeration is represented by some integer and each enumerator by some integer We call the used to represent an enumeration its underlying .
The underlying must be one of the signed or unsigned integer types ; the default is int .
We could be about that : If we considered that too wasteful of space , we could instead use .

human might notice that was missing , and compiler might issue warning because only three out of four values are handled .

An enumerator can be initialized by constant expression of integral .
For example : enum class acknowledg , The values for the enumerators are chosen so that they can be combined by bitwise .

The result of such conversion is undeﬁned unless the is within the range of the enumeration ' underlying .

The last assignments show why there is no implicit conversion from an integer to an enumeration ; most integer values do not have representation in particular enumeration .

We can extract that value explicitly .

The notion of range of values for an enumeration differs from the enumeration notion in the Pascal family of languages .
However , examples that require values outside the set of enumerators to be well deﬁned , the have long history in and .

The sizeof an enum class is the sizeof of its underlying .
In particular , if the underlying is not explicitly speciﬁed , the size is .

The enumerators of plain enum are exported into the enum ' scope , and they implicitly convert to values of some integer .
Consider the examples from with the "

The compiler accepts the , which is almost certainly bug .
The injection of names into an enclosing scope enums , but not enum classes or classes , is namespace pollution and can be major problem in larger programs .

You can specify the underlying type of plain enumeration , just as you can for enum classes .
If you do , you can declare the enumerations without deﬁning them until later .
For example : enum  char ,

If you specify the underlying type , you declare the enum without deﬁning it , and its underlying type is determined by relatively complicated algorithm : when all enumerators are nonnegative , the range of the enumeration is where is the smallest power of for which all enumerators are within the range .
If there are negative enumerators , the range is .
This deﬁnes the smallest capable of holding the enumerator values using the conventional complement representation .

The sizeof an enumeration is the sizeof its underlying type .
If the underlying type explicitly speciﬁed , it is some integral type that can hold its range and not larger than , unless an enumerator cannot be represented as an or as an unsigned .
For example , could be or maybe but not on machine where .

For example : enum , We use that when all we need is set of integer constants , rather than type to use for variables .

Declarations as Statements .

Selection Statements if Statements ; switch Statements ; Declarations in Conditions .

Iteration Statements Statements ; for Statements ; while Statements ; do Statements ; Loop exit .

Comments and Indentation .

Advice Introduction offers conventional and ﬂexible set of statements .
Basically all that is either interesting or complicated is found in expressions and declarations .
Note that declaration is statement and that an expression becomes statement when you add semicolon at its end .

Unlike an expression , statement does not have value .
Instead , statements are used to specify the order of execution .
For example : expression statement ; execute if and only if  is executed before the if , as everyone would expect .
compiler may reorder code to improve performance as long as the result is identical to that of the simple order of execution .

name declared in block goes out of scope at the end of its block .

declaration is statement and there is no assignment statement or statement ; assignments and function calls are expressions .

must be either declaration or an .
Note that both end with semicolon .

must be the declaration of single uninitialized variable .

The statements for handling exceptions , are described in .

Unless variable is declared static , its initializer is executed whenever the thread of control passes through the declaration also .
The reason for allowing declarations wherever statement can be used few other places ; is to enable the programmer to minimize the errors caused by uninitialized variables and to allow better locality in code .
There is rarely reason to introduce variable before there is value for it to hold .

The ability to place declarations after executable code is essential for many constants and for styles of programming where value of an object is not changed after initialization .

For types , postponing the deﬁnition of variable until suitable initializer is available can also lead to better performance .

Input variables are among the few reasonable examples of .

assume that does not return ; if it does , this code may cause buffer overﬂow .
Often , provides better solution to such examples .

If condition evaluates to something different from Boolean , it is if possible implicitly converted to bool .
This implies that any arithmetic or pointer expression can be used as condition .
For example , if is an integer , then if .

Note that " enum can be implicitly converted to an integer and then to bool , whereas an enum class cannot .
For example : Section if Statements .

The operators and will not evaluate their second argument unless doing so is necessary .

This tests only if is not nullptr .

For choosing between two alternatives each of which produces value , conditional expression .

If we need to introduce name in branch , it must be enclosed in block .
For example : Statements Chapter .

The expression in the case labels must be constant expression of integral or enumeration type .
value may not be used more than once for in .

This makes the easier to read for nontrivial examples .
It typically also leads to the generation of better code because there is no reason to repeatedly check individual values .
Instead , jump table can be used .

Consider : switch beware .

For example : switch .

break is the most common way of terminating case , but return is often useful .

When should have default .
There is no single answer that covers all situations .
One use is for the default to handle the most common case .
Another common use is the exact opposite : the default : action is simply way to catch errors ; every valid alternative is covered by the cases .
However , there is one case where default should not be used : if switch is intended to have one case for each enumerator of an enumeration .
If so , leaving out the default gives the compiler chance to warn against set of cases that almost but not quite match the set of enumerators .
For example , this is almost certainly an .

Testing for an " value is best done separately .

However , it is not possible to bypass an initialization .

Here , if , the thread of execution would bypass the initializations of and  so will not compile .
Unfortunately , because an int be initialized , the declaration of is not an error .
Howev er , its use is an error : we read an uninitialized variable .
Unfortunately , compilers often give just warning for the use of an uninitialized variable and cannot reliably catch all such misuses .
As usual , avoid uninitialized variables .

If we need variable within , we can limit its scope by enclosing its declaration and its use in block .
For an example , see in .

In particular , it is usually best to delay the deﬁnition of local variable until one can give it an initial value .
That way , one cannot get into trouble by using the variable before its initial value is assigned .

One of the most elegant applications of these two principles is to declare variable in condition .

Here , is declared and initialized and the value of after initialization is tested as the value of the condition .
The scope of extends from its point of declaration to the end of the statement that the condition controls .
For example , had there been an to the , would be in scope on both branches .

However , this opens the scope for the use of before its initialization or after its intended useful .

declaration in condition must declare and initialize single variable or const .

Note that both end with semicolon .

The statement of the controlled statement or the loop is executed repeatedly until the condition becomes false or the programmer breaks out of the loop some other way as break , return , throw , or .

More complicated loops can be expressed as an algorithm plus lambda expression .

The scope of the variable naming the element , is the .

The expression after the colon must denote sequence ; that is , it must yield value for which we can call and or and to obtain an iterators : the compiler ﬁrst looks for members begin and end and tries to use those .
If begin or an end is found that cannot be used as range , because member begin is variable rather than , the is an error .

If none is found or if what is found cannot be used , because the begin did not take an argument of the sequence ' the is an error .

The compiler uses and as and for array .
The header provides and for arrays and for all containers .

For sequences of our own design , we can deﬁne and in the same way as it is done for containers .

The controlled variable , in the example , that refers to the current element is equivalent to when using an equivalent .

For example , using it you touch two elements at the same time and effectively traverse two ranges simultaneously .
For that we need general .

The loop variable , the termination condition , and the expression that updates the loop variable are explicitly presented front " on single line .

If that initializer is declaration , the variable it introduced is in scope until the end of the .

It is not always obvious what is the right type to use for controlled variable in for loop , so auto often comes in handy : for ;

If no initialization is needed , the initializing statement can be empty .

If the expression that is supposed to increment the loop variable is omitted , we must update some form of loop variable elsewhere , typically in the body of the loop .
If the loop of the simple loop variable , test the condition , update the loop variable " variety , it is often better expressed as .
However , consider this elegant variant : Here , the reading and testing for termination and combined in , so we need an explicit loop variable .
On the other hand , the use of for , rather than while , allows us to limit the scope of the "  to the loop itself .

is also useful for expressing loop without an explicit termination .

is easily rewritten into an equivalent and vice versa .

This might be called like this : but it is all too easy to make horrible mistake .
For example , what if was the empty string .

In my experience , the is source of errors and confusion .
The reason is that its body is always executed once before the condition is evaluated .
However , for the body to work correctly , something very much like the condition must hold even the time through .
More often than would have guessed , have found that condition not to hold as expected either when the program was written and tested or later after the code preceding it has been modiﬁed .
also prefer the condition front where can see " Consequently , recommend avoiding .

break out of " the Section Loop Exit nearest enclosing or .

We use break when we need to leave the loop body the " Unless it warps the logic of loop , requires the introduction of an extra , it is usually better to have the complete exit condition as the condition of or .

Sometimes , we want to exit the loop completely , we just want to get to the end of the loop body .
continue skips the rest of the body of an .

This implies that you can use goto to jump both into and out of blocks .
The only restriction is that you cannot jump past an initializer or into an exception handler .

One of the few sensible uses of goto in ordinary code is to break out from nested loop or break breaks out of only the innermost enclosing loop or .
For example : do something to matrix called mn .

It does not introduce new or enter new .
That makes it the least troublesome and least confusing use of goto .

Several different consistent styles of indentation are in use .
see no fundamental reason to prefer one over another , like most programmers , have my preferences , and this book reﬂects .
The same applies to styles of comments .

Comments can be misused in ways that seriously affect the readability of program .
The compiler does not understand the contents of comment , so it has no way of ensuring that comment .

Most programs contain comments that are incomprehensible , ambiguous , and just plain wrong .

Bad comments can be worse than no comments .

If something can be stated in the language itself , it should be , and not just mentioned in comment .
This remark is aimed at comments such as these : variable " must be initialized function " takes two or three arguments Such comments can typically be rendered unnecessary by proper use of .

Once something has been stated clearly in the language , it should not be mentioned second time in comment .
For example : becomes ; increment the counter Such comments are worse than simply redundant .
They increase the amount of text the reader has to look at , they often obscure the structure of the program , and they may be wrong .
Note , however , that such comments are used extensively for teaching purposes in programming language textbooks such as this .
This is one of the many ways program in textbook differs from real program .

good comment states what piece of code is supposed to do intent of the , whereas the code states what it does terms of how it does .
Preferably , comment is expressed at suitably high level of abstraction so that it is easy for human to understand without delving into minute details .

comment for each source ﬁle stating what the declarations in it have in common , references to manuals , the name of the programmer , general hints for maintenance , etc .

comment for each class , template , and namespace .

comment for each nontrivial function stating its purpose , the algorithm used it is , and maybe something about the assumptions it makes about its environment .

comment for each global and namespace variable and constant .

few comments where the code is nonobvious nonportable .

Very little else For example : Implementation of the symbol table .

See Ralston : ﬁrst course " pg .

Bjar ne Stroustr up , Feb and set of comments is an essential part of good program .
Writing good comments can be as difﬁcult as writing the program itself .
It is an art well worth cultivating .

For example : remove expensive check if should never happen This nesting should give an error for an unmatched ﬁnal .

Desk Calculator The Parser ; Input ; Input ; Error Handling ; The Driver ; Headers ; Arguments ; Note on Style .

Operator Summary Results ; Order of Evaluation ; Operator Precedence ; Temporary Objects .

Constant Expressions Symbolic Constants ; consts in Constant Expressions ; Literal Types ; Reference Arguments ; Address Constant Expressions .

Implicit Type Conversion Promotions ; Conversions ; Usual Arithmetic Conversions .

Advice Introduction This chapter discusses expressions in some detail .
In , an assignment is an expression , function call is an expression , the construction of an object is an expression , and so are many other operations that go beyond conventional arithmetic expression evaluation .
To giv an impression of how expressions are used and to show them in context , ﬁrst present small complete program , simple " Next , the complete set of operators is listed and their meaning for builtin types is brieﬂy outlined .
The operators that require more extensive explanation are discussed in Chapter .

The user can also deﬁne variables .
For example , given the input pi is the calculator program will write where is the result of the ﬁrst line of input and is the result of the second .

The calculator consists of four main parts : parser , an input function , symbol table , and driver .
Actually , it is miniature compiler in which the parser does the syntactic analysis , the input function handles input and lexical analysis , the symbol table holds permanent information , and the driver handles initialization , output , and errors .
We could add many features to this calculator to make it more useful , but the code is long enough as it is , and most features would just add code without providing additional insight into the use of .

The basic units of an expression are numbers , names , the operators , + unary ,
Names need not be declared before use .

use style of syntax analysis called recursive descent ; it is popular straightforward topdown technique .
In language such as , in which function calls are relatively cheap , it is also efﬁcient .
For each production in the grammar , there is function that calls other functions .
Terminal symbols example , end , number , + are recognized by lexical analyzer nonterminal symbols are recognized by the syntax analyzer functions ,
As soon as both operands of are known , the expression is evaluated ; in real compiler , code could be generated at this point .

For input , the parser uses that encapsulates the reading of characters their composition into Tokens .
That is , it turns streams of characters , such as , into Tokens .
Token is pair , such as , where the has been turned into ﬂoating point value .
The main parts of the parser need only to know the of the , ts , how to get Tokens from it .
To read the next Token , it calls .
To get the most recently read Token , it calls .
In addition to providing tokenizing , the hides the actual source of the characters .
see that they can come directly from user typing to cin , from program command line , or from any other input stream .

The deﬁnition of Token looks like this : enum class Kind  char .

Representing each token by the integer value of its character is convenient efﬁcient can be help to people using debuggers .
This works as long as no character used as input has value used as an enumerator no current character set know of has printing character with singledigit integer value .

The interface to looks like this : class .

Each parser function takes bool argument , called get , indicating whether the function Expressions Chapter expression returns the value .
The function handles addition subtraction .

In manner typical of functions in large program , it calls other functions to do the work .

If value tested does not match any case label , default is chosen .

Note that an expression such as is evaluated as , as speciﬁed in grammar .

However , are not only shorter but also express intended operation directly .
Each assignment operator is separate lexical token , so + is syntax error because of space between +

provides assignment for binary  + so that following assignment are possible : is modulo , or remainder , operator ; are bitwise logical  or , exclusive or ; are shift right shift  summarizes their meanings .
For binary operator applied to operands of types , an expression means , except that is evaluated once only .

We therefore test for before dividing call if we detect zero divisor .

Consequently , division assignment are done if only if is nonzero .

Similarly , when Token that is name deﬁned ; see is seen , its value is placed in its .

Note that always reads one more Token than it uses to analyze its primary expression .

In cases where parser function simply wants to move ahead to next Token , it use return value from .
ﬁne because we can get result from .
Had ignoring return value of bothered me , hav either added function that just updated without returning value or explicitly away " result :

Before doing anything to name , calculator must ﬁrst look ahead to see if it is being assigned to or simply read .
In both cases , symbol table is consulted .
For example , if user enters ; calculator will reach case execute ;

Chapter Chapter discuss how to org anize program as set of modules .
However , with one exception , declarations for this calculator example can be ordered so that everything is declared exactly once before it is used .
This loop of calls must be broken somehow .
declaration double ; before deﬁnition of will do nicely .

To communicate with person , program must cope with that whims , conventions , seemingly random errors .
Trying to force person to behave in manner more suitable for machine is often considered offensive .
These tokens are then units of input for routines .
Here , input is done by .
Writing input routine need not be an everyday task .
Many systems provide standard functions for this .

First we need to see complete deﬁnition of : class .

We initialize with an input stream , Chapter from which it gets its characters .
The implements the convention that it eventually deletes ; an istream passed as pointer , but not an istream passed as reference .
This may be bit elaborate for this simple program , but it is useful and general technique for classes that hold pointer to resource requiring destruction .

holds three values : pointer to its input stream , Boolean , indicating ownership of the input stream , and the current token .

gav ct default value because it seemed sloppy not to .
People should not call before , but if they do , they get Token .
chose as the initial value for ct so that program that misuses will not get value that on the input stream .

present in two stages .
First , provide deceptively simple version that imposes burden on the user .
Next , modify it into slightly less elegant , but much easier to use , version .
The idea for is to read character , use that character to decide what of token needs to be composed , read more characters when needed , and then return Token representing the characters read .

Assignment is an operator , and the result of the assignment is the value of the variable assigned to .
This allows me to assign the value to and return it in the same statement .

Having single statement rather than two is useful in maintenance .
If the assignment and the return became separated in the code , programmer might update the one and forget to update the other .

good if we care about the last two members of the Token and not so good if we are worried about performance .
Neither is the case here , but in general dealing with complete objects is clearer and less than manipulating data members individually .
The cases below giv examples of the other strategy .

Consider some of the cases separately before considering the complete function .
The expression terminator , the parentheses , and the operators are handled simply by returning their values : end of expression ; print : return ; The is needed because there is no implicit conversion from char to Kind ; only some characters correspond to Kind values , so we have to " that in this does .

Numbers are handled like this : Section Input ; put the ﬁrst digit back into the input stream ; read the number into ; return  Stacking labels horizontally rather than vertically is generally not good idea because this arrangement is harder to read .
However , having one line for each digit is tedious .
Because operator is already deﬁned for reading values into double , the code is trivial .
First the initial character digit or is put back into cin .
Then , the value can be read into .

If the token is not the end of input , an operator , punctuation character , or number , it must be .
is handled similarly to number : default :  or error if .

Operator applied to string this  reads until it hits whitespace .
This is less than ideal , so we will return to this problem in .

Here , ﬁnally , is the complete input .

The conversion of an to its Token value is trivial because the of an was deﬁned as the integer value of the .

It is tedious to remember to add semicolon after an expression in order to get its value printed , and having terminated by whitespace only is real nuisance .
For example , is an identiﬁer rather than the identiﬁer followed by the and the number .
To get what we want , we would have to add whitespace after 
Both problems are solved by replacing the default input operations in with code that reads individual characters .

First , make newline equivalent to the semicolon used to mark the .

The call reads single character from the input stream succeeds if no character can be read from cin ; in this  is returned to terminate the calculator session .

The test is implemented as table lookup , so using is much faster than testing for the individual whitespace characters .
Similar functions test if character is digit , letter , or digit or letter .

After whitespace has been skipped , the next character is used to determine what of lexical token is coming .

The problem caused by reading into string until whitespace is encountered is solved by reading one character at time until character that is not letter or digit is found : default :  or error if .

Constructing programs so that improvements can be implemented through local modiﬁcations only is an important design aim .

You might worry that adding characters to the end of string one by one would be inefﬁcient .
It would be for very long strings , but all modern string implementations provide the string optimization "
That means that handling the of strings we are likely to use as names in calculator even in inv olve any inefﬁcient operations .
In particular , using short string require any use of free store .
The maximum number of characters for short string is , but would be good guess .

However , for this program , simple handling strategy sufﬁces .
The function simply counts the errors , writes out an .

The stream is an unbuffered output stream usually used to report errors .

The reason for returning value is that errors typically occur in the middle of the evaluation of an expression , so we should either abort that evaluation entirely or return value that is unlikely to Expressions Chapter kept track of the line numbers , could have informed the user approximately where the occurred .
This would be useful when the calculator is used noninteractively .

more stylized and general strategy would separate detection from recovery .
This can be implemented using exceptions , Chapter , but what we have here is quite suitable for calculator .

decided on two functions : to do setup and reporting and to handle the actual .

Conventionally , returns zero if the program terminates normally and nonzero otherwise .
Returning the number of errors accomplishes this nicely .
As it happens , the only initialization needed is to insert the predeﬁned names into the symbol table .

The primary task of the main loop is to read expressions and write out the answer .
This is achieved by the line : The argument tells that it does not need to call to read token on which to work .

Testing for ensures that the loop is correctly exited when encounters an input or an .
exits its nearest enclosing or loop .
Testing for is , for ' and relieves of the responsibility for handling empty expressions .
is equivalent to going to the very end of loop .

Therefore , appropriate headers must be to complete the .

Chapter and Chapter discuss ways of organizing this calculator into modules using namespaces and how to org anize it into source ﬁles .

My most common use was to evaluate single expression .
If that expression could be presented as argument , few keystrokes could be avoided .

program starts by calling ,
When this is done , is given two arguments specifying the number of arguments , conventionally called  and an array of arguments , conventionally called argv .
The arguments are character strings , so the type of argv is .
The of the program it occurs on the command is passed as , so is always at least .
The list of arguments is ; that is ,

For example , for the command dc the arguments have these values :  argv : Because the conventions for calling are shared with , arrays and strings are used .

The idea is to read from the command string in the same way that we read from the input stream .
stream that reads from string is unsurprisingly called an istringstream .
So to calculate expressions presented on the command line , we simply have to get our to read from an appropriate istringstream : Expressions Chapter .

It would be easy to modify to accept several arguments , but this does not appear to be necessary , especially as several expressions can be passed as single .

Some characters from the basic source character set , such as , are not convenient to type on some keywords .
Also , some programmers ﬁnd it odd to use of symbols , such as and , for basic logical operations .
Consequently , set of alternative representation are provided as keywords : and bitand bitor compl not or xor .

The overall aim is produce result of the " operand type .

For example , if binary operator has operand , the computation is done using arithmetic the result is value .
Similarly , if it has long operand , the computation is done using long integer arithmetic , the result is long .
Operands that are smaller than an int as bool are converted int before the operator is applied .

The meaning result type of are determined by their declarations .

Where logically feasible , the result of an operator that takes an lvalue operand is an lvalue denoting that lvalue operand .

Preserving lvalues in this way allows greater ﬂexibility in using .

This is particularly useful when writing code that needs work uniformly efﬁciently with both types , when writing templates or programs that generate .

The result of sizeof is of an unsigned integral type called deﬁned in .
The result of pointer subtraction is of signed integral type called deﬁned in .

Implementations do not have check for arithmetic overﬂow hardly any do .

This will try increase past the largest integer .
What happens then is undeﬁned , but typically the value around " neg ative number my machine .
Similarly , the effect of dividing by zero is undeﬁned , but doing so usually causes abrupt termination of the program .
In particular , underﬂow , overﬂow , division by zero do not throw standard exceptions .

In particular , you cannot assume that the expression is evaluated .
For example : int ; undeﬁned whether or is called ﬁrst .

Compilers can warn about such ambiguities .
Unfortunately , most do not , so be careful not write an expression that reads or writes an object more than once , unless it does so using single Expressions Chapter operator that makes it well deﬁned , such as , or explicitly express sequencing using  or .

The  guarantee that their operand is evaluated before their operand .
For example , assigns .
Examples of the use of can be found in .
For types , the second operand of is evaluated only if its ﬁrst operand is true , the second operand of is evaluated only if its ﬁrst operand is false ; this is sometimes called evaluation .
Note that the sequencing operator  is logically different from the comma used separate arguments in function call .

The call of has two arguments , the order of evaluation of the argument expressions is undeﬁned .

Order dependence of argument expressions is very poor style has undeﬁned behavior .
The call of has only one argument , the comma expression , which is equivalent .
That is confusing , so that too should be avoided .

Parentheses can be used force grouping .
For example , means , so parentheses must be used get ; may be evaluated as only if the user cannot tell the difference .
In particular , for many computations are signiﬁcantly different , so compiler will evaluate such expressions exactly as written .

However , parentheses should be used whenever programmer is in doubt about those rules .
Use of parentheses becomes more common as the subexpressions become more complicated , but complicated subexpressions are source of errors .
Therefore , if you start feeling the need for parentheses , you might consider breaking up the expression by using an extra variable .

There are cases when the operator precedence does not result in the " interpretation .

Fortunately , it is easy enough for compiler warn about most such mistakes .
In this case , parentheses are important :

It is worth noting that the following does not work the way mathematician might expect : Section Operator Precedence .

This is legal , but it is interpreted , where the result the ﬁrst comparison is either true or false .
This Boolean value is then implicitly converted or , which is then compared , yielding true .
To test whether is in the range , we might .

common mistake for novices is instead in condition :
Again , it is easy for compiler warn about most such mistakes many do .
do not recommend warping your style compensate for compilers with weak warnings .
In particular , consider this style worthwhile : tr protect against misuse ; not recommended Temporary Objects Often , the compiler must introduce an object hold an intermediate result an expression .
For example , for the result has be put somewhere before it is added .
For types , this is all handled so that temporary object referred just is invisible the user .
Howev er , for type that holds resource knowing the lifetime temporary can be important .
Unless bound to reference or used to initialize named object , temporary object is destroyed at the end the full expression in which it was created .
full expression is an expression that is not subexpression some other expression .

The string has member that returns pointer to zeroterminated array characters ,
Also , the operator + is deﬁned to mean string concatenation .
These are useful facilities for strings .
However , in combination they can cause obscure .

Probably , your ﬁrst reaction is do " agree .
However , such code does get written , so it is worth knowing how it is interpreted .

temporary string object is created to hold .
Next , pointer to string is extracted from that object .
Then at the end the expression the temporary object is deleted .

However , the string returned by was allocated part the temporary object holding , that storage is not guaranteed to exist after that temporary is destroyed .
Consequently , points to deallocated storage .
The output operation might work expected , but that would be sheer luck .
compiler can detect warn against many variants this problem .

The condition will work expected the full expression in which the temporary holding is created is the condition itself .

However , that temporary is destroyed before the controlled statement is entered , so any there is not guaranteed to work .

Please note that in this case , in many others , the problems with temporaries arose from using data type in way .
cleaner programming style yields more understandable program fragment avoids the problems with temporaries completely .

The temporary is destroyed when " reference or named object goes out scope .

Remember that returning reference to local variable is an error that temporary object cannot be bound to lvalue reference .

temporary object can also be created explicitly in an expression by invoking constructor .

Basically , constexpr ' role is to enable ensure evaluation , whereas const ' Section Constant Expressions primary role is to specify immutability in interfaces .
This section is primarily concerned with the ﬁrst role : evaluation .

constant expression is an expression that compiler can evaluate .
It cannot values that are not known at compile time and it cannot have side effects .
Ultimately , constant expression must start out with an integral value , value , or an enumerator , and we can combine those using operators and constexpr functions that in turn produce values .
In addition , some addresses can be used in some forms constant expressions .
For simplicity , discuss those separately in .

There are variety reasons why someone might want named constant rather than literal or value stored in variable : Named constants make the code easier to understand and maintain .

Also , data in memory is immune to most system crashes .

Note that reasons , and are logical .
We just constant expressions an obsession with performance .
Often , the reason is that constant expression is more direct representation our system requirements .

As part the deﬁnition data item , deliberately avoid the word , constexpr expresses the need for evaluation .
If the initializer for constexpr be evaluated at compile time , the compiler will give an error .
For example : int .

clever compiler could deduce that the value in the initializer for was .
Howev er , we prefer to rely on degrees cleverness in compilers .
In large program , determining the values variables at compile time is typically either very difﬁcult or impossible .

We can use integer , and enumeration values .
We can use any operator that modify state , + and , but or .
We can use constexpr functions and literal types to provide signiﬁcant level of type safety and expressive power .
It is almost unfair to compare this to what is commonly done with macros .

The operator : is the means of selection in constant expression .
For example , we can compute an integer square root at compile .

The condition of : is evaluated and then the selected alternative is evaluated .
The alternative selected is evaluated and might even be constant expression .
Similarly , operands of and that are evaluated need be constant expressions .
This feature is primarily useful in constexpr functions that are sometimes used as constant expressions and sometimes .

Consider : Functions Chapter .

It is not possible to eliminate every form of confusion in overload resolution example , see , but giving parameters priority for arguments seems to minimize confusion .

The call was an example of that .

Note that these rules apply to arguments only .
There are no special rules for or for other types that just happen to be called some other .

To implement such interfaces , we have three choices : Use variadic : this allows us to handle an arbitrary number of arbitrary types in manner by writing small metaprogram that interprets the argument list to determine its meaning and take appropriate actions .

This allows us to handle an arbitrary number of arguments of single type in manner .
In many contexts , such homogeneous lists are the most common and important case .

This solution is not inherently and can be hard to use with sophisticated types .
However , this mechanism has been used from the earliest days of .

The ﬁrst two mechanisms are described elsewhere , so describe only the third mechanism though consider it inferior to the others for most .
For example : int .

Such function must rely on information not available to the compiler when interpreting its argument list .
In the case of , the ﬁrst argument is format string containing special character sequences that allow to handle other arguments correctly ; means argument " and means an int " Howev er , the compiler cannot in general ensure that the expected arguments are really provided in call or that an argument is of the expected type .

This is not valid code , but most compilers will not catch this error .
At best , it will produce some output .

In that case , char or short is passed as an int and ﬂoat is passed as double .
This is not necessarily what the programmer expects .

program needs at most few functions for which the argument types are not completely speciﬁed .
Overloaded functions , functions using default arguments , functions taking arguments , and variadic templates can be used to take care of type checking in most cases when one would otherwise consider leaving argument types unspeciﬁed .
Only when both the number of arguments and the types of arguments vary and variadic solution is deemed undesirable is the ellipsis necessary .

The most common use of the ellipsis is to specify an interface to library functions that were deﬁned before provided .

standard set of macros for accessing the unspeciﬁed arguments in such functions can be found in .
Consider writing an error function that takes one integer argument indicating the severity of the error followed by an arbitrary number of strings .
The idea is to compose the error message by passing each word as separate string argument .
The list of string arguments should be terminated by the null .

always pass because that , conventionally , is the name of the program .

Note that using the integer as the terminator would not have been portable : on some implementations , the integer and the null pointer do not have the same representation .
This illustrates the subtleties and extra work that face the programmer once type checking has been suppressed using the ellipsis .

First , is deﬁned and initialized by call of .
The macro takes the name of the and the name of the last formal argument as arguments .
The macro is used to assumes that an actual argument of that type has been passed , but it typically has no way of ensuring that .
Before returning function in which has been used , must be called .
The reason is that may modify the stack in such way that return cannot successfully be done ; undoes any such modiﬁcations .

Alternatively , could have been deﬁned using .

If hav to mimic style , would further simplify the code by passing container as single argument : void severity , const almost as before .

That would allow later improvements of .
The use of the is far less than any use of an unspeciﬁed number of arguments .

In particular , functions that construct objects often provide several options for ﬂexibility .
Consider class complex : class complex double re ,

The actions of complex ' constructors are quite trivial , but logically there is something odd about having three functions , doing essentially the same task .
Also , for many classes , Section Default Arguments constructors do more work and the repetitiveness is common .
We could deal with the repetitiveness by considering one of the constructors real one " and forward to that :  double , construct complex two scalars .

Say we wanted to add some debugging , tracing , or code to complex ; we now have single place to do so .
However , this can be abbreviated further : double , construct complex two scalars This makes it clear that if user supplies fewer than the two arguments needed , the default is used .

The intent of having single constructor plus some shorthand notation is now explicit .

default argument is type checked at the time of the function declaration and evaluated at the time of the call .
For example : class .

Using same name for operations on different types is called overloading .
The technique is already used for basic operations in .
That is , there is only one name for addition , + yet it can be used to add values of integer and types and combinations of such types .
This idea is easily extended to functions deﬁned by programmer .
For example : void ; print an void ; print string As far as compiler is concerned , only thing functions of same name have in common is that name .
Presumably , functions are in some sense similar , but language does not constrain or aid programmer .
Thus , overloaded function names are primarily notational convenience .

This convenience is for functions with conventional names such as sqrt , print , and open .

When name is semantically  this convenience becomes essential .
This happens , for example , with operators such as + and , in case of constructors , and in generic programming , Chapter .

Templates provide systematic way of deﬁning sets of overloaded functions .

This is done by comparing types of actual arguments with types of parameters of all functions in scope called fct .
The idea is to invoke function that is best match to arguments and give error if no function is best match .

The resolution rules are this elaborate primarily to take into account elaborate and rules for numeric types .

The reason to distinguish between conversions and promotions is that we want to prefer safe promotions , such as to  over unsafe conversions , such as to .

Overload resolution is independent of order of declaration of functions considered .

Function templates are handled by applying overload resolution rules to result of specialization based on set of arguments .
There are separate rules for overloading when is used lists take priority ; and for rvalue reference template arguments .

Overloading relies on relatively complicated set of rules , and occasionally programmer will be surprised which function is called .

Consider alternative to overloading .

Often , we need similar operations performed on objects of several types .
Without overloading , we must deﬁne several functions with different names : Functions Chapter .

Compared to overloaded , we hav to remember several names and remember to use those correctly .
This can be tedious , defeats attempts to do generic programming , and generally encourages programmer to focus on relatively type issues .
Because there is no overloading , all standard conversions apply to arguments to these functions .
It can also lead to errors .

In previous example , this implies that only one of four calls with doubtful semantics is caught by compiler .
In particular , two calls rely on narrowing ,

Thus , overloading can increase chances that an unsuitable argument will be rejected by compiler .

The reason is to keep resolution for an individual operator , or function call .

If return type were taken into account , it would no longer be possible to look at call of in isolation and determine which function was called .

By default , that means functions of single scope ; functions declared in different scopes do not overload .
For example : Section Overloading and Scope .

Clearly , would have been best match for , but only is in scope .
In such cases , local declarations can be added or subtracted to get desired behavior .
As always , intentional hiding can be useful technique , but unintentional hiding is source of surprises .

base class and derived class provide different scopes so that overloading between base class function and derived class function happen by default .

When overloading across class scopes or namespace scopes is wanted , usingdeclarations or can be used .
lookup can also lead to overloading across namespaces .

function that is the best match for one argument and better or equal match for all other arguments is called .
If no such function exists , the call is rejected as ambiguous .

The call is ambiguous because is the best match for the ﬁrst argument of and is the best match for the second argument of .

Often the problem can be solved by adding version that resolves ambiguities .
For example , adding inline void ; would resolve all ambiguities similar to in favor of the larger type long int .

One can also add an explicit type conversion to resolve speciﬁc call .
For example : However , this is most often simply an ugly stopgap .
Soon another similar call will be made and have to be dealt with .

Some novices get irritated by the ambiguity errors reported by the compiler .
More experienced programmers appreciate these error messages as useful indicators of design errors .

Some of these expectations are expressed in the argument types , but others depend on the actual values passed and on relationships among Section and Postconditions argument values .
The compiler and linker can ensure that arguments are of the right types , but it is up to the programmer to decide what to do about " argument values .
We call logical criteria that are supposed to hold when function is called preconditions , and logical criteria that are supposed to hold when function returns its postconditions .
For example : calculate the area of rectangle precondition : len and wid are positive postcondition : the return value is positive postcondition : the return value is the area of rectange with sides len and wid return ; Here , the statements of the and postconditions are longer than the function body .
This may seem excessive , but the information provided is useful to the implementer , to the users of , and to testers .
For example , we learn that and are not considered valid arguments .
Furthermore , we note that we could pass couple of huge values without violating the precondition , but if overﬂows either or both of the postconditions are not met .

Yes , but what if the caller .

If so , how is an error to be handled .

There are several possible answers to these questions .
It is easy for caller to make mistake and fail to establish precondition .
It is also difﬁcult for an implementer to cheaply , efﬁciently , and completely check preconditions .
We would like to rely on the caller to get the preconditions right , but we need way to test for correctness .
For now , just note that some and postconditions are easy to check , len is positive and is .
Others are semantic in nature and hard to test directly .
For example , how do we test return value is the area of rectangle with sides len and .
This is semantic constraint because we have to know the meaning of of " and just trying to multiply len and wid again with precision that precluded overﬂow could be costly .

It seems that writing out the and postconditions for uncovered subtle problem with this very simple function .

Writing out and postconditions is great design tool and provides good documentation .
Mechanisms for documenting and enforcing conditions are discussed in .

If function depends only on its arguments , its preconditions are on its arguments only .
Howev er , we hav to be careful about functions that depend on values , member function that depends on the state of its .
In essence , we have to consider every nonlocal value read as an implicit argument to function .
Similarly , the postcondition of function without side effects simply states that value is correctly computed , but if function writes to nonlocal objects , its effect must be considered and documented .

If postconditon fails , there was either an unchecked precondition or programming error .

We can have pointer to function just as we can have pointer to an object .

However , for variety of reasons some related to machine architecture and others to system design pointer to function does not allow the code to be modiﬁed .
There are only two things one can do to function : call it and take its address .
The pointer obtained by taking the address of function can then be used to call the function .
For example : void .

The rules for argument passing are the same for calls directly to function and for calls to function through pointer .

You can convert pointer to function to different type , but you must cast the resulting pointer back to its original type or strange things may .

Macros can even be variadic .
For example : The ellipsis means that represents the arguments actually passed as string , so the output is : error : The Conditional Compilation One use of macros is almost impossible to avoid .
The directive IDENTIFIER does nothing if IDENTIFIER is deﬁned , but if it is not , the directive causes all input to be ignored until directive is seen .
For example : Unless macro called has been  this produces : int ; This example confuses tools that assume sane behavior from the programmer .

Names of the macros used to control should be chosen carefully so that they clash with ordinary identiﬁers .

This source text will cause some confusion should someone write : Unfortunately , common and unavoidable headers contain many dangerous and unnecessary macros .

Its value is in program ; previous standards have lower values .

In addition , few macros are conditionally deﬁned by the .

For example : in   on  In addition , most implementations allow user to deﬁne arbitrary macros on the command or in some other form of environment .
For example , NDEBUG is deﬁned unless the compilation is done in mode " and is used by the macro .
This can be useful , but it does imply that you be sure of the meaning of program just by reading its source text .

Obviously , the standard cannot specify how such facilities are provided , but one standard syntax is of tokens preﬁxed with the preprocessor directive .
For example : foo bar foobar If possible , are best avoided .

Error Handling Exceptions ; Traditional Error Handling ; Muddling Through ; Alternative Views of Exceptions ; When You Use Exceptions ; Hierarchical Error Handling ; Exceptions and Efﬁciency .

Resource Management Finally .

Throwing and Catching Exceptions Throwing Exceptions ; Catching Exceptions ; Exceptions and Threads .

vector Implementation Simple vector ; Representing Memory Explicitly ; Assignment ; Changing Size .

Advice Error Handling This chapter presents error handling using exceptions .
For effective error handling , the language mechanisms must be used based on strategy .
Consequently , this chapter presents the exceptionsafety guarantees that are central to recovery from errors and the Resource Acquisition Is Initialization technique for resource management using constructors and destructors .
Both the guarantees and RAII depend on the speciﬁcation of invariants , so mechanisms for enforcement of assertions are presented .

The language facilities and techniques presented here address problems related to the handling of errors in software ; the handling of asynchronous events is different topic .

Such parts of program are often separately developed .
Consequently , often refer to part of program that is invoked to perform task as " library is just ordinary code , but in the context of discussion of error handling it is worth remembering that library designer often cannot even know what kind of programs the library will become part .

The author of library can detect error but does not in general have any idea what to do about it .

The user of library may know how to cope with error but cannot easily detect it else it would have been handled in the code and not left for the library to .

The discussion of exceptions focuses on problems that need to be handled in systems , systems with stringent reliability requirements , and libraries .
Different kinds of programs have different requirements , and the amount of care and effort we expend should reﬂect that .
For example , would not apply every technique recommended here to program written just for myself .
However , many of the techniques presented here simplify code , so would use those .

function that cannot cope with problem throws an exception , hoping that its or caller can handle the problem .
function that wants to handle kind of problem indicates that by catching the corresponding exception .

calling component indicates the kinds of failures that it is willing to handle by specifying those exceptions in of .

called component that cannot complete its assigned task reports its failure to do so by throwing an exception using .

Consider simpliﬁed and stylized .

If can do that job and return correct  is prepared to handle , but some other kind of exception may be thrown .
For example , may call other functions to do lot of subtasks , and one of those may throw because it do its assigned subtask .
An exception different from indicates failure of to do its job and must be handled by whatever code invoked .

called function cannot just return with an indication that an error happened .
If the program is to continue working not just print an error message and , the returning function must leave the program in good state and not leak any resources .
The mechanism is integrated with the mechanisms and the concurrency mechanisms to help ensure that .
The .

Is an alternative to the traditional techniques when they are insufﬁcient , inelegant , or errorprone .

Is complete ; it can be used to handle all errors detected by ordinary code .

Supports more regular style of error handling , thus simplifying cooperation between separately written program fragments An exception is an object thrown to represent the occurrence of an error .
It can be of any type that can be copied , but it is strongly recommended to use only types speciﬁcally deﬁned for that purpose .
That way , we minimize the chances of two unrelated libraries using the same value , say , to represent different errors , thereby throwing our recovery code into chaos .

An exception is caught by code that has expressed interest in handling particular type of exception .
Thus , the simplest way of deﬁning an exception is to deﬁne class speciﬁcally for kind of error and throw that .

If that gets tedious , the standard library deﬁnes small hierarchy of exception classes .

An exception can carry information about the error it represents .
Its type represents the kind of error , and whatever data it holds represents the particular occurrence of that error .
For example , the exceptions contain string value , which can be used to transmit information such as the location of the throw .

Each conventional approach has problems , and none are general : Exception Handling Chapter .

Terminate the program .
This is pretty drastic approach .
For example : if ; For most errors , we can and must do better .
For example , in most situations we should at least write out decent error message or log the error before terminating .
In particular , library that know about the purpose and general strategy of the program in which it is embedded cannot simply or .
library that unconditionally terminates cannot be used in program that cannot afford to crash .

Return an error value .
This is not always feasible because there is often no acceptable " For example : int ; get next integer from input For this input function , every int is possible  so there can be no integer value representing an input failure .
At minimum , we would have to modify to return pair of values .
Even where this approach is feasible , it is often inconvenient because every call must be checked for the error value .
This can easily double the size of program .

Also , callers often ignore the possibility of errors or simply forget to test return value .

Consequently , this approach is rarely used systematically enough to detect all errors .
For example , returns negative value if an output or encoding error occurred , but programmers essentially never test for that .
Finally , some operations simply do not have return values ; constructor is the obvious example .

Return legal value and leave the program in an '  This has the problem that the calling function may not notice that the program has been put in an error state .
For example , many standard library functions set the nonlocal variable errno to indicate an error , double ; Here , the value of is meaningless and errno is set to indicate that an acceptable argument for square root function .
However , programs typically fail to set and test errno and similar nonlocal state consistently enough to avoid consequential errors caused by values returned from failed calls .
Furthermore , the use of nonlocal variables for recording error conditions work well in the presence of concurrency .

Call an function .
For example : if ; and possibly continue here This must be some other approach in disguise because the problem immediately becomes does the function " Unless the function can completely resolve the problem , the function must in turn either terminate the program , return with some indication that an error had occurred , set an error state , or throw an exception .
Also , if the function can handle the problem without bothering the ultimate caller , why do we consider it an error .

Traditionally , an unsystematic combination of these approached in program .

The traditional response has been to muddle through and hope for the best .
Thus , exception handling makes programs more " in the sense that more care and effort must be taken to get program to run acceptably .
This is preferable , though , to getting wrong results later in the development process or after the development process is considered complete and the program is handed over to innocent users .
Where termination is unacceptable , we can catch all exceptions .

Thus , an exception terminates program only if programmer allows it to terminate .
Typically , this is preferable to the unconditional termination that happens when traditional incomplete recovery leads to catastrophic error .
Where termination is an acceptable response , an uncaught exception will achieve that because it turns into call of .
Also , noexcept speciﬁer can make that desire explicit .

Sometimes , people try to alleviate the unattractive aspects of through " by writing out error messages , putting up dialog boxes asking the user for help , etc .
Such approaches are primarily useful in debugging situations in which the user is programmer familiar with the structure of the program .
In the hands of nondevelopers , library that asks the for help is unacceptable .
good library " in this way .
If user has to be informed , an exception handler can compose suitable message , in Finnish for Finnish users or in XML for an .
Exceptions provide way for code that detects problem from which it cannot recover to pass the problem on to part of the system that might be able to recover .
Only part of the system that has some idea of the context in which the program runs has any chance of composing meaningful error message .

Please recognize that error handling will remain difﬁcult task and that the mechanism although more formalized than the techniques it replaces is still relatively unstructured compared with language features involving only local control ﬂow .
The mechanism provides the programmer with way of handling errors where they are most naturally handled , given the structure of system .
Exceptions make the complexity of error handling visible .
However , exceptions are not the cause of that complexity .
Be careful not to blame the messenger for bad news .

The mechanism is designed to support handling of errors that cannot be handled locally .
In particular , it is intended to support error handling in programs composed of independently developed components .
Given that there is nothing particularly exceptional about part of program being unable to perform its given task , the word " may be considered bit misleading .
Can an event that happens most times program is run be considered exceptional .
Can an event that is planned for and handled be considered an error .
The answer to Exception Handling Chapter Asynchronous Events The mechanism is designed to handle only synchronous exceptions , such as array range checks and errors .
Asynchronous events , such as keyboard interrupts and power failures , are not necessarily exceptional and are not handled directly by this mechanism .
Asynchronous events require mechanisms fundamentally different from exceptions deﬁned to handle them cleanly and efﬁciently .
Many systems offer mechanisms , such as signals , to deal with asynchrony , but because these tend to be , they are not described here .

Exception throws should be infrequent compared to function calls or the structure of the system has been obscured .
However , we should expect most large programs to throw and catch at least some exceptions in the course of normal and successful run .

If an exception is expected and caught so that it has no bad effects on the behavior of the program , then how can it be an error .
Only because the programmer thinks of it as an error and of the mechanisms as tools for handling errors .
Alternatively , one might think of the mechanisms as simply another control structure , an alternative way of returning value to caller .
Consider binary tree search .

This actually has some charm , but it should be avoided because it is likely to cause confusion and inefﬁciencies .
When at all possible , stick to the handling is error handling " view .

When this is done , code is clearly separated into two categories : ordinary code and code .
This makes code more comprehensible .
Furthermore , the implementations of the exception mechanisms are optimized based on the assumption that this simple model underlies the use of exceptions .

Error handling is inherently difﬁcult .
Anything that helps preserve clear model of what is an error and how it is handled should be treasured .

However , we must reluctantly conclude that there are programs that for practical and historical reasons cannot use exceptions .

component of an embedded system where an operation must be guaranteed to complete in speciﬁc maximum time .
In the absence of tools that can accurately estimate the maximum time for an exception to propagate from throw to catch , alternative methods must be used .

large old program in which resource management is an ad hoc mess , free store is unsystematically " using " pointers , news , and , rather than relying on some systematic scheme , such as resource handles , string and vector ;

In such cases , we are thrown back onto " techniques .
Because such programs arise in great variety of historical contexts and in response to variety of constraints , cannot give general recommendation for how to handle them .
However , can point to two popular .

To mimic RAII , give every class with constructor an operation that returns some useful convention is for to represent success .
If the constructor fails to establish the class invariant , it ensures that no resource is leaked and returns nonzero .
This solves the problem of how to get an error condition out of constructor .
user can then systematically test after each construction of an object and engage in suitable error handling in case of failure .

To mimic function either returning value or throwing an exception , function can return .
user can then systematically test the after each function call and engage in suitable error handling in case of failure .

Variations of this scheme have been reasonably successful , but they are clumsy compared to using exceptions in systematic manner .

The assumption is that the two parts of the program are written independently and that the part of the program that handles the exception often can do something sensible about the error .

To use handlers effectively in program , we need an overall strategy .
That is , the various parts of the program must agree on how exceptions are used and where errors are dealt with .
The mechanisms are inherently nonlocal , so adherence to an overall strategy is essential .

This implies that the strategy is best considered in the earliest phases of design .
It also implies that the strategy must be simple to the complexity of the total and explicit .
Something complicated would not be consistently adhered to in an area as inherently tricky as error recovery .

Successful systems are multilevel .
Each level copes with as many errors as it can without getting too contorted and leaves the rest to higher levels .
Exceptions support that view .

Furthermore , supports this view by providing an escape if the mechanism itself is corrupted or if it has been incompletely used , thus leaving exceptions uncaught .

Similarly , noexcept provides simple escape for errors where trying to recover seems infeasible .

Not every function should be ﬁrewall .
That is , not every function can test its preconditions well enough to ensure that no errors could possibly stop it from meeting its postcondition .
The reasons that this will not work vary from program to program and from programmer to programmer .

However , for larger programs : The amount of work needed to ensure this notion of " is too great to be done consistently .

However , separating the program into distinct subsystems that either complete successfully or fail in ways is essential , feasible , and economical .
Thus , major libraries , subsystems , and key interface functions should be designed in this way .
Furthermore , in most systems , it is feasible to design every function to ensure that it always either completes successfully or fails in welldeﬁned manner .

Usually , we hav the luxury of designing all of the code of system from scratch .
Therefore , to impose general strategy on all parts of program , we must take into account program fragments implemented using strategies different from ours .
To do this we must address variety of concerns relating to the way program fragment manages resources and the state in which it leaves the system after an error .
The aim is to have the program fragment appear to follow the general strategy even if it internally follows different strategy .

Occasionally , it is necessary to convert from one style of error reporting to another .
For example , we might check and possibly throw an exception after call to library or , conversely , catch an exception and set before returning to program from library : Section Hierarchical Error Handling .

In such cases , it is important to be systematic enough to ensure that the conversion of without clear strategy and therefore difﬁcult to be systematic about .

Error handling should be as far as possible hierarchical .
If function detects error , it should not ask its caller for help with recovery or resource acquisition .
Such requests set up cycles in the system dependencies .
That in turn makes the program hard to understand and introduces the possibility of inﬁnite loops in the and recovery code .

In addition , this can be done so that throwing an exception all that expensive compared to calling function .
Doing so without adding signiﬁcant memory overhead while maintaining compatibility with calling sequences , debugger conventions , is possible , but hard .
However , please remember that the alternatives to exceptions are not free either .
It is not unusual to ﬁnd traditional systems in which half of the code is devoted to error handling .

Consider simple function that appears to have nothing to do with exception .

Had not thrown an exception , it would have had to report its error some other way .
Consequently , the comparable code using ordinary code to handle errors instead of exceptions the plain code above , but something .

Using local buffer for would simplify the code by eliminating the calls to , but then have code instead .
Complexity tends to move around rather than just disappear .

People usually handle errors this systematically , though , and it is not always critical to do so .
However , when careful and systematic handling of errors is necessary , such housekeeping is best left to computer , that is , to the mechanisms .

The noexcept speciﬁer can be most helpful in improving generated code .
Consider : void noexcept ; void noexcept ; Now , the code generated for can possibly be improved .

No traditional function throws an exception , so most functions can be declared noexcept .

In particular , implementer knows that only few standard library functions as and can throw , and can take advantage of that fact to generate better code .

Before declaring function " noexcept , take minute to consider if it could possibly throw an exception .
For example , it might have been converted to use the operator  can throw , or it might call library that throws an exception .

As ever , discussions about efﬁciency are meaningless in the absence of measurements .

Only then can recovery be meaningful .
Therefore , we call an operation exceptionsafe if that operation leaves the program in valid state when the operation is terminated by throwing an exception .
However , for that to be meaningful and useful , we have to be precise about what we mean by " For practical design using exceptions , we must also break down the overly general " notion into few speciﬁc guarantees .

When reasoning about objects , we assume that class has class invariant ,

We assume that this invariant is established by its constructor and maintained by all functions with access to the object ' representation until the object is destroyed .
So , by valid state we mean that constructor has completed and the destructor has not yet been entered .
For data that easily viewed as an object , we must reason similarly .
That is , if two pieces of nonlocal data are assumed to have speciﬁc relationship , we must consider that an invariant and our recovery action must preserve it .
For example : namespace Points .

However , that was only stated in comment , and compilers do not read comments .
Such implicit invariants can be very hard to discover and maintain .

Before throw , function must place all constructed objects in valid states .
However , such valid state may be one that suit the caller .
For example , string may be left as the empty string or container may be left unsorted .
Thus , for complete recovery , an error handler may have to produce values that are more for the application than the ones existing at the entry to .

The standard library provides generally useful conceptual framework for design for program components .
The library provides one of the following guarantees for ev ery library .

The basic guarantee for all operations : The basic invariants of all objects are maintained , and no resources , such as memory , are leaked .
In particular , the basic invariants of every and type guarantee that you can destroy an object or assign to it after every operation .

The strong guarantee for key operations : in addition to providing the basic guarantee , either the operation succeeds , or it has no effect .
This guarantee is provided for key operations , such as , on list , and .

The nothrow guarantee for some operations : in addition to providing the basic guarantee , some operations are guaranteed not to throw an exception .
This guarantee is provided for few simple operations , such as of two containers and .

Violating requirement , such as having destructor exit by throwing an exception , is logically equivalent to violating fundamental language rule , such as dereferencing null pointer .
The practical effects are also equivalent and often disastrous .

Both the basic guarantee and the strong guarantee require the absence of resource leaks .
This is necessary for every system that cannot afford resource leaks .
In particular , an operation that throws an exception must not only leave its operands in states but must also ensure that every resource that it acquired is released .
For example , at the point where an exception is thrown , all memory allocated must be either deallocated or owned by some object , in turn must ensure that the memory is properly deallocated .

Remember that memory the only kind of resource that can leak .
consider anything that has to be acquired from another part of the system and or given back to be resource .
Files , locks , network connections , and threads are examples of system resources .
function may have to release those or hand them over to some resource handler before throwing an exception .

The language rules for partial construction and destruction ensure that exceptions thrown while constructing subobjects and members will be handled correctly without special attention from code .
This rule is an essential underpinning for all techniques dealing with exceptions .

In general , we must assume that every function that can throw an exception will throw one .

This implies that we must structure our code so that we get lost in rat ' nest of complicated control structures and brittle data structures .
When analyzing code for potential errors , simple , highly structured , code is the ideal ; includes realistic example of such code .

Often that release " is achieved by having the function that acquired it release it before returning to its caller .
For example : Section Resource Management .

Exactly the same problem can occur in languages that do not support exception handling .

For example , the standard library function can cause the same problem .
Even an ordinary could exit without closing .

ﬁrst attempt to make looks like .

The code using the ﬁle is enclosed in that catches every exception , closes the ﬁle , and rethrows the exception .

The problem with this solution is that it is verbose , tedious , and potentially expensive .
Worse still , such code becomes signiﬁcantly more complex when several resources must be acquired and released .
Fortunately , there is more elegant solution .
The general form of the problem looks like .

It is typically important that resources are released in the reverse order of their acquisition .
This Exception Handling Chapter strongly resembles the behavior of local objects created by constructors and destroyed by destructors .
Thus , we can handle such resource acquisition and release problems using objects of classes with constructors and destructors .
For example , we can deﬁne class that acts like : class .

In either case , will be destroyed at the end of its scope and its destructor will close the ﬁle .
throws an exception if it cannot open ﬁle because otherwise every operation on the ﬁle handle would have to test for nullptr .
Our function now shrinks to this .

The destructor will be called independently of whether the function is exited normally or exited because an exception is thrown .
That is , the mechanisms enable us to remove the code from the main algorithm .
The resulting code is simpler and less errorprone than its traditional counterpart .

This technique for managing resources using local objects is usually referred to as Acquisition Is Initialization "
This is general technique that relies on the properties of constructors and destructors and their interaction with exception handling .

The problem with that approach is that you need to remember to and correct " the problem wherever resource is acquired in an undisciplined way dozens or hundreds of places in large , whereas the handler class need be written only once .

An object is not considered constructed until its constructor has completed .
Then and only then will stack unwinding call the destructor for the object .
An object composed of subobjects is constructed to the extent that its subobjects have been constructed .
An array is constructed to the extent that its elements have been constructed only fully constructed elements are destroyed during .

constructor tries to ensure that its object is completely and correctly constructed .
When that cannot be achieved , constructor restores as far as possible the state of the system to what it was before creation .
Ideally , constructor always achieves one of these alternatives and leave its object in some " state .
This can be simply achieved by applying the RAII technique to the members .

Consider class for which constructor needs to acquire two resources : ﬁle and mutex .
This acquisition might fail and throw an exception .
Class constructor must never complete having acquired the ﬁle but not the mutex the mutex and not the ﬁle , or .
Furthermore , this should be achieved without imposing burden of complexity on the programmer .

We use objects of two classes , and : to represent the acquired resources .
The acquisition of resource is represented by the initialization of the local object that represents the resource : class .

Now , as in the local object case , the implementation takes care of all of the bookkeeping .
The user hav to keep track at all .
For example , if an exception occurs after has been constructed but before lck has been , then the destructor for but not for lck will be invoked .

This implies that where this simple model for acquisition of resources is adhered to , the author of the constructor need not write explicit code .

The most common resource is memory , string , vector , the other standard containers use RAII to implicitly manage acquisition release .
Compared to ad hoc memory management using possibly also , this saves lots of work avoids lots of errors .

When pointer to an object , rather than local object , is needed , consider using the standardlibrary types , to avoid leaks .

Again again , people have inv ented " language constructs for writing arbitrary code to clean up after an exception .
Such techniques are generally inferior to RAII because they are ad hoc , but if you really want ad hoc , RAII can supply that also .
First , we deﬁne class that will execute an arbitrary action from its destructor .

In addition , the memory allocated pointed to by is appropriately deleted .

It is generally good idea to place guard close to the deﬁnition of whatever it is guarding .

That way , we can at glance see what is considered resource if ad what is to be done at the end of its scope .
The connection between actions the resources they manip is far better than scattering cleanup code around in block .

Basically , does for block what the increment part of does for the forstatement : it speciﬁes the ﬁnal action at the top of block where it is easy to be seen where it logically belongs from speciﬁcation point of view .
It says what is to be done upon exit from scope , saving the programmer from trying to write code at each of the potentially many places from which the thread of control might exit the scope .

Similarly , when constructor cannot establish its class invariant , the object is not usable .
In those cases , typically throw exceptions .
However , there are programs for which throwing an exception is not an option , there are people with different views of how to deal with the failure of precondition similar .

Just do that : It is the job to meet preconditions , if the caller do that , let bad results occur eventually those errors will be eliminated from the system through improved design , debugging , testing .

Terminate the program : Violating precondition is serious design error , the program must not proceed in the presence of such errors .
Hopefully , the total system can recover from the failure of one component eventually such failures may be eliminated from the system through improved design , debugging , testing .

Why would anyone choose one of these alternatives .
The ﬁrst approach often relates to the need for performance : systematically checking preconditions can lead to repeated tests of logically unnecessary conditions example , if caller has correctly validated data , millions of tests in thousands of called functions may be logically .
The cost in performance can be signiﬁcant .
It may be worthwhile to suffer repeated crashes during testing to gain that performance .

Obviously , this assumes that you eventually get all critical precondition violations out of the system .
For some systems , typically systems completely under the control of single organization , that can be realistic aim .

The second approach tends to be used in systems where complete timely recovery from precondition failure is considered infeasible .
That is , making sure that recovery is complete imposes unacceptable complexity on the system design implementation .
On the other hand , Exception Handling Chapter termination of program is considered acceptable .
For example , it is not unreasonable to consider program termination acceptable if it is easy to rerun the program with inputs parameters that make repeated failure unlikely .
Some distributed systems are like this long as the program that terminates is only part of the complete , so are many of the small programs we write for our own consumption .

Realistically , many systems use mix of exceptions these two alternative approaches .
All three share common view that preconditions should be deﬁned obeyed ; what differs is how enforcement is done whether recovery is considered feasible .
Program structure can be radically different depending on whether recovery is an aim .
In most systems , some exceptions are thrown without real expectation of recovery .
For example , often throw an exception to ensure some error logging or to produce decent error message before terminating or process , from in .

variety of techniques are used to express checks of desired conditions invariants .
When we want to be neutral about the logical reason for the check , we typically use the word assertion , often abbreviated to an assert .
An assertion is simply logical expression that is assumed to be true .
Howev er , for an assertion to be more than comment , we need way of expressing what happens if it is false .
Looking at variety of systems , see variety of needs when it comes to expressing .

We need to choose between asserts by the asserts at run .

For asserts we need choice of throw , terminate , or ignore .

No code should be generated unless some logical condition is true .
For example , some runtime asserts should not be evaluated unless the logical condition is true .
Usually , the logical condition is something like debug ﬂag , level of checking , or mask to select among asserts to enforce .

Asserts should not be verbose or complicated to write they can be very .

Not every system has need for or supports every alternative .

The standard offers two simple .

In , the standard library provides the macro , which checks its assertion , at run time if and only if the macro NDEBUG is not deﬁned .
If the assertion fails , the compiler writes out an error message containing the assertion , the source ﬁle name , and the source ﬁle line number and terminates the program .

The language provides , which unconditionally checks its assertion , at compile time .
If the assertion fails , the compiler writes out the message and the compilation fails .

Where and are insufﬁcient , we could use ordinary code for checking .

Evaluating condition that is expected to be true for some calls and not for others .

Checking precondition which should never fail .
What we would like is recognizable mechanism for checking assertions .
What follows here is slightly mechanism for expressing variety of assertions and variety of responses to failures .
First , deﬁne mechanisms for deciding when to test and deciding what to do if an assertion .

The idea is to test whenever an assertion has " lower than or equal to .
If an assertion fails , is used to choose among three alternatives .
The and are constants because the idea is to generate no code whatsoever for an assertion unless we have made decision to do so .
Imagine and to be set in the build environment for program , possibly as compiler options .

chose the name : at run to contrast with at compile ;

Further implementation trickery could be used to minimize the amount of code generated .

Alternatively , we could do more of the testing at run time if more ﬂexibility is needed .
This Assert is not part of the standard and is presented primarily as an illustration of the problems and the implementation techniques .
suspect that the demands on an assertion mechanism vary too much for single one to be used everywhere .

We can use : like .

The and are macros that expand at their point of appearance in the source code .
hide them from the view by placing them inside the implementation of Assert where they belong .

is the default exception , so we need not mention it explicitly .
Similarly , if we are willing to use the default assertion level , we need to mention the level explicitly : Section Enforcing Invariants .

It is possible to control the testing done and the response to testing through build options , controlling conditional through options in the program code .
That way , you can have debug version of system that tests extensively and enters the debugger and production version that does hardly any testing .

personally favor leaving at least some tests in the ﬁnal version of program .
For example , with Assert the obvious convention is that assertions marked as level zero will always be checked .
We nev er ﬁnd the last bug in large program under continuous development and maintenance .
Also , ev en if all else works perfectly , having few checks " left to deal with hardware failures can be wise .

Only the builder of the ﬁnal complete system can decide whether failure is acceptable or not .

The writer of library or reusable component usually does not have the luxury of terminating unconditionally .
interpret that to mean that for general library code , reporting an error preferably by throwing an exception is essential .

As usual , destructors should not throw , so use throwing in destructor .

This temporary may be further copied several times before it is caught : the exception is passed from called function to calling function until suitable handler is found .
The type of the exception is used to select handler in the of some .
The data in the exception object if any is typically used to produce error messages or to help recovery .
The process of passing the exception the stack " from the point of throw to handler is called stack unwinding .
In each scope exited , the destructors are invoked so that every fully constructed object is properly destroyed .

After the throw in , all the strings that were constructed are destroyed in the reverse order of their construction : but not , which the thread of control never reached , and not , which was unaffected .

Exceptions containing few words are very common .
The semantics of exception propagation are those of initialization , so objects of types with move semantics , are not expensive to throw .
Some of the most common exceptions carry no information ; the name of the type is sufﬁcient to report the error .

To indicate that , we can declare such function noexcept .
For example : double noexcept ; may not throw an exception Exception Handling Chapter Now no exception will come out of .

Declaring function noexcept can be most valuable for programmer reasoning about program and for compiler optimizing program .
The programmer need not worry about providing dealing with failures in noexcept and an optimizer need not worry about control paths from exception handling .

However , noexcept is not completely checked by the compiler and linker .
What happens if the programmer " so that noexcept function deliberately or accidentally threw an exception that caught before leaving the noexcept function .

The constructor may fail to acquire memory for its ten doubles and throw .
In that case , the program terminates .

It does not invoke destructors from calling functions .
It is whether destructors from scopes between the throw and the noexcept , for in are invoked .
The program is just about to terminate , so we should not depend on any object anyway .

By adding noexcept speciﬁer , we indicate that our code was not written to cope with throw .

For example : void ; The means that may not throw if the predicate is true but may throw if it is false .
may want to write this if copies its argument .
know that copying POD does not throw , whereas other types , string or may .

The predicate in speciﬁcation must be constant expression .
Plain noexcept means .

The standard library provides many type predicates that can be useful for expressing the conditions under which function may throw an exception .

What if the predicate we want to use easily expressed using type predicates only .
For example , if the critical operation that may or may not throw is function call .
The operator takes an expression as its argument and returns true if the compiler " that it cannot throw and false otherwise .
For example :

The operand of is not evaluated , so in the example we do not get error if we pass with an empty .

operator does not go to heroic lengths to determine whether expr can throw ; it simply looks at every operation in expr and if they all have noexcept speciﬁcations that evaluate to true , it returns true .
does not look inside deﬁnitions of operations used in expr .

Conditional noexcept speciﬁcations and the operator are common and important in operations that apply to containers .
For example : siz void , Exception Speciﬁcations In older code , you may ﬁnd exception speciﬁcations .
For example : void ; may only throw Bad or Worse exceptions void ; may not throw An empty exception speciﬁcation is deﬁned to be equivalent to noexcept .
That is , if an exception is thrown , the program terminates .

The meaning of nonempty exception speciﬁcation , such as , is that if the function throws any exception that is not mentioned in the list or publicly derived from an exception mentioned there , an unexpected handler is called .
The default effect of an unexpected exception is to terminate the program .
nonempty throw speciﬁcation is hard to use well and implies potentially expensive checks to determine if the right exception is thrown .
This feature has not been success and is deprecated .

If you want to dynamically check which exceptions are thrown , use .

The handler is invoked : If is the same type as If is an unambiguous public base of If and are pointer types and or holds for the types to which they refer If is reference and or holds for the type which refers In addition , we can add const the type used catch an exception in the same way that we can Exception Handling Chapter add it function parameter .
This change the set of exceptions we can catch ; it only restricts us from modifying the exception caught .

In principle , an exception is copied when it is thrown .
The implementation may apply wide variety of strategies for storing and transmitting exceptions .
It is guaranteed , however , that there is sufﬁcient memory allow new throw the standard exception ,

Note the possibility of catching an exception by reference .
Exception types are often deﬁned as part of class hierarchies reﬂect relationships among the kinds of errors they represent .
For examples , see and .
The technique of organizing exception classes into hierarchies is common enough for some programmers prefer catch every exception by reference .

The in both the and of are real scopes .
Consequently , if name is be used in both parts of or outside it , that name must be declared outside the .

The everything " clause , is explained in .

In that case , the handler typically does what can be done locally and then throws the exception again .
Thus , an error can be handled where it is most appropriate .
This is the case even when the information needed best handle the error is not available in single place , so that the recovery action is best distributed over sev eral handlers .
For example : Section Rethrow .

rethrow is indicated by throw without an operand .
rethrow may occur in or in function called from .
If rethrow is attempted when there is no exception rethrow , will be called .
compiler can detect and warn about some , but not all , such cases .

The exception rethrown is the original exception caught and not just the part of it that was accessible as an exception .
For example , had an out_of_range been thrown , would catch it as plain exception , but throw ; would still rethrow it as an out_of_range
Had written throw err ; instead of the simpler , the exception would have been sliced and caller could not have caught it as an out_of_range

This catches every exception .
However , the exceptions are just one set of exception types .
Consequently , you cannot catch every exception by catching .
If someone threw an int or an exception from some hierarchy , it would not be caught by the handler for .

However , we often need deal with every kind of exception .
For example , if is supposed leave some pointers in the state in which it found them , then we can write code in the handler Exception Handling Chapter give them acceptable values .
As for functions , the ellipsis , indicates argument "

Because derived exception can be caught by handlers for more than one exception type , the order in which the handlers are written in trystatement is signiﬁcant .
The handlers are tried in order .

Here , the exception is never considered .
Even if we removed the " handler , be considered because it is derived from exception .
Matching exception types catchclauses is operation and is not as general as overload resolution .

For most functions , all we gain from using function is bit of notational convenience .

However , allows us deal with exceptions thrown by initializers in constructors .
By default , if an exception is thrown in initializer , the exception is passed on whatever inv oked the constructor for the class .
However , the constructor itself can catch such exceptions by enclosing the complete function body including the member initializer list in .

Similarly , we can catch exceptions thrown by member destructors in destructor destructor should never .
However , we cannot " the object and return normally as if the exception had not happened : an exception from member constructor means that the member may not be in valid state .
Also , other member objects will either not be constructed or already have had their destructors invoked as part of the stack unwinding .

The best we can do in of function for constructor or destructor is throw an exception .
The default action is rethrow the original exception when we off the end " of the .

There are no such restrictions for the of an ordinary function .

The guiding principles .

If the implementation catches you doing either , it will terminate your program .

If you managed to have two exceptions active at time the same thread , which you , the system would have no idea which of the exceptions to try to handle : your new or the it was already trying to handle .
Note that an is considered handled immediately upon entry into .
Rethrowing an or throwing new from within is considered new done after the original has been handled .
You can an from within destructor during stack as long as you catch it before it leaves the destructor .

When no suitable handler was found for thrown .

When noexcept function tries to exit with .

When destructor invoked during stack unwinding tries to exit with .

When code invoked to propagate an , copy tries to exit with .

When someone tries to rethrow when there is no current being handled .

When destructor for statically allocated or object tries to exit with .

When an initializer for statically allocated or object tries to exit with .

When function invoked as an function tries to exit with In such cases , the function is called .
In addition , user can call if less drastic approaches are infeasible .

By to exit with " mean that an is thrown somewhere and not caught so that the system tries to propagate it function to its caller .

By default , will call .
This default is the correct choice for most users especially during debugging .
If that is not acceptable , the user can provide terminate handler function by call : Section Termination using .

For example , terminate handler could be used to abort process or maybe to system .
The intent is for to be drastic measure to be applied when the error recovery strategy implemented by the mechanism has failed and it is time to go to another level of fault tolerance strategy .
If terminate handler is entered , essentially nothing can be assumed about data structures ; they must be assumed to be corrupted .
Even writing an error message using cerr must be assumed to be hazardous .
Also , note that as is written , it is not .
or even return before will leave in place when it meant to be .
If you must mess with , at least use RAII .

terminate handler cannot return to its caller .
If it tries to , will call .

Note that indicates abnormal exit the program .
The function can be used to exit program with return value that indicates to the surrounding system whether the exit is normal or abnormal .

It is whether destructors are invoked when program is terminated because of an uncaught .
On some systems , it is essential that the destructors are not called so that the program can be resumed the debugger .
On other systems , it is architecturally close to impossible not to invoke the destructors while searching for handler .

If you want to ensure cleanup when an otherwise uncaught happens , you can add handler to in addition to handlers for exceptions you really care about .

This will catch every  except those thrown by construction and destruction of namespace and variables .
There is no way of catching exceptions thrown during initialization or destruction of namespace and variables .
This is another reason to avoid global variables whenever possible .

When an is caught , the exact point where it was thrown is generally not known .
This represents loss of information compared to what debugger might know about the state of program .
In some development environments , for some programs , and for some people , it might therefore be preferable not to catch exceptions which the program designed to recover .

See Assert for an example of how might encode the location of into the thrown .

So , if we want an error in thread to stop the whole program , we must catch all errors which we would like to recover and somehow report them to part of the program that is interested in the results of the thread .
The " construct comes in handy for that .

This is the basic technique used by to handle exceptions user code .

Obviously , vector implementation relies on many language facilities provided to support the implementation and use of classes .
If you are not comfortable with classes and templates , you may prefer to delay studying this example until you have read Chapter , Chapter , and Chapter .
However , good understanding of the use of exceptions in requires more extensive example than the code fragments so far in this chapter .

The tr .

The support for the Acquisition Is Initialization " technique .

The general principles to follow are to .

Nev er let go of piece of information before its replacement is ready for use .

Always leave objects in valid states when throwing or rethrowing an exception .

That way , we can always back out of an error situation .
The practical difﬁculty in following these principles is that operations , and sor might throw exceptions .

Knowing what to look for in an application takes experience .

When you are writing library , the ideal is to aim at the strong guarantee and always to provide the basic guarantee .
When writing speciﬁc program , there may be less concern for exception safety .
For example , if write simple data analysis program for my own use , usually quite willing to have the program terminate in the unlikely event of memory exhaustion .

Correctness and basic exception safety are closely related .
In particular , the techniques for providing basic exception safety , such deﬁning and checking invariants , are similar to the techniques that are useful to get program small and correct .
It follows that the overhead of providing the basic guarantee or even the strong guarantee can be minimal or even insigniﬁcant .

The default allocator uses new delete to acquire release memory .

Here is declaration of vector simpliﬁed to present only what is needed to discuss exception safety avoidance of resource leaks : class class vector private : elem ; star of allocation space ; end of element sequence , star of space allocated for possible expansion last ; end of allocated space alloc ; allocator Exception Handling Chapter public : using unsigned .

What about the copy of the allocator .
We can imagine that it throws , but the standard speciﬁcally requires that it does not do that .
Anyway , hav written the code so that it matter if it did .

In both cases of throw , no object is created , so destructor is not called .

When fails , the throw will exit before any resources are acquired , so all is well .

When copy constructor fails , we have acquired some memory that must be freed to avoid memory leaks .
Worse still , the copy constructor for might throw an exception after correctly constructing few elements but before constructing them all .
These objects may own resources that then would be leaked .

Note that the declaration of is outside the ; otherwise , we would not be able to access it in both the the .

The overhead here is the overhead of the .
In good implementation , this overhead is negligible compared to the cost of allocating memory initializing elements .
For implementations where entering incurs cost , it may be worthwhile to add test if before the try to explicitly handle the empty case .

The main part of this constructor is repeat of the implementation of :  class .

The curious construct takes care of iterators that are not pointers .
In that case , we need to take address of element obtained by dereference to get pointer .
Together with explicitly Exception Handling Chapter is used to invoke constructor , not some .
The calls to in constructors are simply syntactic sugar this placement .
Similarly , call simply hides explicit destruction .
This code is operating at rather low lev el where writing truly general code can be difﬁcult .

Fortunately , we hav to invent or implement , because standard library provides it .
It is often essential to have initialization operations that either complete successfully , having initialized every element , or fail , leaving no constructed elements behind .
Conse , which offer strong guarantee .

The algorithm does not protect against exceptions thrown by element destructors or iterator operations .
Doing so would be prohibitively expensive probably impossible .

The algorithm can be applied to many kinds of sequences .
Consequently , it takes forward iterator cannot guarantee to destroy elements in reverse order of their construction .

Using , we can simplify our .

This is signiﬁcant improvement on ﬁrst version of this constructor , but next section demonstrates how to further simplify it .

The constructor rethrows caught exception .
The intent is to make transparent to exceptions so that user can determine exact cause of problem .
All containers layers of software .
This is in contrast to major parts of system that generally need to take responsibility all exceptions thrown .
That is , implementer of such module must be able to list every exception that module can throw .
Achieving this may involve grouping exceptions into hierarchies using .

In fact , it is unnecessarily difﬁcult because there is an alternative : The Section Representing Memory Explicitly Acquisition Is Initialization " technique can be used to reduce amount of code that must be written and to make code more stylized .
In this case , key resource required by is memory to hold its elements .
By providing an auxiliary class to represent notion of memory used by  we can simplify code and decrease chances of accidentally forgetting to release it :  class struct memor str ucture alloc ; allocator  star of allocation  of element sequence , star of allocated possible expansion .

As long as and are correct , can be destroyed .
Class deals with memory type  not objects of type .
Consequently , user of must construct all objects explicitly in allocated and later destroy all constructed objects in before itself is destroyed .

The is designed exclusively to be part of implementation of .
It is always hard to predict where and how class will be used , so made sure that be copied and also that move of properly transfers ownership of memory allocated elements :  class .

There are no objects of type to destroy : deals with memory and leaves concerns about objects of type to .

Given  can be deﬁned like this :  class .

The destructor explicitly invokes destructor every element .
This implies that if an element destructor throws an exception , destruction fails .
This can be disaster if it happens during stack unwinding caused by an exception and is called .
In case of normal destruction , throwing an exception from destructor typically leads to resource leaks and unpredictable behavior of code relying on reasonable behavior of objects .
There is no really good way to protect against exceptions thrown from destructors , so library makes no guarantees if an element destructor throws .

The algorithm and its cousins provide equivalent guarantee partially constructed sequences .

The move operations are even .

Just those headers causes slurry of error messages : Line , Te xt , and are deﬁned twice in ways that compiler cannot disambiguate .
Trying to use the libraries would give further error messages .

There are many techniques for dealing with such name clashes .
For example , some such problems can be addressed by placing all the facilities of library inside few classes , by using supposedly uncommon names , Te rather than Te , or by systematically using preﬁx for names from library , and .
Each of these techniques known as " and works in some cases , but they are general and can be inconvenient to use .
For example , names tend to become long , and the use of many different names inhibits generic programming .

The members of namespace are in the same scope and can refer to each other without special notation , whereas access from outside the namespace requires explicit notation .
In particular , we can avoid name clashes by separating sets of declarations , library into namespaces .
For example , we might call the graph library .

As long as we manage to pick distinct namespace names , such as and Te , we can now compile the two sets of declarations together without name clashes .

namespace should express some logical structure : the declarations within namespace should together provide facilities that unite them in the eyes of their users and reﬂect common set of design decisions .
They should be seen as logical unit , for example , graphics library " or text manipulation " similar to the way we consider the members of class .
In fact , the entities declared in namespace are referred to as the members of the namespace .

namespace is scope .
You can access members deﬁned earlier in namespace from later declarations , but you cannot special refer to members from outside the namespace .

Here , the Word and Line in the declaration of Te refer to Te and Te .
That local name lookup is not affected by the global Line .
Conversely , the Glyph and lookup is not affected by Te Glyph and Line .

To refer to members of namespace , we can use its fully qualiﬁed name .
For example , if we want that uses deﬁnitions from Te , we can write : Te ln , int ; Other ways of referring to members from outside their namespace are , and lookup .

Members of namespace must be introduced using this notation : namespace .

We cannot declare new of namespace outside namespace deﬁnition using the qualiﬁer syntax .
The idea is to catch errors such as misspellings and type mismatches , and also to make it reasonably easy to ﬁnd all names in namespace declaration .
For example : Section Explicit Qualiﬁcation .

namespace is scope .
The usual scope rules hold for namespaces .
Thus , is very fundamental and relatively simple concept .
The larger program is , the more useful namespaces are to express logical separations of its parts .
The global scope is namespace and can be explicitly referred to using .

Classes are namespaces .

Ideally , every entity in program belongs to some recognizable logical unit .

Therefore , every declaration in nontrivial program should ideally be in some namespace named to indicate its logical role in the program .
The exception is , which must be global in order for the compiler to recognize it as special ,

That depends on how we decide to access code in other namespaces .
We can always access names from own " namespace exactly as we did before we introduced namespaces .
However , for names in other namespaces , we have to choose among explicit qualiﬁcation , and .

provides good test case for the use of namespaces in an implementation because it uses each of the other namespaces .
If we use explicit qualiﬁcation , we .

use : because that would be redundant within namespace Parser .

If we use , we get : using namespace .

do not recommend such intricate use of header ﬁles unless it is really necessary .
The example above repeatedly violates the rules against including into nonlocal scope against having syntactic construct span ﬁle boundaries use of ; see .
Sadly , hav seen worse .

In most cases , we can achieve versioning by less intrusive means .
The only example can think of that is completely impossible to do by other means is the specialization of template explicitly using the name ,
However , in many important cases most cases " good enough .
Also , solution based on combination of other techniques is less obviously completely right .

For examples of nested namespaces in the standard library , see chrono .

That is , the aim is to preserve locality of code rather than to present an interface to users .

In particular , unnamed namespaces in different translation units are different .
As desired , there is no way of naming member of an unnamed namespace from another translation unit .

Breaking this program be good idea .
Making standard libraries special cases good idea either .
Consequently , the language rules for namespaces are designed to make it relatively easy to take program written without namespaces turn it into more explicitly structured one using namespaces .
In fact , the calculator program is an example of this .

One way to provide the standard facilities in namespace would be to place the declarations from the header in namespace .

consider nonlocal primarily transition tool .
also use them for essential foundation libraries , such as the ISO standard library .
Most code referring to names from other namespaces can be expressed more clearly with explicit qualiﬁcation .

The relationship between namespaces linkage is described in .

Linkage Names ; Header Files ; The Rule ; Headers ; Linkage to Code ; Linkage and Pointers to Functions .

Using Header Files Organization ; Organization ; Include Guards .

Programs Initialization of Nonlocal Variables ; Initialization and Concurrency ; Program Termination .

Advice Separate Compilation Any realistic program consists of many logically separate components , namespaces ; Chapter ﬁles where each ﬁle contains one or more logical components .
Our task is to devise physical structure of for the program that represents the logical components in consistent , comprehensible , and ﬂexible manner .
In particular , we aim for clean separation of interfaces , function and implementations , function .
ﬁle is the traditional unit of storage ﬁle and the traditional unit of compilation .
There are systems that do not store , compile , and present programs to the programmer as sets of ﬁles .
However , the discussion here will concentrate on systems that employ the traditional use of ﬁles .

Having complete program in one ﬁle is usually impossible .
In particular , the code for the standard libraries and the operating system is typically not supplied in source form as part of Source Files and Programs Chapter program .
For realistically sized applications , even having all of the own code in single ﬁle is both impractical and inconvenient .
The way program is organized into ﬁles can help emphasize its logical structure , help human reader understand the program , and help the compiler enforce that logical structure .
Where the unit of compilation is ﬁle , all of the ﬁle must be recompiled whenever change has been made to it or to something on which it depends .

For even moderately sized program , the amount of time spent recompiling can be signiﬁcantly reduced by partitioning the program into ﬁles of suitable size .

user presents source ﬁle to the compiler .
The ﬁle is then preprocessed ; that is , macro processing is done and directives bring in headers ,
The result of preprocessing is called translation unit .
This unit is what the compiler proper works on and what the language rules describe .
In this book , differentiate between source ﬁle and translation unit only where necessary to distinguish what the programmer sees from what the compiler considers .

To enable separate compilation , the programmer must supply declarations providing the type information needed to analyze translation unit in isolation from the rest of the program .
The declarations in program consisting of many separately compiled parts must be consistent in exactly the same way the declarations in program consisting of single source ﬁle must be .
Your system has tools to help ensure this .
In particular , the linker can detect many kinds of inconsistencies .
The linker is the program that binds together the separately compiled parts .
linker is sometimes called loader .
Linking can be done completely before program starts to run .
Alternatively , new can be added to the running program later .

The organization of program into source ﬁles is commonly called the physical structure of program .
The physical separation of program into separate ﬁles should be guided by the logical structure of the program .
The same dependency concerns that guide the composition of programs out of namespaces guide its composition into source ﬁles .
However , the logical and physical structures of program need not be identical .
For example , it can be helpful to use several source ﬁles to store the functions from single namespace , to store collection of namespace deﬁnitions in single ﬁle , or to scatter the deﬁnition of namespace over sev eral ﬁles .

Here , we will ﬁrst consider some technicalities relating to linking and then discuss two ways of breaking the desk calculator , into ﬁles .

It is the task to ensure that every namespace , class , function , is properly declared in every translation unit in which it appears and that all declarations referring to the same entity are consistent .
For example , consider two ﬁles : int ; int do something Section Linkage .

The keyword extern indicates that the declaration of in is declaration and not deﬁnition .
Had been initialized , extern would simply be ignored because declaration with an initializer is always deﬁnition .
An object must be deﬁned exactly once in program .
It may be declared many times , but the types must agree exactly .

The replaces the line in which the appears with the contents of the ﬁle .
The content of should be source text because the compiler will proceed to read it .

To headers , use the angle brackets , and , around the name instead of quotes .

Furthermore , most modern implementations provide some form of or precompiling of header ﬁles to minimize the work needed to handle repeated compilation of the same header .

As rule of thumb , header may contain : Named namespaces namespace .

It is simply reasonable way of using the mechanism to express the physical structure of program .

Conversely , header should never contain : Ordinary function deﬁnitions char ; Data deﬁnitions int .

Header ﬁles are conventionally sufﬁxed by , and ﬁles containing function or data deﬁnitions are sufﬁxed by .
They are therefore often referred to as ﬁles " and " respectively .
Other conventions , such as , and hpp are also found .
The manual for your compiler will be quite speciﬁc about this issue .

The reason for recommending that the deﬁnition of simple constants , but not the deﬁnition of aggregates , be placed in header ﬁles is that it is hard for implementations to avoid replication of aggregates presented in several translation units .
Furthermore , the simple cases are far more common and therefore more important for generating good code .

It is wise not to be too clever about the use of .

Place all before other code to minimize unintended dependencies .

Avoid macro magic .

Minimize the use of names not local to header in header .

One of my least favorite activities is tracking down an error caused by name being into something completely different by macro deﬁned in an indirectly header that hav never even heard of .

From practical point of view , this means that there must be exactly one deﬁnition of , say , class residing in single ﬁle somewhere .
Unfortunately , the language rule cannot be that simple .

For example , the deﬁnition of class may be composed through macro expansion , and definition of class may be textually included in two source ﬁles by directives .

Consequently , the rule in the standard that says that there must be unique deﬁnition of class ,  is phrased in somewhat more complicated and subtle manner .
This rule is commonly referred to as the rule .
That is , two deﬁnitions of class ,  or inline function are accepted as examples of the same unique deﬁnition if and only if they appear in different translation units , and they are identical , and the meanings of those tokens are the same in both translation units .

The ODR says that this example is valid and that refers to the same class in both source ﬁles .

However , it is unwise to write out deﬁnition twice like that .
Someone maintaining will naturally assume that the deﬁnition of in is the only deﬁnition of and so feel free to change it .
This could introduce error .

The intent of the ODR is to allow inclusion of class deﬁnition in different translation units from common source ﬁle .

Here the two deﬁnitions of are identical , but the example is an error because the meaning of the name has sneakily been made to differ in the two ﬁles .

Checking against inconsistent class deﬁnitions in separate translation units is beyond the ability of most implementations .
Consequently , declarations that violate the ODR can be source of subtle errors .
Unfortunately , the technique of placing shared deﬁnitions in headers and them protect against this last form of ODR violation .
Local type aliases and macros can change the meaning of declarations :

The best defense against this kind of hackery is to make headers as as possible .
For example , if class Point had been declared in the header , the error would have been detected .

template deﬁnition can be in sev eral translation units as long as the ODR is adhered to .
This applies even to function template deﬁnitions and to class templates containing member function deﬁnitions .

No sufﬁx is needed for headers ; they are known to be headers because they are included using the syntax rather than .
The absence of sufﬁx does not imply anything about how the header is stored .
header such as is usually stored as text ﬁle called in some standard directory .
On the other hand , standard headers are not required to be stored in conventional manner .
An implementation is allowed to take advantage of knowledge of the deﬁnition to optimize the implementation and the way standard headers are handled .
For example , an implementation might have knowledge of the standard math library built in and treat as switch that makes the standard math functions available without actually reading any ﬁle .

For each header , there is corresponding standard header .

For example , provides what does .
typical will look something like this : namespace std extern "

The macro is deﬁned by the compiler and can be used to distinguish code from code intended for compiler .

Similarly , it is common for code fragments to be used as parts of programs written mainly in some other language , Python or .
Cooperation can be difﬁcult between program fragments written in different languages and even between fragments written in the same language but compiled with different compilers .
For example , different languages and different implementations of the same language may differ in their use of machine registers to hold arguments , the layout of arguments put on stack , the layout of types such as strings and integers , the form of names passed by the compiler to the linker , and the amount of type checking required from the linker .
To help , one can specify linkage convention to be used in an extern declaration .
For example , this declares the and function and speciﬁes that it should be linked according to the linkage conventions : Section Linkage to Code extern " const ; The effect of this declaration differs from the effect of the " declaration extern , const ; only in the linkage convention used for calling .

The extern " directive is particularly useful because of the close relationship between and .
Note that the in extern " names linkage convention and not language .
Often , extern " is used to link to Fortran and assembler routines that happen to conform to the conventions of implementation .

An extern " directive speciﬁes the linkage convention and does not affect the semantics of calls to the function .
In particular , function declared extern " still obeys the and argument conversion rules and not the weaker rules .

This technique is commonly used to produce header from header .
Alternatively , conditional compilation can be used to create common and header : extern "

Any declaration can appear within linkage .

This looks odd at ﬁrst glance .
However , it is simple consequence of keeping the meaning unchanged when adding " to an and the meaning of ﬁle unchanged when enclosing it in linkage block .

name with linkage can be declared in namespace .
The namespace will affect the way the name is accessed in the program , but not the way linker sees it .
The from std is typical .

Even when called , it is still the same old .

Note that this allows us to libraries with linkage into namespace of our choice rather than polluting the global namespace .
Unfortunately , the same ﬂexibility is not available to us for headers deﬁning functions with linkage in the global namespace .
The reason is that linkage of entities must take namespaces into account so that the object ﬁles generated will reﬂect the use or lack of use of namespaces .

If the two implementations of the two languages share linkage conventions and function call mechanisms , such passing of pointers to functions is trivial .
However , such commonality cannot in general be assumed , so care must be taken to ensure that function is called the way it expects to be called .

When linkage is speciﬁed for declaration , the speciﬁed linkage applies to all function types , function names , and variable names introduced by the .
This makes all kinds of strange and occasionally essential combinations of linkage possible .
For example : Section Linkage and Pointers to Functions .

An implementation in which and use the same calling conventions might accept the declarations marked error as language extension .
However , even for compatible and implementations , or lambdas with any form of capture cannot cross the language barrier .

the initial organization would use for simple program for my own use ; if something more elaborate turned out to be needed , would reorganize later .

For the calculator program , we might use ﬁve ﬁles , table , and to hold function and data deﬁnitions .
The header holds the declarations of every name used in more than one ﬁle : Source Files and Programs Chapter .

The keyword extern is used for every variable declaration to ensure that multiple deﬁnitions do not occur as we in the various ﬁles .
The corresponding deﬁnitions are found in the appropriate ﬁles .

added headers as needed for the declarations in , but did not add declarations as needed only for the convenience of an individual ﬁle .

Leaving out the actual code , will look something like .

The distinction between the user interface and the interface for implementers would be even clearer had we used namespace .

The interface in header is to giv the compiler chance to check consistency .

The functions implementing the parser are stored in together with directives for the headers that the Parser functions .

For larger system , it is usually worthwhile to separate out the driver and minimize what is done in .
That way calls driver function placed in separate source ﬁle .
This is particularly important for code intended to be used as library .
Then , we cannot rely on code in and must be prepared for the driver to be called from variety of functions .

Many of these factors have more to do with the way ﬁles are handled on your system than with .
For example , if your does not make it convenient to look at several ﬁles simultaneously , then using many headers becomes less attractive .

However , if you partition the declarations of large program into the logically headers each structure declaration in its own ﬁle , you can easily get an unmanageable mess of hundreds of ﬁles even for minor projects .
ﬁnd that excessive .

For large projects , multiple headers are unavoidable .
In such projects , hundreds of ﬁles counting standard are the norm .
The real confusion starts when they begin to be counted in the thousands .
At that scale , the basic techniques discussed here still apply , but their management becomes Herculean task .
Tools , such as dependency analysers , can be of great help , but there is little they can do for compiler and linker performance if the program is an unstructured mess .
Remember that for realistically sized programs , the style is not an option .

Such programs will have multiple headers .
The choice between the two styles of organization occurs for the parts that make up the program .

The style and the style are not really alternatives .
They are complementary techniques that must be considered whenever signiﬁcant module is designed and must be reconsidered as system evolves .
crucial to remember that one interface serve all equally well .
It is usually worthwhile to distinguish between the implementers ' interface and the users ' interface .
In addition , many larger systems are structured so that providing simple interface for the majority of users and more extensive interface for expert users is good idea .
The expert users ' interfaces tend to many more features than the average user would ever want to know about .
In fact , the average users ' interface can often be identiﬁed by eliminating features that require the inclusion of headers that deﬁne facilities that would be unknown to the average user .
The term user " is not derogatory .
In the ﬁelds in which have to be an expert , strongly prefer to be an average user .
In that way , minimize hassles .

Viewed from the program as whole , many of the declarations needed to make each logical module complete are redundant .
For larger programs , such redundancy can lead to errors , as header containing class deﬁnitions or inline functions gets twice in the same compilation unit .

We hav two choices .
We can reorganize our program to remove the redundancy , or ﬁnd way to allow repeated inclusion of headers .

The ﬁrst approach which led to the ﬁnal version of the calculator is tedious and impractical for realistically sized programs .
We also need that redundancy to make the individual parts of the program comprehensible in isolation .

The beneﬁts of an analysis of redundant and the resulting simpliﬁcations of the program can be signiﬁcant both from logical point of view and by reducing compile times .
However , it can rarely be complete , so some method of allowing redundant must be applied .
Preferably , it must be applied systematically , since there is no way of knowing how thorough an analysis user will ﬁnd worthwhile .

For example :

Thus , the ﬁrst time is seen during compilation , its contents are read and is given value .
Should the compiler be presented with again during the compilation , the contents are ignored .
This is piece of macro hackery , but it works and it is pervasive in the and worlds .
The standard headers all have guards .

Header ﬁles are included in essentially arbitrary contexts , and there is no namespace protection against macro name clashes .
Consequently , choose rather long and ugly names for my guards .

Once people get used to headers and guards , they tend to lots of headers directly and indirectly .
Even with implementations that optimize the processing of headers , this can be undesirable .
It can cause unnecessarily long compile time , and it can bring lots of declarations and macros into scope .
The latter might affect the meaning of the program in unpredictable and adverse ways .
Headers should be included only when necessary .

Every function , object , type , used in this collection must have unique deﬁnition ,
program must contain exactly one function called .
The main computation performed by the program starts with the invocation of the global function and ends with return from .

The return type of is int , and the following two versions of are supported by all implementations : int .
In addition , an implementation can allow other versions of .
The argc , argv version is used to transmit arguments from the environment ; see .

The int returned by is passed to whatever system invoked as the result of the program .
nonzero return value from indicates an error .

This simple story must be elaborated on for programs that contain global variables or that throw an uncaught exception .

Such nonlocal variables in translation unit are initialized in their deﬁnition order .
If such variable has no explicit initializer , it is by default initialized to the default for its type .
The default initializer value for types and enumerations is .

Here , and are initialized before  so is called .

There is no guaranteed order of initialization of global variables in different translation units .

Consequently , it is unwise to create order dependencies between initializers of global variables in different compilation units .
In addition , it is not possible to catch an exception thrown by the initializer of global variable .
It is generally best to minimize the use of global variables and in particular to limit the use of global variables requiring complicated initialization .

Several techniques exist for enforcing an order of initialization of global variables in different translation units .
However , none are both portable and efﬁcient .
In particular , dynamically linked libraries do not coexist happily with global variables that have complicated dependencies .

Often , function returning reference is good alternative to global variable .

Like other uses of static , this technique is not .
The initialization of local static is .
In this case , the initialization is even with constant expression , so that it is done at link time and not subject to data races .
However , the can lead to data race .

The initialization of nonlocal variables is controlled by whatever mechanism an implementation uses to start up program .
This mechanism is guaranteed to work properly only if is executed .
Consequently , one should avoid nonlocal variables that require initialization in code intended for execution as fragment of program .

Note that variables initialized by constant expressions cannot depend on the value of objects from other translation units and do not require initialization .
Such variables are therefore safe to use in all cases .

The obvious answer is and " Why .
The initialization of statically allocated object with constant expression is done at link time , so becomes .
Howev er , initializer is not constant expression is no , so is not initialized until run time .
However , the order of initialization of statically allocated objects in single translation unit is well deﬁned : they are initialized in deﬁnition order .

The ﬂaw in this argument is that if multiple threads are used , each will do the initialization .
No mutual exclusion is implicitly provided to prevent data race .
Then , in one thread may happen before or after the other thread manages to increment .

To avoid such problems , we should .

Minimize the use of statically allocated objects and keep their initialization as simple as possible .

Avoid dependencies on dynamically initialized objects in other translation units .

In addition , to avoid data races in initialization , try these techniques in order : Initialize using constant expressions that types without initializers are initialized to zero and that standard containers and strings are initialized to empty by linktime .

If program is terminated using the function , the destructors for constructed static objects are called ,
However , if the program is terminated using the function , they are not .
Note that this implies that does not terminate program immediately .
Calling in destructor may cause an inﬁnite recursion .
The type of is : void ; Source Files and Programs Chapter Like the return value of , argument is returned to system " as the value of the program .
Zero indicates successful completion .

Calling means that the local variables of the calling function and its callers will not have their destructors invoked .
Throwing an exception and catching it ensures that local objects are properly destroyed .
Also , call of terminates the program without giving the caller of the function that called chance to deal with the problem .
It is therefore often best to leave context by throwing an exception and letting handler decide what to do next .
For example , may catch every exception .

The function offers the possibility to have code executed at .

This strongly resembles the automatic invocation of destructors for global variables at program termination ,
An argument to cannot take arguments or return result , and there is an limit to the number of atexit functions .
nonzero value returned by indicates that the limit is reached .
These limitations make less useful than it appears at ﬁrst glance .
Basically , is workaround for the lack of destructors .

The destructor of constructed statically allocated object created before call of will be invoked after is invoked .
The destructor of such an object created after call of will be invoked before is invoked .

The function is like except that it does not invoke any destructors .
You register functions to be invoked by using .

The , and functions are declared .

Techniques commonly called programming and generic programming are presented .

Chapters Classes Construction , Cleanup , Copy , and Move Operator Overloading Special Operators Derived Classes Class Hierarchies Type Information Templates Generic Programming Specialization Instantiation Templates and Hierarchies Metaprogramming Matrix Design Abstraction Mechanisms Part III .
For the reformer makes enemies of all those who proﬁt by the old  and only lukew arm defenders all Classes Those are not ; they are as real as int and ﬂoat .

Class Basics Member Functions ; Default Copying ; Access Control ; class and struct ; Constructors ; explicit Constructors ;  Deﬁnitions ; Mutability ; Member Access ; static Members ; Member Types .

Concrete Classes Member Functions ; Helper Functions ; Overloaded Operators ; The Signiﬁcance of Concrete Classes .

Advice Introduction classes are tool for creating new that can be used as conveniently as the .

In addition , derived classes , Chapter and templates , Chapter allow the programmer to express and relationships among classes and to take advantage of such relationships .

is concrete representation of concept idea , notion ,
For example , the ﬂoat with its operations + provides concrete approximation of the mathematical concept of real number .
class is .
We design new to provide deﬁnition of concept that has no direct counterpart among the .
For example , we might provide program dealing with telephony , Explosion for video game , or for program .
program that provides that closely match the concepts of the application tends to be easier to understand , easier to reason about , and easier to modify than program that does not .
set of Classes Chapter also makes program more concise .
In addition , it makes many sorts of code analysis feasible .
In particular , it enables the compiler to detect illegal uses of objects that would otherwise be found only through exhaustive testing .

The fundamental idea in deﬁning new is to separate the incidental details of the implementation , the layout of the data used to store an object of the from the properties essential to the correct use of it , the complete list of functions that can access the .
Such separation is best expressed by channeling all uses of the data structure and its internal housekeeping routines through speciﬁc interface .

This chapter focuses on relatively simple " that logically differ much from  Class introduces the basic facilities for deﬁning class and its members .

The following chapters go into greater detail and presents abstract classes and class hierarchies : Chapter Construction , Cleanup , Copy , and Move presents the variety of ways to control initialization of objects of class , how to copy and move objects , and how to provide actions " to be performed when an object is destroyed , goes out of .

Chapter Operator Overloading explains how to deﬁne unary and binary operators as + and for and how to use them .

Chapter Special Operators considers how to deﬁne and use operators as , are " in they are commonly used in ways differ from arithmetic and logical operators .
In particular , this chapter shows how to deﬁne string class .

Chapter Derived Classes introduces the basic language features supporting programming .
Base and derived classes , virtual functions , and access control are covered .

Chapter Class focuses on the use of base and derived classes to effectively organize code around the notion of class hierarchies .
Most of this chapter is devoted to discussion of programming techniques , but technical aspects of multiple inheritance with more than one base are also covered .

Chapter Type Information describes the techniques for explicitly navigating class hierarchies .
In particular , the conversion operations and are presented , as is the operation for determining the of an object given one of its base classes .

class is .

class consists of set of members .
The most common kinds of members are data members and member functions .

Member functions can deﬁne the meaning of initialization , copy , move , and cleanup .

Members are accessed using .

Operators , such as + and , can be deﬁned for class .

class is namespace containing its members .

The public members provide the interface and the private members provide implementation details .

struct is class where members are by default public .

For example : class private : the representation is private .

The style is tutorial : gradual development of ideas , with details postponed until later .

Such connection can be established by declaring the functions as members : Classes Chapter .

For example , when is invoked for today , assigns to .
On the other hand , when is invoked for thday , assigns to .
class member function " for which object it was invoked .
But see for the notion of static member .

In particular , class object can be initialized with copy of an object of its class .
For example : thday ; initialization by copy ; initialization by copy Section Default Copying By default , the copy of class object is copy of each member .
If default is not the behavior wanted for class , more appropriate behavior can be provided ,

Similarly , class objects can by default be copied by assignment .

Again , the default semantics is memberwise copy .
If is not the right choice for class , the user can deﬁne an appropriate assignment operator ,

This restriction can be expressed by using class instead of struct : class .

The public label separates the class body into two parts .
The names in the ﬁrst , private , part can be used only by member functions .
The second , public , part constitutes the public interface to objects of the class .
struct is simply class whose members are public by default ; member functions can be deﬁned and used exactly as before .

For example , any error causing to take on an illegal value example , December , must be caused by code in member function .
This implies that the ﬁrst stage of debugging localization is completed before the program is even run .
This is special case of the general observation that any change to the behavior of the type can and must be effected by changes to its members .
In particular , if we change the of class , we need only change the member functions to take advantage of the new .
User code directly depends only on the public interface and need not be rewritten it may need to be .
Another advantage is that potential user need examine only the deﬁnitions of the member functions in order to learn to use class .
more subtle , but most signiﬁcant , advantage is that focusing on the design of good interface simply leads to better code because thoughts and time otherwise devoted to debugging are expended on concerns related to proper use .

The protection of private data relies on restriction of the use of the class member names .
It can therefore be circumvented by address manipulation and explicit type conversion .

But this , of course , is cheating .
protects against accident rather than deliberate circumvention .
Only hardware can offer perfect protection against malicious use of language , and even that is hard to do in realistic systems .

For historical reasons , class deﬁnition is often referred to as class declaration .
Also , like declarations that are not deﬁnitions , class deﬁnition can be replicated in different source ﬁles using without violating the rule .

By deﬁnition , struct is class in which members are by default public ; that is , struct .

Which style you use depends on circumstances and taste .
tend to use struct for classes that think of as simple data " If think of class as proper type with an " use class .
Constructors and access functions can be quite useful even for structs , but as shorthand rather than guarantors of invariants ,

By default , members of class are private : class .

It is not requirement to declare data ﬁrst in class .
In fact , it often makes sense to place data members last to emphasize the functions providing the public user interface .
For example : class .

Access speciﬁers can be used many times in single class declaration .
For example : class public : dd , int mm , int .

So does having more than one private section .
However , allowing many access speciﬁers in class is useful for code .

Because it is nowhere stated that an object must be initialized , programmer can forget to do so or do so twice with equally disastrous .
better approach is to allow the programmer to declare function with the explicit purpose of initializing objects .
Because such function constructs values of given type , it is called constructor .
constructor is recognized by having the same name as the class itself .
For example : Classes Chapter class .

There are cases where notation must be used , but they are rare .

By providing several constructors , we can provide variety of ways of initializing objects of type .

When designing class , programmer is always tempted to add features just because somebody might want them .
It takes more thought to carefully decide what features are really needed and to include only those .
However , that extra thought typically leads to smaller and more comprehensible programs .
One way of Section Constructors reducing the number of related functions is to use default arguments .

In addition , we can make the association explicit by enclosing the class and its helper functions in namespace .

The Chrono namespace would naturally also contain related classes , such as Time and Stopwatch , and their helper functions .
Using namespace to hold single class is usually an overelaboration that leads to inconvenience .

Naturally , the helper function must be deﬁned .

be outside the jan to dec range , but it is possible might have been sloppy with , so check .

The troublesome ﬁnally .

These operators are deﬁned in Chrono together with to avoid overload problems to beneﬁt from lookup .

For  these operators can be seen as mere conveniences .
However , for many types such as complex numbers , vectors , objects , the use of conventional operators is so ﬁrmly entrenched in minds that their deﬁnition is almost mandatory .
Operator overloading is discussed in Chapter .

Had done so , would have followed common idiom .

Note that assignment copy initialization are provided by default ,

Concrete classes are used just like types .
Concrete types have also been called value types their use programming .
Their model of use the " behind their design are quite different from what is often called programming , Chapter .

The intent of concrete is to do single , relatively simple thing well efﬁciently .
It is not usually the aim to the user with facilities to modify the behavior of concrete .
In particular , concrete types are not intended to display polymorphic behavior ,

If you like some detail of concrete  you build new with the desired behavior .

If you want to " concrete  you use it in the implementation of your new exactly as you would have used an int .
For example : class .

Alternatively , the derived class mechanism discussed in Chapter can be used to deﬁne new types from concrete class by describing the desired differences .
The deﬁnition of Vec from vector is an example of this .
However , derivation from concrete class should be done with care only rarely because of the lack of virtual functions information , Chapter .

With reasonably good compiler , concrete class such as incurs no hidden overhead in time or space .
In particular , no indirection through pointers is necessary for access to objects of concrete classes , no " data is stored in objects of concrete classes .
The size of concrete is known at compile time so that objects can be allocated on the stack is , without .
The layout of an object is known at compile time so that inlining of operations is trivially achieved .
Similarly , layout compatibility with other languages , such as Fortran , comes without special effort .

good set of such types can foundation for applications .
In particular , they can be used to make interfaces more speciﬁc less .
For example : Month ; This is far less likely to be misunderstood or misused than : int ; Lack of concrete types can lead to obscure programs time wasted when each programmer writes code to directly manipulate frequently used " data structures represented as Section The Signiﬁcance of Concrete Classes simple aggregates of types .
Alternatively , lack of suitable efﬁcient types " in an application can lead to gross space inefﬁciencies when overly general expensive classes are used .

Where applicable , prefer concrete over more complicated classes over plain data structures ;

Constructors Destructors Constructors Invariants ; Destructors Resources ; Base Member Destructors ; Calling Constructors Destructors ; virtual Destructors .

Class Initialization Initialization Without Constructors ; Initialization Using Constructors ; Default Constructors ; Constructors .

Member Base Initialization Member Initialization ; Base  Delegating Constructors ;  static Member Initialization .

Copy Move Copy ; Move .

Generating Default Operations Explicit Defaults ; Default Operations ; Using Default Operations ; deleted Functions .

Advice Introduction This chapter focuses on technical aspects of an : How do we create an object , how do we copy it , how do we move it around , and how do we clean up after it when it goes away .

What are proper deﬁnitions of " and .
For example : Construction , Cleanup , Copy , and Move Chapter string .

Next , we construct with the value " and copy it into .
Finally , at the exit from we destroy the variables and .
The difference between move and copy is that after copy two objects must have the same value , whereas after move the source of the move is not required to have its original value .
Moves can be used when the source object will not be used again .
They are particularly useful for implementing the notion of moving resource ,

Several functions are used .

move constructor moving the value of string arg out of into temporary .

move assignment moving the value of string the temporary variable holding the .

destructor releasing the resources owned by , and the temporary variable holding the An optimizer can eliminate some of this work .
For example , in this simple example the temporary variable is typically eliminated .
However , in principle , these operations are executed .

Constructors , copy and move assignment operations , and destructors directly support view of lifetime and resource management .
An object is considered an object of its type after its constructor completes , and it remains an object of its type until its destructor starts executing .
The interaction between object lifetime and errors is explored further in and .
In particular , this chapter discuss the issue of and objects .

Construction of objects plays key role in many designs .
This wide variety of uses is reﬂected in the range and ﬂexibility of the language features supporting initialization .

Constructors , destructors , and copy and move operations for type are not logically separate .

We must deﬁne them as matched set or suffer logical or performance problems .
If class has destructor that performs nontrivial task , such as deallocation or lock release , the class is likely to need the full complement of functions : Section Introduction .

There are ﬁve situations in which an object is copied or .

As the source of an assignment .

As an object initializer .

As function argument .

As an exception In all cases , the copy or move constructor will be applied it can be optimized .

In addition to the initialization of named objects and objects on the free store , constructors are used to initialize temporary objects and to implement explicit type conversion .

Except for the " these special member functions can be generated by the compiler ; see .

This chapter is full of rules and technicalities .
Those are necessary for full understanding , but most people just learn the general rules from examples .

To complement constructors , we can deﬁne destructor to ensure " at the point of destruction of an object , when it goes out of .
Some of the most effective techniques for resource management in rely on pairs .
So do other techniques relying on pair of actions , such as , etc .

Often , that initialization must establish class invariant , that is , something that must hold whenever member function is called outside the .
Consider : class Vector public :

For example : Section Constructors and Invariants .

This constructor tries establish the invariant and if it cannot , it throws an exception .
If the constructor cannot establish the invariant , no object is created and the constructor must ensure that no resources are leaked ,
resource is anything we need acquire and eventually or give back once we are ﬁnished with it .
Examples of resources are memory , locks , ﬁle handles , and thread handles .

Why would you deﬁne an invariant .

To simplify the documentation of the class On average , the effort deﬁne an invariant ends up saving work .

In other words , it creates the environment in which the member functions operate .
Sometimes , creating that environment involves acquiring resource such as ﬁle , lock , or some memory that must be released after use ,
Thus , some classes need function that is guaranteed be invoked when an object is destroyed in manner similar the way constructor is guaranteed be invoked when an object is created .
Inevitably , such function is called destructor .
The name of destructor is followed by the class name , for example .
One meaning of is " and destructor for class complements its constructors .
destructor does not take an argument , and class can have only one destructor .
Destructors are called implicitly when an automatic variable goes out of scope , an object on the free store is deleted , etc .
Only in very rare circumstances does the user need call destructor explicitly .

Destructors typically clean up and release resources .
For example : class Vector .

In both cases ,  destructor invoked free the memory allocated by the constructor .

What if the constructor failed acquire enough memory .
For example , or may be larger than the amount of available memory in .
In that case , an exception thrown by new the mech freed .

This style of resource management called Resource Acquisition Is Initialization or simply RAII ,

matching pair the usual mechanism for implementing the notion of variably sized object in .
containers , such as , use variants of this technique for providing storage for their elements .

type that has no destructor declared , such as type , considered have destructor that does nothing .

programmer who declares destructor for class must also decide if objects of that class can be copied or moved .

constructor builds class object the bottom : ﬁrst , the constructor invokes its base class constructors , then , it invokes the member constructors , ﬁnally , it executes its own body .

destructor down " an object in the reverse order : ﬁrst , the destructor executes its own body , then , it invokes its member destructors , ﬁnally , it inv okes its base class destructors .

In particular , virtual base constructed before any base that might use it destroyed after all such bases .
This ordering ensures that base or member not used before it has been initialized or used after it has been destroyed .
The programmer can defeat this simple Section Base Member Destructors essential rule , but only through deliberate circumvention involving passing pointers to uninitialized variables as arguments .
Doing so violates language rules the results are usually disastrous .

Constructors execute member base constructors in declaration order the order of : if two constructors used different order , the destructor could not serious guarantee to destroy in the reverse order of construction .

If class used so that default constructor needed , if the class does not have other constructors , the compiler will try to generate default constructor .

Default constructors are very common .
For example : Construction , Cleanup , Copy , Move Chapter class Vector .

default argument can make constructor that takes arguments into default constructor .
For example : class String .

However , for type the default constructor is not invoked for uninitialized variables default value of type is for integers , for types , nullptr for pointers .

References consts must be initialized ,
Therefore , class containing such members cannot be default constructed unless the programmer supplies member initializers deﬁnes default constructor that initializes them .

In such cases , default constructor is obviously required for class used as the element type of array .

It is good idea not to be too clever when inventing default values .
For example , the problem with containers of elements without default values is often best solved by not allocating elements until you have proper values for them ,

An constructor is used to construct objects as its initializer Construction , Cleanup , Copy , Move Chapter value .
containers , hav constructors , assignments , etc .

That is , all elements must be of the template argument type ,  implicitly convertible to .

For selecting constructor , default initializer lists take precedence .

If either default constructor an constructor could be invoked , prefer the default constructor .

If both an constructor an constructor " could be invoked , prefer the constructor .

Furthermore , if you deﬁne an constructor to do something with an empty that differs from what the default constructor does , you probably have design error on your hands .

The second rule , the " is necessary to avoid different resolutions based on different numbers of elements .

In every case , the constructor is used .
If we really want to invoke the constructor taking one or two integer arguments , we must use the notation : one element with the value Use of .

Unfortunately , provide subscripting .

An is passed by value .
That is required by the overload resolution rules and does not impose overhead because an object is just small handle two to an array of Ts .

That loop could equivalently have been .

The elements of an are immutable .
even think about trying to modify their values .

That would have done serious damage to some of our most fundamental concepts .

Because elements are immutable , we cannot apply move constructor , to them .

container might implement an constructor like this : class Vector .

For container , this implies that the distinction is applied to both the container and its elements : Section Direct and Copy Initialization .

The constructor can be explicit or not .

The constructor of the element type of the initializer can be explicit or not .

For , we can see the direct initialization .

This example was carefully crafted to give an example of the most confusing cases .
Note that the apparent ambiguities the eyes of the human reader but not the do not emerge for longer lists .
For example : OK : has three elements with values ; OK : has three elements with values Construction , Cleanup , Copy , and Move Chapter .

Generally , they do that by initializing class members and base classes .

The member initializer list starts with colon , and the individual member initializers are separated by commas .

The constructors are called in the order in which the members are declared in the class rather than the order in which the members appear in the initializer list .
To avoid confusion , it is best to specify the initializers in the member declaration order .
Hope for compiler warning if you get the order right .
The member destructors are called in the reverse order of construction after the body of the own destructor has been executed .

If member constructor needs no arguments , the member need not be mentioned in the member initializer list .

This constructor is equivalent to the previous version .
In each case , and are initialized to with no elements .

It is usually good idea to be explicit about initializing members .
Note that an initialized " member of type is left uninitialized .

constructor can initialize members and bases of its class , but not members or bases of its members or bases .

reference member or const member must be initialized ,
However , for most types the programmer has choice between using an initializer and using an assignment .
In that case , usually prefer to use the member initializer syntax to make it explicit that initialization is being done .
Often , there also is an efﬁciency advantage to using the initializer syntax to using an .
For example : Construction , Cleanup , Copy , and Move Chapter .

Here name is initialized with copy of .
On the other hand , is ﬁrst initialized to the empty string and then copy of is assigned .

That is , if base requires an initializer , it must be provided as base initializer in constructor .
If we want to , we can explicitly specify default construction .

As with members , the order of initialization is the declaration order , and it is recommended to specify base initializers in that order .
Bases are initialized before members and destroyed after members .

Both " are common older versions of offer anything .
For example : Section Delegating Constructors class .

That is , initializer using the own name constructor calls another constructor as part of the construction .
Such constructor is called delegating constructor occasionally forwarding .

You cannot both delegate and explicitly initialize member .
For example : class .

The simply creates new object and does nothing with it .

Hope for compiler warning .

An object is not considered constructed until its constructor completes .
When using delegating constructor , the object is not considered constructed until the delegating constructor completes just completing the constructor is not sufﬁcient .
destructor will not be Construction , Cleanup , Copy , and Move Chapter called for an object unless its original constructor completed .

If all you need is set member default value depend on constructor , member initializer may be simpler .

For example : class .

By default , constructor will use such an initializer , so that example is equivalent  class .

Such use of initializers can save bit of typing , but the real beneﬁts come in more complicated classes with multiple constructors .
Often , several constructors use the same initializer for member .
For example : class .

To make the common values explicit , we can factor out the unique initializer for data members : class .

An member initializer can use names that are in scope at the point of their use in the .

The value of the global variable is obtained at the point where the constructor for new object is run , so it can in this example change .
Next , is initialized by call the global .

It is bad idea hide subtle dependencies on global data in member initializers .

Generally , the static member declaration acts as declaration for deﬁnition outside the class .

However , for few simple special cases , it is possible initialize static member in the class declaration .
The static member must be const of an integral or enumeration type , or constexpr of literal type , the initializer must be .
For example : class Curious .

For example : int class Fixed .

Copy is the conventional meaning of ; that is , the effect is that the values of are both equal value before the assignment .

Move leaves with former value with some state .

The obvious alternative of copying the complete state of an object is called deep copy .
Often , the better alternative to deep copy is not shallow copy , but move operation , which minimizes copying without adding complexity ,

shallow copy leaves two objects , and with shared state , and has huge potential for confusion and errors .
We say that the objects and have become entangled when the requirement of independence have been violated .
It is not possible to reason about an entangled object in isolation .
For example , it is not obvious from the source code that the two assignments to .

We can represent two entangled objects graphically :  shared state state : state : Note that entanglement can arise in variety of ways .
Often , it is not obvious that entanglement has happened until probems arise .
For example , type like may incautiously be used as member of an otherwise class .
The original author of may be aware of the entanglement and prepared to cope with it , but someone naively assuming that copying an meant copying its complete value could be surprised , and someone who ﬁnds an deeply nested in other classes could be very surprised .

We can address problems related to the lifetime of shared subobject by introducing form of garbage collection .

In fact , shallow copy and such entangled objects are among the sources of demands for garbage collection .
Entangled objects lead to code that is very hard to manage without some form of garbage collection ,

However , is still pointer , so we cannot consider objects containing in isolation .
Who can update the object .
If we are running in multithreaded system , is synchronization needed for access to the shared data .

Entangled objects , resulting from shallow is source of complexity and errors that is at best partially solved by garbage collection any .

Note that an immutable shared state is not problem .
Unless we compare addresses , we cannot tell whether two equal values happen to be represented as one or two copies .
This is useful observation because many copies are never modiﬁed .
For example , objects passed by value are rarely written to .
This observation leads to the notion of .
The idea is that copy actually need independence until shared state is written to , so we can delay the copying of the shared state until just before the ﬁrst write to it .
Consider : class Image .

Then , depending on the use of Images , it can make sense to implement the copy constructor as shallow .

We protect the argument to that copy constructor by copying the Representation before write : Section The Meaning of Copy .

When applied to copy operation , this simple and necessary rule , leads to trap for the unwary .

The variables and contain copies of the part of , that is , copy of .
The member is not copied .
This phenomenon is called slicing .
It may be exactly what you intended , see the copy constructor for in where we pass selected information to base , but typically it is subtle bug .
If you want slicing , you have two major tools to prevent it : Construction , Cleanup , Copy , and Move Chapter Prohibit copying of the base class : delete the copy operations .

The former would make the initializations of and errors ; the latter would make the call of and the initialization of errors .

For an integer in memory , just about the only thing that makes sense : what the hardware can do with single instruction .
However , from general and logical point of view not so .
Consider the obvious implementation of exchanging the value of two objects :

After the assignment to  we have two copies of value .
After the assignment to  we hav two copies of value is , the original value of .

That sounds like lot of work , and it can be .
For example : void ,

What if has thousand characters .
What if has thousand elements each of thousand characters .
What if is matrix of doubles .
The cost of copying those data structures could be signiﬁcant .
In fact , the has always been carefully designed to avoid such overhead for string and vector .
That is , effort has been made to avoid copying advantage of the fact that string and vector objects really are just handles to their .
Similar work must be done to avoid serious performance problem for of Matrixes .
If the only operation we have is copy , similar work must be done for huge numbers of functions and data structures that are not part of the standard .

The fundamental problem is that we really want to do any copying at all : we just wanted to exchange pairs of values .

We can also look at the issue of copying from completely different point of view : we usually copy physical things unless we absolutely have to .
If you want to borrow my phone , pass my phone to you rather than making you your own copy .
If lend you my car , giv you key and Section Move you drive away in my car , rather than in your freshly made copy of my car .
Once have giv en you an object , you have it and no longer do .
Consequently , we talk about " ownership " and " physical objects .
Many objects in computer resemble physical objects we copy without need and only at considerable more than integer values we typically copy because easier and cheaper than .

Examples are locks , sockets , ﬁle handles , threads , long strings , and large vectors .

To allow the user to avoid the logical and performance problems of copying , directly supports the notion of moving as well as the notion of copying .
In particular , we can deﬁne move constructors and move assignments to move rather than copy their argument .
Consider again the simple Matrix from : class .

The idea behind move assignment is to handle lvalues separately from rvalues : copy assignment and copy constructors take lvalues whereas move assignment and move constructors take rvalues .

We can deﬁne move constructor to simply take the representation from its source and replace it with an empty is cheap to .
For example :

For the move assignment , we can simply do swap .
The idea behind using swap to implement move assignment is that the source is just about to be destroyed , so we can just let the destructor for the source do the necessary cleanup work for us : Construction , Cleanup , Copy , and Move Chapter .

Move constructors and move assignments take reference arguments : they can , and usually do , write to their argument .
However , the argument of move operation must always be left in state that the destructor can cope with preferably deal with very cheaply and .

For resource handles , move operations tend to be signiﬁcantly simpler and more efﬁcient than copy operations .
In particular , move operations typically do not throw exceptions ; they acquire resources or do complicated operations , so they need to .
In this , they differ from many copy operations .

How does the compiler know when it can use move operation rather than copy operation .

In few cases , such as for return value , the language rules say that it can the next action is deﬁned to destroy the .
However , in general we have to tell it by giving an rvalue reference argument .
For example :

It would have been better if had been called , but the name has been used for this operation for years .

containers have move operations , and so have other standardlibrary types , such as pair , and ,
Furthermore , operations that insert new into containers , such as and , have versions that take rvalue references .
The net result is that the standard containers and algorithms deliver better performance than they would have been able to if they had to copy .

What if we try to swap objects of type that does not have move constructor .
We copy and pay the price .
In general , programmer is responsible for avoiding excessive copying .
It is not the job to decide what is excessive and what is necessary .
To get the optimization for your own data structures , you have to provide move operations explicitly or implicitly ; see .

types , such as int and , are considered to have move operations that simply copy .

As usual , you have to be careful about data structures containing pointers .
In particular , assume that pointer is set to nullptr .

How does the object created by new deleted .

Do we need garbage collector .

Should we use pool of Matrixes rather than the general new .

Do we need representations .

Should we redesign the interface of our addition .

Must the caller of remember to delete the result .

What happens to the newly allocated memory if the computation throws an exception .

None of the alternatives are elegant or general .

By default , class .

However , if the programmer takes control by deﬁning one or more of those operations , the generation of related operations is .

If the programmer declares any constructor for class , the default constructor is not generated for that class .

If the programmer declares copy operation , move operation , or destructor for class , no copy operation , move operation , or destructor is generated for that class .

Unfortunately , the second rule is only incompletely enforced : for backward compatibility , copy constructors and copy assignments are generated even if destructor is deﬁned .
However , that generation is deprecated in the ISO standard , and you should expect modern compiler to warn against it .

If necessary , we can be explicit about which functions are generated and which are not .

Also , some people prefer to see complete list of operations in the program text even if that complete list is not needed .
For example , we can .

Someone assuming that it is better to write something , rather than nothing , might write : Section Explicit Defaults .

This is not only verbose , making it harder to read the deﬁnition of  but also opens the opportunity for making mistakes .
For example , might forget to copy one of the members and it default initialized than .
Also , when the user provides function , the compiler no longer knows the semantics of that function and some optimizations become inhibited .
For the default operations , those optimizations can be signiﬁcant .

That is , we memberwise copy , memberwise default construction , etc .

The copy construction of copies and .
The return of moves and , leaving as the empty string and unchanged .

Note that the value of object of type is unchanged .
That ' the simplest and fastest thing for the compiler to do .
If we want something else done for member of class , we have to write our move operations for that class .

The default state is one for which the default destructor and default copy assignment work correctly .
It is not guaranteed that an arbitrary operation on object will work correctly .
If you need stronger guarantees , write your own operations .

If they were not linked , errors that are obvious when you think about them would not be caught by the compiler .

Here , sets to the empty string .
The initialization " of member leaves that member uninitialized .
Hope for compiler warning .

If so , we want copy and move operations to maintain it and the destructor to free any resources involved .
Unfortunately , the compiler cannot in every case know what programmer considers an invariant .
Consider somewhat example : struct invariant : ite is the index of my favor ite element of elem .

The programmer stated an invariant in the comment , but the compiler read comments .
Furthermore , the programmer did not leave hint about how that invariant is to be established and maintained .
In particular , there are no constructors or assignments declared .
That invariant is Section Maintaining Invariants implicit .
The result is that can be copied and moved using the default operations :

The root problem is that is badly designed because critical information is " in comment or completely missing .
The rules for the generation of default operations are heuristic intended to catch common mistakes and to encourage systematic approach to construction , copy , move , and destruction .
Wherever possible Establish an invariant in constructor possibly resource .

Consider simple Handle : class Handle .

Also , declares destructor : this suppresses the generation of copy and move operations .

Again , that saves us from nasty problem .
Consider : Construction , Cleanup , Copy , and Move Chapter .

Had had default copy constructor , both and would have had copy of the pointer and both would have deleted it .

Caveat : the generation of copy operations is only deprecated , not banned , so if you ignore warnings , you might get this example past the compiler .
In general , if class has pointer member , the default copy and move operations should be considered suspicious .
If that pointer member represents ownership , memberwise copy is wrong .
If that pointer member does not represent ownership and memberwise copy is appropriate , and comment are most likely good idea .

If we wanted copy construction , we could deﬁne something like :

Troublesome examples that rely on invariants but only partially express them through constructors or destructors are rarer but not unheard of .

It uses the number " to implement copy assignment that accesses its argument arg without checking that the argument actually has nine elements .
Also , it explicitly implements the copy assignment , but not the copy constructor .

That destructor be because all it needs to do is to ensure that the member pos is destroyed , which is what would have been done anyway had the copy assignment not been deﬁned .
At this point , we notice that the copy assignment is essentially the one we would have gotten by default , so we that also .
Add copy constructor for completeness and we get : class .

When we made the copy , we eliminated the nasty dependence on the magic constant .
Unless other operations on  not mentioned so far , are also with magic " we safely add move operations simplest way to do that is to remove the , and then we see that is really perfectly ordinary type : class .

For every class , we should ask : Is default constructor needed the default one is not adequate or has been suppressed by another .

In particular , we should never just consider one of operations in isolation .

For example , it is common to want to prevent the copying of classes used as bases because such copying easily leads to slicing .

Enabling and disabling copy and move is typically more conveniently done by saying what we want ; rather than saying what we want .
However , we delete any function that we declare .
For example , we eliminate specialization from the set of possible specializations of function 

Note the difference between function and one that simply has not been declared .
In the former case , the compiler notes that the programmer has tried to use the deleted function and gives an error .
In the latter case , the compiler looks for alternatives , such as not invoking destructor or global .

Operator Functions Binary and Unary Operators ; Predeﬁned Meanings for Operators ; Operators and UserDeﬁned Types ; Passing Objects ; Operators in Namespaces .

Complex Number Type Member and Nonmember Operators ; Arithmetic ; Conversions ; Literals ; Accessor Functions ; Helper Functions .

Type Conversion Conversion Operators ; explicit Conversion Operators ; Ambiguities .

Advice Introduction Every technical ﬁeld and most nontechnical ﬁelds has developed conventional shorthand notation to make convenient the presentation and discussion involving frequently used concepts .
For example , because of long acquaintance , is clearer to us than multiply by and add the result to It is hard to overestimate the importance of concise notation for common operations .

Like most languages , supports set of operators for its types .
However , most concepts for which operators are conventionally used are not types in , so they must be Operator Overloading Chapter represented as types .
For example , if you need complex arithmetic , matrix algebra , logic signals , or character strings in , you use classes to represent these notions .
Deﬁning operators for such classes sometimes allows programmer to provide more conventional and convenient notation for manipulating objects than could be achieved using only the basic functional notation .
Consider : class complex .

This deﬁnes simple implementation of the concept of complex numbers .
complex is represented by pair of numbers manipulated by the operators + and .

The programmer deﬁnes and to provide meanings for + and , respectively .
For example , if and are of type complex , + means .

However , the usefulness of operators is not restricted to numeric types .
For example , the design of general and abstract interfaces often leads to the use of operators such as , and .

Allowing them to be overloaded would lead to subtleties .

The named be overloaded because they report fundamental facts about their operands : sizeof alignof typeid Finally , the ternary conditional expression cannot be overloaded no particularly fundamental : In addition , literals are deﬁned by using the " notation .
This is kind of syntactic subterfuge because there is no called .
Similarly , deﬁnes conversion to type .

It is not possible to deﬁne tokens , but you can use the function call notation when this set of operators is not adequate .
For example , use , not .
These restrictions may seem Draconian , but more ﬂexible rules can easily lead to ambiguities .
For example , deﬁning an to mean exponentiation may seem an obvious and easy task , but think again .
Should bind to the left in or to the right in .
Should the expression be interpreted as or as .
There are solutions to all such technical questions .
However , it is most uncertain if applying subtle technical rules will lead to more readable and maintainable code .
If in doubt , use named function .

The name of an function is the keyword followed by the itself , for example ,
An function is declared and can be called like any other function .
use of the is only shorthand for an explicit call of the function .
For example : Operator Overloading Chapter .

Given the previous deﬁnition of complex , the two initializers are synonymous .

For any binary , can be interpreted determines which , if any , interpretation is used .

For any preﬁx unary , can be interpreted as either or .
If both are deﬁned , overload resolution determines which , if any , interpretation is used .
For any postﬁx unary , can be interpreted as either or .

If both are deﬁned , overload resolution determines which , if any , interpretation is used .
An can be declared only for the syntax deﬁned for it in the grammar .

For example , user cannot deﬁne unary or ternary +

The operators , and must be member functions .

This special rule does not hold for versions of , and  instead these are treated exactly like other binary .

For example , if is an int , means , which in turn means .
Such relations do not hold for unless the user deﬁnes them to .
For example , compiler will not generate deﬁnition of from the deﬁnitions of and .

These predeﬁned meanings can be eliminated .

This rule ensures that user cannot change the meaning of an expression unless the expression contains an object of type .
In particular , it is not possible to deﬁne an function that operates exclusively on pointers .
This ensures that is extensible but not mutable the exception of ,  for class .

An function intended to accept type as its ﬁrst operand cannot be member function .
For example , consider adding complex variable aa to the integer : can , with suitably declared member function , be interpreted as , but cannot because there is no class int for which to deﬁne + to mean .
Even if there were , two different member functions would be needed to cope with .
Because the compiler does not know the meaning of + it cannot assume that the is commutative so interpret as .
This example is trivially handled using one or more nonmember functions ,

Enumerations are types so that we can deﬁne for them .

Every expression is checked for ambiguities .
Where provides possible interpretation , the expression is checked according to the overload resolution rules in .

Consequently , we hav limited choices of how to pass arguments to the function how it returns its value .
For example , we cannot require pointer arguments expect programmers to use the or return pointer expect the user to dereference it : is not acceptable .

For arguments , we have two main choices .

For small objects , say , one to four words , is typically viable alternative often the one that gives the best performance .
However , performance of argument passing use depends on machine architecture , compiler interface conventions Binary Interfaces ; the number of times an argument is accessed almost always is faster to access an argument passed by value than one passed by .
For example , assume that is represented as pair of ints : void ; Section Passing Objects Larger objects , we pass by reference .
For example , because Matrix simple matrix of doubles ; is most likely larger than few words , we use : Matrix , const ; In particular , we use const references to pass large objects that are not meant to be modiﬁed by the called function .

Typically , an returns result .
Returning pointer or reference to newly created object is usually very bad idea : using pointer gives notational problems , referring to an object on the free store by pointer or by results in memory management problems .
Instead , return objects by value .
For large objects , such as  deﬁne move operations to make such transfers of values efﬁcient ,

If function simply passes an object to another function , an rvalue reference argument should be used ,

Consider this simpliﬁed version of string from the standard .

In other words , was on my best behavior pollute the global namespace or in other ways introduce unnecessary dependencies .

In particular , is in namespace std , so std is considered when looking for suitable deﬁnition of .
In that way , the compiler ﬁnds uses : Consider binary .
If is of type is of type , is resolved like .

If is class , look for as member of or as member of base of .

Declarations for several may be found overload resolution rules are used to ﬁnd the best match , if any .
This lookup mechanism is applied only if the has at least one Section Operators in Namespaces operand of type .
Therefore , conversions , will be considered .
Note that type alias is just synonym not separate type .

Unary are resolved analogously .

Note that in lookup no preference is given to members over nonmembers .
This differs from lookup of named functions .
The lack of hiding of ensures that operators are never inaccessible and that users can supply new for an without modifying existing class declarations .

In particular , the standard iostream library deﬁnes member functions to output types , and user can deﬁne to output types without modifying class ostream .

For example , we would expect this to .

In addition , we would expect to be provided with few additional operators , such for comparison and for output , and suitable set of mathematical functions , such and .

Class is concrete type , so its design follows the guidelines from .
In addition , users of arithmetic rely so heavily on operators that the deﬁnition of brings into play most of the basic rules for overloading .

The type developed in this section uses double for its scalars and is roughly equivalent to the .

This can be achieved by deﬁning only operators that inherently modify the of their ﬁrst argument , such , in the class itself .
Operators that simply produce new based on the values of their arguments , such + are then deﬁned outside the class and use the essential operators in their implementation : Operator Overloading Chapter class .

Except for possible efﬁciency differences , the computations of are equivalent .

Composite assignment operators such tend to be simpler to deﬁne than their " counterparts +
This surprises most people at ﬁrst , but it follows from the fact that three objects are involved in + operation two operands the , whereas only two objects are involved in operation .
In the latter case , efﬁciency is improved by eliminating the need for temporary variables .

This does not require temporary variable to hold the result of the addition is simple for compiler to inline perfectly .

good optimizer will generate close to optimal code for uses of the plain + also .

However , we always have good optimizer , not all types are simple  so discusses ways of deﬁning operators with direct access to the representation of classes .

In Fortran terminology , we need arithmetic .
We can achieve that simply by adding appropriate versions of the operators : Section Arithmetic class .

added the integer addition for completeness .

For example : class double 

constructor is prescription for creating of given type .
The constructor is used when of type is expected when such can be created by constructor from the supplied an initializer or assigned .
Thus , constructor requiring single argument need not be called explicitly .
For example : means ; conversion is implicitly applied only if it is unique .
If you want constructor to be used implicitly , declare it explicit .

Naturally , we still need the constructor that takes two doubles , default constructor initializing to is also .

Using default arguments , we can abbreviate : Section Conversions class .

This can get tedious , what is tedious easily becomes .
What if we had three alternatives for the type of each argument for each function .
We would need three versions of each function , nine versions of each function , versions of each threeargument function , etc .
Often these variants are very similar .
In fact , almost all variants involve simple conversion of arguments to common type followed by standard algorithm .

The alternative to providing different versions of function for each combination of arguments is to rely on conversions .
For example , our class provides constructor that converts double to .
Consequently , we could simply declare only one version of the equality for  bool .

For example , in some cases the conversion can impose overhead , in other cases , simpler algorithm can be used for speciﬁc argument types .
Where such issues are not signiﬁcant , relying on conversions providing only the most general variant of function plus possibly few critical variants contain the Operator Overloading Chapter combinatorial explosion of variants that can arise from arithmetic .

The name of literal is " followed by the .

The basic idea is that after parsing what could be literal , the compiler always checks for sufﬁx .
The literal mechanism simply allows the user to specify Section Literals sufﬁx deﬁne what is to be done with the literal before it .
It is not possible to redeﬁne the meaning of literal sufﬁx or to augment the syntax of literals .

There are four kinds of literals that can be sufﬁxed to make literal .

An integer literal : accepted by literal taking an unsigned long long or const argument or by literal  for example , or .

literal : accepted by literal taking long double or const argument or by literal  for example , or .

string literal : accepted by literal taking , pair of arguments , for example ,

character literal : accepted by literal operator taking character argument of type char , or , for example , or .

For example , we could deﬁne literal operator to collect digits for integer values that cannot be represented in any of the integer .

Note that did not put those digits in double quotes .
requested string for my operator , and the compiler delivered it from the digits provided .

To get string from the program source text into literal operator , we request both the string and its number of characters .
For example : string "  string .

In the raw string , represents the two characters ' and .

The rationale for requiring the number of characters is that if we want to have different kind of " we almost always want to know the number of characters anyway .

literal operator that takes just const argument no can be applied to integer and literals .
For example : string " warning : this will not wor as expected string ; error  no applicable literal operator string ; OK , but why would anyone do that .

literal operator converting numerical values to strings could be quite confusing .

For example : constexpr int " base , ternar Given that , we .

This String is simpliﬁed version of the string , Chapter .
String provides value semantics , checked and unchecked access to characters , stream , support for loops , equality operations , and concatenation operators .
also added String literal , which does not have .

To allow simple interoperability with strings string literals , represent strings as arrays of characters .
For realism , implement the short string optimization .
That is , String with only few characters stores those characters in the class object itself , rather than on the free store .
This optimizes string usage for small strings .
Experience shows that for huge number of applications most strings are short .
This optimization is particularly important in systems where sharing through pointers is infeasible and allocation and deallocation relatively expensive .

To allow Strings to efﬁciently " by adding characters at the end , implement scheme for keeping extra space for such growth similar to the one used for vector .
This makes suitable target for various forms of input .

Writing better string class one that provides more facilities is good exercise .
That done , we can throw away our exercises and use .

This has value semantics .
That is , after an assignment , the two strings and are fully distinct , and subsequent changes to one have no effect on the other .
The alternative would be to give pointer semantics .
That would be to let changes to after also affect the value of .
Where it makes sense , prefer value semantics ; examples are complex , vector , Matrix , and string .
Howev er , for value semantics to be affordable , we need to pass Strings by reference when we need copies and to implement move semantics , to optimize returns .

The slightly nontrivial representation of is presented in .
Note that it requires versions of the copy and move operations .

Unfortunately , you cannot have all of these properties simultaneously .
Here , follow the standard library by providing operations : class .

The idea is to use for ordinary use .
For example : Section Access to Characters .

personally prefer checked at least during development .
However , for serious string manipulation tasks , range check on each character access could impose quite noticeable overhead .

provide const and versions of the access functions to allow them to be used for const as well as other objects .

To make it easy to convert string , string to and to allow easy access to the characters of as string .

To minimize the use of the free store .

To make adding characters to the end of efﬁcient The result is clearly messier than simple representation , but much more realistic : class simple string that implements the short str ing optimization is the number of elements if  the characters are held in the object itself ; otherwise the free store is used .

This supports what is known as the short string optimization by using two string .

The member named space is the number of such characters .

In both cases , the number of elements is kept in and we look at  to determine which implementation scheme is used for given string .

In both cases , ptr points to the elements .
This is essential for performance : the access functions do not need to test which representation is used ; they simply use ptr .
Only the constructors , assignments , moves , and the destructor must care about the two alternatives .

We use the array ch only if and the integer space only if .
Consequently , it would be waste to allocate space for both ch and space in object .
To avoid such waste , use union .
In particular , used form of union called an anonymous union , which is speciﬁcally designed to allow class to manage alternative representations of objects .
All members of an anonymous union are allocated in the same memory , starting at the same address .
Only one member may be used at any one time , but otherwise they are accessed and used exactly as if they were separate members of the scope surrounding the anonymous union .
It is the programmer ' job to make sure that they are never misused .
For example , all member functions of that use space must make sure that it really was space that was set and not ch .

In other words , Shape is other discriminated union with as the discriminant .

Tw of those need to access the representation of  so made them members .
However , made them private members because they represent operations that are generally useful and safe to use .
For many interesting classes , the implementation is not just the representation plus the public functions .
Ancillary functions can lead to less duplication of code , better design , and improved maintainability .

The ﬁrst such function moves characters into newly allocated .

Any necessary cleanup of the target is the task of callers of ; unconditionally overwrites its target .
use the to copy the bytes of the source into the target .
That ' and sometimes pretty nasty function .
It should be used only where there are no objects with constructors or destructors in the copied memory because knows nothing about types .
Both copy operations use .

The corresponding function for move operations .

For example , many " user interfaces deﬁne set of requests to which every object represented on the screen should be prepared to respond .
In addition , such requests can be presented directly or indirectly from programs .
Consider simple variant of this idea : class .

The exact meaning of each operation is deﬁned by the object on which it is invoked .
Often , there is layer of software between the person or program issuing the request and the object receiving it .

Ideally , such intermediate layers of software should not have to know anything about the individual operations such as and .
If they did , the intermediate layers would have to be updated each time an operation changed .
Consequently , such intermediate layers simply transmit data representing the operation to be invoked from the source of the request to its recipient .

For example , to invoke we could send the string .
Howev er , someone has to create that string and someone has to decode it to determine to which operation it corresponds if any .

Often , that seems indirect and tedious .
Instead , we might simply send an integer representing the operation .
For example , might be used to mean .
Howev er , while an integer may be convenient for machines to deal with , it can get pretty obscure for people .
We still have to write code to determine that means and to invoke .

However , we can use pointer to member to indirectly refer to member of class .
If want to invoke for some object without mentioning directly , need pointer to member referring to .
also need pointer or reference to the object want to .
Consider trivial .

variable of type to member of class " is declared using declarator of the form .

The use of an alias to compensate for the lack of readability of the declarator syntax is typical .
However , please note how the declarator matches the traditional declarator exactly .

pointer to member can be used in combination with an object .
The operators and allow the programmer to express such combinations .
For example , binds to the object pointed to by , and binds to the object obj .
The result can be used in accordance with ' type .
It is not possible to store the result of or operation for later use .

Naturally , if we knew which member we wanted to call , we would invoke it directly rather than mess with pointers to members .
Just like ordinary pointers to functions , pointers to member functions are used when we need to refer to function without having to know its name .
However , pointer to member pointer to piece of memory the way pointer to variable or pointer to function is .
It is more like an offset into structure or an index into an array , but of course an implementation takes into account the differences between data members , virtual functions , nonvirtual functions , etc .
When pointer to member is combined with pointer to an object of the right type , it yields something that identiﬁes particular member of particular object .

The call can be represented graphically like this : vtbl :  Section Pointers to Function Members Because pointer to virtual member in this is kind of offset , it does not depend on an object ' location in memory .
pointer to virtual member can therefore be passed between different address spaces as long as the same object layout is used in both .
Like pointers to ordinary functions , pointers to member functions cannot be exchanged between address spaces .

Note that the function invoked through the pointer to function can be virtual .
For example , when we call through pointer to function , we get the right for the object to which the pointer to function is applied .
This is an essential aspect of pointers to functions .

When writing an interpreter , we might use pointers to members to invoke functions presented as .

The type of pointer to function is checked just like any other type .

This implies that we can safely assign pointer to member of base class to pointer to member of derived class , but not the other way around .
This property is often called contravariance .

For example : class Text  public .

This contravariance rule appears to be the opposite of the rule that says we can assign pointer to derived class to pointer to its base class .
In fact , both rules exist to preserve the fundamental guarantee that pointer may never point to an object that at least have the properties that the pointer promises .
In this case , can be applied to any  and most such objects presumably are not of type Te xt .
Consequently , they do not have the member Te with which we tried to initialize .
By refusing the initialization , the compiler saves us from error .

Design of Hierarchies Implementation Inheritance ; Interface Inheritance ; Alternative Implementations ; Localizing Object Creation .

Multiple Inheritance Multiple Interfaces ; Multiple Implementation Classes ; Ambiguity Resolution ; Repeated Use of Base  Base Classes ; Replicated vs .

Advice Introduction The primary focus of this chapter is design techniques , rather than language features .
The examples are taken from design , but avoid the topic of programming as commonly used for graphical user interface systems .
discussion of exactly how an action on the screen is transformed into call of member function would add little to the issues of class hierarchy design and has huge potential for distraction : it is an interesting and important topic in its own right .
For an understanding of GUI , have look at one of the many GUI libraries .

This can be done in bewildering number of ways .
To insulate our program from this variety , and also to get chance to explore the possible design choices , let us start by deﬁning our model of this simple input operation .

program can ask an for its value and ask it to prompt the user if necessary .
In addition , program can ask an if user changed the value since the program last looked at it : value user application : Because there are many ways of implementing this basic idea , we must assume that there will be many different kinds of , such as sliders , plain boxes in which user can type number , dials , and voice interaction .

The general approach is to build system " for the application to use .

This system provides some of the services provided by existing systems .
It can be implemented on wide variety of systems to ensure the portability of application code .
Naturally , there are other ways of insulating an application from system .
chose this approach because it is general , because it allows me to demonstrate variety of techniques and design tradeoffs , because those techniques are also the ones used to build " systems , and most important because these techniques are applicable to problems far beyond the narrow domain of interface systems .

In addition to ignoring the topic of how to map user actions to library calls , also ignore the need for locking in GUI system .

In addition , we declare the data needed to implement the basic notion : class .

realistic class would , for example , provide some range checking .

programmer might use these classes " like .

Most application code is written in terms of plain the way is .
That way , the application hav to know about the potentially large number of variants of the concept .
The knowledge of such specialized classes is isolated in the relatively few functions that create such objects .
This isolates users from changes in the implementations of the derived classes .
Most code can be oblivious to the fact that there are different kinds of .

use , to avoid forgetting to delete the .

To simplify the discussion , do not address issues of how program waits for input .
Maybe the program really does wait for the user in , using on future ; maybe the program associates the with an event and prepares to respond to callback , or maybe the program spawns thread for the and later inquires about the state of that thread .
Such decisions are crucial in the design of systems .
However , discussing them here in any realistic detail would simply distract from the presentation of programming techniques and language facilities .
The design techniques described here and the language facilities that support them are not speciﬁc to user interfaces .
They apply to far greater range of problems .

The different kinds of are deﬁned as classes derived from .
For example : class  public private :

protected member is accessible from own members and from members of derived classes , but not to general users .

In addition to  we would deﬁne other variants of the concept .
These could include  which lets you select by turning knob ; which ﬂashes when you ask it to ; and , which responds to by appearing in some prominent place , thus making it hard for the user to ignore .

From where would we get the graphics stuff .
Most systems provide class deﬁning the basic properties of being an entity on the screen .
So , if we use the system from Bucks " we would have to make each of our   classes kind of BBwidget .
This would most simply be achieved by rewriting our so that it derives from BBwidget .

In that way , all our classes inherit all the properties of BBwidget .
For example , every can be placed on the screen , obey the graphical style rules , be resized , be dragged around , according to the standard set by the BBwidget system .
Our class hierarchy would look like this : class  public BBwidget .

However , there are some awkward details that could lead us to look for alternative designs .

We retroﬁtted BBwidget as the base of .
This is not quite right if this style is common in .
The use of BBwidget part of our basic notion of an  it is an implementation detail .
Deriving from BBwidget elevated an implementation detail to design decision .

For example , using the environment deﬁned by Bucks " may be key decision based on how our organization conducts its business .
However , what if we also wanted to have implementations of our for systems from Section Critique " and .
We would have to maintain four distinct versions of our .

Having many versions could result in version control nightmare .

In reality , we are unlikely to ﬁnd simple , coherent , preﬁx scheme .
More likely , the libraries from different purveyors would be in different namespaces and use different terminologies for similar concepts , such as et , and .
But that does not affect our class hierarchy design discussion , so to simplify ignore naming and namespace issues .

Another problem is that every derived class shares the basic data declared in .
That data is , of course , an implementation detail that also crept into our interface .
From practical point of view , it is also the wrong data in many cases .
For example , an need the stored speciﬁcally .
It can easily be calculated from the position of the slider when someone executes .
In general , keeping two related , but different , sets of data is asking for trouble .
Sooner or later someone will get them out of sync .
Also , experience shows that novice programmers tend to mess with protected data in ways that are unnecessary and that cause maintenance problems .
Data members are better kept private so that writers of derived classes cannot mess with them .
Better still , data should be in the derived classes , where it can be deﬁned to match requirements exactly and cannot complicate the life of unrelated derived classes .
In almost all cases , protected interface should contain only functions , types , and constants .

Deriving from BBwidget gives the beneﬁt of making the facilities provided by BBwidget available to users of .
Unfortunately , it also means that changes to BBwidget may force users to recompile or even rewrite their code to recover from such changes .
In particular , the way most implementations work implies that change in the size of base requires recompilation of all derived classes .

Finally , our program may have to run in mixed environment in which windows of different systems coexist .
This could happen either because two systems somehow share screen or because our program needs to communicate with users on different systems .
Having our systems in " as the one and only base of our one and only interface just ﬂexible enough to handle those situations .

Here , present one that maps cleanly into the language .

First , specify as pure interface :

This is much cleaner than the original declaration of .
The data is gone and so are the simplistic implementations of the member functions .
Gone , too , is the constructor , since there is no data for it to initialize .
Instead , added virtual destructor to ensure proper cleanup of the data that will be deﬁned in the derived classes .

The deﬁnition of might look like this :  public , protected BBwidget .

It also inherits from BBwidget which provides it with the means of doing so .
Since provides the interface for the derived  it is derived using public .
Since BBwidget is only an implementation aid , it is derived using protected .
This implies that programmer using cannot directly use facilities deﬁned by BBwidget .
The interface provided by is the one inherited from , plus what explicitly declares .
used protected derivation instead of the more restrictive usually private derivation to make BBwidget available to classes derived from .
used explicit override because this hierarchy " is exactly the kind of large , complicated hierachy where being explicit can help minimize confusion .

Deriving directly from more than one is usually called multiple inheritance .
Note that must override functions from both and BBwidget .
Therefore , it must be derived directly or indirectly from both .
As shown in , deriving indirectly from BBwidget by making BBwidget base of is possible , but doing so has undesirable side Section Interface Inheritance effects .
Similarly , making the  BBwidget member of is not solution because cannot override virtual functions of its members .
Representing the window by member in leads to completely different design with separate set of tradeoffs .

To some people , the words inheritance " indicate something complicated and scary .

However , the use of one base for implementation details and another for interface abstract is common to all languages supporting inheritance and checked interfaces .
In particular , the use of the abstract is almost identical to the use of an interface in Java or .

Interestingly , this declaration of allows application code to be written exactly as before .
All we have done is to restructure the implementation details in more logical way .

Many classes require some form of cleanup for an object before it goes away .
Since the abstract cannot know if derived requires such cleanup , it must assume that it does require some .
We ensure proper cleanup by deﬁning virtual destructor in the base and overriding it suitably in derived classes .

The delete operator explicitly destroys the object pointed to by .
We hav no way of knowing exactly to which the object pointed to by belongs , but thanks to virtual destructor , proper cleanup as deﬁned by that  destructor will be done .

The hierarchy can now be deﬁned like this :

General users cannot access the protected bases because they are considered part of the implementation .

However , it still fails to solve the version control problem :

There is no way of having the for BBwidgets coexist with the for CWwidgets , ev en if the two systems could themselves coexist .
The obvious solution is to deﬁne several different classes with separate names : class .

For example , if the Bucks " system has slider class , we can derive our directly from the BBslider : class  public , protected BBslider .
In that case , programming is reduced to mapping between similar concepts .
Derivation from general base classes , such as BBwidget , is then done only rarely .

The complete hierarchy will consist of our original conceptual hierarchy of interfaces expressed as derived classes : class .

Using obvious abbreviations , this hierarchy can be represented graphically like this : Class Chapter iﬂash ipopup CWsl CWsl CWsl CWislider BBislider CWipop CWiﬂ BBipop BBiﬂ BBslider BBslider The original class hierarchy appears unchanged surrounded by implementation classes .

In the latter design , the windows class is the root of tree .
In the former , the original application class hierarchy appears unchanged as the root of classes that supply its implementations .
From the point of view , these designs are equivalent in the strong sense that all code works unchanged and in the same way in the two cases .
In either case , you can look at the family of classes without bothering with the implementation details most of the time .
For example , we would not need to rewrite from if we switched from one class hierarchy to the other .

In either case , the implementation of each class must be rewritten when the public interface of the system changes .
However , in the abstract class design , all user code is protected against changes to the implementation hierarchy and requires no recompilation after such change .
This is especially important when the supplier of the implementation hierarchy issues  compatible " release .
In addition , users of the abstract class hierarchy are in less danger of being locked into proprietary implementation than are users of classical hierarchy .
Users of the abstract class application hierarchy cannot accidentally use facilities from the implementation because only facilities explicitly speciﬁed in the hierarchy are accessible ; nothing is implicitly inherited from an base class .

The logical conclusion of this line of thought is system represented to users as hierarchy of abstract classes and implemented by classical hierarchy .

Use abstract classes to support interface inheritance ,

Use base classes with implementations of virtual functions to support implementation inheritance ,

Further , should the derived interfaces evolve to provide more facilities than plain , then most of an application can be written using the , interfaces .
However , the creation of objects must be done using names such as and .
We would like to minimize the number of places where such speciﬁc names occur , and object creation is hard to localize unless it is done systematically .

As usual , the solution is to introduce an indirection .

simple one is to introduce an abstract class to represent the set of creation operations : class .

For each interface from the family of classes that user should know about , class provides function that makes an object .
Such class is sometimes called factory , and its functions are sometimes called virtual constructors .

We now represent each system by class derived from : class  public .

Given an , user can now create objects without having to know exactly which userinterface system is used .
For example : Class Chapter .

Passing arguments to such constructors " is bit tricky .
In particular , we cannot override the base class functions that represent the interface with different arguments in different derived classes .
This implies that fair bit of foresight is required to design the factory interface .

Shared interfaces : leading to less replication of code using classes and making such code more uniform .
This is often called polymorphism or interface inheritance .

Shared implementation : leading to less code and more uniform implementation code .
This is often called implementation inheritance .

class can combine aspects of these two styles .

Here , we explore more general uses of multiple base classes and examine more technical issues related to combining and accessing features from multiple base classes .

For an abstract class without mutable state , there really is little difference between single and multiple uses of base class in class hierarchy .
The resolution of potential ambiguities is discussed in , and .
In fact , any class without mutable state can be used as an interface in lattice without signiﬁcant complications and overhead .
The key observation is that class without mutable state can be replicated if necessary or shared if that is desired .

The use of multiple abstract classes as interfaces is universal in designs any language with notion of an .

Satellite object would contain orbital , size , shape , albedo , density parameters , and provide operations for orbital calculations , modifying attributes , etc .
Examples of Section Multiple Implementation Classes satellites would be rocks , debris from old space vehicles , communication satellites , and the International Space Station .
These kinds of satellites would be objects of classes derived from Satellite .

Such derived classes would add data members and functions and would override some of virtual functions to adjust their meaning suitably .

Now assume that want to display the results of these simulations graphically and that had available graphics system that used the strategy of deriving objects to be displayed from common base class holding graphical information .
This graphics class would provide operations for placement on the screen , scaling , etc .
For generality , simplicity , and to hide the details of the actual graphics system , will refer to the class providing graphical in fact alternatively output Display .

We can now deﬁne class of simulated communication satellites , class : class  public Satellite , public Displayed public :

Virtual functions work as usual .
For example : Class Chapter class Satellite .

This ensures that and will be called for treated as and Displayed , respectively .

Why just keep the Satellite and Displayed parts of completely separate .
could have deﬁned to have Satellite member and Displayed member .
Alternatively , could have deﬁned to have member and member and let its constructor set up the proper connections .
For many design problems , would do just that .
However , the system that inspired this example was built on the idea of Satellite class with virtual functions and Displayed class with virtual functions .
You provided your own satellites and your own displayed objects through derivation .
In particular , you had to override Satellite virtual member functions and Displayed virtual member functions to specify the behavior of your own objects .
That is the situation in which multiple inheritance of base classes with state and implementation is hard to avoid .
Workarounds can be painful and hard to maintain .

The use of multiple inheritance to " two otherwise unrelated classes together as part of the implementation of third class is crude , effective , and relatively important , but not very interesting .
Basically , it sav es the programmer from writing lot of forwarding functions compensate for the fact that we can only override functions deﬁned in .
This technique does not affect the overall design of program signiﬁcantly and can occasionally clash with the wish to keep implementation details hidden .
However , technique hav to be clever to be useful .

generally prefer to have single implementation hierarchy and several abstract classes providing interfaces .
This is typically more ﬂexible and leads to systems that are easier to ev olve .
However , you always get that especially if you need to use existing classes that you want to modify , because they are parts of someone .

Note that with single inheritance , the choices for implementing the classes Displayed , Satellite , and would be limited .
could be Satellite or Displayed , but not both Satellite was derived from Displayed or vice .
Either alternative involves loss of ﬂexibility .

Contrary to some conjectures , the Satellite example is real .
There really was and maybe there still is program constructed along the lines used to describe multiple implementation inheritance here .
It was used to study the design of communication systems involving satellites , ground stations , etc .
In fact , Satellite was derived from an early notion of concurrent task .
Given such simulation , we can answer questions about communication trafﬁc ﬂow , determine proper responses to ground station that is being blocked by rainstorm , consider tradeoffs between satellite connections and connections , etc .

For example : class Satellite .

declared in derived class overrides all functions of the same name and type in its base classes .
Typically , that is exactly the right thing to do because it is generally bad idea to use the same name for operations with different semantics in single class .
The ideal for virtual is for Class Chapter call to have the same effect independently of which interface was used to ﬁnd the .

In the implementation of an overriding  it is often necessary to explicitly qualify the name to get the right version from base class .
qualiﬁed name , such as , can refer to declared either in Telstar or in one of its base classes .
For example : class Telstar  public .

If exactly one match is found , that name will be used .

Otherwise , is either not found or is ambiguous .

If , in , had said plain , the result would have been an " recursive call of .

could have said , but now the code would be subtly broken if someone added ; it is generally better to refer to direct base class than to an indirect base class .

Had said , the result would have been an error because the is over on the Displayed branch of the class hierarchy .

The example basically assumes that at least some parts of Satellite and Displayed have been designed together .
Getting an exact match of names , return types , argument types , and semantics by accident is extremely unlikely .
It is far more likely that similar functionality is provided in different ways so that it takes effort to merge it into something that can be used together .

We might originally have been presented with two classes SimObj and Widget that we could not modify , exactly provide what we needed , and where they did provide what we needed , did so through incompatible interfaces .
In that case , we might have designed Satellite and Displayed as our interface classes , providing layer " for our classes to use : Section Ambiguity Resolution class Satellite  public SimObj map SimObj facilities to something easier to use for Satellite simulation .

These two functions have radically different meanings but are identical in name and type ; we need to override them by two Class Chapter separate functions .
There is no direct language solution to this problem , but adding intermediate classes will do : struct WWindow  Window using .

Or graphically : Window Cowboy WWindow CCowboy Had the designer of Window been bit more careful and speciﬁed to be const , the whole problem would have evaporated .
ﬁnd that fairly typical .

When class can have multiple base classes , class can appear multiple times in the resulting hierarchy .
Consider class providing facilities for storing state in ﬁle , for breakpointing , debug information , or and restoring it .

Such useful class will naturally be used in several places in class hierarchy .
For example : Section Repeated Use of Base Class class Transmitter  public Storable .

Given that , we could imagine two cases : Radio object has two subobjects of class Storable for Transmitter and one for .

The default , provided for the example as written , is two subobjects .
Unless you state otherwise , you get one copy for each time you mention class as base .
Graphically , we can represent that like this : Storable Storable Transmitter Receiver Radio virtual function of replicated base class can be overridden by function in derived class .
Typically , an overriding function calls its base class versions and then does the work speciﬁc to the derived .

Casting from replicated base class to derived class is discussed in .
For technique for overriding each of the functions with separate functions from derived classes , see .

The reason for that is simply that Storable is an abstract class providing pure interface .
Storable object holds no data of its own .
This is the simplest case and the one that offers the best separation of interface and implementation concerns .
In fact , class could not without some difﬁculty determine that there were two Storable subobjects on Radio .

What if did hold data and it was important that it should not be replicated .
For example , we might deﬁne to hold the name of the ﬁle to be used for storing the object : class .

Given this apparently minor change to  we must change the design of Radio .
All parts of an object must share single copy of .
Otherwise , we could get two parts of something derived from multiple times using different ﬁles .
We avoid replication by declaring base virtual : every virtual base of derived class is represented by the same object .
For example : class Transmitter  public virtual .

In an inheritance graph , every base class of given name that is speciﬁed to be virtual will be represented by single object of that class .
On the other hand , each base class not speciﬁed virtual will have its own subobject representing it .

Why would someone want to use virtual base containing data .
can think of three obvious ways for two classes in class hierarchy to share data : Make the data nonlocal the class as global or namespace .

Option , nonlocal data , is usually poor choice because we cannot control what code accesses the data and how .
It breaks all notions of encapsulation and locality .

Option , put the data in base class , is usually the simplest .
However , for single inheritance that solution makes useful data up " to common base class ; often it " all the way to the root of an inheritance tree .
This means that every member of the class hierarchy gets access .
That is logically very similar to using nonlocal data and suffers from the same problems .
So we need common base that is not the root of tree that is , virtual base .

Option , sharing an object accessed through pointers , makes sense .
However , then need to set aside memory for that shared object , initialize it , and provide pointers to the shared object to objects needing access .
That is roughly what constructors do to implement virtual base .

If you need sharing , you can do without virtual bases , and your code is often better and typically simpler for it .
However , if you do need sharing within general class hierarchy , you basically have choice between using virtual base and laboriously constructing your own variants of the idea .

We can represent an object of class with virtual base like this : Receiver Transmitter Radio Class Chapter The " to the shared object representing the virtual base ,  will be offsets , and often one of those can be optimized away by placing in ﬁxed position relative to either the Receiver or the Transmitter subobject .
Expect storage overhead of one word for each virtual base .

Naturally , we would prefer to keep the lattices simple , but however complicated we make them , the language ensures that constructor of is called before its derived classes .
Anything else would cause chaos is , an object might be used before it had been .
To avoid such chaos , the constructor of every virtual base is invoked or from the constructor for the complete object constructor for the most derived .
In particular , this ensures that virtual base is constructed exactly once ev en if it is mentioned in many places in the class hierarchy .

Note that can and must provide an initializer for .
The fact that explicitly mentioned as base of is irrelevant .
Knowledge of virtual base and the obligation to initialize it up " to the most derived class .
virtual base is always considered direct base of its most derived Section Constructing Virtual Bases class .
The fact that both and initialized is irrelevant because the compiler has no idea which of those two initializers to prefer .
Thus , only the initializer provided by the most derived class is used .

The constructor for virtual base is called before the constructors for its derived classes .

In practice , this is not quite as localized as we would prefer .
In particular , if we derive another class , DD , from , then DD has to do work to initialize the virtual bases .
Unless we can simply inherit constructors , that can be nuisance .
That ought to encourage us not to overuse virtual base classes .

This logical problem with constructors does not exist for destructors .
They are simply invoked in reverse order of construction .
In particular , destructor for virtual base is invoked exactly once .

This can be problem when implementing service that requires base class function to be called exactly once for each call of derived function .
Where needed , the programmer can simulate the scheme used for constructors by calling virtual base class function only from the most derived class .
For example , assume we have basic Window class that knows how to draw its contents : class Window .

From this , we can compose plausible Clock class : Class Chapter class Clock  public , public clock stuff .

This is done independently of the kind of Window .

Instead , it directly calls the explicitly named function , thus avoiding nasty inﬁnite recursion .

Casting from virtual base class to derived class is discussed in .

Virtual Bases Using multiple inheritance to provide implementations for abstract classes representing pure interfaces affects the way program is designed .
Class is an example : Section Replicated vs .
Virtual Bases class  public , interface protected BBslider .

One base is public abstract class providing the interface , and the other is protected concrete class providing implementation provided .
The use of multiple inheritance is close to essential here because the derived class needs to override virtual functions from both the interface and the implementation .

For example , consider again the classes from .
In the end , made all the classes abstract to reﬂect their role as pure interfaces .
Doing that allowed me to place all implementation details in speciﬁc implementation classes .
Also , all sharing of implementation details was done in the classical hierarchy of the windows system used for the implementation .

When using an abstract class any shared as an interface , we have .

Replicate the interface class object per mention in the class .

Make the interface class virtual to share simple object among all classes in the hierarchy that mention it .

Using as virtual base gives us : class  public virtual , protected BBslider .

However , we also have this alternative using replicated objects : class  public , protected BBslider .

There are logical differences , though .
In the replicated design , be implicitly converted to an that would be .

On the other hand , it is possible to construct plausible scenarios where the sharing implied in the virtual base design causes ambiguities for casts from the base class .
However , such ambiguities are easily dealt with .

How do we choose between virtual base classes and replicated base classes for our interfaces .

Most often , of course , we get choice because we have to conform to an existing design .

When we do have choice , we can take into account that the replicated base solution tends to lead to slightly smaller objects there is no need for data structures supporting and that we often get our interface objects from constructors " or functions "

No explicit conversion is needed to get from an implementation , to its direct interfaces ,

In particular , two different classes might override different virtual functions from the virtual base .
In that way , sev eral derived classes can contribute implementations to the interface presented by virtual base class .
For example , the Window class might have functions and .
In that case , might override as part of controlling the color scheme , and might override as part of its control of user interactions : Section Overriding Virtual Base Functions .

For example , could override to improve on what .

If two classes override base class function , but neither overrides the other , the class hierarchy is an error .
The reason is that no single function can be used to give consistent meaning for all calls independently of which class they use as an interface .
Or , using implementation terminology , no virtual function table can be constructed because call to that function on the complete object would be ambiguous .
For example , had Radio in not declared , the declarations of in Receiver and Transmitter would have caused an error when deﬁning Radio .
As with Radio , such conﬂict is resolved by adding an overriding function to the most derived class .

class that provides some but not all of the implementation for virtual base class is often called mixin .

Class Navigation dynamic cast ; Multiple Inheritance ; and ; Recovering an Interface .

Double Dispatch and Visitors Double Dispatch ; Visitors .

Construction and Destruction .

Type Identiﬁcation Extended Type Information .

Uses and Misuses of RTII .

Advice Introduction In general , class is constructed from lattice of base classes .
Such class lattice is often called class hierarchy .
We try to design classes so that users need not be unduly concerned about the way class is composed out of other classes .
In particular , the virtual call mechanism ensures that when we call function on an object , the same function is called whichever class in the hierarchy provided the declaration of used for the call and whichever class deﬁned it .
This chapter explains how to gain information about the total object given only the interface provided by base class .

We will refer to the combination of GUI library and operating system facilities that control the screen as the system .
Objects passed back and forth between the system and the application are commonly referred to as widgets or controls .
This is how many user interfaces work .

From language point of view , it is important that the system does not know about our .

The interfaces are speciﬁed in terms of the own classes and objects rather than our classes .

Howev er , it does have the unpleasant effect that we lose information about the type of objects passed to the system and later returned to us .

Recovering the " type of an object requires us to somehow ask the object to reveal its type .

Any operation on an object requires us to have pointer or reference of suitable type for the object .
Consequently , the most obvious and useful operation for inspecting the type of an object at run time is type conversion operation that returns valid pointer if the object is of the expected type and null pointer if it .
The operator does exactly that .
For example , assume that system " inv okes with pointer to BBwindow , where an activity has occurred .
then might invoke my application code using .

One way of explaining what is going on here is that translates from the language of the system to the language of the application .
It is important to note what is not mentioned in this example : the actual type of the object .
The object will be particular kind of , say , an , implemented by particular kind of BBwindow , say , BBslider .
It is neither necessary nor desirable to make the actual type of the object explicit in this interaction between system " and the application .
An interface exists to represent the essentials of an interaction .
In particular , interface hides inessential details .

Graphically , the action of can be represented like this : BBwindow BBslider pw Section Class Navigation The arrows from pw and represent the pointers into the object passed , whereas the rest of the arrows represent the inheritance relationships between the different parts of the object passed .

The use of type information at run time is conventionally referred to as type " often abbreviated to RTTI .

Casting from base class to derived class is often called downcast because of the convention of drawing inheritance trees growing from the root down .
Similarly , cast from derived class to base is called an upcast .
cast that goes from base to sibling class , like the cast from BBwindow to , is called crosscast .

Consider ﬁrst the pointer .

However , it is reassuring to know that allow accidental violation of the protection of private and protected base classes .
Since used as an upcast is exactly like simple assignment , it implies no overhead and is sensitive to its lexical context .

The purpose of is to deal with the case in which the correctness of the conversion cannot be determined by the compiler .
In that case , looks at the object pointed to by .
If that object is of class or has unique base class of type , then returns pointer of type to that object ; otherwise , nullptr is returned .
If the value of is nullptr , returns nullptr .
Note the requirement that the conversion must be to uniquely identiﬁed object .
It is possible to construct examples where the conversion fails and nullptr is returned because the object pointed to by has more than one subobject representing bases of type .

requires pointer or reference to polymorphic type in order to do downcast or crosscast .
For example : Type Information Chapter .

Requiring the type to be polymorphic simpliﬁes the implementation of because it makes it easy to ﬁnd place to hold the necessary information about the type .
typical implementation will attach information object " to an object by placing pointer to the type information in the virtual function table for the class .

It is clear that can be efﬁciently implemented .
All that is involved are few comparisons of objects representing base classes ; no expensive lookups or string comparisons are needed .

Restricting to polymorphic types also makes sense from logical point of view .

That is , if an object has no virtual functions , it cannot safely be manipulated without knowledge of its exact type .
Consequently , care should be taken not to get such an object into context in which its type known .
If its type is known , we need to use .

The target type of need not be polymorphic .
This allows us to wrap concrete type in polymorphic type , say , for transmission through an object system , and then " the concrete type later .

The object representing base class , such as , in derived class object is not necessarily the ﬁrst subobject in that object of the most derived class .
So , does not necessarily hold the same address as .

Such casts are only useful for interaction with very functions such functions deal with .
There is no from there would be no way of knowing where to ﬁnd the vptr ;

When used for pointer type , nullptr indicates failure .
That neither feasible nor desirable for references .

Given pointer result , we must consider the possibility that the result nullptr , that  that the pointer point to an object .
Consequently , the result of of pointer should always be explicitly tested .
For pointer , can be seen as the question the object pointed to by , if any , of type " For .

On the other hand , we may legitimately assume that reference refers to an object .
Consequently , of reference not question but an assertion : object referred to by of type " The result of for reference implicitly tested by the implementation of itself .
If the operand of to reference of the expected type , exception thrown .
For example : Type Information Chapter .

The calls to and the ﬁrst call to will return normally that really can cope with , but the second call of will cause exception that will be caught by .

Explicit tests against nullptr can easily be accidentally omitted .
If that worries you , you can write conversion function that throws an exception instead of returning nullptr in case of failure .

This simple but often constraining .
When multiple inheritance used , there no single root .
In itself , this complicate matters much .
However , if class appears more than once in hierarchy , we must be bit careful when we refer to the object or objects that represent that class .

Naturally , we try to keep hierarchies as simple as our application allows no .

However , once nontrivial hierarchy has been constructed , we sometimes need to navigate it to ﬁnd speciﬁc class to use .
This need occurs in two .

Sometimes , we want to explicitly name base class for use as an interface , for example , to resolve an ambiguity or to call speciﬁc function without relying on the virtual function mechanism explicitly qualiﬁed call ;

Sometimes , we want to obtain pointer to subobject of hierarchy giv en pointer to another , for example , to get pointer to the complete derived class object from pointer to base downcast ; or to get pointer to base class object from pointer to another base crosscast ;

Here , we consider how to navigate class hierarchy using type conversions to gain pointer of the desired type .
To illustrate the mechanisms available and the rules that guide them , consider lattice containing both replicated base and virtual base : Section Multiple Inheritance class Component  public virtual Storable .

Consequently , from to within Radio will be ambiguous and return .
There simply no way of knowing which the programmer .

Instead , code written with the knowledge of some sublattice .

For example , programmer might know only about the Transmitter part of Radio and write : void .

The ambiguity for pointer to Radio object not in general detectable at compile time .

This kind of ambiguity detection needed only for virtual bases .
For ordinary bases , there always unique subobject of given cast when downcasting  toward Type Information Chapter derived class ;
The equivalent ambiguity for virtual bases occurs when upcasting  toward , but such ambiguities are caught at compile time .

does not examine the object it casts from , so it .

In particular , an object of type with layout constraints determined by some other language such as Fortran or may be used as virtual base class .
For objects of such types , only static type information will be available .
However , the information needed to provide type identiﬁcation includes the information needed to implement the .

Why would anyone want to use for class hierarchy navigation .
There cost associated with the use of .
More signiﬁcantly , there are millions of lines of code that were written before became available .
This code relies on alternative ways of making sure that cast valid , so the checking done by seen as redundant .
However , such code typically written using the cast ; often obscure errors remain .
Where possible , use the safer .

The compiler cannot assume anything about the memory pointed to by .
This implies that which must look into an object to determine its type cannot cast from .

It not possible to cast to private base class using or , and aw ay const " requires .
Even then , using the result safe only provided the object originally declared const .

As an example , consider simple object system .
Users want to read objects from stream , determine that they are of the expected types , and then use them .

The function deals with shapes exclusively through the abstract class Shape and can therefore use every kind of shape .
The use of is essential because the object system can deal with many other kinds of objects , and the user may accidentally have opened ﬁle containing perfectly good objects of classes that the user has never heard of .

used , so that would not forget to delete the object allocated by .

This object system assumes that every object read or written is of class derived from Class must be polymorphic type to allow the user of to use to recover the type " of returned object .
For example : class .

Assume that the data representing an object on an input stream is preﬁxed by string identifying the class .
The job of is to read that string and call function capable of reading and creating an object of the right class .
For example : using ; pointer to function returning an .

This is an example of how class can be ﬁtted into hierarchy using an abstract class with less foresight than would have been required to build it as node class in the ﬁrst place .

The constructor initializes an object with data from its istream argument .
The function is the one put into the to make the class known to the object system .

Note that does not have access to private or protected data .
The idea is that the transmission format for type is what is needed to construct an using one of constructors .
The information of the stream is not necessarily the sequence of member values .

The template is an example of way to ﬁt concrete types into class hierarchy by providing handle that is node in that hierarchy .
It derives from its template parameter to allow casting from .

This simple object system does not do everything anyone ever wanted , but it almost ﬁts on single page and the key mechanisms have many uses .
It is blueprint for the end " of system for transmitting arbitrary objects across communication channel in manner .

More generally , these techniques can be used to invoke function based on string supplied by user and to manipulate objects of unknown type through interfaces discovered through type identiﬁcation .

In general , the sender part of such an object system will also use RTTI .
Consider : class Face  public .

To correctly write out the pointed to by outline , we need to ﬁgure out which kind of it is .
job for .
In general , we must also keep table of pairs to be able to transmit linked data structures and to avoid duplicating objects pointed to by more than one pointer .

In particular , can do this lookup called dynamic for one type at time .
In this , resembles Simula and Smalltalk and more recent languages , such as Java and .
Not being able to select function based on two dynamic types can be serious limitation .

This implies that we cannot add virtual function to class hierarchy without modifying the base that provides the interface and all derived classes that should be affected .

This section describes the basic workarounds for these problems : Double Dispatch shows how to select virtual function based on two types .

Most realistic examples of these techniques occur when we deal with data structures , such as vectors or graphs or pointers to objects of polymorphic types .
In such cases , the actual type of an object , vector element or graph can only be known dynamically by or inspecting the interface provided by base class .

We would like this to work for any two classes in the class hierarchy rooted in  such as Circle and Triangle .

The basic strategy is to do virtual function call to select the right function for and then do second call to select the right function for .
To simplify , will leave out the calculation of whether the two shapes actually intersect and just write the code skeleton for selecting the right functions .
First we deﬁne with function for intersection : class .

Next we need to deﬁne and to override those virtual functions : Type Information Chapter class  public .

The interesting functions here are and .
These need to handle argument because that argument must refer to derived class .
The is to simply do virtual call with the arguments in the reverse order .

That done , we are in one of the four functions that can actually do an intersection calculation .

We can test this by making of all pairs of values and calling for .

If you consider this elegant , you need to raise your standards , but it gets the task done .
As the class hierarchy grows , the need for virtual functions grows exponentially .
That is not acceptable in most cases .
Expanding this to three or more arguments is trivial , but tedious .
Worst of all , each new operation and each new class require modiﬁcation to every class in the hierarchy : this technique is highly intrusive .
Ideally , would have preferred simple function with overriders speciﬁed for the desired combinations of particular Section Double Dispatch shapes .

The awkwardness of double dispatch does not make the problem it is trying to address less important .
It is not unusual to want an action , such as , that depends on the types of two operands .
For example , ﬁnding the intersection of rectangles is simple and efﬁcient .
So , for many applications , people have found it sufﬁcient to deﬁne box " for each shape and then calculate intersections on bounding boxes .
For example : class .

Variations of this idea are widely used .
Many variants use precomputed values stored in objects to speed up type identiﬁcation .

Consider how to apply two operations to every class in class hierarchy .
Basically , we will do double dispatch for hierarchy of nodes and hierarchy of operations to select the correct operation for the correct node .
The operations are called visitors ; here they are deﬁned in Type Information Chapter classes from class .
The nodes are hierarchy of classes with virtual function that takes .
For this example , use hierarchy of Nodes that describe language constructs , as is common in tools based on abstract syntax trees : class .

do not use here , because in general an operation from may update either the Node " or the itself .

Now the performs the trick and passes the Node itself to the .

It is only mildly intrusive , and many variations on the basic idea are used .
However , many operations on class hierarchies are hard to express as visitors .
For example , an operation that needs access to multiple nodes of different types in graph cannot be trivially implemented as visitor .
So , consider the visitor pattern an inelegant workaround .
Alternatives exist , for example , but not in plain .

Most alternatives to visitors in are based on the idea of explicit iteration over homogeneous data structure , or graph of nodes containing pointers to polymorphic .

At each element or node , call of virtual function can perform the desired operation , or some optimization based on stored data can be applied , see .

class object is built from memory " by its constructors , and it reverts to memory " as its destructors are executed .
Construction is , destruction is , and class object is an object to the extent that it has been constructed or destroyed .
This order is necessary to ensure that an object is not accessed before it has been initialized .
It is unwise to try to access base and member objects early or out of order through " pointer manipulation .
The order of construction and destruction is reﬂected in the rules for RTTI , exception handling , and virtual functions .

It is unwise to rely on details of the order of construction and destruction , but you can observe that order by calling virtual functions , or typeid at point where the object complete .
At such point in constructor , the type of the object reﬂects only what is constructed so far .
For example , if the constructor for Component in the hierarchy from calls virtual function , it will invoke version deﬁned for Storable or Component , but not one from Receiver , Transmitter , or Radio .
At that point of construction , the object yet Radio .
Similarly , calling virtual function from destructor will reﬂect only what is still not destroyed .
It is best to avoid calling virtual functions during construction and destruction .

Importantly , it ensures that code written using it works correctly with classes from those explicitly mentioned by the programmer .
Thus , preserves ﬂexibility and extensibility in manner similar to virtual functions .

However , it is occasionally essential to know the exact type of an object .
For example , we might like to know the name of the class or its layout .
The typeid operator serves this purpose by yielding an object representing the type of its operand .
Had been function , its declaration would have looked something like this : class ; pseudo declaration That is , returns reference to type called deﬁned in .

Giv en the name of type as its operand , returns reference to that represents the type_name type_name must be completely deﬁned type .

Giv en an expression as its operand , returns reference to that represents the type of the object denoted by the expr ; the expr must refer to completely deﬁned type .
If the value of expr is nullptr , throws .

can ﬁnd the type of an object referred to by reference or .

If the operand of has nonpolymorphic type or is not an lvalue , the result is determined at compile time without evaluating the operand expression .

If the object denoted by dereferenced pointer or reference to polymorphic type , the returned is that of the most derived class for the object , that is , the type used when the object was deﬁned .

The deﬁnition of looks like this : class .

The function allows be used as keys for hash tables as .

It is not guaranteed that there is only one object for each type in the system .
In fact , where dynamically linked libraries are used , it can be hard for an implementation to avoid duplicate objects .
Consequently , we should on objects to test equality , rather than on pointers to such objects .

We sometimes want to know the exact type of an object so as to perform some service on the whole object not just on one of its .
Ideally , such services are presented as virtual functions so that the exact type be known .
In some cases , no common interface can be assumed for every object manipulated , so the detour through the exact type becomes necessary .

Another , much simpler has been to obtain the of class for diagnostic output : Type Information Chapter .

The character representation of is .
This string resides in memory owned by the system , so the programmer should not attempt to it .

Therefore , ﬁnding the exact type of an object is often just the ﬁrst step to acquiring and using more detailed information about that type .

Consider how an implementation or tool could make information about types available to users at run time .
Suppose have tool that generates descriptions of object layouts for each class used .
can put these descriptors into to allow user code to ﬁnd the layout .

We hardwire comparison criterion into the container because the container impose its needs on the element types .
For example , by default , the map uses for comparison , but not all Keys hav that we would want to use .

We hardwire an ordering criterion into the Key type because there are many different ways of ordering elements based on key .
For example , one of the most common Key types is string and strings can be ordered based on variety of criteria , case sensitive and case .

Consequently , sorting criterion is not built into the container type or into the element type .
In principle , the notion of sorting criteria for map could be represented as : type argument to the map determining the type of comparison object At ﬁrst glance , the ﬁrst solution comparison object of speciﬁc seems simpler .
For example : Key , typename  const .

In particular , the designer of will have to decide whether to compare the Key type using pointer to function or function object of some speciﬁc type .
Also , because the argument types of the comparison operator must depend on the Key type , it can be hard to provide default comparison criterion .

Consequently , the second alternative the type of the comparison as type is the more common and the one used in the standard library .
For example : Key , Class  typename class .

The most common case , comparing using , is the default .
If we want different Section Operations as Arguments comparison criterion , we can supply it as function object .

simple class member function deﬁned is trivial to inline , whereas inlining call through pointer to function requires exceptional attention from compiler .

function object with no data members can be passed with no cost .

Sev eral operations can be passed as single object with no additional cost .

The comparison criterion for is just an example .
However , the technique used to pass it is general and very widely used to parameterize classes and functions with " Examples include actions for algorithms , allocators for containers , and deleters for .
We hav the same design alternatives when we need to specify arguments for function  such as , and the standard library chooses alternative for those cases also , see .

If we had only one use of comparison criterion in our program , it might make sense to use lambda to express the function object version bit more tersely :  const const return ; error Unfortunately , that work because there is no conversion of lambda to function object type .
We could name the lambda and then use that name : auto  const const return ; ﬁnd naming operations useful from design and maintenance point of view .
Also , anything named and declared nonlocally might ﬁnd other uses .

For example : Specialization Chapter  class .

For example , we specify that parameter is class that takes single type argument .
If we , we be able to use specializations of .
The point of using as parameter is usually that we want to instantiate it with variety of argument types as and in the previous .
That is , we want to express the member declarations of in terms of another  but we want that other to be parameter so that it can be speciﬁed by users .

Only class templates can be arguments .

The common case in which needs only container or two is often better handled by passing the container types .
For example :  typename .

Here , the value types of and can be obtained by simple type function for obtaining the type of elements of container , for example ,
This is the technique used for the container adaptors , such as queue .

We can specify to be the default type for the argument , so that only uncommon comparison criteria have to be explicitly speciﬁed : Section Default Template Arguments Key , Class  typename class .

Note how the default constructor creates default comparison object ,
the common case .
If we want more elaborate construction , we must do so explicitly .
For example : The semantic checking of default argument for parameter is done only if that default argument is actually used .
In particular , as long as we refrain from using the default argument , we can values of type for which compile .
This point is crucial in the design of the standard containers , which rely on argument to specify default values .

Just as for default function arguments , the default arguments can be speciﬁed and supplied for trailing arguments .

Not allowing an " argument to mean the default " was deliberate tradeoff between ﬂexibility and the opportunity for obscure errors .

Curiously enough , it is not used for , Chapter comparisons .
Instead , the string relies on .
Similarly , the standard algorithms rely on and the containers rely on allocators .
The use of traits is presented in .

For example : typename .

This implementation of is bit heavyweight for combinations of simple types , such as , but improved implementations can be supplied as specializations .
Note that will not work because char and int do not share string representation .
For conversion among scalar numeric types , tend prefer .

This always make sense for someone writing template .
might want say , template argument is pointer , use this implementation ; if it is not , use that " or an error unless template argument is pointer derived from class " Many such design concerns can be addressed by providing alternative deﬁnitions of template and having compiler choose between them based on Section Specialization template arguments provided where they are used .
Such alternative deﬁnitions of template are called specializations , or simply user specializations .
Consider likely uses of Vector : class Vector general type .

In such code , most Vectors will be Vectors of some pointer type .
There are several reasons for this , but primary reason is that preserve polymorphic behavior , we must use pointers ,
That is , anyone who practices programming and uses containers as will end up with lot of containers of pointers .

The default behavior of most implementations is replicate code for template functions .
This is usually good for performance , but unless care is taken , it leads code bloat in critical cases such as example .

Fortunately , there is an obvious solution .
Containers of pointers can share single implementation .
This can be expressed through specialization .
First , we deﬁne version of for pointers void :

This specialization can then be used as common implementation for all Vectors of pointers .

Another use would be implement based on single shared implementation class storing .

The preﬁx says that this is specialization that can be speciﬁed without template parameter .
The template arguments for which specialization is be used are speciﬁed in brackets after name .
That is , says that this deﬁnition is be used as implementation of every for which is .

That is , there is no template parameter specify or deduce when we use specialization ; is used for Vectors declared like this : vpv ; To deﬁne specialization that is used for every of pointers and only for Vectors of pointers , we can write : class  private .

The specialization pattern after name says that this specialization be used for every pointer type ; that  this deﬁnition be used for every with template argument that can be expressed as .
For example : vps ; so Shape vppi ; so specialization with pattern containing template parameter called partial specialization in contrast complete specializations in deﬁnition of , where  pattern " simply speciﬁc type .

Note that when partial specialization used , template parameter deduced from specialization pattern ; template parameter not simply actual template argument .

Given this partial specialization of  we hav shared implementation for all Vectors of pointers .
The class simply an interface implemented exclusively through derivation and inline expansion .

It important that this reﬁnement of implementation of be achieved without affecting interface presented users .
Specialization way of specifying alternative implementations for different uses of common interface .
Naturally , we could have giv en general and of pointers different names .
However , when tried that , many people who should have known better forgot use pointer classes and found their code much larger than expected .

In this case , it much better hide crucial implementation details behind common interface .

This technique proved successful in curbing code bloat in real use .
People who do not use have found that replicated code can cost megabytes of code space even in moderately sized programs .
By eliminating time needed compile those additional versions of operations , this technique can also cut compile and link times dramatically .
Using single specialization Section Specialization implement all lists of pointers an example of general technique of minimizing code bloat by maximizing amount of shared code .

Some compilers are getting smart enough perform this particular optimization without help from programmer , but technique generally applicable and useful .

Variants of technique of using single representation for values of number of types and relying on type system ensure that they are used only according their declared type has been called type erasure .
In context of , it was ﬁrst documented in original template paper .

For example , standard library complex uses specializations adjust set of constructors and argument types for important operations for important specializa looks like this : class .

In addition , conversions from and are provided described in : class .

Note that these specialized constructors are constexpr , making literal type .

Also , this deﬁnition takes advantage of the knowledge that conversion from to safe never , so that we can have an implicit constructor from .
Howev er , the constructor from explicit to make narrowing less likely .

In that case , specialization can even provide representation that differs from that of the general template .
For example :  int class .

The primary template deﬁnes the interface for all specializations .
That  the primary template the one used to determine if use valid and takes part in overload resolution .

Only after primary template has been chosen are specializations considered .

The primary template must be declared before any specialization .
For example : class .

If we have deﬁned constraints check for template , the primary template where it belongs because concepts are something user cares about and must understand to use the template .
For example :

For technical reasons the language recognize constraints checks for what they , constraints check needs to be replicated in every specialization .

declaration of the primary template sufﬁcient to allow the deﬁnition of specialization : class .

If the primary template never instantiated , it need not be deﬁned .
This can be used to deﬁne template for which only ﬁxed set of alternative arguments are accepted .
If user specializes template , that specialization must be in scope for every use of the template with the type for which it was specialized .
For example : class .

Here , was specialized for after had been used .

It is essential that every use of template for given set of template arguments be implemented by the same specialization .
If not , the type system is broken , so that identical uses of template in different places may yield different results and objects created in different parts of program may not be compatible .
Clearly that would be disastrous , so programmer must take care that explicit specialization is consistent throughout program .
In principle , implementations are capable of detecting inconsistent specialization , but the standard does not require them to and some .

All specializations of template must be declared in the same namespace as the primary template .
If used , specialization that is explicitly declared opposed to generated from more general must also be explicitly deﬁned somewhere .
In other words , explicitly specializing template implies that no deﬁnition is generated for that specialization .

For example : class Vector ; general ; the primar template class ; specialized for any pointer class ; specialized for Every type can be used as template argument for the most general Vector , but only pointers can be used for and only can be used for .

The most specialized version will be preferred over the others in declarations of objects , pointers , etc .

specialization pattern can be speciﬁed in terms of types composed using the constructs allowed for template parameter deduction .

However , we can overload functions , so we see less specialization .
Furthermore , supports only complete specialization for functions , so we use overloading where we might have tried partial specialization .

Those versions compare elements using and swap elements using detailed code .
better deﬁnition would be :

We now hav and swap as named entities for which we can provide improved versions .
Such names are often referred to as customization points .

As written , will not sort correctly will compare the two .

That is , it will compare the addresses of the ﬁrst char in each string .
Instead , we would like it to compare the characters pointed to .
simple specialization of for const will take care of .

As for classes , the preﬁx says that this is specialization that can be speciﬁed without template parameter .
The after the template function name means that this specialization is to be used in cases where the template argument is const .
Because the template argument can be deduced from the function argument list , we need not specify it explicitly .

So , we can simplify the deﬁnition of the specialization :

Given the preﬁx , the second empty is redundant , so we would typically simply write : Specialization Chapter .

Now that we have " to version that is semantically correct , we can consider what we might do for .
The is correct for our use and has already instead of the three potentially expensive copy operations , we improved performance for large number of argument types .

Specialization comes in handy when an irregularity of an argument type causes the general .

The " might look something like .

It is all generic programming : after all , we are just deﬁning and using generic types and algorithms .

Both of these positions are useless because they basically deﬁne generic programming and template metaprogramming as synonyms .
think there is useful distinction to be made .
distinction helps us decide between alternative approaches to problems and to focus on what is important for given problem .
When write generic type or algorithm , feel that am writing compiletime program .
am not using my programming skills for the part of my program .

Instead , am focusing on deﬁning requirements on arguments .
Generic programming is primarily design philosophy programming paradigm , if you must .

In contrast , metaprogramming is programming .
The emphasis is on computation , often involving selection and some form of iteration .
Metaprogramming is primarily set of implementation techniques .
can think of four levels of implementation complexity : Simple computation types or not using tests or iteration , for Computation using explicit tests , for example , if .

So , metaprogramming is combination of " and programming : metaprogram is computation yielding types or functions to be used at run time .
Note that say metaprogramming " because the computation may be done using constexpr functions .

Note also that you can rely on other metaprogramming without actually doing metaprogramming yourself : calling constexpr function hiding metaprogram or extracting the type from template type function is not in itself metaprogramming ; it just uses metaprogram .

Generic programming usually falls into the ﬁrst , computation " category , but it is quite possible to support generic programming using metaprogramming techniques .
When doing so , we have to be careful that our interface speciﬁcations are precisely deﬁned and correctly implemented .

Once we use as part of an interface , the possibility of programming errors creeps in .
Without programming , the meaning is directly deﬁned by the language rules .

Generic programming focuses on interface speciﬁcation , whereas metaprogramming is programming , usually with types as the values .

Overenthusiastic use of metaprogramming can lead to debugging problems and excessive compile times that render some uses unrealistic .
As ever , we hav to apply common sense .
There are many simple uses of metaprogramming that lead to better code type safety , lower memory footprint , and lower run without exceptional overhead .
Many components , such as function , thread , and tuple , are examples of relatively simple application of metaprogramming techniques .

This chapter explores the basic metaprogramming techniques and presents the basic building blocks of metaprograms .
Chapter offers more extensive example .

For example , is type function that given type argument returns the size of an object in chars ;

Type functions don ' hav to look like conventional functions .

For example , the standard takes its argument as template argument and returns its result as member called value : if .

function can take more than one argument and return several result values .
For example : Metaprogramming Chapter , int .

Type functions are functions .
That is , they can only take arguments and that are known at compile time and produce results and that can be used at compile time .

Most functions take at least one argument , but there are useful ones that .
For example , here is function that returns an integer of the appropriate number of bytes :

It is of course possible to write templates that take values only and produce values only .
don ' consider those functions .
Also , constexpr functions are usually better way of expressing computations on values .
can compute square root at compile time using templates , but why would want to when can express the algorithm more cleanly using constexpr functions ,

So , functions are mostly templates .
They can perform very general computations using types and values .
They are the backbone of metaprogramming .
For example , we might want to allocate an object on the stack provided that it is small and on the free store otherwise : constexpr int ; max size of object we want on the stack struct using typename .

If its ﬁrst argument evaluates to true , the result as the member is the second argument ; otherwise , the result is the third argument .
In this case , is deﬁned to be if an object of is small and .

The example is not hypothetical .
For example , the standard contains the following comment in its deﬁnition of the function for holding entities : are encouraged to avoid the use of dynamically allocated memory for small callable objects , for example , where ' target is an object holding only pointer or reference to an object and member function pointer "
It would be hard to follow that advice without something like .

How are Scoped and implemented .
Their implementations are trivial and do not involve any metaprogramming , but here they are :

This is consequence of the way the language is speciﬁed and used , this is the way template metaprogramming code has been written for the last years , and this is the way it appears in the standard .

It reminds me of the bad old days in , where every occurrence of had to be preﬁxed with the struct keyword .
By introducing template alias , we can hide the : implementation details and make function look much more like function returning like .

For example :

Except when explaining an implementation or what the standard speciﬁcally offers , use such aliases systematically .
When the standard provides function something like  property predicate " or category , such as  deﬁne corresponding alias : typename  typename using typename ; Please note that these aliases are unfortunately not part of the standard .

If only one of the alternatives is supposed to be valid  we should not use an alias .
Consider ﬁrst simple analogy : Section When Not to Use an Alias .

It is important that we enter the block if is the nullptr .
We are using the test to see if is valid .
Similarly , we might want to test to see if is valid .
For example :  Here , we test if is an integral the and make the unsigned variant of that if it is the .
If that succeeds , we have an unsigned  otherwise , we will have to deal with the indicator .

Had we written meaning typename : and tried to use it for nonintegral  say , we would have tried to make nonexistent .
The result would have been error .

In the rare cases where we use aliases consistently to hide , we can fall back on the more explicit , style .
Alternatively , we can introduce function to delay evaluation of function until its use :  The implementation of perfect function is nontrivial , but for many uses this will do : class  typename .
using ; This uses template template argument and variadic templates .

Independently of which solution we choose to avoid the undesired instantiation , this is the kind of expert territory that enter only with some trepidation .

If you want to write functions that take arguments that are types , it seems obvious that like to ask questions about the arguments ' types .

For example : Is this signed type .
Is this type polymorphic , does it have at least one virtual .
Is this type derived from that type .

The answers to many such questions are known to the compiler and exposed to the programmer through set of type predicates .
For example : Metaprogramming Chapter .

If not , we copy the objects one by one using their copy constructor .
We determine whether the template argument type is POD by the type predicate .
The result is presented by the member value .
This convention is similar to the way type functions present their result as member type .

The : predicate is one of the many provided by the standard library .
Since the rules for being POD are tricky , is most likely compiler intrinsic rather than implemented in the library as code .

Like the convention , the value causes verbosity and is departure from conventional notation that lets implementation details shine through : function returning bool should be called using .

Fortunately , the standard supports that for all type predicates .
Unfortunately , for reasons , this resolution is not available in the context of template argument .

For example :

In particular , is interpreted as the type of function taking no argument and returning an .

My solution is to add functions to provide the conventional notation in all contexts :

In addition , keep them in separate namespace .

We can deﬁne our own type predicates .
For example :

When we have to deﬁne such predicates , we have rather powerful techniques available .
For example , we can deﬁne type function to determine whether class has member of given name and of an appropriate type .

Naturally , type predicates with more than one argument can also be useful .
In particular , this is how we represent relations between two types , such as , and tible .

use constexpr functions to support the usual calling syntax for all of these functions .

In particular , this means that the condition must be constant expression .
Note the parentheses around ; without those , we would have gotten syntax error because the compiler would have interpreted the as the end of the template argument list .
For that reason , prefer to use rather than .
Also , sometimes use parentheses around conditions for readability .

trait is used to associate properties with type .
For example , the properties of an iterator are deﬁned by its :

You can see trait as type function with many results or as bundle of type functions .

The standard library provides , and , which confusingly are simple type functions .

Given for  we can talk about the and the of even though pointers hav members :

This is most useful and powerful technique ,

It often bundles otherwise weakly related type functions .

It exposes implementation details to users .

Also , people sometimes throw in type aliases in " leading to unneccesary complexity .

Consequently , prefer to use simple type functions : using typename ; using typename ; Section Traits using typename ; The example cleans up .

Also , auto and decltype are new , so older code could not have been written this way .

We need trait equivalent , such as to associate type with another type , such as with .
For that , trait an is indispensable for adding type names needed for generic programming or metaprogramming .
When trait is used simply to provide name for something that already has perfectly good name , such as for and for , the utility is less clear and the potential for confusion Control Structures To do general computation at compile time , we need selection and recursion .

If you want to choose among values , is sufﬁcient ; Metaprogramming Chapter and Select are for selecting types .
They are not simply equivalents to if and switch ev en though they can appear to be when they are used to choose among function objects ,

The template is part of the standard library , so we hav to implement it , but it illustrates an important technique : typename , typename .

If the condition is not true , the specialization for false is chosen and is deﬁned to be .
For example : typename : Obviously , the syntax leaves bit to be desired , but the underlying logic is beautiful .

Specialization is used to separate the general case from one or more specialized ones .

In this example , the primary template takes care of exactly half of the functionality , but that fraction can vary from nothing nonerroneous case is handled by specialization ; to all but single terminating case .
This form of selection is completely and cost byte or cycle at run time .

To improve the syntax , introduce alias : typename , typename using typename ; Given that , we can write : consider that signiﬁcant improvement .

Run Time Looking at something like .

On my implementation , got , and as the compiler optimizes away the empty base classes .
This is called the optimization and is guaranteed by the language .

For example : typename , typename , typename .

Unsurprisingly , the output is : Metaprogramming Chapter .

We would like to access those elements efﬁciently and without the possibility of type system violations , without using .
We can imagine variety of schemes , such as naming the elements , numbering the elements , and accessing elements by recursing though the elements until we reach desired element .
The last alternative is what we will to implement the most common access strategy : index the elements .
In particular , want to implement way to subscript .
Unfortunately , am unable to implement an appropriate , so function template .

The idea is to index the elements , starting from , in such way that the element selection is done at compile time and we preserve all type information .

The function constructs an object of type .
The job of is to return reference to the Nth element , which is assumed to have type .
Given such helper , we can .

Basically , is , implemented by recursing times .
The member functions are static because we really want any objects of class .
That class is only used as place to hold Ret and in way that allows the compiler to use them .

This is quite bit of scaffolding to index into  but at least the resulting code is and efﬁcient .
By " mean that given reasonably good compiler is , there is no overhead for accessing member .

Why must we write rather than just .

Unfortunately , this does not .

Inside , the argument is not known to be constant expression .

" that only lambdas can deduce their result type from their , but that could be handled by adding .

To that , we need some language lawyering and for now , we hav to make do with .

For example :  

The problem is that takes its argument by reference .
But is const , so it is not an acceptable argument .

Naturally , we also want to be able to have const Tuples .
For example : Metaprogramming Chapter .

Now , we can handle both const and arguments .

This implies that we can make type implicit in code by having function construct it for us : Section , typename , typename , typename .

For example , an errorreporting function may take between zero and ten arguments , matrix may have between one and ten dimensions , and tuple can have zero to ten elements .
Note that in the ﬁrst and the last example , the elements may not necessarily be of the same type .
In most cases , we would prefer not to deal with each case separately .
Ideally , single piece of code should handle the cases for one element , two elements , three elements , etc .
Also , pulled the number ten out of hat : ideally , there should be no ﬁxed upper limit on the number of elements .

Over the years , many solutions have been found .
For example , default arguments can be used to allow single function to accept variable number of arguments , and function overloading can be used to provide function for each number of arguments .
Passing single list of elements can be an alternative to having variable number of arguments as long as the elements are all of the same type .
However , to elegantly handle the case of an unknown number of arguments of unknown possibly types , some additional language support is needed .

That language feature is called variadic .

Consider the archetypical example of function needing an unknown number of arguments of variety of types :
As provided by the and standard libraries , is ﬂexible and performs nicely .
However , it is not extensible to types and not , and it is popular target for hackers .

The ﬁrst argument to is string interpreted as " Additional arguments are used as required by the format string .
Format speciﬁers , such as for ﬂoatingpoint and for arrays of characters , control the interpretation of the additional arguments .
For example : value of is ; Metaprogramming Chapter string .

The ﬁrst call of works as intended , but the second call has two problems : the format speciﬁcation refers to strings , and will not interpret the argument correctly .

Furthermore , there is no format and in general no direct way of printing values of types , such as Point .
In the third call of , provided an int as the argument for and " to provide an argument for .
In general , compiler is not able to compare the number and types of arguments required by the format string with the number and types of arguments provided by the programmer .
The output of that last call would not be pretty .

Using variadic templates , we can implement an extensible and variant of .
As is common for programming , the implementation has two parts : Handle the case where there is just one argument format .

The simplest case is the one with only one argument , the format .

That prints out the format string .
If format speciﬁer is found , this throws an exception because there is no argument to be formatted .
format speciﬁer is deﬁned to be not followed by another is ' notation for that does not start type .
Note that does not overﬂow even if is the last character in string .
In that case , refers to the terminating zero .

That done , we must handle with more arguments .
Here is where  and in particular variadic  comes into .

Ordinary characters , not formal are simply printed .

The overloading of replaces the use of the " in the format speciﬁer .
If an argument has type for which is deﬁned , that argument is printed ; otherwise , that call does not type check and the program will never run .
formatting character after is not used .
can imagine uses for such characters , but the purpose of this example is not to design the perfect but to explain variadic templates .

parameter pack is sequence of pairs from which you can off " arguments starting with the ﬁrst .
When is called with two or more arguments void  value 
In the call the parameter pack args is expanded so that the ﬁrst element of args is selected as value and args is one element shorter than in the previous call .
This carries on until args is empty , so that we call : void .

The standard library provides and , but hav to craft yourself .

If not , here are minimal technical examples that might help .
First , we can declare and use simple variadic template function :
void .

The type of each args function argument is the corresponding Types template argument .

The ellipsis is separate lexical token , so you can place whitespace before or after it .
That ellipsis can appear in many different places in the grammar , but it always means or more occurrences of .
Think of parameter pack as sequence of values for which the compiler has remembered the types .
For example , we could graphically represent parameter pack for :

used argument for the type of the " to be called , so that can accept functions , pointers to functions , function objects , and lambdas .

hav to be speciﬁc about which specialization of function to pass because cannot deduce which one to use from the types of the other arguments .

This section presents the deﬁnition of the ; and explains the techniques used to implement it .
The key difference between : and our simple Tuple is that the former uses variadic templates to remove the limitation on the number of elements .
Here are the key deﬁnitions : Head ,
class ,  private here is the recursion and derives from the of its tail rest of the .

Note that the type is encoded in the type , not stored as data typedef .

There is no guarantee that : is implemented as hinted here .
In fact , several popular implementations derive from helper class variadic class , so as to the element layout in memory to be the same as struct with the same member types .

The reference " type functions add reference to type if it isn ' reference already .

They are used to avoid copying .

Curiously , does not provide and functions , so made them private .
In fact , does not provide any member functions for accessing an element .
If you want to access an element of  you must or call function that splits it into value and .

It can tedious to mention all of those types .
Instead , we can deduce them from argument types , Section The for example , using the .

Every member of : is useful to someone and most are useful to many , but none adds to our understanding of variadic templates , so do not go into details .
There are constructors and assignments from the same type and , from other types and , and from pairs and .
The operations taking : argument use .
There are constructors and assignments taking allocators and .

Unfortunately , the standard library does not offer or for .
Worse , writing for : is amazingly complicated because there is no simple and general way of iterating through the elements of .
First we need helper ; it is struct with two functions .
One recurses through list printing elements , and the other stops the recursion when there is no more elements to print : print element and following elements struct .

The pattern is that of recursive function with terminating overload from .

We can now write for .

Providing input for such computations can be tricky , but we can always data into the program text .

However , prefer simpler examples that in my opinion stand better chance when it comes to maintenance .
Here , will show an example that provides reasonable tradeoff between implementation complexity and utility .
The compilation overhead is minimal and there is no overhead .
The example is to provide small library for computations using units , such as meters , kilograms , and seconds .
These MKS units are subset of the international standard units used universally in science .
The example is chosen to show how the simplest metaprogramming techniques can be used in combination with other language features and techniques .

We want to attach units to our values , so as to avoid meaningless computations .

Units provide type system for physical values .
As shown , we can use auto to hide types when we want to , literals to introduce typed values , and type for use when we want to be explicit about Units .

Meters for length .

Kilograms for mass .

Seconds for Note that the unit values are encoded in the type .

We can provide more conventional notation for the most common .

Negative unit values indicate division by quantity with that unit .
This representation of unit is very ﬂexible .
We can represent the proper unit of any computation involving  mass , and .
doubt we will ﬁnd much use for , that is , distances multiplied , divided by masses multiplied , and then multiplied by measurements multiplied but it is nice to know that the system is general .

When we multiply two quantities , their units are added .
Thus , addition of Units is useful : typename struct .

Now we can start thinking about computations .
What do we do to physical measurements .
' not going to review whole physics textbook , but certainly we need addition , subtraction , multiplication , and division .
You can only add and subtract values with the same units :

Similarly , division of Quantitys subtraction of their Units .
For example : typename .

Given these arithmetic operations , we can express most computations .
However , we ﬁnd that realworld computations contain fair number of scaling operations , that is , multiplications and divisions by dimensionless values .
We could use but that gets tedious : auto .

We needed the or the explicit double to ensure that the is double the correct result for the .

The code generated for the two examples should be identical , and we can do better still notationally .
We can introduce literals ; for the types : constexpr " return ;

However , we could also provide more of the conventional units as .

Obviously , this could really get out of control through overuse of nonstandard sufﬁxes , us is suspect even though it is widely used because looks bit like Greek .

could have provided the various magnitudes as more types is done for ; but thought it simpler to keep the types simple and focused on doing their primary task well .

Deﬁning is .

That basically shows how to write arbitrary computational functions .
could have constructed the right there in the return value deﬁnition , but using the existing function was easier .
Alternatively , we could easily have deﬁned function .

It is deﬁned for values of the same Units only :

Such code will , given reasonable compiler , generate exactly the same code as would have been generated using doubles directly .
Howev er , it is  checked " compile according to the rules for physical units .
It is an example of how we can add whole new of types with their own checking rules to program .

Introduction Basic Matrix Uses ; Matrix Requirements .

Matrix Template Construction and Assignment ; Subscripting and Slicing .

Matrix Arithmetic Operations Scalar Operations ; Addition ; Multiplication .

Matrix Implementation slice ; Matrix Slices ; Matrix List Initialization ; Matrix Access ; Matrix .

Solving Linear Equations Classical Gaussian Elimination ; Pivoting ; Testing ; Advice Introduction language feature in isolation is boring and useless .
This chapter demonstrates how features can be used in combination to address challenging design task : general matrix .

hav never seen perfect matrix class .
In fact , given the wide variety of uses of matrices , it is doubtful whether one could exist .
Here , present the programming and design techniques needed to write simple dense matrix .
If nothing else , this is far easier to use , and just as compact and fast , as anything programmer would have to write using vectors or builtin arrays directly .

As for vector , we use to specify sizes and to specify element values ,

The number rows must match the speciﬁed number of dimensions and the number of elements in .

Each dimension has number of elements deduced from the initializer list or speciﬁed as constructor argument using the notation .
The total number of elements is referred to .

Given that , prints :

dimensions , where is parameter that can vary from to many , without specialized code for every dimension .

storage is useful in general , so the element type can be anything we can store vector .

The mathematical operations should apply to any type that can reasonably be described as number , including .

subscripting using one index per dimension , for example , for  yielding an element .

subscripting , for example , yielding row row is an of an .

Subscripting should be potentially fast potentially range checked .

Move assignment move constructor to ensure efﬁcient passing of results to eliminate expensive temporaries .

Some mathematical matrix operations , such as +

way to read , write , pass around references to submatrices , for use for both reading writing elements .

The absence of resource leaks in the form of the basic guarantee .

Fused critical operations , for example , as single function call .

Introduction Facilities ; Design Constraints ; Description Style .

Language Support Support ; Support .

Error Handling Exceptions ; Assertions ;

Advice Introduction The standard library is the set of components speciﬁed by the ISO standard and shipped with identical behavior by every implementation .
For portability and longterm maintainability , strongly recommend using the standard library whenever feasible .
Maybe you can design and implement better alternative for your application ,

How easy will it be for some future maintainer to learn that alternative design .

How likely is the alternative to be available on yet unknown platform ten years from now .

How likely is the alternative to be useful for future applications .

How likely is it that your alternative will be interoperable with code written using the standard library .

How likely is it that you can spend as much effort optimizing and testing your alternative as was done for the standard library .

And , of course , if you use an alternative , you your will be responsible for the maintenance and evolution of the alternative " In general : try not to reinvent the wheel .

And that is without describing the ISO standard library , which is part of the standard library .
To compare , the language speciﬁcation is pages .
Here , summarize , relying heavily on tables , and give few examples .
Details can be found elsewhere , including online copies of the standard , complete online documentation of implementations , and you like to read open source implementations .
Rely on the references to the standard for complete details .

The chapters are not intended to be read in their order of presentation .
Each chapter and typically each major subsection can be read in isolation .
Rely on and the index if you encounter something unknown .

One ideal is for programmer to be able to ﬁnd ev ery interesting , signiﬁcant , and reasonably general class , function , template , in library .

However , the question here is not ought to be in some " but ought to be in the standard " is reasonable ﬁrst approximation to an answer to the former question but not to the latter .
standard library is something that every implementer must supply so that every programmer can rely on it .

Support for language features , such as memory management , the statement .

Information about aspects of the language , such as the largest ﬁnite .

Primitive operations that cannot be easily or efﬁciently implemented in the language .

Functions that most programmers cannot easily implement optimally and portably , such as .

Minimal support for reclamation of unused memory , such as .

Nonprimitive foundational facilities that programmer can rely on for portability , such as .

Frameworks for extending the facilities it provides , such as conventions and support facilities that allow user to provide of type in the style of for few facilities are provided by the standard library simply because it is conventional and useful to do so .
Examples are the standard mathematical functions , such as , random number generators , complex arithmetic , and regular expressions .

The standard library aims to be the common foundation for other libraries .
In particular , combinations of its facilities allow the standard library to play three supporting roles : Section Facilities .

foundation for portability .

set of compact and efﬁcient components that can be used as the foundation for libraries and applications .

set of components enabling communications The design of the library is primarily determined by these three roles .
These roles are closely related .
For example , portability is commonly an important design criterion for specialized library , and common container types such as lists and maps are essential for convenient communication between separately developed libraries .

The last role is especially important from design perspective because it helps limit the scope of the standard library and places constraints on its facilities .
For example , string and list facilities are provided in the standard library .
If they were not , separately developed libraries could communicate only by using types .
However , advanced linear algebra and graphics facilities are not provided .
Such facilities are obviously widely useful , but they are rarely directly involved in communication between separately developed libraries .

Unless facility is somehow needed to support these roles , it can be left to some library outside the standard .
For good and bad , leaving something out of the standard library opens the opportunity for different libraries to offer competing realizations of an idea .
Once library proves itself widely useful in variety of computing environments and application domains , it becomes candidate for the standard library .
The regular expression library is an example of this .

reduced standard library is available for freestanding implementations , that is , implementations running with minimal or no operating system support .

The facilities offered by the standard library are designed to .

Valuable and affordable to essentially every student and professional programmer , including the builders of other libraries .

Used directly or indirectly by every programmer for everything within the scope .

Efﬁcient enough to provide genuine alternatives to functions , classes , and templates in the implementation of further libraries .

Either policy free or with an option to supply policies as arguments .

Primitive in the mathematical sense .
That is , component that serves two weakly related roles will almost certainly suffer overhead compared to individual components designed to perform only single role .

Convenient , efﬁcient , and reasonably safe for common uses .

The standard library may leave major functions to other libraries , but if it takes on task , it must provide enough functionality so that individual users or implementers need not replace it to get the basic job done .

Easy to use with types and operations .

Type safe by default , and therefore in principle checkable at run time .

Supportive of commonly accepted programming styles .

Extensible to deal with types in ways similar to the way types and types are handled .

This is why the takes comparison function as an argument rather than relying on something ﬁxed , say , the operator .
On the other hand , the overhead imposed by function call for each comparison compromises as building block for further library building .
For almost every data type , it is easy to do comparison without imposing the overhead of function call .

However , the function call overhead can dominate the execution time for some algorithms and cause users to seek alternatives .
The technique described in of supplying comparison criteria through template argument solves that problem for and many other algorithms .
The sort example illustrates the tension between efﬁciency and generality .
It is also an example of how such tensions can be resolved .
standard library is not merely required to perform its tasks .
It must also perform them so efﬁciently that users are not tempted to supply their own alternatives to what the standard offers .

Otherwise , implementers of more advanced features are forced to bypass the standard library in order to remain competitive .
This would add burden to the library developer and seriously complicate the lives of users wanting to stay or to use several separately developed libraries .

The requirements of " and of common uses " can conﬂict .
The former requirement precludes exclusively optimizing the standard library for common cases .
Howev er , components serving common , but nonprimitive , needs can be included in the standard library in addition to the primitive facilities , rather than as replacements .
The cult of orthogonality must not prevent us from making life convenient for the novice and the casual user .
Nor should it cause us to leave the default behavior of component obscure or dangerous .

Consequently , use an extremely abbreviated style of presentation .
Sets of related operations are typically presented in tables : Some Operations op does something to the range and , returning foo does something to but returns no result Does have something to do with .

try to be mnemonic when choosing identiﬁers , so and will be iterators specifying range , pointer or an iterator , and some value , all depending on context .
In this notation , only the commentary distinguishes no result from Boolean result , so you can confuse those if you try hard enough .
For an operation returning Boolean , the explanation usually ends with question mark .

Where an algorithm follows the usual pattern of returning the end of an input sequence to indicate " etc .

Usually , such an abbreviated description is accompanied with reference to the ISO standard , some further explanation , and examples .

The headers identify the major parts of the library .
Thus , listing them gives an overview of the library .

The rest of this subsection is list of headers grouped by function , accompanied by brief explanations and annotated by references to where they are discussed .
The grouping is chosen to match the organization of the standard .

standard header with name starting with the letter c is equivalent to header in the standard library .
For every header deﬁning part of the standard library in the global namespace and also in namespace std , there is header deﬁning the same names .
Ideally , the names from header do not pollute the global namespace , but unfortunately to complexities of maintaining multilanguage , most do .

Containers resizable array queue list list Associative array Set Hashed associative array Hashed set Queue Stack array Array of bool The associative containers multimap and multiset can be found in and , respectively .

The is declared in .

General Utilities Operators and pairs , Tuples Type traits Use as key or hash code Function objects Resource management pointers Scoped allocators rational arithmetic Time utilities date and time Iterators and iterator support Iterators provide the mechanism to make standard algorithms generic ,

The standard library functions and apply to arrays with elements of types without copy constructors and destructors only .

Diagnostics Exception class Standard exceptions Assert macro error handling System error support Assertions using exceptions are described in .

Strings and Characters String of Chapter Character classiﬁcation classiﬁcation string functions string functions allocation functions multibyte characters Regular expression matching Chapter header declares the , family of functions .

Forward declarations of facilities Standard iostream objects and operations iostream bases Stream buffers Input stream template Output stream template Manipulators Streams strings Character classiﬁcation functions Streams ﬁles family of of wide characters Manipulators are objects used to manipulate the state of stream .

Language Support Numeric limits numeric macros numeric limit macros Standard integer type names Dynamic memory management type identiﬁcation support support initializ library language support function argument lists stack unwinding Program termination System clock signal handling The header deﬁnes the type of values returned by , the type of the result of pointer subtraction and of array subscripts , and the infamous NULL macro .

stack unwinding setjmp and longjmp from is incompatible with the use of destructors and with exception handling , and is best avoided .
stack unwinding and signals are not discussed in this book .

Numerics Complex numbers and operations Numeric vectors and operations Generalized numeric operations Standard mathematical functions random numbers Random number generators For historical reasons , and are found rather than with the rest of the mathematical functions .

The standard library provides access to all such facilities : Compatibility Aliases for common integer types bool environment alignment generic : and The header will not deﬁne macros bool , true , or false .
The header will not deﬁne macro alignas .
The equivalents to , and approximate facilities for .
Av oid them if you can .

The header provides types as and , status ﬂags , and control modes describing an environment .

user or library implementer is not allowed to add or subtract declarations from the standard headers .
Nor is it acceptable to try to change the contents of header by deﬁning macros to change the meaning of declarations header .
Any program or implementation that plays such games does not conform to the standard , and programs that rely on such tricks are not portable .

Even if they work today , the next release of any part of an implementation may break them .
Av oid such trickery .

For facility to be used , its header must be included .
Writing out the relevant declarations yourself is not alternative .
The reason is that some implementations optimize compilation based on standard header inclusion , and others provide optimized implementations of facilities triggered by the headers .
In general , implementers use standard headers ways programmers cannot predict and hav to know about .

programmer can , however , specialize utility templates , such as , for , types .

In , we ﬁnd : class .

Naturally , an can also be used by .
For example : Overview Chapter .

All containers , vector strings support iteration using ; container adaptors as stack do not .
The container headers , such as , so the user rarely has to do so directly .

Thus , their style approaches to error handling are not .

libraries consist of functions , many of which set errno to indicate that an error happened ; see .

Many algorithms operating on sequence of elements return an to the element to indicate found " or ; see .

The streams library relies on state in each stream to reﬂect errors may the user requests throw exceptions to indicate errors ; see .

Some components , such as vector , string , bitset , throw exceptions to indicate errors .

The standard library is designed so that all facilities obey basic guarantee " that is , ev en if an exception is thrown , no resource as is leaked no invariant for class is broken .

For example , will throw an exception if the function it is required to execute throws .

Unless you know that no facility is used in way that could throw an exception , it is good idea to always catch one of the root classes of the exception hierarchy as as well as any exception somewhere , for example , in .

Instead , throw objects of types speciﬁcally deﬁned to be used as exceptions .

This hierarchy of standard exception classes provides classiﬁcation of exceptions : exception out_of_range This hierarchy attempts to provide framework for exceptions beyond the ones deﬁned by the standard library .
Logic errors are errors that in principle could be caught either before the program starts executing or by tests of arguments to functions and constructors .
errors are all other errors .

Not all exceptions are part of the exception hierarchy .
Howev er , all exceptions thrown by the standard library are from the exception hierarchy .

Unless you know that no facility is used in way that could throw an exception , it is good idea to somewhere catch all exceptions .

the exception pointed to by  is an to exception ; noexcept An can point to any exception , not just exceptions from the exception hierarchy .

Think of as smart pointer that keeps its exception alive for as long as an points to it .
That way , we can pass an to an exception out of function that caught it and elsewhere .
In particular , an can be used to implement of an exception in different thread from the one in which the exception was caught .
This is what promise and future rely on .
Use of on an different does not introduce data race .

Default constructor : holds an to the ; noexcept ; Copy constructor : both and hold an to the stored exception Copy assignment : both and hold an to the stored exception Destructor ; virtual .

An exception cannot propagate out of noexcept function .

In , the standard library provides facilities for dealing with unexpected exceptions : Section .

Terminate the program ; noreturn ; noexcept Has an exception been thrown on the current thread and not yet been caught .
call of terminates program by calling terminate handler set by call of .
The almost always correct default is to immediately terminate the program .
For fundamental operating system reasons , it is whether destructors for local objects are invoked when is called .
If is invoked as the result of noexcept violation , the system is allowed optimizations that imply that the stack may even be partially unwound .

It is sometimes claimed that can be useful for writing destructors that behave differently depending on whether function is exited normally or by an exception .
Howev er , is also true during stack unwinding after the initial exception has been caught .
consider too subtle for practical use .

The is macro found in .
The error message produced by is but should contain the source ﬁle name , and the source line number containing the .

Asserts are they should used more frequently in production code than in small illustrative textbook examples .

It can be serious mistake to assume that the is evaluated when it is not .
For example , given usual compiler setup , will catch an error during debugging , but not in the ﬁnal shipped product .

For way to manage assertions , see .

For example , we may write function to check ﬁle name and then open ﬁle like .

Assuming that system " know about exceptions , we have no choice about whether to deal with error codes or not ; the only questions are " and " In , the standard library provides facilities for classifying error codes , for mapping systemspeciﬁc error codes into more portable ones , and for mapping error codes into exceptions : System Error Types Holds value identifying an error and the category of that error ; base class for types used to identify the source and encoding Holds value identifying an error and the category of that error ; errc enum class with enumerators for error codes ; basically POSIX error codes Section Error Codes Error Codes When an error up " lower level as an error code , we must handle the error it represents or turn it into an exception .
But ﬁrst we must classify it : different systems use different error codes for the same problem , and different systems simply have different kinds of errors .

For type representing the simple idea of an error code , provides lot of members .
It is basically as simple map an integer to pointer to an : Overview Chapter class public : representation : of type ; An is an interface to an object of class derived .

The reason is is deﬁned in terms of equivalence , taking both the error and the error into account .

The operations on are .
In some cases , can be mapped into using the mechanisms described in .

An typically contains less information than an , so it is usually good idea to keep the available and only extract its when needed .

Manipulating does not change the of errno ,
The standard library leaves the error states provided other libraries unchanged .

Speciﬁc errors are represented class derived class : class public :

Access an through pointers or references .

There are four named categories : is reference to an .

For example , means not permitted " in POSIX , is generic code for all errors as an iostream error , and means already retrieved " as future error .

It passes along an and optionally an string : class  public public :

Naturally , can be used code is not part of the standard library .
is passed , rather than potentially portable .

The general idea is each system has set of speciﬁc codes are mapped into the potentially portable ones for the convenience of programmers of programs need to work on multiple platforms .

For example : enum class , The meaning of these values is completely .
The integer values of these enumerators are .

The future error is part of the standard , so you can ﬁnd it in your standard library .
The details are likely to differ from describe .

Next , we need to deﬁne suitable for our error codes : class 

For example , an argument intended to become the of an of must be .

For to work for our  we must repeat we did for .
For example : noexcept ; struct  public ; For more interesting design , we could use separate enum for the and have implement mapping from to that .

For systems supporting facilities , they are also valid for the " category :

The POSIX macros are integers whereas the errc enumerators are of type errc .

Container Overview Container Representation ; Element Requirements .

Operations Overview Member Types ; Constructors , Destructor , and Assignments ; Size and Capacity ; Iterators ; Element Access ; Stack Operations ; List Operations ; Other Operations .

Containers vector ; Lists ; Associative Containers .

Container Adaptors stack ; queue ;

Advice Introduction The STL consists of the iterator , container , algorithm , and function object parts of the standard library .
The rest of the STL is presented in Chapter and Chapter .

This section summarizes the types of containers and brieﬂy outlines their properties .
Operations on containers are summarized in .

Sequence containers provide access to sequences of elements .

Associative containers provide associative lookup based on key .

In addition , the standard library provides types of objects that hold elements while not offering all of the facilities of sequence containers or associative .

Container adaptors provide specialized access to underlying containers .

Almost containers are sequences of elements that provide most , but not all , of the facilities of container .

The STL containers sequence and associative are all resource handles with copy and move operations .
All operations on containers provide the basic guarantee to ensure that they interact properly with error handling .

Sequence Containers contiguously allocated sequence of Ts ; the default choice of container list of ; use when you need to insert and delete elements without moving existing elements list of ; ideal for empty very short sequences queue of ; cross between vector list ; slower than one or the other for most uses The template argument is the that the container uses to acquire release memory ,
For example : typename .

These containers are deﬁned in ,
The sequence containers are contiguously allocated , or linked lists , of of their in the notation used .

Unless you have solid reason not to , use vector .
Note that vector provides operations for inserting erasing  allowing vector to grow shrink as needed .
For sequences of small  vector can be an excellent representation for data structure requiring list operations .

When inserting erasing of vector , may be moved .
In contrast , of list or an associative container do not move when are inserted or other are erased .

An empty takes up only one word .
There are surprisingly many uses for lists where most are empty the rest are very .

The default ordering criterion for key , is .

As for sequence containers , the template argument is the that the container uses to acquire release memory ,
The template argument is defaulted to for maps for sets .

is the hash function type ; is the equality test ; is the type An unordered map from to An unordered map from to ; duplicate keys allowed An unordered set of An unordered set of ; duplicate keys allowed These containers are implemented as hash tables with linked overﬂow .
The default hash function type , for type is .
The default for the equality function type , for type is ; the equality function is used to decide whether two objects with the same hash code are equal .

The associative containers are linked structures with nodes of their the notation used above , for maps for .
The sequence of set , map , or multimap is ordered by its key value .
An unordered container need not have an ordering relation for its , uses hash function instead .
The sequence of an unordered container does not have guaranteed order .

Container adaptors are containers providing specialized interfaces to other containers : Container Adaptors is the container type Priority queue of Ts ; Cmp is the priority function type The default for priority function , Cmp , is .
The default for the container type , is for queue for stack .

Some data types provide much of what is required of standard container , but not all .
We sometimes refer to those as " The most interesting of those are : STL Containers Chapter array : contiguous of type ; no siz or other member functions array of contiguous of type ; like the array , but with most problems solved contiguously allocated sequence of characters of type with text manipulation operations , concatenation ; is typically optimized not to require free store for string wstring numerical vector with vector operations , but with restrictions to encourage implementations ; use only if you do lot of vector arithmetic set of bits with set operations , such as specialization of with compactly stored bits For , is the Tr is the character traits .

Prefer container , such as vector , string , or array , over an array when you have choice .
The implicit conversion the need to remember the size for array are major sources of errors , see .

Prefer the standard strings to other strings to strings .
The pointer semantics of Cstyle strings imply an awkward notation extra work for the programmer , they are major source of errors as memory .

Instead , the standard speciﬁes the container interfaces some complexity requirements .
Implementers will choose appropriate often cleverly optimized implementations to meet the general requirements common uses .
In addition to what is needed to manipulate elements , such " will hold an allocator .

For vector , the element data structure is most likely an array : rep elements free space vector : The vector will hold pointer to an array of elements , the number of elements , the capacity number of allocated , currently unused or equivalent .

Like vector , string can grow into space " allocated to avoid repeated reallocations : rep string : characters free space Like array , an array is simply sequence of elements , with no handle : elements array : This implies that local array does not use any free store it is allocated and that an array member of class does not imply any free store operations .

If container copies an element using copy constructor or copy assignment , the result of the copy must be an equivalent object .
This roughly means that any test for equality that you can devise on the value of the objects must deem the copy equal to the original .
In other words , copying an element must work much like an ordinary copy of an int .
Similarly , move constructor and move assignment must have the conventional deﬁnitions and move semantics .
In addition , it must be possible to elements with the usual semantics .
If type has copy or move , the will work .

The details of the element requirements are scattered over the standard and quite hard to read , but basically container can hold elements of type that will work as long as the requirements for being container element are met as well as the speciﬁc requirements as elements being ordered ;

Some violations of the rules for standard containers can be detected by compiler , but others cannot and might then cause unexpected behavior .
For example , an assignment operation that throws an exception might leave partially copied element behind .
That would be bad design and would violate the rules of the standard by not providing the basic guarantee .

An element in an invalid state could cause serious trouble later .

When copying objects is not reasonable , an alternative is to put pointers to objects into containers instead of the objects themselves .
The most obvious example is polymorphic types ,
For example , we use or rather than to preserve polymorphic behavior .

So do many operations that can be applied to containers , and .
By default , the operator is used to deﬁne the order .
If is not suitable , the programmer must provide an alternative ,
The ordering criterion must deﬁne strict weak ordering .
Informally , this means that both and equality must be transitive .
That is , for an ordering criterion cmp of it as we require : Irreﬂexivity : is false .

Transitivity of equivalence : Deﬁne to be .

The last rule is the one that allows us to deﬁne equality as if we .

For example , we might decide to sort fruit using comparison that case sensitive .
We do that by deﬁning function object , that does the comparison when invoked for pair of strings : class Nocase .

Thus , associative containers will not work as most people would expect them to if strings are used as keys .
To make them work properly , operation that compares based on lexicographical order must be used .

When the default right , programmer can supply comparison criterion .
However , no mechanism is provided for also passing an equality test .
Instead , when programmer supplies comparison cmp , equality is tested using two comparisons .
For example : not done where the user supplied comparison if done where the user supplied comparison cmp This saves the user from having to provide an equality operation for every type used as the value type for an associative container or by an algorithm using comparison .
It may look expensive , but the library check for equality very often , in about of the cases only single call of is needed , often the compiler can optimize away the double check .

Using an equivalence relationship deﬁned by rather than equality also has practical uses .
For example , associative containers compare keys using an equivalence test .
This implies that equivalent keys not be equal .

For example , multimap that uses comparison as its comparison criterion will consider the strings Last , last , lAst , laSt , lasT equivalent , even for strings deems them different .
This allows us to ignore differences we consider insigniﬁcant when sorting .

The standard library deﬁnes them in the namespace presents them in .

question mark indicates simpliﬁcation : have included operations that are provided for only some of the containers .
In particular : STL Containers Chapter .

associative container set does not .

does not , instead , it provides the operations .

does not ,

associative container does not ,

The operations are replicated simply to reduce the number of arrows .

The bucket interface is described in .

Where meaningful , an access operation exists in two versions : one for const one for nonconst objects .

The operations have complexity guarantees : Standard Container Operation Complexity List Front Back Iterators vector const Ran list const const const Bi const const For deque const const const Ran stack const queue const const .

Bi multimap Bi set Bi multiset Bi For For For For string const Ran array const Ran array const Ran valarray const Ran bitset const " operations refer to insertion and deletion before the ﬁrst element .
Similarly , operations refer to insertion and deletion after the last element , and " operations refer to insertion and deletion not necessarily at the ends of container .

In the Iterators column , means " means " and " means iterator "

const entry means the operation takes an amount of time that does not depend on the number of elements in the container ; another conventional notation for constant time is .
means the operation takes time proportional to the number of elements involved .
+ sufﬁx indicates that occasionally signiﬁcant extra cost is incurred .
For example , inserting an element into list has ﬁxed cost it is listed as , whereas the same operation on vector involves moving the elements following the insertion point it is listed as .
Occasionally , all elements of vector must be relocated added .
The " notation is conventional .
added the + for the beneﬁt of programmers who care about predictability in addition to average performance .
conventional term for is amortized linear time .

Naturally , if constant is large , it can dwarf small cost proportional to the number of ele and to mean " For even moderately large values of , where log is the binary logarithm , is far closer to constant time than to .
For example : Logarithm Examples People who care about cost must take closer look .
In particular , they must understand what elements are counted to get the .
Howev er , the message is clear : mess with quadratic algorithms for larger values of .

The measures of complexity and cost are upper bounds .
The measures exist to give users some guidance as to what they can expect from implementations .
Naturally , implementers will try to do better in important cases .

Note that the " complexity measures are asymptotic ; that is , it could require lot of elements before complexity differences matter .
Other factors , such as the cost of an individual operation on an element , may dominate .
For example , traversing vector and list both have complexity .
Howev er , giv en modern machine architectures , getting to the next element through link can be very much more expensive than getting to the next element of vector the elements are .
Similarly , linear algorithm may take signiﬁcantly more or signiﬁcantly less than ten times as long for ten times as many elements because of the details of memory and processor architecture .
just trust your intuition about cost and your complexity measures ; measure .
Fortunately , the container interfaces are so similar that comparisons are easy to code .

The operation is constant time for all operations .
Note that does not have , so if you want to know the number of elements , you must count them yourself the cost of .
is optimized for space and does not store its size or pointer to its last element .

The string estimates are for longer strings .
The string optimization " makes all operations of short strings , less than constant time .

The entries for stack and queue reﬂect the cost for the default implementation using deque as the underlying container ,

However , they provide types that are not meaningful .
For example , array does not have an and vector does not have .

For container called , or we hav : is container ; by default , uses the default allocator c ; Default constructor : c is an empty container .

; Initialize c with copies of ; use allocator ; not for associative containers Section Constructors , Destructor , and Assignments is container ; by default , uses the default allocator c .

Initialize with elements from ; use allocator Destructor : destroy elements and release all resources Copy assignment : copy elements into .

Assign to from Additional constructors for associative containers are described in .

Note that an assignment does not copy or move allocators .
target container gets new of but retains its old container , which it uses to allocate space for the new .

Remember that constructor or an element copy may throw an exception to indicate that it cannot perform its tasks .

The potential ambiguities for initializers are discussed in and .

Use for size initializers and for every other kind of iterator .

Containers are often large , so we almost always pass them by reference .
However , because they are resource handles , we can return them using efﬁciently .
Similarly , we can move them as arguments when we want aliasing .
For example : STL Containers Chapter .

Erase all of When changing the size or the capacity , the may be moved to new locations .
That implies that iterators pointers and to may become invalid , point to the old element .
For an example , see .

An iterator to an element of an associative container , is only invalidated if the element to which it points is removed from the container ;
To contrast , an iterator to an element of sequence container , is inv alidated if the are relocated , by , or or if the element to which it points is moved within the container , by an or of an element with lower .

It is tempting to assume that improves performance , but the standard growth strategies for are so effective that performance is rarely good reason to use .

Instead , see as way of increasing the predictability of performance and for avoiding invalidation of iterators .

For an associative container , the order is based on the containers comparison criterion default : Iterators points to ﬁrst element of .

The simplest way of doing that is by which implicitly uses and .
For example : When we need to know the position of an element in container or if we need to refer to more than .

Where such issues are important , examine your implementations .

The associative containers map and have and that take arguments of the key type , rather than positions .

If we run out of memory or copy constructor throws an exception , fails .
failed has no effect on the container : the strong guarantee is offered .

Note that does not return value .
Had it done so , copy constructor throwing an exception could seriously complicate the implementation .

In addition , list and deque provide the equivalent operations on the start of their sequences .

The is perennial favorite for growing container without preallocation or chance of overﬂow , but can be used similarly .

Add elements from before .

Erase of c Erase all elements of c For functions , the result ,  points to the last inserted .
For functions , points to the that followed the last erased .

For containers with contiguous allocation , such as and deque , inserting and erasing an can cause elements to be moved .
An iterator pointing to moved becomes invalid .
An is moved if its position is after the point or if all elements are moved because the new exceeds the previous capacity .

The does not provide operations , such as , that operate before an identiﬁed by an iterator .
Such an operation could not be implemented because there is no general way of STL Containers Chapter ﬁnding the previous in given only an iterator .
Instead , provides operations , such as , that operate after an identiﬁed by an iterator .
Similarly , unordered containers use to provide hint rather than "

When comparing containers with an operator , the elements are compared using the equivalent operator generated or , is done using .

The operations exchange both elements and allocators .

If your suggested alternative is or array , think twice .

However , giv en the importance of  this section takes second look with more emphasis on how the operations are provided .

The template argument and member types are deﬁned like this : typename class .

The standard does not specify by how much capacity is increased when it is exceeded , but adding half the is common .
used to be careful about using reser when was reading into .

was surprised to ﬁnd that for essentially all of my uses , calling reser did not measurably affect performance .
The default growth strategy worked just as well as my estimates , so stopped trying to improve performance using reser .
Instead , use it to increase predictability of reallocation delays and to prevent invalidation of pointers and iterators .

The notion of capacity allows for iterators into to be valid unless reallocation actually happens .
Consider reading letters into buffer and keeping track of word boundaries : chars ; input " for characters constexpr int .

Had not used here , the pointers in words would have been invalidated if caused relocation .
By " mean that any use of those pointers would be undeﬁned behavior .
They may or may not point to an  but almost certainly not to the elements they pointed to before the relocation .

The ability to grow using and related operations implies that Cstyle use of and is as unnecessary as it is tedious and .

The elements of are compactly stored : there is no memory overhead .

The amount of memory consumed by vec of type is roughly .

The is about bytes , which is insigniﬁcant for larger vectors .

Traversal of is very fast .
To get to the next element , the code does not have to indirect through  and modern machines are optimized for consecutive access through structure .
This makes linear scans of elements , as in and , close to optimal .

This is what makes many algorithms on vectors , such as and , efﬁcient .

It is easy to underestimate these beneﬁts .
For example , list , such as list , usually incurs memory overhead links plus allocation , and traversing it can easily be an order of magnitude more expensive than traversing containing equivalent data .
The effect can be so spectacular and surprising that suggest you test it yourself .

Consider how to represent matrix .
There are two obvious .

of vectors : accessed by double subscripting :

speciﬁc matrix type , that stores elements contiguously The memory layout for looks like this : The memory layout for looks like this : To construct the , we need four constructor calls with four allocation operations .
To access an element , we need to do double indirection .

To construct the , we need one constructor call with one allocation .

To access an element , we need single indirection .

Once we reach an element of row , we need further indirection to access its successor , so access to the is not always twice as costly as access to .

However , for algorithms that require high performance , the allocation , deallocation , access costs implied by the linked structure of could be problem .

The solution implies the possiblity of the row having different sizes .

There are cases where that is an advantage , but more often it is simply an opportunity for errors burden for testing .

The problems overhead get worse when we need higher dimensions : compare the number of added indirections allocations for .

In summary , note that the importance of compactness of data structures is often underestimated or compromised .
The advantages are logical as well as performance related .
Combine this with tendency to overuse pointers new we have widespread problem .
For example , consider the development complexities , costs , memory costs , opportunities for errors in an implementation of structure when the rows are implemented as independent objects on the free store :

This is what allows it to be resized enables efﬁcient move semantics .
However , that occasionally puts it at disadvantage compared to data structures as arrays that do not rely on storing elements separately from handle .
Keeping sequence of elements on the stack or in another object can give performance advantage , just as it can be disadvantage .

deals with properly initialized objects .
This is what allows us to use them simply rely on proper destruction of elements .
However , that occasionally puts it at disadvantage compared to data structures as arrays that allow uninitialized elements .

As an example , we need not initialize elements before reading into .

is general mechanism for storing values .
It makes no assumptions about the relationships among the values stored in it .
To , the string Hello , World .
Sorting them into by makes sense .
To contrast , string is intended to hold character sequences .
The relationships among the characters are assumed to be important .
So , for example , we rarely sort the characters in string because that destroys meaning .
Some string operations reﬂect that , that Cstyle strings are .
The implementations of string reﬂect assumptions about the way we use strings .
For example , the optimization would be pure pessimization if it for the fact that we use many short strings , so that minimizing use becomes worthwhile .

suspect not , but it would require massive empirical study to be sure .

When you insert into list or delete an element from list , the locations of other elements of the list are not affected .
In particular , iterators referring to other elements are not affected .

If necessary , use similar operations to navigate lists .
list can be traversed using iterators : list provides bidirectional iterators provides forward iterators the name of that type of .

By default , list elements are individually allocated in memory include predecessor successor pointers .
Compared to vector , list uses more memory per element at least four words more per , traversals are signiﬁcantly slower because they involve indirection through pointers rather than simple consecutive access .

is list .
Think of it as data structure optimized for empty or very short lists that you typically traverse starting from the beginning .
For compactness , even provide ; an empty takes up just one word of memory .
If you need to know the number of elements of , just count them .
If there are enough elements to make counting them expensive , maybe you should use different container .

With the exception of subscripting , capacity management , for , the STL lists provide the member types operations offered by vector .
In addition , list provide speciﬁc list member functions : Add to lst copy or before the ﬁrst element .

Sort lst as the order Reverse the order of the elements of lst ; noexcept As opposed to the general algorithms , the member algorithms really .

The algorithm is stable ; that is , equivalent elements keep their relative order .

Insert the elements from before  the elements are removed from .

Splice in after  remove from Splice in after  remove from These operations are all stable ; that is , they preserve the relative order of elements that have equivalent values .

They come in two .

Ordered associative containers do lookup based on an ordering criterion , by default .
They are implemented as balanced binary trees , usually trees .

Unordered associative containers do lookup based on hash function .
They are implemented as hash tables with linked overﬂow .

Finally , maps and sets , whether ordered or unordered , come in two .

Internally , map and an are very different .
See for graphical representations .
In particular , map uses its comparison criterion on key to search through balanced tree , whereas applies hash function on key to ﬁnd slot in hash table operation for good hash .

If  is not found by subscript operation , default value is inserted .
For example : dictionary ; body of ; inser or assign to cout ; read value If seal is not in the dictionary , nothing is printed : the empty string was entered as the value for seal and returned as the result of the lookup .

The notation is rather verbose .
Instead , we could use : Depending on the quality of the optimizer , this may also be more efﬁcient .

If you try to insert into and there already is an with its  the is unchanged .
If you want to have more than one for single  use .

You can print the of all elements with the " in like this : mm ,

However , that would imply an extra traversal of the .
The , and are also provided for sorted sequences .

tend to think of set as with no separate .

try to modify  if you were to succeed , the underlying mechanism for ﬁnding elements would break .

For simple uses , there are few differences from containers because the associative containers share most operations .

In particular , there is no guarantee that elements are printed in the order of their insertion .

By default , an uses for hashing and to compare keys .

The general template hash hav deﬁnition .
It is up to users of type to deﬁne if needed .
For common types , such as string , standard hash specializations are provided , so the user need not provide them : Types with Supplied by the Standard Library string wstring string bool characters integers types pointers hash function , specialization of hash for type or to must be callable with an argument of type and return .
Two calls of hash function for the same must give the same result , and ideally such results are uniformly distributed over the of values so as to minimize the chances that if .

There is potentially bewildering of combinations of template argument types , constructors , and defaults for an unordered container .
Fortunately , there is pattern : Construct with buckets , the hash function hf , the equality function .

Here , is an element count for an otherwise empty .

The number of elements will be then number of elements in ,

The number of elements in the will be the number of elements in the initializer list .

Finally , has copy and move constructors , and also equivalent constructors that supply allocators : Copy and move constructors : construct from ; Default construct and give it allocator ; explicit ; Construct from and give it allocator .

Try something like : um ; OK and Equality Functions Naturally , user can deﬁne hash function .

Different techniques serve different needs .
Here , present several versions , starting with the most explicit and ending with the simplest .
Consider simple Record .

used decltype to avoid having to explicitly repeat the types of hf and eq .

If we hav an initializer list handy , we can give an initial instead : That also makes it bit easier to focus on the and equality operations .

If we wanted to avoid separating the deﬁnitions of hf and eq from their point of use , we could try lambdas :

The point about using or lambdas instead of functions is that they can be deﬁned locally in  next to their use .

However , here , may incur overhead that would prefer to avoid if the was heavily used .
Also , consider that version messy and prefer to the lambdas : auto return ; auto , const return .

The default and hashes obtained from it by using are often pretty good .
rush to use homemade functions without experimentation .

Keys with the same value are said to be the same bucket "
programmer can examine and set the of the table as number of : is .

For example , if the is elements and the is , the is .

Note that setting the , calling , or calling can be very expensive operations case because they can and in realistic scenarios typically do cause .

One use for the bucket interface is to allow experimentation with functions : poor will lead to large for some key values .
That is , it will lead to many keys being mapped to the same value .

Container adaptors are intended to be used only through their specialized interfaces .
In particular , the STL container adaptors do not offer direct access to their underlying container .
They do not offer iterators or subscripting .

The techniques used to create container adaptor from container are generally useful for nonintrusively adapting the interface of class to the needs of its users .

It can be described by partial implementation : typename class stack .

That is , is an interface to container of the type passed to it as template argument .
eliminates the operations on its container from the interface , and provides the conventional names : and .

In addition , provides the usual comparison , and nonmember .

Elements are added to using on the underlying container .
Consequently , cannot " as long as there is memory available on the machine for the container to acquire .
On the other hand , can .

By default , relies on the allocator from its underlying container .
If not enough , there are handful of constructors for supplying another .

The declaration of is much like the declaration of with additions to deal with comparison object and couple of constructors initializing from sequence : typename , typename class .

The order in which elements with equal come to the head of the is not deﬁned .

Tw elements are considered of equal if neither has higher than the other .

Keeping elements in order free , but it be expensive either .
One useful way of implementing is to use tree structure to keep track of the relative positions of elements .
This gives an cost of both and .
is almost certainly implemented using heap .

Algorithms Sequences ; Policy Arguments ; Complexity .

Nonmodifying Sequence Algorithms .

Modifying Sequence Algorithms ; and ; and ; Permuta .

Sorting and Searching .

Min and Max .

Advice Introduction This chapter presents the STL algorithms .
The STL consists of the iterator , container , algorithm , and function object parts of the standard library .
The rest of the STL is presented in Chapter and Chapter .

They operate on sequences deﬁned by pair of iterators or single iterator .
When copying , comparing , two sequences , the ﬁrst is represented by pair of iterators , but the second by just single STL Algorithms Chapter iterator , which is considered the start of sequence holding sufﬁcient elements for the algorithm , for example , as many elements as the ﬁrst sequence :
Some algorithms , such as , require iterators , whereas many , such as , only read their elements in order so that they can make do with forward iterator .
Many algorithms follow the usual convention of returning the end of sequence to represent found "
mention that for each algorithm .

Algorithms , both the algorithms and the users ' own ones , are .

Each names speciﬁc operation , documents an interface , and speciﬁes semantics .

Each can be widely used and known by many programmers .

For correctness , maintainability , and performance , these can be immense advantages compared to code " with less functions and dependencies .
If you ﬁnd yourself writing piece of code with several loops , local variables that seem to relate to each other , or complicated control structures , consider if the code could be simpliﬁed by making part into with descriptive name , purpose , interface , and welldeﬁned dependencies .

Numerical algorithms in the style of the STL algorithms are presented in .

The interfaces are good , but not perfect , approximation to that ideal .
For example , an interface does not directly represent the notion of sequence , leading to the possibility of confusion and difﬁculties in detecting some range .

However , the container versions are also less general than the versions that use iterators directly .
In particular , you cannot use the container to sort half container , and you cannot use the container to write to an output stream .

complementary approach is to deﬁne " or " abstraction that allows us to iterators .
That is , there is no class holding data exactly as there is no class or Container class in the STL .
So , in the " and " examples , called the template argument Cont , but they will accept any sequence with and an that meets the rest of the requirements for the algorithm .

The containers mostly return iterators .
In particular , they do not return containers of results in few rare examples ,
One reason for that is that when the STL was designed , there was no direct support for move semantics .
So , there was no obvious and efﬁcient way to return lot of data from an algorithm .
Some programmers used explicit indirection , pointer , reference , or or some clever trickery .
Today , we can do better : Cont , typename .

If the choice of seems restrictive or insufﬁcient , extension with new of STL or new is often viable and superior alternative to just writing code " to work around the problem .

Note that whatever an STL algorithm returns , it cannot be an argument container .
The arguments to STL are iterators , an algorithm has no knowledge of the data STL Algorithms Chapter structure those iterators point into .
Iterators exist primarily to isolate from the data structure on which they operate , vice versa .

" version that performs its action using conventional operations , such as .

version that takes key operations as arguments For example :

This greatly increases the ﬂexibility of the standard library its range of uses .

The usual two of an algorithm can be implemented as two function templates or as single function template with default argument .
For example : Ran , typename use default template argument .

The difference between having two functions having one with default argument can be observed by someone taking pointers to functions .
However , thinking of many of the variants of the standard as simply version with the default predicate " roughly halves the number of template functions you need to remember .

In some cases , an argument could be interpreted as either predicate or value .
For example : bool ; auto ; In general , compiler cannot disambiguate such examples , programmers would get confused ev en in the cases where the compiler could disambiguate .

To simplify the task for the programmer , the sufﬁx is often used to indicate that an algorithm takes predicate .
The reason to distinguish by using two names is to minimize ambiguities confusion .
Consider : using ; Section Policy Arguments .

Unless otherwise stated , assume that policy argument passed to an algorithm should not modify an element .
In particular , do not try to modify elements through .

If you are really sneaky , you could even modify the sequence , by inserting or removing an element using the name of container being iterated , so that the iteration would fail in obscure .
To avoid accidents , you may pass arguments to predicates by const reference .

Similarly , predicate should not carry state that changes the meaning of its operation implementation of an algorithm may copy predicate , we rarely want repeated uses of predicate on the same value to give different results .
Some function objects passed to  such as random number generators , do carry mutable state .
Unless you are really sure that an algorithm copy , keep function object mutable state in another object access it through pointer or reference .

In particular , do not sort or search containers of strings using the .

Most are linear , for some , which is usually the length of an input sequence .

All the rest As ever , these are asymptotic complexities , you have to know what measures to have an idea of the implications .
For example , if , quadratic algorithm may be the best choice .
For example , traversing list can be much slower than STL Algorithms Chapter traversing  even though the complexity in both cases is linear .
Complexity measures are not substitute for common sense actual time measurements ; they are one tool among many to ensure quality code .

Typically , operations to an algorithm change the values of elements either ; they tend to be predicates may not modify their .

For example : STL Algorithms Chapter .

No end is speciﬁed for the second sequence ; that is , there is no .
Instead , it is assumed that there are at least as many elements in the second sequence as in the  and is used as .
This technique is used throughout the standard library , where pairs of sequences are used for operations on pairs of elements .
We could implement like .

If that second sequence is found , an iterator for the matching element in the sequence is returned .
As usual , the end of the sequence is used to represent " For .

Thus , is useful algorithm for ﬁnding substring generalized to all sequences .

Use or to look for just single element .

Instead , it produces an output that is transformation of its input based on operation .

The family of algorithms copy elements from one sequence into another .
The following sections list versions of combined with other algorithms , such as .

Move all elements in to .

To read sequence , we need of iterators describing where to begin and where to end .
To write , we need only an iterator describing where to write to .
However , we must take care not to write beyond the end of the target .
One way to ensure that we do this is to use an inserter to grow the target as needed .
For example : Section .

We use when the sequences do not overlap or if the end of the output sequence is in the input sequence .

Like other standard algorithms , operates on iterators .
It does not know which container these iterators point into , so it cannot modify that container .
It can only modify the values of the elements .
This implies that does not eliminate duplicates from its input sequence in the way we naively might expect .
Therefore , this does not eliminate duplicates in .

Algorithms that might have removed elements generally come in two forms : the " version that reorders elements in way similar to and version that produces new in way similar to .

To eliminate duplicates from container , we must explicitly shrink it :

The algorithm " elements to the end of  Remove elements with value from , Remove elements from .

Copy into in rev erse order The algorithm assigns new to selected elements : Section Replace elements in for which with Replace elements in for which with Copy to , replacing elements for which with Copy to , replacing elements for which with These algorithms cannot change the size of their input  so even leaves the size of its input unchanged .
Like , it " by moving elements to the left .

That is , after shufﬂe , the elements are in random order , where " is deﬁned by the distribution produced by the random number generator .

By default , shufﬂes its using uniform distribution random number generator .

That is , it chooses permutation of the elements of the so that each STL Algorithms Chapter permutation has the same chances of being chosen .
If you want different distribution or better random number generator , you can supply one .
For call , the generator is .

Make the previous permutation , using for comparison Is there permutation of that compares equal to .

Is there permutation of that compares equal to , using as the element comparison .

Permutations are used to generate combinations of elements of .
For example , the permutations of abc are acb , bac , bca , cab , and cba .

The next permutation is found by assuming that the set of all permutations is lexicographically sorted .

If such permutation exists , returns true ; otherwise , it transforms the into the smallest permutation , that is , the ascendingly sorted one in the , and returns .

The family of algorithms provide ways of assigning to and initializing elements of .

For example , using the random number generators Randint and Urand from .

The and functions assign rather than initialize .
If you need to manipulate raw STL Algorithms Chapter storage , say , to turn region of memory into objects of type and state , you use one of the versions in .

Uninitialized sequences should only occur at the lowest level of programming , usually inside .

algorithm exchanges the of two .

The pointer had better point to an with at least elements .

The algorithm is possibly the simplest and arguably the most crucial algorithm in the standard library .
It is used as part of the implementaton of many of the most widely used algorithms .
Its implementation is used as an example in and the version is presented in .

Comparison is by default done using the  and equivalence of values and is determined by rather than requiring .

Sort , using as the sorting criterion In addition to the sort " there are many variants : Section Sorting and Searching Sort maintaining order of equal elements .

Sort enough of to get into .

The algorithms require iterators .

Despite its name , returns an iterator , rather than bool .

The standard list does not provide iterators , so lists should be sorted using the speciﬁc list operations or by copying their elements into  sorting that  and then copying the elements back into the list :

The basic is efﬁcient average .
If stable sort is required , should be used , that is , an algorithm that improves tow ard when the system has sufﬁcient extra memory .
The function may be used for getting such extra memory .
The relative order of elements that compare equal is preserved by but not by .

Sometimes , only the ﬁrst elements of sorted sequence needed .
In that case , it makes sense to sort the sequence only as far as is needed to get the ﬁrst part in order , that is , partial sort .
The STL Algorithms Chapter plain algorithms put the elements in the range in order .

The algorithms produce elements , where is the lower of the number of elements in the output sequence and the number of elements in the input sequence .
We need to specify both the start and the end of the result sequence because what determines how many elements we need to sort .
For example : void ﬁnd the top ten books .

Because the target of must be iterator , we cannot sort directly to .

If the number of elements desired to be sorted by is small compared to the total number of elements , these algorithms can be signiﬁcatly faster than complete .
Then , their complexity approaches compared to .

The algorithm sorts only as far as is necessary to get the Nth element to its proper place with no element comparing less than the Nth element placed after it in the sequence .
For example :

Replacing with in that example using the same seed for the random number generator to get the same , got :  The algorithm is particularly useful for people such as economists , sociologists , and teachers who need to look for medians , percentiles , etc .

Sorting strings requires an explicit sorting criterion .
The reason is that strings simply pointers with set of conventions for their use , so on pointers compares machine addresses rather than character sequences .
For example : Section Sorting and Searching .

However , to sort strings by string value rather than by address we need proper sort predicate .
For example :  const return ; The function is described in .

Note that did not have to supply to sort strings .
To simplify the user interface , the standard library uses rather than to compare elements .

Once sequence is sorted , however , we can use binary search to determine whether value is in sequence .
For example : STL Algorithms Chapter .

returns bool indicating whether value is present .
As with , we often also want to know where the elements with that value in that sequence .
However , there can be many elements with given value in sequence , and we often need to ﬁnd either the ﬁrst or all such elements .
Consequently , algorithms provided for ﬁnding range of equal elements , and algorithms for ﬁnding the and of that range .

If ﬁnd , it returns an iterator to the ﬁrst with key greater than , or last if no such greater exists .
This way of reporting failure is also used by and .
This means that we can use these algorithms to determine where to insert new into sorted sequence so that the sequence remains sorted : just insert before the second of the returned pair .

Curiously enough , the binary search algorithms do not require iterators : forward iterator sufﬁces .

The merge algorithms combine two ordered sequences into one : into , using as the comparison into sorted sequence , using as the comparison The algorithm can take different kinds of sequences and elements of different types .
For example : Section .

The output is : Set Algorithms These algorithms treat sequence as set of elements and provide the basic set operations .
The input sequences are supposed to be sorted and the output sequences are also sorted .

Are all elements of also in , using for comparison .

This little test produces : ceqrtvwxz Heaps heap is compact data structure that keeps the with the highest value ﬁrst .
Think of heap as representation of binary tree .
The heap algorithms allow programmer to treat sequence as heap : Make ready to be used as heap .

The largest is extracted by reading through , and then .

The way to understand the changes to is that user reads only and writes only where is the index of the current of the heap .
The heap removes an by swapping it with .

The point of heap is to provide fast addition of elements and fast access to the with the highest value .
The main use of heaps is to implement priority queues .

lexicographical compare is the rule we use to order words in dictionaries .

That is , string compares as sequence of characters .
For example : STL Algorithms Chapter .

Value comparisons are useful in many contexts : is the smaller of and .

For example : int ; int ; Section Min and Max .

With the ACSII character set on my machine , this little test produces : Advice An STL algorithm operates on one or more sequences ;

Iterator Model Iterator Categories ; Iterator Traits ; Iterator Operations .

Iterator Adaptors Reverse Iterators ; Insert Iterators ; Move Iterator .

Range Access Functions .

Function Adaptors ; function .

Advice Introduction This chapter presents the STL iterators and utilities , notably function objects STL consists of the iterator , container , algorithm , and function object parts of the standard library .

Iterators are the glue that ties algorithms to their data .
Conversely , you can say that iterators are the mechanism used to minimize an algorithm ' dependence on the data structures on which it operates : STL Iterators Chapter .

Iterators vector map list .

sequence is deﬁned by pair of iterators deﬁning range : elements : end iterators : That is , points to the of the sequence , and end points to the of the sequence .
Never read from or write to .
Note that the empty sequence has ; that is , is the empty sequence for any iterator .

To read sequence , an algorithm usually takes pair of iterators and iterates using until the end is .

Algorithms that search for something in sequence usually return the end of the sequence to indicate ; for example : auto .

In that case , it is the responsibility not to write beyond the end of that sequence .
For example :

Some implementations range check that is , throw an exception for that last call of but you rely on that for portable code : many implementations check .
For simple safe alternative an insert iterator .

Input iterator : We can iterate forward read each .

We can compare input iterators .
This is the kind of iterator that istream offers ; see .

Output iterator : We can iterate forward write an once only .

This is the kind of iterator that ostream offers ; see .

Forward iterator : We can iterate forward repeatedly read write the elements are elements repeatedly .
If forward iterator points to class object , we can to refer to member .
We can compare forward iterators .
This is the kind of iterator offers .

Bidirectional iterator : We can iterate forward backward read write the elements are elements repeatedly .
If bidirectional iterator points to class object , we can to refer to member .
We can compare bidirectional iterators .
This is the kind of iterator that list , map , set offer .

iterator : We can iterate forward backward read write the elements are elements repeatedly .
If iterator points to class object , we can to refer to member .
We can subscript iterator , add an integer + subtract an integer .
We can ﬁnd the distance between two iterators to the same sequence by subtracting one from the other .
We can compare iterators ,
This is the kind of iterator that offers .

Logically , these iterators are organized in hierarchy : STL Iterators Chapter Iterator , Input Iterator , single read , Output Iterator single write Forward Iterator repeated read write Bidirectional Iterator Iterator , + The iterator categories are concepts rather classes , so this hierarchy is not class hierarchy implemented derivation .
If you need to do something advanced with iterator categories ,

Category for iterators ; derived from ; provided for  deque , array , arrays , string Section Iterator Traits The iterator tags are types used to select among algorithms based on the type of an iterator .
For example , iterator can go directly to an element :

Typically , will be inlined to ensure that no overhead is introduced by this tag dispatch technique .
Variants of this technique are pervasive in the STL .

The key properties of an iterator are described by the aliases in 

This is an error waiting to happen .
Calling this with argument would be an error .

The compiler would catch it , but the error messages might be voluminous obscure .
Instead , we can write :

The idea is that to ﬁnd property of an iterator , you look in its , rather than at the iterator itself .
To avoid directly referring to the  which after all is just an implementation detail , we can deﬁne an alias .
For example : typename ; typename ; So , if we want to know the type of the difference between two iterators to the same , we have some .

The iterator template simply bundles the key properties of an iterator into struct for the convenience of iterator implementers provides few defaults : Section Iterator Traits Cat , typename , typename , typename , typename .

Thus , for more complicated iterators , is likely to be more efﬁcient than .

The following operations work for every iterator for which they can be implemented , but they may work more efﬁciently for iterators : STL Iterators Chapter ; must be at least an input iterator .

In each case , if is not iterator , the algorithm will take steps .

Iterators for iostreams are described in .

If the sequence allows bidirectional access , we can also traverse the sequence in reverse order , from to .
An iterator that does that is called .
iterates from the end of the sequence deﬁned by its underlying iterator to the beginning of that sequence .
To get sequence , we must consider as one past the end and as the start of the sequence :
Thus , the fundamental relation between reverse iterator and its corresponding iterator is .

In particular , if is vector , points to its last element ,
Consider : This sequence can be viewed like this using : Section Reverse Iterator The deﬁnition of looks something like this : class  public ,

In particular , if Iter is  its has , + and .
For example : STL Iterators Chapter .

use to move the iterator because + wouldn ' work for bidirectional iterator , such as .

Reverse iterators allow us to use algorithms in way that views sequence in the reverse order .

For example , to ﬁnd the last occurrence of an element in sequence , we can apply to its reverse sequence : auto ; last occurrence .

So , to get an iterator pointing to the same element as the reverse iterator  hav to return .
Howev er , my container may be that does not support for its iterators , so use instead .

rev erse iterator is perfectly ordinary iterator , so could write the loop .

As for the earlier deﬁnitions of , this version requires at least bidirectional iterator .

This implies the possibility of overﬂow and consequent memory corruption .

If vi has fewer than elements , we are in trouble .

In , the standard library provides solution in the form of an inserter : when written to , an inserter inserts new into sequence rather than overwriting an existing .

So , container grows by one each time value is written to it through an insert iterator .
Inserters are as simple and efﬁcient as they are useful .

There are three insert .

An inserter is usually constructed by call to helper .

The iterator passed to must be an iterator into the container .
For sequence container , that implies that it must be bidirectional iterator that you can insert before .
For example , you can ' use to make an iterator to insert into .
For an associative container , where that iterator is only used as hint for where to insert , forward iterator , as provided by an can be acceptable .

An inserter is an output iterator : Inserter for container c pointing to ; must point into c ; Copy constructor : is copy of Copy assignment : is copy of Move assignment : points to what pointed to STL Iterators Chapter Make point to the next  the value is new value Make point to the next  the value is old value Insert before Insert before  then increment The and differ in that their constructors don ' require an iterator .
For example :  You cannot read through an inserter .

We usually make move iterator from another iterator using helper function : Move Iterator Construction Function is pointing to the same as  must be an input iterator move iterator has the same operations as the iterator from which it is made .
For example , we can simply returns an rvalue reference to the pointed to :

In , the standard library provides nonmember and functions for containers : These functions are very simple : Section Range Access Functions auto ; auto .

Common uses are comparison criteria , predicates returning , and arithmetic operations .

In , the standard library supplies few common function objects : means and are of type .

Note that and always evaluate both their arguments and do .

Given function and set of arguments , produces function object that can be called with remaining " arguments , if any , of the function .
For example : double ; auto .

To deal with that , the standard library provides yet another pair of adaptors : is for ; noexcept .

This is needed to pass references as arguments to threads because thread constructors are variadic templates .

So far , either used the result of immediately or assigned it to variable declared using auto .
This saves me the bother of specifying the return type of call of .
That can be useful because the return type of varies with the type of function to be called and the argument values stored .
In particular , the returned function object is larger it has to hold values of bound parameters .
However , we sometimes want to be speciﬁc about the types of the arguments required and the type of result returned .
If so , we can specify them for function .

In that , resembles lambda .

If we want to assign the result of to variable with speciﬁc type , we can use the type .
is speciﬁed with speciﬁc return type and speciﬁc argument type .

If , points to the contained object , otherwise , noexcept Is empty .

The functions are provided for the rare cases where someone wants to examine  rather than simply call it as usually intended .

The is type that can hold any object you can invoke using the call operator ,
That is , an object of type is object .

For example : int return ;

Obviously , functions are useful for callbacks , for passing operations as arguments , etc .

When bits are shifted , logical than shift is used .
That implies that some bits off the end " and that some positions get the default value .
Note that because is an unsigned type , it is not possible to shift by negative number .
It does , however , imply that shifts by very large positive value , thus leaving every bit of the with the value .
Your compiler should warn against this .

also supports common operations such as , Tr , and have defaults for is the unsigned long corresponding to .

Does any bit in have the value .

Does no bit in have the value .

To avoid nonobvious conversions , named operations were preferred over conversion operators .
If the value of the has so many signiﬁcant bits that it cannot be represented as an unsigned long , throws ; so does if its argument ﬁt .

Fortunately , the template arguments for the returned by are defaulted .

This prints the bits represented as and from left to right , with the most signiﬁcant bit leftmost , so that argument would give the output For this example , it is simpler to directly use the output .

As in , elements of with higher indices have higher addresses : position : This is exactly the opposite of the layout in .
Also , there is no direct support for converting integers and strings to and from .

Use as you would any other , but expect operations on single bit to be less efﬁcient than the equivalent operations on .
Also , it is impossible in to completely faithfully mimic the behavior of reference with proxy , so try to be subtle about distinctions when using .

pair holds two values .

tuple holds zero or more values .

We use pair when it is useful to know that we have exactly two values .
With tuple , we always have to deal with all possible numbers of values .

Similarly , copy or move operations exist for if the corresponding operations on its elements do .

The elements and are members that we can directly read and write .

However , pointer does not indicate who owns the objects .
That is , looking just at pointer , we hav no idea who is supposed to delete the object pointed to , or how , or if at all .
In , we ﬁnd pointers " to express .

owns the object to which it holds pointer .
That is , it is the obligation to destroy the object pointed to by its contained pointer .

cannot be copied no copy constructor or copy .

stores pointer and deletes the object pointed to using the associated deleter when it is itself destroyed as when thread control leaves the scope ;

Passing ownership dynamically allocated memory to function .

Returning dynamically allocated memory from function .

Storing pointers in containers Think as being represented by simple pointer contained or it has as pointers : object object deleter When is destroyed , its deleter is called to destroy the owned object .
The deleter represents what it means to destroy an object .

deleter for memory pool should return the object to the memory pool and destroy it or not , depending on how that pool is deﬁned .

The default version of uses delete .
It doesn ' even store the default deleter .
It can be specialization or rely on the optimization .

This way supports general resource management .

The contained is not directly accessible to users .

Exchange and values ; noexcept .

Note : does not offer copy constructor or copy assignment .
Had it done so , the meaning of " would have been very hard to deﬁne use .
If you feel the need for copies , consider using .

It is possible to have for array .

The style illustrated by is explicit about ownership the use of is typically motivated by ownership .
See also the discussion of the use of references in .

On balance , notation that modiﬁes is more than notation that does not .

This , too , is unlikely to be signiﬁcant in most programs , so the choice between the styles of and has to be made on reasoning about code quality .

Here is simple example of deleter used to provide guaranteed release of data obtained from program fragment using .

It is used where two pieces of code need access to some data but neither has exclusive ownership the sense of being responsible for destroying the .
is kind of counted where the object pointed to is deleted when the use count goes to zero .
Think of shared as structure with two pointers : one to the object and one to the use count : use count deleter object The deleter is what is used to delete the shared object when the use count goes to zero .
The default deleter is the usual delete the destructor , if any , and deallocate free .

For example , consider Node in general graph used by an algorithm that adds and removes both nodes and connections between nodes .
Obviously , to avoid resource leaks , Node must be deleted if and only if no other node refers to it .
We could try : Section .

Given that , answering questions such as many nodes points to this " is very hard and requires much added " code .
We could plug in garbage collector , but that could have neg ative performance implications if the graph was only small part of large application data space .
Worse , if the container contained resources , such as thread handles , ﬁle handles , locks , even garbage collector would leak resources .

Here , destructor implicitly generated destructor will do deletes its edges .
That is , the destructor for each is invoked , and the Node pointed to is deleted if was the last pointer to it .

use just to pass pointer from one owner to another ; what is for , and does it better and more cheaply .
If you have been using counted pointers as return values from factory functions and the like , consider upgrading to rather than .

Do not thoughtlessly replace pointers with in an attempt to prevent memory leaks ; are not panacea nor are they without .

circular linked structure of can cause resource leak .
You need some logical complication to break the circle , for example , use .

Objects with shared ownership tend to stay " for longer than scoped objects causing higher average resource .

Shared pointers in environment can be expensive of the need to prevent data races on the use .

destructor for shared object does not execute at predictable time , so the for the update of any shared object are easier to get wrong than for an object not shared .
For example , which locks are set at the time of the execution .

Which ﬁles are open .
In general , which objects are " and in appropriate states at the point of execution .

If single node keeps large data structure alive , the cascade of destructor calls triggered by its deletion can cause signiﬁcant collection " That can be detrimental to response .

represents shared ownership and can be very useful , even essential , but shared ownership my ideal , and it always carries cost of how you represent the .
It is better if an object has deﬁnite owner and deﬁnite , predictable life span .
When there is choice : Memory and Resources Chapter .

Prefer ordinary scoped objects to objects on the heap owned by .

The provides fairly conventional set of operations : is the contained pointer ; is the use count sp Default constructor : noexcept sp .

Like but with the deleter Like but with the deleter and the allocator ; noexcept ; noexcept ; noexcept pp is or Exchange and values ; noexcept In addition , the standard library provides few helper functions : is for an object of type constructed from the arguments args ; allocated using new is for an object of type constructed from the arguments args ; allocated using allocator Section ; or may be the nullptr ; or may be the nullptr .

If has deleter of type , is deleter ; otherwise , noexcept Write to ostream os For .

Note that unlike , deleter is not member function .

To access the object , can be converted to using the member function .
allows access to an object , owned by someone else , that .

You need access to if it exists .

May get deleted someone at any time .

In particular , we use weak pointers to break loops in data structures managed using .

Think of as structure with two pointers : one to the object and one to the use count structure of that : Memory and Resources Chapter : wp : use count deleter weak use count Object The use count " is needed to keep the use count structure alive because there may be after the last for an object the is destroyed .

Destructor : no effect on ; Copy : decrease wuc and set to pp : pp is or  noexcept .

There is no standard way of saying which alternative you prefer .
Consider that issue programming environment issue .

Doing so simpliﬁes programming and eliminates many kinds of errors .
However , in relatively rare cases , such as when writing memory allocators , implementing containers , and dealing directly with hardware , direct use of uninitialized memory , also known as raw memory , is essential .

In addition to the standard allocator , the header provides the family of functions for dealing with uninitialized memory .
They share the dangerous and occasionally essential property of using type name to refer to space sufﬁcient to hold an object of type rather than to properly constructed object of type .
These functions are intended primarily for implementers of containers and algorithms .
For example , and are most easily implemented using these functions .

Often , such temporary space is best allocated in one operation but not initialized until particular location is actually needed .

Consequently , the library provides of functions for allocating and deallocating uninitialized space : allocate , initialize void ; deallocate , destroy operation tries to allocate space for more objects of type .
If it succeeds in allocating some memory , it returns pointer to the ﬁrst uninitialized space and the number of objects of type that will ﬁt into that space ; otherwise , the value of the is zero .
The idea is that system may keep space ready for fast allocation so that requesting space for objects of given size may yield space for more than .
It may also yield less , however , so one way of using is to optimistically ask for lot and then use what happens to be available .

buffer obtained by must be freed for other use by call of .
Just as allocates without constructing , frees without destroying .
Because is and likely to be optimized for managing temporary buffers , it should not be used as an alternative to new for obtaining storage .

That is , the algorithms use assignment rather than copy construction for writing .
Consequently , we cannot use uninitialized memory as the immediate target of an algorithm .
This can be unfortunate because assignment can be signiﬁcantly more expensive than initialization , and to initialize immediately before overwriting is waste .
The solution is to use from that initializes instead of assigns : Memory and Resources Chapter Out , typename class  public .

This is somewhat contrived example because see nothing wrong in allocating default initialized storage for the strings and then assigning the test strings .

Note that there are operators for  so don ' try to use it to write to range .
For example will not work if and are .

Don ' mess with uninitialized memory unless you absolutely have to .

Time duration ; Clocks ; Time Traits .

Rational Arithmetic .

Type Functions Type Traits ; Type Generators .

Minor Utilities and ; Relational Operators ; Comparing and Hashing .

Advice Introduction The standard library provides many components " that are so widely useful that they are not easily classiﬁed as part of some major component .

All chrono facilities are in the , so we have to either explicitly qualify with : add : using namespace ; We often want to time things to do things that depend on timing .
For example , the standardlibrary mutexes and locks provide the option for thread to wait for period of time to wait until given point in time .

In fact , the time facilities originated with the stringent needs of physics .

It turns out that " is far more complicated to deal with than we usually think .
For example , we have leap seconds , clocks that are not accurate and must be adjusted causing time as reported by clock to go , clocks of differing precision , etc .
Furthermore , language facilities for dealing with short time spans , must not themselves take signiﬁcant time .
Consequently , the chrono facilities are not simple , but many uses of those facilities can be very simple .

The time utilities can be found in .

Copy constructor : gets the same value as ; must be convertible to Rep without narrowing ; constexpr gets the same value as ; must be representable as Rep is the number of clock ticks in  constexpr We can deﬁne with speciﬁc value .
For example : Section .

Allowing that would be like allowing the addition of of an unknown SI unit to length in meters .

Comparison is done in the of and ; constexpr Comparison is done in the of and ; constexpr Comparison is done in the of and ; constexpr .

Convert to type ; implicit conversions are used for the representation  constexpr The standard library provides some convenience aliases using the SI units from : Section .

The precision of is .

In , the standard library provides basic interfaces for clocks .
Class represents time " as obtained from  class .

All data and function members are static .
We don ' explicitly deal with objects .
Instead , we use types : Is this type steady .

We can determine the basic properties of the clocks like .

When ran it on one of my systems , this produced : not steady Different systems and different clocks can give different results .

The conversion rules for and depend on whether their representation is that rounding is or  struct  few standard values are .

This implies that : can hold any value from and without truncation error .
Howev er , durations may have errors .

The standard library uses to provide representation of time and time points :

The basic idea is to encode the numerator and denominator of rational number as template arguments .
The denominator must always be nonzero .

In , we ﬁnd the conventional notation , + and for rational arithmetic for time .
Similarly , to help express unit values , the standard library provides common SI magnitude names : using yocto ; conditionally supported using zepto ; conditionally supported using atto .

These functions are primarily used at compile time to support simple , and not so simple , metaprogramming .

Their names are mostly .
The primary predicates test fundamental properties of  Is void .

type trait returns value that is used as Boolean .
To access that value , use the sufﬁx .

For example :

Ideally , use library that provides such functions for all standard library type traits .

Some type functions inquire about combination of fundamental properties : Is reference or rvalue .

These composite type predicates simply offer notational convenience .
For example , is true if is either an lvalue reference or an rvalue reference .

For example : class Cont .

This optimization may be unnecessary , though , because is likely to already have been optimized in this way .

The type property predicates do access checking depending on where they are used .

Instead , they consistently give the result you would expect for use outside members and friends .

For example : class .

Both and will write to report that an is neither destructible nor copy assignable .
Also , if you want to eliminate an operation , rather than relying as private .

Like , property query returns numeric related to type argument : If is an array , is the number of dimensions ; otherwise If is an array , is the number of elements in the Nth dimension ; otherwise For example :

The type relations are predicated on two types : Is the same type as .

For example :

To access that type , the sufﬁx .
For example : typename .

Ideally , support library that provides such aliases systematically for the type transformers .

The type functions for adding and removing references are important for when writing templates that should work with an argument that may be reference or not .
For example : Utilities Chapter .

We can make pointer type pointing to an arbitrary type , or ﬁnd the type : If is pointer type , the type ; otherwise For example : Section Type Generators .

It is often useful to ﬁnd that can be used for operations on more than one  such as the result of an addition of two values of related but different types .
The function ﬁnds such common types .
is the common of itself : Utilities Chapter struct .

Curiously enough , the same does not apply to nonmember functions .

Returns an rvalue for  typename ; never use return value of The function is unusual in the standard library because it is actually function users needing to wrap .
It returns value that must never be used .
The intent is to use as where the of variable of is needed .
For example :  siz .

See also the deﬁnition of .

They ﬁt into larger grouping .

In , we ﬁnd some of the most useful small functions : is an rvalue ; may not be an lvalue ; noexcept .

is used to tell the compiler that an object will not be used anymore in context , so that its value can be moved and an empty object left behind .
The simplest example is the implementation of .

produces an rvalue from an rvalue .

The assert is there for programmer who are too clever for their own good and calls the second version with an explicit template argument and an lvalue .

The is good example .

Use when the intent is to the representation " of an object with move operation , and use for forwarding .
Thus , is safe , whereas marks for destruction so that should be used with care .
The only safe use of an after is destruction or as target for an assignment .
Obviously particular could provide further guarantees , and ideally the inv ariant is left intact .
However , rely on that unless you really know .

In , the standard library provides general and specialization for .

This could expose the perfectly general templates from to be found by lookup and applied to types for which they may be inappropriate .
safer approach is to place in local scopes .

is created from , speciﬁcally to allow such comparison and hashing .

Character Classiﬁcation Classiﬁcation Functions ; Character Traits .

Strings string vs .
Strings ; Constructors ; Fundamental Operations ; String ; Numeric Conversions ; Operations ; The ﬁnd Family ; Substrings .

Advice Introduction The standard library offers character classiﬁcation operations in , strings with associated operations in , regular expression matching in , and support for strings in .
Handling of different character sets , encodings , and conventions is discussed in Chapter .

simpliﬁed string implementation is presented in .

In addition , the standard library provides two useful functions for removing case .

The character classiﬁcation functions are sensitive to the " locale ,
Equivalent functions for other locales are provided in .

One reason that these character classiﬁcation functions are useful is that character classiﬁcation can be trickier than it might appear .
For example , novice might write : if character This is more verbose most likely than : if low ercase character Also , there is no guarantee that the characters are contiguous in code space .
Furthermore , the use of standard character classiﬁcations are far easier to convert to another locale : if low ercase character in Danish Note that Danish has three more lowercase characters than English , so that the initial explicit test using ' and ' would be ﬂat wrong .

However , efﬁciency can be improved and implementations can be simpliﬁed for types that hav copy operations .
Consequently , the standard string requires that type used as its character type be POD .
This also helps to make of strings simple and efﬁcient .

The properties of character type are deﬁned by its .
is specialization of the  struct ; All are deﬁned in std , and the standard ones are presented in .
The general itself has no properties ; only specializations for particular character type have .
Consider : struct operations should not throw exceptions .

Copy to ; and may overlap ; Copy to ; and may not overlap ; Strings Chapter points to the ﬁrst occurrence of in or nullptr is the value representing Comparing with is often not simply .
For example , would deﬁne its so that would return true .

Because does not protect against overlapping ranges , it may be faster than .

The function uses and to compare characters .
It returns int , where represents exact match , negative number means that its ﬁrst argument comes lexicographically before the second , and positive number means that its ﬁrst argument comes after its second .

The functions are used by the implementation of .

The elements are stored contiguously , so that input operations can safely use sequence of characters as source or target .

The offers the strong guarantee : if operation throws , the is left unchanged .

All these strings provide host of operations .

Like containers , is not meant to be used as base class and offers move semantics so that it can be efﬁciently returned by value .

Strings assume some familiarity with from the many examples in this book , so start with few examples contrasting use with the use of strings which are popular with programmers primarily familiar with and .

Consider making up email address by concatenating user identiﬁer and domain .

At least it gav the output expected .
Like most experienced programmers , got the version correct the ﬁrst time , but there are lot of details to get right .
However , experience , error shows that this is not always the case .
Often , such simple programming tasks are given to relative novices who still don ' know all the techniques needed to get it right .
The implementation of the contains lot of tricky manipulation , and its use requires the caller to remember to free the returned memory .
Which code would you prefer to maintain .

Sometimes , it is claimed that strings are more efﬁcient than strings .
However , for most uses , the does fewer allocations and deallocations than equivalent of the optimization and move semantics ;
Also , is operation , whereas is simple read .
In the example , this implies that the code traverses each input twice , whereas the version does only one traversal per input .
Efﬁciency concerns at this level are often misguided , but the version has fundamental edge .

The fundamental difference between strings and is that is proper type with conventional semantics , whereas the is set of conventions supported by few useful functions .
Consider assignment and .

The sort function is presented in .
Again , is fast typically much faster , so there is no performance reason to choose the , more verbose , and less maintainable programming style .

All operations are noexcept Find in  is the index of the ﬁrst character found or .

All operations are noexcept .

This explicit use of constants to denote positions and lengths is brittle and .

Regular Expressions Regular Expression Notation .

Regular Expression Functions .

Regular Expression Iterators ;

Advice Regular Expressions In , the standard library provides regular .

This function reads ﬁle looking for The United States postal codes , such as and DC .
An smatch type is container of regex results .
Here , is the whole pattern and is the optional subpattern .
used raw which is particularly suitable for regular expressions because they tend to contain lot of backslashes .
Had used conventional  the pattern deﬁnition would have been : regex pat ; The United States postal code pattern The regular expression syntax and semantics are designed so that regular expressions can be compiled into state machines for efﬁcient execution .
The regex type performs this compilation at run time .

Here , ﬁrst present the default notation used , variant of the ECMA standard used for ECMAScript commonly known as .

The syntax of regular expressions is based on characters with special meaning : Regular Expression Special Characters .

pattern can be optional or repeated default is exactly by adding sufﬁx : Repetition Exactly times , or more times At least and at most times Zero or more , that is , + One or more , that is ,

Optional or , that is For example : Examples that match : AAABBC AAABBB Example that do not match : AABBC too few As AAABC too few Bs AAABBBBBCCC too many Bs .

Typed values : Byte sequences : Streams Chapter An istream converts stream of characters to typed objects : istream stream buffer .

Any operation attempted on stream that is not in the state has no effect ; it is .
An iostream can be used as condition .
In that case , the condition is true if the state of the iostream is .
That is the basis for the idiom for reading stream of values : for ; read into an input buffer of type .

For example , we can make cin throw when its state is set to , by .

That usually means all exceptions .

The description here is based on the conventional English small character set .
The ways in which different character sets and different natural languages are handled are described in Chapter .

The is primarily intended as base class for more speciﬁc input classes , such as istream and  typename class  virtual public .

It provides common code for and input operations .
Code that needs to be executed ﬁrst such as ﬂushing tied stream is provided as the sentry ' constructor .
For example : typename .

If is  means .
That is , iostream input is sensitive , inherently , and extensible .
designer of new can provide operations without direct access to the implementation of iostream .

If pointer to function is the target of , that function will be invoked with the istream as its argument .
For example , yields .
This is the basis for the input manipulators , such as skipws .
Output stream manipulators are more common than input stream manipulators , so the technique is explained further in .

Unless otherwise stated , an istream operation returns reference to its istream , so that we can " operations .
For example : typename .

For example : This will take sequence of positive integers and print them one to line .

Skipping of whitespace can be suppressed using noskipws .

The input operations are not virtual .
That is , user cannot do an where base is class hierarchy and automatically have the resolved to an operation on the appropriate derived class .

However , simple technique can deliver that behavior ; see .
Furthermore , it is possible to extend such scheme to be able to read objects of essentially arbitrary types from an input stream ; see .

One use of unformatted input is the implementation of formatted input : Read one character from in and return its integer .

Exchange the values of in and If you have choice , use formatted input instead these input functions .

The simple is useful when you need to compose your values out of characters .
The other function and read sequences of characters into area .
They read until they reach the maximum number of characters or ﬁnd their terminator character default .

They place at the end of the characters written to ; removes its terminator from the input , if found , whereas does not .
For example : Streams Chapter .

For these functions , it is not immediately obvious what terminated the .

We found the terminator .

We read the maximum number of characters .

We hit .

There was input error .

The last two alternatives are handled by looking at the ﬁle state .
Typically , the appropriate actions are quite different for these cases .

does not write to the array after the characters read .
Obviously , the formatted input operators are simpler to use and less than the unformatted ones .

Place get pointer at position Place get pointer at the offset off in the direction dir Output Operations Output operations are provided by ostream , found in except for the ones writing out string ; those are found in : typename class  virtual public .

An ostream offers formatted output , unformatted output of , and simple operations on its streambuf : Write to out according to  can be an arithmetic  pointer , bitset , complex , valarray , Write the character to out .

Place put pointer at position Place put pointer at the offset off in the direction dir Unless otherwise stated , an ostream operation returns reference to its ostream , so that we can " operations .
For example : value 

This prints : the value ' the value ' Streams Chapter Versions for types are usually trivial to write :

This will work for every where has deﬁned .
For full generality , must be deﬁned for .

The output operations that programmer can add are not members , so they cannot be virtual either .
One reason for this to achieve close to optimal performance for simple operations such as putting character into buffer .
This place where runtime efﬁciency often crucial so that inlining must .
Virtual functions are used to achieve ﬂexibility for the operations dealing with buffer overﬂow and underﬂow only .

However , programmer sometimes wants to output an object for which only base class known .
Since the exact known , correct output cannot be achieved simply by deﬁning for each new .
Instead , virtual output function can be provided in an abstract base : class .

The technique generally useful to provide operations that act like virtual functions , but with the selection based on their second argument .
This similar to the technique that under the double dispatch often used to select an operation based on two dynamic types .
similar technique can be used to make input operations virtual .

For example , means .
Such function called manipulator .
Manipulators that take arguments can be useful .
For example : angle ; This prints the the variable angle with four digits .

To do this , returns an object that initialized by and calls when invoked .
Such manipulator function object that invoked by rather than by .
The exact that function object , but it might be deﬁned like .

We can now write : angle ; programmer can deﬁne new in the style smanip as needed .
Doing this does not require modiﬁcation the deﬁnitions templates and classes .

The are described in .

The class manages the state .

It might be the most complicated class in the standard library .

The holds information that does not depend on template arguments : class .

The types are all bitmask types ; that  they support bitwise logical operations , such as and .
Examples are int and bitset .

The controls an connection lack to stdio : Default constructor ; protected .

call before the ﬁrst iostream operation in the execution program Section Stream State guarantees that the iostream and stdio operations share buffers .
call before the ﬁrst stream operation prevents buffer sharing and can improve performance signiﬁcantly on some implementations .

Note that has no copy or move operations .

However , the usual meaning is that character gets mapped to byte .
For example :

Images and streams are examples .

The operations can be summarized : ios ; Construct ios given the stream buffer pointed to by .

Set locale to  is the previous locale is char value obtained by converting of , is default value : Section Stream State is value obtained by converting of char .

Copy and move operation ; protected Exchange the states of and ; protected ; noexcept The conversion of an istreams and to bool is essential to the usual idiom for .

Sometimes , people want to add to the state of stream .
For example , one might want stream to " whether complex should be output in polar or Cartesian coordinates .
Class provides function to allocate space for such simple state information .
The value returned by identiﬁes pair of locations that can be accessed by and .

Sometimes , an implementer or user needs to be notiﬁed about change in state .

The function " function to be called when its " occurs .
Thus , call of , or will call function " for an , or , respectively .
When the state changes , registered functions are called with the argument supplied by their .

The event and types are deﬁned in  Streams Chapter enum event , using void , int ; Formatting The format of stream is controlled by combination of object type , stream state , format state , locale information , and explicit operations , manipulators ;

To get the equivalent , use manipulators defaultﬂoat and hexﬂoat , or manipulate the .

An format state can be read and written by operations provided in its  Section Formatting State is formatting ﬂags .

The general format lets the implementation choose format that presents value in the style that best preserves the value in the space available .
The precision speciﬁes the maximum number of digits .

The scientiﬁc format presents value with one digit before decimal point and an exponent .
The precision speciﬁes the maximum number of digits after the decimal point .

The ﬁxed format presents value as an integer part followed by decimal point and fractional part .
The precision speciﬁes the maximum number of digits after the decimal point .
For example , see .

values are rounded rather than just truncated , and affect integer output .

This produces : The function speciﬁes the minimum number of characters to be used for the next standardlibrary output operation of numeric value , bool , string , character , pointer , string , and bitset .

The default ﬁll character is the space character , and the default ﬁeld size is , meaning many characters as " The ﬁeld size can be reset to its default value like this : Streams Chapter call sets the minimum number of characters to .

If the explicit control of formatting options through many separate operations becomes tedious , we can combine them using manipulator .

An also allows the programmer to set an locale : Set locale to  is the old value of the locale is locale Standard Manipulators The standard library provides manipulators corresponding to the various format states and state changes .
The standard manipulators are deﬁned in , and manipulators that take : On output preﬁx octal numbers by and hexadecimal numbers by Always show decimal point Show + for positive numbers Use uppercase in numeric output , and Use lowercase in numeric output , and Flush after each output operation Do not ﬂush after each output operation Section Standard Manipulators Pad where marked in formatting pattern Pad after value Pad before value Integer base is Integer base is Integer base is format Scientiﬁc format Use base for mantissa and exponent , using to start an exponent , and Use the default ﬂoating point format Skip whitespace Each of these operations returns reference to its ﬁrst operand ,

We can explicitly set the output format for numbers : constexpr double .

The idea is that Form holds all the information needed to format one data item .
The default is chosen to be reasonable for many uses , and the various member functions can be used to reset individual aspects of formatting .
The is used to bind value with the format to be used to output it .
is , Form plus can then be output to given stream by suitable .

Note that these declarations make the combination and into ternary  collects the ostream , the format , and the value into single function before doing any real computation .

Sometime later , the characters are then written to wherever they are supposed to go .
Such buffer is called streambuf .
Its deﬁnition is found .
Different types streambufs implement different buffering strategies .
Typically , the streambuf stores characters an array until an overﬂow forces it to write the characters to their real destination .
Thus , an ostream can be represented graphically like this : ostream : begin current end streambuf : real destination character buffer locale : The set template arguments for an ostream and its streambuf must be the same , and they determine the type character used in the character buffer .

An istream is similar , except that the characters ﬂow the other way .

Unbuffered is simply where the streambuf immediately transfers each character , rather than holding on to characters until enough have been gathered for efﬁcient transfer .

The key class in the buffering mechanisms is :  typename class public : using  the type character using typename ; the integer type to which character can be converted using typename ; type position in buffer using typename ; type offset from position in buffer .

Many the public operations simply call protected virtual function that ensures that function from derived class implemented the operation appropriately for the particular kind buffer : Section Buffering Destructor : release all resources ; virtual .

has put area into which and other output operations write , and get area from which and other input operations read .
Each area is described by beginning pointer , current pointer , and .

For use of positioning , see .

The interface is separated into public and protected .

In addition , there are virtual functions to be overridden by derived classes .

The how many function is an odd function intended to allow user to learn something about the state of input system .
It returns an estimate of how many characters can be read " say , by emptying the operating buffers rather than waiting for disk read .
call to returns if it cannot promise that any character can be read without encountering .
This is rather and highly .
use without careful reading of your system documentation and conducting few experiments .

In addition , an ostream provides operations that deal directly with its  typename class  virtual public .

The functions override their equivalents in the base .

An ostream is constructed with argument , which determines how the characters written are handled and where they eventually go .
For example , an ostringstream or an ofstream is created by initializing an ostream with suitable .

The sufﬁx indicates that it is the position used for putting characters into the stream .
These functions have no effect unless the stream is attached to something for which positioning is meaningful , such as ﬁle .
The represents character position in ﬁle , and the represents an offset from point indicated by an .

Stream positions start at , so we can think of ﬁle as an array of characters .
For example : int refers to some ﬁle .

Attempting to seek beyond the beginning or the end of ﬁle typically puts the stream into the state .
However , some operating systems have operating modes where the behavior differs , positioning might resize .

The operation allows the user to empty the buffer without waiting for an overﬂow .

It is possible to use to write streambuf directly into an ostream .
This is primarily handy for implementers of mechanisms .

In addition , an istream provides operations that deal directly with its streambuf : typename class  virtual public .

The positioning functions work like their ostream counterparts .
The sufﬁx indicates that it is the position used for getting characters from the stream .
The and sufﬁxes are needed because we can create an iostream derived from both istream and ostream , and such stream needs to keep track of both get position and put position .

The function allows program to put character " into an istream to be the next character read .
The function puts the most recently read character back .
Unfortunately , backing up an input stream is not always possible .
For example , trying to back up past the ﬁrst character read will set .
What is guaranteed is that you can back up one character after successful read .
The function reads the next character and also leaves that character in the streambuf so that it can be read again .
Thus , is logically equivalent to .
Setting failbit might trigger an exception .

Flushing an istream is done using .

For some kinds of streams , we would have to reread characters from the real source and that is not always possible or desirable , for stream attached to .
Consequently , returns if it succeeded .
If it failed , it sets and returns .
Setting badbit might trigger an exception .
on buffer attached to an ostream ﬂushes the buffer to output .

The and operations that directly reads from streambuf are primarily useful for implementers of facilities .

The function is operation that allows user to peek at stream to see if there are any characters available to read .
This can be most useful when it is undesirable to wait for input , say , from keyboard .

In particular , these iterators are widely used by locale facets .

If you use an as an input  its effect is like that of other input iterators : stream of characters can be read from input using : is an  noexcept ; constexpr .

By most measures , operations are odd , but the net effect is that if you use it as an output  its effect is like that of other output iterators : stream of characters can be written to output using : is an for ; noexcept ; is an for the istreambuf ; noexcept Section Do nothing Do nothing Do nothing Has on streambuf reached eof .

Handling Cultural Differences .

Class locale Named locales ; Comparing strings .

Class facet Accessing facets in locale ; Simple facet ; Uses of locales facets .

Standard facets string Comparison ; Numeric Formatting ; Money Formatting ; Date Time Formatting ; Character Classiﬁcation ; Character Code Conversion ; Messages .

Convenience Interfaces Character Classiﬁcations ; Character Conversions ; String Conversions ; Buffer Conversions .

Advice Handling Cultural Differences locale is an object that represents set of cultural preferences , such as how strings are compared , the way numbers appear as output , the way characters are represented in external storage .
The notion of locale is extensible so that programmer can add to locale representing entities not directly supported by the standard library , such as postal codes phone numbers .
The primary use of locales in the standard library is to control the appearance of information written to an ostream the format of data read by an istream .

This chapter describes how to use locale , how locale is constructed out of  how locale affects an stream .

The notion of locale is not primarily notion .
Most operating systems application environments have notion of locale .
Such notion is in principle shared among all programs Locales Chapter on system , independently of which programming language they are written in .
Thus , the notion of locale can be seen as standard portable way for programs to access information that has very different representations on different systems .
Among other things , locale is an interface to system information that is represented in incompatible ways on different systems .

Consider writing program that needs to be used in several countries .
Writing program in style that allows that is often called internationalization the use of program in many or localization the adaptation of program to local .
Many of the entities that program manipulates will conventionally be displayed differently in those countries .
We can handle this by writing our routines to take this into account .

This style of code does the job .
Howev er , such code is ugly hard to maintain .
In particular , we have to use this style consistently to ensure that all output is properly adjusted to local conventions .

If we want to add of writing date , we must modify the application code .
Worse yet , writing dates is only one of many examples of cultural differences .

Consequently , the standard library provides an extensible of handling cultural conventions .

The iostream library relies on this framework to handle both types .

For example , consider simple loop copying pairs that might represent series of measurements or set of .

How would we make this program read ﬁle that conformed to French conventions comma is the character used to represent the decimal point in number ; for example , Section Handling Cultural Differences means twelve and and write it according to American conventions .
We can deﬁne locales and operations so that can be used to convert between .

Given these streams : Apr , Apr , Apr ,

July , July , July ,

Much of the rest of this chapter is devoted to describing the mechanisms that make this possible and explaining how to use them .
However , most programmers will have little reason to deal with the details of locales and will never explicitly manipulate locale .
At most , they will simply retrieve standard locale and imbue stream with it .

The concept of localization is simple .
However , practical constraints make the design and implementation of locale quite intricate : locale encapsulates cultural conventions , such as the appearance of date .
Such conventions vary in many subtle and unsystematic ways .
These conventions have nothing to do with programming languages , so programming language cannot standardize them .

The mechanisms provided to compose those locales and to make them trivial to use constitute little programming language of their own .

locale is composed of facets that control individual aspects , such as the character used for punctuation in the output of value ; and the format used to read monetary value ;
facet is an object of class derived from class .
We can think of locale as container of facets ,

Set the global to  is the previous global is the classic " Section Class If of given or facet referred to exist , the operation naming it throws .

Naming of locales is bit curious .
When you make new from another plus facet and the resulting has  that is .
Often , such an includes the of the that supplied most of the facets .

can be thought of as an interface to , that is , something that allows us to use to ﬁnd corresponding object of class derived from .
real implementation of is an efﬁcient variant of this idea .
The layout will be something like this :

All facets are derived from .

is meant to be copied freely and cheaply .
Consequently , is almost certainly implemented as handle to the specialized that constitutes the main part of its implementation .
The facets must be quickly accessible in .
Consequently , the specialized will be optimized to provide fast access .
The facets of are accessed by using the notation ; see .

The standard library provides rich set of facets .
To help the programmer manipulate facets in logical groups , the standard facets are grouped into categories , such as numeric and collate : collate , collate ; ctype , ctype ; numeric , et , numpunct ; monetary , et , moneypunct ; time , messages messages ; all collate ctype monetary numeric time messages none There are no facilities for programmer to specify string for newly created .
Name strings are either deﬁned in the program ' execution environment or created as combinations of such names by constructors .

However , there is no way for programmer to deﬁne new .
The notion of " applies to standardlibrary facets only , and it is not extensible .
Thus , facet need not belong to any  and many facets do not .

If does not have string , it is undeﬁned whether affects the global .
This implies that program cannot reliably and portably set the to that retrieved from the execution environment .
There is no standard way for program to set the global by calling function to do .
In mixed and program , having the global differ from is error prone .

By far the dominant use of locales is implicitly , in stream .
Each istream and ostream has its own .
The of stream is by default the global at the time of the stream ' creation .
The of stream can be set by the operation , and we can extract copy of stream ' using .

Setting the global does not affect existing streams ; those still use the locales that they were imbued with before the global was reset .

The simplest way of making is to copy an existing one .

function implementing this would need to know where and how system keeps its locales .
For example , many Linux systems keep their locales in the directory .

If the string argument refer to deﬁned locale , the constructor throws the exception .

Similarly , is copy of the modiﬁed to use .
The resulting locales can be represented like this :

: If argument , is nullptr , the resulting is simply copy of the argument .

In construction , the argument must identify speciﬁc facet type .
plain is not sufﬁcient .

Speciﬁcally , the implementation of uses identifying type , to ﬁnd that facet in the .
The constructor , is the only mechanism offered within the language for the programmer to supply facet to be used through .
Other are supplied by implementers as named .
Named can be retrieved from the execution .
programmer who understands the mechanism used for that might be able to add new .

The set of constructors for is designed so that the type of every facet is known either from type deduction the Facet or because it came from another knew its .
Specifying category argument speciﬁes the type of facets indirectly , because the knows the type of the facets in the categories .
This implies that the class can keep track of the types of facets so that it can manipulate them with minimal overhead .

There is no way of modifying .
Instead , the operations provide ways of making new from existing ones .
The fact that is immutable after it has been created is essential for efﬁciency .
This allows someone using to call virtual functions of facet and to cache the values returned .
For example , an istream can know what character is used to represent the decimal point and how true is represented without calling each time it reads number and each time it reads to bool .
Only call of for the stream can cause such calls to return different value .

Consequently , this operation is provided directly by so that users hav to build their own comparison function from the collate facet .
This string comparison function is .

facet represents one speciﬁc cultural aspect , such as how number is represented on output , how date is read from input , and how characters are stored in ﬁle .
The are listed in .

user can deﬁne new  such as facet determining how the names of the seasons are printed .

is represented in program as an object of class derived from .
Like all other facilities , is found in : Section Class class :

The class is designed to be base class and has no public functions .
Its constructor is protected to prevent the creation of  objects , and its destructor is virtual to ensure proper destruction of objects .

is intended to be managed through pointers stored in .
argument to the constructor means that should delete the when the last reference to it goes away .
Conversely , nonzero constructor argument ensures that never deletes the .
nonzero argument is meant for the rare case in which the lifetime of is controlled directly by the programmer rather than indirectly through .

Each kind of interface must have separate  class :

The intended use of is for the user to deﬁne static member of type of each class supplying new interface example , see .
The mechanisms use ids to identify ,
In the obvious implementation of  an is used as an index into of pointers to  thereby implementing an efﬁcient .

Data used to deﬁne is deﬁned in the derived class .
This implies that the programmer deﬁning has full control over the data and that arbitrary amounts of data can be used to implement the concept represented by .

is intended to be immutable , so all member functions of should be deﬁned const .

Alternatively , think of as kind of explicit type conversion of to speciﬁc This is feasible because can have only one of given type .
For example : Locales Chapter .

The standard are guaranteed to be available for all , so we need to use for standard .

One way of looking at the : mechanism is as an optimized implementation of form of polymorphism .
can be used to get very similar results to what produces .
However , the specialized can be implemented more efﬁciently than the general .

An identiﬁes an and behavior rather than class .
That is , if two classes have exactly the same and implement the same semantics far as locale is , they should be identiﬁed by the same .
For example , and are interchangeable in locale , so both are identiﬁed by :

If we deﬁne with new such as in we must deﬁne corresponding to identify it and .

To examine the mechanism in isolation from the complexities of widely used types and the efﬁciency concerns that accompany them , let me ﬁrst present for trivial type : enum Season spring , summer , fall , winter ; very simple type The style of outlined here can be used with little variation for most simple types .

The class provides general and abstract for all .
To deﬁne the representation of Season for particular locale , we derive class from , deﬁning and appropriately .

Output of Season is easy .
If the stream has  we can use that to convert the .

For maximum efﬁciency and ﬂexibility , standard tend to operate directly on stream buffers ,
However , for simple type , such as Season , there is no need to drop to the streambuf level of abstraction .

As is typical , input is bit more complicated than .

The error handling is simple and follows the style for types .
That is , if the input string represent Season in the chosen locale , the stream is put into the fail state .
If exceptions are enabled , this implies that an exception is thrown .

Here is trivial test .

Given the input summer this program responds : summer To get this , we must derive class from , and deﬁne an appropriate string representation of the  class  public .

Note that because is simply an implementation of the  did not deﬁne an for .
In fact , if we want to be used as , we must not give its own .
Operations on locales , such as , rely on facets implementing the same concepts being identiﬁed by the same .

The only interesting implementation question is what to do if asked to output an invalid Season .

Naturally , that happen .
However , it is not uncommon to ﬁnd an invalid value for simple type , so it is realistic to take that possibility into account .
could have thrown an exception , but when dealing with simple output intended for humans to read , it is often helpful to produce an " representation for an value .
Note that for input , the errorhandling policy is left to the  whereas for output , the function implements an policy .
This was done to illustrate the design alternatives .
In " the facet functions would either implement error handling for both input and output or just report errors for and to handle .

This design relies on derived classes to supply the strings .
An alternative design would have itself retrieve those strings from repository .
The possibility of having single class to which the season strings are passed as constructor arguments is left as an exercise .

However , the locale mechanism is general and extensible mechanism for representing information .
The messages facet is an example of facet that has nothing to do with streams .
Extensions to the iostream library and even facilities that are not based on streams might take advantage of locales .
Also , user may use locales as convenient way of organizing arbitrary culturesensitive information .

Because of the generality of the mechanism , the possibilities for facets are unlimited .
Plausible candidates for representation as facets are dates , time zones , phone numbers , social security numbers identiﬁcation , product codes , temperatures , general pairs , postal codes , clothing sizes , and ISBN numbers .

As with every other powerful mechanism , facets should be used with care .
That something can be represented as facet mean that it is best represented that way .
The key issues to consider when selecting representation for cultural dependencies are as ever how the various decisions affect the difﬁculty of writing code , the ease of reading the resulting code , the maintainability of the resulting program , and the efﬁciency in time and space of the resulting operations .

When instantiating facet from this table , must be character type .
These facets are guaranteed to be deﬁned for char or .
In addition , is guaranteed to support and .
user who needs standard to deal with another character type must rely on facet specializations or provide suitable versions of facets for .

For example , might be needed to control conversions between and char .

International can be true or false ; true means that zero " representation of currency symbol is used , such as USD and BRL .

parameter , SS , is used to represent the shift states of multibyte character representation .
In , is deﬁned to represent any of the conversion states that can occur in an set of supported multibyte character encoding rules .
The equivalent to for an arbitrary character type is .

In and Out are input iterators and output iterators , respectively ,
Providing the and facets with these template arguments allows programmer to provide facets that access nonstandard buffers .
Buffers associated with iostreams are stream buffers , so the iterators provided for those are ,
Consequently , the function is available for error handling .

Each standard facet has version .
An facet is derived from the facet .

provides the identical interface to , except that it adds constructor taking string argument naming locale , see .
The provides the appropriate semantics for deﬁned in .
For example : Section Standard facets .

The characters of the string returned by are read as sequence of small integer values .

Each number speciﬁes number of digits for group .
Character speciﬁes the rightmost group .

standard facet , such as , is typically used implicitly through standard stream function .
Consequently , most programmers need not know about it .
However , the use of such facets by functions is interesting because they show how streams work and how facets can be used .
As ever , the standard library provides examples of interesting programming techniques .

Using  the implementer of ostream might write :  class .

We get the ostream ' locale by calling its member function .
We function to do the real work .
An can be constructed from an ostream , and an ostream can be implicitly converted to its base class , so the ﬁrst two arguments to are easily supplied .

call of returns its output iterator argument .
This output iterator is obtained from  so it is an .
Consequently , is available to test for failure and to allow us to set the stream state appropriately .

did not use , because the standard facets are guaranteed to be present in every locale .
If that guarantee is violated , is thrown .

The function calls the virtual .
Consequently , code may be executed , and must be prepared to handle an exception thrown by the overriding .
Also , may not exist for some character types , so might throw .

The behavior of for type , such as double , is deﬁned by the standard .
Consequently , the question is not what should do but rather how it should do what the standard prescribes .
If badbit is set in this ostream ' exception state , the exception is simply .
Otherwise , an exception is handled by setting the stream state and continuing .

In either case , badbit must be set in the stream state :  class .

The is needed because might throw ,
Howev er , if badbit is set in the exception state , must the exception that caused to be called than simply throwing .

The for type , such as double , must be implemented by writing directly to stream buffer .
When writing for type , we can often avoid the resulting complexity by expressing the output of the type in terms of output of existing types .

The iostate variable is set to reﬂect the state of the stream .
If value of the desired type could not be read , failbit is set in  if the was reached , eofbit is set in .
An input will use to determine how to set the state of its stream .
If no error was encountered , the value read is assigned through ; otherwise , is left unchanged .

sentry is used to ensure that the stream ' preﬁx and sufﬁx operations are performed .

For example , an implementer of istream might write :  class .

Unfortunately , that cannot be guaranteed for all input operations .

Exceptions enabled for the istream will be thrown by in case of error .

By deﬁning  such as from , we can read using nonstandard punctuation .

If we want to read really unusual numeric formats , we have to override .
For example , we might deﬁne that reads Roman numerals , such as XXI and MM .

However , the presentation of monetary amounts is even more sensitive to cultural differences .
For example , negative amount loss , such as , should in some contexts be presented as number in parentheses :
Similarly , color is in some contexts used to ease the recognition of negative amounts .

There is no standard " Instead , the money facets are meant to be used explicitly for numeric values that the programmer knows to represent monetary amounts .
For example : struct Money simple type to hold monetary .

The task of the monetary facets is to make it reasonably easy to write an output for Money so that the is printed according to local convention .
The output would vary depending on  locale .
Possible outputs are : Section Money Formatting DKK CAD For money , accuracy to the smallest currency unit is usually considered essential .
Consequently , adopted the common convention of having the integer represent the number of cents , øre , ﬁls , cents , rather than the number of dollars , kroner , dinar , euro ,
This convention is supported by moneypunct ' function .
Similarly , the appearance of the point " is deﬁned by .

The facets and provide functions that perform based on the format deﬁned by the facet .

simple Money type can be used to control formats or to hold monetary values .
It is less to consistently hold monetary amounts in Money type ; that way , we cannot forget to cast to Money before writing it , and we get input errors by trying to read monetary values in localeinsensitive ways .
However , it may be infeasible to introduce Money type into system that designed for that .

version , of is provided : bool .

The , and members return the string to be used to represent the currency symbol example , INR , the plus sign , and the minus sign , respectively .
If the template argument is true , the member will also be true , and " representations of the currency symbols will be used .
Such an " representation is string .

The and algorithms are inverses of each other and deal with the notion of incremental change .

Given sequence , c ,  produces , etc .

Consider of temperature readings .
We could transform it into of temperature .

Thus , turns , back into ,

For people who think of temperature differences as boring detail of meteorology or science lab experiments , note that analyzing changes in stock prices or sea levels involves exactly the same two operations .
These operations are useful for analyzing any series of changes .

The name iota is the Latin spelling of the Greek letter , which was used for that function in APL .

Do not confuse with the , but not uncommon ,

For example , we might want to choose the address for router simulation , decide whether monster should attack or scratch its head , or generate set of values for testing square root function .
In , the standard library deﬁnes facilities for generating numbers .
These random numbers are sequences of values produced according to mathematical formulas , rather than unguessable numbers that could be obtained from physical process , such as radioactive decay or solar radiation .
If the implementation has such truly random device , it will be represented as .

Four kinds of entities are .

uniform random number generator is function object returning unsigned integer values such that each in the range of possible results has equal probability of being returned .

random number engine is uniform random number generator that can be created with default state or with state determined by seed .

random number engine adaptor is random number engine that takes values produced by some other random number engine and applies an algorithm to those values in order to deliver sequence of values with different randomness properties .

random number distribution is function object returning values that are distributed according to an associated mathematical probability density function or according to an associated discrete probability function .

For details see .

In simpler terms , the users ' terms , random number generator is an engine plus distribution .

The engine produces uniformly distributed sequence of values , and the distribution bends those into the desired shape .
That is , if you take lots of numbers from random number generator and draw them , you should get reasonably smooth graph of their distribution .
For example , binding to the gives me random number generator that produces normal distribution : auto ; for ; The function makes function object that will invoke its argument given its second argument .

Using ASCII graphics , got : Numerics Chapter Most of the time , most programmers just need simple uniform distribution of integers or ﬂoatingpoint numbers in given range .

Just for variation , use different technique for : class .

In such algorithms we need to choose sample of some size from much larger population .
Here is algorithm simplest from famous old paper : Iter , typename Size , typename Out , typename .

seed sequence , is an object that provides that when called ﬁlls with newly generated seeds .

For , if the modulus is , the value is used .
For example , this writes out the index of the repetition of number : was lucky ; the parameters were not too bad and got no duplicate values .
Try instead and see the difference .
Use the unless you have real need and know what you are doing .

number engine adaptor takes number engine as an argument and produces new number engine with different randomness properties .

few aliases are deﬁned for useful engines : using , using , using , Section Engines using ,

The is deﬁned as .
The entropy is an estimate of the randomness , the degree of unpredictability , of the generated numbers .
In contrast to thermodynamics , high entropy is good for numbers because that means that it is hard to guess subsequent numbers .
The formula reﬂects the result of repeatedly throwing perfect dice .

The is intended to be useful for cryptograpic applications , but it would be against all rules of that kind of application to trust an implementation of without ﬁrst studying it closely .

An means that an integer is required and int is the default .

Distribution Precondition Defaults Result .

The simplest is the famous curve " that Numerics Chapter distributes values symmetrically around peak with the distance of elements from the mean being controlled by standard deviation parameter : Distribution Precondition Defaults Result , exp , exp .

Such representations are easily generated and even more easily found on the Web .

Sampling distributions map integers into speciﬁc range according to their probability density function : Distribution Precondition Defaults Result none .

In particular , the bits of random number are often suspect , so is not good portable way of generating random number between and .
Often , gives acceptable results .
However , for serious applications , generators based on will give more reliable results .

call starts new of random numbers from the  giv en as argument .

For debugging , it is often important that of random numbers from given be repeatable .
However , we often want to start each real run with new .
In fact , to make games unpredictable , it is often useful to pick from the environment of program .
For such programs , some bits from clock often make good .

If you are not certain about the mathematical aspects of numerical problem , either take expert advice , experiment , or do both ;

Memory Model Memory Location ; Instruction Reordering ; Memory Order ; Data Races .

Atomics atomic Types ; Flags and Fences .

Advice Introduction Concurrency the execution of several tasks simultaneously is widely used to improve throughput using several processors for single or to improve responsiveness allowing one part of program to progress while another is waiting for .

The standard support for concurrency is introduced in tutorial manner in .
This chapter and the next provide more detailed and systematic view .

We call an activity potentially executed concurrently with other activities task .
thread is the representation of facilities for executing task .
thread can execute task .
thread may share an address space with other threads .
That is , all threads in single address space can access the same memory locations .
One of the central challenges of the programmer of concurrent system is to make sure that threads access memory in sensible manner .

The standard support for concurrency includes : Concurrency Chapter .

memory model : set of guarantees for concurrent access to memory that basically ensures that simple and ordinary access works as one would naively expect .

Support for programming without locks : mechanisms for avoiding .

thread library : set of components supporting traditional system .

task support library : few facilities supporting concurrent programming : future , These topics are ordered from the most fundamental and to the .
The memory model is common to all programming .
For programmer productivity and error minimization , work at the highest feasible level .
For example , prefer future over mutex for exchanging information and mutex over an atomic for anything but simple counters and the like .
Leave the complexities to implementers whenever feasible .

In the context of the standard library , lock is mutex mutual exclusion and any abstraction built upon mutex to provide mutually exclusive access to resource or to synchronize the progress of several concurrent tasks .

The topic of processes , that is , threads of execution in their own address spaces and communicating though communication mechanisms , is not addressed in this book .
suspect that after reading about the problems with and techniques for managing shared data , you may become sympathetic to my view that explicitly shared data is best avoided .
Naturally , communication implies some form of sharing , but that sharing most often need not be directly managed by the application programmer .

Please also note that as long as you pass pointers to your local data to other threads , your local data is free of the problems mentioned here .
This is yet another reason to avoid global data .

This chapter is not comprehensive guide to concurrent programming or even complete explanation of the facilities for concurrent programming .

basic description of the problems facing programmer who has to deal with concurrency at the system level .

fairly detailed overview of the concurrency facilities provided by the standard .

An introduction to the basic uses of the concurrency features at the level and above It does .

Go into details of the relaxed memory models or programming .

Teach advanced concurrent programming and design techniques Concurrent and parallel programming have been popular topics of research and widely used for more than years , so there is an extensive specialized literature example , for concurrency see .
In particular , just about any presentation of POSIX threads can be used as source of examples that can be easily improved by using the facilities described here .

In contrast to the POSIX facilities and to many older libraries , the thread support is .
There is no longer any reason to mess around with macros or to pass information among threads .
Similarly , we can deﬁne tasks as function objects , and pass them to threads without using casts or worrying about type violations .
Furthermore , there is no reason to invent elaborate conventions for reporting errors from one Section Introduction thread to another ; futures , can transmit exceptions .
Given that concurrent software is often complex and that code running in different threads is often separately developed , consider type safety and standard strategy even more important than for software .
The thread support also greatly simpliﬁes notation .

These components rely on set of language guarantees known as the memory model .
memory model is the result of discussions between machine architects and compiler writers about how best to represent computer hardware .
The memory model , as speciﬁed in the ISO standard , represents contract between the implementers and the programmers to ensure that most programmers do not have to think about the details of modern computer hardware .

To understand the problems involved , keep one simple fact in mind : operations on an object in memory are never directly performed on the object in memory .
Instead , the object is loaded into processor register , modiﬁed there , and then written back .
Worse still , an object is typically ﬁrst loaded from the main memory into cache memory and from there to register .
For example , consider incrementing simple integer : add one to : load into cache element Cx load Cx into register ; store back into Cx store Cx back into Memory can be shared by several threads , and cache memory may on the machine be shared among threads running on the same or different units " called something like processors , cores , or ; this is an area of rapid evolution of both system facilities and .
This opens host of opportunities for simple operation as one to to get corrupted .
It will be obvious to machine architecture experts that am simplifying .
For the few who notice that have not mentioned store buffers , recommend Appendix of .

Consider what might Concurrency Chapter the machine could not load or store anything smaller than word : word : Without and reasonable memory model , thread might read the word containing and  change  and write the word back into memory .
At the same time , thread could do the same with .
Then , whichever thread managed to read the word ﬁrst and whichever thread managed to write its result back into memory last would determine the result .

The memory model saves us from such chaos ; we get .
The reason that cannot happen is that the initializations of and are done the compiler or the before either thread starts .

The memory model guarantees that two threads of execution can update and access separate memory locations without interfering with each other .
This is exactly what we would naively expect .
It is the job to protect us from the sometimes very strange and subtle behaviors of modern hardware .
How compiler and hardware combination achieves that is up to the compiler .
We program " that is provided by combination of hardware and very software .

give access to parts of word .
If two threads simultaneously access two ﬁelds of the same word , all bets are off .
If and are two ﬁelds of the same word , most hardware has no way of avoiding the problem race from the example without using some form of very locking .
Lock and unlock operations are not cost we could implicitly impose on , which are commonly used in critical device drivers .
Consequently , the language deﬁnes memory location as the unit of memory for which sensible behavior is guaranteed to exclude individual .

memory location is either an object of arithmetic type , pointer , or maximal sequence of adjacent all having nonzero width .

Here , has exactly four separate memory locations .
try to update and from separate threads without explicit synchronization .

From the explanation above , you might conclude that if and are of the same type , is guaranteed to result in being copy of .
This is true if and only if you hav data race and if and are memory locations .
However , if and are of multiword struct they are not single memory location , and if you have data race , all behavior is undeﬁned , so make sure you have proper synchronization in place if you share data ,

For this piece of code there is no stated reason to assign to before assigning to .
The optimizer the hardware instruction may decide to speed up the program by executing ﬁrst .

We probably meant for to indicate whether had been initialized by or not .

However , we did not say that , so the hardware , the compiler , and the optimizer do not know that .

Add another thread to the .

Even if thread did not set and in wrong " we still may have problem .
In thread , there are no assignments to  so an optimizer may decide to lift the evaluation of out of the loop , so that thread either never sleeps or sleeps forever .

At best , maybe instructions are executed before the reaches the register , and another instructions are executed before new reaches its intended location .
The ﬁgure is guess that depends on machine architecture and varies over time , but for the last decades it has steadily increased .
When there is no rush to load and store particular because the computation is optimized for throughput , the time taken can be much higher .
can be from its location " for tens of thousands of instruction cycles .
This is one of the facts that give modern hardware its amazing performance , but it also opens huge Concurrency Chapter opportunities for confusion as different threads look at at different times and in different places in the memory hierarchy .
For example , my simpliﬁed description mentions only single cache ; many popular architectures use cache .
To illustrate , here is diagram of possible cache architecture where each core has its own cache , pair of cores share cache , and all cores share the memory : memory cache cache cache cache core core cache cache core core Memory ordering is the term used to describe what programmer can assume about what thread sees when it looks at from memory .
The simplest memory order is called sequentially consistent .
In sequentially consistent memory model , every thread sees the effects of every operation done in the same order .
The order is as if the instructions were done sequentially in single thread .

thread can still reorder operations , but at every point where another thread might observe variable , the set of operations performed before and the of the memory location observed must be well deﬁned and the same for all threads .
An operation that " and thereby forces consistent view of memory location is called an atomic operation .
simple read or write does not impose an order .

There are many possible sequentially consistent orders for given set of threads .

The only result we cannot get is .
Obviously , to get predictable result , you need some form of synchronization of the access to the shared variables .

The sequential consistent order is just about all programmer can effectively reason about , but on some machine architectures it imposes signiﬁcant synchronization costs that can be eliminated by relaxing the rules .
For example , two threads running on separate cores might decide to initiate the reads of and before the writes of and or at least before the writes had completed .
That could give the nonsequentially consistent result .
More relaxed memory models allow that .

First , we must avoid data races .
Two threads have data race if both can access memory location deﬁned in simultaneously and at least one of their accesses is write .
Note that deﬁning " precisely is not trivial .
If two threads have data race , no language guarantees hold : the behavior is undeﬁned .
This may sound drastic , but the effects of data race can shown in be drastic .
An optimizer hardware instruction may reorder code based on assumptions about values and may execute sections of code apparently unrelated or not based on such assumptions .

There are many ways of avoiding data .

Use only single thread .
That eliminates the beneﬁts of concurrency you use processes or .

Put lock on every data item that might conceivably be subject to data race .
That can eliminate the beneﬁts of concurrency almost as effectively as single threading because we easily get into situation where all but one thread waits .
Worse still , heavy use of locks increases the chances of deadlock , where thread waits for another forever , and other locking problems .

Try to look carefully at the code and avoid data races by selectively adding locks .
This may be the currently most popular approach , but it is .

Hav program detect all data races and either report them for the programmer to ﬁx or automatically insert locks .
Programs that can do that for programs of commercial size and complexity are not common .
Programs that can do that and also guarantee the absence of deadlocks are still research projects .

Design the code so that threads communicate only through simple interfaces that do not require two threads to directly manipulate single memory location ,

Use library or tool that makes data sharing concurrency implicit or sufﬁciently stylized to make sharing manageable .
Examples include parallel implementations of algorithms in library , tools , and transactional memory abbreviated to .

One way of looking at the rest of this chapter is as approach to arrive at support for one variant of that last style of programming .
In the process , we encounter the tools needed to support just about every way of avoiding data races .

Why must programmers suffer all this complexity .
An alternative would be to provide only simple , sequentially consistent model with minimal opportunities for data races .
can offer two reasons : That is not the way the world is .
The complexities of machine architectures are real , and systems programming language , such as , must provide the tools for programmers to live with them .
Maybe someday machine architects will deliver simpler alternatives , but for now someone must deal with bewildering variety of facilities provided by machine architects to deliver the performance that their customers demand .

We would have liked to provide memory model that was an improved version of what Java and provide .

Howev er , this idea was effectively vetoed by the providers of operating systems and virtual machines : they insisted that they needed roughly what was then provided by the various implementations what is now provided by the standard .
The alternative would be for your operating systems and your virtual machines to slow down factor of two or " guess that programming language fanatics might have welcomed an opportunity to simplify at the expense of other languages , but doing so would have been neither practical nor professional .

Fortunately , most programmers never hav to work directly at the lowest level of the hardware .

Most programmers do not need to understand memory model at all and can think of reordering problems as amusing curiosities : Write code and mess with memory order ; then the memory model guarantees that code executes as naively expected .
even better than sequential consistency .

ﬁnd machine architecture fascinating topic , see , but as sensible and productive programmers , we stay away from the lowest levels of software whenever we can .
Leave those for the experts and enjoy the higher levels that those experts provide for you .

Instead , the programmer relies on primitive operations supported by to avoid data races for small objects single word or double .

Primitive operations that do not suffer data races , often called atomic operations , can then be used in the implementation of concurrency mechanisms , such as locks , threads , and lockfree data structures .

With the notable exception of simple atomic counters , programming is for specialists .

In addition to an understanding of language mechanisms , detailed understanding of speciﬁc machine architectures and knowledge of somewhat specialized implementation techniques are needed .
Do not try programming with only the information provided here .
The primary logical advantage of techniques over techniques is that classical locking problems , such as deadlock and starvation , cannot happen .
For each atomic operation , it is guaranteed that every thread will eventually typically make progress even if other threads compete for access to an atomic object .
In addition , techniques can be signiﬁcantly faster than alternatives .

The standard atomic types and operations provide portable alternative to traditional ways of expressing code .
Those typically either rely on assembly code or primitives .
In this sense , the standard support for atomics is another step in and long tradition of increasing portable and relatively comprehensible support for systems programming .

synchronization operation is something that determines when thread sees the effects of another thread ; it determines what is considered to have happened before something else .
Between synchronization operations compiler and processor are free to reorder code as long as the semantic rules of the language are maintained .
In principle , nobody is looking and all that is affected is performance .
synchronization operation on one or more memory locations is Section Atomics consume operation , an acquire operation , release operation , or both an acquire and release operation .

For an acquire operation , other processors will see its effect before any subsequent effect .

For release operation , other processors will see every preceding effect before the effect of the operation itself .

consume operation is weaker form of an acquire operation .
For consume operation , other processors will see its effect before any subsequent effect , except that effects that do not depend on the consume value may happen before the consume operation .

An atomic operation ensures that the state of the memory is as required by the speciﬁed memory order .
By default , the memory order is consistent ;
The standard memory orders are : enum ,    The enumerations .

As an example , consider using atomic loads and stores to express relaxed memory .

It is entirely whether given memory order makes sense .
Clearly , relaxed memory model is not something to be directly used in applications programming .
Utilizing relaxed memory model is an even more specialized task than general programming .
see it as something done by small subset of operating system kernel , device driver , and virtual machine implementers .
It can also be useful in code gotos can .
If two threads really do not directly share data , some machine architectures deliver signiﬁcant performance improvements through the use of relaxed memory model at the cost of complexity in the implementation of primitives , future and promise ;

To allow signiﬁcant optimizations for architectures with relaxed memory models , the standard provides an attribute for transmitting memory order dependencies across function calls .

You can also put on function arguments , and there is function for stopping the propagation of such dependencies .

One of the designers of the memory model , Lawrence Crowl , summarizes : ordering is probably the most complex concurrency feature .

Given that , we will get the output Hello , World .

Hello , We will not get corrupted or some output characters .

The operation is used when we have some other work we might usefully do if some other is using resource .
As an example , consider work generator that composes work requests for other tasks and places them on work .

When some server is examining wq , the simply makes some more work instead of waiting .

That is , we must not wait for lock that can never be released .
The simplest form of deadlock requires only one lock and one .
Consider variant of the output operation : 

Now , if calls , it will deadlock with itself when it tries the recursive call for the tail .

Recursive and mutually recursive calls are common enough for the standard to provide solution .
is just like plain  except that single can acquire it repeatedly .
For example : changed to to avoid deadlock .

Now the recursive call of is correctly handled by .

If so , the operation throws .
Some of the possible errors reﬂect conditions in the underlying system : deadlock would occur Some native handle is not available The is not allowed to perform the operation Some native handle is already locked constructor native handle argument is bad For example : Threads and Tasks Chapter .

got the output device or resource busy generic : This looks like good argument for using or .

If we want to block , we can use , but when we fail to acquire mtx , we often want to wait for while before trying again .
The and offer support for that : Default constructor ; is not owned ; constexpr ; noexcept .

Release system type is the system handle for the The interface is identical to the interface as the interface is identical to the .

More generally , we can or for .

As an example , consider updating an output buffer with new , in video game or : extern imtx ; extern Image buf ; Section and .

The assumption here is that if the cannot be updated reasonably fast , in , the user would prefer newer version of the .
Further , it is assumed that missing an in sequence of updated images will rarely be noticed , so that more complicated solution is not needed .

That is , each operation must be matched by an operation .
The usual opportunities for mistakes exist ; for .

The is there , but if or if is out of vs ' range and vs is range checked , the thread of execution never gets to the and mtx may be locked forever .

The standard library provides two RAII classes , and , to handle such problems .

The " is the simplest , smallest , and fastest guard .
In exchange for added functionality , carries small cost , which may or may not be signiﬁcant for given application on given machine .

As usual , we should only hold lock for the minimal amount of time , so should not become an excuse for holding lock until the end of large scope if we only need the lock for small section of the scope .
Obviously , the checking of does not require locking , so we could do that before acquiring the .

Is such complication of the worthwhile .
Without looking at the in the " we cannot tell , but we should deﬁnitely not use just out of unwillingness to consider where locking is needed .
Minimizing the size of critical sections is in general useful thing to do .

If nothing else , it forces us to think about exactly where lock is needed and why .

So , also is resource handle for an object that you can lock to acquire ownership and unlock to release .

The obvious lockable object is of mutex type , but users can deﬁne their own .

is very simple class with no interesting operations .
All it does is RAII for mutex .
To get an object that provides RAII and operations on contained mutex , we use : is lockable object lck ; Default constructor : lck does not hold .

For example : Threads and Tasks Chapter .

Unfortunately , acquiring two locks implies the opportunity of deadlock .
For example : mutex ; protects one resource .

It is needed to pass reference through variadic template thread constructor ;
mutex cannot be copied or moved , so must pass them by reference use .

Change the names from and to something that does not indicate order and separate the deﬁnitions of and from each other in the source text and it will no longer be obvious that there is good chance that the program will eventually deadlock with owning , owning , and each trying to acquire its second mutex forever .

Try to acquire all members of locks ; the locks are acquired in order ; if all locks were acquired ; otherwise .

Acquire all members of locks ; do not deadlock .

The type and the function offer , efﬁcient , and simple tool for that .

use the double underscore preﬁx to emphasize that this latter version represents compilergenerated code .

See is the system handle for cv may may rely on system resources , so constructor may fail for lack of such resource .
However , like mutex , cannot be copied or moved , so it is best to think of as resource in itself , rather than as handle .

When is destroyed , all waiting threads must be notiﬁed , told to wake or they may wait forever .

The status returned by and is deﬁned as : enum class , timeout ; is used by the wait functions to prevent being lost due to contention on the list of waiting threads .

The " is operation that should be used with extra care and usually in the implementation of some abstraction .
It can wake up " That is , the system may decide to resume thread ev en though no other thread has notiﬁed it .

Always use " in loop .
For example : while ; An additional reason for this loop is that some thread may have up " and invalidated the condition , before the thread calling the unconditional got to run .
Such loop basically is the implementation of wait with condition , so prefer those over the unconditional .

The releases its mutex as it goes to sleep and reacquires it as its thread is unblocked .
Finally , lck releases the mutex at the end of its scope .

Another simple use of is to control the ﬂow of messages from producer to consumer : class .

That is , producer acquires the mutex , adds value at the end of the queue , calls Section Condition Variables to wake possibly blocked consumer , and implicitly releases the mutex .
provided an rvalue version of so that we can transmit objects of types that have move , but not copy , operations , such as , and .

used rather than because only added one element and wanted to keep simple .
The possibility of multiple consumers and the possibility of consumers falling behind the producer might make me reconsider .

The is bit more complicated because it should only block its thread if the mutex precludes access or if the queue is empty :

caller of will remain blocked until the is nonempty .

used rather than plain because the is optimized for simplicity and does not offer the operations needed to unlock and relock the mutex .

used to enable the lambda to access the object .

return the value from through reference argument , rather than as return value , to be sure that an element type with copy constructor that can throw will not cause trouble .
That is the conventional technique , the STL stack adaptor provides and the containers provide .
Writing general that directly returns value is possible , but surprisingly tricky .
For an example , see .

Had we simply used mutex to control access to the  the consumer would have had to repeatedly wake up , look for work on the queue , and decide what to do when it found the queue empty .

copy values into and out of the use to hold my queue elements .
copy of an element type may throw an exception , but if it does , the will remain unchanged and the or simply fails .

is not itself shared data structure , so we don ' use separate mutex for it ; only need to be protected against data races .

For some applications , the simple has fatal ﬂaw : What if consumer waits forever because producer stopped adding values .
What if consumer has other things to do so that it cannot wait for long time .
Often there are answers , but one common technique is to add timeout to , that is , to specify maximum time to .

Actually , we don ' really care about the timeout , but only whether the predicate in the is true or not , so that is what returns .
chose to report the failure of with timeout by throwing an exception .
Had thought that timing out would be common and " event , would have returned bool instead .

For , the alternative of returning bool to encourage the producer to always explicitly handle both cases seems more attractive than for .
Howev er , to avoid getting into discussion of how best to handle overﬂow , again chose to signal failure by throwing an exception .

chose to if the queue was full .
Maybe , some consumer needs nudge to continue .

The choice between and depends on the behavior of the application and is not always obvious .
Notifying just one thread serializes access to the queue and could therefore minimize throughput when there are several potential consumers .
On the other hand , notifying all waiting threads may wake up sev eral threads , causing contention on the mutex and possibly having threads repeatedly waking up just to ﬁnd the queue empty by other .
fall back on the old rule : Don ' trust your intuition ; measure .

is functionally equivalent to but can use any lockable object for its operations : lck can be any lockable object with the operations required .

For many concurrent tasks , ﬁnd this focus on mechanisms distracting from the real task of specifying concurrent tasks .
This section focuses on specifying simple kind of task : task that does one thing given arguments and produces one result .

Please keep in mind the fundamental simplicity of the task model .
Most of the more complicated details support rare uses , such as hiding uses of the messier level .

The task support is just one example of what can be done to support concurrency .
Often , we would like to provide lot of small tasks and let system " worry about how to map their execution onto hardware resources and how to keep them out of problems with data races , spurious , excessive waits , etc .

The importance of these facilities is their simplicity to programmer .
In sequential program , we usually write something like : perfor task given arguments and get the result The concurrent version .

By default , use the simplest technique and reserve the more complex solutions for where you know that they are really worthwhile .

task puts its result into promise , and task that needs the result retrieves the result from the corresponding  promise value task : task : The " in this diagram is technically known as the shared state .
In addition to Section future and promise the return value or exception , it contains the information needed for two threads to safely exchange the information .
At minimum , shared state must be able to .

value of the appropriate type or an exception .
For future void " the value is nothing .

ready bit to indicate whether value or exception is ready to be extracted by future .

The task to be executed when is called for future for task launched by with the launch policy deferred .

use count , so that the shared state can be destroyed when and only when its last potential user relinquishes access .
In particular , if stored value is of class with destructor , its destructor is called when the use count goes to zero .

Some mutual exclusion data to enable unblocking of any thread that might be waiting ,

An implementation can take actions on shared .

Construct : Possibly using allocator .

Make ready : Set the bit " and unblock any waiting threads .

Release : Decrease the use count and destroy the shared state if this was the last user .

Abandon : If it becomes impossible for value or exception to be put into the shared state by promise , because the promise is , exception with the error condition is stored in the shared state and the shared state is made ready .

It is where task can deposit its result to be retrieved through future .

Set the result of the task for void future The result of the task is the exception pointed to by ; is an Threads and Tasks Chapter The result of the task is the value .

set function throws if value or exception is already set .

It is only possible to transmit single result value through .
That may seem restrictive , but remember that the value is moved into and out of the shared state , rather than copied , so that we can cheaply pass collection of objects .
For example : 

When our task executes return , it causes on the .

offers fairly conventional set of operations : Section .

Exchange the values of and ; noexcept .

may copy its task , and copy of task is assumed to yield the same result as the original .
This is important because task may be moved with its onto the stack of new .

To abandon shared state is done by the destructor and the means making it ready .
If there is no value or exception stored , pointer to is stored .

The advantage of is that the result is not available until destructors for variables have been executed .

There is no operation to match .
The use of the is completely handled by the .

For really simple example we even need any threads .
First deﬁne simple .

We can now package this function into and call them : Threads and Tasks Chapter .

In particular , we see the exception triggered by .
In fact , did on the attached to , and did on the attached to ; that px is an to .

Later , we can try to retrieve the results .
The operation is used to hold of the future into which the packaged will deposit the result of its task .

The point is that the version works exactly like the version using ordinary function calls even when the calls of the task and the calls of the are in different threads .
We can concentrate on specifying the tasks , rather than thinking about threads and locks .

We can move the future , the  or both around .
Eventually , the is invoked and its task deposits its result in the future without having to know either which executed it or which will receive the result .
This is simple and general .

Consider that processes series of requests .
It could be GUI  owning access to piece of specialized hardware , or indeed any server that serializes access to resource through queue .
We can implement such service as queue of messages , or we could pass tasks to be executed : using result type for server ; using argument types for server ; Section .

The server would take the from the server queue and execute them in some suitable order .
Typically , the tasks would carry data with them from the calling context .

The tasks are written essentially like ordinary functions , function objects , and lambdas .
The server calls the tasks essentially like ordinary functions .
The are actually easier for the server to use than ordinary functions because the handling of their exceptions has been taken care of .

It is where task can retrieve result deposited by .

Move assignment : gets shared state , if any ; no longer has shared state ; release old shared state , if any Threads and Tasks Chapter Move value into  no longer has shared state .

Block until value arrives or until tp ; tells if value is ready , timeout occurred , or execution was deferred holds unique value and offers no copy operations .

The value , if any , is moved out of .
So can only be called once .
If you potentially need to read result several times , by different , use .

It is undeﬁned happens if you try to twice .
In fact , it is undeﬁned happens if you try to do any operation except ﬁrst , or destructor on that is not .

The standard " an implementation to throw with the error condition in such cases .

If value type , is void or reference , special rules apply for .

reference an object , so the library must have transmitted something else , such as , and converts that into .

The status of can be observed by calling and : enum class ready The has value timeout The operation timed out deferred The possible errors from operations on futures are : Errors : promise abandoned the state before supplying value second on An operation tried to access shared state In addition , an operation on the value of could possibly throw , an unusual move .

Looking at the table , ﬁnd that miss two useful .

Ideally , my thread would be blocked and unblocked at most once .
However , for many uses , this implementation is good enough : if some of the tasks are , the extra waits will not be signiﬁcant .
On the other hand , if all tasks are short , they will most likely have ﬁnished after the ﬁrst wait .

An implementation of is trickier .
First we need way of checking if is ready .

For example : Using to the status of is not obvious , but will tell us why it resumed , and it tests for ready before suspending .
It is common , but unfortunately not guaranteed , that returns immediately rather than trying to suspend for zero time .

Given , we can write :

decided to consider deferred task an error for my uses .

Note the check for .
Trying on an invalid , on which you have already done will cause error .
At best , you can hope for exception being thrown .

This simple implementation only approximates that .
With large useless is unlikely but implies the possibility of an unnecessarily long wait .

The and functions are useful building blocks for concurrent algorithms .

Thus , if you want to read the value repeatedly or potentially have it read by multiple readers , you must copy it , and then read the copy .

Every usable is directly or indirectly initialized by moving the value out of with the same result type .

Copy and move constructor ; the move constructor is noexcept Destructor : release the shared state , if any Copy assignment Move assignment ; noexcept .

Block until value arrives or until tp ; tells if value is ready , timeout occurred , or execution was deferred Obviously , is very similar to .
The key difference is that moves its value to location where it can be repeatedly read and shared .
As for , special rules apply for when ' value type , is void or .

reference an object , so the library must have transmitted something else , such as , and converts that into .

Unless the returned object is reference , it is const , so it can safely be accessed from several threads without synchronization .
If the returned object is reference , you need some form of mutual exclusion to avoid data races on the object .

Given those , is just something you give task to run .

However , we still need to consider how many threads to use and whether task is best run on the current or on another .
Such decisions can be delegated to launcher , that is , function that decides whether to create new  to recycle an old  or simply run the task on the current .

For example , we can easily imagine programmer wanting to give the launcher hint about how long task is likely to run .
However , only two policies are currently standard : Launch Policies : launch Execute the task as if new was created to do so deferred Execute the task at the point of for the task ' Note the as if .
The launcher has wide discretionary powers when it comes to launching new not .
For example , since the default policy is , it is not too fanciful to imagine an that decided to use deferred for , so that the execution reduced to calling .
could even imagine an optimizer reducing that whole code fragment to double ; However , we should not expect an implementation of to be optimized for such trivial examples .
Implementer efforts are better spent on realistic examples where the task performs signiﬁcant amount of computation so that launching on new " could be reasonably considered .

Depending on the implementation of system threads , this can drastically lower the cost of executing task on .
If is recycled , the launcher must take care that task does not see leftover state from previous task executed on the and that task does not store pointers to its stack data in nonlocal storage .
Such data could conceivably be used for security violations .

simple and realistic use of would be to spawn task to collect from .

Such task often requires some data from the caller .
used lambda to make it obvious that can pass arguments allow access to local variables .
When using lambda to specify task , beware of capturing local variables by reference .
That could lead to data races unfortunate cache access patterns by two threads accessing the same stack frame .
Also , beware that capturing members of an object using implies that the members of the object are accessed indirectly , rather than copied , so that the object is subject to data races unless you make certain that it is not .
If in doubt , copy capture by 

It is often important that we can select scheduling policy " and change it as needed .
For example , might use for initial debugging .
That would eliminate errors related to concurrency until had eliminated sequential errors .
Also , can often go back to to determine if an error really is related to concurrency .

Over time , more launch policies may become available , and maybe some systems offer better launch policies than others .
In such cases , might be able to improve the performance of my code by local change of launch policy , rather than by reworking subtle details of the program logic .

This , again , is an effect of the fundamental simplicity of the model .

Having as the default launch policy can be practical problem .

Basically , it is not so much default as lacking design decision .
An implementation might decide that concurrency " is good idea and always use .
If your experiments with concurrency show results surprisingly similar to execution , try being explicit about the launch policy .

Imagine having millions of items that are not easily sorted so that is the right algorithm for ﬁnding something .
This could be slow , so instead of searching once starting at the beginning and going until the end , we might start each on hundredth of the data .

First , we represent the data as of Records : extern goods ; data to be searched Section Parallel Example An individual task is simply use of the .

That is , we need to specify the number of records to be searched sequentially .

It is hard to choose well unless lot is known about the hardware , the library implementation , the data , and the algorithm .
Experimentation is essential .
Tools and frameworks that save us from having to pick size help us choose can be most useful .
However , for simple illustration of basic standardlibrary facilities and the most basic techniques for their use , is sufﬁcient .

The function simply does the number of calls required by the and the number of Records .
Then , it the results :

Like , it reports the ﬁrst element that matches the predicate ; that is , it ﬁnds the element with the lowest index that matches .

We could end up waiting for lot of tasks that ﬁnd anything only the last task ﬁnds .

We may throw away lot of information that could be useful thousand items match our .

The ﬁrst problem may not be as bad as it sounds .
Assume that launching cost anything and that we have as many processing units as there are tasks ; then we would still get the result in roughly the time it took to process one task .
That is , we would potentially get our result in the time taken to examine records rather than millions .
If we have processing units , the results will be delivered in batches of results for records .
If no is found until the last segment of the  the time will be roughly units .

Instead of waiting for each task in order , we could try to look at the results in the order the tasks completed .

use to make sure keep looking after all tasks have reported back .
Apart from over depends on lots of things , but the key observation is that to gain advantages of concurrency , we had to use slightly different algorithm .
Like , returns its ﬁrst match , whereas returns whichever match it ﬁrst found .
Often , the best parallel algorithm for problem is variant of the idea for sequential solution , rather than simple repetition of the sequential solution .

In this case , the obvious question is do you really only need one " Giv en concurrency , it makes more sense to ﬁnd all matches .

All we need to do is to let each task return of matches , rather than just simple match : Section Parallel Example .

This is the basic idea that , when developed into framework so that the details of concurrent execution have been completely hidden , is commonly referred to as .

The example can be run like .

To do so , added simple sequential versions to my .

In this case , the cost of thread creation in the immature implementation of dominates the effects of concurrency .
If needed significant parallel speedup right now , would implement my own variant of based on set of threads and work queue , along the lines of of .
Note that such signiﬁcant optimization can be done without changing my with an optimized version is an implementation detail .

The Family .

Date and Time .

Advice Introduction The standard library for the language is with very minor modiﬁcations incorporated into the standard library .
The standard library provides quite few functions that have proven useful over the years in wide variety of contexts especially for relatively programming .

There are more functions than are presented here ; see good textbook , such as and Ritchie " or the ISO standard , if you need to know more .

ﬁle can refer to ﬁle or to one of the standard input and output streams : stdin , stdout , and stderr .
The standard streams are available by default ; other ﬁles need to be opened : The Standard Library Chapter File Open and Close Open ﬁle stream for ﬁle named with the mode is the for the opened ﬁle if successful or nullptr Close ﬁle stream  return if successful ﬁle opened with must be closed by or the ﬁle will remain open until the operating system closes it .
If that is problem considered , use an fstream .

mode is string containing one or more characters specifying how ﬁle is to be opened used after : File Modes Binary ; use together with one or more other modes There may be usually more options on speciﬁc system .
For example , is sometimes used to mean ﬁle must not exist before this open " Some options can be combined , for example , tries to open ﬁle called foo for binary reading .
The modes should be the same for stdio and iostreams .

However , prefer iostreams because that library is and extensible .
The formatted output function , is widely used in and widely imitated in other programming languages : Print the format string fmt to stdout , inserting the arguments args as appropriate Print the format string fmt to ﬁle  inserting the arguments args as appropriate Print the format string fmt to the string , inserting the arguments args as appropriate .

The return value from is essentially always ignored .

The declaration of is : int format ; In other words , it takes string string followed by an arbitrary number of arguments of arbitrary type .
The meaning of those arguments " is controlled by Section The Family conversion speciﬁcations , such as as and as decimal , in the .

The ﬁrst applies to the ﬁrst argument " applies to , the second to the second argument " applies to , and so on .
In particular , the output of that call to is the value of is ' and the value of is ' followed by newline .

In general , the correspondence between conversion directive and the type to which it is applied cannot be checked , and when it can , it usually is not .
For example : value of is ' and the value of is ; oops The set of conversion speciﬁcations is quite large growing over the and provides great degree of ﬂexibility .
Various systems support options beyond the ones offered by the standard .

See also the set of options used for formatting .
Following the , there may be : an optional minus sign that speciﬁes of the converted value in the ﬁeld ; + an optional plus sign that speciﬁes that value of signed type will always begin with + or sign ; an optional zero that speciﬁes that leading zeros are used for padding of numeric value .

If or precision is speciﬁed this is ignored ; an optional that speciﬁes that values will be printed with decimal point ev en if no nonzero digits follow , that trailing zeros will be printed , that octal values will be printed with an initial , and that hexadecimal values will be printed with an initial or ; an optional digit string specifying ﬁeld width ; if the converted value has fewer characters than the ﬁeld width , it will be on the left right , if the indicator has been to make up the ﬁeld width ; if the ﬁeld width begins with zero , zeropadding will be done instead of .

In this case an integer argument supplies the ﬁeld width or precision ; an optional character , specifying that following ,  or corresponds to or short integer argument ; hh an optional pair of characters hh , specifying that following ,  or argument is treated as or char argument ; an optional character , specifying that following ,  or corresponds to or long integer argument ; The Standard Library Chapter ll an optional pair of characters ll , specifying that following ,  or corresponds to or long long integer argument ; an optional character , specifying that following ,  or corresponds to long double argument ; specifying that following ,  or corresponds to or argument ; specifying that following ,  or corresponds to .

The conversion characters and their meanings are : The integer argument is converted to decimal notation ; The integer argument is converted to decimal .

The integer argument is converted to octal .

The integer argument is converted to hexadecimal notation ; The integer argument is converted to hexadecimal notation ; The ﬂoat or double argument is converted to decimal notation in the style .

The number of after the decimal point is equal to the precision for the argument .

If necessary , the number is rounded .
If the precision is missing , six digits are given ; if the precision is explicitly and speciﬁed , no decimal point is printed ; Like but uses capital letters for INF , INFINITY , and NAN .

If necessary , the number is rounded .
If the precision is missing , six digits are given ; if the precision is explicitly and speciﬁed , no digits and no decimal point are printed ; As , but with an uppercase used to identify the exponent ; The ﬂoat or double argument is printed in style , in style , or in style , whichever gives the greatest precision in minimum space ; As , but with an uppercase used to identify the exponent ; The double argument is printed in the hexadecimal format or ; Like but using and instead or and  c The character argument is printed .
Null characters are ignored ; The argument is taken to be string , and characters from the string are printed until null character or until the number of characters indicated by the precision speciﬁcation is reached ; however , if the precision is or missing , all characters up to null are printed ; The argument is taken to be pointer .
The representation printed is implementationdependent ; The unsigned integer argument is converted to decimal notation ; The number of characters written so far by the call of , or is written to the int pointed to by the pointer to int argument .

Here is more elaborate .

Because does not have types in the sense that has , there are no provisions for deﬁning output formats for types , such as complex , vector , or string .
The format for is an example of the contortions you can get into by trying to design yet another set of format speciﬁers .

The standard output , stdout , corresponds to cout .
The standard input , stdin , corresponds to cin .
The standard error output , stderr , corresponds to cerr .
This correspondence between standard and streams is so close that and streams can share buffer .
For example , mix of cout and stdout operations can be used to produce single output stream not uncommon in mixed and .
This ﬂexibility carries cost .
For better performance , mix stdio and iostream operations for single stream .

To ensure that , call before the ﬁrst operation .

Here , tries to read an integer into and sequence of characters into .
character speciﬁes that the input should contain that character .
For example : will read into and string followed by into .
If the call of succeeds , the resulting value in the call will be the number of argument pointers assigned to in the ; otherwise , EOF .
This way of specifying input is , what would happen if you forgot the space after string on that input .
All arguments to must be pointers .
The Standard Library Chapter strongly recommend against the use of .

So what can we do for input if we are obliged to use stdio .
One popular answer is the .

If an is encountered or if an error occurred , is set to the nullptr ; otherwise , it is set to .

Nev er use or its rough equivalent .
For years , they were the favorites of virus writers : By providing an input that overﬂows the input buffer in the , program can be corrupted and computer potentially taken over by an attacker .
The function can suffer similar problems .
The version of the standard library offers whole alternate set of stdio input functions that take an extra argument to defend against overﬂow , such as .
As for unformatted input , that leaves the user with the problem of deciding exactly which termination condition was encountered ; too many characters , terminator character , or an .

The stdio library also provides simple and useful character read and write functions : Stdio Character Functions .

For example , this is typical input loop : int .

thread support , ctype facet .
