Southern Adventist University .

Legal Notices and Information .

Permission is hereby granted to make hardcopies and freely distribute the material herein under the following .

The copyright and this legal notice must appear in any copies of this document made in whole or in part .

None of material herein can be sold or otherwise distributed for commercial purposes without written permission of the copyright holder .

Instructors at any educational institution may freely use this document in their classes as primary or optional textbook under the conditions specified above .

local electronic copy of this document may be made under the terms specified for hard .

The copyright and these terms of use must appear in any electronic representation of this document made in whole or in part .

None of material herein can be sold or otherwise distributed in an electronic form for commercial purposes without written permission of the copyright holder .

Instructors at any educational institution may freely store this document in electronic form on local server as primary or optional textbook under the conditions specified above .

Additionally , hardcopy or local electronic copy must contain the uniform resource locator .

Simply send message to .

computer program , from one perspective , is sequence of instructions that dictate the flow of cal impulses within computer system .
These impulses affect the memory and interact with the display screen , keyboard , mouse , and perhaps even other computers across network in such way as to produce the " that permits humans to perform useful tasks , solve problems , and play games .
One program allows computer to assume the role of financial calculator , while another transforms the machine into worthy chess opponent .
Note the two extremes .

So well is the illusion achieved that most computer users are oblivious to the activity machinery under the hood , so to .
Surprisingly , perhaps , most programmers today write software at this higher , more abstract level also .
An accomplished computer programmer can develop sophisticated software with little or no interest or knowledge of the actual computer system upon which it runs .
Powerful software construction tools hide the details from programmers , allowing them to solve problems in terms .

The concepts of computer programming are logical and mathematical in nature .
In theory , computer programs can be developed without the use of computer .
Programmers can discuss the viability of program and reason about its correctness and efficiency by examining abstract symbols that correspond to the features of programming languages but appear in no programming language .

While such exercises can be very valuable , in practice computer programmers are not isolated from their machines .
Software is written to be used on real computer systems .
Computing professionals known as software engineers develop software to drive particular systems .
These systems are defined by their underlying hardware and operating system .
Developers use concrete tools like compilers , debuggers , and profilers .
This chapter examines the context of software development , including computer systems and tools .

Software makes computer truly universal machine transforming it into the proper tool for the task at hand .
One can refer to program as piece of software as if it were tangible object , but software is actually quite intangible .
It is stored on medium .
hard drive , CD , DVD , and USB pen drive are all examples of media upon which software can reside .

The CD is not the software ; the software is pattern on the CD .
In order to be used , software must be stored in the memory .
Typically computer programs are loaded into memory from medium like the hard disk .
An electromagnetic pattern representing the program is stored on the hard drive .
This pattern of electronic symbols must be transferred to the memory before the program can be executed .
The program may have been installed on the hard disk from CD or from the Internet .
In any case , the essence that was transferred from medium to medium was pattern of electronic symbols that direct the work of the computer system .

These patterns of electronic symbols are best represented as sequence of zeroes and ones , digits from the binary number system .
An example of binary program sequence is To the underlying computer hardware , specifically the processor , zero here and three ones there might mean that certain electrical signals should be sent to the graphics device so that it makes certain part of the display screen red .
Unfortunately , only minuscule number of people in the world would be able to produce , by hand , the complete sequence of zeroes and ones that represent the program Microsoft Word for an computer running the Windows operating system .
Further , almost none of those who could produce the binary sequence would claim to enjoy the task .

The Word program for older Mac OS computers using PowerPC processor works similarly to the Windows version and indeed is produced by the same company , but the program is expressed in pletely different sequence of zeroes and ones .
The Intel Core processor in the Windows machine accepts completely different binary language than the PowerPC processor in the Mac .
We say the processors have their own machine language .

If very few humans can to speak the machine language of the computers ' processors and software is expressed in this language , how has so much software been developed over the years .

Software can be represented by printed words and symbols that are easier for humans to manage than binary sequences .
Tools exist that automatically convert description of what is to be done into the required code .
programming languages like allow programmers to express solutions to programming problems in terms that are much closer to natural language like English .

Some examples of the more popular of the hundreds of programming languages that have been devised over the past years include FORTRAN , COBOL , Lisp , Haskell , Perl , Python , Java , and .

Most programmers today , especially those concerned with applications , usually do not worry about the details of underlying hardware platform and its machine language .

One might think that ideally such conversion tool would accept description in natural language , such as English , and produce the desired executable code .
This is not possible today because natural languages are quite complex compared to computer programming languages .
Programs called compilers that translate one computer language into another have been around for over years , but natural language .

Natural languages , as they are used by most humans , are inherently ambiguous .
To understand properly all but very limited subset of natural language , human artificially intelligent computer requires vast amount of background knowledge that is beyond the capabilities of software .
Fortunately , programming languages provide relatively simple structure with very strict rules for forming statements that can express solution to any problem that can be solved by computer .

Consider the following program fragment written in the programming .

The statements in this program fragment look similar to expressions in algebra .
We see no sequence of nary digits .
Three words ,   and  called variables , are used to hold information .

Mathematicians have used variables for hundreds of years before the first digital computer was built .
In programming , variable represents value stored in the memory .

Since this program is expressed in the language , not language , it cannot be executed directly on any processor .
compiler is used to translate the code into code .

The language code is called source code .
The compiled language code is called the target code .
The compiler translates the source code into the target language .

The beauty of languages is this : the same source code can be compiled to different target platforms .
The target must have compiler available .
Minor changes in the source code may be required because of architectural differences in the platforms , but the work to move the program from one to another is far less than would be necessary if the program for the new had to be rewritten by hand in the new language .
Just as importantly , when writing the program the human programmer is free to think about writing the solution to the problem in , not in specific language .

Programmers have variety of tools available to enhance the software development process .
Some common tools .

An editor allows the user to enter the program source code and save it to files .
Most gramming editors increase programmer productivity by using colors to highlight language features .

The syntax of language refers to the way pieces of the language are arranged to make sentences .
To illustrate , the sentence The tall boy runs quickly to the door .

Boy the tall runs door to quickly the .

It uses the same words as the original sentence , but their arrangement does not follow the rules of English .

Similarly , programmers must follow strict syntax rules to create computer programs .

Only programs are acceptable and can be compiled and executed .
Some editors can use colors or other special annotations to alert programmers of syntax errors before the program is compiled .

compiler translates the source code to target code .
The target code may be the language for particular or embedded device .
The target code could be another source language ; for example , the earliest compiler translated into , another language .

The resulting code was then processed by compiler to produce an executable program .
compilers today translate directly into language .

The complete set of build tools for includes preprocessor , compiler , and linker : Preprocessor to or modifies the contents of the source file before the compiler begins processing the code .
We use the services of the preprocessor mainly to nclude information about library routines our programs use .

Most compiled code is incapable of running by itself and needs some additional code to make complete executable program .
The missing code has been precompiled and stored in repository of code called library .
program called linker combines the compiled code and the library code to make complete program .

We generally do not think about the preprocessor , compiler , and linker working as three separate programs they ; the tools we use make it appear as only one process is taking place : translating our source code to an executable program .

debugger allows programmer to more easily trace execution in order to locate and correct errors in the implementation .
With debugger , developer can simultaneously run program and see which line in the source code is responsible for the current actions .
The programmer can watch the values of variables and other program elements to see if their values change as expected .
Debuggers are valuable for locating errors called bags and repairing programs that contain errors .

profiler collects statistics about execution allowing developers to tune propriate parts of the program to improve its overall performance .
profiler indicates how many times portion of program is executed during particular run , and how long that portion takes to execute .
Profilers also can be used for testing purposes to ensure all the code in program is actually being used somewhere during testing .
This is known as coverage .
It is common for software to fail after its release because users exercise some part of the program that was not executed anytime during testing .
The main purpose of profiling is to find the parts of program that can be improved to make the program run faster .

The programming components of the development process are illustrated in Figure Many developers use integrated development environments .
An IDE includes editors , gers , and other programming aids in one comprehensive program .
Examples of IDEs for include Visual Studio , the Eclipse Eclipse CDT , and XCode .

Despite the plethora of tools tool vendors ' the programming process for all but trivial programs is not automatic .
Good tools are valuable and certainly increase the productivity of developers , but they cannot write software .
There are no substitutes for sound logical thinking , creativity , common sense , and , of course , programming experience .

is an extension of the programming language , product of Bell Labs from the early .
was developed to write the Unix operating system , and is widely used for software and embedded systems development .

initially provided programming features Chapter and Chapter and later added generic programming capabilities .
close relationship to allows programs to utilize large collection of code developed in .

is widely used in industry for commercial software development .
It is an industrial strength gramming language used for developing complex systems in business , science , and engineering .
Examples of software written in include Microsoft Windows , Microsoft Office , macOS , and Adobe Creative Suite .

In order to meet the needs of commercial software development and accomplish all that it does , itself is complex .
While experienced programmers can accomplish great things with , beginners times have difficult time with it .
Professional software developers enjoy the flexible design options that permits , but beginners need more structure and fewer options so they can master simpler concepts before moving on to more complex ones .

This book does not attempt to cover all the facets of the programming language .
Experienced programmers should look elsewhere for books that cover in much more detail .
The focus here is on introducing programming techniques and developing good habits .
To that end , our approach avoids some of the more esoteric features of and concentrates on the programming basics that transfer directly to other imperative programming languages such as Java , and Python .
We stick with the basics and explore more advanced features of only when necessary to handle the problem at hand .

List several advantages developing software in language has over developing software in machine language .

How can an IDE improve productivity .

Properly written programs have particular structure .
The syntax must be correct , or the compiler will generate error messages and not produce executable machine language .
This chapter introduces by providing some simple example programs and associated fundamental concepts .
Most of the concepts presented in this chapter are valid in many other programming languages as well .
While other languages may implement the concepts using slightly different syntax , the ideas are directly transferable to other languages like , Java , and Ada .

The actual name of the file is irrelevant , but the name " accurately describes the nature of this program .
The extension is common extension used for source code .

After creating this file with text editor and compiling it , you can run the program .
The program prints the message .

This one directs the preprocessor to add some predefined source code to our existing .

This process is done automatically and is invisible to us .

Here we want to use an object from the ostream library , collection precompiled code that programs can use .
The iostream library contains elements that handle input and output to the display , getting user input from the keyboard , and dealing with files .

One of the items used in Listing , std   cout , is not part of the language itself .

This item , along with other things related to input and output , were developed in , compiled , and stored in the ostream library .
The compiler needs to be aware of these ostream items so it can compile our program .
The nclude directive specifies file , called header  that contains the specifications for the library code .
The compiler checks how we use std   cout within our code against its specification in the header to ensure that we are using the library code correctly .

Most of the programs we write use this nclude directive , and some programs .

Here we are declaring function named main .
All programs must contain this function to be executable .
Details about the meaning of nt and the parentheses will appear in later chapters .
More general information about functions appear in Chapter Sjand Chapter ' The opening curly brace at the end of the line marks the beginning of the body of function .
The body of function contains the statements the function is to execute .

This statement directs the executing program to print the message This is simple + program .
statement is the fundamental unit of execution in program .
Functions contain statements that the compiler translates into executable machine language instructions .
has variety of different kinds of statements , and the chapters that follow explore these various kinds of statements .
All statements in end with semicolon .
more detailed explanation of this statement appears below .

Note which lines in the program end with semicolon and which do not .
Do not put semicolon after the preprocessor directive .
Do not put semicolon on the line containing mai , and do not put semicolons after the curly braces .

One option involves commandline environment with collection of independent tools .
The other option is to use an IDE Section which combines all the tools into convenient package .
Visual Studio is the dominant IDE on the Microsoft .

Windows platform , and Apple Mac developers often use the XCode IDE .
AppendixJA provides an overview of how to use the Visual Studio IDE to develop simple program .

The myriad of features and configuration options in these powerful IDEs can be bewildering to those learning how to program .
In environment the programmer needs only type few simple commands into console window to edit , compile , and execute programs .
Some developers prefer the simplicity and flexibility of build environments , especially for less complex projects .

One prominent build system is the GNU Compiler Collection 

The GCC compiler , called , is one of most standards conforming compilers available .
The GCC compiler toolset is available for the Microsoft Windows , Apple Mac , and Linux platforms , and it is free , software project with development team .

Appendix an overview of how to use the GCC compiler .

Visual Studio and XCode offer command line development options as well .
Appendix an overview of the Visual Studio command line development process .

We can omit the std   prefix and use the shorter name , cout .
This directive is optional , but if we omit it , we must use the longer name .
The name std stands for " and the std prefix indicates that cout is part of collection of names called the standard namespace .
The std namespace holds names for all the standard types and functions that must be available to all development environments .
Components outside the standard library provided by ers reside in their own namespaces .
These include projects and commercial libraries .

This approach offers some advantages for smaller programs , such as examples in books and online tutorials .
This blanket usi ng directive allows programmers to use shorter names as in the more more focused using directives , and it also can use fewer lines of code than the more focused usi ng directives , especially when the program uses multiple elements from the std namespace .

Our choice of usi ng directives makes no difference in our final product , the executable gram .
The compiler generates the same machine language code for all three using , focused usi ng , and blanket usi ng .
We thus must select an approach that enhances our ability to write and manage our software projects .

It is important to note that while this blanket usi ng approach has its place , its use generally is couraged for more complex software projects .
At this point we cannot fully appreciate the rationale for avoiding the usi ng namespace std directive , but later , in Section we will have enough ence to understand the disadvantages of the blanket usi ng namespace std directive .
We will strive for best practices from the start and avoid the blanket usi ng statement .
We generally will use the full names of the elements in the std namespace and use the more focused using directives in our code when it makes sense to do so .

The statement in the mai function in any of the three versions of our program uses the services of an object called std   cout .
The std   cout object prints text on the screen .
The text of the message as it appears in the source code is called string , for string of characters .
Strings are enclosed within quotation marks .
The symbols make up the insertion operator .
You can think of the message to be printed as being " into the cout object .
The cout object represents the output stream ; that is , text that the program prints to the console window .
The end of the message contains the symbol sequence .
This known as character escape sequence , and this combination of backslash and the letter represents the newline character .
It indicates that the printing on that line is complete , and any subsequent printing should occur on the next line .
This newline character effectively causes the cursor to move down to the next line .
If you read the statement from left to right , the cout object , which is responsible for displaying text on the screen , receives the text to print terminated with the newline character to move to the next line .

For simplicity , refer to this type of statement as print statement , even though the word print does not appear anywhere in the statement .

With minor exceptions , any statement in must appear within function definition .
Our single print statement appears within the function named main .

Any function , including mai , may contain multiple statements .
In Listing , six print statements draw an arrow on the .

The body consists of all the statements between the open curly brace and close curly brace .
We say that the curly braces delimit the body of the function .
The word delimit means to determine the boundaries or limits of something .
The symbol determines the beginning of the body , and the symbol specifies the end of the body .

Listing and Listing may appear to be identical , but upon closer inspection of this new we see that std   cout appears only once within mai , and only one semicolon appears within mai .
Since semicolons in terminate statements , there really is only one statement .
Notice that single statement can be spread out over several lines .
The statement within mai appearing as .

Read this second version .

Since Listing does not use the std   cout object and so does not need the nclude and usi ng directives .
While it is legal and sometimes even useful in to write functions with empty bodies , such functions will do nothing when they execute .
Listing with its empty mai function is , therefore , truly the simplest executable we can write , but it does nothing when we runs it .

In general , may contain multiple functions , but we defer such generality until For now , we will restrict our attention to programs with only amain function .

For our immediate purposes all the programs we write will have the form shown in Figure Our programs generally will print something , so we need the directive that brings the std   cout definition from into our .
Depending on what we need our to do , we may need additional nclude directives .
The mai function definition is required for an executable  and we will fill its body with statements that make our do as we wish .
Later , our programs will become more sophisticated , and we will need to augment this simple template .

What preprocessor directive is necessary to use statements with the std : printing stream object .

What allows the short name cout to be used instead of std   cout .

Write program that prints your name in the console window .

Write program that prints your first and last name in the console window .
Your first name should appear on one line , and your last name appear on the next line .

What other files must you distribute with your executable file so that your program will run on Windows PC without Visual Studio installed .

Can single in span multiple lines in the source code .

In this chapter we explore some building blocks that are used to develop programs .

Integers are whole numbers , which means they have no fractional parts , and an integer can be positive , negative , or zero .
Examples of integers include , and .
In contrast , is not an integer , since it is not whole number .

supports number of numeric and values .
In particular , programs can use integer .

Notice that unlike the programs we saw earlier .
Listing does not use quotation marks .
The number appears unadorned with no quotes .
The expression   represents single newline character .
Multiple characters comprising string appear in double quotes , but , in , single character represents distinct type of data and is enclosed within single quotes .

Both programs behave identically , but Listing prints the value of the number four , while prints message containing the digit four .
The distinction here seems portant , but we will see in Section that the presence or absence of the quotes can make big difference in the output .

The std   endl expression does involve newline character , but it also performs some additional work that normally is not necessary .

Programs that do significant printing may execute faster if they terminate their output lines with   instead of std :
The difference in speed is ligible when printing to the console , but the different can be great when printing to hies or other output streams .
For most of the programs we consider , the ence in program execution speed between the two is imperceptible ; nonetheless , we will prefer   for printing newlines because it is good habit to form it requires five fewer keystrokes when editing .

The three major modern computing platforms are Microsoft Windows , Apple macOS , and Linux .
Windows handles newlines differently from macOS and Linux .

Historically , the character  represents  usually known as feed or LF for short , and the character  means carriage return , or CR for short .
The terminology comes from typewriters which feed piece of paper into roller on carriage that moves to the left as the user types the imprinted symbols form left to .
At the end of  the user must advance the roller so as to move the paper up by one and move the carriage back all the way to its left .
Windows uses the character sequence CR LF for lines , while macOS and Linux use LF .
This can be an issue when attempting to edit text hies written with an editor on one platform with an editor on different platform .

The good news is that the standard guarantees that the std   cout output stream translates the  character as it appears in source code into the correct character sequence for the target platform .
This means you can print  via std   cout , and it will behave identically on all the major platforms .

In source code , integers may not contain commas .
This means we must write the number two thousand , four hundred as , not .
Modern does support single quotes  as digit separators , as in 
Using digit separators can improve the human comprehension reading large numbers in source code .

In mathematics , integers are unbounded ; said another way , the set of mathematical integers is infinite .

In the range of integers is limited because all computers have finite amount of memory .
The exact range of integers supported depends on the computer system and particular compiler .
on most computer systems can represent integers in the range to .

The number printed was not even negative .
Most compilers will issue warning about this statement .

Section explores errors vs .
If the compiler finds an error in the source , it will not generate the executable code .
warning indicates potential problem and does not stop the compiler from producing an executable program .
Here we see that the programmer should heed this warning because the execution produces meaningless output .

This limited range of values is common among programming languages since each number is stored in fixed amount of memory .
Larger numbers require more storage in memory .
In order to model the infinite set of mathematical integers an infinite amount of memory would be needed .
As we will see later , supports an integer type with greater range .
Section  provides some details about the implementation of integers .

The same is true in , except variables also can represent values other than numbers .
Listing uses variable to store an integer value and .

All variables in program must be declared .
declaration specifies the type of variable .
The word nt indicates that the variable is an integer .
The name of the integer variable is .
We say that variable has type nt .
supports types other than integers , and some types require more or less space in the memory .
The compiler uses the declaration to reserve the proper amount of memory to store the value .
The declaration enables the compiler to verify the programmer is using the variable properly within the program ; for example , we will see that integers can be added together just like in mathematics .
For some other data types , however , addition is not possible and so is not allowed .
The compiler can ensure that variable involved in an addition operation is compatible with addition .
It can report an error if it is not .

The compiler will issue an error if programmer attempts to use an undeclared variable .
The piler cannot deduce the storage requirements and cannot verify the proper usage if it not declared .
Once declared , particular variable cannot be redeclared in the same context .
variable may not change its type during its lifetime .

An assignment statement associates value with variable .
The key to an assignment statement is the which is known as the assignment operator .
Here the value is being assigned to the variable .
This means the value will be stored in the memory location the compiler has reserved for the variable named .
We need not be concerned about where the variable is stored in memory ; the compiler takes care of that detail .

After we declare variable we may assign and reassign it as often as necessary .

The meaning of the assignment is different from equality in mathematics .
It is best to read as  is assigned the value " or  gets the value " This distinction is important since in mathematics equality is symmetric : if , we .
Such statement will produce compiler error : error : left operand must be .

Observe the each print statement in Listing is identical , but when the program .

We introduce objects in Multiple variables of the same type can be declared and , if desired , initialized in single statement .
The following statements declare three variables in one declaration statement : int   The following statement declares three integer variables and initializes two of them : int , Here value is undefined .
The declarations may be split up into multiple declaration statements : int ; int ; int ; the case of multiple declaration statements the type name must appear in each statement .

The compiler maps variable to location in the memory .
We can visualize variable and its corresponding memory location as box as shown in Figure We name the box with the name .
Figure shows how the following sequence of code affects memory .

After this statement and still refer to separate boxes .
It simply means the value stored in box has been copied to box , and remain distinct boxes .
The original value found in box is overwritten when the contents of box are copied into .
After the assignment of to  the reassignment of to does not affect .

Names such as alti tude , sum , and are much better than the equally permissible  and .
name should be related to its purpose within the program .
Good variable names make programs more readable by humans .
Since programs often contain many variables , variable names can render an otherwise obscure collection of symbols more understandable .

variable name is one example of an identifier .
An identifier is word used to name things .
One of the things an identifier can name is variable .
We will see in later chapters that identifiers name other things such as functions and classes .
Identifiers have the following .

The remaining characters may be alphabetic characters or lower , the underscore , or digit ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghij .

Here are some examples of valid and invalid .

All of the following words are valid identifiers and so qualify as variable names :  total , and FLAG .

None of the following words are valid identifiers : is not legal symbol in an , first entry is not legal symbol in an , with , sign is not legal symbol in an , and class is reserved .

reserves number of words for special use that could otherwise be used as identifiers .
Called reserved words or keywords  these words are special and are used to define the structure of programs and statements .
Table lists all the reserved words .

The purposes of many of these reserved words are revealed throughout this book .

You may not use any of the reserved words in Table as identifiers .
Fortunately , if you accidentally attempt to use one of the reserved words in program as variable name , the compiler will issue an error Section for more on compiler .

In Listing we used several reserved words : usi ng , namespace , and nt .
Notice that nclude , cout , and mai are not reserved words .

Some programming languages do not require programmers to declare variables before they are used ; the type of variable is determined by how the variable is used .
Some languages allow the same variable .

Such languages are known as languages .
is language .
In language , the type of variable must be explicitly specified before it is used by statements in program .
While the requirement to declare all variables may initially seem like minor annoyance , it offers several .

When variables must be declared , the compiler can catch typographical errors that languages cannot detect .
For example , consider the following section of code : int  The identifier in the first line ends with capital " In the second line , the identifier ends with the digit zero .
The distinction may be difficult or impossible to see in particular editor or printout of the code .
compiler would immediately detect the typo in the second statement , since letter has not been declared .
language would create two variables : and .

When variables must be declared , the compiler can catch invalid operations .
For example , variable may be declared to be of type nt , but the programmer may accidentally assign value to the variable .
In language , the variable would silently change its type introducing an error into the program .
In , the compiler would report the improper assignment as error , since once declared variable cannot change its type .

Ideally , requiring the programmer to declare variables forces the programmer to plan ahead and think more carefully about the variables program might require .
The purpose of variable is tied to its type , so the programmer must have clear notion of the purpose before declaring it .

The programmer need not do the simple double check of the purpose that writing the declaration requires .
While declaring the type of variable specifies its purpose in only very limited way , any opportunity to catch such errors is beneficial .

languages are generally more efficient than languages .
The piler knows how much storage variable requires based on its type .
The space for that value will not change over the life of the variable , since its type cannot change .
In dynamically typed language that allows variable to change its type , if type changes during program execution , the storage it requires may change also , so memory for that variable must be allocated elsewhere to hold the different type .
This memory reallocation at run time slows down the execution .

is language .
This means that capitalization matters , is reserved word , but none of If , IF , or are reserved words .
Identifiers are case sensitive also ; the variable called Name is different from the variable called name .

Since it can be confusing to human readers , you should not distinguish variables merely by names that differ in capitalization .
For the same reason , it is considered poor practice to give variable the same name as reserved word with one or more of its letters capitalized .

The type short nt , which may be written as just short , represents integers that may occupy fewer bytes of memory than the nt type .
If the short type occupies less memory , it necessarily must represent smaller range of integer values than the nt type .
The standard does not require the short type to be smaller than the nt type ; in fact , they may represent the same set of integer values .
The Tong nt type , which may be written as just long , may occupy more storage than the nt type and thus be able to represent larger range of values .
Again , the standard does not require the long type to be bigger then the nt type .
Finally , the long long int type , or just long long , may be larger than long .
The standard guarantees the following relative ranges of values hold : short int int long int long long int On small embedded device , for example , all of these types may occupy the exact same amount of memory and , thus , there would be no advantage of using one type over another .
On most systems , however , there will some differences in the ranges .

provides types that exclude negative numbers .
These types include the word unsigned in their names , meaning they do not allow negative sign .
The unsigned types come in various potential sizes in the same manner as the signed types .
The standard guarantees the following relative ranges of unsigned values : unsigned short unsigned unsigned long unsigned long long Table lists the differences among the signed and unsigned integer types in Visual .
Notice that the corresponding signed and unsigned integer times occupy the same amount of memory .
As result , the unsigned types provide twice the range of positive values available to their signed counterparts .
For applications that do not require negative numbers , the unsigned type may be more appropriate option .

Within the source code , any unadorned numerical literal without decimal point is interpreted as an .

In order to represent as an long , append an , as in long ; also permits the elle , as in long ; but you should avoid it since on many display and printer fonts it looks too much like the digit .

Use the LL suffix for long long literals .
The suffixes for the unsigned integers are , us , uL , and uLL gned long .
The capitalization is unimportant , although capital Ls are preferred .

Many computational tasks require numbers that have fractional parts .
For example , the formula from ematics to compute the area of circle given the radius , involves the value , which is approximately .
supports such numbers , and they are called numbers .
The name comes from the fact that during mathematical calculations the decimal point can move or " to ous positions within the number to maintain the proper number of significant digits .
The types float and double represent different types of numbers .
The type double is used more often , since it stands for " and it can represent wider range of values with more digits of .

The first line in Listing declares variable named and assigns it value .
The second line in Listing prints the value of the variable  and the third line prints literal value .

Any literal numeric value with decimal point in program automatically has the type double , so has type double .
To make literal value float , you must append an or to the number , as in .

numbers are an approximation of mathematical real numbers .
As in the case of the nt data type , the range of numbers is limited , since each value requires fixed amount of memory .
In some ways , though , nts are very different from doubles .
Any integer within the range of the nt data type can be represented exactly .
This is not true for the types .
Consider the real number .
Since contains an infinite number of digits , number with finite precision can only approximate its value .
Since the number of digits available is limited , even numbers with finite number of digits have no exact representation ; for example , the number contains too many digits for the double type and must be approximated as .
Section contains more information about the consequences of the inexact nature of numbers .

We can express numbers in scientific notation .
Since most programming editors do not .

The number to the left of the can use capital as is .

In Listing , and the speed of are scientific constants ; that is , to the degree of precision to which they have been measured calculated , they do not vary .
supports named constants .
Constants are declared like variables with the addition of the const keyword : const double ; Once declared and initialized , constant can be used like variable in all but one constant may not be reassigned .
It is illegal for constant to appear on the left side of the assignment outside its declaration statement .
subsequent statement like .

By convention , programmers generally express constant names in all capital letters ; in this way , within the source code human reader can distinguish constant quickly from variable .

supports several other numeric data .

It is guaranteed to provide range of integer values at least as large as the nt type .

An integer literal with suffix , as in , has type long .
lower case elle is allowed as suffix as well , but you should not use it because it is difficult for human readers to distinguish between case and .
Attempting to do so would change the name of the .

It is guaranteed that the range of nts is at least as big as the range of shorts .

While the unsigned type is limited in nonnegative values , it can represent twice as many positive values as the nt type .

While the language standard specifies minimum ranges and precision for all the numeric data types , particular compiler may exceed the specified minimums .

provides such variety of numeric types for specialized purposes usually related to building highly efficient programs .
We will have little need to use many of these types .
Our examples will use mainly the numeric types nt for integers , double for an approximation of real numbers , and , less frequently , unsi gned when nonnegative integral values are needed .

The char data type is used to represent single characters : letters of the alphabet upper and lower , digits , punctuation , and control characters newline and tab .
Most systems support the American Standard Code for Information Interchange character set .
Standard ASCII can represent different characters .
Table lists the ASCII codes for various characters .

In source code , characters are enclosed by single quotes  as in .

Standard quotes are reserved for strings , which are composed of characters , but strings and .

The value is the ASCII code for the character .
If is printed , as in ;  the corresponding character .
, would be printed because declared type is char , not nt or some other numeric type .

, The first is printed because the statement .

The second is printed because the statement .

The third is printed because the literal character  is sent directly to the output stream .

Integers and characters can be freely assigned to each other , but the range of chars is much smaller than the range of nts , so care must be taken when assigning an nt value to cha variable .

Some characters are characters .
The ASCII chart lists several common characters :  newline character  carriage return character  backspace character  character " sound or other tone on some ' tab character ' formfeed character .

These special characters begin with backslash symbol .
The backslash is called an escape symbol , and it signifies that the symbol that follows has special meaning and should not be interpreted literally .
This means the literal backslash character must be represented as two backslashes :

These special character codes can be embedded within strings .
To embed backslash within string , you must escape it ; for example , the statement .

The following two statements behave identically : of line "  of ; On the Microsoft Windows platform , the character sequence " return , line appears at the end of lines in text files .
Under Unix and Linux , lines in text files end with  
On Apple Macintosh systems , text file lines end with the   character .
The compilers that adhere to the standard will ensure that the   character in program when sent to the output stream will produce the correct character sequence for the given platform .

Such is called an enumerated  or an enumeration .
The enum keyword introduces an enumerated .

The values listed with the curly braces constitute all the values that variable of the enumerated can attain .
The name of each value of an enumerated must be valid identifier Section .

Given the Color defined as above , we can declare and use variables of the enum as shown by the following code fragment : Color  Orange ; Here the variable has our custom Color , and its value is Orange .

When declaring enumerated types in this manner it is illegal to reuse an enumerated value name within another enumerated within the same program .
In the following code , the enumerated value Light .

This style of enumerated definition is known as an unscoped enumeration .
inherits this scoped enumeration style from the programming language .
The standards committee introduced relatively recently an enhanced way of defining enumerated types known as scoped enumerations , also known as enumeration classes .
Scoped enumerations solve the problem of duplicate enumeration values in different types .
The following definitions are legal within the same .

Prefixing the name to the value with the   operator enables the compiler to distinguish between the two different values .

Scoped enumerations require the name prefix even if the program contains no other enumerated types .

In modern development , scoped enumerations are preferable to unscoped enumerations .
You should be familiar with unscoped enumerations , though , as lot of published code and older books use unscoped enumerations .

Whether scoped or unscoped , the value names within an enum must be unique .
The convention in is to captialize the first letter of an enum and its associated values , although the language does not enforce this convention .

An enum is handy for representing small number of discrete , options .
For example , consider program that controls the movements made by small robot .
The allowed orientations are forward , backward , left , right , up , and down .
The program could encode these movements as integers , where means left , means backward , etc .
While that implementation will work , it is not ideal .
Integers may assume many more values than just the six values expected .
The compiler cannot ensure that an integer variable representing robot move will stay in the range .
What if the programmer makes mistake and under certain rare circumstances assigns value outside of the range .
The program then will contain an error that may result in erratic behavior by the robot .
With enum types , if the programmer uses only the named values of the enum  the compiler will ensure that such mistake cannot happen .

particular enumerated necessarily has far fewer values than such as nt .
Imagine making an integer enum and having to list all of its values .

requires that variable be declared before it is used .
Ordinarily this means specifying the  as in int  char  double  variable may be initialized when it is declared : int ; char   double ; Each of the values has  is an nt ,   is char , and is double .
The auto keyword allows the compiler to automatically deduce the of variable if it is initialized when it is declared : auto ; auto '  auto ; The auto keyword may not be used without an accompanying initialization ; for example , the following declaration is .

Automatic deduction with auto is not useful to beginning programmers .
It is just as easy to specify the .
The value of auto will become clearer when we consider some of the more advanced features of Section .

Will the following lines of code print the same thing .

Will the following lines of code print the same thing .

What is the largest nt available on your system .

What can you do if variable name you would like to use is the same as reserved word .

Why does require programmers to declare variable before using it .
What are the advantages of declaring variables .

What is the difference between float and double .

What is printed by the following code fragment .

This chapter uses the numeric types introduced in Chapter to build expressions and perform .

We can use operators to combine values and variables and form more complex expressions .

As we examine the rest of the program we will see that it would be superfluous to assign values to the variables here .

This statement is our usual print ment , but it is not terminated with the marker 
This is because we want the cursor to remain at the end of the printed line so when the user types in values they appear on the same line as the message prompting for the values .
When the user presses the enter key to complete the input , the cursor will automatically move down to the next line .

The first number entered will be assigned to valuel , and the second number entered will be assigned to .
Once the user presses the enter key , the value entered is assigned to the variable .
The user may choose to type one number , press enter , type the second ber , and press enter again .
Instead , the user may enter both numbers separated by one of more spaces and then press enter only once .
The program will not proceed until the user enters two numbers .

The std   ci input stream object can assign values to multiple variables in one .

The compiler will not generate an error message , because it is legal code .
The statement , however , will not assign the three variables from user input as desired .

The comma operator in has different meanings in different contexts , and here it is treated like statement separator ; thus , the variables and are not involved with the std   ci input stream object .
We will have no need to use the comma operator in this way , but you should be aware of this potential pitfall .

The used here in the context of the std   ci known as the extraction .
Notice that it is wards " from the used with the std   cout object .
The std   ci object represents the input flowing into the program from user input from the keyboard .
The extracts the data from the input stream std   ci and assigns the pieces of the data , in order , to the various variables on its right .

The variable appears to the left of the assignment  so will receive value when this statement cutes .
To the right of the assignment is an arithmetic expression involving two variables and the addition .
The expression is evaluated by adding together the of the two variables .

Once the value has been determined , that value can be assigned to the variable .

All expressions have value .
The process of determining the value is called evaluation .

Evaluating simple expressions is easy .
The literal value evaluates to .
The value of variable named is the value stored in the memory location reserved for .
The value of more complex expression is found by evaluating the smaller expressions that make it up and combining them with operators to form potentially new .

The two operands of the + are and .

Two of the operators above , + and serve also as unary operators .
unary has only one operand .
The unary expects single numeric expression number , variable , or complex numeric expression within immediately to its right ; it computes the additive inverse of its operand .
If the operand is positive than , the result is negative value of the same magnitude ; if the operand is negative than , the result is positive value of the same magnitude .
Zero is unaffected .
For example , the following code sequence nt ; int ; nt ;       within program would print .

Omitting the unary + from the following statement + does not change the behavior .

All the arithmetic operators are subject to the limitations of the data types on which they operate ; for example , on system in which the largest nt is , the expression + will not evaluate to the correct answer since the correct answer falls outside the range of nts .

If you add , subtract , multiply , is divide two nts , the result is an integer .
As long as the operation does not exceed the range of nts , the arithmetic works as expected .
Division , however , is another matter .
The statement :  

Since integers are whole numbers , any fractional part of the answer must be discarded .
The process of discarding the fractional part leaving only the whole number part is called truncation .
Truncation is not rounding ; for example , divided by is , but it also truncates to .

The modulus computes the remainder of integer division ;

Figure uses long division for more hands on illustration of how the integer division and modulus operators work .

The modulus is more useful than it may first appear .
Listing shows how we can use it to convert given number of seconds to hours , minutes , and seconds .

In contrast to integer arithmetic , arithmetic with doubles behaves as .

Since cha is stored internally as number Section , we can perform arithmetic on ters .
We will have little need to apply mathematics to characters , but sometimes it is useful .
As an example , the letters of the alphabet occupy ASCII values , with , etc .
The case letters are coded as , with , etc .
To capitalize any letter , you need only subtract , as in char '   This section of code would print .
If you do not remember the offset of between and letter , you can compute it with the letters themselves : In this case , if has been assigned any value in the range   to    the statement will assign to the capitalized version of .
On the other hand , if value is outside of that range , will not receive meaningful value .

Expressions may contain mixed elements ; for example , the following program fragment int ; double ,  +  adds an nt to double , and the result is being assigned to double .
How is the arithmetic performed .

As shown in Figure , the range of nts falls completely within the range of doubles ; thus , any nt value can represented by double .
The nt also can be expressed as the double .
In fact , since the largest nt on most systems is , the minimum digits of double precision are more than adequate to represent all integers exactly .
This means that any nt value can be represented by double .
The converse is not true , however .
We say that the double type is wider than the nt type and that the nt type is narrower than the double type .

It would be reasonable , then , to be able to assign nt values to double variables .
The process is called widening , and it is always safe to widen an nt to double .
The following code fragment .

Assigning adoubletoanint variable is not always possible , however , since the double value may not be in the range of nts .
Furthermore , if the double variable falls within the range of nts but is not whole number , the int variable is unable to the manage fractional part .
Consider the following code fragment : double ; int  The second line assigns to .
Truncation loses the fractional part Section .
Note that proper rounding is not done .
The Visual compiler will warn us of potential problem : warning : conversion from ' to , possible loss of data This warning reminds us that some information may be lost in the assignment .
While the compiler and linker will generate an executable program when warnings are present , you should carefully scrutinize all warnings .
This warning is particularly useful , since it is easy for errors due to the truncation of point numbers to creep into calculations .

Converting from wider type to narrower type double to is called narrowing .
It often is necessary to assign value to an integer variable .
If we know the value to assign is within the range of nts , and the value has no fractional parts or its truncation would do no harm , the assignment is safe .
To perform the assignment without warning from the compiler , we use procedure called cast , also called type cast .
The cast forces the compiler to accept the assignment without issuing warning .
The following statement convinces the compiler to accept the nt assignment without warning :  The reserved word stati performs the narrowing conversion and silences the compiler warning .

The item to convert this case the variable is placed in the parentheses , and the desired type this case the type appears in the angle brackets .
The statement  does not change the type of the variable  is declared to be double and so must remain double variable .
The statement makes copy of value in temporary memory location , converting it to its integer representation during the process .

We also can cast literal values and .

The widening conversion is always safe , so type cast is not required .
Narrowing is potentially .

The printed values of and are not even close , nor can they be because it is impossible to represent the value as an nt on system that uses integers .
When assigning value of wider type to variable of narrower type , the programmer must assume the responsibility to ensure that the actual value to be narrowed is indeed within the range of the narrower type .
The compiler cannot ensure the safety of the assignment .

Casts should be used sparingly and with great care because cast creates spot in the program that is immune to the type checking .

When we must perform mixed as adding an nt to double the compiler matically produces machine language code that copies the nt value to temporary memory location and transforms it into its double equivalent .
It then performs arithmetic to compute the result .

Integer arithmetic occurs only when both operands are nts .

Since double is wider than nt , we say that double dominates nt .
In mixed type arithmetic expression , the less dominant type is coerced into the more dominant type in order to perform the arithmetic operation .

enumerated types .
Behind the scenes , the compiler translates enumerated values into integers .
The first value in the enumeration is , the second value is , etc .
Even though the underlying implementation of enumerated types is integer , the compiler does not allow the free exchange between integers and enumerated types .
The following code will not .

The std :  cout printing object knows how to print integers , but it does not know anything about our Color class and its values .
If we really want to treat an enumerated type value as its underlying integer , we must use type cast .
Listing shows how to extract the underlying integer value from an enumerated type .

This is the expected output because Color :  Red is , Color :  Orange is , Color :  Yellow is , Color :  Green is , etc .

Even though enumerated types are encoded as integers internally , programmers may not perform metic on enumerated types without involving casts .
Such opportunities should be very rare ; if you need to perform arithmetic on variable , it really should be numerical type , not an enumerated type .

Precedence an expression contains two different kinds of operators , which should be applied first .

Associativity an expression contains two operators with the same precedence , which should be applied first .

To see how precedence works , consider the expression + Should it be interpreted as + is , or rather is +

As in normal arithmetic , in multiplication and division have equal importance and are performed before addition and subtraction .
We say multiplication and division have precedence over addition and subtraction .
In the expression + the multiplication is performed before addition , since multiplication has precedence over addition .

The multiplicative operators , and have equal precedence with each other , and the additive operators + and have equal precedence with each other .
The multiplicative operators have precedence over the additive operators .

As in standard arithmetic , in if the addition is to be performed first , parentheses can override the precedence rules .
The expression + evaluates to .
Multiple sets of parentheses can be arranged and nested in any ways that are acceptable in standard arithmetic .

To see how associativity works , consider the expression The two operators are the same , so they have equal precedence .
Should the first subtraction operator be applied before the second , as in is , or rather is is , the correct interpretation .
The former is the correct interpretation .
We say that the tion operator is left associative , and the evaluation is left to right .
This interpretation agrees with standard arithmetic rules .
All binary operators except assignment are left associative .
Assignment is an exception ; it is right associative .
To see why associativity is an issue with assignment , consider the statement ; This is legal and is called chained assignment .
Assignment can be used as both statement and an expression .
The statement  assigns the value to the variable .
The expression assigns the value to the variable and evaluates to the value that was assigned ; that is ,
Since assignment is right associative , the compiler would interpret the chained assignment example as if it were written as  which behaves as .

The expression is evaluated first , value is assigned to  and the value of the expression is value .

The expression evaluated .
The value of , that is , is assigned to .
The overall value of the expression is thus the value of .
Now the values of   and are all equal .

The expression evaluated .
The value of the expression is equal to value , so value is assigned to .
The overall value of the expression is equal to , and the variables    and are all equal .

As in the case of precedence , we can use parentheses to override the natural associativity within an sion .

The unary operators have higher precedence than the binary operators , and the unary operators are right associative .
This means the statements .

These notes are meant for human readers , not the compiler .
It is common in industry for programs to be reviewed for correctness by other programmers or technical managers .
identifiers Section and comments can aid this assessment process .
Also , in practice , teams of programmers develop software .
different programmer may be required to finish or fix part of the program written by someone else .
comments can help others understand new quicker and increase their productivity modifying old or unfinished .
While it may seem difficult to believe , even the same programmer working on her own months later can have difficult time remembering what various parts do .
Comments can help greatly .

Any text contained within comments is ignored by the compiler .
supports two types of comments : single line comments and block .

The comment begins with the double forward slash symbols and continues until the end of that line .
The compiler will ignore the symbols and the contents of the rest of the line .
This type of comment is also useful for appending short comment to the end of statement : sum number ; Compute the average of the values Here , an executable statement and the comment appear on the same line .
The compiler will read the assignment statement here , but it will ignore the comment .
The compiler generates the same machine for this example as it does for the preceding example , but this example uses one line of source instead of two .

Block comment second type of comment begins with the symbols and is in effect until the symbols are encountered .
Unlike parentheses , however , these block comments cannot be nested within other block comments .

The block comment is handy for comments : After the computation is completed the is displayed .

Thus , the audience of the comments should be taken into account ; generally , activities require no remarks .

The extra time it takes to write good comments is well worth the effort .

Program comments are helpful to human readers but ignored by the compiler .
Another aspect of source that is largely irrelevant to the compiler but that people find valuable is its formatting .
Imagine the difficulty of reading book in which its text has no indentation or spacing to separate one paragraph from another .
In comparison to the source for computer program , organization is quite simple .

Over decades of software construction programmers have established small collection of source formatting styles that the industry finds acceptable .

Both reformatted programs are valid and compile to the same machine language as the inal version .
Most would argue that the original version is easier to read and understand more quickly than either of the reformatted versions .
The elements in Listing are organized ter .
Experienced programmers would find both Listing and Listing visually painful .

What are some distinguishing characteristics of Listing .

Each statement appears on its own line .
statement is not unnecessarily split between two lines of text .
Visually , one line of text implies one action to perform .

The close curly brace aligns vertically with the line above that contains the corresponding open curly brace .
This makes it easier to determine if the curly braces match and nest properly .
It also better trays the logical structure of the program .
The ability to accurately communicate the logical structure of program becomes very important as write more complex programs .
Programs with complex logic frequently use multiple nested curly braces example , see Listing ,
out consistent , organized arrangement of curly braces it can difficult to determine which opening brace goes with particular closing brace .

The statements that constitute the body of main are indented several spaces .
This visually phasizes the fact that the elements are indeed logically enclosed .
As with curly brace alignment , indentation to emphasize logical enclosure becomes more important as more complex programs are considered .

Spaces are used to spread out statements and group pieces of the statement .
Space around the makes it easier to visually separate the operands from the operators and comprehend the details of the expression .
Most people find the statement subtotal + tax ; much easier to read than ; since the lack of space in the second version makes it more difficult to pick out the individual pieces of the statement .
In the first version with extra space , it is clearer where operators and variable names begin and end .

In natural language like English , book is divided into distinct chapters , and chapters are composed of paragraphs .
One paragraph can be distinguished from another because the first line is indented or an extra space appears between two paragraphs .
Space is used to separate words in each sentence .

Consider how hard it would be to read book if all the sentences were printed like this one : Theboyranquicklytothetreetoseethestrandedcat .

gives the programmer large amount of freedom in formatting source .

The compiler reads the characters that make up the source one symbol at time left to right within line before moving to the next line .
While extra space helps readability , spaces are not allowed in some places : Variable names and reserved words must appear as unbroken units .

One common coding convention that is universal in programming is demonstrated in Listing .
While programmers usually use letters in variable names , they usually express constant names with all capital letters ; for example , PI is used for the mathematical constant instead of pi .
does not require constants to be capitalized , but capitalizing them aids humans reading the source code so they can quickly distinguish between variables and constants .

Figure shows the four most common ways programmers use indentation and place curly braces in source code .

The and ANSI styles are the most popular in published source code .
The Whitesmith and Banner styles appear much less frequently , reviews the various ways to format code .
Observe that all the accepted formatting styles indent the block of statements contained in the mai function .

Most software development organizations adopt set of style guidelines , sometimes called code tions .
These guidelines dictate where to indent and by how many spaces , where to place curly braces , how to assign names to identifiers , etc .
Programmers working for the organization are required to follow these style guidelines for the code they produce .
This better enables any member of the development team to read and understand more quickly code written by someone else .
This is necessary when code is reviewed for correctness or when code must be repaired or extended , and the original programmer is no longer with the development team .

Even if you are not forced to use particular style , it is important to use consistent style throughout the code you write .
As our programs become more complex we will need to use additional curly braces and various levels of indentation to organize the code we write .
consistent style one of the standard styles shown in Figure makes it easier to read and verify that the code actually expresses our intent .
It also makes it easier to find and fix errors .
Said another way , haphazard formatting increases the time it takes to develop correct software because mistakes hide better in poorly formatted code .

Good software development tools can boost programmer productivity , and many programming editors have the ability to automatically format source code according to standard style .
Some of these editors can correct the style as the programmer types in the text .
standalone program known as pretty printer can transform an arbitrarily formatted source file into properly formatted one .

Seasoned programmers make mistakes due to carelessness or because the proposed solution to problem is faulty and the correct implementation of an incorrect solution will not produce correct program .
Regardless of the reason , programming error falls under one of three .

error results from the misuse of the language .
syntax error is common error .
For example , in English one can say The boy walks quickly .

The boy walk quickly .

It violates grammatical rule of the English language .
Similarly , the statement + is syntactically correct because it obeys the rules for the structure of an assignment statement described in Section However , consider replacing this assignment statement with slightly modified version : +  If statement like this one appears in program and the variables and have been properly declared , the compiler will issue an error message ; for example , the Visual compiler reports other : error : left operand must be The syntax of does not allow an expression like + to appear on the left side of the assignment operator .

Visual reports : error : undeclared identifier Other common errors include missing semicolons at the end of statements , mismatched curly braces and parentheses , and simple typographical errors .

errors usually are the easiest to repair .
The compiler pinpoints the exact location of the problem , and the error does not depend on the circumstances under which the program executes .
The exact error can be reproduced by simply recompiling the same source code .

Compilers have the reputation for generating cryptic error messages .
They seem to provide little help as far as novice programmers are concerned .
Sometimes combination of errors can lead to messages that indicate errors on lines that follow the line that contains the actual error .
Once you encounter the same error several times and the compiler messages become more familiar , you become better able to deduce the actual problem from the reported message .
Unfortunately is such complex language that sometimes simple error can result in message that is incomprehensible to beginning programmers .

It can detect , for ple , the malformed assignment statement and the use of variable before its declaration .
Some violations of the language cannot be detected at compile time , however .
program may not run to completion but instead terminate with an error .
We commonly say the program " Consider Listing which under certain circumstances will crash .

If the user enters , for example , and , the program works nicely .

If the user instead types the numbers and , the program reports an error and terminates .
Division by zero is undefined in mathematics , and integer division by zero in is illegal .

When the program attempts the division at run time , the system detects the attempt and terminates the program .

This particular program can fail in other ways as well ; for example , outside of the world , looks like respectable integer .
If the user types in and , however , the program crashes because is not valid way to represent an integer in .
When the compiler compiles the source line dividend divisor ; given that dividend has been declared to be an nt , it generates slightly different machine language code than it would if dividend has been declared to be double instead .
The compiled code expects the text entered by the user to be digits with no extra decoration .
Any deviation from this expectation results in error .
Similar results occur if the user enters text that does not represent an integer , like fred .

Observe that in either of valid but inappropriate integer or entry of or fred is impossible for the compiler to check for these problems at compile time .
The compiler cannot predict what the user will enter when the program is run .
This means it is up to the programmer to write code that can handle bad input that the user may provide .
As we continue our exploration of programming in , we will discover ways to make our programs more robust against user input Listing in for .
The solution involves changing the way the program runs depending on the actual input provided by the user .

It runs , and unless value of zero is entered for the  no errors arise .
However , the answer it computes is not correct in general .
The only time the correct answer is printed is when visor .
The program contains an error , but neither the compiler nor the system is able detect the problem .
An error of this type is known as logic error .

Listing is an example of program that contains logic error .
Listing compiles and does not generate any errors , but it produces incorrect results .

Beginning programmers tend to struggle early on with errors due to their unfamiliarity with the language .
The compiler and its error messages are actually the best friend .
As the programmer gains experience with the language and the programs written become more complicated , the number of errors decrease or are trivially fixed and the number of logic errors increase .

Unfortunately , both the compiler and environment are powerless to provide any insight into the nature and sometimes location of logic errors .
Logic errors , therefore , tend to be the most difficult to find and repair .
Tools such as debuggers are frequently used to help locate and fix logic errors , but these tools are far from automatic in their operation .

Errors that escape compiler detection errors and logic are commonly called bugs .

Since the compiler is unable to detect these problems , such bugs are the major source of frustration for developers .
The frustration often arises because in complex programs the bugs sometimes only reveal themselves in certain situations that are difficult to reproduce exactly during testing .
You will discover this frustration as your programs become more complicated .
The good news is that programming experience and the disciplined application of good programming techniques can help reduce the number logic errors .

The bad news is that since software development in an inherently human intellectual pursuit , logic errors are inevitable .
Accidentally introducing and later finding and eliminating logic errors is an integral part of the programming process .

In Listing the programmer is attempting to print the value of variable before it has been given known value .

When run , the program produces random result because it prints the value in memory associated with the variable , but the program does not initialize that memory location .

Listing assigns double value to an nt variable , which we know from Section .

Since it is warning and not an error , the compiler generates the executable , but the warning should prompt .

The default Visual warning level is when compiling in the IDE and level on the command line is why we use the option on the command ; the highest warning level is .
You can reduce the level to or or disable warnings altogether , but that is not recommended .
The only reason you might want to reduce the warning level is to compile older existing source that does meet newer standards .
When developing new  higher warning levels are preferred since they provide more help to the programmer .
Unless otherwise noted , all the complete program examples in this book compile cleanly under Visual set at warning level .
Level is helpful for detecting many common logic errors .

We can avoid most warnings by simple addition to the .
Section showed how we can use stati to coerce wider type to narrower type .
At Visual warning Level , the compiler issues warning if the cast is not used .
The little that must be added should cause the programmer to stop and reflect about the correctness of the construct .
The enhanced warning level prevents the programmer from being oblivious to the situation .

The kind of arithmetic to perform in complex expression is determined on an operator by operator basis .

Fahrenheit to degrees Celsius using the formula .

The value is the point where the Fahrenheit and Celsius curves cross , so the result should be , not zero .
The first test was only coincidentally correct .

Unfortunately , the printed result is always zero regardless of the input .
The problem is the division in the statement ; Division and multiplication have equal precedence , and both are left associative ; therefore , the division is performed first .
Since both operands are integers , integer division is performed and the quotient is zero divided by is , remainder .
Of course zero times any is zero , thus the result .
The fact that value is involved in the expression and the overall result is being assigned to variable , is irrelevant .
The decision about the exact type of operation to perform is made on an basis , not globally over the entire expression .
Since the division is performed first and it involves two integer values , integer division is used before the other pieces become involved .

One solution simply uses literal for either the five or the nine , as in ; This forces division that the literal is .
The correct result , subject to rounding instead of truncation , is finally computed .

Listing uses integer division and modulus to split up given of seconds to hours , minutes , and seconds .

If the user enters , the program prints hr  mi , sec .
Notice the assignments to .

The remainder of divided by is assigned back to .
This statement can alter the value of if the current value of is greater than .
similar statement that occurs frequently in programs is one like + This statement increments the variable to make it one bigger .
statement like this one provides further evidence that the assignment does not mean mathematical equality .
The following statement from mathematics + is surely never true ; cannot be equal to one more than itself .
If that were the case , would deposit one dollar in the bank and then insist that really had two dollars in the bank , since is equal to one more than itself .
That two dollars would become , then , and soon would be rich .
In , however , this statement simply means one to and assign the result back to " variation on Listing .
Listing performs the same logic to compute the time pieces ,  and , but it uses more simple arithmetic to produce slightly different of printing as hr , min , sec , Listing displays it as .
It is trivial to modify Listing so that it would print , but Listing includes some extra arithmetic to put leading zeroes in front of values for and as is done on digital clock displays .

Numbers numbers offer some distinct advantages over integers .
numbers , especially doubles have much greater range of values than any integer type .
numbers can have fractional parts and integers cannot .
Integers , however , offer one big advantage that numbers .
To see why integers are exact and numbers are not , we will explore the way computers store and manipulate the integer and types .

Computers store all data internally in binary form .
The binary number system is much simpler than the familiar decimal number system because it uses only two digits : and .
The decimal system uses digits : and .
Despite the lack of digits , every decimal integer has an equivalent binary representation .
Binary numbers use place value system not unlike the decimal system .

how the familiar base place value system works .

Since both binary and decimal numbers share the digits and , we will use the subscript to indicate binary number ; therefore , represents the decimal value one hundred , while IOO is the binary number four .
Sometimes to be very clear we will attach subscript of to decimal number , as in In the decimal system , it is easy to add :  The sum + is little more complicated , as early elementary students soon .

The sum is + We can say + is , carry the .
The rules for adding binary numbers are shorter and simpler than decimal numbers : + + + We can say the sum + is  carry the .
typical larger sum would be +

These are distinguished by the number of bits required to store the type , and , consequently , the range of values they can represent .
Mathematical integers are finite , but all of integer types correspond to finite subsets of the mathematical integers .
The most commonly used integer type in is nt .
All nts , regardless of their values , occupy the same amount of memory and , therefore use the same number of bits .
The exact number of bits in an nt is processor specific .
processor , for example , is built to manipulate integers very efficiently .
compiler for such system most likely would use nts , while compiler for machine might represent nts with bits .
On computer , the numbers and both occupy bits of memory .

For simplicity , we will focus on unsigned integers , particularly the unsi gned type .
The unsi gned type in Visual occupies bits .
With bits we can represent different values , and so Visual unsi gned type represents the integers .
The hardware in many computer systems in the provided only integer types , so it was common then for compilers to support unsi gned values with range .
To simplify our exploration into the properties of integers , we will consider an even smaller , mythical unsigned integer type that we will call unsigned ti ny .
has no such unsigned ti ny type as it has very small range of too small to be useful as an actual type in real programs .
Our unsigned ti ny type uses only five bits of storage , and Table shows all the values that variable of type unsigned tiny can assume .

Table : The unsigned tiny values .

To see that arithmetic works , try adding + + That was easy since involved no carries .
Next we will try +

In the twos column , + + IO  so we must carry into the fours column as well .

The next example illustrates limitation of our finite representation .
Consider the sum + + In the this sum we have carry of from the eights column to the column , and we have carry from the column to nowhere .
We need sixth column , another place value , our unsigned ti ny type is limited to five bits .
That carry out from the place is lost .
The largest unsi gned ti ny value is , +
It is not possible to store the value in an unsigned tiny just as it is impossible to store the value in unsi gned variable .

Consider exceeding the capacity of the unsigned ti ny type by just .

Adding one to the largest possible unsigned ti ny , results in the smallest possible value ,

Figure The cyclic nature of unsigned integers .
Adding to produces , one .

In fact , Visual unsi gneds follow the cyclic pattern shown in Figure In the figure , an addition moves value clockwise around the circle , while subtraction moves value counterclockwise around the circle .
When the numeric limit is reached , the value rolls over like an mobile odometer .
Signed integers exibit similar cyclic pattern as shown in Figure .

Figure The cyclic nature of signed integers .
Adding to produces .

Attempting to exceed the maximum limit of numeric type results in overflow , and attempting to exceed the minimum limit is called underflow .
Integer arithmetic that overflow or underflow produces valid , yet incorrect integer result .
The compiler does not check that computation will result in exceeding the limit of type because it is impossible to do so in general adding two integer variables whose values are determined at run .
Also significantly , an overflow or underflow situation does not generate error .
It is , therefore , logic error if program performs an integral computation that , either as final result or an intermediate value , is outside the range of the integer type being used .

Floating point numbers can have fractional parts , and the term floating point refers to the fact the imal point in number can float left or right as necessary as the result of calculation example , two place values produce place .
As with the integer types , the different types may be distinguished by the number of bits of storage required and corresponding range of values .
The type float stands for , and double stands for .
Floating point numbers serve as rough approximations of ematical real numbers , but as we shall see , they have some severe limitations compared to actual real numbers .

On most modern computer systems numbers are stored internally in exponential form according to the standard adopted by the Institute for Electrical and Electronic Engineers .
In the decimal system , scientific notation is the most familiar form of exponential notation : One mole contains molecules .

Here is called the mantissa , and is the exponent .

The IEEE standard uses binary exponential notation ; that is , the mantissa and exponent are binary numbers .
numbers occupy bits , distributed as follows : Mantissa bits .

We will call our mythical type tiny float .
The first three bits of our tiny float type will represent the mantissa , and the remaining two bits store the exponent .
The three bits of the mantissa all appear to the right of the binary point .
The base of the exponent is , of course , two .
Figure illustrates such value .

To simplify matters even more , neither the mantissa nor the exponent can be negative .
Thus , with three bits , the mantissa may assume one of eight possible values .
Since two bits constitute the exponent of ti ny floats , the exponent may assume one of four possible values .
Table lists all the possible values that ti ny float mantissas and exponents may assume .
The number shown in Figure is thus .

Table combines the mantissas and exponents to reveal all possible ti ny float values that we can .

The range of our tiny float numbers is .
Just stating the range is misleading , however , since .

Figure plots all the possible ti ny float values on the real number line .

Figure plot of all the possible ti ny float numbers on the real number line .
Note that the numbers are more dense near zero and become more sparse moving to the right .
The precision in the range .
The precision in the range .
In the range our tiny float type can represent only whole numbers .

There are many gaps ; for example , the value is missing and thus cannot be represented exactly is the closest .
As another example , and both appear , but is missing .

The scheme duplicates some numbers ; for example , three different bit patterns represent the decimal value : This duplication limits the number of different values that can be represented by given number of bits .
In our ti ny float example of the bit strings are redundant .

The numbers are not uniformly dense .
There are more values nearer to zero , and the numbers become more sparse farther away from zero .

Our unsigned tiny type discussed in Section exhibits none of these weaknesses .
All integers in given range are present , no two bit strings represent the same value , and the integers are uniformly distributed across their specified range .
While the standard integer types provided by have much greater ranges than our unsigned tiny type , they all share these same qualities : all values in their ranges are present , and all bit strings represent unique integer values .
The standard types provided by use many more bits than our tiny float type , yet they exhibit the same problems .

Table : The tiny float values .
The first three bits of the bit string constitute the mantissa , and the last two bits represent the exponent .
Given five bits we can produce different bit strings .
Notice that due to the ways different mantissas and exponents can combine to produce identical values , the different bit strings yield only unique tiny float values .

This is not solely problem of implementation of numbers ; all computer languages and hardware that adhere to the IEEE standard exhibit these problems .
To overcome these problems and truly represent and compute with mathematical real numbers we would need computer with an infinite amount of memory along with an infinitely fast processor .

The program uses an additional nclude directive : ttinclude This preprocessor directive allows us to use the std   setp reci si on output stream manipulator that directs the std   cout output stream object to print more decimal places in values .
During the execution , the first subtraction yields the correct answer .
We now know that some point numbers have exact internal representations while others are only approximations .
The exact answer for the second subtraction should be , and if we round the reported result to decimal places , the answer matches .
arithmetic often produces results that are close approximations of the true answer .

Listing  computes zero in roundabout .

The number has an exact decimal representation ,
It also has an exact binary representation ,

Surely the reported answer  is close to the correct .

Being careful to avoid overflow and underflow , integer arithmetic is exact and , on most computer tems , faster than arithmetic .
If an application demands the absolute correct answer and gers are appropriate for the computation , you should choose integers .
For example , in financial calculations it is important to keep track of every cent .
The exact nature of integer arithmetic makes integers an attractive option .
When dealing with numbers , an integer type should be the first choice of programmers .

The limitations of numbers are unavoidable since computers have finite resources .
promise is inevitable even when we do our best to approximate values with infinite characteristics in finite way .
Despite their inexactness , numbers are used every day throughout the world to solve sophisticated scientific and engineering problems ; for example , the appropriate use of numbers have enabled space probes to reach distant planets .
In the example programs above that demonstrate the inexactness of numbers , the problems largely go away if we agree that we must compute with the most digits possible and then round the result to fewer digits .
numbers provide good of precision for practicality .

variable may increase by or decrease by five .

The statement +  increments by  making it bigger than it was before this statement was executed .
has shorter statement that accomplishes the same effect :

When they appear alone in statement , the and versions of the increment and decrement operators work identically .
Their behavior is different when they are embedded within more complex statement .
Listing demonstrates how the and increment operators work slightly differently .

If has the just before the statement .

If has the just before the statement ; then immediately after the statement executes is and is also .

As you can see , the operator uses the new of the incremented variable when uating the overall expression .
In contrast , the operator uses the original of the cremented variable when evaluating the overall expression .
The and operator behaves similarly .

For beginning programmers it is best to avoid using the increment and decrement operators within more complex expressions .
We will use them frequently as standalone statements since there is no danger of misinterpreting their behavior when they are not part of more complex expression .

provides more general way of simplifying statement that modifies variable through simple .

This means the statement .

The arithmetic assignment is especially handy if variable with long name is to be modified ; consider + versus .

Do not accidentally reverse the order of the symbols for the arithmetic assignment .

These special operators allow programmers to examine or manipulate the individual bits that make up data values .
They known as the bitwise operators .
These operators consist of ,  
Applications programmers generally do not need to use bitwise operators very often , but bit manipulation is essential in many systems programming tasks .

Consider unsigned integers .
The bit positions usually numbered right to left , starting with zero .
Figure shows how the individual bit positions often numbered .

The bitwise operator , takes two integer subexpressions computes an integer result .
The expression is evaluated as follows : If bit in both ei is , then bit in the result is ; otherwise , bit in the result is .

The bitwise or operator , takes two integer subexpressions computes an integer result .
The pression ei is evaluated as follows : If bit in both is , then bit in the result is ; otherwise , bit in the result is .

For example , the expression evaluates to , since : Bits zero in both .
In bits either has one or has one ; therefore , the result has ones in bits zeroes everywhere else .

The bitwise exclusive or refered to as xor operator takes two integer subexpressions computes an integer result .
The expression is evaluated as follows : If bit in is the same as bit in .

If bit in is the same as bit in  then bit in the result is ; otherwise , bit in the result .

For example , the expression evaluates to ,

The bits match in all the other positions , so these positions must be set to zero in the result .

The bitwise negation operator is unary operator that inverts all the bits of its expression .
The expression is evaluated as .

Signed integers use representation called complement binary , slight variation of the standard binary layout .
Suffice it to say that the nt expression evaluates to the same bit pattern as , but as signed integer it represents .

The shift operators move all the bits in an integer to the left or .

Shift left .
The expression , where are integer types , shifts all the bits in to the left places .
Zeros fill vacated positions .
The bits shifted off the left side are discarded .

The expression evaluates to , since shifted two places to the left yields Observe that is equal to .

Shift right .
The expression , where are integer types , shifts all the bits in to the right places .
What fills the vacated bits on the left depends on whether the integer is signed or unsigned example , nt vs .

The bits shifted off the right side are discarded .
The expression evaluates to , since shifted two places to the left yields original bits in positions .

Do not confuse the left shift operator with the output stream insertion tor .
The operators are identical , but the context differentiates them .
If the left operand is an integer type , means left shift ; if the left operand is stream put object like std : means send the operand to the output stream object for display .

Similarly , the input stream object std   ci uses the for different purpose from the right shift operator used with integers .

Developers use bitwise operations for variety of programming tasks .
For example , in graphical user interface , the user generates events by interacting with an application using the mouse and keyboard .
One event might be clicking mouse button over particular graphical element within window .
Multiple pieces of information about this event can be stored in single integer .

For example , bit may indicate whether or not the key was held down when the mouse button was clicked .
Bit may be responsible for the Rjn key , bit for the key , etc .

This might require different action on the part of the program than if some other combination of keys were being pressed .
For example , suppose the nt variable holds information about which keys the user was depressing during the most recent mouse click .

The bit string .

If the answer is zero , this means bit is in  and so the .

Do you see how the expression means both keys are down simultaneously .

We can use masks to ensure that certain bits are on or off .
To see how , consider the mask , which is If is integer variable , we can selectively turn on its bits and with the statement .

Next , consider the unsigned value , which is , or .

If is integer variable , we can selectively turn off its bits and with the statement ; We cannot fully appreciate the utility of using bitwise operators for masking purposes until we consider conditional execution in Even then , since we concentrate on applications programming instead of systems programming in this book , we will have little use for the bitwise operators except for few isolated situations .
It is good to be aware of their presence , though , since their accidental use may lead to difficult to diagnose compiler messages and logic errors .

Like the other arithmetic operators that work on two operands , we may combine the bitwise binary operators ,  and with assignment to simplify the modification of variable ; for example , the following statement  Turn on bits in determined by .

computer program is one example of an algorithm , as is recipe to make lasagna .

In the case of lasagna , the noodles must be cooked in boiling water before they are layered into the filling to be baked .
It would be inappropriate to place the raw noodles into the pan with all the other ingredients , bake it , and then later remove the already baked noodles to cook them in boiling water separately .
In the same way , the ordering of steps is very important in computer program .
While this point may be obvious , consider the following sound argument :
The relationship between degrees Celsius and degrees Fahrenheit can be expressed as .

The English description provided above is correct .
No integer division .

At the point of the assignment , degreesF has the value of zero .
The executing program computes and assigns the variable before receiving value from the user .

As another example , suppose and are two integer variables in some program .
How would we interchange the values of the two variables .
We want to have original value and to have original value .
This code may seem reasonable :   The problem with this section of code is that after the first statement is executed , and both have the same value original .
The second assignment is superfluous and does nothing to change the values of or .
The solution requires third variable to remember the original value of one the variables before it is reassigned .
The correct code to swap the values is .

Informal notions about how to solve problem can be valuable in the early stages of program design , but the coded program requires correct detailed description of the solution .

The algorithms we have seen so far have been simple .
Statement , followed by Statement , etc .
Chapter and Chapter introduce some language constructs that permit optional and repetitive execution of some statements .
These constructs allow us to build programs that do much more interesting things , but more complex algorithms are required to make it happen .
We must not lose sight of the fact that complicated algorithm that is correct is not correct .

An design and implementation can be derailed by inattention to the smallest of details .

Sort the following binary operators in order of high to low  +

Write program that receives two integer values from the user .
The program then should print the sum , difference , product , quotient , and remainder after division .
Your program must use only integers .

Can you explain the results it produces for all of these operations .

Write program that receives two values from the user .
The program then should print the sum , difference , product , and quotient .
Your program should use only integers .

sample program run would look like user enters the and the after the colons , and the program prints the : Please enter the first number : Please enter the second number : +

Can you explain the results it produces for all these operations .
What happens if you attempt to .

Given the following .

What is the purpose of comments .

The programs in Listing , Listing , and Listing compile to the same machine code and behave exactly the same .
What makes one of the programs clearly better than the others .

Why is human readability such an important consideration .

Consider the following program which contains some errors .
You may assume that the comments within the program accurately describe the intended behavior .

For each line listed in the comments , indicate whether or not , or logic error is present .
Not all lines contain an error .

What distinguishes compiler warning from compiler error .
Should you be concerned about warnings .

What are the advantages to enhancing the warning reporting capabilities of the compiler .

Consider the following program that attempts to compute the circumference of circle given the radius entered by the user .
Given radius , the circumference , is given by the formula :

In mathematics , the midpoint between the two points , and is computed by the formula .

 Write program that receives two mathematical points from the user and computes and prints their midpoint .

sample run of the program produces .

The user literally enters " and " with the parentheses and commas as shown .
To see how to do this , suppose you want to allow user to enter the point , assigning the component of the point to variable named and the component to variable named .
You can add the following code fragment to your program to achieve the desired .

It next will assign to the variable .
It assigns the  character to the variable named comma , the value to the variable , and the character to the ri variable .
The , comma , and variables are just placeholders for the input and are not used elsewhere within the program .
In reality , the user can type in other characters in place of the parentheses and comma as long as the numbers are in the proper location relative to the characters ; for example , the user can type : and the program will interpret the input as the point .

Table lists the Calorie contents of several foods .
Running or walking burns off about Calories per mile .
Write program that requests three values from the user : the number of bean burritos , salads , and shakes consumed that .
The program should then display the number of miles that must be run or walked to burn off the Calories represented in that food .
The program should run as follows user types in the : Number of bean burritos , bowls of salad , and milkshakes eaten .

You will have to run miles to expend that much energy .

All the programs in the preceding chapters execute exactly the same statements regardless of the input , if any , provided to them .
They follow linear sequence : Statement , Statement , etc .
Linear programs like these are very limited in the problems they can solve .
This chapter introduces constructs that allow program statements to be optionally executed , depending on the context of the execution .

While Boolean expressions may appear very limited on the surface , they are essential for building more interesting and useful programs .

supports the data type bool , which stands for Boolean .
The term Boolean comes from the name of the British mathematician George Boole .
branch of discrete mathematics called Boolean algebra is dedicated to the study of the properties and the manipulation of logical expressions .

Compared to the numeric types , the bool type is very simple in that it can represent only two values : true or false .
Listing is simple program demonstrating the use of Boolean ables .

As you can see from running Listing , the Boolean values false and true are represented as integer and integer .
More precisely , zero represents the bool value false , and any integer or means true .
The direct assignment to bool variable of an integer other than or may result in warning reports truncation of ' to , but the variable is still interpreted as true .
The data type bool is basically convenience for programmers ; any program that uses bool variables can be rewritten using integers instead to achieve the same results .
While Boolean values and variables are freely compatible and interchangeable with integers , the bool type is convenient and should be used when the context involves truth values instead of numbers .

It is important to note that the Visual compiler issues warnings for the last two assignment ments in Listing .
Even though any value is considered true , is the preferred integer equivalent to true you can see when you attempt to print the literal value .
Since the need to assign to Boolean variable value other than true or false or the equivalent or should be extremely rare , the message alerts the programmer to check to make sure the assignment is not mistake .

Boolean variable is also Boolean expression .
An expression comparing numeric expressions for equality or inequality is also Boolean expression .
The simplest kinds of Boolean expressions use relational operators to compare two expressions .
Table lists the relational operators available in .

Table shows some simple Boolean expressions with their associated values .
An expression like is legal but of little use , since the expression true is equivalent , simpler , and less likely to confuse human readers .
Boolean expressions are extremely useful when their truth values depend on the values of one or more variables .

The relational operators are binary operators and are all left associative .
They all have lower dence than any of the arithmetic operators ; therefore , the expression .

If you make mistake and as shown here .
Visual will issue warning that includes message .

Recall from Section that compiler warning does not indicate violation of .

Why are expressions allowed as statements .
Some simple expressions have side effects that do alter behavior of program .
One example of such an pression is + +
Listing showed how + + behaves both as standalone statement and as an expression within larger statement .
more mon example is of function call is an as standalone statement .
tunately , most compilers issue informative warnings about useless expressionstatements to keep developers on track .

Boolean expressions described in Section at first may seem arcane and of little in practical programs .
Boolean expressions are essential for program to be able to adapt its behavior at run time .
Most truly useful and practical programs would be impossible without availability of Boolean expressions .

One way that Listing can fail is when user enters zero for divisor .
Fortunately , programmers can take steps to ensure that division by zero does not occur .
Listing shows how it might be done .

In this case , printing statement is executed only if variable di vi value is not zero .

Boolean expression determines if single statement that follows right parenthesis is executed .
If is not zero , message is printed ; otherwise , program prints nothing .

Figure shows how program execution flows through statement , of Listing .

Good coding style dictates we should indent body to emphasize optional execution and improve readability .
Sometimes programmers will place body on same line as  for example , following statement optionally assigns  if .

This is legal in ; it means the statement has an empty body .
In which case the assignment is not part of the body .
The assignment statement is after the body and always will be executed regardless of the truth value of the Boolean expression .

Since an assignment statement has value value that is assigned , see Section .
It is , however , almost always mistake when beginning programmers in this context .
sual at warning Level checks for the of assignment within conditional expression ; the default Level does not .

Listing shows how you must curly braces to group multiple statements together .

The assignment statement and printing statement are both part of the body of the statement .
Given the truth value of the Boolean expression during particular program run , either both statements will be executed or neither statement will be executed .

compound statement consists of zero or more statements grouped within curly braces .
We say the curly braces define block of statements .
As matter of style many programmers always curly braces .

The format of the following code .

Since multiple statements making up the body must be in compound statement within curly braces , the compiler interprets the code fragment as if it had been written .

The programmer probably meant to write it as .

The curly braces are optional if the body consists of single statement .
If the body consists of only one statement and curly braces are not used , then the semicolon that terminates the statement in the body also terminates the statement .
If curly braces are used to delimit the body , semicolon is not required after the close curly brace .

An empty pair of curly braces represents an empty block .
An empty block is valid compound ment .

One undesirable aspect of Listing is if the user enters zero  the program prints nothing .
It may be better to provide some feedback to the user to indicate that the provided cannot be used .
The statement has an optional else clause that is executed only if the Boolean sion is false .
Listing uses the statement to provide the desired effect .

The else clause contains an alternate body that is executed if the condition is false .
The flow of execution is shown in Figure Listing avoids the division by zero error that causes the program to terminate prematurely , but it still alerts the user that there is problem .
Another application may handle the situation in different way ; for example , it may substitute some default value for di vi sor instead of zero .

The general form of an statement is .

The reserved word begins the statement .

The condition is Boolean expression that determines whether the running program will execute statement or statement .
As with the simple statement , the condition must appear within parentheses .

The program executes statement if the condition is true .
To make the statement more readable , indent statement more spaces than the line .
This part of the statement is sometimes called the body of the .

The reserved word else begins the second part of the statement .

The program executes statement if the condition is false .
To make the statement more readable , indent statement more spaces than the else line .
This part of the statement is sometimes called the body of the else .

The body of the else clause of an statement may be compound .

If you ever attempt to use an statement and discover that you need to leave the else clause .

Due to the imprecise representation of numbers Listing in Section  programmers must use caution when using the equality by itself to compare expressions .
Listing uses an statement to demonstrate the perils of using the equality with quantities .

In Listing the displayed values of and are rounded so they appear equivalent , but internally the exact representations are slightly different .
By including the header omani we can use the std : stream manipulator to force display more decimal places in the number it prints .
Observe from the output of Listing that the two quantities that should be identically are actually slightly different .

Simple Boolean expressions , each involving one relational  can be combined into more complex .

To introduce compound Boolean expressions , consider computer science degree that requires , among other computing courses .
Operating Systems and Programming Languages .
If we isolate those two courses , we can say student must successfully complete both Operating Systems and Programming Languages to qualify for the degree .
student that passes Operating Systems but not Programming Languages will not have met the requirements .
Similarly , Programming Languages without Operating Systems is insufficient , and student completing neither Operating Systems nor Programming Languages surely does not qualify .

Logical AND works in exactly the same way .
If and ei are two Boolean expressions , is true only if and ei are both true ; if either one is false or both are false , the compound expression is false .

To illustrate logical OR , consider two mathematics courses .
Differential Equations and Linear Algebra .

computer science degree requires one of those two courses .
student who successfully completes Differential Equations but does not take Linear Algebra meets the requirement .
Similarly , student may take Linear Algebra but not Differential Equations .
It is important to note the student may elect to take both Differential Equations and Linear Algebra on the way to mathematics , but the requirement is no less fulfilled .

Logical OR works in similar fashion .
Given our Boolean expressions and c  the compound pression is false only if and are both false ; if either one is true or both are true , the compound expression is true .
Note that logical OR is an inclusive or , not an exclusive or .
In informal conversion we often imply exclusive or in statement like you like cake or ice cream for " The tion is one or the other , not both .
In computer programming the or is inclusive ; if both subexpressions in an or expression are true , the or expression is true .

It shows all the combinations of truth values for two simple .

Logical not is unary operator Section  it requires single Boolean operand immediately to its right .

This means the expression is evaluated .

The relational operators such as compare two operands .
The result of the parison is Boolean value , which is freely convertible to an integer .
The cation of relational operators can lead to surprising results ; consider , for example , the expression This expression is always true , regardless of the value of .
If the intent is to represent the mathematical notion of falling within the range .

The expression is evaluated as If is greater than or equal to one , the evaluates to true , or integer .
Integer , however , is always less than , so the overall sion is true .
If instead is less than one , the evaluates to false , or integer .
Integer is always less than , so the overall expression is true .
The problem is due to the fact that does not strictly distinguish between Boolean and integer values .

correct way to represent the mathematical notion of is In this case must simultaneously be greater than or equal to and less than or equal to .
The revised Boolean expression is little more verbose than the mathematical representation , but it is the correct formulation for .

The following section of code assigns the indicated values to bool : bool ; int ; int .

Since the operator evaluates left to right , this means that if is false , there is no need to evaluate If is false , no value of can make the expression ei true .
The logical and operator first tests the expression to its left .
If it finds the expression to be false , it does not bother to check the right expression .

This approach is called evaluation .
In similar fashion , in the expression ej , if is true , then it does not matter what value ei logical or expression is true unless both subexpressions are false .
The operator uses evaluation also .

Why is evaluation important .
Two situations show why it is important to .

The order of the subexpressions can affect performance .
When program is running , complex pressions require more time for the computer to evaluate than simpler expressions .
We classify an expression that takes relatively long time to evaluate as an expensive expression .
If compound Boolean expression is made up of an expensive Boolean subexpression and an less expensive Boolean subexpression , and the order of evaluation of the two expressions does not affect the behavior of the program , then place the more expensive Boolean expression second .
If the first subexpression is false and is being used , then the expensive second subexpression is not evaluated ; if the first pression is true and is being used , then , again , the expensive second subexpression is avoided .

Subexpressions can be ordered to prevent errors .
This is especially true when one of the .

Suppose you wish to print word " if variable is , or .

The correct statement would be .

We can use nested statements to build arbitrarily complex control flow logic .

Listing behaves as .

The program checks condition first .
If is less than zero , executing program does not evaluate second condition and does not print In range , but it immediately executes print statement following outer statement which prints Done .

If executing program finds to be greater than or equal to zero , it checks second condition .
If second condition is met , it displays In range message ; otherwise , it is not .

Regardless , program prints Done before it terminates .

For program to display message In range both conditions of this nested must be met .
Said another way , first condition and second condition must be met for In range message to be printed .

Listing shows .

Listing uses logical to check both conditions at same time .
Its logic is simpler , using only one statement , at expense of slightly more complex Boolean expression in its condition .
The second version is preferable here because simpler logic is usually desirable goal .

Sometimes logic cannot be simplified as in Listing .
In Listing one statement alone is insufficient to implement necessary behavior .

Listing provides more specific message instead of simple notification of acceptance .
The program prints exactly one of three messages based on of variable .
single or statement cannot choose from among more than two different execution paths .

Listing uses series of statements to print binary string ing binary equivalent of decimal integer supplied by user .

The outer checks to see if use provides is in proper range .
The program works only for nonnegative integer values less than , so the range is .

Each inner compares the entered integer against decreasing powers of two .
If the number is large enough , the program : prints the digit to the console , and removes via the remainder operator that power of contribution to the .

If the number is not at least as big as the given power of two , the program prints instead and moves on without modifying the input .

For the ones place at the end no check is remaining will be or and so the program prints whatever remains .

The following shows sample run of Listing .

Figure illustrates the execution of Listing when the user enters .

It uses only one statement .

The sole statement in Listing ensures that the user provides an ger in the proper range .
The other statements that originally appeared in Listing are gone .
clever sequence of integer arithmetic operations replace the original conditional logic .
The two and identically but logic is simpler .

Listing .

This very simple troubleshooting program attempts to diagnose why computer does not work .
The potential for enhancement is unlimited , but this version only deals with power issues that have simple fixes .

Notice that if the computer has power or disk drive makes sounds or lights are , the program directs the user to seek help elsewhere .
The decision tree capturing the basic logic of the program is shown in Figure The steps performed .

If applicable , is the fuse blown .
Some computer systems have fuse that can blow out during power surge .
Is there power at the receptacle .
Perhaps the circuit breaker or fuse has problem .

The program directs the user to make the easier checks first .
It progressively introduces more difficult checks as it continues .
Based on your experience with troubleshooting computers that do not run properly , you may be able to think of many enhancements to this simple program .

Note that in Listing curly braces are used in many places where they strictly are not necessary .
Their inclusion in Listing improves the readability of the gram and makes the logic easier to understand .
Even if you do not subscribe to the philosophy of using curly braces for every body , it is good idea to use them in situations that improve the readability .

Suppose we wish to improve the English presentation by not using abbreviations .
If we spell out hours , minutes , and seconds , we must be careful to use the singular form hour , minute , or second when the corresponding value is one .
Listing uses if statements to express to time units with the correct number .

In Listing each code segment responsible for printing time value and its English word unit is protected by an statement that only allows the code to execute if the time value is greater than zero .
The exception is in the processing of  if all time values are zero , the program should print .
Note that each of the statements responsible for determining the singular or plural form is nested within the statement that determines whether or not the value will be printed at all .

Listing showed how to select from among three options .

It prints exactly one of eight messages depending on the input .

Notice that each body contains single printing statement and each else body , except the last one , contains an statement .
The control logic forces the program execution to check each tion in turn .
The first condition that matches wins , and its corresponding body will be executed .

If none of the conditions are true , the last Too large message will be printed .

No curly braces are necessary to delimit the if or else bodies since each body contains only single statement single deeply nested statement is mighty big .

The sequence of else lines all indented to the same level identifies this construct as statement .

Listing uses to transform numeric date in format to an expanded US English form and an international Spanish form ; for example , would be converted to February and febrero .

Figure compares the structure of the statements in program such as Listing to those in program like Listing .

In program like Listing , the statements are nested , while in program like Listing the statements are sequential .

provides the tools to construct some very complicated conditional statements .
It is important to resist the urge to make things overly complex .
Consider the problem of computing the maximum of five integer values provided by the user .
The complete solution is left as an exercise in Section but here we will outline an appropriate strategy .

Now , allow yourself one extra variable called max .
All variables have meaning , and their names .

Set max equal to nl .
This means as far as we know at the moment , nl is the biggest number because max and nl have the same value .

Compare max to .
If is larger than max , change max to have value to reflect the fact that we determined is larger ; if is not larger than max , we have no reason to change max , so do not change it .

Compare max to .
If is larger than max , change max to have value to reflect the fact that we determined is larger ; if is not larger than max , we have no reason to change max , so do not change it .

Follow the same process for and .

The extra variable max is not strictly necessary , but it makes thinking about the problem and its solution easier .

Something to think about : Do you want series of statements or one large multiway construct .

Also , you may be tempted to write logic such as .

This will work , but this logic is much more complicated and less efficient and operation requires few machine cycles to .
Since it is more complicated , it is more difficult to write correctly , in addition to being more code to type in .
It is easy to use by mistake instead , which will not produce the correct results .
Also , if you use this more complicated logic and decide later to add more variables , you will need to change all the conditions in your code and , course , make sure to modify each one the conditions correctly .
If you implement the simpler strategy outlined before , you need only add one simple statement for each additional variable .

Chapter introduces loops , the ability to execute statements repeatedly .
You easily can adapt the first approach to allow the user to type in as many numbers as they like and then have the program report the maximum number the user entered .
The second approach with the more complex logic cannot be adapted in this manner .
With the first approach you end up with cleaner , simpler logic , more efficient program , and code that is easier to extend .

Listing demonstrates common the assignment operator where the equality operator is intended .
This program , when run , always prints the message " and insists the user entered regardless the actual .
Recall from Section that the assignment expression has value .
The value an assignment expression is same as the value that is assigned ; thus , the expression .

Additionally , the variable nput is always assigned the value .

Since it is such common coding error , most compilers can check for such misuse assignment .
At warning Level , for example .
Visual will issue warning when assignment appears where conditional expression is expected : warning : assignment within conditional expression Occasionally the use assignment within conditional expression is warranted , so the compiler does not perform this check by default .
For our purposes it is good idea to direct the compiler to perform this extra check .

Carefully consider each compound conditional used , such as found in .
Confusing logical and and logical or is common programming error .
If you substitute for , the expression is always true , no matter what is assigned to the variable .
Boolean expression that is always true is known as tautology .

If is an nt , what could the variable assume that would make false .
Regardless its  one or both the subexpressions will be true , so this compound logical or expression is always true .
This particular or expression is just complicated way expressing the true .

Another common error is contriving compound Boolean expressions that are always false , known as contradictions .
Suppose you wish to exclude values from given range ; for example , reject values in the range and accept all other numbers .
Is the Boolean expression in the following code fragment up to the task .

What number can be both less than zero and greater than ten at the same timel None can , course , so the expression is contradiction and cated way expressing false .
To correct this code fragment , replace the operator with .

Write program that requests an integer value from the user .
If the value is between and inclusive , print " otherwise , do not print anything .

Write program that requests an integer value from the user .
If the value is between and inclusive , print " otherwise , print of "
The following program attempts to print message containing the English word corresponding to given integer input .
For example , if the user enters the value , the program should print entered .
In its current state , the program contains logic errors .
Locate the problems and repair them so the program will work as expected .

Write program that requests five integer values from the user .
It then prints the maximum and minimum values entered .
If the user enters the values , and , the program would indicate that is the maximum and is the minimum .
Your program should handle ties properly ; for example , if the user enters , and , the program should report as the minimum and as maximum .

Write program that requests five integer values from the user .
It then prints one of two things : if any of the values entered are duplicates , it prints ; otherwise , it prints .

How would you write the code to to .
Would you copy , paste , and modify printing statements .

Counting is such common activity , and computers routinely up to very large values , so there must be better way .
What we really would like to do is print the value of variable it , then increment the variable , and repeat this process until the variable is large enough or perhaps .
This process of executing the same section of code over and over is known as iteration , or looping  and in we can implement loops in several different ways .

Listing uses while statement to display variable that is counting up to five .
Unlike the approach taken in Listing , it is trivial to modify Listing to up to change the literal value to .

The expression within the parentheses must be Boolean expression .
If the Boolean expression is true when the the execution reaches the whi le statement , the program executes the body of the whi le statement and then checks the condition again .
The program repeatedly executes the within the body of the whi le as long as the Boolean expression remains true .

If the Boolean expression is true when the whi le statement is executed , the body of the whi le ment is executed , and the body is executed repeatedly as long as the Boolean expression remains true .

The statements '  constitute the body of the whi le statement .
The curly braces are necessary since more than one statement makes up the body .

The while statement has the general .

The reserved word whi le begins the whi le statement .

The Boolean expression condition determines whether the body will be will continue to cuted .
The expression must be enclosed within parentheses as shown .

The statement is the statement to be executed while the Boolean expression is true .
The statement makes up the body of the whi le statement .
The statement may be compound statement statements enclosed within curly braces , see .

Except for using the reserved word while instead of , whi le statement looks identical to an statement .
Sometimes beginning programmers confuse the two or accidentally type when they mean whi le or .
Usually the very different behavior of the two statements reveals the problem immediately ; however , sometimes , especially in nested complex logic , this mistake can be hard to detect .

Figure shows how program execution flows through Listing .

The program checks the whi condition before executing the body , and then the condition each time after it executes the body .
If the condition is initially false the execution skips the body completely and continues executing the statements that follow the whi body .
If the condition is initially true , the program repeatedly executes the body until the condition becomes false , at which point the loop terminates .
Program execution then continues with the statements that follow the body , if any .
Observe that the body may never be executed if the Boolean expression in the condition is initially false .

Listing counts up from zero as long as the user wishes to do so .

The Boolean variable controls the execution .
It is important to note that the expression inside the condition evaluates to the opposite truth value of the variable  the expression does not affect the value of .

Listing is program that allows user to enter any number nonnegative integers .
When the user enters negative value , the program no longer accepts  and it displays the .

The initialization to zero coupled with the condition the whi le guarantees that program will execute the body the while loop at least once .
The if statement ensures that negative entry will not be added to sum .
The execution then leaves the loop and executes the print statement at the end .

Listing shows that whi le loop can be used for more than simple counting .

The program does not keep track the number values entered .
The program simply accumulates the .

It is little awkward in Listing that the same condition appears twice , once in the whi le and again in the .
Furthermore , what if the user wishes to enter negative values along with nonnegative values .
We can simplify the code with common idiom that uses std   ci and the extraction operator as condition within whi le statement .

If is an integer , the expression .

When the user enters    the loop is terminated .
If the user types   at the beginning , the loop is not entered .
The statement is no longer necessary , since the statement  can be executed only if has been legitimately assigned .
Also , the variable no longer needs to initialized with value simply so the loop is entered the first time ; now it is assigned and then checked within the condition the whi le .

In Listing , the execution will terminate with any letter the user types ; an entry   or will terminate the sequence just as well as 

It you wish to use this technique and reuse std   ci later , you must reset std   ci and extract and discard keystrokes entered since the last valid use the extractor operator .
This recovery process is covered in Section but , for now , use this idiom to control loop only if the program does not require additional user later during its execution .

It is customary to right justify column numbers , but Listing prints the powers ten with their digit left aligned .
We can right align the numbers using stream object called steam manipulator .
The specific stream manipulator we need is named std 

Observe that in order to use the compiler needs to be made aware it .
The needed information about std   is not found in the ostream header file , so an additional preprocessor include directive is required : ttinclude The std :  manipulator " the output stream for the next item to be printed .
The values passed to the " stream are all right justified within the number spaces specified by std :

As an aside , this is good place to reveal another trick to improve the output program .

We can use whi le statement to make Listing .

The bulk of the body of the Listing wrapped by whi le statement .
The Boolean variable is often called flag .
You can think of the flag being down when the value is false and raised when it is true .
In this case , when the flag is raised , it is signal that the program should terminate .

In the way this code is organized , the matching opening curly brace of particular closing curly brace can be found by scanning upward in the source code until the closest opening curly brace at the same indentation level is found .
Our programming logic is now getting complex enough that the proper placement of curly braces is crucial for human readers to more quickly decipher how the program should work .
See for guidelines on indentation and curly brace placement to improve code readability .

Just like in statements , while bodies can contain arbitrary statements , including other while statements .
loop can therefore be nested within another loop .
To see how nested loops work , consider program that prints out multiplication table .
Elementary school students use multiplication tables , or times tables , as they learn the products of integers up to or even .
multiplication table .
We want our multiplication table program to be flexible and allow the user to specify the size .
We will begin our development work with simple program and add features as we go .
First , we will not worry about printing the row and column titles , nor will we print the lines separating the titles from the contents of the table .
Initially we will print only the contents of the table .
We will see we need nested loop to print the contents , but that still is too much to manage in our first attempt .
In our first attempt we will print the rows of the table in very rudimentary manner .
Once we are satisfied that .

Listing does indeed print each in its proper just does not supply the needed detail for each .
Our next step is to refine the way the program prints each .
Each should contain size numbers .
Each number within each represents the product of the current and current column ; for example , the number in , column should be .
In each  therefore , we must vary the column number from from to size .
Listing contains the needed refinement .

The numbers within each column are not lined up nicely , but the numbers are in their correct positions tive to each other .
We can use the std   setw stream manipulator introduced in Listing to right justify the numbers within area .
Listing contains this ment adjustment .

Listing adds the necessary code .

This is how Listing .

It is important to distinguish what is done only once all from that which is done repeatedly .
The column heading across the top of the table is outside of all the loops ; therefore , it is printed all at once .

The work to print the heading for the rows is distributed throughout the execution of the outer loop .

This is because the heading for given row cannot be printed until all the results for the previous row have been printed .

code fragment like if    prints in one of two ways : if is number , it prints space before it ; otherwise , it does not print the extra space .
The net effect is to right justify one and two digit numbers within two character space printing area .
This technique allows the columns within the times table to be properly right aligned .

In the nested loop , row is the control variable for the outer loop ; column controls the inner loop .

newline is printed after the contents of each row is displayed ; thus , all the values printed in the inner loop appear on the same line .

Nested loops are used when an iterative process itself must be repeated .
In our times table example , whi le loop is used to print the contents of each row , but multiple rows must be printed .
The inner loop prints the contents of each row , while the outer is responsible for printing all the rows .

Listing uses loop to print all the different arrangements of the letters , and .
Each string printed is permutation of ABC .

The executing program checks this condition only at the " of the loop .
This means that even if the Boolean expression that makes up the condition becomes false before the program completes executing all the statements within the body of the loop , all the remaining statements in the body must complete before the loop can once again check its condition .
In other words , the while statement in and of itself cannot exit its loop somewhere in the middle of its body .

Ordinarily this behavior is not problem .
Usually the intention is to execute all the statements within the body as an indivisible unit .
Sometimes , however , it is desirable to immediately exit the body or recheck the condition from the middle of the loop instead .
provides the break and conti nue statements to to give programmers more flexibility designing the control logic of loops .

The break statement causes the immediate exit from the body of the loop .
is variation of Listing .

The condition of the whi le in Listing is tautology .
This means the condition is true and can never be false .
When the execution reaches the whi le statement it is guaranteed to enter the body and the whi le loop itself does not provide way of escape .
The statement in the .

In this case the break statement , executed conditionally based on the value of the variable nput , exits the loop .
In Listing the break statement executes only when the user enters negative number .
When the execution encounters the break statement , it immediately jumps out of the loop .
It skips any statements following the break within the body .

Some software designers believe that programmers should use the break statement sparingly because it deviates from the normal loop control logic .
Ideally , every loop should have single entry point and single exit point .
While Listing has single exit point break , some programmers commonly use break statements within while statements in the which the condition for the while is not tautology .
Adding break statement to such loop adds an extra exit point top of the loop where the condition is checked is one point , and the break statement is .
Using multiple break statements within single loop is particularly dubious and you should avoid that practice .

Why have the break statement at all if its use is questionable and it is dispensable .
The logic in Listing is fairly simple , so the restructuring of Listing is straightforward ; in general , the effort to restructure code to avoid break statement may complicate the logic bit and require the introduction of an additional Boolean variable .
As shown in Figure any program that uses break statement can be rewritten so that the break statement is not used .

The version introduces Boolean variable , and the loop control logic is little more plicated .
The version uses more memory extra and more time to execute an extra check in the loop condition during every iteration of the .
This extra memory is insignificant , and except for rare , specialized applications , the extra execution time is imperceptible .
In most cases , the more important issue is that the more complicated the control logic for given section of code , the more difficult the code is to write correctly .
In some situations , even though it violates the entry point , single exit point " principle , simple break statement is an acceptable loop control option .

break statement is insufficient to jump completely out of the middle of nested loop .
The goto statement allows the execution flow to jump to specified location within the function .
Listing uses goto statement to jump out from the middle of nested loop .

When is , program flow will jump to the specified label within the program .
In this example , the label is named end , but this name is arbitrary .
Like variable names , label names should be chosen to indicate their intended purpose .
The label here named end comes after and outside the nested whi le loops .

name is an identifier Section  and label is distinguished by the colon that ately follows its name .
label represents target to which goto can jump .
goto label must appear before statement within function .

With the goto statement , the whi le is superfluous ; for example .
Listing could be rewritten without the whi le statement as shown in Listing .

Early programming languages like FORTRAN and early versions of BASIC did not have structured statements like whi le , so programmers were forced to use goto statements to write loops .
The problem with using goto statements is that it is easy to develop program logic that is very difficult to understand , even for the original author of the code .
See the Wikipedia article about spaghetti code 

The structured programming revolution of the introduced constructs such as the whi le statement and resulted in the disappearance of the use of goto in most situations .
All modern programming languages have form of the whi le statement , so the goto statement in is largely ignored except for the case of breaking out of nested loop .
You similarly should restrict your use of the goto statement to the abnormal exit of nested loops .

The conti nue statement is similar to the break statement , except the conti nue statement does not necessarily exit the loop .
The conti nue statement skips the rest of the body of the loop and immediately checks the condition .
If the condition remains true , the execution resumes at the top of the loop .
Listing shows the conti nue statement in action .

Programmers do not use the continue statement as frequently as the break statement since it is easy .

The transformation is simpler than for break elimination ure since the condition remains the same , and no additional variable is needed .

The version that uses conti nue is no more efficient than the version that uses else ; in fact , the sual and GNU compilers generate the same machine language code for and Listing .
Also , the logic of the else version is no more complex than the continue version .
Therefore , unlike the break statement above , there is no compelling reason to use the continue statement .
Sometimes programmer may add continue statement at the last minute to an existing loop body to handle an exceptional condition ignoring negative numbers in the example that initially went unnoticed .
If the body of the loop is lengthy , the programmer can add tional statement with continue near the top of the loop body without touching the logic of the rest of the loop .
The conti nue statement thus merely provides convenient alternative for the programmer .
The else version is preferred .

Some infinite loops are by design ; for example , server application , like Web .

Figure The code on the left generically represents any loop that uses continue statement .

All too often , however , beginning programmers create infinite loops by accident , and these infinite loops represent logic errors in their programs .

Intentional infinite loops should be made obvious .

It is easy to write an intentional infinite loop .
Accidental infinite loops are quite common , but can be puzzling for beginning programmers to diagnose and repair .
Consider Listing that attempts to print all the integers with their associated factors from to .

This type of behavior is frequent symptom of an unintentional infinite loop .
The factors of display properly , as do the factors of .
The first of is properly displayed and then the program hangs .
Since the program is short , the problem may be easy to locate .
In some programs , though , the error may be challenging to find .
Even in Listing the debugging task is nontrivial since it involves nested loops .

Perhaps the programmer intended to use instead of to stay in the loop as long as remains in the range .

In Listing the outer loop condition is If is and is , then the condition is false , so this is not tautology .
Checking the inner loop condition : we see that if acto is and is , then the expression is false ; therefore , it also is not tautology .

The condition of whi le must be true initially to gain access to its body .
The code within the body must modify the state of the program in some way so as to influence the outcome of the condition that is checked at each iteration .
This usually means code within the body of the loop modifies one of the variables used in the condition .
Eventually the variable assumes value that makes the condition false , and the loop terminates .

In Listing the outer condition involves the variable and constant .

Fortunately , the last statement in the body of the outer loop increments .

The inner condition involves the variables and .
No statement in the inner loop modifies  so it is imperative that be modified in the loop .
The good news is is incremented in the body of the inner loop , but the bad news is the increment operation is protected within the body of the statement .
The inner loop contains one statement , the statement .
That statement in turn has two statements in its .

This new runs correctly .

Programmers can use debugger to step through program to see where and why an infinite loop arises .
Another common technique is to put print statements in strategic places to examine the values of the .

Under these conditions : is true , so the loop continues and .

This section provides several examples that show off the power of conditional execution and iteration .

Our program , however , must vary its height and width based on input from the user .

Listing provides the necessary functionality .

The program will execute the outer whi le body as long as the user enters value greater than zero ; if the user enters zero or less , the program terminates and does nothing .
This is the expected behavior .

The last statement in the body of the outer whi .

There is no possibility of an infinite loop here .

The body of the outer loop consists of more than one statement ; therefore , the body must be enclosed within curly braces .
Whenever group of statements is enclosed within curly braces block is formed .
Any variable declared within block is local to that block .
scope section of the source code in which the variable exists and can be is from its point of declaration to the end of the block in which it is declared .
For example , the variables height and are declared in the block that is mai body ; thus , they are local to mai .
The variable is declared within the block that is the body of the outer whi le statement ; therefore , is local to the outer whi le statement .
An attempt to use outside the body of the outer while statement would be an error .

What does it mean for variable to be local to particular section of code .
It means does not exist outside its scope .
There may be other variables in the program named , but they are different variables .
If it seems odd that you can have two different variables in the same program with the same name , consider the fact that there can be two people in the same room with the same name .
They are different people , but they have the same name .
Similarly , the meaning of variable depends on its context , and its name is not necessarily unique .

The two inner loops play distinct .

The first inner loop prints spaces .
The number of spaces printed is equal to the height of the tree the first time through the outer loop and decreases each iteration .
This is the correct behavior since each succeeding moving down contains fewer leading spaces but more asterisks .

The second inner loop prints the of asterisks that make up the tree .
The first time through the outer loop , is zero , so no left side asterisks are printed , one central asterisk is printed top of the , and no right side asterisks are printed .
Each time through the loop the number of and stars to print both increase by one and the same central asterisk is printed ; therefore , the tree grows one wider on each side each line moving down .
Observe how the + value expresses the needed number of asterisks perfectly .

While it seems asymmetrical , note that no third inner loop is required to print trailing spaces on the line after the asterisks are printed .
The spaces would be invisible , so there is no reason to print them .

For example , is prime number and divide into it with no , but is not , and are factors of .
Prime numbers were once merely an intellectual curiosity of mathematicians , but now they play an important role in cryptography and computer security .

The task is to write program that displays all the prime numbers up to value entered by the user .

The logic of Listing is little more complex than that of Listing .

The main loop whi le iterates over all the values from two to .

Two new  local to the body of the outer loop , are introduced : and me .

The expression is zero when divides into with no when tri actor is factor of .
If the executing program determines that any of the values of tri is factor of  then it sets me to false and exits the loop via the break .
If the loop continues to completion , the program never sets me to false , which means it found no factors and is indeed prime .

The statement after the inner .

If is true , then must be prime , so it prints along with an extra space for separation from output it may produce during subsequent iterations .

Some important questions we can ask include :
If the user enters , will it be printed .

In this case , so the condition of the outer loop is true ,
Thus , the inner loop is skipped , me is not changed from true , and is printed .
This behavior is correct because is the smallest prime number the only even .

The whi le condition ensures that values less than two are not considered .
The body of the whi le will never be entered .
Only the newline is printed , and no numbers are displayed .
This behavior is correct .

Is the inner loop guaranteed to always terminate .

In order to enter the body of the inner loop , must be less than  does not change anywhere in the loop .
Eventually , tri will equal  and the loop will terminate .

Is the outer loop guaranteed to always terminate .

In order to enter the body of the outer loop , must be less than or equal to .

Since the inner loop is teed to terminate as shown in the previous answer , eventually will exceed and the loop will end .

This version without the break introduces slightly more complicated condition for the whi le but moves the statement within its body , ri me is initialized to true before the loop .
Each time through the loop it is reassigned , tri will become false if at any time is zero .
This is exactly when is factor of .
If becomes false , the loop cannot continue , if never becomes false , the loop ends when comes equal to .
Due to operator precedence , the parentheses are not necessary .
The parentheses do improve readability , an expression including .
When parentheses are placed where they are not needed , as in +

Recall that with the operator the of the variable is used in the surrounding expression , then the variable is incremented .
Since the whi body now contains only one statement , the curly braces are not needed .

In Listing could the condition the statement have used instead achieved the same results .

In Listing could the condition the whi le statement have used instead achieved the same results .

Use loop to rewrite the following code fragment so that it uses just one std 

In Listing what would happen if the statement containing std   ci is .

How many asterisks does the following code fragment print .

How many asterisks does the following code fragment print .

How many asterisks does the following code fragment print .

What is printed by the following code fragment .

What is printed by the following code fragment .

Rewrite the following code fragment using break statement and eliminating the variable .

Your code should behave identically to this code fragment .

Rewrite the following fragment so it eliminates the conti nue statement .

Suppose you were given some from the in language that did not support structured statements like whi le .
Your task is to modernize it and adapt it to .
The following fragment has been adapted to already , but you must now structure it with whi le statement to replace the gotos .
Your should be goto free and still behave identically to this fragment .

What is printed by the following fragment .

Write program that accepts single integer value entered by the user .
If the value entered is less than one , the program prints nothing .
If the user enters positive integer ,  the program prints .

Write program that allows the user to enter exactly twenty .

Write program that allows the user to enter any number of nonnegative values .
The user terminates the input list with any negative value .
The program then prints the sum , average , maximum , and minimum of the values entered .
The nating negative value is not used in the computations .
If the first number the user supplies is negative , the program simply prints the text NO NUMBERS PROVIDED .

Redesign Listing so that it draws sideways tree pointing right ; for example , if .

The if and while statements are sufficient to implement any algorithms that involve conditional execution and looping .
The break and conti nue statements are convenient but are not necessary .
provides some additional conditional and iterative statements that are more convenient to use in some circumstances .
These additional statements include .

This chapter explores these other forms of expressing conditional execution and iteration .

The swi tch statement provides convenient alternative for some statements like the .

The reserved word swi tch identifies swi tch statement .

The required parenthesized expression that follows the word swi tch must evaluate to an integral value .
Any integer type , characters , and Boolean expressions are acceptable .
Floating point sions and other types are forbidden .

The body of the swi tch is enclosed by required curly braces .

Each occurrence of the word case is followed by an integral constant and colon .
We call the integral constant case label .
This label can be either literal value or const symbolic value Section .
In particular , variables and other expressions are expressly forbidden .

The case label defines position within the code ; it is not an executable statement .
case label represents target to which the execution flow can jump .

If the case label matches the expression , then the statements that follow that label are executed up until the break statement is encountered .
The statements and break statement that follow each case label are optional .
One way to execute one set of statements for more than one case label is to provide empty statements for one or more of the labels , as in : key ; get key from user .

If the user enters neither nor , none of the statements in the swi tch is executed .

When case label is matched , the statements that follow are executed until break statement is encountered .
The control flow then transfers out of the body of the swi tch .
In this way , the break within swi tch works just like break within loop : the rest of the body of the statement is skipped and program execution resumes at the next statement lowing the body .
missing break statement , common error , when its omission is not intentional , causes the statements of the succeeding case label to be executed .
The process continues until break is encountered or the end of the swi tch body is reached .

The default label is matched if none of the case labels match .
It serves as catch all option like the final else in statement .
The default label is optional .
If it is missing and none of the case labels match the expression , then no statement within the swi body is executed .

The swi tch statement has two restrictions that make it less general than the .

The swi tch argument must be an integral expression .

Case labels must be constant integral values .
Integral literals and constants are acceptable .
Variables or expressions are not allowed .

To illustrate these restrictions , consider the following statement that translates easily to an alent swi tch .

This code cannot be easily translated into swi tch statement .
The variable cannot be used as case label .
The second choice checks for an inequality instead of an exact match , so direct translation to case label is impossible .
In the last condition , different variable is checked , instead of .
The control flow of switch statement is determined by single value example , the value of , but statement is not so constrained .

Where applicable , swi tch statement allows programmers to compactly express selection logic .
Most programmers find swi tch statement easier to read than an equivalent construct .

positive consequence of the swi tch restrictions is that it allows the compiler to produce more efficient code for swi tch than for an equivalent .
If choice must be made from one of several or more options , and the swi tch statement can be used , then the swi tch statement will likely be faster than the corresponding .

It has limited application but is convenient nonetheless .
The following code fragment assigns one of two things to .

The conditional operator uses two symbols .
Since it has three operands it is classified as ternary operator only .
The overall type of conditional expression is the more dominant of and expi The conditional expression can be used anywhere an expression can be used .
It is not statement itself ; it is used within statement .

As another example , the absolute value of number is defined in mathematics by the following formula :  when   when In other words , the absolute value of positive number or zero is the same as that number ; the lute value of negative number is the additive inverse of that number .
The following expression represents the absolute value of the variable .

To seasoned programmers it is quite understandable , but it is used sparingly because of its very specibc nature .

how it .

The condition of the whi le specifies set that includes all values that are not in the desired range .

The initialization of ensures the condition of the while will be true initially , and , thus , the program always will execute the body at least one time .

The user does not get chance to enter value until execution is inside the loop .

The initialization of before the loop check is somewhat artificial .
It is there only to ensure entry into the body .
It seems unnatural to check for valid value before the user gets chance to enter it .
loop that checks its condition after its body is executed at least once would be more appropriate .

The statement is loop that behaves exactly in this manner .
Listing uses le statement to check for valid input .

Figure compares the flowcharts of while and loop .

The statement has the general .

The condition is associated with the while at the end of the loop .
The condition is Boolean expression and must be enclosed within parentheses .

The statement is exactly like the statement in the general form of the whi le loop Section .

It can be compound statement enclosed within curly braces .

The body of statement , unlike the while statement , is guaranteed to execute at least once .

The le loop is convenience to the programmer and is not an essential programming construct .

It is easy to transform any code that uses statement into code that behaves identically that uses whi le statement instead .
In practice , programmers use whi le loops much more frequently than le loops because more algorithms require loops than loops .
The le statement is included in for reason , however .
Transforming an algorithm that can be expressed more naturally with loop into one the uses loop can lead to awkward code .
Use le when appropriate .

It simply counts from one to five .
Counting is frequent activity performed by computer programs .
Certain program elements are required in order for any program to .

variable must be used to keep track of the count ; in Listing , count is the aptly named counter variable .

The counter variable must be given an initial value .
In the case of , the initial value is .

The variable must be modified as the program counts .

way must be provided to determine if the counting has completed .
In Listing , the condition of the whi le statement determines if the counting is complete or must contine .

provides specialized loop that packages these four programming elements into one convenient statement .
Called the for statement , its general form is .

The header , contained in parentheses , contains three parts , each separated by semicolons : Initialization .
The initialization part assigns an initial value to the loop variable .
The loop variable may be declared here as well ; if it is declared here , then its scope is limited to the statement .
This means you may use that loop variable only within the loop .
It also means you are free to reuse that name outside the loop to declare different variable with the same name as the loop variable .

The initialization part is performed one time .

The condition part is Boolean expression , just like the condition of while statement .
The condition is checked each time before the body is executed .

The modification part generally changes the loop variable .
The change should be such that the condition will eventually become false so the loop will terminate .
The modification is performed during each iteration after the body is executed .

Notice that the last part modification is not following by semicolon ; semicolons are used strictly to separate the three parts .

The statement is like the body of any other loop .
It may be compound statement within curly braces .

With whi le loop , the four counting components declaration , initialization , condition , and modification can be scattered throughout the code .
With for loop , programmer should be able to determine all the important information about the control by looking at one statement .

Recall Listing that prints multiplication table on the screen .

for loop is ideal for stepping through the rows and columns .
The information about the control of both loops is now packaged in the respective for statements instead of being spread out in various places in ma .
In the while version , it is easy for the programmer to forget to update one or both of the counter variables .
The for makes it harder for the programmer to forget the loop variable update , since it is done right up front in the for statement header .

It is considered bad programming practice to do either of the following in for .

Modify the loop control variable within the body of the loop the loop variable is modified within the body , then the logic of the control is no longer completely isolated to the header .
The programmer must look elsewhere within the statement to understand completely how the loop works .

Prematurely exit the loop with break this action also violates the concept of keeping all the loop control logic in one place .

The language allows both of these practices , but experience shows that it is best to avoid them .
If it seems necessary to violate this advice , consider using different kind of loop .
The whi le and le loops do not imply the same degree of control regularity expected in for loop .

Listing is rewrite of Listing that replaces its while .

As shown in Listing , the conditional expression in the for loop is not limited to simple test of the loop control variable ; it can be any legal Boolean expression .
Programmers can use the logical and , or , and not operators to create complex Boolean expressions , if necessary .

The modification part of the for loop is not limited to simple arithmetic and can be quite elaborate .

While the for statement supports such complex headers , simpler is usually better .
Ordinarily the for loop should manage just one control variable , and the initialization , condition , and modification parts should be straightforward .
If particular programming situation warrants an overly complicated construction , consider using another kind of loop .

Any or all of the parts of the for statement , condition , modification , and may be .

break or goto must appear in the body unless an infinite loop is intended .

If the modification is missing , as in .

Some programmers use an empty loop to produce delay in the execution .
programmer may , for example , need to slow down graphical animation .

Such an attempt using an empty loop is for several reasons .
If the program actually executes the loop , slower computers will delay longer than faster computers .
The timing of the delay will differ from one computer to another .
Worse yet , some compilers may detect that such code has no functional effect and optimize away the empty loop .
This means the compiler will ignore the for statement altogether .

One common idiom to make an intentional infinite loop is to use statement with all control .

While the statement supports the omission of parts of its header , such constructs should be avoided .

The intention of the for loop is to allow the programmer to see all the aspects of the control in one place .
If some of these control responsibilities are to be handled elsewhere in the then consider using another kind of loop .

Programmers usually select simple name for the control variable of for statement .
Recall that variable names should be well chosen to reflect the meaning of their use within the program .
It may come as surprise that is probably the most common name used for an integer control variable in for loop .

This practice has its roots in mathematics where variables such as   and are commonly used to index vectors and matrices .
Such mathematical structures have programming analogs in arrays and vectors , which we explore in Chapter Computer programmers make considerable use of for loops in array .

allows the break , conti nue , and goto statements to be used in the body of for statement .

Like with the while and le statements , break causes immediate loop termination , continue causes the condition to be immediately checked to determine if the iteration should continue , and goto jumps to label somewhere in the function .
As previously mentioned , however , loop control should be restricted to its header , and the use of break , conti nue , and goto within for loops should be avoided .

Any for loop can be rewritten with whi le loop and behave identically .
For example , consider the loop for ;

The for loop conveniently packages the loop control information in its header , but in the whi le loop this information is distributed throughout the small section of code .
The for loop thus provides better organization of the loop control code .
Does one loop outperform the other .
No , most compilers produce essentially the same code for both constructs .
Thus , the for loop is preferred in this example .

Consider the following code .

What is printed when What is printed when What is printed when What is printed when What is printed when What is printed when What is printed when the user enters .

What is printed by the following code fragment .

Rewrite the following code fragment so that swi tch is used instead of the statements .

Rewrite the following code fragment so that is used instead of the swi tch statement .

Rewrite the following code fragment so that is used instead of the swi tch statement .

Rewrite the following code fragment so whi le loop is used instead of the for statement .

Rewrite the following code fragment so that it uses the conditional operator instead of an .

Enter number : root is root is root is root is root is root is root is Square root .

While this code may be acceptable for many applications , better algorithms exist that work faster and produce more precise answers .
Another problem with the code is this : What if you are working on significant scientific or engineering application and must use different formulas in various parts the source code , and each these formulas involve square roots in some way .
In mathematics , for example , you use square root to compute the distance between two geometric points and as .

In electrical engineering and physics , the root mean square set values .

Must we copy and paste the relevant portions the square root code in ing to each location in our source code that requires square root tation .
Also , what if we develop another program that requires computing root mean square .
Will we need to copy the code from Listing into every program that needs to compute square roots , or is there better way to package the square root code and reuse it .

Code is made reusable by packaging it in functions .
function is unit reusable code .
In we will write our own reusable functions , but in this chapter we examine some the functions available in the standard library .
provides collection standard precompiled and code stored in libraries .
Programmers can use parts this library code within their own code to build sophisticated programs .

In mathematics , function computes result from given  for example , from the function definition + we can .
function in works like mathematical function .
To introduce the function concept , we will look at the standard function that implements mathematical square root .

In , function is named sequence code that performs specific task .
program itself consists collection functions .
One example function is the mathematical square root function .
Such function , named sqrt , is available to programs Section .
The square root function accepts one numeric produces double as result ; for example , the square root is , so when presented with , sqrt responds with .
Figure visualizes the square root function .

For the programmer using the sqrt function within program , the function is black box ; the grammer is concerned more about what the function does , not how it does it .

This sq rt function is exactly what we need for our square root program ,

Listing , uses the library function sqrt eliminates the .

The sqrt function is among them .
Table lists some the other commonly used mathematical functions available in the cmath library .
The compiler needs this augmented code so it can check to see if we are using the sqrt function properly .

The expression is function invocation , also known as .
function provides service to the code that uses it .
Here , our mai function is the caller that uses the service provided by the sqrt function .
We say mai calls , or invokes , sq rt passing it the value nput .
The expression sq evaluates to the square root the value the variable input .
Behind the the black box as it precompiled code uses the value the input variable to its square root .
There is nothing special about this precompiled code that constitutes the sq rt function ; it was written by programmer or team programmers working for the library vendor using the same tools we have at our disposal .
In In Chapter we will write our own functions , but for now we will enjoy the functions that others have provided for us .

When calling function , pair parentheses follow the name .

We also can say are passing input to the sq rt " While we might say are passing nput to the sqrt " the program really is not giving the function access to mai nput variable .
The sqrt function itself cannot change the value mai nput variable , it simply uses the value to perform the computation .

The following simple analogy may help explain how the communication works between main sqrt .
The mai function has work to do , but instead doing all the work itself , it delegates some the work this case the hard to sq rt .
When mai needs to the square root nput , it writes down the value its nput variable on piece paper hands it to sqrt .
The sqrt function accepts mai note begins working on the task the square root the number on the note mai gave .
When it is finished , sqrt does two things ; sqrt hands back to main different piece paper with the answer , sqrt throws away the piece paper main originally passed to it .
When main receives the note from sq rt it uses the information on the note then discards the note .
The mai function then can continue with its other business .

The sq rt function thus has no access to mai original nput variable ; it has only copy nput , as if on piece " if the sq rt function uses any variables to do its work , mai is oblivious to them has no way to access After sqrt is finished returns to main its computed answer , sqrt discards its copy nput analogy , the function away " the paper with the copy nput that mai gave .
Thus , during function call the parameter is temporary , transitory value used only to communicate information to the function .
The parameter lives only as long as the function is executing .

Figure illustrates execution involving simple function calls .

Figure shows that execution begins in its mai function .
Here mai calls the sqrt function twice .
vertical bar represents the time that function is active , or " variables .

Figure The diagram on the right visualizes the execution of the program on the left .
Time flows from left to right .
rectangular bar represents the time that function is active .
execution begins with its man function .
Here , man calls the sqrt function twice .
The shaded parts of mai bar shows the times mai has to wait for sqrt to complete .

Observe that the main function is active for the duration of the .

The sqrt function accepts single numeric argument .
The parameter that caller can pass to sqrt can be literal number , numeric variable , an arithmetic expression , or even function invocation that produces an acceptable numeric result .

Some functions , like sq rt , return it to the caller .
The caller can use this result in various ways , as shown in Listing .
The next to the last statement passes the result of calling sq rt to sq rt , thereby computing , which is .

If the caller code attempts to pass parameter to the function that is incompatible with the type expected by the function , the compiler will issue an error .

Listing shows that program can call the sqrt function as many times and in as many places as needed .
As noted in Figure to the caller of the square function , the function is black box ; the caller is concerned strictly about what the function does , not how the function accomplishes its task .

We safely can treat all functions as black boxes .
We can use the service that function provides without being concerned about its internal details .
We are guaranteed that we can influence the behavior only via the parameters that we pass , and that nothing else we do can affect what the function does or how it does it .
Furthermore , the function cannot affect any of our code , apart from what we do with the it computes .

Some functions take more than one parameter ; for example , the function requires two ments in order to produce result .
The function selects and returns the larger of the two parameters .

The function visualized in The function could be used as .

Notice that the parameters are contained in parentheses following the name , and the parameters .

From the perspective function has three important .

Every function has name that identifies the location of the code to be executed .
Function names follow the same rules as variable names ; function name another example of an identifier Section .

caller must provide the exact number and types of parameters that function expects .
If caller attempts to call function with too many or too few parameters , the compiler will issue an error message and not compile the code .
Similarly , if the caller passes parameters that are not compatible with the types specified for the function , the compiler will report appropriate error messages .

function can compute result and return this to the caller .
The use of this result must be compatible with the specified result type .
The result type returned to the caller and the parameter types passed in by the caller can be completely unrelated .

In function prototype , the return type listed first , followed by the name , and then the .

The names make it easier to describe what the function does ; for example , sq rtcomputes the square of and determines the larger of and .

When using library function the programmer must the appropriate directive in the source code .
The file specified in an nclude directive contains prototypes for library functions .

Unlike mathematical functions that must produce result , does not require function to return value to its caller .
The function exit expects an integer value from the caller , but it does not return result back to the caller .
prototype for function that returns nothing uses voi as the return type , as .

The exi function immediately terminates the execution .
The integer argument passed to exi returned to the operating system which can use the value to determine if the program terminated normally or due to an error .
programs automatically return zero when mai finishes exi call necessary .

void function useful for the side effects it produces instead value it computes .
Example side effects printing something on the console , sending data over network , or animating graphical image .

Computes the cosine of value specified in radians : cos cosx ; other trigonometric .

The cmath library also defines constant named .
Programmers can use this constant to represent infinity or an undefined value such the slope of vertical line or fraction with zero denominator .

complete list of the numeric functions available to can be found at http 

The distance to the planet , therefore , also fixed .
satellite orbiting the planet in circular orbit .
We wish to compute how much farther away the satellite will be from the spacecraft when it has progressed degrees along its orbital path .

We will let the origin of our coordinate system be located at the center of the planet which responds also to the center of the circular orbital path .
The satellite is initially at point and the spacecraft is stationary at point Xl .
The spacecraft is located in the same plane as the orbit .

We need to compute the difference in the distances between the moving point and the fixed point at two different times during the orbit .

Facts from mathematics provide solutions to the following two .

Figure Orbital distance problem .
In this diagram , the satellite begins at , distance of .

Solution : Given an initial of the moving  rotation of degrees around the origin will yield new at ' where xi +

We can use the square root function to improve the efficiency of our primes program .

We say that the sqrt function is loaded .
If the caller passes double parameter , the compiler generates code to call the double version .
If the caller instead passes float variable , the compiler selects the float version of sqrt .
When an nt is passed to sqrt , the compiler cannot decide which version to use , because an nt can be converted automatically to either float , double , or long double .
The compiler thus needs some help to resolve the ambiguity , so we duced an additional variable of type double so the compiler will use the double version of the sqrt function .
Another option is to use type cast to convert the integer into one of the types acceptable to the sqrt function .

The clock function from the library requests from the operating system the amount of time an executing program has been running .
The units returned by the call clock is system dependent , but it can be converted into seconds with the constant , also defined in the cti me library .

Under Visual , the constant is , which means the call clock returns the number of milliseconds that the program has been running .

Using two calls to the clock function you can measure elapsed time .
Listing measures .

In the expression the cast is required to force division ; otherwise , the result is truncated to an integer .

By comparison , the newer , more efficient version , Listing , which uses the square root optimization takes only seconds to display all the primes up to .
Exact times will vary depending on the speed of the computer .

As it turns out , much of the execution time is taken up printing the output , not computing the prime numbers to print .
We can compare the algorithms better by redirecting the output to file .

If the executable program is named , you can redirect its output at the command line by issuing the command .

This creates text file named runl that can be viewed with any text editor .
Its contents are exactly what would have been printed to the screen if the redirection is not used .

When run using redirection , the time difference is even more dramatic : The unoptimized version erates the prime numbers up to in seconds , while the optimized square root version requires only seconds to generate the same number of primes .
An even faster prime generator can be found in Listing ; it uses completely different algorithm to generate prime numbers .

You must nclude the header to use the standard ti me function in program .

At the enhanced warning level for .

Other functions exist to determine if character is punctuation character like comma or semicolon .

To use the standard character functions in your program , you must include the header .

Random numbers are useful particularly in games and simulations .
For example , many board games use die of pair of to determine how many places player is to advance .
die is cube containing spots on each of its six faces .
The number of spots range from one to six .
player rolls die or sometimes pair of dice , and the that face up have meaning in the game being played .

The of face after roll is determined at random by the complex tumbling of the die .
software adaptation of game that involves dice would need way to simulate the random roll of die .

All algorithmic random number generators actually produce pseudorandom numbers , not true random numbers .
pseudorandom number generator has particular period , based on the nature of the algorithm used .
If the generator is used long enough , the pattern of numbers produced repeats itself exactly .
sequence of true random numbers would not contain such repeating subsequence .
The good news is that all practical algorithmic pseudorandom number generators have periods that are large enough for most applications .

programmers can use two standard functions for generating pseudorandom numbers : srand and .

Each call to rand .

The numbers printed by the program appear to be random .
The algorithm is given seed to begin , and formula is used to produce the next .
The seed determines the sequence of numbers ated ; identical seed values generate identical sequences .
If you run the program again , the same sequence is displayed because the same seed  is used .
In order to allow each program run to display different sequences , the seed must be different for each run .
How can we establish different seed for each run .
The best way to make up " seed at run time is to use the ti me function which is found in the cti me library .
The call ti me returns the number of seconds since midnight January ,

This obviously differs between program runs , so each execution will use different seed  and the .

Notice that the numbers returned by rand can be rather large .
The pseudorandom values range from to maximum value that is implementation dependent .
The maximum value for Visual rand function is , which corresponds to the largest si gned nt value .
The cstdli header defines the constant that represents the largest value in the range .
The following statement .

Ordinarily we need values in more limited range , like .
Simple arithmetic with the modulus operator can produce the result we need .
If is any nonnegative integer and in is any positive integer , the expression .

Suppose you need to compute the square root of number in program .
Would it be good idea to write the code to perform the square root calculation .

In source code what is one way to help you distinguish variable name from function name .

Ordinarily how often should program call the srand function .

In Listing , what does the mai function do while the sqrt function is computing the square root of the argument that mai provides .

Consider each of the following code fragments below that could be part of program .
Each fragment contains call to standard library function .
Answer each question in one of the following three .

If the code fragment contains error , write the word error for the answer .

If the code fragment contains no errors and you can determine its output at , provide the literal output .

If the code fragment contains no errors but you cannot determine its exact output at , provide one possible evaluation and write the word example for the answer and provide one possible literal output that the code fragment could produce .

From geometry : Write computer program that given the lengths of the two sides of right triangle adjacent to the right angle computes the length of the hypotenuse of the triangle .

As programs become more complex , programmers must structure their programs in such way as to fectively manage their complexity .
Most humans have difficult time keeping track of too many pieces of information at one time .
It is easy to become bogged down in the details of complex problem .
The trick to managing complexity is to break down the problem into more manageable pieces .
Each piece has its own details that must be addressed , but these details are hidden as much as possible within that piece .
The problem is ultimately solved by putting these pieces together to form the complete solution .

So far all of our programs have been written within one .
As the number of statements within function increases , the function can become unwieldy .
The code within such function that does all the work by itself is called monolithic code .
Monolithic code that is long and complex is undesirable for several .

It is difficult to debug .
If the sequence of code does not work correctly , it is often difficult to find .

Using divide and conquer strategy , programmer can decompose complicated function mai into several simpler functions .
The original function can then do its job by delegating the work to these other functions .
In this way the original function can be thought of as " Besides their code organization aspects , functions allow us to bundle functionality into reusable parts .
In saw how library functions can dramatically increase the capabilities of our programs .
While we should capitalize on library functions as much as possible , sometimes we need function exhibiting custom behavior that is not provided by any standard function .
Fortunately we can create our own functions , and the same function may be used in numerous places within program .
If the purpose is general enough and we write the function properly , we may be able to reuse the function in other programs as well .

Recall the " square root code we saw in Listing .
We know that the better option is the standard library function sqrt ; however , we will illustrate custom function opment by writing our own square root function based on the code in Listing .

In Listing we see the definition for the function .

Clearly we should use the standard sqrt function instead of .

There are two aspects to every .

The definition of function specifies the return type and parameter types , and it provides the code that determines the behavior .
In Listing the definition of the function appears above the mai function .

programmer uses function via function invocation .
The main function invokes both our function and the sqrt function .
Every function has exactly one definition but may have many invocations .

Name function in has name .
The name is an identifier Section .

Type function has return type .
If the function returns value to its caller , its type .

Parameters function must specify the types of parameters that it accepts from callers .
The parameters appear in parenthesized list like in function prototype tion .
Unlike function prototypes , however , parameters usually have names associated with each type .

Body function definition has body enclosed by curly braces .
The body contains the code to be executed when the function is invoked .

Figure dissects our function definition .

The prompt function simply prints message .
The program runs as follows :
The execution , like in all programs , begins with the first executable statement in the function named mai .
The first line in the mai function simply declares some variables needed for compiler housekeeping , so the next line actually begins the executable code .

The first executable statement prints the message of the intent .

The next statement is call of the prompt function .
At this point the execution transfers to the body of the prompt function .
The code within prompt is executed until the end of its body or until return statement is encountered .
Since prompt contains no return statement , all of body one print will be executed .

When prompt is finished , control is passed back to the point in mai immediately after the call of prompt .

The next action after prompt call reads the of valuel from the keyboard .

second call to prompt transfers control back to the code within the prompt function .
It again prints its message .

When the second call to prompt is finished , control passes back to mai at the point of the second input statement that assigns from the keyboard .

The remaining two statements in mai are executed , and then the execution terminates .

Our prompt and counttolQ functions are bit underwhelming .
The prompt function could be eliminated , and each call to prompt could be replaced with the statement in its body .
The same could be said for the counttolQ function , although it is convenient to have the simple statement that hides the complexity of the loop .
Using the prompt function does have one advantage , though .
If prompt is removed and the two calls to ompt are replaced with the print statement within prompt , we have to make sure that the two messages printed are identical .
If we simply call prompt , we know the two messages printed will be identical because only one possible message can be printed one in the body of .

We can alter the behavior of function through mechanism called parameter passing .
If function is written to accept information from the caller , the caller must supply the information in order to use the function .
The caller communicates the information via one or more parameters as required by the function .

The counttolQ function does us little good if we sometimes want to count up to different number .

Listing generalizes Listing to count as high as the caller needs .

caller must pass exactly one integer parameter other type that is with to during call .
An attempt to do otherwise will result in compiler error or warning : Error , missing parameter during the call .

quick look at the first line of definition confirms our .

Because prompt is declared to return an nt  it must contain retu rn statement .
retu rn statement specifies the exact to return to the caller .
When return is encountered during execution , control immediately passes back to the caller .
The of the function call is the specified by the return statement , so the statement promptQ .

Note that in Listing , we declared variable named result inside the prompt function .
This variable is local to the function , meaning we cannot use this particular variable outside of prompt .
It also means we are free to use that same name outside of the prompt function in different context , and that use will not interfere with the result variable within prompt .

We can further enhance our prompt function .
Currently prompt always prints the same message .

Using parameters , we can customize the message that prompt prints .

In the first line of the function definition : int prompt is called the formal parameter .
formal parameter is used like variable within the body , but it is declared in the parameter list ; it is not declared in the body .
formal parameter is parameter as used in the formal definition of the function .

The parameters used within function definition are called formal parameters .

Formal parameters behave as local variables within the body ; as such , the name of formal parameter will not conflict with any local variable or mal parameter names from other functions .
This means as function developer you may choose parameter name that best represents the role in the function .

If you are writing function , you cannot predict the actual parameters .

You must be able to handle any value the caller sends .
The compiler will ensure that the types of the parameters are compatible with the declared types of your formal parameters .

formal parameter is parameter declared and used in formal definition .

An actual parameter is parameter supplied by the caller when the caller actually uses or the function .

definition requires that all formal parameters be declared in the theses following the name .
caller does not provide actual parameter type declarations when calling the function .
Given the function defined in Listing , the following caller code fragment is .

The special type voi indicates that the function does not return .

The name of the function is an identifier Section .
The name should indicate the purpose of the function .

The parameterlist is comma separated list of pairs of the form type name where type is type and name is an identifier representing parameter .
The caller of the tion communicates information into the function via parameters .
The parameters specified in the parameter list of function definition are called formal parameters .
parameter is also known as an argument .
The parameter list may be empty ; an empty parameter list indicates that no information may be passed into the function by the caller .

The body is the sequence of statements , enclosed within curly braces , that define the actions that the function is to perform .
The statements may include variable declarations , and any variables declared within the body are local to that function .

The body may contain only one statement , many statements , or no statements at all ; regardless , the curly braces always are required .

Observe that multiple pieces of information can be passed into function via multiple parameters , but only one piece of information can be passed out of the function via the return .
Recall the greatest .

Consider the problem of dividing piece of plywood inches long inches wide into square pieces of maximum size without wasting any material .
Since the , we can cut the plywood into twelve inch inch square pieces as shown in Figure .

If we cut squares larger than inches inches , not all the plywood can be used to make the squares .

Figure shows how some larger squares would fare .

In addition to basic arithmetic and geometry , the function plays vital role in cryptography , enabling secure communication across an insecure network .

Listing implements but naive algorithm that seeks potential factors considering every integer less than the smaller of the two values provided the user .
This algorithm is not very efficient , especially for larger numbers .
Its logic is easy to follow , with no deep mathematical insight required .
Soon we will see better algorithm for computing .

If we need to compute the from several different places within our program , we should package the code in function rather than copying it to multiple places .
The following code fragment defines function that that computes the greatest common divisor of two integers .
It determines the largest factor common to its .

This function is named gcd and expects two integer arguments .
Its formal parameters are named numl and .
It returns an integer result .
Its body declares three local variables : mi ,  and is local to the for .
The last line in its body is return statement .
return statement is required for functions that return value .
Avoid function is not required to have retu statement .
If void function does have retu statement , it must simply consist of retu rn followed semicolon other words , it cannot return value , like return statement .
voi function that does not contain retu statement simply returns at the end of its body .

Recall from Section that local variables have meaning only within their scope .
This means that when you write function you can name local variable without fear that its name may be used already in another part of the program .
Two different functions can use local variables named , and these are two different variables that have no influence on each other .
Anything local to function definition is hidden to all code outside that function definition .

Since formal parameter is local variable , you can reuse the names of formal parameters in different functions without problem .

It may seem strange that we can use the same name in two different functions within the same program to refer to two distinct variables .
The block of statements that makes up function definition constitutes context for local variables .
simple analogy may help .
In the United States , many cities have street named Main Street  for example , there is thoroughfare named Main Street in San Francisco , California .

Dallas , Texas also has street named Main Street .
Each city and town provides its own context for the use of the term Main Street .
person in San Francisco asking do get to Main " will receive the directions to San Main Street , while someone in Dallas asking the same question will receive instructions .
In similar manner , assigning variable within function block localizes its identity to that function .
We can think of execution as person traveling around the The United States When .

thread of execution cannot execute more than one statement at time , which means the compiler can use its current context to interpret any names it encounters within statement .
Similarly , at the risk of overextending the analogy , person cannot be physically located in more than one city at time .
Furthermore , Main Street may be bustling , boulevard in one large city , but street the same name in remote , rural township may be narrow dirt road .
Similarly , two variables may have two completely different types .
variable named in one function may represent an integer , while different function may use string variable named .

Another advantage of local variables is that they occupy space in the memory only when the function is executing .
Space is allocated for local variables and parameters when the function begins executing .
When the function is finished and control returns to the caller , the variables and parameters go out of scope , and the memory they held is freed up for other purposes within the running program .
This process of local variable allocation and deallocation happens each time caller invokes the function .
More information about how handles memory management during execution can be found in Section Once we have written complete function definition we can use the function within our program .
We invoke function in exactly the same way as standard library function like sqrt or rand .
If the function returns value is , it is not declared , then we can use its invocation anywhere an expression of that type is allowed .
The parameters used for the function call are known as actual parameters .
The function gcd can be called as part of an assignment statement : int ,

Variables , expressions , and literals can be freely used as actual parameters .
The function then computes and returns its result .
This result is assigned to the variable .

How does the function call and parameter mechanism work .
actually quite simple .
The actual parameters , in order , are assigned to each of the formal parameters in the function definition , then control is passed to the body of the function .
When the body is finished executing , control passes back to the point in the program where the function was called .
The value returned by the function , if any , replaces the function call expression .
In the statement int , an integer value is assigned to .
The expression on the right is function call , so the function is invoked to determine what to assign .
The value of the variable val is assigned to the formal parameter numl , and the literal value is assigned to the formal parameter .
The body of the gcd function is then executed .
When the return statement in the body is encountered , program execution returns back to where the function was called .
The argument of the return statement becomes the value that is assigned to .
This process of copying actual parameters to formal parameters works exactly like during assignment .
This means the compiler , where possible , automatically will widen or narrow Section the value of an actual parameter to make it compatible with its corresponding formal parameter ; for example , if val is declared to cha , its value would automatically be copied to temporary location and converted to an nt .
This temporary value would then be bound to the formal parameter numl .

Note that gcd could be called from many different places within the same program , and , since different parameter values could be passed at each of these different invocations , gcd could compute different result at each invocation .

Other invocation examples .

The result of the call is then assigned to .
Since the right side of the assignment statement is evaluated before being assigned to the left side , the original value of is used when calculating , and the function return value then updates .

Since the function returns an ger value its result can itself be used as an actual parameter in function call .
Passing the result of one function call as an actual parameter to another function call is called function composition .

The compiler will report an error if function call does not agree with the definition .
Possible problems .

Number of actual parameters do not agree with the number of formal parameters .

Passing an actual parameter that is not assignment compatible with the formal parameter .
For example , passing the std   object when an nt has been defined , as in int , Error : second parameter is wrong type The compiler will detect that std : not valid int and report an error .

Using the result in context where an expression of that type is not allowed .
For example , function that returns void cannot be used where an int is expected : Error : srand does not return anything .

This means the value of the actual parameter is copied to the formal parameter for the purpose of executing the code .
Since it is working on copy of the actual parameter , the execution cannot affect the value of the actual parameter owned by the caller .

Listing illustrates the consequences of pass by value .

Before increment , Beginning execution of increment , Ending execution of increment , After increment , The memory for the variable in mai is unaffected since ncrement works on copy of the actual parameter .

supports another way of passing parameters called pass by reference .
Pass by reference is duced in Section function communicates its return value to the caller in the same way that the caller might pass parameter by value .
In the prompt function we saw .

We informally may say we are returning the result variable , but , in fact , we really are returning only the value of the result variable .
The caller has no access to .

In fact , the local variables for function exist only when the function is active is ,
When the function returns to its caller all of its local variables disappear from memory .
During subsequent invocations , the local variables reappear when the function becomes active and disappear again when it finishes .

Listing illustrates several important points about .

The complete work of the program is no longer limited to the mai function .
The effort to test for primality is delegated to separate function , ma is focused on simpler task : generating all the numbers to be considered and using another function the hard work of ing if given number is prime , main is now simpler and more logically coherent .
function is coherent when it is focused on single task .
Coherence is desirable property of functions .
If function becomes too complex by trying to do too many different things , it can be more difficult to write correctly and debug when problems are detected .
complex function should be decomposed into several , smaller , more coherent functions .
The original function would then call these new pler functions to accomplish its task .
Here , mai is not concerned about how to determine if given number is prime ; main simply delegates the work to me and makes use of the me findings .

Each function is preceded by thorough comment that describes the nature of the function .
It explains the meaning of each parameter , and it indicates what the function should return .
The comment for mai may not be as thorough as for other functions ; this is because mai usually has no parameters , and it always returns code to the operating system upon the termination .

While the exterior comment indicates what the function is to do , comments within each function explain in more detail how the function accomplishes its task .

The call to me returns or depending on the passed to it .
This means we can express condition like if .

The expression suffices .

Just as it is better for loop to have exactly one entry point and exactly one exit point , preferably function will have single return statement .
Simple functions with small number of returns are .

We now can easily adapt that concept to function .
Listing uses function named range .

The high and low values are specified by parameters .
This makes the function more flexible since it could be used elsewhere in the program with completely different range specified and still work correctly .

The function is supposed to be called with the lower number passed as the parameter and the higher number passed as the second parameter .
The function will also accept the parameters out of .

These important components of the program are now in functions , so their details can be perfected independently from mai .

Note how the result of the call to roll is passed directly as an argument to .

During the call , the value of mai hei ght variable is copied into to the formal parameter in tree also named hei ght .
The compiler can keep track of which hei ght is which based on where each is declared .

Just as cannot be represented finitely in the decimal number system , cannot be represented exactly in the binary number system with fixed number of digits .
Often , no problems arise from this imprecision , and in fact many software applications have been written using numbers that must perform precise calculations , such as directing spacecraft to distant planet .
In such cases even small errors can result in complete failures .
numbers can and are used safely and effectively , but not without appropriate care .

To build our confidence with numbers , consider Listing .

We are adding , just as in Listing , but now there is lem .
Since cannot be represented exactly within constraints of representation , repeated addition of leads to round off errors that accumulate over time .
Whereas + rounded off may equal , added to itself times may be or , neither of which is exactly .

When comparing two point numbers , we essentially must determine if absolute value of their difference is small ; example ,
abs function was introduced in Section we can incorporate it .

Since uses evaluation Boolean expressions involving logical OR Section  if operator indicates equality , more elaborate check is not performed .

You should use function like equals when comparing two values equality .

We can decompose code into functions as shown in ing .
Our goal is to have collection of functions that each are very simple .

We also want overall structure to be logically organized .

Figure trace of activation of various functions in Listing when .

In Listing , each function plays very specific role ; example , header prints label particular row and then prints vertical bar that separates row label from body of table .
We reuse function from Listing .
Notice that there no longer appear to be any nested loops in program .
Observe that function contains loop .
Each time through loop it calls pri , but pri itself contains loop .
The nested iteration , therefore , is still present .

Realistically , the functional decomposition within Listing is extreme .
The relative simplicity of the program does not not really justify eight separate functions each with such narrow focus ; however , more complex software systems are decomposed in this very manner .
Not only does Listing give us insight into how we can take complicated problem and break it down into simpler , more manageable pieces , we can use the program to better understand how the function invocation process works .
To see how , consider the situation where user wishes to print multiplication table using Listing .

Functions of type void have no labels on their return arrows .

This means that mai value variable .

This is not true for the variables used in :   and the parameters and .
These variables maintained by appear automatically when begins executing left end of its and their space is released when is finished right end of its bar ; During the printing of table the program calls pri three times , and for each call the parameters row and column and local variable col come to life and then disappear when the function returns .

The following points are important in the parsing .

The earlier definition of the twi ce function declares the identifier twi ce to the compiler .
quently the compiler expects caller to twi ce to pass single argument that is compatible with the nt type .
The compiler also knows that the call to twi ce will return an integer value .

The parentheses after the name twi ce in the statement indicate the expression is function call .

Within the parentheses is the integer literal , which clearly is compatible with the nt type .

The expression twi ce thus evaluates to an nt , and the operator can send integer values to the std   output stream object .

The compiler thus can verify that the code within the main function is using the twi ce function correctly .

If we instead place twi definition after the mai definition , the compiler will report an error where twi call appears within mai .
This is because the compiler parses source code line by line from top to bottom within the file .
When the compiler sees the identifier first at its , the environment does not allocate the space for local variable until after its point of declaration .
For variables declared within blocks , like temp with the body , the variable is discarded at the end of the execution .

The compiler needs to know return type and parameter types in order to verify that the caller is invoking the function correctly .

As it turns out , we can satisfy the need to know about the twi ce function as used in mai without providing its full definition .
Listing provides alternate organization of .

It essentially is function definition without the body .
semicolon terminates the declaration , and no curly braces appear in function declaration .

We can provide name the parameter , but that is not necessary .
function declaration provides all the information the compiler needs to determine if caller is invoking the function correctly .
The function is available to any callers that appear after the declaration within the source file .

This means that any code within main that appears after twi declaration can use twi ce , but code outside of main cannot other functions themselves independently provide their own declaration of twi ce .
Listing and Listing provide concrete example of the difference between local and global declaration .

Note that while allows us to declare function within the body of another function , it does not .

They argue that this better represents the way the compiled code ma method begins running first , and it calls the other functions .
As we read the source code from top to bottom we see the details of the mai function before seeing the implementation details of the functions that mai calls .

more frequent way to organize functions within source code is to separate function declarations , function invocations , and function definitions into their own distinct files .
The function declarations go into one or more header files , the function definitions appear in one or more files , and the calling code mai appear in separate file .
The compiler compiles all the files separately , producing multiple machine language object files files in Visual .
The linker then combines these separate object files into single executable file .
this technique is detail .

It is good practice to comment definition with information that aids programmers who may need to use or extend the function .
The essential information .

The purpose of the function .
The purpose is not always evident merely from its name .

This is especially true for functions that perform complex tasks .
few sentences explaining what the function does can be helpful .

The role of each parameter .
The parameter names and types are obvious from the definition , but the purpose of parameter may not be apparent merely from its name .
It is helpful indicate the purpose of each parameter , if any .

While the function may do number of interesting things as indicated in the purpose , what exactly does it return to the caller .
It is helpful to clarify exactly what value the function produces , if any .

Other information is often required in commercial .

Author of the function .
Specify exactly who wrote the function .
An email address can be included .

If questions about the function arise , this contact information can be invaluable .

Date that the implementation was last modified .
An additional comment can be added each time the function is updated .
Each update should specify the exact changes that were made and the person responsible for the update .

If the code was adapted from another source , list the source .
The reference may consist of Web URL .

The following fragment shows the beginning of function .

Armed with our knowledge of function definitions , we can rewrite Listing so .

Is Listing better than Listing which uses the standard sqrt function from the cmath library .
Generally speaking , if you have the choice of using standard library function or writing your own custom function that provides the same functionality , choose to use the standard library routine .
The advantages of using the standard library routine .

Your effort to produce the custom code is eliminated entirely ; you can devote more effort to other parts of the development .

If you write your own custom code , you must thoroughly test it to ensure its correctness ; standard library code , while not immune to bugs , generally has been subjected to complete test suite .
Library code is used by many developers , and thus any lurking errors are usually exposed early ; your code is exercised only by the programs you write , and errors may not become apparent immediately .
If your programs are not used by wide audience , bugs may lie dormant for long time .
Standard library routines are well known and trusted ; custom code , due to its limited exposure , is suspect until it gains wider exposure and adoption .

Standard routines are typically tuned to be very efficient ; it takes great deal of effort to make custom code efficient .

Standard routines are ; extra work is required to document custom code , and writing good documentation is hard work .

Listing tests our custom square root function over range of values .

Listing uses our equals function from Listing .

The third parameter specifies tolerance ; if the difference between the first two parameters is less than the specified tolerance , the first two parameters are considered equal .
Our new function uses the equals function .
The main function uses the equals function as well .
Observe , however , that the tolerance used within the square computation is smaller than the tolerance main uses to check the result .
The main function , therefore , uses less strict notion of equality .

Five wrong answers out of one billion tests represents error rate .
While this error rate is very small , indicates our function is not perfect .
One of values that causes the function to fail may be very important to particular application , so our function is not trustworthy .

What happens if caller passes too many parameters to function .

All variables to this point have been local to functions or local to blocks within the bodies of conditional or iterative statements .
Local variables have some very desirable .

local variable occupies memory only when the variable is in scope .
When the program execution leaves the scope of local variable , it frees up the memory for that variable .
This freed up memory is then available for use by the local variables in other functions during their invocations .

We can use the same variable name in different functions without any conflict .
The compiler derives all of its information about local variable used within function from the declaration of that variable in that function .
The compiler will not look for the declaration of local variable in the definition of another function .
Thus , there is no way local variable in one function can interfere with local variable declared in another function .

local variable is transitory , so its value is lost in between function invocations .
Sometimes it is desirable to have variable that lives as long as the program is running ; that is , until the main function completes .

In contrast to local variable , global variable is declared outside of all functions and is not local to any particular function .
In fact , any function that appears in the text of the source code after the point of the global declaration may legally access modify that global variable .

Listing is modification of Listing that uses global variable named result that is shared by several functions in the program .

Listing uses global variables  argl , and .
These names no longer appear in the mai function .
These global variables are accessed modified in four different functions : nput , report , add , and subtract .

When in the course of translating the statements within function to machine language , the compiler resolves variable it encounters as .

If the variable has local declaration is , it is local variable or , the compiler will use the local variable or parameter , even if global variable of the same name exists .
Local ables , therefore , take precedence over global variables .
We say the local declaration hides the global declaration in the scope of the local variable .

If the variable has no local declaration but is declared as global variable , the compiler will use the global variable .

If the variable has neither local declaration nor global declaration , then the variable is undefined , and its use is an error .

In the situation where local variable hides global variable of the same name , there is way to access both the local variable and global variable within the local scope .
Suppose program has global variable named and function with local variable named .
The statement ; within the scope of the local variable will assign the local .
The following statement will assign the global variable in the scope of the local variable of the same name : The   operator is called the scope resolution operator .
This special syntax may be used whenever global variable is accessed within function , but usually it only used when necessary to access hidden global variable .

If the value of local variable is used by statement before that variable has been given value , either through initialization or assignment , the compiler will issue warning .
For example , the Visual .

Its value should not be used until it has been properly assigned .
Global variables , however , do not need to be initialized before they are used .
Numeric global variables are automatically assigned the value zero .
This means the initialization of in ing is superfluous , since will be assigned zero automatically .
Boolean global variables are automatically assigned zero as well , as zero represents false Section .

In general , local variables are preferred to global variables for several .

When function uses local variables exclusively and performs no other input operations using the std   ci , its behavior is influenced only by the parameters passed to it .
If variable appears , the behavior is affected by every other function that can modify that variable .
As simple example , consider the following trivial function that appears in .

If your guess is , you are correct .
The ncrement function simply returns the of adding one to its argument .
The ncrement function behaves the same way each time it is called with the same argument .

Next , consider the following three functions that appear in some .

It may be difficult to locate an error if that function fails because it may be the fault of another tion that assigned an incorrect value to the global variable .
The situation may be more complicated .

function that uses only local variables can be tested for correctness in isolation from other tions , since other functions do not affect the behavior of this function .
This behavior is only influenced only by its parameters , if it has any .

The exclusion of global variables from function leads to functional independence .
function that depends on information outside of its scope to correctly perform its task is dependent function .
When function operates on global variable it depends on that global variable being in the correct state for the function to complete its task correctly .
Nontrivial programs that contain many dependent functions are more difficult to debug and extend .
truly independent function that uses no global variables and uses no functions to help it out can be tested for correctness in isolation .
Additionally , an independent function can be copied from one program , pasted into another program , and work without modification .
Functional independence is desirable quality .

Unlike global variables , global constants are generally safe to use .
Code within functions that use global constants are dependent on those constants , but since constants cannot be changed , developers need not worry that other functions that have access to the global constants might disturb their values .

The use of global constants within functions has drawbacks in terms of program maintenance .
As program evolves , code is added and removed .
If global constant is removed or its meaning changes during the course of the development , the change will affect any function using the global constant .

Listing uses global constants to assist the display of digital timer .

The main function controls the initialization and update and deals strictly in .
The logic in mai is kept relatively simple .

The code that extracts the   and from given number of is isolated in pri me .
The pri me function can now be used anytime value in needs to be expressed in the   format .

The second conversion constants , and are global constants so that both functions can access them if necessary .
In this case the functions use different constants  but it makes sense to place all the conversion factors in one place .

Since the two functions divide the responsibilities in way that each can be developed independently , the design is cleaner and the program is easier to develop and debug .
The use of constants ensures that the shared values cannot be corrupted by either function .

The exclusion from definition of global variables and global constants does not guarantee that it will always produce the same results given the same parameter values ; consider .

Its behavior is totally predictable .
Furthermore , ncrement does not modify any global variables , ing it cannot in any way influence the overall behavior .
We say that increment is pure function .
pure function cannot perform any input or output example , use the std :  and std   ci , nor may it use global variables .
While ncrement is pure , the compute function is impure .
The following function is impure also , since it performs output : int nt .

pure function simply computes its return value and has no other observable side effects .

Space in the memory for local variables and function parameters is allocated at run when the function begins executing .
When the function is finished and returns , the memory used for the local variables and parameters is freed up for other purposes .
If function is never called , the local variables and parameters will never occupy the memory .

Because locals are transitory , function cannot ordinarily retain any information between calls .
provides way in which variable local to function can be retained in between calls .
ing shows how declaring local variable staff c allows it to remain in the memory for the duration of the execution .

The local declaration static int ; allocates space for and assigns zero to it the beginning of the execution .
The space set aside for is not released until the program finishes executing .

Recall Listing that included the following .

Another caller might use prompt within loop like .

Notice that it is the responsibility to keep track of the proper number to pass to ompt .
The caller may make mistake and pass the wrong number or may not want to manage such details .
It would be better to move the responsibility of tracking input to prompt , static variables make that possible , as Listing .

Local static variables were inherited from the programming language , but their need has ished with the introduction of objects in Chapter .
Functions with stati c variables provide way to implement executable code with persistent state .
Objects provide more natural and more flexible way to achieve the same effect .

In , program can have multiple functions with the same name .
When two or more functions within program have the same name , the function is said to be overloaded .
The functions must be different somehow , or else the compiler would not know how to associate call with particular function definition .

The compiler identifies function by more than its name ; function is uniquely identified by its signature .

function signature consists of the name and its parameter list .
In the parameter list , only the types of the formal parameters are important , not their names .
If the parameter types do not match exactly , both in number and position , then the function signatures are different .
Consider the following overloaded functions :

Overloaded functions are convenience for programmers .
If overloaded functions were not allowed programming languages do not support , new names must be created for different functions that perform basically the same task but accept different parameter types .
It is better for the programmer to choose the same name for the similar functions and let the compiler properly resolve the differences .
Overloading becomes more important issue for constructors , special functions called during object creation .

The following call .

As we can see , when the caller does not supply parameter specified by  and that parameter has default  the default is used during the call .

We may mix and default parameters in the parameter lists of declaration , but all default parameters within the parameter list must appear after all the parameters .

Overloading Section enables programmers to write different definitions for two different functions that have the same name .
Mixing overloading and default arguments can produce .

The factorial of is often expressed as .
Factorial is defined for nonnegative integers as .

Mathematicians precisely define factorial in this way : if .

Note that the factori al function can be slightly optimized by changing the condition from .

Figure Traces the function activations of the recursive function factori al when called from mai with an argument of .
The arrows into an activation bar indicates the argument passed by the caller ; the arrows out show the value passed back to the caller .
The length of bar represents the time during which that invocation of the function is active .

The function must optionally not call itself within its definition ; this is the base case .

Some sort of conditional execution as an selects between the recursive case and the base case based on one or more parameters passed to the function .

Each invocation that does not correspond to the base case must call itself with that move the execution closer to the base case .
The recursive execution must converge to the base case .

Each recursive invocation must bring the execution closer to it base case .
The function calls itself in the else clause of the statement .
Its base case is executed if the condition of the statement is true .
Since the is defined only for nonnegative integers , the initial invocation of facto ri al must be passed value of zero or greater .
zero parameter base results in no recursive call .
Any other positive parameter results in recursive call with parameter that is closer to zero than the one before .
The nature of the recursive process progresses towards the base case , upon which the recursion terminates .

We can easily write function , as Listing shows .

Which function is better , the recursive or version .
Generally , if the same basic algorithm is being used by both the recursive and functions , then the function will be more efficient .
function call is relatively expensive operation compared to variable assignment or comparison .
The body of the function invokes no functions , but the recursive version calls calls all but the last recursive invocation .
The iterative version of is therefore more efficient than the recursive version .

Even though the iterative version of the function is technically more efficient than the recursive version , on most systems you could not tell the difference .
The execution time difference between the two versions is negligible .
The reason is the function " fast , meaning it returns fairly large .

In particular , acto ri al is the largest value that fits within .

It works , but it is not very efficient .

Running Listing you will see that the gcd and terati functions compute the same results given the same arguments .
Listing showcases the difference in performance between the two functions by computing the GCD of relatively large integers .
The gcd function produces its result much faster than terati .
Note that this gcd function is recursive .

Because of the difference in the algorithms , this .

While Listing expresses the gcd functions recursively , it is not hard to rewrite it so that it still follows algorithm but uses loop instead of very task appears as an exercise at the end of the chapter .
Often the concept of an algorithm solving certain kinds of problems is better understood when expressed recursively .
Later , once the details of the recursive version are perfected , developers may rewrite the algorithm in an iterative fashion .

Listing provides another example of recursive function .
The segmentsl function .

This beginning of the infinite Fibonacci sequence kipedia .
It sequence of integers beginning with followed by .
Subsequent elements of the sequence are the sum of their two immediately preceding elements ; thus , the third number , the fourth number + the fifth number , etc .
The numbers that comprise the Fibonacci sequence are known as Fibonacci numbers .
Note that Fibonacci number but not .

The mathematical properties of Fibonacci numbers have bearing in such diverse fields as biology , nomics , and art .

common problem computing the lb Fibonacci number .
Zero the th  the st  also the nd  the rd  the th  the th  etc .

recursive function to compute the th Fibonacci number follows easily from the definition of the Fibonacci sequence : Returns the nth Fibonacci number int fibonacci nt if return ; else if return .

While this facto rial function computes the correct result , this tendency to call itself so many times .

Figure The recursive computation offibonacci .
Each rectangle represents an invocation of the fibonacci fuunction .
The call at the top of the diagram represents the initial call offibonacci .
An arrow pointing down indicates the argument being passed into an invocation offibonacci , and an arrow pointing up represents the value returned by that invocation .
An invocation of fibonacci with no arrow pointing down away from the invocation represents base case ; observe that any invocation receiving or base case .
We see that the recursive process for fibonacci invokes the function total of times .

It possible to reuse function with this technique only if the function definition does not use any global variables , global constants , nor other functions .
If function does use any of these external entities , we must copy and paste all of this extra code in order for the function to compile .
If the names of the external variables or functions that we must copy into the new conflict with existing names within the  the will not compile as  and we must rename the offending variables or functions to resolve the conflicts .
Changing code provides the opportunity to introduce bugs accidentally , so the process requires absolute care .

We can avoid the issues introduced by copying and pasting if the function we wish to reuse in other programs uses only local variables and parameters .
Such function truly an independent function that can be reused easily in multiple programs .

The notion of copying source code from one to another not ideal , however .
It too easy for the copy to be incomplete or for some other error to be introduced during the copy .
Furthermore , such code duplication wasteful .
If programs on particular system all need to use the me function , under this scheme they must all include the code .
This redundancy wastes space .
Finally , in perhaps the most compelling demonstration of the weakness of this approach , what if we discover bug in the me function that all programs are built around .
When we discover the error and fix it in one  the other programs still will contain the bug .
Their source code must be updated , and they each then must be recompiled .
The problem even more complicated if the other programs have different authors .
We then must contact multiple developers to tell them to fix their me function .
The situation would be similar if we updated correct me function to make it more efficient .
The problem this : all the programs using define their own function ; while the function definitions are meant to be identical , there no mechanism tying all these common definitions together .
We really would like to reuse the function as without copying it .

Fortunately , provides way to develop functions in separate files and combine the code from these independently developed functions into one .
We can compile the source files separately , and the linker can combine the compiled code into an executable .
What we need way for the compiler to verify that the calling code in one source file correctly invoking the function defined in another source file .

The simple code in Listing .
In Visual Studio , you simply add new to your project specified as header file , name it prime .
This file contains the prototype for our me function our earlier discussion of function prototypes in Section .
Caller code that intends to use our me function must nclude this file so that compiler can check to see if the caller using our me function properly .
An attempt , for example , to pass two arguments to me would result in compiler error since the prototype specifies single integer argument .

While not required , this serves as good check to see if the implementation code in this file is faithful to the prototype specified in .
This file is compiled separately , and the compiler will report an error if the implementation of disagrees with the information in the header file .

Note that the file does not contain mai function ; mai will appear in another file .
Also observe that we do not need to nclude the ostream header , since the std   cout and std   ci objects are not used anywhere in this file .
The cmath header is ncluded since me uses the sqrt function .

Visual Studio will automatically compile and link the .

If you are using the Visual Studio Command Line tool , in order to build the you would type .

The executable name is determined by the name of the first source file listed , in this case primetester .

If you are using the GCC tools instead of Visual Studio , in order to make the executable named primetester under the Microsoft Windows version of the GCC , you would issue the command .

The GNU compiler will separately compile the two source files producing two machine language object .

The me function is now more readily available to other programs .
If it becomes an often used function in many programs , it can be compiled and placed into special file called library .
In this form it need not be recompiled each time new is built that requires it .
If our me is placed in dynamic library , its code can be loaded and linked at nin time and shared by many executing programs .

We do not cover library creation in this text .

In , and Listing we used the clock function from the library to measure the elapsed time of sections of various executing programs .
In each of these programs the programmer must be aware of the type and constant , both defined in the header file .
Furthermore , the programmer must use the clock function properly and correctly perform some arithmetic and include messy type cast operation .
Armed with our knowledge of global variables and separate compilation of multiple source files , we can provide better programming interface to the timing functions provided to the library .

Observe that the code in Listing allows client code to stop the and restart it later without losing any previously accumulated time .
The implementation uses three global  sta me , and runni ng maintain the state of the .
One or more of these global variables is influenced by three ,
The fourth function returns the value of the variable .

All traces of the type and the messy arithmetic and casting are gone .
The module provides simple interface to callers that hides the details on how the timing actually happens .

Despite the ease of use of our module , it has servere limitation .
Suppose you wish to measure how long it takes for function to execute and also , during that execution , separately time smaller section of code within that function .
When the function is finished executing , you would like to know how long it took the function to do its job and how long portion of its code took to execute .
We essentially need two independent timers , but with our module it is not possible to conduct taneously more than one timing .
We will see far superior way to model execution in We will use objects to enable us to maintain as many simultaneous stopwatches as we need .

The compiler generates machine code that takes care of those details for us .
Some systems software like operating systems and device drivers need to access specific memory locations in order to interoperate with hardware .
Systems programmers , therefore , must be able to write code that can access such detail .
Developers of applications sometimes need to access the address of variables to achieve specialized effects .

Each byte in memory is numbered with unique address .
The first address is , and the locations are numbered sequentially up to some maximum value allowed by the operating system and hardware .
variable is stored in memory , so each variable lives at particular address .

The operator is called the address of operator .
Regardless of the type of , the expression .

While an address is really just nonnegative integer value , uses special notation when dealing with addresses .
In the following declaration .

The symbol used as shown above during variable declaration indicates that the variable is pointer .

It will be used to refer to another variable or some other place in memory .
In this case , the sequence of assignments allows pointer to refer to variable .

In order to access memory via pointer , we use the unary operator .
When not used in the context of declaration , the unary operator is called the pointer dereferencing operator .
Continuing the code sequence above , int  int ; the statement ; copies the value into the address referenced by the pointer .
Figure illustrates the full sequence .

Notice that the assignment to modifies variable value .
The pointer provides another way to .

It is important to note that the statement ; is the first assignment statement we have seen that uses more than just single variable name on the left of the assignment operator .
The statement is legal because the expression represents memory location that can store value .
Here , stands in the place of the variable  and we easily can assign value to .

The unary operator has two distinct meanings depending on the .

The operator is the inverse of the operator .

We may declare pointer and not assign it , as in int ; We say is an uninitialized pointer  sometimes called wild pointer .
If is local variable , its contents are undetermined bits .
Because of declared type , we interpret these bits as an address , so the net effect is that the uninitialized pointer points to random location in the memory .
An attempt to dereference  as in ; is certainly asking for trouble .
This statement attempts to write the value at some memory location .
Often the address is not part of the area of memory the operating system has set aside for the executing program , so the operating system steps in and issues error .
This is the best possible result for misusing wild pointer .
It is possible , however , that the spurious address is within the executing domain .
In this case the value may overwrite another variable or the compiled machine language instructions of the program itself .
Such errors are difficult to track down because the overwritten value of the variable cannot be detected until the program attempts to use the variable .
The statement that misuses the uninitialized pointer may be far away in the source code in different source from the code that attempts to use the clobbered variable .
When the program fails , the programmer naturally looks around in the code where the failure code in the vicinity where .

is very strict about disallowing the mixing of pointers and across assignment .

Systems programmers sometimes need to assign pointer to particular address in memory , and permits the assignment with special kind of type cast , the .

The familiar Section will not work .
Why is so strict when it comes to assignments of pointers to and vice versa .
It is easy to make mistake such as omitting the operator when it is needed , so the special cast forces the programmer to pause and consider whether the mixed assignment truly is necessary or whether attempting to do so would be mistake .

Modern compiler supports the reserved word nullptr to represent pointer to " It .

On most platforms , nullptr maps to address zero , which is out of bounds for any running program .
Dereferencing thus would result in error .
Adept programmers can find the source of such null pointer access problem quickly with debugger .

does not allow direct integer assignment to pointer , as in int .

This is how programmers assigned pointer to point to nothing before the nullptr keyword was available .
Since newer compilers support existing source code , the literal zero assignment still works .
You should use the nullptr keyword because it improves the source code readability .
Since can represent both an integer value and pointer to any type , both of the following statements are legal if has been declared to be pointer to an .

Said another way , the first statement changes where points ; the second statement changes the memory to which points .
Superficially , the two statements look very similar and are easy to confuse .
Next , consider the statements .

The nullptr reserved word is part of the standard .
The name nullptr is simply an identifier example , variable or function for older ers .
Before the nullptr constant became available the literal was sidered the null pointer reference .
For backwards compatibility with older  allows you to use in place of nullptr , but if possible you should avoid this practice when writing new .
The nullptr literal allows the compiler to perform better type checking .
To see why , suppose the programmer believes the variable is pointer to an integer , but is instead simple .

In this case the compiler is powerless to detect problem because is an integer , and zero is valid integer value .
If really is an integer rather pointer , the compiler will flag the following  Programmer believes is pointer to an integer .

supports another kind of variable that is many ways similar to pointer .
When the symbol is used as part of the type name during variable declaration , as in nt ; we say is reference variable .
This declaration creates variable that refers to the same memory location as the variable .
We say that aliases .
Unlike pointer variable , we may treat as if it were an nt dereferencing with is necessary .
Listing demonstrates how reference variables can alias other variables .

Reassigning changes in exactly the same way , and reassigning changes in exactly the same way .
The variable  on the other hand , is independent from both and .
Reassigning either or does not affect  and reassigning affects neither nor .

The space around the symbol used to declare reference variable is not significant ; specifically , the statement .

Reference syntax is simpler than pointer syntax because it is not necessary to dereference reference variable in order to assign the memory location to which it refers .
If is an nt , ptr is pointer to an nt , and ref is reference to an nt , consider the following .

reference variable must be initialized with an actual variable when it is declared .
pointer variable may be declared without an initial value and assigned later .
Consider the following statements : int ; Legal , we will assign later  Illegal , we must initialize when declaring it Attempting to compile this code under Visual prompts the compiler to issue the error error :  references must be initialized .

There is no way to bind reference variable to different variable during its lifetime .
Consider the following code .

The declaration of binds to the variable for the life of .
This statement simply assigns value to via the reference .
In contrast , we may freely bind pointer variables to any variables we choose at any time .

reference variable , therefore , in the examples provided here works like pointer that must be bound to variable and may not be redirected to point anywhere else .
Also , unlike with pointers , it is illegal to attempt to assign nullptr to reference variable .
There are some other differences between references and pointers that we will not explore here .
Reference variables provide simpler syntax than pointer variables since we do not use the pointer dereferencing operator when working with references .

There is one other major difference between pointers and adopted pointers as is from the programming language , but does not provide references .
programmers often use library tions written in , so it is important to not mix references with code .

Section reveals ver important practical application of pointers and references in their role of enabling pass by reference to functions .

The default technique for passing parameters to functions is pass by value Section .

Unfortunately , the swap function simply interchanges copies of the actual parameters , not the actual rameters themselves .
We really would like to write function that interchanges the variables .

Pass by reference is necessary to achieve the desired effect .
can do pass by reference in two ways : pointer parameters and reference parameters .

We can use this pability to allow function to modify the values of variables that are owned by its caller .
Listing provides correct version of our variable interchange program .

The formal parameters to swap , and  are pointers to integers ; they are not integers themselves .
In order to access the integer to which the pointer named refers , it must be dereferenced .
That is why any use of in body is prefixed with the pointer dereferencing operator ,
The statement int ; assigns to the local variable the value of the variable to which points .
Since mai passes the address of as the first parameter in its call to swap , in this case points to  so is effectively another way to access the memory location of in mai .
The function thus assigns the value of mai variable to .

In statement .

In reality , pass by reference with pointers is still using pass by value .
Instead of passing copies of values , we are passing copies of addresses .
The difference is we are not attempting to reassign or  we are reassigning memory to which and point .
Whether we use the original address or copy of the address , it is still the same same numeric location in memory .

Both and support pass by reference with pointers Section .
Since programs often use libraries , programmers must be familiar with the pointer technique for pass by reference .
, however , provides simpler way of implementing pass by reference using reference parameters .

The formal parameters to swap , and  are references to integers ; this is signified by the symbol following nt in their declarations .
Because is reference we use it exactly like an integer ; there is no need to dereference it with the operator to change the value of the integer it aliases .
Because is reference , however , it is an alias to another variable or memory location elsewhere .
This means if we modify  we also modify the variable it references , in this case in mai .
The statement int  assigns to the local variable the value of  but since is another way to get to  this statement ultimately assigns value to .

Reference parameters were introduced into so that some of the more advanced features could be implemented more cleanly .
Some argue that for simpler situations like the swa function , pointer pass by reference is more desirable than reference parameter pass by reference because with pointer pass by reference , the caller is forced to pass addresses of the actual parameters that may be modified .
In this way there can be no doubt that pass by reference is going on .
With reference parameters , pass by value and pass by reference cannot be distinguished at the call site , since call with reference parameters looks exactly like pass by value invocation .

In general , pure pass by value functions are preferred to pass by reference functions .
Functions using pass by reference cause side effects .
This means they can change the state of the program in ways that can be determined only by looking inside of the function and seeing how it works .
Functions that access global variables Section can also cause side effects .
Program development is much easier when functions can be treated as black boxes that perform computations in isolation without the possibility of affecting anything outside of their local context .
The result of work can be assigned to variable thus changing the state of the program , but that change is the responsibility of the caller , not the responsibility of the function itself .
With pass by value , the parameters and local variables come into existence when the function executes , the parameters and local variables disappear when the function is finished , and nothing else is affected by the execution .

functions can be developed and tested in isolation from the rest of the program .
Once programmers are satisfied with their correctness , they need not be touched again as the remainder of the system is developed .
Functions with side effects , however , have dependencies to other parts of the program , and changes elsewhere in the system may require programmers to modify and existing functions .

Since functions can contain conditional statements and loops , they can do different things based on the data they receive .
The code within each function , however , is fixed at compile time .
Consider the following .

The function returns different result this time because we passed different parameters to it .

The evaluate function in sense behaves differently depending on the arguments passed by its caller ; however , it always adds its two parameters .
There is no way we can call evaluate and expect it to multiply its two parameters instead .
The evaluate function is to perform addition .

What if we wanted the evaluate function to be able to perform different arithmetic operations at different times during execution .
Unfortunately , evaluate as it currently is written cannot adapt to perform different arithmetic operation .
The good news is that we can rewrite evaluate so that it can flexibly adapt to changing arithmetic needs .

allows programmers to pass functions as parameters to other functions .
function even may return function as result .
function that accepts one or more functions as parameters or returns function as result is known as function .
As we will see , functions open up new possibilities enabling us to customize the behavior of function by plugging into it different functions to achieve different effects .

achieves functions via function pointers .
During execution , the compiled machine language code for function must reside in the memory for the program to be able to invoke the function .
That means every function has memory address just as each variable has its own specific memory address .
pointer to function holds the starting address for the compiled code of particular function .

The name is  and is pointer to function that accepts two integer parameters and returns an integer result .
In Listing , the first parameter caller must pass to evaluate is the address of function with prototype that matches the formal parameter specified in definition .
Both the and multi ply functions qualify because they accept two integer parameters and return an integer result .
The expression ,

has somewhat relaxed syntax for function pointers that cannot be applied to pointers to data .

Function pointers are not restricted to function parameters .
Given the definition of above , the following code fragment is legal : Declare to be pointer to function that accepts .

This code fragment as part of complete program would print .

functions via function pointers provide powerful tool for developing flexible programs .

With functions as parameters we can dynamically customize the behavior of function , essentially ging in " new by passing in different functions .
We will put functions to good use in .

If is variable , how would you determine its address in the memory .

Given the .

Complete the following function that assigns to its and reference parameters the components of the point of intersection of two lines .
The first line passes through the points and the second line passes through the points ' and 
If the two lines do not intersect in single point is , they are parallel to each , the function should assign INFINITY to both ix and iy .
INFINITY is constant defined in the cmath header file .
It represents very large number that you effectively can treat as infinity .

The variables we have used to this point can assume only one value at time .
As we have seen , we can use individual variables to create some interesting and useful programs ; however , variables that can represent only one value at time do have their limitations .
Consider Listing which averages five numbers entered by the user .

The program conveniently displays the values the user entered and then computes and displays their age .

Suppose the number of values to average must increase from five to .
If we use Listing as guide , we must introduce twenty additional variables , and the overall length of the program will necessarily grow .
Averaging numbers using this approach is impractical .

Listing can be modified to average values much more easily than ing that must use separate change the constant .

In fact , the coding change to average numbers is no more difficult .
However , unlike the original age program , this new does not display the numbers entered .
This is significant difference ; it may be necessary to retain all the values entered for various .

All the values can be redisplayed after entry so the user can visually verify their correct entry .

The programmer may want to display the values in some more persistent way ; for example , the user may instead type the values in graphical user interface component , like visual grid .

more sophisticated program may need to process the values in different way ; for example , we may wish to display just the values entered above certain value greater than , but the limit is not determined until after the user finishes entering all the numbers .

In all of these situations we must retain the values of all the variables for future recall .

In this chapter we will examine the common sequence types available in : vectors and arrays .

Vectors and arrays are sequence types because sequence implies its elements are ordered .
nonempty sequence has the following .

Every nonempty sequence has unique first element .

We call this linear ordering .
In linear ordering you can begin at the first element and repeatedly visit successor elements until you reach the last element .
There never is any ambiguity about which element comes next in sequence .

The data structures we examine in this chapter , std   vecto rs , primitive arrays , and std   rays , are all sequence types .

vector has name , and we may access the values it contains via their position within the block of memory managed by the vector .
vector stores sequence of values , and the values must all be of the same type .
collection of values all of the same type is said to be homogeneous .

When declared this way , the vector .

We can declare with particular initial size as follows :

Here initially holds integers .
All elements are zero by default .
Note that the size .

Note that the elements appear within curly braces , not parentheses .
The list of elements within the curly braces constitutes initializer list .
This kind of declaration is practical only for relatively small vectors .
Figure provides conceptual illustration of the vectors , and .

Visual Studio do not support this initializer list syntax .

This code fragment shows how the square brackets allow us to access an individual element based on that position within the .
The number within the square brackets indicates the distance from the beginning of the .
The expression li st therefore indicates the element at the very beginning distance of zero from the , and is the second element distance of one away from the .
After executing these assignment statements , the li st conceptually looks like Figure classifies the square brackets , as binary operator , since it requires two operands : name and an index .

Vectors may hold any valid data type .
The following code fragment declares three vectors of differing .

Here li st is empty but can contain integer values , collecti on is of point numbers initially containing the values contained in the initializer  and letters holds the ercase versions of the first three letters of the English alphabet .
Figure illustrates these three objects .

We can observe two key points from .

Vectors store their elements in contiguous block of memory .
This means , for example , the memory occupied by the element at index follows immediately after the memory occupied by the element at index and immediately before the element at index .

Elements in are located by numeric index .
The first element is at index zero  not one .

Figure Vectors containing different types of elements .
Note that while two different objects .

The subscript nology comes from mathematicians who use subscripts to reference elements in mathematical sequence example , represents the second element in the mathematical sequence .
Unlike the convention often used in mathematics , however , the first element in is at position zero  not one .
The expression li st can be read aloud as st sub " As consequence of zero beginning index , if holds elements , the last element in is , not .

An element of accessed via its index behaves just like variable of that type ; for .

The following examples illustrate the variety of expressions that qualify as legal .

The compiler will issue warning about using index with good reason .
may have an element at index or index , but it is not possible to have an element located between indices and ; therefore , the executing program will truncate index to an integer in order to select the proper element within the .

If is an integer containing elements , the following loop prints each element in .

Variable value starts at and ends at , the last valid position in .

The following loop prints contents of in reverse .

Listing uses and loop to achieve the generality of .

Unlike the original program , however , we now conveniently can extend this program to handle as many values as we wish .
We need only change the definition of the constant to allow the program to handle any number of values .
This centralization of the definition of the size eliminates duplicating value and leads to program that is more maintainable .
Suppose every occurrence of were replaced with the literal value .
The program would work exactly the same way , but changing the size would require touching many places within the program .
When duplicate information is scattered throughout program , it is common error to update some but not all of the information when change is to be made .
If all of the duplicate information is not updated to agree , the inconsistencies result in errors within the program .
By faithfully using the constant throughout the program instead of the literal numeric value , we eliminate the possibility of such inconsistency .

The first loop in collects all five input values from the user .
The second loop only prints the first four because it also prints trailing comma after each element .
Since no comma should be displayed after the last element , the program prints the last element after the loop is finished .

The compiler will insist that the programmer use numeric value for an index , but the programmer must ensure that the index used is within the bounds of the .
Since the index may consist of an arbitrary integer expression whose value cannot be determined until run time , the compiler cannot check for accesses ; for example , in the code .

Attempting to access elements outside the bounds of vector produces what is known as undefined behavior .
The language standard uses this term to indicate behavior is not specified , and compiler writers are free to do whatever they want .
Often , running programs that venture into undefined behavior will crash , but sometimes they may continue executing with no indication of problem and appear to behave correctly most of the time .
In other words , the actual program behavior is system dependent and compiler dependent .
Consider code that represents undefined behavior to logic error , since its action is inconsistent across platforms and compilers .
Simply said , the behavior is unpredictable .
Unpredictable behavior is incorrect behavior .

In most cases , an access simply accesses memory outside the vector .
If this includes memory that does not belong to the executing program , modern operating systems will terminate the gram and produce an error message .
Under Visual when the program is built as debug version default when using the , the program prints the contents of the vector the first time but crashes before it can print it out second time .
Microsoft Windows then displays the dialog box shown in Figure The program running under Linux or macOS may simply print in the .

If your program is using vector , and it terminates with such message , you should check its source code .

The following code fragment shows some proper and improper vector accesses :

supports variation of the for statement that uses special syntax for objects like vectors that support traversal .
Commonly known as the for or " statement , this version of the statement permits vector traversal without an index variable keeping track of the position .
The following code fragment uses for statement to print the contents of an integer vector named vec : for 

You can read this statement as each nt in vec , std   cout  The colon therefore is pronounced " In the first interation of this for loop the variable represents the first element in the vector vec .
In the second iteration represents the second element .
The third time through is the third element , and so forth .
The declared variable assumes the role of different vector element during each iteration of the loop .
Note that the for loop requires no control variable to keep track of the current index within the vector ; the loop itself takes care of that detail , freeing the programmer from that task .

The general form of this statement is .

If the element variable within the for loop is declared to reference , the code within .

It is not always possible to use the for statement when traversing vectors .
The rangebased for statement iterates forward through the vector elements and cannot move backwards .
Also , the for statement is not convenient you want to consider only portion of the elements in the vector .
Examples include visiting every other element in the vector or considering only the first third of the elements .
In these specialized cases you can use standard for loop with an integer control variable .

some other options for traversing vectors in creative ways .

Most objects have access to special functions called methods .
programmers often refer to methods as member functions .
method is function associated with class of objects .
method invocation involves slightly different syntax than function invocation ; for example , obj is an object that supports method named that accepts no parameters , we can invoke on behalf of obj with the .

The dot operator connects an object with method to invoke .
Other than this special invocation syntax , methods work very much like the global functions introduced in method may accept ters and may return value .

Vectors support number of methods , but we will focus on seven of .

We have seen how to declare vector of particular size and use the space provided ; however , we are .

Each method call increases the number of in by one .

The method performs the opposite action of .
call to removes the last from  effectively reducing the number of in the by one .

Declare list to be Add to the end of list Add to the end of the list Add to the end of list Removes from the list Removes from the list .

Programmers use the shorter syntax exclusively , but the longer expression better illustrates the fact that the square bracket operator really is method in the std   class of objects .

As we have seen , programmer must be vigilant to avoid using an index with the operator method .
The class provides an additional method , at , that provides index bounds checking .
The expression in and of itself provides no bounds checking and so may represent undefined behavior .
The functionally equivalent expression vec .
If is outside the acceptable range of indices , the method is guaranteed to produce error .
Listing is variation of Listing that uses the at method instead of the operator method .

errors are bad , but undefined behavior is worse because it can manifest itself as unpredictable errors and programs that behave differently across multiple platforms .

The size method returns the number of in .
The following code fragment prints the contents of list : int  for ;    The exact type that the si ze method returns here is std   vectorci   si .
This type is defined within the std   class .
It is compatible with the unsigned type and may be assigned to an nt variable as shown above .
We can avoid the additional local variable as follows : for ;   Notice that declared type is unsigned , not int .
This prevents warning when comparing to .
comparison between signed and unsigned integer types potentially is dangerous , and .

To see why you should not take this warning lightly , consider the .

This is because even though is not less than , is signed value , not an unsigned value .
The unsigned data type cannot represent signed numbers .
An attempt to compute unsi gned minus on system produces , which definitely is not less than zero .
To be safe , assign the value of the si ze method to an nt variable or use unsigned variables to control loop iterations .
Better yet , use the for statement whenever possible .

The empty method is convenience method ; if vec is  the expression vec .
Note that the empty method does not make the empty ; it simply returns true if the is empty and false if it is not .

The clear method removes all the from leaving it empty .
Invoking clear on an initially empty has no effect .
Immediately after clearing  the size method will return zero , its empty method will return true , and call to its operator method with an index of any value will exhibit undefined behavior .

In this case , the print function uses pass by value , so during the execution an invocation of pri nt will copy the data in the actual parameter to the formal parameter .
Since potentially can be quite large , it generally is inefficient to pass by value as shown above .
Pass by value requires function invocation to create new object for the formal parameter and copy all the of the actual parameter into the new which is local to the function .
better approach uses pass by reference , with twist : void for elem 

The symbol indicates that caller invoking pri nt will pass by reference Section .
This copies the address of the actual parameter by the to the formal parameter instead of making copy of all the data in the .
Passing the address is much more efficient because on most systems an address is the same size as single nt , whereas could , for example , contain nts .
With pass by value function invocation would have to copy all those integers from the actual parameter into the formal parameter .

Section indicated that parameter passing is preferred to parameter passing .
This is because function using pass by value cannot modify the actual variable the caller passed to it .
Observe closely that our new nt function declares its formal parameter vtobeaconst reference .

This means the function cannot modify the actual parameter passed by the caller .
Passing object as constant reference allows us to achieve the efficiency of pass by reference with the safety of pass by value .

Passing by const reference is not the same as pass by value , though .
The function receiving ter passed by value can modify the parameter and return modified copy .
function using pass by const reference cannot modify the parameter passed to it .

Like the nt function , the sum function in Listing does not intend to modify the contents of its parameter .
Since the sum function needs only look at the contents , its parameter should be declared as const reference .
In general , if purpose is to modify  the reference should not be const .
Listing uses function named that fills with pseudorandom integer values .

The function in Listing calls the method clear which makes empty .
We call clear first because we want to ensure the is empty before we add more elements .
The function then proceeds to add random number of random integers to the empty .

function may return object .
Listing is practical example of function .

The function examines every value in the range begi .
The mes function uses me as helper function .
If the me function classifies value as prime , code within the mes function adds the value to the After mes has considered all the values in the provided range , will contain all the prime numbers in that range .
In the end , primes returns the containing all the prime numbers in the specified range .

When returning local variable that is scalar type like int , double , char , function normally makes copy of the local variable to return to the caller .
Making copy is necessary because local variables exist only while the function in which they are declared is actively executing .
When the function is finished executing and returns back its caller , the environment reclaims the memory held by the local variables and parameters so their space can be used by other functions .

The return value in mes is not simple scalar is an object that can be quite large , especially if the caller passes in large range .
Modern compilers generate machine code that eliminates the need to copy the local .
The technique is known as return value optimization , and it comes into play when function returns an object declared within the function .
With return value optimization , the compiler " that the variable will disappear and that the variable is to be returned to the caller ; therefore , it generates machine language code that makes the space for the in the memory space , not the called function .
Since the caller is maintaining the space for the object , it persists after the function returns .
Because of return value optimization you can return vectors by value in situations like this one without fear of copy operation .

Due to the fact that vectors may contain large number of elements , you usually .

If the function is not meant to modify the contents of the  declare the as const reference .

It generally is safe to return by value from function if that is .

supports vectors .
is best visualized as table with rows and columns .

It literally creates with two elements , and each element is itself containing three integers .
Note that the type of is of of integers .
is sometimes called matrix .
In this case , the declaration specifies that contains two rows and three columns .
Figure shows the logical structure of the created by the following sequence of code : 

Rows are arranged horizontally , and the values in columns are arranged vertically .

In each of the assignment statements above , for example ; the first index signifies the row and the second index denotes the column of the element within the .
Literally , the expression means ; that is , the element at index of the at index within .

Using syntax similar to the initialization lists of vectors , we can declare and initialize .

Note that each row appears within its own set of curly braces , and each row looks like ID .

Such type alias .

In this case this typedef directive works identically to the usi ng alias .

inherits the typedef keyword from the programming language .
The using alias is newer and supports aliasing capabilities beyond those provided by the more primitive typedef .
For this reason , you should prefer the usi ng aliasing to typedef when writing pure code .

Here we replaced the explicit const std   with the word auto .
The piler is able to infer the of the variable from the context : is Mat is , std : so must be an element of the itself is ID .

We can build vectors with dimensions higher than two .
Each " of is simply  is of vectors , etc .
For example , statement .

In practice , vectors with more than two .

began as an extension of programming language , but does not directly support programming .
Consequently , does not have vectors available to represent sequence types .
The language uses more primitive construct called an array .
True to its roots , supports arrays as well as vectors .

Some libraries use arrays in instead of vectors .
In addition , programs can use any of large number of libraries that have been built up over past years , and many of these libraries process arrays .
While more modern construct like std   may be better suited for may of roles an array has played in past , it nonetheless is important for programmers to be familiar with arrays .

An array is variable that refers to block of memory that , like  can hold multiple values simultaneously .
An array has  and values it contains are accessed via their position within block of memory designated for array .
Also like  elements within an array must all be of same .
Arrays may be local or global variables .
Arrays are built into core language of both and .
This means you do not need to add any include directives to use an array within program .

Arrays come in two varieties , static and dynamic .
programmer must supply of static array when declaring it ; for example , following statement : list is an array of integers int ; declares li st to be an array of integers .
The value within square brackets specifies number of elements in array , and is fixed for life of array .
The value within square brackets must be constant value determined at compile time .
It can be literal value or symbolic constant , but it cannot be variable .
This is in contrast to declarations in which initial may be specified by variable with value determined at run time : int .

If you provide number within square brackets , it should be at least as large as number of elements in initialization list .
The equals symbol is required for array initialization .
You optionally can use equals symbol as shown here when initializing vectors , but it is not required for vectors .

If declaration omits an initializer list , as in : int .

This code fragment shows that square brackets used after point of declaration allow us to access an individual element based on that position within block of memory assigned to array .

This syntax is identical to that used with objects .
As with vectors , very first element in an array appears at index .

The compiler uses this number along with the type of the array to determine how much memory to allocate for the array .

After the declaration , for .

Unlike with vectors , the compiler will insist that the programmer use an integral value for an index ; for .

Identically to vectors , the programmer must ensure that the array index .

The programmer can supply number .

An undecorated array name by itself in source code behaves like constant pointer to the beginning element of the array .
Consequently , when an array is passed as an actual parameter during function .

The clear function actually modifies the contents of array .
The function works on the actual elements , not copies of its elements .

Arrays , therefore , by default are passed by reference with respect to the elements they contain .
By default , an contents are open to corruption by errant functions .
In order to protect an array so that .

does not directly support empty arrays .
physical array must contain at least one element .
times it is appropriate to consider an array that is conceptually empty ; for example , what if we wish to pass an " array to the sum function .
We can pass as the second parameter since an empty array contains no elements , but what should we pass as the first parameter .
Any array will do , but there is no need create an real array when none truly is needed .

An array name used in source code references location in memory , the address of the first element at index in the array .
In this way an array name is similar to constant pointer Section for more information about .
Because of this , we can treat in some ways an array identifier like pointer .
Similarly , we can direct pointer to point to an array , and then treat the pointer itself as if it were an array .

shorter way to accomplish the same thing is  since is itself reference to the location in memory .
This assignment statement clearly strates the association between array variables and pointer variables .
Note that the opposite assignment is impossible , because array declared as above may not appear by itself on the left side of the assignment operator .

Pointer variables can participate in addition and subtraction expressions .
The statement + + changes the address stored in so subsequently the pointer will point to the next integer position in memory .

If is assigned to array  incrementing redirects it to point to next element .

The expression is another way to write so the array indexing operator can be used with pointers .

Since most types require more than one byte of storage , incrementing pointer by does not simply add to the address it holds .
The amount added depends on the type of the pointer ; for example , on systems using integers , adding to an integer pointer variable increments its address by , not .
The compiler knows the type of the pointer variable because programmers must declare all variables .
The compiler , therefore , can automatically adjust the arithmetic to work properly .
If pointer points to memory within an array and is of the same type as the array , incrementing the pointer correctly repositions the pointer to point to the next element in the array .

The expression + dereferences the address that is positions away from the address referenced by .

Sometimes pointer notation is used to represent an array parameter to function .
The array print .

The recursion terminates when the length is zero .

Instead of passing pointer to an array and the size , we can pass two pointers .
The first pointer points to the beginning of the array and another pointer points just past the end of the array .

Listing also shows how we can use the square bracket array access .

The advantage of the pointer approach is that it allows programmer to pass slice of the array to the function ; for example , if we wish to print the elements of the array from index to index , we would .

Programmers need not worry about managing the memory used by static arrays .
The compiler and environment automatically ensure the array has enough space to hold all of its elements .
The space held by local arrays is freed up automatically when the local array goes out of the scope of its declaration .
Global arrays live for the lifetime of the executing program .
Memory management for static arrays , therefore , works just like scalar variables .

Static arrays have significant limitation : The size of static array is determined at compile time .
The programmer may change the size of the array in the source code and recompile the program , but once the program is compiled into an executable program any static size is fixed .
For many applications the circumstances of the executing program must determine the size of an array .
Static arrays lack such flexibility .

Listing creates an array that can hold one million entries .

Notice that the array numbers is global variable and is not local to mai .
This is because most systems limit the amount of storage available to local variables within functions .
Local variables reside in an area of memory known as the stack .
Local variables exist in memory only when the function that uses them is invoked ; therefore , the stack grows and shrinks as functions execute and return .
Global variables , on the other hand , exist in the memory for the life of the execution .
Global variables are stored in what is known as static memory .
There is limit to the amount of static memory available for global variables amount of memory in RAM or virtual memory on disk , if nothing , but the global limit usually is much higher then the local limit .
One million numbers consumes bytes in Visual and on many other systems .
The default stack size for local variables under Visual is only one megabyte , although the stack size can be increased by adjusting the compiler and linker build options .

While the approach taken in Listing works , it wastes memory resources .

In modern computing , user may have multiple programs open at the same time .
If each program is tying up the maximum amount of memory it may ever need , there may not be enough real memory to go around , and the computer will be forced to use more virtual memory portions of the running memory to and from the disk .
Virtual memory access greatly degrades the speed of program , and so the experience suffers .
It is important that each program uses its resources wisely .

Statically allocating the largest array that might ever be needed is not good approach .

This statement makes space for single pointer , merely four bytes on system or eight bytes on .

The value of this expression is the starting address of the newly allocated memory block .

While we access dynamic array via pointer , static array array behaves like constant pointer ; that  pointer that we cannot reassign to point elsewhere .

The reserved word new memory for the elements , new classified as an operator .
The area of memory used for dynamic allocation via new different from both the area used for local variables and global variables .
Dynamic memory comes from the heap .

The variable local to mai , so it lives on the stack .
It pointer , so it stores memory address .
The new returns an address to memory in the heap .

We do not need to worry about our array being too big to be local to mai , since its contents do not consume stack space .

An executing program automatically on the stack the local variables of function when caller invokes the function .
The executing program also automatically deallocates local variables when the function returns .
The programmer does not need to explicitly manage local variables .
Dynamically allocated memory , however , requires more attention on the part of the programmer .
The statement delete  Free up the space held by uses the delete to free up the memory held by the array .
The programmer sible for deallocating memory that was allocated with .
Notice that the square brackets are empty .
The environment keeps track of the amount of memory to free up .

You should develop the habit of ensuring that every use of the has an associated call of delete .
If the delete statement omitted from Listing , the program in this case likely will behave no differently since most operating systems reclaim all the dynamic memory program holds when the program finishes executing .
Serious problems arise in longer running programs that must allocate and deallocate dynamic memory over time .
Programs that run for extended periods of time , like web servers and operating system kernels , can crash due to failures to properly deallocate memory .
The condition known as memory leak program overtime more and more memory via never releases the memory back with delete .
Eventually the program uses up all of the available heap space and crashes .

Since behaves like constant pointer , we cannot reassign it ; that  the name cannot appear on the left .

The code above will not compile .

Declare two arrays , one dynamic Populate one of them is filled with increasing values Make copy of array .

This illustrates another key difference between vectors and arrays : It is not possible to assign one array .

If the arrays are static arrays , the simple assignment is illegal .
If the arrays are dynamic arrays , the .

Figure shows how this process works .

It is important to note that since the above allocates dynamically with  elsewhere within the program should eventually use delete to free up space when it is no longer used .
Failure to properly deallocate constitutes memory leak .

Consider the following .

Not only does this simple assignment create an alias , it also creates memory leak .
If the reassigned originally was pointing to block of memory allocated on its behalf , and no other pointers reference that block of memory , that block is unreachable by the executing program .

Listing requires the user to enter up front the number of values to average .
This is inconvenient , and people are notoriously poor counters .
One solution is to allocate minimal size  and then resize it as necessary when it fills up .
Listing uses this approach .

Notice that the programmer of Listing .
Unlike vectors , an has fixed size .
It is impossible to change the size of static of editing the source and .
In order to change at run time the size of dynamic  you must .

Just as supports vectors , it also supports multidimensional arrays .
The following statement :  declares to be of integers .
In this case , the declaration specifies that contains two rows and three columns .
Figure shows the logical structure of the created by the .

Rows are arranged horizontally , and the values in columns are arranged vertically .

In each of the assignment statements above , for example ; the first index signifies the row and the second index denotes the column of the element within the .

For arrays initialized in this manner the first subscript is optional , but the second subscript is , the .

The declaration of the parameter is quite complicated , and , as we did for vectors , we can simplify the syntax by using aliasing statement , statement using double  defines new named .

Given the alias using statement defining the new name Mat , we can express the .

As with vectors , allows arrays with dimensions higher than two .
Each " of array is .

and implement strings as arrays of char .
The language additionally supports string objects Section .
In the language , the only option is char array .

We use the term string to refer to an array of characters as used in the language .
In this section , any mention of the term string refers to string .

string is an array of characters .
string literal is sequence of characters enclosed within quotation marks , as in .

This means the last character in the array is ASCII zero , which .

Enough space must be reserved for number of characters in the string , including the null terminating .

The array of characters must be properly null terminated .

The following code fragment is safe and .

The following code fragment is less .

The string can hold viable characters plus the null terminator .
If the user types in relatively short words less than , there is no problem .
If at any time the user types in more characters than will fit in the array , the executing program will have problem .
The problem is known as buffer overrun .
In the best case , buffer overruns lead to buggy programs .
In the worst case , clever users can exploit buffer overruns to compromise software systems .
Buffer overruns are always logic errors and you should take great care to avoid them .

The following code provides safe way to get user .

The second parameter specifies the maximum length of the string , including the terminating null character , that will be placed in the string .
The last argument , stdi is construct related to the object std   ci .
In order to use gets within program you must include the header .

The following code begs for .

In this case points to random location in memory is , and the code allocates no buffer to receive the input characters from std   ci .
The behavior executing this code is undefined , but it likely will lead to the program crashing .
Insidiously , depending on how the operating system manages memory , the program may run fine much of the time and crash only rarely .
Regardless , the program contains serious bug .

When passing an array to function caller must provide the size of the array so that the function may process the array properly .
Since strings are null terminated , such size information is not necessary .

The function in Listing determines if particular character is present in string .

The function in Listing uses pointer notation to traverse the string .
It does not need to know in advance the number of characters in the string because it starts at the beginning and keeps scanning each character in turn until it finds the character it is looking for or encounters the null terminating character .

The only way out of the loop is to scan the null terminating or the sought .
Here , if the loop encounters the null terminating  it exits and returns that null .
The null is simply ASCII false .
If the loop locates the sought  it exits and returns that which will not be ASCII zero .
Any except the null has an ASCII value greater than zero ; therefore , the calling code interprets the returned as Boolean true .

Some standard string functions include .

The function returns an integer less than zero if appears lexicographically before .
The function returns an integer greater than zero if appears lexicographically after .
The function returns zero if the two strings are identical .

The following code fragment .

The function returns an integer less than zero if the first characters of appear lexicographically before the first characters of ; that is , would appear before is dictionary .
The function returns an integer greater than zero if the first characters of appear lexicographically after the first characters of .
The function returns zero if the first characters of the two strings are identical .

You should be familiar with strings because code can use libraries , and libraries often use strings .
Since strings tend to be problematic , however , in most cases you should use the newer stri ng objects whenever possible .

Windows command prompt the command .

These filenames are called arguments .
They are provided in addition to the program ' name .

arguments allow the user to customize in some way the behavior of the program when launching it .
In the example above , the user specifies which file to copy and the name of its copy .
programs that process arguments do so via an array .

extra .

The program did not print the first line shown in this program run .
The command shell printed awaiting the user ' command , and the user typed the remainder of the first line .
In response , the program printed the remaining four lines .
The parameter argc contains the number of arguments on the command line typed by the user .
The declaration cha rgv indicates rgv is an array of strings .

Notice that rgv is simply the name of the file containing the program .

Since the arguments are strings , not integers .

It is important to note is that arrays are not objects and , therefore , have no associated methods .
The square bracket notation when used with arrays does not represent special operator method .
The square bracket array access notation is part of the core language inherited from .
The creators of the vector library designed vectors to behave as much as possible like primitive arrays .
Arrays have been part of the language since its beginning , but vectors by have adopted the syntactical features of arrays .

Both arrays and vectors use square brackets for element access , and both locate their first element at index zero .
Both provide access to block of memory that can hold multiple elements .
vector object adds some additional capabilities and conveniences that make vectors the better choice for developers .
Table summarizes many of the differences between vectors and arrays .

Vectors have close association with vector object is thin wrapper around dynamic array .

The ty pointer points to the memory location just past the block of memory allocated for the array .

The pointer is present because the array managed by vector often will have more space allocated than the vector currently needs .
An algorithm determines the amount of extra space needed to balance the demands of storage economy and fast calls .
When an executing program attempts to an onto vector that has not reached its capacity , the operation is very fast ; however , an attempt to onto vector that is at its capacity forces the memory manager to do the .

Resizing and copying the array is relatively process , especially as the size of the vector grows .
The capacity is tuned so that the average time to perform fast without the need to consume too much extra memory .

vector adds value to raw array by providing convenient methods for adding elements and resizing the array it manages .
vector keeps track of its own size .
Arrays provide none of the convenient methods that vectors do .
The overhead that vector imposes over raw dynamic array is negligible .
You should prefer vectors over arrays when writing code .

What if you are using vectors , but you need to use library that accepts only arrays .

Note that the first parameter is the starting address of the wrapped array , and the second parameter is the .

Since the standard , the std : class has method named data that returns pointer to the first of the array the vector manages .
We can rewrite the above statement as .

As these examples show , you may use objects instead of arrays without any danger of not being able to use libraries that deal only with arrays .

If you happen to be using an array and need to use function that expects instead , it is easy to .

One disadvantage of this technique is that it copies all the elements in arr to new array managed by the .
This is because object demands full control over the array it manages .
automatically frees up the memory of its array when it goes out of scope .
Forcing to manage preexisting array could lead to problems in two .

The code that created the array could later delete the contents of the array out from under the Any attempted use of the after that point would be problem .

When the goes out of scope it automatically deallocates the array it manages .
The code that originally created the array could afterward attempt to access the deallocated array with similar predictably disastrous results .

For these reasons the developers of the standard library designed the std   class to be in full control of its managed array .
We thus cannot create object from array created elsewhere without making copy of the array .

We will see in Chapter that it is relatively easy to write function in generic way so that it can accept and process either or an array with equal efficiency .

Vectors are convenient data structures for working with arrays .
provides an type equivalent to static arrays .
The std :  array is the preferred way to represent arrays in .

In order to use the std   ray class you must use the following preprocessor directive : ttinclude Instead of declaring static array as int ; you can write nt  arr ; The first expression in the angle brackets specifies the type of elements held by the array , and the second expression specifies the size .
The compiler must be able to compute the size ; this means the size must be an integral literal or defined integral constant .
Like static array , this size cannot be specified at run time .
Also unlike std   vectors , the size of std  object remains fixed for the duration of the execution .
Like std :   however , std : object keeps track of its own size and supports reassignment .
Listing shows that we can determine the number of elements in std   ray object via its size method , just as we would with std :  object .

Programmers must manage primitive arrays and associated pointers very carefully because array and pointer misuse is common source of difficult to find and repair bugs within programs .
Vectors effectively take care of much of the memory management problems that plague raw arrays .
Additionally , vectors provide functionality and convenience that arrays cannot .
As we have seen , it is easy to adapt to context that requires an array .

Listing uses an algorithm developed by the Greek mathematician Eratosthenes who lived from .
The principle behind the algorithm is simple : Make list of all the integers two and larger .
Two is prime number , but any multiple of two cannot be prime number multiple of two has two as .
Go through the rest of the list and mark out all multiples of two ,
Move to the next number in the list this case ,
If it is not marked out , it must be prime , so go through the rest of the list and mark out all multiples of that number ,
Continue this process until you have listed all the primes you want .

Recall Listing , which also prints all the prime numbers up to .

Using redirection Section  Listing takes seconds .
In comparison , Listing fll takes about one second to perform the same task on the system .
This is comparable to the square root version .
Listing , which takes two seconds to run .
If the goal is to print the prime numbers up to , the original version averages seconds , or about four and minutes .
The square root version averages seconds .
The  version averages seconds .
For values the unoptimized original version takes little over an hour and minutes , the square root version takes respectable seconds , but version averages only seconds to run .

Both the and array types represent linear sequences of elements .
Vectors and arrays are venient for storing collections of data , but they have some limitations .
In Section we will consider another kind of aggregate data structure called an associative container .
Associative containers permit ment access via key rather than an index .
Unlike an index , key is not restricted to an integer expression .

Associative containers are better choice for some kinds of problems .

Provide single declaration statement that declares an integer named li st that contains the values , and .

Does keep track of the number of elements it contains .

Does the std   ray class have more in common with static array or dynamic array .

Complete the following function that adds up all the positive values in an integer .
For example , if vec contains the elements , and , the call ti ve would evaluate to , + + +
The function returns zero if the is empty .
The function does not affect the contents of the .

Complete the following function that counts the even numbers in an integer .
For example , if vec contains the elements , and , the call would evaluate to , the contains two even numbers : and .
The function returns zero if the is empty .
The function does not affect the contents of the .

Complete the following function that compares two integer vectors to see if they contain exactly the same elements in exactly the same positions .
The function returns true if the vectors are equal ; otherwise , it returns false .
For example , if vecl contains the elements , and , and contains the elements , and , the call equals , would evaluate to true .
If instead contains the elements , and , the call equals , would evaluate to false second and third elements are not in the same .
Two vectors of unequal sizes cannot be equal .
The function does not affect the contents of the vectors .

Complete the following function that determines if all the elements in one also appear in another .
The function returns true if all the elements in the second also appear in the first ; otherwise , it returns false .
For example , if vecl contains the elements , and , and contains the elements , and , the call contai ns , would evaluate to true .
If instead contains the elements , and , the call contai ns , would evaluate to false does not appear in the first .
Also If contains the elements , and , the call contai ns , would evaluate to false appears twice in but only once in vecl , so vecl does not contain all the elements that appear in .
The function does not affect the contents of the vectors .

All the elements in the same row should appear on the same line , and but each successive row should appear on its own line .

Consider the declaration , std :

Provide the that declare and ceate dynamic array named that can hold integers .

What extra attention does programmer need to give to static array when its use within program is finished .

What extra attention does programmer need to give to dynamic array when its use within program is finished .

What extra attention does programmer need to give to array when its use within program is finished .

Provide single declaration statement that declares an integer array named li st that contains the values , and .

Does an array keep track of the number of elements it contains .

Complete the following function that adds up all the positive values in an array of integers .
For example , if array ar contains the elements , and , the call would evaluate to , + +
The function returns zero if the array is empty is ,

Complete the following function that sums the even numbers in an array of integers .
For example , if array arr contains the elements , and , the call would evaluate to , +
The function returns zero if the array is empty is ,
The function does not affect the contents of the array .

All the elements in the same row should appear on the same line , and but each successive row should appear on its own line .

Given the following declarations which appear in function .

What is the consequence of its omission .

List some common errors programmers make when dealing with dynamic memory .

Chapters introduced the fundamentals of making and using vectors .

the elements within sequence into particular common activity .
For example , sequence of integers may be arranged in ascending order is , from smallest to .
sequence of words may be arranged in lexicographical called order .
Many sorting algorithms exist , and some perform much better than others .
We will consider one sorting algorithm that is relatively easy to implement .

The selection sort algorithm is relatively easy to implement , and it performs acceptably for smaller sequences .
If is sequence , and and represent indices within the sequence , selection sort works as follows :

Examine all the elements , where .
If any of these elements is less than , then exchange with the smallest of these elements .
If is less than the length of , increase by and goto Step .

If the condition in Step is not met , the algorithm terminates with sorted sequence .
The command to Step " in Step represents loop .
We can begin to translate the above description into as .

In order to determine if any of the elements is less than , we introduce new named The purpose of is to keep track of the position of the smallest element found so far .
We will set equal to initially because we wish to locate any element less than the element found at position .

Interchanges the values of memory referenced by its parameters and .

It effectively interchanges the values of variables in the caller ' context .

We really do not need to write our own function to interchange the values of two integers as shown in Listing .
The standard library includes std   swap that works just like the swap function in Listing ; therefore , if you remove our custom swap definition in Listing and replace the call to swap with call to std   swap , the program will work just as well .

It is actually an easy modification ; simply change the line .

This would take little more effort , but it still is possible to do .

The next question is more intriguing : How can we rewrite the selecti function so that , by passing an additional parameter , it can sort the in any way we want .

We can make our sort function more flexible by making it function Section that accepts an ordering function as parameter .
Listing arranges the elements in two different ways using the same selecti function .

The comparison function passed to the sort routine customizes the behavior .
The basic structure of the sorting algorithm does not change , but its notion of ordering is adjustable .
If the second parameter to selecti is , the sort routine arranges the elements into ascending order .
If the caller passes instead , selecti rearranges elements into descending order .
More creative orderings are possible with more elaborate comparison functions .

Selection sort is relatively efficient simple sort , but more advanced sorts are , on average , much faster than selection sort , especially for large data sets .
One such general purpose sort is Quicksort  devised by .

Quicksort is the fastest known general purpose sort .
Since sorting is common data processing activity , the standard library provides function More information about Quicksort and qsort is available at Quicksort .

The key function in Listing is locate ; all the other functions simply lead to more interesting display of results .
If locate finds match , it immediately returns the of the matching element ; otherwise , if locate considers all the elements of the and finds no match , it returns .

This alignment simplifies the di splay function .

The kind of search performed by locate is known as linear search , since the process takes straight line path from the beginning to the end of the  and it considers each element in order .
Figure illustrates linear search .

An alternative to linear search is binary search .
In order to perform binary search elements must be in sorted order .
Binary search exploits this sorted structure of the using clever but simple strategy that quickly zeros in on the element to find :
If the is empty , return .

Check the element in the middle of the .
If the element is what you are seeking , return its If the middle element is larger than the element you are seeking , perform binary search on the first half of the .
If the middle element is smaller than the element you are seeking , perform binary search on the second half of the .

This approach is analogous to looking for telephone number in the phone book in this manner :
Open the book at its center .
If the name of the person is on one of the two visible pages , look at the phone number .

If not , and the last name is alphabetically less the names on the visible pages , apply the search to the left half of the open book ; otherwise , apply the search to the right half of the open book .

Discontinue the search with failure if the name should be on one of the two visible pages but is not present .

If the is empty , is zero , and is equal to which equals .
So in the case of an empty bi na rch will skip the loop body and immediately return .
This is correct behavior because an empty cannot possibly contain any item we seek .

The variable represents the midpoint value between and  and it is computed in the .

The problem arises if the is large , and and both have relatively large values .
The expression + can overflow the range of integers producing meaningless result .
The subsequent division by two is too late to help .
The result of the expression + would overflow the range of integers more often than the expression + + because + would be much smaller value to add to fi st .
If you are thinking would never have thought of that " worry too much .
large number of competent , professional software engineers have fallen prey to this oversight http 

The calculation of ensures that .

If mi is the location of the sought element in the , the loop terminates , and returns the correct .

The second statement ensures that either decreases or increases each time through the loop .
Thus , if the loop does not terminate for other reasons , eventually will be larger than  and the loop will terminate .
If the loop terminates for this reason , the function returns .

This is the correct behavior .

The second statement excludes the irrelevant elements from further search .
The number of ments remaining to consider is effectively cut in half .

Figure illustrates how binary search works .

The implementation of the binary search algorithm is more complicated than the simpler linear search algorithm .
Ordinarily simpler is better , but for algorithms that process data structures that potentially hold large amounts of data , more complex algorithms employing clever tricks that exploit the structure of the data binary search often dramatically outperform simpler , algorithms .

For fair comparison of linear vs .
The revised linear search algorithm is .

Notice that , as in the original version of linear search , the loop will terminate when all the elements have been examined , but it also will terminate early when it encounters an element larger than the sought element .

Since the is sorted , there is no need to continue the search once you have begun seeing elements larger than your sought value ; seek cannot appear after larger element in sorted .

Suppose to search contains elements .
In the worst for an element larger than any currently in the the loop in linear search takes iterations .
In the best for an element smaller than any currently in the function immediately returns without considering any other elements .
The number of loop iterations thus ranges from to  and so on average linear search requires comparisons before the loop finishes and the function returns .

Now consider binary search of that contains elements .
After each comparison the size of the left to consider is the original size .
If the sought item is not found on the probe , the number of remaining elements to search is .
After the next time through the loop , the number of elements left to consider is of , or After the third iteration , search space in the drops to of which is This process of cutting the search space in half continues each time through the loop until the process locates the sought element or runs out of elements to consider .
The problem of determining how many times set of things can be divided in half until only one element remains can be solved with logarithm .
For binary search , the worst case scenario of not finding the sought element requires the loop to make log iterations .

How does this analysis help us determine which search is better .
The quality of an algorithm is judged by two key .

How much time does it take to run .

How much space does it take to run .

In our situation , both search algorithms process the sequence with only few extra local variables , so for large sequences they both require essentially the same space .
The big difference here is speed .
Binary search performs more elaborate computations each time through the loop , and each operation takes time , so perhaps binary search is slower .
Linear search is simpler operations through the , but perhaps its loop executes many more times than the loop in binary search , so overall it is slower .

We can deduce the faster algorithm in two ways : empirically and analytically .
An empirical test is an .

Listing measures the running times of the two kinds of searches to compare the two algorithms empirically .

Listing applies linear search and binary search to vectors of various sizes and plays the results .
The sizes range from to .
The program uses the function ti to compute the average running times of linear search and binary search .
The main function directs which search ti should perform by passing as the parameter pointer to the appropriate function .
The second parameter to ti specifies the number of runs the function should use to compute the average .
Notice that in this program we average linear search over five runs and execute binary search over runs .
We subject the binary search function to more runs since it executes so quickly , and five runs is not an adequate sample to evaluate its performance , especially for smaller vectors where the binary execution time is close to the resolution of the timer .
Besides , since binary search does execute so quickly , we easily can afford to let ti run more tests and compute more accurate average .

In Listing we use stream manipulators std   and std   setpreci si to dress up the output .
The std   manipulator adjusts std   to use number of mal places , and the std   setpreci si manipulator specifies the number of digits to display after the decimal point .
The two manipulators in tandem allow us to align the columns of numbers by their decimal points .

With vector of linear search takes average about seconds one system , while binary search requires small fraction of one second .
The times for binary search are so small that the progression of times wanders bit from perfectly ascending order .
This is because the operating system is performing other tasks while our program is running .
It gives each active program its own slice of processor time to run .
The operating system can interrupt executing programs to give other tasks time to run .
For most programs this processor time sharing is imperceptible , but it can make significant difference in running programs .
We can see in the results that the operating system must have attending to some other matters during the binary search of vectors of size and , as these times are slightly higher than we would expect from the pattern of values .
Ideally we would perform the tests multiple times and average the results to get more accurate picture .

If we increase the size to , linear search runs in seconds minutes , while binary search still takes less than one second .
Empirically , binary search performs dramatically better than linear search .

One might wonder why binary search on vector with items is slightly slower than one on vector containing elements .
This particular execution was performed on computer running Microsoft Windows .
Microsoft Windows ' timer resolution via the clock function is milliseconds , so the values for nary search are near that resolution .
Windows is multitasking operating system , meaning it manages number of tasks simultaneously .
The measurements above were performed on loaded " which means during the execution the user was not downloading files , browsing the web , or doing anything else in particular .
Windows , as all modern multitasking OSs , runs lot of services in the background that steal processor time slices .
It continually checks for network connections , tracks the users mouse movement , etc .
The binary search speed coupled with multitasking OS with millisecond timer resolution can lead to such minor timing anomalies .

In addition to using the empirical approach , we can judge which algorithm is better by analyzing the source code for each function .
Each arithmetic operation , assignment , logical comparison , and vector access requires time to execute .
We will assume each of these activities requires one unit of processor " This assumption is not strictly true , but it will give acceptable results for relative comparisons .
Since we will follow the same rules when analyzing both search algorithms , the relative results for comparison purposes will be fairly accurate .

We determined that , on average , the loop makes iterations for vector of length .
The initialization of happens only one time during each call to .
All other activity involved with the loop except the return statements happens times .
The function returns either or , and only one return is executed during each call .
Table shows the breakdown for linear search .

We determined that in the worst case the loop in bi na rch iterates log times if the vector contains elements .
The two initializations before the loop are performed once per call .
Most of the actions within the loop occur log times , except that only one return statement can be executed per call , and in the statement only one path can be chosen per loop iteration .
Table shows the complete analysis of binary search .

We will call our binary search function .
Figure shows the plot of the two functions and .

For , the linear function + is less than the binary function log +
This means that linear search should perform better than binary search for vector sizes less than .
This is because the code for linear search is less complicated , and it can complete its work on smaller vectors before the binary search finishes its more sophisticated computations .

Unfortunately we cannot empirically compare the running times of the two searches for vectors small enough to demonstrate that linear search is faster for very small vectors .
As the output of Listing shows , both searches complete their work in time less than the resolution of our timer for vectors with elements .
Both empirically and analytically , we see that binary search is fast even for very large vectors , while linear search is impractical for large vectors .

Sometimes it is useful to consider all the possible arrangements of the elements within vector .
sorting algorithm , for example , must work correctly on any initial arrangement of elements in vector .
To test sort function , programmer could check to see if it produces the correct result for all arrangements of relatively small vector .
rearrangement of collection of ordered items is called permutation .

Listing prints all the permutations of the contents of given vector .

The permute function in Listing is recursive function , as it calls itself inside of its definition .
We have seen how recursion can be an alternative to iteration ; however , the permute function here uses both iteration and recursion together to generate all the arrangements of glance , the combination of these two algorithm design techniques as used here may be difficult to follow , but we actually can understand the process better if we ignore some of the details of the code .

First , notice that in the recursive call the argument begi is one larger , and end remains the same .

This means as the recursion progresses the ending index never changes , and the beginning index keeps increasing until it reaches the ending index .
The recursion terminates when becomes equal to end .

In its simplest form the function looks like .

If loop iterates fixed number of times , you may replace the loop with the statements in its body duplicated that number times ; for example , we can rewrite the code for ;  as .

This process of transforming loop into the series of statements that the loop would perform is known as loop unrolling .
Compilers sometimes unroll loops to make the execution faster .
After unrolling the loop the loop control variable this case is gone , so there is no need to initialize it and , more importantly , no need to check its value and update it during each iteration of the loop .

Our purpose for unrolling the loop in pe rm is not to optimize it .
Instead we are trying to understand better how the algorithm works .
In order to unroll loop , we will consider the case for vectors .

This series of operations allows .

The leftmost third of Figure shows the original contents of the and the initial call of permute .
The three branches represent the three iterations of the for loop : varying from to .
The vectors indicate the state of the after the first swap but before the recursive call to permute .

The middle third of Figure shows the state of the during the first recursive call to permute .

The two branches represent the two iterations of the for loop : varying from begi to .
The vectors indicate the state of the after the first swap but before the next recursive call to permute .

At this level of recursion the element at index zero is fixed , and the remainder of the processing during this chain of recursion is restricted to indices greater than zero .

The rightmost third of Figure shows the state of the during the second recursive call to .

The function makes no more recursive calls to itself .
The function merely prints the current contents of the vector .

The arrows in Figure ; represent call to , or return from , permute .
They illustrate the recursive call chain .
The arrows pointing left to right represent call , and the arrows pointing from right to left represent return from the function .
The numbers associated with arrow indicate the order in which the calls and returns occur during the execution of permute .

The second column from the left shows the original contents of the vector after the first swa call but before the first recursive call to permute .
The swapped elements appear in red .
The third column shows the contents of the vector at the second level of recursion .
In the third column the elements at index zero are fixed , as this recursion level is using begi with value of one instead of zero .
The for loop within this recursive call swaps the elements highlighted in red .
The rightmost column is the point where begi equals  and so the permute function does not call itself effectively terminating the recursion .

While Listing is good exercise in vector manipulation and recursion , the standard library provides function named on that rearranges the elements of vector .
Listing uses on within loop to print all the permutations of the elements .

Section showed how we can generate all the permutations of vector in an orderly fashion .
More often , however , we need to produce one of those permutations chosen at random .
For example , we may need to randomly rearrange the contents of an ordered vector so that we can test sort function to see if it will produce the original ordered sequence .
We could generate all the permutations , put each one in vector of vectors , and select permutation at random from that vector of vectors .
This approach is very inefficient , especially as the length of the vector to permute grows larger .
Fortunately , we can randomly permute the contents of vector easily and quickly .
Listing contains function named permute that randomly permutes the elements of an vector .

Notice that the permute function in Listing uses simple loop and no recursion .
The permute function varies the index variable from to the index of the next to last element in the .
Within the loop , the function obtains via rand Section pseudorandom index greater than or equal to .
It then exchanges the elements at position and the random position .
At this point all the elements at index and smaller are fixed and will not change as the execution continues .
The loop then increments index  and the process continues until all the values have been considered .

To be correct , our permute function must be able to generate any valid permutation of the .
It is important that our permute function is able to produce all possible permutations with equal probability ; said another way , we do not want our permute function to generate some permutations more often than others .
The permute function in Listing is fine , but consider slight variation of the .

Do you see the difference between and permute .
The function chooses the random index from all valid indices , whereas permute restricts the random index to valid indices greater than or equal to .
This means that can exchange any element within with the element at position during any loop iteration .
While this approach superficially may appear to be just as good as permute , it in fact produces an uneven distribution of permutations .

Listing exercises each permutation function times on the ,  and tallies each permutation .
There are exactly six possible permutations of this threeelement .

In one million runs , the permute function provides an even distribution of the six possible permutations of .

To see why misbehaves , we need to examine all the permutations it can produce .

The top of the tree shows the original 
The second row shows the three possible resulting configurations after the first iteration of the for loop .
The leftmost represents the element at index zero swapped with the element at index zero no .
The second on the second row represents the interchange of the elements at index and index .
The third on the second row results from the interchange of the elements at positions and .
The underlined elements represent the elements most recently swapped .
If only one item in the is underlined , the function merely swapped the item with itself .
The bottom row of contains all the possible outcomes of the .

Compare Figure to Figure The second row of the tree for permute is identical to the second row of the tree for , but the third row is different .
The second time through its loop the permute function does not attempt to exchange the element at index zero with any other elements .
We see that none of the first elements in the in row three are underlined .
The third row contains exactly one instance of each of the possible permutations of , 
This means that the correct permute function is not biased towards any of the individual permutations , and so the function can .

Complete the following function that reorders the contents of so they are reversed from their original order .
For example , containing the elements , would be transformed into ,
Note that your function must physically rearrange the elements within the  not just print the elements in reverse order .

Complete the following function that reorders the contents of so that all the even numbers before any odd number .
The even values are sorted in ascending order with respect to selves , and the odd numbers that follow are also sorted in ascending order with respect to themselves .

For example , containing the elements , would be transformed into , Note that your function must physically rearrange the elements within the  not just print the elements in reverse order .

Complete the following function that shifts all the elements of backward one place .
The last element that gets shifted off the back end of the is copied into the first position .
For example , if containing the elements , is passed to the function , it would be transformed into , Note that your function must physically rearrange the elements within the vector , not just print the elements in the shifted order .

Complete the following function that returns true if contains duplicate elements ; it returns false if all the elements in are unique .
For example , the , contains duplicates appears more than , but the , does not of the elements more than .

An empty has no duplicates .

Can linear search be used on an unsorted .

Complete the following function ng that returns true if the elements in of integers in ascending order precisely , order , if the contains .
For example , the following statement .

Consider sort function that uses the ng function from the previous problem .
It uses loop to test the permutations of of integers .
When it finds permutation that contains all of the elements in ascending order it exits the loop .
Do you think this would be good sorting algorithm .

technician does not need to assemble the card ; the card is used as is off the shelf .
The video card provides substantial amount of functionality in standard package .
One video card can be replaced with another card from different vendor or with another card with different capabilities .
The overall computer will work with either card to availability of drivers for the operating because standard interfaces allow the components to work together .

Software development today is increasingly component based .
Software components are used like hardware components .
software system can be built largely by assembling software building blocks .
supports various kinds of software building blocks .
The simplest of these is the function that we investigated in Chapter and Chapter more powerful technique uses and user designed software objects .

is .
It was not the first OO programming language , but it was the first OO language that gained widespread use in variety of application areas .
An OO programming language allows the programmer to define , create , and manipulate objects .
Variables representing objects can have considerable functionality compared to the primitive numeric variables like nts and doubles .
Like normal variable , every object has type .
We say an object is an instance of particular class  and class means the same thing as type .
An type is its class .
We have been using the std   and std   ci objects for some time , std   is an instance of the std   ostream is to say std   is of type std   ostream .

Code that uses an object is client of that object ; for example , the following code fragment : uses the std   object and , therefore , is client of std 
Many of the functions we have seen so far have been clients of the std   std   ci objects .
Objects provide services to their clients .

The standard library provides the class stri ng which specifies string objects .
In order to use string objects , you must provide the preprocessor directive ttinclude .

You declare stri ng object like any other variable : string  You may assign literal character sequence to st ri ng object via the familiar string quotation syntax : string ;   You may assign one stri ng object to another using the simple assignment operator : string ,

In this case , the assignment statement copies the characters making up into .
After the assignment both and have their own copies of the characters that make up the string ; they do not share their contents .
After the assignment , changing one string will not affect the other string .
Code within the string class defines how the assignment operator should work in the context of string objects .

The ng class provides method named si ze that behaves exactly like the length method .

The ng class defines method named that allows programmer to access .

Similarly , the syntactally sweetened way to write " The + performs concatenation , making new by appending one to the back of another .

With the substr method we can extract new from another , as shown in Figure In addition to methods , the standard ng library provides number of global functions that process strings .
These functions use syntax and allow us to compare strings , etc .

more complete list of methods and functions can be found at .

The precise type of std   std   ostream , and std   ci type std   stream .

Like objects , std   and std   ci have methods .
The and operators actually are the methods and .
The second statement calls the method on behalf of the std   object passing the value of variable .
statement such as :

The return value std   then used to invoke the method again with   as its argument .

It reads value from the keyboard and assigns it to .
The method call returns std   ci itself , and the return value is used immediately to invoke passing variable by reference .

You probably have noticed that it is easy to cause program to fail by providing input that the program .

What if the user enters the " which arguably is an integer .
The program produces incorrect results .
We can use some additional methods available to the std   ci object to build more robust program .
Listing detects illegal input and continues to receive input until the user provides an acceptable value .

If the user enters value with type compatible with the declared type of the variable , the expression evaluates to true ; otherwise , it .

While determining whether of not entry is correct seems sufficient for the programmer to make corrective measures , it is not .
Two additional steps are .

The bad input characters the user provided cause the std   ci object to enter an error state .

Whatever characters the user typed in that cannot be assigned to the given variable remain in the keyboard input buffer .
Clearing the stream object does not remove the leftover keystrokes .
Asking the user to retry without clearing the bad characters entered from before results in the same the stream object the error state and the bad characters remain in the keyboard buffer .
The solution is to flush from the keyboard buffer all of the characters that the user entered since the last valid data entry .

Once the stream object has been reset from its error state and the keyboard buffer is empty , user input can proceed as usual .

The ostream and stream classes have number of other methods , but we will not consider them here .

This means you cannot use the to assign complete line of text from the keyboard if that .

To read in complete line of text from the keyboard , including any embedded spaces that may be .

Vectors would be more useful it they were persistent .
Data is persistent when it exists between program executions .
During one execution of particular program the user may create and populate vector .
The user then saves the contents of the vector to disk and quits the program .
Later , the user can run the program again and reload the vector from the disk and resume work .

The user also may quit the program , and later the program and load in the previously saved list of numbers .
The user can save different number lists to different files using different file names .

Notice that in the and functions we pass the std   stri ng eter as const reference .
We do this for the same reason we do so for std :  objects Section technique avoids making copy of the string to pass the functions .
These functions can " the actual string via the reference , rather than working with copy of the string object .

The const specifier prevents the functions from modifying the string passed .
It takes time to copy string long , and the copy would occupy extra memory .
In this case the copy really is not necessary , so passing by const reference is the ideal approach .

This opens the file as the point of .

An output file stream may fail for various reasons , including the disk being full or insufficient permissions to create file in given folder .

Once we have its associated file open , we can use std   ofstream object like the std   cout output stream object , except the data is recorded in text file instead of being printed on the screen .
Just like with std   cout , you can use the operator and send std   ofstream object stream lators like std   setw .
The std   cout object and objects of class std   ofstream are in the same family of classes and related through concept known as inheritance .
We consider inheritance in more detail in ChapterjTTj For our purposes at this point , this relationship means anything we can do with the std   cout object we can do std  ofstream object .
The difference , of course , is the effects appear in the console window for std   cout and are written in text file given std : object .

After the executing program has written all the data to the file and the std : object goes of scope , the file object automatically will close the file ensuring that all data the program writes to the file is saved completely on disk .
The std :  ofstream class provides also close method that allows programmers to manually close the file .
This sometimes is useful when using the same file object to recreate the same file , as in Listing .

In Listing , std   fstream object reads data from files .

This opens the file as the point of .

As with std   ofstream objects , filename is string file name identifying the file to read .

After opening the file the program should call good to ensure the file was successfully opened .
An input stream object often fails to open properly because the file does not exist ; perhaps the file name is misspelled , or the path to the file is incorrect .
An input stream can also fail because of insufficient permissions or because of bad sectors on the disk .

Once it opens its associated file , an input file stream object behaves like the std   ci object , except its data comes from text file instead the keyboard .
This means the familiar operator and getli ne function are completely compatible with std :  fstr earn objects .
The std :  ci object and std 

As with an output stream object , std   fstream object automatically will close its associated file when it goes out of scope .

Input and output streams use technique known as buffering .
Buffering relies on two .

It is faster to write data to memory than to disk .

buffer is special place in memory that holds data to be written to disk .
program can write to the buffer much faster than directly to the disk .
When the buffer is full , the program the operating can write the complete contents of the buffer to the disk .

To understand the concept of buffering , consider the task of building wall with bricks .
Estimates indicate that the wall will require about bricks .
Once we are ready to start building the wall we can drive to the building supply store and purchase brick .
We then can drive to the job site and place the brick in its appropriate position using mortar as required .
Now we are ready to place the next brick , so we must drive back to the store to get the next brick .
We then drive back to the job site and set the brick .
We repeat this process about times .

It would be better to put as many bricks as possible into the vehicle on the first trip , and then make subsequent trips to the store for more loads of bricks as needed until the wall is complete .

In this analogy , the transport vehicle is the buffer .
The output stream object uses special place in memory called buffer .
Like the vehicle used to transport our bricks , the memory buffer has fixed capacity .
program can write to the buffer much more quickly than directly to the disk .
The operator writes the individual values to save to the buffer , and when the buffer is full , the output stream sends all the data in the buffer out to the disk with one request to the operating system .
As with the bricks , this is more efficient than sending just one character at time to the display .
This buffering process can speed up significantly the input and output operations of programs .

After the std   of stream object writes all its data to its buffer and its lifetime is over , it flushes the remaining data from the buffer to disk , even if the buffer is not full .
The buffer is fixed size , so the last part of the data likely will not completely fill the buffer .
This is analogous to the last load of bricks needed for our wall that may not make up full load .
We still need to get those remaining bricks to our almost complete wall even though the vehicle is not fully loaded .

In some situations it is necessary to ensure the buffer is flushed before it is full and before closing the file completely .
With any output stream object writing text we can use the std :  endl stream object to flush the buffer without closing the file .
We mentioned std :  endl briefly in Section We can use std   endl interchangeably with   to represent newlines for console printing .
Because of the performance advantage buffering provides to file input and output , the choice of std : and   can make big difference for file processing .
Listing compares the performance of std   endl and   in various situations .

Listing writes vector containing integers to the console and text file .
Each number appears on its own line .
Since std   endl flushes the stream buffer in addition to printing    we would expect it to reduce the performance since it would minimize the benefit of buffering in this case .
Multiple runs of Listing on one system revealed that using   to terminate lines generally was only slightly faster than std   endl not when writing to the console window .
The   terminator was consistently about three times faster than std   endl when writing to text file .

Listing also exploits the special relationship between std  cout and any std   of stream object .
The pri and pri functions both accept std   ostream object as their second parameter .
Note that the caller , mai , passes both the std   cout object and the fout object to these printing functions at various times , and the compiler does not complain .
We defer an nation of how this works until Chapter .

supports mathematical complex numbers via the std   complex class .
Recall from mathematics that complex number has real component and an imaginary component .
Often written as + bi , is the real part , an ordinary real number , and bi is the imaginary part where is real number and .

The std   complex class in is template class like vector .
In the angle brackets you specify the precision of the complex components :

Here , the real component and imaginary coefficient of fc are values , dc .

If the imaginary part is zero , the number is number , in this case ,

Imaginary numbers have scientific and engineering applications that exceed the scope of this book , so this concludes our brief into class .
If you need to solve problems that involve plex numbers , more information can be found at http 

Listing showed that we must use care when randomly permuting the .

Suppose we wish to generate pseudorandom numbers in the range .
This range spans numbers .
Under Visual is , which is large enough to handle maximum value of .
The expression will evaluate to number in our desired range .
good pseudorandom number generator should be just as likely to produce one number as another .
In program that generates one billion pseudorandom values in the range .
The actual value for given number will vary .

Listing evaluates the quality of the rand with modulus technique by generating one billion pseudorandom numbers within loop .
It counts the number of times the pseudorandom number generator produces and also it counts the number of times appears .
Note that is near the beginning of the range .
To verify the consistency of its results , it repeats this test times .
The program reports the results of each individual trial , and in the end it computes the average of the trials .

Figure If shown in full , the table would contain rows and individual numbers .

Elements in each row are .

Four ways to obtain .

Only three ways to obtain any value in the range .
The next lines that the program show the result of each trial , monitoring the activity of the one billion number generations .
Since we are dealing with pseudorandom numbers , the results for each trial will not be exactly the same , but over one billion runs each they should be close .
Note how consistent the results are among the runs .

While we expected both and to appear about the same number of approximately fact the number appeared consistently more that times , averaging times .
The number appeared consistently less than times , averaging .
Note that ; this means the value appeared times more often than .

Figure shows why the expression rand does not produce an even distribution .

Figure shows an abbreviated list of all the numbers the rand function can produce before applying the modulus operation .
If you add the missing rows that the ellipses represent , the table would contain rows .
All of the four values in each row are equivalent modulus ; thus , for example .

Because the leftmost three columns are complete , the modulus operator can produce values in the range .

The rand function cannot return value greater than ; specifically , in our program above , rand not produce .
Listing , therefore , using rand and modulus we can produce in only three different ways : and .
Based on our analysis , Listing can generate the number four different ways and three different ways .
This ratio agrees with our empirical observations of the behavior of Listing .
The consequences of this bias means that values in the relatively small range .
Such bias definitely is undesirable in pseudorandom number generator .

We must use more sophisticated means to produce better pseudorandom numbers .

The rand function itself has another weakness that makes it undesirable for serious scientific , ing , and mathematical applications , rand uses linear congruential generator algorithm http 
This means that the pattern of the sequence of numbers it generates will repeat itself exactly if you call rand enough times .
For Visual , period is .
Listing verifies the period of rand .

Listing uses the long long int integer data type because it needs to count above the limit of the nt type ,
The short name for long long nt is just long long .
Visual uses four bytes to store both nt and long types , so their range of values are identical .
Under Visual , the type long long occupies eight bytes which allows the long long data type to span the range .
To represent literal long long within source code , we append the LL suffix , as in .
The expression represents the nt of , but represents the long long of .

Listing prints the first pseudorandom numbers it generates , then it prints .

careful observer could detect this repetition and thus after some time be able to predict the next pseudorandom value that the program would produce .
predictable pseudorandom number generator is not good random number generator .
Such generator used in game of chance would render the game perfectly predictable by clever players .
better pseudorandom number generator would have much longer period .

The Mersenne twister is widelyused , pseudorandom number generator .
It has very long period , ly , which is proximately lO .
If an implementation of the Mersenne twister could generate pseudorandom numbers every second , program that generated such pseudorandom numbers exclusively and did nothing else would need to run about years before it began to repeat itself .
It is safe to assume that an observer will not be able to wait around long enough to be able to witness repeated pattern in the sequence .

The standard library contains the class from which programmers can instantiate objects used to generate pseudorandom numbers using the Mersenne twister algorithm .
Generating the dom numbers is one thing , but ensuring that the numbers fall uniformly distributed within specified range of values is another concern .
Fortunately , the standard library provides multitude of classes that allow us to shape the production of an object into mathematically sound distribution .

Our better pseudorandom generator consists of three .

We use the object in place of srand .
The object performs the role of the rand function , albeit with much better characteristics .
The uni stri buti on object constrains the pseudorandom values to particular range , replacing the simple but problematic modulus erator .
Listing upgrades Listing with improved random number generation is based on these classes .

During this particular program run we see that in attempts the program generates the value on average times and generates on average times .
Both of these counts imately equal the expected target .
Examining the trials individually , we see that neither the for nor the for is predisposed to be greater than or less than the other .
In some als the program generates slightly less than times , and in others it appears slightly greater than times .

These multiple trials show that in over tions the program consistently generates approximately times and approximately times .

The object produces pseudorandom number from the generator object .
The mt object generates pseudorandom number , and the uni stri buti on object constrains this pseudorandom number to the desired range .

Programmers create an object with ce object .
The ce object provides the seed value , potentially from hardware source , to the generator object .

We also can pass fixed integer value to constructor if we want the generator to produce perfectly reproducible sequence of values ; for example , the following code fragment .

The use of ce , and uni stri buti on is little more complicated than using srand and rand with the modulus operator , but the extra effort is worth it for many applications .
This approach is more modular because it allows us to substitute an object of different pseudorandom number generator class in place of if we so choose .
We also may swap out the normal distribution for different distribution .
Those familiar with probability theory may be familiar with variety of different probability distributions , such as Bernoulli , Poisson , binomial , etc .
The standard library contains distribution classes that model all of these probability distributions and many more .
Programmers can mix and match generator objects and distribution jects as needed to achieve specialized effects .
While this flexibility is very useful and has its place , the .

All these strings are examples of strict palindromes where spacing and punctuation must reverse exactly .
Complete the following function that determines if given string is strict palindrome .
It should return true if the string is strict palindrome and false otherwise .

The empty string reads the same forward and backward , so it is palindrome .

What is the class of the std   ci object .

Suppose the user types in line of text and presses the enter key .
For example , the user might type the following : The sky is blue What statement could you use to assign to std   stri ng variable named msg the complete line of text , including spaces .

In earlier times programmers wrote software in the machine language of the computer system because pilers had yet to be invented .
The introduction of variables in association with programming languages marked great step forward in the late .
No longer did programmers need to be concerned with the details of the processor and absolute memory addresses .
Named variables and tions allow programmers to abstract away such details and concentrate on concepts such as integers and characters that transcend computer electronics .
Objects provide level of abstraction above that of simple variables .
Objects allow programmers to go beyond simple can focus on more complex things like geometric shapes , bank accounts , and aircraft wings .
Programming objects that represent these things can possess capabilities that go far beyond the simple variables we have studied to this point .

object typically consists of collection of data and code .
By bundling data and code together , objects store information and provide services to other parts of the software system .
An object forms computational unit that makes up part of the overall computer application .
programming object can model object more naturally than can collection of simple variables since it can encapsulate considerable complexity .
Objects make it easier for developers to build complex software systems .

is classified as an language .
Most modem programming languages have some degree of object orientation .
This chapter shows how programmers can define , create , and use custom objects .

Mathematicians represent single point as an ordered pair of real numbers , usually expressed as .
In , the double type serves to approximate subset of the mathematical real numbers .
We can model point with coordinates within the range of numbers with two double variables .
We may consider point as one thing conceptually , but we here we would be using two variables .
As consequence , function that computes the distance between two points requires four ,  and yj than two and  Ideally , we should be able to use one variable to represent point .

This approach has several .

We must use numeric indices instead of names to distinguish between the two components of point object .
We may agree that means the coordinate of point pt and means the coordinate of point pt , but the compiler is powerless to detect the error if programmer uses an expression like pt or pt .

We cannot restrict the size to two .
programmer may accidentally push extra items onto the back of meant to represent point object .
The compiler could not defend against program treating an empty as point object .

We cannot use to represent objects in general .
Consider bank account object .
bank account object could  among many other diverse things , an account number , customer name , and an interest rate .
implementation of such an object is impossible because the elements in must all be of the same type .

In addition to storing data , we want our objects to be active agents that can do computational tasks .
We need to be able associate code with class of objects .
We need fundamentally different programming construct to represent objects .

Before examining how specifically handles objects , we first will explore what capabilities are sirable .

An automobile the car for transportation .
The interface to the car is fairly simple , considering an overall complexity .
driver vides input to the car via its steering wheel , accelerator and brake pedals , turn signal control , shift lever , etc .

The automobile produces output to the driver with its speedometer , tachometer , various instrument lights and gauges , etc .
These standardized interfaces enable an experienced driver to drive any modern car without the need for any special training for particular make or model .

The typical driver can use car very effectively without understanding the details of how it works .
To drive from point to point driver does not need to know the number of cylinders in the engine , the horsepower , or whether the vehicle is drive or drive .
driver may look under the hood at the engine , but the driver cannot confirm any details about what is inside the engine itself without considerable effort or expense .
Many details are of interest only to auto enthusiasts or mechanics .

There may be only select few automotive engineers capable of understanding and appreciating other more esoteric details about the design and implementation .

In some ways programming objects as used in programming languages are analogous to automobile components .
An object may possess considerable capability , but programmer using the object needs to know only what the object can do without needing to know how it works .
An object provides an interface to any client code that wishes to use that object .
typical object selectively exposes some parts of itself to clients and keeps other parts hidden from clients .
The designer , on the other hand , must know the complete details of the implementation and must be an expert on both the what the object does and how it works .

Programmers define the structure of new of object using one of two keywords : struct or class .
The two constructs are very similar .
We will use the class construct in this chapter , and we will consider structs in Section class serves as pattern or template from which an executing program may produce objects .
In this chapter we will concentrate on four things facilitating programming with .

Notice the semicolon that follows the close curly brace of the class definition .
This semicolon is required , but it is easy to forget .
By convention class names begin with capital letter , but class names are just identifiers like variable names and function names .
Here , our class name is Poi nt .
The body of the class appears within the curly braces .

The elements declared within class are known as members of the class .
The Poi nt class specifies two data components named and .
These components are known as instance variables .
The community often refers to these as member data or data members .
Other names for instance variables include fields and attributes .
The declarations for and appear within the class body after the publi c label .
We say that and are public members of the Poi nt class ; this means client code using Poi nt object has full access to the and fields .
Any client may examine and modify the and components of Poi nt object .

Once this Poi nt class definition is available , client can create and use Poi nt objects as shown in .

It is important to note that Poi nt is not an object .
It represents class of objects .

The variables and are the objects , or instances , of the class Poi nt .
Each of the objects and has its own copies of fields named and .
conceptual view of point objects and .

numbers on most systems require eight bytes of memory .
Since each Point object stores two doubles , Poi nt object uses at least bytes of memory .
In practice , an object may be slightly bigger than the sum its individual components because most computer architectures restrict .

This means some objects include few extra bytes for " We can use the si zeof operator to determine the exact number of bytes an object occupies .
Under Visual , the expression si zeof evaluates to .

client may use the dot operator with an object to access one of the members .
The dot operator is binary operator ; its left operand is an expression representing class instance , and its right operand is the name of member of the class .

The assignment statement in Listing ; and the statements that follow demonstrate that we may assign one object to another directly without the need to copy each individual member of the object .
The above assignment statement accomplishes the following : No need to assignment this way ; direct object assignment does this As another example , suppose we wish to implement simple bank account object .
We determine that the necessary information for each account consists of name , ID number , and balance of money in the .
We can define our bank account class as .

We can define that holds instances of our Account class as easily as .

This shows that objects can contain other objects and implies that our objects can have arbitrarily complex structures .

sample run of Listing prints .

Enter  account number , and account  Sheri Enter  account number , and account  Mary Enter  account number , and account  Larry Enter  account number , and account  Terry Enter  account number , and account  Gary .

The program allows users to sort the bank account database in several different ways using different parison functions .
Notice that the and similar comparison functions use const reference parameters for efficiency Section .

Observe that the function has local variable named name .
All objects have field named name .
The function uses the name identifier in both ways without problem .
The compiler can distinguish between the two uses of the identifier because one is qualified with an object variable before the dot operator and the other is not ; that is , acct .
Despite their similar names , the data to which acct .

The classes we have developed so far .
Pen nt and Account , have been passive entities that have no builtin functionality .
In addition to defining the structure of the data for its objects , class can define functions that operate on behalf of its objects .

Recall the bank account class , Account , from Section .

We need to be able to protect the internal details of our bank account objects and yet permit clients to interact with them in , controlled manner .

Consider example .
If deposit dollars into bank , the bank then has custody of my money .
It is still my money , so theoretically can reclaim it at any time .
The bank stores money in its safe , and my money is in the safe as well .
Suppose wish to withdraw dollars from my account .
Since have total in my account , the transaction should be no problem .
What is wrong with the following scenario :
Enter the bank .

Leave the bank .

This is not the process normal bank uses to handle withdrawals .
In perfect world where everyone is honest and makes no mistakes , all is well .
In reality , many customers might be dishonest and intentionally take more money than they report .
Even though faithfully counted out my funds , perhaps some of the bills were stuck to each other and made an honest mistake by picking up six bills instead of five .
If place the bills in my wallet with other money already there , may never detect the error .
Clearly bank needs more controlled procedure for handling customer withdrawals .

When working with programming objects , in many situations it is better to restrict client access to the internals of an object .
Client code should not be able to change directly bank account objects for various reasons ,

withdrawal should not exceed the account .

Federal laws dictate that deposits above certain amount should be reported to certain government agencies , so bank would not want customers to be able to add funds to an account in way to circumvent this process .

An account number should never change for given account for the life of that account .

How do we protect the internal details of our bank account objects and yet permit clients to interact with them in , controlled manner .
The trick is to hide completely from clients the fields and provide special functions called member functions or methods that have access to the hidden fields .

These methods provide the only means available to clients of changing the internal state .

In the following revised Account .

Because any parts of class not explicitly labeled are implicitly private , the private label is not necessary if you place all the private members in the first unlabeled section of the class .
Said another way , all members of class are automatically private unless otherwise labeled .
Some programmers like to put the public members before the private members within class definition , as in class Account public .

In this case the pri vate label is necessary .

In order to enforce the spirit of the wi thd raw function , we will make it method , and add deposi method to put funds into an account .
Listing enhances the Account class with .

method looks like function  but it appears within class Because of this , method is also known as member function .

client accesses method with the dot .

The withdraw method uses three variables : amt , result , and .
The variables amt and result are local to is the parameter , and result is declared within the body of wi thd raw .

It is the field declared in the private section of the class .
The wi thd raw method affects the field of the object upon which it is called : Affects the field of acctl object .

When you see variable used within the code of method  it can be one of several kinds of variables .
The compiler establishes the exact nature of the variable in the following order :
Method the variable is declared in the parameter list , it is parameter to the method .
As in the case of free functions , method parameter is variable local to that method .

Local the variable is declared in the body of the method , the variable is local to the method .
Do anything you please with the local variable , and it will not affect any variables outside of that function .

Instance the variable is not parameter to the method , is not declared within the method body , but is declared as an instance variable within the class , it is an instance variable of the object the client used to invoke the method .

Global the variable is not parameter to the method , is not declared within the method body , and is not declared as an instance variable within the class , it must be global variable .
If no such global variable exists , the variable is undeclared , and the compiler will report the error .

It is important to note that the compiler checks in this order .
That means it is legal to give parameter to method or local variable the same name as an instance variable within the class .
In this case the code cannot access the instance variable or global variable by using its simple name .
We say the local variables hide the instance or global variables from view .
Section how we can gain access to these hidden variables .

Methods may be overloaded just like global functions Section .
This means multiple methods in the same class may have the same names , but their signatures must be different .
Recall that signature consists of its name and parameter types ; signature too consists of its name and parameter types .

We saw in Section that each object provides storage space for its own data fields .
An object does not require any space for its methods .
This means the only things about an individual object that an executing program must maintain are the fields .
While the exact organization of memory varies among operating systems , all the data processed by program appears in one of three sections : stack , heap , or static memory .
As with simple data types like nts , the fields of an object declared local to function or method reside in the segment of memory known as the stack .
Also like simple data types , the fields of an object allocated with the new appear on the heap .
The fields in global and stati c local objects reside in the static section of the executing memory .

For this code we see that each Counter object will store single integer value .
Under Visual sizeof Counter is the same as sizeof int that is , four .
local Counter object consumes four bytes of stack space , global Counter object uses four bytes of static memory , and Counter object uses four bytes of heap space .

In addition to static , stack , and heap memory used for data , executing programs reserve section of memory known as the code segment which stores the machine language for all the functions and methods .
The compiler translates methods into machine language as it does regular functions .
nally , the method nc in the Counter class is identified by longer name .
Counter   nc .
Although Counter   nc is method , in the compiled code it works exactly like normal function unrelated to any class .
In the client code Counter Ctrl , Declare couple of Counter objects .

Since all Counter objects share the same reset method , how does each call to Counter   clear reset the field of the proper Counter object .
The trick is this : While it appears that the reset method of the Counter class accepts no parameters , it actually receives secret parameter that corresponds to the address of the object on left side of the dot .

The code within the method can influence the field of the correct object via the .

One crucial piece still is missing .
How can we make sure the fields of an object have reasonable initial values before client begins using the object .
class may define constructor that ensures an object will begin in sate .
constructor looks similar to method .
The code within constructor executes on behalf of an object when client creates the object .
For some classes , the client can provide information for the constructor to use when initializing the object .
As with functions and methods , class constructors may be overloaded .
Listing exercises an enhanced Account class that offers deposi and wi thd raw methods , as well as constructor .

constructor has no return type , not even void .

The constructor in initializes all the fields with values supplied by the client .
The list between the colon and the curly brace that begins the body of the constructor is called the constructor initialization list .
An initialization list contains the name of each field with its initial value in parentheses .
All of the fields that make up an object must be initialized before the body of the constructor executes .
In this case the code within the constructor adjusts the to zero and issues warning if client attempts to create an account with an initial negative .

The wi thdraw method ensures that , once created , an Account will never be negative .
Notice that the client provides the required constructor parameters at the point of the declaration : Client creating two Account objects .

Account ; Illegal , must supply arguments for constructor .

The details of depositing and withdrawing funds are the responsibility of the object itself , not the client code .
The attempt to withdraw the dollars above would not change the  and the client can check the return value of wi thd raw to provide appropriate feedback to the user about the error .

The program then could take steps to correct the situation .

constructor that specifies no parameters is called default constructor .
If the programmer does not specify any constructor for class , the compiler will provide default constructor that does nothing .
If the programmer defines any constructor for class , the compiler will not generate default constructor .
See the consequences of this constructor policy .

If you do not define constructor for your class , the compiler automatically will create one for default constructor that accepts no parameters .
The constructor does not do anything to affect the state of newly created instances .

class feature allows us to define our own complete types .
We will define new type that models mathematical rational numbers .
In mathematics , rational number is defined as the ratio of two integers , where the second integer must be nonzero .
Commonly called fraction , rational two integer components are called numerator and denominator .
Rational numbers possess certain properties ; for example , two fractions can have different numerators and denominators but still be considered equal .
Listing shows how we can define and use rational numbers .

The SimpleRational class defines new type that does not natively rational number type .
One constructor accepts the numerator and denominator values from the client .

The other constructor allows client to declare Si mpleRati onal object as SimpleRational .

Both constructors ensure that Si mpleRati onal denominator will not be zero .

It is free function , not method member of the Si mpleRati onal class .
The return statement requires special attention .
Because of the declaration the compiler knows the function returns Si mpleRati onal object .
The expression within curly braces after the retu rn .

The retu statement therefore creates fraction object with numerator that is the product of the numerators of the objects supplied by the caller .
Similarly , the denominator of the returned object is the product of the denominators of the parameters .

We can use this curly brace initialization syntax when passing parameters to functions ; for example , we .

The compiler knows that accepts single SimpleRational object as parameter .

The compiler generates code that uses the curly brace initialization list to create Si mpleRati onal object to pass to the function .

Our new type certainly leaves lot to be desired .
We cannot display one of our rational number objects with std   very conveniently .
We cannot use the standard arithmetic operators like + or , and we cannot compare two rational numbers or .
In Section we address these shortcomings .

It is all too easy for careless , confused , or inept programmer to change an state in such way as to corrupt the behavior of the entire system .
malicious programmer may intentionally tweak one or more objects to sabotage the system .
In either case , if the software system controls medical device or military missile system , the results can be deadly .

provides several ways to protect the internals of an object from the outside world , but the simplest strategy is the one we have been  We can qualify fields and methods , genetically referred to as class members , as either publi c or pri vate .

The compiler enforces the inaccessibility of private members .
In Listing , for example , client code cannot directly modify the denomi nator instance variable of Si mpleRati onal object making it zero .
client may influence the values of numerator and denomi nator only via methods provided by the class designer .

Accessibility rules , also called visibility rules or permissions , determine what parts of class object are accessible to the outside world .
provides great deal of flexibility in assigning access permissions , but some general principles exist that , if followed , foster programs that are easier to build and extend .

In general , fields should be vate .
Clients should not be able to arbitrarily change the state of an object .
Allowing such might allow client code to put an object into an undefined state example , changing the denominator of fraction to .
An state should only change as result of calling the methods .

The primitive types like nt and double offer no protection from client access .
One ception to the private fields rule applies to simple objects that programmers naturally would treat as primitive types .
Recall the geometric Poi nt class found in Listing .
The and fields of point object safely may assume any legitimate value , and it may be reasonable in some applications for clients to treat Poi nt object as primitive type .
In this case it is appropriate to make the and fields public .

Methods that provide service to client code should be part of the publi c section of the class .

For example , consider the following .

Methods that assist the service methods but that are not meant to be used by the outside world should be in the pri vate section of the class .
This allows publi c method to be decomposed into pler , perhaps more coherent activities without the threat of client code accessing these more primitive methods .
These private methods are sometimes called helper methods or auxiliary methods .

Why would programmer intentionally choose to limit access to parts of an object .
Restricting access obviously limits the control over the objects it creates .
While this may appear to be disadvantage at first glance , this access restriction actually provides number of .

Flexibility in implementation .
class conceptually consists of two parts : The class visible part .
Clients see and can use the public parts of an object .

The public methods and public variables of class constitute the interface of the class .
interface specifies what it does .

Clients cannot see any private methods or vate variables .
Since this private information is invisible to clients , class developers are free to do whatever they want with the private parts of the class .
implementation specifies how it accomplishes what it needs to do .

We would like our objects to be black boxes : clients need to know how the objects work but merely rely on what objects can do .

Many objects follow this design philosophy .
Consider digital wristwatch .
Its display gives its user the current time and date .
It can produce different output in different modes ; for examples , elapsed time in stopwatch mode or wake up time in alarm mode .
It presents to its user only few buttons for changing modes , starting and stopping stopwatches , and setting the time .
How it does what is does is irrelevant to most users ; most users are concerned with what it does .
Its user risks great peril by opening the watch and looking at its intricate internal details .
The user is meant to interact with the watch only through its display and buttons .

Similarly , an automobile presents an accelerator pedal to its user .
The user knows that pushing the pedal makes the car go faster .
That the pedal is connected to the fuel injection system possibly other systems , like cruise through cable , wire , or other type of linkage is of concern only to the automotive designer or mechanic .
Most drivers prefer to be oblivious to the details .

Changing the interface of class can disturb client code that already has been written to use jects of that class .
For example , what if the maintainers of the Si mpleRati onal class decide that mp Ra objects should be immutable ; that is , after client creates mp le Ra object the client cannot adjust the numerator or denomi nator values .
The and nator , therefore , would have to disappear .
Unfortunately , both of these methods are public and thus part of Si mpleRati interface to client .
Existing client code may be these methods , and removing them , making them private , altering the types of their parameters or any other changes to the interface would render existing client code incompatible .
Client code that has been written to use according to its original interface no longer will be correct .
We say the change in Si mpleRati interface breaks the client code .

Class have no flexibility to alter the interface of class once the class has been released for clients to use ; any changes risk breaking existing client code .
On the other hand , altering the private information in class will not break existing client code that uses that class , since private class information is invisible to clients .
When the private parts of class change , clients need only recompile their code ; client programmers do not need to modify their source code .
class , therefore , becomes less resilient to change as more of its components become exposed to clients .
To make classes as flexible as possible , which means maximizing the ability to make improvements to the class in the future , hide as much information as possible from clients .

Reducing programming errors .
Client code cannot misuse the parts of class that are private since the client cannot see the private parts of class .
Properly restricting client access can make it impossible for client code to put an object into an state .
In fact , if client can coax an object into an illegal state via the class interface , then the design implementation of the class is faulty .
As an example , if client can somehow make Si mpleRati onal zero , then one of the methods or constructor must contain logic error .
Clients should never be able to place an object into an illegal state .

Objects can provide great deal of functionality .
Even though class may provide fairly simple interface to clients , the services it provides may require significant amount of complex code to accomplish their tasks .
One of the challenges of software development is dealing with the often overwhelming complexity of the task .

It is difficult , if not impossible , for one programmer to be able to comprehend at one time all the tails of large software system .
Classes with interfaces and hidden implementations provide means to reduce this complexity .
Since private components of class are hidden , their tails cannot contribute to the complexity the client programmer must manage .
The client programmer needs not be concerned with exactly how an object works , but the details that make the object work are present nonetheless .
The trick is exposing details only when necessary : Class .
The class must be concerned with the hidden implementation details of the class .
Since objects of the class may be used in many different contexts , the class usually does not have to worry about the context in which the class will be used .
From the perspective of the class  the complexity of the client code that may use the class is therefore eliminated .

The developer of the client code must be concerned with the details of the application code being developed .
The application code will use objects .
The hidden details of the class these objects represent are of no concern to the client developers .

From the perspective of the client code  therefore , the complexity of the code that makes the objects work is eliminated .

This concept of information hiding is called encapsulation .
Details are exposed to particular parties only when appropriate .
In sum , the proper use of encapsulation results in .

Finally , the encapsulation model has its limits .
It is not possible to protect an object from code within itself .
Any method within class has full access to any member defined within that class .
If you believe that parts of class should be protected from some of its methods , you should split up the class into multiple classes with suitable restrictions among the resulting component classes .

Given the definition of the geometric Poi nt class in Listing , complete the function .

May class constructor be overloaded .

Given the definition of the Si mpleRati onal number class in Section , complete the following free function named .

What are the minimum and maximum values allowed for the coordinate .

Develop Circle class that , like the Rectangle class above , provides methods to compute perimeter and area .
The Rectangle instance variables are not appropriate for circles ; cally , circles do have corners , and there is no need to specify width and height .
center point and radius more naturally describe circle .
Build your Circle class appropriately .

Given the Rectangle and Ci rcle classes from questions above , write an encloses .

Ifcircis too big , the function returns false .
The positions of rect and ci rc do not influence the result .

Consider the following .

In Chapter introduced the basics of programming : private data , public methods , and .

At this point the program has two copies of the fraction ; the client has rational in its variable rati onal , and the executing pri on has rational in its formal parameter .
When the function finishes executing , the formal parameter goes out of scope and its memory is freed .
The function returns back to the caller , leaving the rational as the sole remaining one .

Even though mpleRati onal objects are relatively small bytes under Visual , this cess of creating new serving as the formal parameter , copying the contents from the actual eter into the formal parameter , and finally cleaning up the formal parameter is all unnecessary work on the part of the executing program .

Pass by reference sends single memory address to the function .
There is no need to copy the data into the function .

Safety of pass by  The function cannot modify the actual parameter since the formal parameter is declared const .

If passing types by const reference for types is the better approach why does not do this automatically for us .
defaults to pass by as the default .
This guarantees safety for all types at the expense of reduced efficiency for some types .

When is pass by warranted for types .
caller may make an and then pass copy of the to function that would modify that and return the modified back to the caller .

The caller then could have both the original plus the modified returned by the function .
Doing this via passing by const reference is possible , but requires little more code .
The following sample code .

caller could use the zerol and functions as shown .

Given the Poi nt class from Section the statement Point pt ; declares the variable pt to be Poi nt .
As with primitive data , we can declare pointers to .

Before we use the pointer we must initialize it to point to valid .
We can assign the pointer to refer to an existing  as in ; or use the to dynamically allocate an from the heap :  If the class has constructor that accepts parameters , we need to provide the appropriate arguments when .

As in the Poi nt class example , we can assign the pointer to refer to an existing  as in ; or use the to dynamically allocate an from the heap :  Note that we include the arguments expected by the class constructor .
This statement allocates memory for one and executes the code to initialize the newly created .

Figure illustrates pointer to an account .

As with any dynamically allocated entity , programmer must be careful to use the delete to deallocate any objects created via .

The dot syntax to access field of through pointer is bit .

Without the parentheses , the statement would be evaluated as if the parentheses were placed as shown here .

provides simpler syntax to access fields of an through pointer .
The pointer eliminates the need for the parentheses :  The pair of symbols arrow_operator constitute one space in between is , and the is meant to look like an arrow pointing right .
There is no associated left pointing arrow in .

You can use the arrow_operator to access the methods of an referenced by .

The delete with no decoration frees up single dynamically allocated object : points to an object previously allocated via .

Here , is variable , so it occupies space on the stack .
The space for the variable is automatically deallocated when completes .
The problem is points to memory that was allocated with  this memory is not freed up within the function .
The pointer is the only way to get to that memory , so when the function is finished , that memory is lost for the life of the program .
The condition is known as memory leak .
If the program runs to completion quickly , the leak may go undetected .
In longer running program such as web server , memory leaks can cause the program to crash after period of time .
The problem arises when code that leaks memory is executed repeatedly eventually all of available memory becomes used up .

The corrected function would be written void .

supports vectors arrays of objects , but they present special challenges .
First , consider simple .

No special initializations are needed since has no constructor .
What if class defines constructor that accepts arguments does not supply also constructor that requires no arguments .

The following statement is .

When creating the space for the accts elements , expects default constructor properly initialize all of the elements .
The only constructor in the class requires arguments , so the compiler refuses accept the declaration of accts .
The compiler has no means by which it can produce the code needed initialize the elements before the programmer begins using the .

One solution uses of pointers , as in ; of account pointers Note that this does not create any objects .
The programmer subsequently must iterate through the use create individually each element .

Within method dehnition programmer may access this secret parameter via the reserved word this .

In the method the parameter has the same name as field .
This is legal in ; method parameter or local variable of method may have the same name as field within that class .
The problem is that the local variable or parameter hides the access the field .
Any unqualified use of the name refers the parameter , not the field .
One solution would be name the parameter something else : perhaps or .
strong argument can be made , though , that is the best name for the field , and is also the best name for the parameter the method .
To get access the field in this case , use the thi pointer .
Since thi is reserved word , the expression thi cannot be mistaken for anything other than the field of the object upon which the method was invoked .

Another use of the this pointer involves passing the current object off another function or method .

Remember the syntax of pointers : If thi is pointer , is the object which this points .

Since thi serves as an implicit parameter passed methods , it is illegal use the this expression outside of the body of method .

This behavior is desirable , since the method can change the state of aSi mpleRati onal object , and our tract object is supposed be constant .
Unfortunately , this correct behavior is accidental .

The compiler does not analyze our methods determine exactly what they do .
Consider the following code that also will not .

Since the method does not modify Si mpleRati onal object , we would expect that invoking it on constant object should be acceptable , but the compiler rejects it .
Again , the compiler cannot understand what is supposed to do ; specifically , it is not designed to be able to determine that method will not change the state of an object .
The programmer must supply some additional information to help the compiler .

If method is not supposed to change the state of an object , that method should be declared const .
In the Si mpleRati onal class , the methods and nator simply return , respectively , copies of the and denominator .
Neither method is intended to modify any instance variables .
If we look at the code for those methods , we see that indeed neither method changes anything about Si mpleRati onal object .
What if the programmer made spurious copy and paste the statement .

Unfortunately , the way things stand now , the compiler cannot detect this error , and will contain serious logic error .

We can remove the possibility of such an error by declaring .

The const keyword goes after the closing parenthesis of the parameter list and before the opening curly .

Declaring method is not merely good defensive programming strategy used by class developer .
Methods declared to be can be called with objects , while it is illegal to voke method with object .
With the new version of Si mpleRati method , the following code .

You should declare any method that has no need to change any field within the object .
Similarly , do not declare any method that is supposed to change field in an object .
method can be used with both and objects , but method cannot be used with objects .
For maximum flexibility , always declare method to be unless doing so would prevent the method from doing what it is supposed to do .

You can invoke method from both and objects , but you cannot invoke method from object .
For maximum flexibility , always declare method to be unless doing so would prevent the method from doing what it is supposed to do .

We would ffinclude the header file in all source files that need to use MyClass objects ; the file is compiled separately and linked into the rest of the files .

The class name prefix such as Poi nt   is necessary not only so the compiler can distinguish method definition such as from global function definition , but also to distinguish the method from method with the same name and parameter types that might appear in different class .
method signature for method is just like global function signature , except method signature includes the class name as well .
Each of the following represent distinct .

Poi nt :  is the signature for method of the Poi nt class named that accepts no parameters .

If the class is meant to be used in multiple programs , the compiler must recompile the methods each time the header file is by some source file .
When the method declarations and definitions are separate , the compiler can compile the code for the definitions once , and the linker can combine this compiled code with the client code that uses it .

Client programmers can look at the contents of header files .
If method definitions are Mined , client programmers can see exactly how the methods work .
This can be disadvantage ; for example , client programmer may make assumptions about how fast method takes to execute or the particular order in which method processes data in vector .
These assumptions can influence how the client code calls the method .
If the class maintainer changes the implementation of the method , the client .

certain ordering of the data that before the change resulted in faster processing may now be slower .
An improvement in graphics processing algorithm may cause an animation to run too quickly when the method is rewritten .
For the class maximum flexibility , client programmers should not be able to see the details of implementation because then they cannot form such assumptions .

Client programmers need to know what the method does , not how it accomplishes it .

To enforce this hidden method implementation :
Separate the method declarations from their definitions .
Put the class declaration in the header file and the method definitions in .

Compile the file into an object file .

The client code can now be compiled by including the .

Some programmers find the inline style difficult since it provides too much detail .
It complicates determining what objects of the class are supposed to do because the how is sprinkled throughout the class declaration .

The code within Listing must nclude the header so the compiler is exposed to the Trafficlight class declaration ; otherwise , when compiling the compiler would not know if the method implementations faithfully agreed with declarations .
If the method definition of TrafficLi ght :  change in specified parameters but its declaration within did not , that would be problem .
Furthermore , without including , the type SignalColor would be an undefined type within .

Notice that outside the class declaration in Listing we must prefix the method names with TrafficLi ght 
Without this prefix the compiler would treat the identifiers as globals .
It would interpret them as free functions , not methods .
Si gnalColor is declared outside of the TrafficLi ght class , so it does not need the TrafficLight :  prefix .
SignalColor is global type available to any code that ncludes .

Observe that the variable within the Trafficli ght class is private .
That means that once the client creates traffic light object the only way client can influence the value of is via the change method .
This makes it impossible for client to force traffic light object to cycle incorrectly ; for example , client cannot make traffic light change directly from yellow to green would have to pass through red on the way from yellow to .

The code within the following function definition violates the one definition mle : int int ,

The first appearance denotes the local variable named si ze , and the second use is call to the si ze method of the std   class .
This statement defines only the variable  the method already has been defined in the std   class the compiler processed its definition from the header .

The variable has two distinct definitions in the same context , so its redeclaration right before the display code is an error .

Like variable , class may have only one definition .
When we build general purpose classes meant to be used widely in our programs we must take care that we do not violate the one definition mle .
In fact , we can violate the one definition rule accidentally even if we define class only once .

To see how we can accidentally violate the one definition rule , consider the following simple example .

Suppose we have simple counter class declared in : class Counter int .

Similarly , the header must be included in in order for the compiler to accept Gadget ' declaration of its ti cker field .

Client code that wishes to use Wi dget objects must use the appropriate nclude .

Both of these client programs will build without any problems .
Sometimes , however , program may need to use both Wi dget objects and Gadget objects .
Since the header file does not know anything about the Gadget class and the header file has no information about Wi dgets , we must include both header files in code that uses both classes .
The appropriate include directives would be .

Including one of the header files without the other is insufficient since the compiler must be able to check if the client is using both types correctly .
This client code , however , will not compile .
In this case the problem is with .
Including both and includes the definition of the Counter class twice , so the compiler sees two definitions of Counter .
Even though the two definitions are identical , this violates the one definition rule and so results in compiler error .

The issue here is known as multiple inclusion , and it can arise when header files nclude other header files .
Multiple inclusion is problem , but it often is necessary because the programmer may have legitimate need for both types of objects within the same program .
Fortunately , the solution is simple .
The standard way to prevent multiple inclusion is to wrap class definition as follows : ttifndef .

Do not use semicolons at the end of the lines beginning with fndef , ttdefine , and because these are preprocessor directives , not statements .
The word following the fndef and preprocessor directives can be any valid identifier , but best practice produces unique word tied to the name of the header file in which it appears .
The convention is to use all capital letters and underscores as shown above identifier cannot contain .
Putting an underscore after the header file name further makes it less likely that name will be used elsewhere within the program .
If the header file is named , the preprocessor wrapper would be ttdefine Declare your classes here Like program , the preprocessor can maintain collection of variables .
These variables can influence the compilation process .
variables are merely an artifact of compilation and are unavailable to an executing program .
The preprocessor directive fndef uates to true if the preprocessor has not seen the definition of given preprocessor variable ; fndef returns false if it has seen the definition of the preprocessor variable .
The directive defines processor variable .
The net effect of the directives is that the preprocessor will not include the header file more than once when it is processing source file .
This means the compiler will see the class definition exactly once , thus satisfying the one definition rule .

The preprocessor directives should be used to wrap the class tion in the header file and do not appear in the .
Since you cannot always predict how widespread the use of class will become , it is good practice to use this cessor trick for all general purpose classes you create .
By doing so you will avoid the problem of multiple inclusion .

Point result ; result .

It often is convenient to overload the output stream for custom classes .
The std   cout object , therefore , the std : has overloaded methods named that allow us to print the primitive types like integers and numbers .
If we create new  such as Poi nt or Rati onal , the std   ostream class has no built in to handle objects of our new .
In order to use std   with objects we must define global function of the form : os , const where represents .
Notice that the function returns std  

This is because the first parameter is also an std   ost , and the function returns the same object that was passed into it .
If is  the expression , thus evaluates to reference to std   cout .
This process of returning the object that was passed allows us to chain together the  as in '

Given the above definitions of + and , clients can write code such as Point ,      +    +

When class developers provide such an function , clients can print out objects just as easily as printing the basic data types .

The is not overloaded for the std   class , but we now easily can do it ourselves .

class may define methods .
method for unary accepts no parameters , and method for binary accepts only one parameter .
The " parameter is the object upon which the is applied ; that is , the this pointer .
To see how methods work , consider an enhanced rational class : class EnhancedRational int numerator ; int denominator ; public .

In the Rational class , for example , it is impossible to enable the binary + to have higher precedence than the binary in the context of Rati onal objects or any other classes of objects .

Variables declared in class declaration are known as instance variables because each instance of that class maintains its own copy of the variables .
This means , for example , that changing the numerator of one Rational object will not affect the numerator of any other Rational object .

Sometimes it is convenient to have variables or constants that all objects of class share .
Global variables and constants certainly will work , but globals are not tied to any particular class .
uses the stati c keyword within class to specify that all objects of that class share field ; for example .

One unusual thing about static fields is that must be defined outside of the class declaration .
For the Wi dget class above , we must supply the statement .

Consider factory in which each object must have unique serial number .
Serial numbers are sequential , and new serial number is one larger than the produced immediately before .
Important for warranty claims , client should not be able to alter serial number of object .

The Widget class in Listing shows how to use static variable to manage serial numbers for objects .

The executing program initializes seri rce one time at the beginning of the execution before it calls the main function .
This means seri rce is properly initialized to before the program creates any Wi dget objects .

Each time the client creates new object , the constructor assigns the individual serial from the stati c variable .
The constructor also increments seri  so the next object created will have serial one higher than the previous Wi dget .

programmers often use class static fields to provide public constants available to clients .
sider Listing that models simple traffic light little differently from Listing .

The state of traffic light of its lamps is determined by an integer  represents red  stands for green  and means yellow .
It is much more convenient for clients to use the symbolic constants RED , GREEN , and YELLOW than to try to remember which integer values stand for which colors .
These constants are publi c , so clients can freely access them , but , since they are constants , clients cannot alter their values .
An additional benefit to being const is this : You may initialize stati c const field within the class body itself .
You do not need to stati c const field outside the class body as you do for stati c field .

Code outside of the TrafficSi gnal class can access the constants because they are public but must use the names TrafficSi gnal :  RED , TrafficSi gnal :  GREEN , and TrafficSi gnal :

This statement makes an initially yellow traffic light .
Since the RED , GREEN , and YELLOW public fields are constants , clients cannot modify them to subvert the behavior of traffic light object .

It may not be obvious , but the constants in the rafficSi gnal class must be declared stati c .

Recall from Section that default .

This means the client cannot write code such .

During the creation the client must provide an integer argument representing traffic light .

If RED , GREEN , and YELLOW are constant instance variables is , constant c , every TrafficSi gnalAlt object has its own copy of the fields , and the RED , GREEN , and YELLOW fields cannot exist outside of any traffic light object .
This leads to can we create the first TrafficSi gnalAlt object using the symbolic constants RED , GREEN , or YELLOW .
These constants do not exist unless we have traffic light object , yet we need traffic light object to have any of these constants .

An executing program initializes stati c class fields before it invokes the mai function .
This means any data pertaining to class that must exist before any object of that class is created must be declared stati c .
stati c class variable exists outside of any instance of its class .

allows methods to be declared stati c .
stati c method executes on behalf of the class , not an instance of the class .
This means that stati c method may not access any instance variables is c of the class , nor may they call other c methods .
Since stati c method executes on behalf of the class , it has no access to the fields of any particular instance of that class .
That explains the restriction against static methods accessing data members .
Since nonstati c method may access instance variables of an object upon which it is called , stati c method may not call c method and thus indirectly have access to instance variables .
The restriction goes only one class method , stati c or c , may access stati c data member or call astatic method .

Looking at it from different perspective , all c methods have the thi implicit parameter .

The language supports the struct feature , but not the class keyword .
structs do not support methods and constructors .
In in , struct can contain methods and constructors .
By default , members in st ructs are public , but you can apply the ri vate and publi c labels as in class to fine tune client access .

Despite their similarities , programmers favor classes over structs for types with methods .
The struct construct is useful for declaring simple composite data types that are meant to be treated like primitive types .
Consider the nt type , for example .
We can manipulate directly integers , and integers do not have methods or any hidden parts .
Likewise , geometric point object consists of two coordinates that can assume any valid values .
It makes sense to allow client code to manipulate directly the coordinates , rather than forcing clients to use methods like and .
On the other hand , it is unwise to allow clients to modify directly the denominator of Rati onal object , since fraction with zero denominator is undefined .

In , by default everything in an object defined by struct is accessible to clients that use that object .
In contrast , clients have no default access to the internals of an object that is an instance of class .
The default member access for struct instances is public , and the default member access for class instances is private .

The struct feature is , in some sense , redundant .

By retaining the struct keyword , however , programs can use libraries that use structs .
Any program that expects to utilize library using struct must restrict its struct definitions to the limited form supported by .
Such struct definitions may not contain c members , methods , constructors , etc .

The private members of by default are inaccessible to code outside of that .
Ordinarily only methods within the itself have permission to see and modify the private instance variables and invoke the private methods within that .
This access protection allows programmers to modify the tation of the hidden internals of without affecting existing client code that uses the .

For some designs this access dictated by the public and pri vate labels within or struct is too limiting .
At times it can be advantageous to design that grants special access to some precisely specified functions or classes of objects outside of the .

As an example , consider variation of the Si mpleRati onal from Listing .

Our new  named OpaqueRati onal is shown .

Gone are the , nator , and nator methods of the Si mpleRati onal .

This would require an function overloaded to accept OpaqueRati onal object , and this .

can grant access to an outside function or another via the ri end reserved word .

Listing we specify ri end function that allows clients to display in humanreadable form an opaque rational number object via with an output stream object .

PrintOnlyRational int numerator ; int denominator ; public .

Observe that the function is not member function of the Pri ntOnlyRational .

Ordinarily would be unable to access the numerator and denominator fields of Pri ntOnlyRational object .
We can see , however , that the compiler allows function to access the private instance variables of its parameter .

We chose in Listing to implement the function outside of .

The reserved word ri end at the front indicates to the compiler that is it indeed free function ; does not allow member functions to be declared as friends .

In Listing the Gadget constructor accesses the private data element of Wi dget object to initialize Gadget object .
The Gadget :  compare method accesses the data of Wi dget parameter passed to it .
Neither of these accesses would be possible if the Wi dget did not declare Gadget to be friend .
Note that while Gadget object may freely access the private members of any Wi dget object , no Wi dget object has special access to any Gadget object .
Friendship is not cally symmetric ; that is , the ri end declaration is one directional .
For the relationship to be mutual , the programmer would have to declare the Wi dget to be friend within the Gadget  then objects of both classes could freely access the internal details of each other .

Note that grants friendship unilaterally to an outside or function ; there is no way for an .

Suppose , and are classes .
Further suppose that class is friend of class and that class is friend of class .
The friendship is not transitive ; this means that being friend of and being friend of does not automatically make friend of .
is very strict about the friendship relationship .
The designer of class would need to declare as an additional friend of .
class may have as many friend functions and classes as needed .

Good design avoids friends as much as possible .
Ideally , if class grants friendship to class , the design of classes and should be under the control of the same developers .
Otherwise , friendship weakens encapsulation .
If class grants friendship to class and class is not under the control of the developer of class , one or more of the methods in class could manipulate the internals of an object of type and potentially place it in an state .

The and nator methods eliminate the need for friend function .
Note that Readonly Rati onal object is subtly different from an Pri ntOnlyRati onal object .
Clients can see the numerator and denominator fields of ReadOnlyRational object as desired , but Pri ntOnlyRati onal objects are " clients readily can print an Pri ntOnlyRati onal object but cannot easily discern the individual numerator and denomi nator values .

Both the Pri ntOnlyRati onal and Readonly Rati onal classes represent fraction client creates one these objects the client cannot change its .
In truth , the Readonly Rati onal class is more versatile , as programmers could incorporate ReadOnlyRati onal objects into an tion that displays its output via graphical interface .
Pri ntOnlyRati onal objects limit their access to output streams .
The Pri ntOnlyRati onal class may better serve applications that need such limited access .

Suppose Widget is class of objects , and function proc accepts single Widget object as parameter .
Without knowing anything about class Widget , which of the following definitions of function proc is considered better , and why .

Suppose you have the following definition for class .

Counter cl ; const Counter .

Counter cl ; const Counter ; determine if each of the following statements is legal .

Private static methods .

The algorithm for the recursive gcd common method was introduced in tion The common method is derived from the mathematical relationship : gcd lcm These two methods are declared pri vate because they are not meant to be used directly by client code .
Greatest common divisor and least common multiple are concepts from number theory of which clients have no direct need .
Client code expects functionality typical of rational bers , such as addition and reduction ; these two private methods are used by other , public , methods that provide functionality more closely related to rational numbers .
These two private methods are stati c methods because they do not use instance variables .
An object is not required to compute the greatest common divisor of two integers .
It is legal for gcd and to be instance methods , but instance methods should be used only where necessary , since they have the power to alter the state of an object .
Faulty coding that accidentally modifies an instance variable can be difficult to track down .
If class method is used , however , the compiler can spot any attempt to access an instance variable immediately .

Public instance methods .
None of the instance methods , reduce , + and ope rato modify the state of the object upon which they are invoked .
Thus , the class still produces immutable objects .
The methods + and reduce use the private helper methods to accomplish their respective tasks .

The linear search vs .
The program used the clock function .

programmer must take care to implement the timing code correctly for each section of code to be timed .
This process is error prone : is specialized type that is used infrequently .
It is not obvious from its name that is equivalent to an unsigned integer , so programmer may need to consult library reference to ensure its proper use .

If programmer incorrectly applies parentheses as so .

The timing code is supplemental to the actual code that is being profiled , but it may not be diately obvious by looking at the complete code which statements are part of the timing code and which statements are part of the code to be timed .

Section offered solution to the above shortcomings of using the raw types , constants , and tions available from the time library .

Unfortunately , as mentioned in Section the functional approach has serious limitation .
The code in Listing uses global variables to maintain the state of the timer .
There is only one copy of each global variable .
This means grammers using the timer functions cannot independently measure the elapsed time of overlapping events ; for example , you cannot measure how long it takes for function to execute and simultaneously measure how long section of code within that function takes to execute .

programmer could time multiple , simultaneous activites by using the raw library clock function directly , but then we are back to where we began : messy , potentially code .

Objects provide solution .
Consider the following client code that uses stopwatch object to keep track .

This code using Stopwatch object is as simple as the code that uses the timer functions from ing .
As an added benefit , developer can think of Stopwatch object as if it is real physical stopwatch object : push button to start the clock the start , push button to stop the clock the stop , and then read the time the result of the .
What do you do if you need to time two different things at once .
You use two stopwatches , of course , so programmer would declare and use two Stopwatch objects .
Since each object maintains its own instance variables , each Stopwatch object can keep track of its own time independently of all active Stopwatch objects .

Programmers using Stopwatch object in their code are much less likely to make mistake cause the details that make it work are hidden and inaccessible .
With objects we can wrap all the messy details of the code into convenient package .
Given our experience designing our own types though classes , we now are adequately equipped to implement such Stopwatch class .
Listing provides the header hie defining the structure and capabilities of our Stopwatch objects .

From this class declaration we see that when clients create Stopwatch object constructor is available to take care of any initialization details .
Four methods are available to clients : sta rt , stop , reset , and The reset method is included to set the clock back to zero to begin new .
Note that the " detail of the variable is private and , therefore , clients cannot see or directly affect its value within Stopwatch object .

This Stopwatch class addresses the weaknesses of the approach noted .

The code can be implemented in methods of the Stopwatch class .
Once the methods are correct , programmer can use Stopwatch objects for the execution of sections of code without worrying about the details of how the is actually done .
Client code cannot introduce errors in the code if the code is hidden within the Stopwatch class .

The details of the code no longer intertwine with the code to be timed , since the code is located in the Stopwatch class .
This makes it easier for programmers to maintain the code they are .

The Stopwatch class provides convenient interface for the programmer that replaces the lowerlevel details of calling system time functions .

Stops the stopwatch if it currently is  void .

An alternate design might print an error message and perhaps exit the execution if client attempts to see the of stopwatch .

Some aspects of the Stopwatch class are .

Stopwatch objects use three instance variables : The instance variable records the when the client last called the start method .

The constructor sets the initial values of the instance variables ,  and runni ng .

The sta rt method notes the system after the assignment to runni ng .
If these two statements were reversed , the would include the to do the assignment to runni ng .
The should as closely as possible just include the statements in the client code between the start and stop method calls .

Notice that sta me is not assigned if the stopwatch is .

In the stop method , the system is noted before the assignment to runni ng so the does not include the assignment to runni ng .
This provides more accurate accounting of the client code execution .

The stop method computes the accumulated .
This design allows client to stop the stopwatch and restart it later without losing an earlier segment of .

The method either returns the computed by the stop method or computes the current without altering the me variable .
Clients should avoid calling when Stopwatch object is since doing so would interfere with the accurate of client code execution .

Stopwatch timer ; Ensure the elements are ordered low to high for ; SIZE ;  Search for all the elements in list using linear search .

The design of the Stopwatch class allows clients to create multiple Stopwatch instances , and each instance will keep track of its own .
In practice when profiling executing programs , such generality usually is unnecessary .
Rarely do developers need to overlapping code , so one timer per program usually is enough .
Multiple sections of code can be checked with the same Stopwatch  simply start it , stop it , check the  and then reset it and start it again when another section of code is to be timed .

Section shows how to use function pointers to customize the ordering that selection sort performs on vector of integers .
The function in Listing accepts function pointer parameter in addition to the vector .
The function pointer points to function that accepts two integer parameters and returns true or false .
The function is supposed to use some kind of ordering rule to determine if its first integer parameter precedes its second integer parameter .

Suppose we wish to analyze the number of comparisons and the number of swaps the sort function performs on given vector with particular ordering strategy .
One way to do this is have the sort function itself keep track of the number of times it calls the comparison function and swap function and return this information when it finishes .
To do so we would have to define an to hold the two pieces of data and since function can return only one value , not two .
Also if we do this , we must significantly alter the code of the sort algorithm itself .
We would prefer to keep the sort algorithm focused on its task of sorting and remain uncluttered from this additional logging code .

If instead of passing function pointer to our sort function we pass specially crafted .
We can design our to do whatever we want ; specifically , we can design our special to perform the necessary comparisons and keep track of how many comparisons it performs .
We could let the do the swap , and it could log the swaps it performs .

Notice that Comparison object wraps comparison function pointer , contains swap method , and maintains two integer counters .
The comparison object passed to the sort routine customizes the behavior its function and keeps track of the number of and swaps it performs its integer .
As in Listing , the basic structure of the sorting algorithm remains the same regardless of the ordering determined by the comparison object .

We see from the results that the number of is dictated by the algorithm itself , but the number of element swaps depends on the ordering of the elements and the nature of the comparison .
Sorting an already sorted array with selection sort does not reduce the number of the function must perform , but , as we can see , it requires no swaps .

We can detect errors in our code as we interact with the executing program .
The process of exercising code to reveal errors or demonstrate the lack thereof is called testing .
The informal testing that we have done up to this point has been adequate , but serious software development demands more formal approach .
As you gain more experience developing software you will realize that good testing requires the same skills and creativity as programming itself .

Until recently testing was often an afterthought .
Testing was not seen to be as glamorous as designing and coding .
Poor testing led to buggy programs that frustrated users .
Also , tests were written largely after the design and coding were complete .
The problem with this approach is major design flaws may not be revealed until late in the development cycle .
Changes late in the development process are invariably more expensive and difficult to deal with than changes earlier in the process .

Weaknesses in the standard approach to testing led to new  development .
In testdriven development the testing is automated , and the design and implementation of good tests is just as important as the design and development of the actual program .
In pure TDD , developers write the tests before writing any application code and immediately test all application code they write .

simple test object keeps track of the number of tests performed and the number of failures .
The client uses the test object to check the results of computation against predicted result .
Notice that the equals method , which checks for the equality of two numbers is private , as it is meant to be used internally by the other methods within the class .
The equals method works the same way as the equals function we examined in Listing .

The second test checks to see if our sort function will not disturb an already sorted  and we pass this test with no problem .
This is an example of coincidental correctness .

In the sum function , the programmer was careless and used as the beginning index for the .

Notice that the first test does not catch the error , since the element in the zeroth position does not affect the outcome .
tester must be creative and devious to try and force the code under test to demonstrate its errors .

In Section we used some classes from the standard library to generate .

The class construct allows us to creatively combine multiple sources of functionality into one .

The Uni formRandomGenerator class provides simplified interface to programmers who need cess to pseudorandom numbers .
Behind the scenes , every Uni formRandomGenerator object contains its own uni stri bution object and object .
The constructor accepts the minimum and maximum values in the range of pseudorandom numbers desired .
The structor uses this range to construct the appropriate uni stri buti on object for this range .
The constructor also initializes the object field .
The Uni formRandomGenerator constructor passes to the constructor of the class temporary ce object .
Since Uni formRandomGenerator object uses the ce only for creating its field and does not need it later .
Uni formRandomGenerator objects do not contain ce field .

To create Uni formRandomGenerator object that produces pseudorandom integers in the range .

The expression is syntactic sugar for gen .
The expression gen .

Listing is simplified remake of Listing .

In Listing we see that with our Uni formRandomGenerator class we .

Create large unsigned integer type named Bi gUnsi gned .
Bi gUnsi gned objects represent signed integers with arbitrary precision ; that is , unlike the standard unsigned integer primitive types , Bi gUnsi gned object can represent an unsigned integer as large as necessary .
Unlike the types , Bi gUnsi gned value retains all its digits of precision .

Internally , the Bi gUnsi gned class should hold std   vector of integers .
Each integer in the vector is one of , or .
Each element in the vector represents digit in place value within the integer ; for example , if the internal vector contains the following elements in the following order : we would interpret the associated Bi gUnsi gned object as the mathematical nonnegative integer .

Your gUnsi gned class implementation should provide the following .

The class should provide constructor that accepts no arguments that initializes the gUnsi gned vector to contain single element equal to zero .

The class should provide constructor that accepts single unsigned integer .
This constructor should populate its internal vector with the appropriate elements to correspond to the value of its parameter .

The class should provide constructor that accepts gUnsi gned argument .
Clients use this constructor to create new gUnsi gned object from an exiting gUnsi gned object .

The class should provide constructor that accepts std   st ng object representing an teger .
Clients use this constructor when they need to create large integer whose value exceeds the range of unsigned long long .
The string argument should contain only digits .

The class should provide access to friend function named that adds two gUnsi gned objects and returns the gUnsi gned result .

The class should provide access to ri end function named that allows clients to print gUnsi gned value as easily as integer type .

In we saw how it is possible to design classes from which clients can produce objects that exhibit somewhat sophisticated behavior .
We built each of the classes from scratch .
provides way to create from an existing by process known as inheritance .
Through this process the new inherits all the characteristics of the existing  and the developer can extend and customize the inherited functionality as well as add new .

Recall from Section that writing data to file is almost as easy as printing it on the screen .

Can we easily adapt our so that we can use it with std   of stream objects as well .

The answer , perhaps surprisingly , is we do not have to adapt our function ; it works as is with std :  of stream objects .
How can this be , since the std :  object has type std  which is not the same as std   of stream .

allows some automatic conversions among the built in numeric types ; for example , an nt is widened to double , and double is truncated to an nt .

These types are built into the language , so standard conversions apply .
When it comes to programmerdefined types , however , the compiler is unable to generate automatically code to convert from one type to another .
Most of the time it would make no sense to do attempting to convert an object of type Stopwatch to an object of type Tester .

So , how is it that an object of type std :  of stream can be converted automatically to an object of type ostream .
You might think that it is because they are both part of the standard library , so the conversion has been programmed into them .
The fact is , no conversion takes place .
Any object of type std   of st ream object is automatically treated as if it were an ostream object because the ostream and std   of stream classes are related in special way .
The std   of stream is derived from the ostream .
We say that ostream is the base and std   of stream is the derived .

Sometimes the term superclass is used for the base  in which case the derived is called the subclass .
The terminology is used interchangeably with , although the community tends to prefer the terms to .
The process is known as inheritance because the derived inherits all the characteristics of its base .
The terms derivation , subclassing and specialization are sometimes used in place of the term inheritance .

As consequence of the derivation process , an instance of the derived can be treated as if it were an instance of the base .
shows how function can process instances .

This ability to allow subclass object to be used in any context that expects superclass object is known as the Liskov Substitution Principle , after computer scientist Barbara Liskov .

The term is has special meaning in the context of inheritance .
Suppose we have and derived from .
is the base and is the derived .
Since we can treat an instance of derived as if it were an instance of its base  if we declared object as Dd ; is object we can say is it is , and we also can say is .

The developers of the std : did not begin with blank slate .
The ost ream existed first , and the developers specified the std   of stream in such way so any std :  of stream object would be treated as specific kind of ost ream .
In this section we will examine very simple example that illustrates the mechanics of inheritance in .

Even though the source code for does not explicitly show the definition of method named , it has such method that it inherits from .

Note that inheritiance works in one direction only .
Class inherits method from , but cannot inherit method .
Given the definitions of classes and above , the following code is illegal :

While this private inheritance is useful in rare situations , the majority of objectoriented software design uses public inheritance .
is one of the few objectoriented languages that supports private inheritance .

In design , multiple inheritance is not as common as single inheritance base .

The next section provides simple example that shows how inheritance works .

Inheritance is design tool that allows developers to take an existing and produce new that provides enhanced or different .
The enhanced or new does not come at the expense of existing code ; that is , when using inheritance programmers do not touch any source code in the base .
Also , developers can leverage existing code the base without duplicating it in the derived classes .

We can demonstrate the use of inheritance to enhance the of simple .

Text object wraps std   stri ng object , and , since the string object is private to the Text  clients cannot get to the string object directly .
The clients may see the string via the get method , and can modify the wrapped string only in limited way via the append method .
Notice that the two methods , get and append , are marked vi rtual .
The vi rtual keyword indicates that the designer of this Text intends that classes derived from Text will be able to customize the of their get and append methods .

Observe that the declarations of the get and append methods include the override specifier .
This keyword indicates that the FancyText overrides , or provides custom for , the methods declared vi rtual in its base .

, const .

The body of the constructor is empty , so all initialization happens in the constructor initialization list .
We want to assign the first parameter , to the inherited member text , but text is private in the base .
This means the FancyText constructor cannot initialize it directly .
Since the constructor of its base knows what to do with this parameter , the first expression in the constructor initialization list part between the  and the .

This base initialization expression must be the first thing in the initialization list because requires that the of an object inherited from its base must be initialized before any new by the derived are initialized .
The next three expressions in the initialization list :

The body of the constructor is empty as no other initialization work is necessary .

The FancyText alters the way get works .
We say the FancyText overrides its herited get method .
The keyword over ri de emphasizes the fact that the code in the get method in FancyText intends to do something differently from the code in get method .
In this case the FancyText :  get method builds string result by concatenating three other strings : the first string is front bracketing string , the second is the wrapped string , and the third string is trailing bracketing string .

Notice that the second string is obtained with the expression .

The member specifier vate means sible outside of the  period .
Derived classes have no special privilege in this regard .
In order to perform the delegation we must use Text   get and not simply get ; the unqualified expression get is equivalent to thi , which calls FancyText :
This means invoking the unqualified get within the definition of FancyT ext   get is recursive call , which is not what we want .

method declared vi rtual in base is automatically virtual in its derived classes .

The override keyword was added to the language in .
Prior to when method in derived had the same signature as virtual method in its base  the method implicitly overrode its base version .
The problem was that programmer could intend to override method in the derived but get the signature wrong .
The resulting method overloaded the original method rather than overriding it .
If programmer uses the ove de specifier and uses signature that does not match the base version , the compiler will report an error .
The over ri de specifier provides way for programmers to explicitly communicate their intentions .

For backwards compatibility the override keyword is optional .
Its presence enables the compiler to verify that the method is actually overriding avi rtual method in the base .
Without it , the programmer must take care to faithfully reproduce the signature of the method to override .

The over ri de keyword is keyword , meaning it is keyword .

The FancyText :  append method overrides the inherited append method by inserting special separator string in between the existing wrapped text string and the string to append .
Like FancyText : the FancyText :  append method delegates the actual concatenation operation to its base by ing Text :  append .
Again , this is because code within the FancyText cannot directly influence its text field .

The FixedText , declared and defined in Listing and Listing .

The FixedText is somewhat simpler than the FancyText .
It adds no fields and does not override the get method .
Its constructor accepts no parameters because clients are not permitted to mine the contents of the wrapped text field is always the word FIXED .
It inherits the text field and get method from the Text .

Notice that the assignment ; copied into object only the fields that FancyText objects have in common with Text objects ; that is , the text field .
Since is plain Text object , it does not have the racket , and connector fields capable of storing the additional data contained in FancyText object .
This cess of losing derived class data when assigning to base class instance is known as object slicing .
The parts that will not fit into the base class instance are " off .
Figure illustrates object slicing .

Figure shows how such an attempted assignment would be meaningless because the base class instance has missing information needed by the derived class instance .
Failure to properly assign all .

Fi xedText class instances do not contain any additional data that plain Text instances do not .

It always is legal to assign derived class instance to variable of base type .

This is because derived class instance is specific kind of base class instance .

In contrast , it is not legal to assign base class instance to variable of derived type .
This is because the is relationship is only one directional , from derived class to its base class .

The Text , FancyText , and FixedText classes form small class hierarchy .
We can represent the relationships in this class hierarchy in graphical form using the Unified Modeling Language .

Figure shows the UML diagram for our simple Text class hierarchy .

rectangle represents class .
Text , the base class , appears at the top of the Figure The two derived classes appear below Text .
The inheritance arrow points from the derived classes to the base class .
The arrow represents the is relationship which flows upward .
This visual layout and level of detail provided by the UML diagram more succinctly communicates the relationships amongst the classes than does the source code .

The UML is large , complex graphical language that may be used to model many facets of the software development process .
More information about the UML is available at http 

What is the nature of the machine code generated by the expression .
The compiler translates this expression into the machine language instmction that causes the execution to jump to another part of the compiled code .
Where does the execution jump to .
The variable declared type is ext , the execution jumps to the compiled Text :  method the address of is passed as the implicit this parameter to the method so the compiled code can access text .

When the compiler can determine which method to execute based on the declared type of an object , the process is known as static binding or early binding .
Static binding is used in all cases for methods and in the cases we have seen so far for virtual methods .

The situation is different if we use pointers to objects instead of the objects themselves .

The variable is Text object , so the assignment ; makes perfect sense .
The variable has declared type of FancyText , but FancyText object is Text object , so the assignment .

Even though declared type is to Text object " not to FancyText " the expression calls FancyText :   not Text :
How does the compiler determine which method to call in this case .
The answer may be surprising : The compiler does not determine which method to call .

In the case of virtual method invoked via pointer , the running program , not the compiler , determines exactly which code to execute .
The process is known as dynamic binding or late binding .
Static binding is relatively easy to understand : the method to execute depends on the declared type of the variable upon which the method is invoked .
The compiler keeps track of the declared type of every variable , so the choice is easy .
Inheritance and the is relationship make things more complicated .
In the example above , declared type is to " If the compiler were given the authority to select the method to call for the expression , its only choice would be Text :   however , actually is pointing to FancyText object .
How does the executing program know which code to execute .

We know that every instance of class contains its own copy of the fields declared within the class .

In reality , if class contains at least one virtual method , all instances of that class will contain one extra " field , pointer to an array of virtual method pointers .
This array of method pointers commonly is called the vtable .
One vtable exists for each class , but all instances of that class must store pointer to that shared vtable .
The compiler assigns an index to each virtual method in class .
In our example , the Text class contains two virtual methods , so the index of might be , and the index of append might be .

Figure illustrates typical scenario with vtables .
In this case the compiler translates the expression into the machine language equivalent of , which invokes the correct method for the instance pointed to by .
Similarly for the append method , internally becomes .
If points to Text instance , points to the vtable array for the Text class .
If points instead to FancyText instance , points to the vtable array of the FancyT ext class .
In either case the correct method is selected during the execution .

Such extended analysis capabilities would further complicate the compiler , and compilers are ready very complicated pieces of software .
Attempting to add this ability would prove futile anyway cause the compiler cannot in general always determine which method to invoke .
To see why , consider the following code .

Figure Several objects and their associated vtables .
You will not find any evidence in the source code of the dashed pointers and vtables shown in this diagram .
When virtual methods are involved the compiler produces executable code that builds these hidden data structures behind the scenes .
When client calls virtual method via pointer to an object , the environment locates the exact method to execute by following the vtable pointer stored in the object itself .
Observe that since the class does not override the inherited method , its vtable references the same code as that of vtable .

This code generates pseudorandom number at run time .
If it generates an even number , it directs to point to plain object ; otherwise , it directs to point to object .
Which method will this code call , ext :  or FancyT ext :
Since the code generates the pseudorandom number at run time , the compiler is powerless to determine the exact type of the object to which points ; thus , the compiler cannot determine which method to call .
The compiler can , however , generate code that jumps to the method found at the address stored in associated vtable at the index corresponding to the method .

Listing demonstrates that the vtable pointer does occupy space within an object .

NoVTable object requires four bytes for its integer field , but HasVTable object occupies eight bytes for its integer field and four bytes for its secret vtable pointer .

Dynamic binding enables powerful technique in programming called polymorphism .

We know from is collection of homogeneous elements .
Homogeneous means the elements in must all be of the same type .
Homogeneity takes on deeper meaning when inheritance and the is relationship is involved .
In Listing the declared type of the texts is std  
With inheritance , not only can the texts hold pointers to simple objects , it also simultaneously can hold pointers to and objects .

As we can see , the expression in the mai function is polymorphic ; the actual method       or   on the exact type of the object to which points .
The append method is polymorphic as well .
As assumes the value of each element in the during the execution , the exact type of object that points to varies .
Even though all the elements of the texts are pointers to objects , only one of the elements points to pure object ; the rest of the elements point to or Fi xedText objects .

Why must we use pointers to objects rather than the objects themselves to achieve polymorphism .

Remember that pointer stores memory address Section .
All pointers , no matter what type they point to , are all the same bytes on systems and bytes on .

If we made texts of objects rather than of pointers to objects , when we assign FancyT ext object to an element in the texts  the assignment would slice the extra fields in the object .
Pointer assignment avoids the slicing problem .

The main reason for using pointers is that uses static binding for all methods and invoked on behalf of an object ; the compiler chooses the method based on the declared type of the object .
In contrast , uses dynamic binding for virtual method calls made via pointers to objects ; the exact type of the object determines the method selection .

Derived classes override the behavior of the inherited virtual methods as needed .

From the perspective , however , the two programs are very different .
Listing packages within single class all the functionality for the three different classes in Listing .

This code differentiates among text objects with the TextType custom enumeration type .
Note that each of the methods that were polymorphic in our earlier example now use conditional logic swi tch to execute the code appropriate for actual kind of object we wish to model .

This approach that avoids inheritance and polymorphism has several different issues :
Every object carries the burdens of every possible of object .
plain object holds the left bracket , right bracket and separator strings that fancy objects require .
The amount of memory string occupies depends on its length of characters it , but even an empty std  st ng object requires some memory .
An application managing many mainly plain objects could be consuming much more memory than it otherwise needs .

With inheritance , developer can introduce new type without touching the code in existing classes .
programmer wishing to introduce new of object in this example that avoids inheritance must make considerable changes to the code , involving the .

This is not small point .
Modifying existing can introduce errors .
This can cause existing applications that depend on the Text to fail .
With inheritance , programmers add new without touching existing .
applications will continue to function as usual because they do not use the new introduced via inheritance .

Without inheritance we need access to the original source in order to augment the data type .
If it is part of library , we cannot make the necessary modifications .
With inheritance , however , we can derive new from an existing even if we do not have access to , or control over , the source of its implementation .

To illustrate these issues , suppose we wish to add new of object that bounds the length of the Listing .

TextType type ;  connector ; Maximum number of characters in the .

We extended the enumeration to TextType :
We added one more field to .

Note that even though our new objects require no special method , we still must add the case label to match the TextType :  Bounded type .
Failure to add this case label would mean every object would respond with the TYPE " string .
We definitely must add new to the append to ensure the concatenation operation does not make objects too long .

Even if the and append methods were known to work flawlessly before we introduced this new of object , they now are suspect .
Our act of modifying them could have introduced subtle bug , and so they must be thoroughly retested .

Our is relatively small , containing only two methods .

Now suppose we do not have access the source within Listing .

pure object will have string field , period .
Fixed object as well contains only single string field .
FancyText object will contain four string fields , and each object will maintain string and integer value .
Each particular type of object will contain only the data it requires , not all the data that may be required for any possible kind of object .

This derived leaves the original code in the base untouched .
We can do nothing in our code to damage the  FancyText , or Fi xedText classes .

We can compile the code within Listing .
All we need is the header file Listing , that specifies the interface of the .
This header must be available to any clients that wish to use object , but the source code for the implementation of the is not needed to compile client code that uses objects .
The linker would need the compiled Listing in order to link and produce an executable program , but at no point in the build process is the source code in Listing necessary if its compiled code is available .

The inheritance with polymorphism approach is more modular ; that is , if our code does not work or is not as efficient as it could be , we or someone else easily can supply different version to compile and link into an application .
This modularity enables multiple programmers to work independently implementing separate classes without interfering with each other .

Suppose library provides named Message that is similar to the classes in our .

In addition to revealing its contained  each time client calls Message method the .

The Message provides method named that returns the number .

My message My message My message We cannot modify the Message , either because we do not have the source code to this library , or .

Message or how it works .

What if would like to maintain collection of and objects , storing them all in single vector .

All of the elements in particular vector must all be of the same type .
The is not part of the hierarchy , so no is relationship exists between the two classes .
Let us experiment with two possible solutions to this problem .

Make copy of object .
We could try to simply copy the contents of object .

Unfortunately as you may have noticed , the code calls only once , when creating the txt object from the object .
It is this single call that makes the access count become one .
The subsequent calls to get are on object , not object .
This means we really do not have object in our vector , so none of the objects in our vector can take advantage of the services that object provides .

Use inheritance and polymorphism to encapsulate objects within objects .

MessageText : public .

Instances of this MessageText wrap pointer to object .
The constructor does not call the wrapped method , so making MessageText object from ject does not artificially elevate the access count for the object .
Further , any call to MessageT ext get method actually calls the method of the object it is managing .
The following .

This proves that we really did sneak object into our vector of objects .

This technique of adapting the interface of one to that of another has name : the adapter design pattern .
The adapter design pattern is useful when you have with properties similar to another but with incompatible interfaces .
You can use this technique of inheritance and polymorphism to derive new with the desired interface Suppose you have and that describe objects with similar ality but different interfaces , and you need to treat object as if it were an object .
You may be able to use the adapter design pattern as follows :
Derive new  from .

Figure illustrates packing some shapes into container .

We thus want to determine the minimum area of the container that can hold given collection of parts .

application could be computing the size of the smallest circuit board that can hold collection of electronic components .
Our program will be much simpler and give us only rough approximation ; it does not take into account the geometry and orientation of the individual shapes but merely computes the total area of the components .
The actual answer generally will be larger than the result computed by our program .

An interesting problem arises if method in derived needs to use an inherited variable .
If the variable is declared pri vate in the base  derived method cannot access it .
The pri vate specifier means available outside the  We know it is unwise in general to make instance variables public , since that breaks encapsulation .
Since encapsulation is desirable property , provides third level of access protection within protected .
protected member , whether it be data or method , is inaccessible to all code outside the  except for code within derived .
The use of protected is illustrated in the shapes code .

The to zero " of the two virtual methods in the Shape make them special ; they are called pure virtual methods or pure virtual functions .
This special syntax signifies that these methods have no implementations .
It is not possible to provide body for these methods .
that contains at least one pure virtual method is an abstract .
It is not possible to create an instance of an abstract .
The compiler enforces this restriction ; the following .

An abstract represents an abstract concept .
Shape is an abstract concept .
We can have circles , rectangles , and lots of other kinds of shapes , but can we have something that is shape " without being particular kind of shape .
Even though we cannot create instances of abstract classes , abstract classes are useful for organizing hierarchy .

Note the appearance of the protected access specifier .
The methods in any derived directly or indirectly from Rectangle will be able to access the length and wi dth fields .
These fields will be inaccessible to code outside these classes .
Listing provides the implementation of methods .

Circle .

The DrawableRectangle :  draw method needs access to the fields length and wi dth to be able to draw the rectangle .
It is important to remember that every DrawableRectangle object contains these fields because it inherits them from Rectangle ; however , if the length and wi dth fields were declared private instead of protected in Rectangle , DrawableRectangle :  raw would not be able to access these fields .

supports three levels of protection for its .

Protected members are inaccessible to other classes .

In sum , private means not accessible outside the  period .
Public means open .

The ordering imposed by selection sort function can be varied by using custom comparison tions .

The object used to determine the ordering collects data about the number of comparisons and element interchanges the sort function performs .

Listing provides slight variation of Listing .

Listing provides the client code that tests the new class .

The design of this new class is .

Since its counter fields are private , only methods in the class itself can access aComparer data .

The two virtual methods , compa mpl and .
Derived classes , however , can see them and override them .
The suffix stands for " so compare .

The public compare and swap methods both delegate part of their work to the protected compa mpl and methods .

The compare and swap methods are not declared vi rtual , so derived classes cannot override them .

The compare and swap methods manage the compa and counter fields .

Since derived classes cannot see these fields , there is nothing that designer of derived class can do when overriding compa mpl or swap .

The and swaps methods that report the results to the client are , so derived classes may not override their behavior .

Observe that the designer of the class allows the nature of the and swaps in derived classes to be flexible , but it is rigid on the enforcement of how the accounting is performed and reported .

The proper use of protected and pri vate specifiers in base class as shown in affords class designers great deal of control over exactly what derived class designers can do .
Derived classes may adapt some behaviors , but other behaviors are .

What kind of customization would programmer want to do to the class beyond .

The two overridden methods , and , write text to the log file .

Comparing to Comparing to Comparing to Comparing to Comparing to Comparing to Swapping and Comparing to Comparing to Comparing to Comparing to Comparing to Swapping and Comparing to Comparing to Comparing to Comparing to Swapping and Comparing to Comparing to Comparing to Swapping and Comparing to Comparing to Comparing to If during development the selection sort function has problem , the programmer can review the contents of the log file to examine how the sort progresses and perhaps determine where the problem lies .

The design of the Compa class provides overall structure that allows inheriting classes to fine tune the details without disturbing the overarching framework .
Inheritance and polymorphism allow us to add functionality to an existing code base .
Virtual methods provide extension points by which derived classes can add custom behavior .

CHAPTER UNDER CONSTRUCTION The programming language provides many options to programmers when it comes to managing the memory used by an executing program .
This chapter explores some of these frequently used options and introduces modem techniques aimed at reducing the memory management problems that have plagued projects in the past .

modern operating system reserves section of memory for an executing program .

The code section of memory holds the compiled executable instructions .

The data section of memory contains global variables Section and persistent local variables c locals , see Section .
The variables in the data section exist for the life of the executing program , but , unless they are constants Section  the executing program may freely change their values .
Even though the values stored in the variables found in the data segment may change during the execution , the size of the data segment does not change while the program executes .
This is because the source code precisely defines the number of global stati c local variables .
The compiler can compute the exact size of the data segment .

The heap is where an executing program obtains dynamic memory .
The new gets its memory from the heap , delete returns previously allocated memory back to the heap .
The size of the heap grows shrinks during the execution as the program allocates deallocates dynamic memory using new delete .

The stack is where local variables function parameters live .
Space for local variables parameters appears when function is called disappears when the function returns .
The size of the stack grows shrinks during the execution as various functions execute .

Operating systems generally limit the size of the stack .
Deep recursion can consume considerable amount of stack space .
An improperly written recursive function , for example one that omits the base case thus exhibits " recursion , will consume all the space available on the stack .
Such situation is known as stack overflow .
Modern operating systems will terminate process that consumes all of its stack space , but on some embedded systems this stack overflow may go undetected .
Heap space typically is much more plentiful , operating systems can use virtual memory to provide executing program more space than is available in real memory .
The extra space for virtual memory comes from disk drive , the operating system shuttles data from disk to real memory as needed by the executing program .
Programs that use lot of virtual memory run much slower than programs that use little virtual memory .
Virtual memory is not unlimited , however , so program with memory leaks eventually can run out of memory .

Because of the way function method calls their subsequent returns work , the stack grows shrinks in very regular fashion .
It expands during function call to make room for the executing local variables parameters it expands even more if that function calls other , when the function returns , the stack contracts back to the original size it had before the function invocation .

Variables are removed from the stack in the reverse order of their creation on the stack .
The stack always consists of one contiguous chunk of memory with no areas of unused space within that chunk .

The heap grows shrinks as the program executes delete , but its expansion traction is not regular .
One function may allocate an object or dynamic array with  different function may much later in the execution deallocate the object or array with delete .
An cuting program may delete dynamically allocated memory in very different order from its allocation .

This means that memory allocated on the heap is not contiguous ; that is , space for deallocated objects can be interspersed with space for allocated objects .
The the available memory on the heap thus can become fragmented during the execution .

Global variables static local variables in the data segment live for the life of the executing program .
The environment initializes globals before main begins executing cleans them up when mai returns .
The environment initializes static locals during the or first invocation .
local variables on the stack exist only when function is executing .
If program calls returns from the same function times , that local variables appear disappear times .
An executing program can create dynamic memory as needed , hold onto it as long as necessary , finally release it when it is no longer needed .

The quantity of global data is fixed when the program begins executing , stack data is not persistent for the life of the executing program .
This means an executing program that must manage varying amount of data for an arbitrary amount of time must use the heap as source of memory for that data .
The time environment automatically manages global local memory .
Unfortunately , programmers must write code that manually manages heap data .
The problem is this : Manual memory management in all but very simple systems turns out to be difficult task .
Development of large software systems with in the early days often was frustrating experience .

Memory management issues with delete frequently are the source of difficult to find fix logic errors .
Programmers must adhere strictly to the following .

Every call to have an associated call to delete when the allocated memory is no longer needed .
It sounds simple enough , but it is not always clear when delete be used .

Before the call to calc , variable does not exist .

Figure shows how memory is stranded when local pointers go out of scope at the end of execution .

In the calc function is local variable .
As such , lives on the stack .
When particular call calc completes , the clean up code automatically releases the space help by the variable This is because all functions automatically manage the memory for their parameters local variables .
The problem is is assigned via point memory allocated from the heap , not the stack .
Function executions manage the stack memory only .
When the execution completes , is gone , the memory which pointed is not deallocated automatically .
Worse yet , the heap memory formerly referenced by the local variable now is unreachable because no other variables that remain viable know anything about it .

correctly written calc function has three options in this .

Option is the easiest solution .
The calc function needs dynamically allocated array , creates it , uses it , then deallocates it before returning .
Within this single function definition we can see later its corresponding delete perfect matched pair .
Unfortunately , this is not common case .
If calc needs local working space , it is best handled on the stack through local variables .
That way memory clean up is automatic .

Option possible only if callers invoke the calc function exactly once  additionally in the case of global pointer , invoke calc before attempting use the global pointer .

the more common occurrence .
The heap enables an executing program add extra data at run time that persists across function calls .
In theory the process simple :

The problem here we cannot see the with the delete .
The hidden in calc , the caller must exercise delete .

The delete operator never be used free up memory that was not allocated by .

Attempting delete memory not allocated with in undefined behavior represents logic error .

Such pointers are called aliases .
The following code .

Multiple deletes of the same memory in undefined behavior represents logic error .

Memory previously deallocated via delete never be accessed .
Attempting access .

For efficiency reasons the delete operator generally marks heap space as " without modifying the contents of that memory .
Careless mers can accidentally use the memory of deleted pointer obliviously as if it were still live problem manifests itself when the freed up memory eventually gets reallocated elsewhere via call result that programs seem " for while mysteriously fail at dictable times .
Debugging such situations can be very difficult .

Aliasing problem because of our concept of variables .
When we have two variables with different names it natural assume they represent two different objects .
ers references introduce the possibility of aliasing ; they use reference semantics .
Reference semantics enable useful techniques such as the traversal of dynamic data structures like linked lists , but reasoning about the identity of objects using reference semantics requires extra caution .

It seems simple enough make sure every exactly one corresponding delete , but in practice it can be very difficult determine exactly when use delete .
Suppose , for example , you obtain .

Entering main Creating node Creating node Creating node Creating node Creating node Creating node Creating node Destroying node Destroying node Destroying node .

Destroying node Destroying node Destroying node Destroying node Destroying node Destroying node Destroying node Leaving main Observe widgets , being destroyed twice .
On some systems the program crashes before printing Leaving main .
Double deletion classified as undefined behavior , it represents bug in our program .

Before returning from process , how can you traverse the vector releasing the dynamically allocated memory ensuring that you do not delete the same object more than once .
Even if you are careful account for each allocation of objects of particular value , you really do not know if the program elsewhere earlier called stored the result in global variable that outlives this call to process .
You would need to implement within your code complex global accounting infrastructure that keeps track of all memory allocations .

Node contains an integer Node , but this contained Node field itself would contain an integer Node , the nested containment would go on forever .
Such structure understandably illegal in , the compiler will issue an error .
You are not allowed to have class or struct field of the same type within the class or struct being defined .

Another object definition looks similar , but it is legal .

pointer is simply memory address under the hood , all pointer variables are the same size regardless of their declared type .

This ability of object to refer to an object like itself is not merely an interesting curiosity ; it practical applications .
Suppose we wish to implement sequence structure like vector .
We can use the structure defined above to build of Node objects linked together via pointers .

Listing builds small linked .

In Figure the line in the next field of node represents the null pointer .

Listing augments the simple Node struct by adding constructor program uses no dynamic memory calls to ; is possible only because we know the nodes that are in the ahead of time .
This enables to visit nodes nl , finally will point to , the last node in the list .
The next field of is nullptr , so when the loop reassigns to next field , will be nullptr , the loop will terminate .

The value nullptr in Boolean context is considered false , so we can simplify the Boolean pression .

The following statement :  is simpler , but why stop there .
Since we know the nodes and their values ahead of time , the following .

It makes sense to use linked list only when its elements are unknown ahead of time .
We then can dynamically allocate space for the elements as they become available .

Armed with our knowledge of classes , encapsulation , and methods , we can build , dynamic linked list type .
The code found in Listing , Listing , and Listing demonstrates the power of linked lists .
Listing is the header file for simple integer linked list class .

The struct is declared within the IntLi stl class .
We say that is nested struct .
Since the declaration of appears in the private section oflntListl , is type known only to code within the IntLi stl class .
Because its declaration is nested within the IntLi stl class , the complete name of the type is IntLi stl :
Recall that struct is equivalent to class , except the default access to its members is public .
We can define nested class in same manner as we defined our nested struct .

Notice that the IntLi stl class has several private methods in addition to its public methods .
Code outside the class cannot execute these private methods directly .
These private methods are helper methods that several of the public methods invoke to accomplish their tasks .
We say that public method delegates the work to its private helper methods .
Why is delegation necessary here .
The private methods use recursion that requires parameter of type IntListl :  which is unknown outside the IntLi stl class .
client is therefore unable to use the private methods directly , even it they were made public .
The public methods do not expose to the client any details about the implementation ; specifically they keep the IntListl :  type and the head and tai instance variables hidden from clients .

Observe that the overloaded length methods private and and print method of the IntListl class are declared const .
Neither printing list nor requesting its length should modify an IntListl object .
Clients can , therefore , use the print and length methods with constant IntListl object .
An attempt to use insert or clear on constant IntListl object will yield compiler error .
The error here makes sense because nsert definitely will modify list object , and clear potentially will modify list object say potentially here because clear will not modify an empty .

The clear method is responsible for deallocating the list nodes , effectively cleaning up the memory held by the list .

Listing provides some sample client code that exercises linked list .

Observe that the client code does not use pointers at all .
All the pointer manipulations are hidden within the IntLi stl class .
Pointer programming can be tricky , and it is easy to introduce subtle , hard to find bugs ; thus , encapsulation once again results in easier and more robust application development .
The Node struct itself is private within IntLi stl , out of the reach of programmers who use these linked lists .

As shown in the IntList : method , pointer variable by itself can be used as condition within conditional statement or loop .
null pointer is interpreted as false , and any pointer is true .
This means if is pointer , the statement if .

Most programmers use the shorter syntax .

In order to better understand how the recursive methods work , think about the structure of Node object with this interpretation : Node object holds data item and pointer to rest of the list that follows .

pointer to Node is either null or .
null pointer represents the empty list .
pointer represents list consisting of two parts : the first element in the list and the rest of the list .
If the next field of Node object is null , the rest of the list is empty .

Armed with this view of lists we can now examine the behavior of the recursive linked list methods in more .

The length of the empty list is zero .
The length of list is at least one because list contains at least one element .

Notice , however , that it makes the recursive call deleting the nodes in the of the list before it deletes the current node .
An attempt to access data via pointer after using delete to deallocate that data results in undefined behavior ; therefore , it is logic error to attempt to do so .
This means the code in dispose should not be written as .

While the recursive methods provided good review of recursion , recursion is not strictly necessary for these functions .
We could instead express the public and clear functions as shown in the following code snippets : Iterative versions of and clear .

As mentioned in Section given the same basic algorithm implemented recursively or iteratively , the iterative version will be more efficient .
This is because each recursive call requires additional on the stack to store fresh local variables and parameters .
Not only does recursive method or function require more memory , it takes more time to complete because the executing program must perform extra work to set up the new needed by recursive invocation and restore the context when recursive invocation returns .
If we build very large linked list , call to our recursive or clear method could consume considerable on the stack and impose significant performance overhead .
For future versions of our linked list code we will use the iterative version of the clear method .

To optimize the method , we will choose different route .
If you have an application that ages rather large lists and makes frequent calls to the method , even iteration can take considerable time .
We can add an integer variable to the IntListl class that keeps track of the number of elements in the list .
This new variable affects the of the class members as .

The constructor would initialize this variable to zero .

The insert method would increment this variable by one each time the client adds an element to the list .

The clear method would reset this variable to zero .

The time spent looping over all the elements in list counting them can be considerable for large .

The IntLi stl class code as defined in Listing and Listing is useful for introducing the concepts of implementing linked data structures .
Our IntLi stl class is , however , fundamentally different from all the earlier custom classes we examined in Section ' With the tions to and clea mentioned above , it may appear to be ready for clients to use as an alternative to std   vector , but it has some servere limitations and pitfalls that make it practically useless for most applications .
Section exposes its weaknesses and introduces the modifications required to make it viable , class worthy for use in any applications requiring dynamic linked list data structure .

The IntLi stl :  nsert method dynamically allocates ory for list elements from the heap .
It is essential that the programmer intentionally call clear when finished with linked list object .
Consider the following function .

The variable st is local to function .
When function finishes executing the variable st goes out of scope .
At this point the on the stack allocated for the local IntLi stl variable named st is reclaimed ; however , the for the elements remains .
The only access the program could have to that memory is via st .
This presents classic memory leak .

Observe that none of the classes we have designed thus far except for IntLi stl have this potential problem .

Fortunately provides way for class designers to specify actions that must occur at the end of an lifetime .
Analogous to constructor that executes code at the beginning of an existence , destructor is special method that executes immediately before an object ceases to exist .
destructor has the same name as its class , with tilde prefix .
destructor accepts no arguments .
Listing adds destmctor to Listing and also adds the previously suggested optimizations of the and clear methods .

When do constructors and destructors execute .
local or global object definition calls the class structor to properly initialize the object ; for example , seq ; defines the object seq .
This definition invokes the IntLi constructor to set both seq .
If seq is local variable , its destructor executes at the end of the execution .
If seq is global , its destructor executes when the program finishes .

pointer is not an object ; it points to an object .
This means the definition ; does not invoke IntLi constructor .
Given this definition of  the statement new ; actually creates an IntLi object and therefore calls the IntLi constructor for the newly created object .
The object to which points is not destroyed until the programmer uses delete , as in .

Here we have the Node constructor identify which element it is creating by printing its data field and the address of where it resides in memory .
is very strict about conversions between pointer and is easy to do by mistake and almost never simple stati will not work here .
The rei removes the safeguard and treats the bits that make up the pointer as ui , an integer type guaranteed to represent the same range of values as pointer .

The destructor indicates when Node object is destroyed .
Listing is same program as Listing , except it uses an IntLi object instead of an IntLi object .

When this function returns , st no longer exists , so we no longer can access the nodes it allocated .
If we leave IntLi as is .
Listing prints the .

This shows that the IntLi destructor properly deallocates the dynamic memory held by the linked list object .
The Node constructor executes when declaring Node object or when using new create Node object assign Node pointer .
The nsert method uses new create Node object , so this invokes the constructor .
The Node destructor executes when an object goes out of scope or when delete deallocates object .
The IntLi destructor uses delete free up each node in the list .

When goes out of scope at the end of function execution , the stack variable goes away , but since it is pointer , not an object , no destructor code executes .
The client must explicitly free up memory with .

As you can see , dynamically allocating the list itself from the nodes that store its brings us back the situation we were in before : We must remember do something when we are finished with the .
In this case we must remember delete the list itself .
destructor cannot help us here .
This is good example that demonstrates that while dynamic memory enables us do many interesting things , it is best avoid it unless absolutely necessary achieve the behavior we need .

destructor performs the reverse role of constructor : constructor ensures that new begins its life in state , while destructor is responsible for performing actions required when an life is over .
destructor is unnecessary for most classes .
For linked list  however , destructor is essential because the nodes that comprise the linked list are dynamically allocated with the new .

Any memory allocated with new corresponding call delete when the memory no longer will be used .
The clear method will take care of the memory deallocation , but , without destructor , programmer must remember intentionally call clear when finished with linked list .
The destructor relieves the programmer of this responsibility and removes the possibility of memory leak .
The destructor simply calls clea clean up the resources held by the list .

Listing demonstrates that executing program destroys local and global .

Entering main Entering Creating widget Creating widget .

Creating widget Leaving Destroying widget Destroying widget .

Destroying widget Entering Creating widget Creating widget .

Destroying widget Leaving Leaving main Destroying widget .

Adding destructor the IntListl class is significant step in correcting its deficiencies , but its .

During this particular run the program ran to completion ; however , sometimes the program will crash before printing All done .
On some systems the program crashes before printing the last three lines of output .

During this run of Listing the output shows that the program never destroys the nodes containing , and .
Further , the program destroys the nodes containing and twice .
We can see the program deletes the same memory twice by comparing the memory addresses in parentheses .

This undefined behavior of double deletion is what causes the program to crash at times .

The problem is in this .

With no additional guidance from the programmer , the assignment for type simply copies the bits in memory that make up the object to right of the assignment operator into the memory reserved for the object on the left side of the assignment operator .
Under Visual executable , for example , an IntLi object occupies bytes of bytes for its head pointerplus four bytes for its tail pointerplus four bytes for ten .
The actual size of an IntLi object will vary from system to system and will be larger on computers .
You can verify the actual size object on your system by adding the following statement to Listing .

This produces three undesirable .

This means any actions to modify the list managed by will modify identically .
The assignment operator does not make copy of the contents of .
This means that our linked list objects behave differently than std   vector objects with respect to assignment ; assigning one vector to another makes copy of the contained elements .
Clients will expect our linked list objects to behave similarly .
This aliasing problem , however , is the least of our problems .

Simply redirecting head and tai pointers to list renders the nodes in original list unreachable from any variables within the program .
The program has no way to delete the nodes in original list .
This constitutes memory leak .

Both and are objects local to the mai function .
Based on their declaration order , constructor executes before constructor .
This means when mai is finished executing destructor will execute before destructor , as object destruction occurs in the reverse order of object construction for local objects .
The destructor for will free up all the nodes in list .
Next , destructor will attempt to delete the memory occupied by its list .
Unfortunately this involves referencing and deleting dynamic memory previously deleted by .
Any attempts to delete already deleted memory results in undefined behavior that usually results in memory corruption .
That is why Listing crashes during some runs .

Fortunately provides way for programmers to customize how assignment works for custom type .

Before we tackle assignment itself , we must distinguish between initialization and assignment .
Consider the following statement : int ; This statement defines and initializes the variable to .
This statement is fundamentally different from the following two statements : int  For simple types like integers , numbers , and characters , this pair of statements on the surface behave identically to the single statement above .
In fact , these two statements involve declaration followed by assignment .
Initialization and assignment are not the same thing .
Recall from Section the alternate syntax for initialization : int .

gives programmers full control over initialization and assignment of custom types .
We have seen how we can specify initialization via constructor .
In order to legitimize our linked list class and make it safe for clients to use , we need to provide an additional constructor , called the copy constructor , and define an assignment operator for the class .

Node ; Points to the first item in the list .

The expression in the constructor initialization list following the colon is calling the overloaded version of the constructor that accepts no arguments .
This is known as constructor delegation .

The constructor simply initializes head and tail to nullptr .
We could have done the same thing here without calling the other constructor , but , in general , delegation is good idea .
Delegation can avoid code duplication , and while there currently is not much code in the constructor , we may decide to add more functionality in the future .
By delegating , we can add the extra activity to the constructor without having to add it also to this copy constructor .

Constructors always begin with brand  object .
In the case of our linked list objects , that means our constructor does not have to worry about cleaning up any preexisting list of nodes .

All our copy constructor needs to do is ensure that head and tai instance variables initially are null constructor delegation takes care of and then visit each node in the other list , inserting that data value into its own list as it goes .

Next we will consider assignment .
Suppose and are two linked list objects .

This means the assignment in the course of its operation must deallocate the original list of nodes , if any , managed by the list .
Failure to do so would introduce memory leak .
Also , the assignment must make copy of all the values in the list to avoid aliasing .

There are various ways we can implement the assignment to ensure it works correctly , but since assignment of this nature is such common operation , programmers have developed standard idiom that guarantees the correctness of assignment .
Best practices dictates that we implement our assignment as process .
This entails making local temporary copy of the list and swapping the list of nodes from the temporary list with list of nodes from the list .
Note that swapping the list of nodes simply requires swapping the head and tai pointers between the two objects .
This process depends on correctly implemented copy constructor and correctly implemented destructor .

Missing is any calls to delete to free up any preexisting list nodes in the list .

How does this assignment magically meet our requirements for correct assignment .

Recall that the copy constructor uses loop to traverse the list , making copy of each node in that list .
This solves the aliasing issue and explains how this assignment does actually visit every node in list .

This means the list object now holds the copy of the assi rom list , and the list object holds the list originally managed by the list object .

Since it is local variable the list object goes out of scope at the end of the execution .
The temp destructor executes at this time .
This object now holds the original list , so the destructor properly deallocates all the nodes in the assi original list .
The calls to delete to prevent the memory leak are found in the linked list class destructor .

Figure illustrates the process of the assignment .

Our assignment leverages the code already written in the copy constructor and destructor .
Any other implementation of assignment that correctly addresses the aliasing and memory management issues necessarily would duplicate the functionality of either the copy constructor or the destructor .

Note that the : declaration indicates it returns reference to an object , and we see in the last line of :  body that the method tually returns reference to the object that appears on the left side of the assignment during its invocation .
Recall that the thi keyword represents pointer to the object upon which the caller invoked the method this case the list .
If and are list objects , when executing the statement .

This is the typical idiom used when defining for types .

We could instead define the ope rato method to return nothing is , declare its return type to be voi .
Instead we could define the method to return some type of object other than IntLi .
If we do so , however , our IntLi objects will not behavior properly with chained assignment Section .

To illustrate , suppose  and are all properly declared IntLi objects .
If we define the IntLi :  method to return voi , the following statement :

If we use the original definition above of the IntLi :  method that returns ence to the IntLi object on the left side of the assignment , the compiler does not complain and the chained assignment works flawlessly in the same manner as chained assignment involving the numeric types ; that is , after executing the chained assignment statement above , and each will contain exact copies of the elements in .

Figure An annotated output of Listing updated to use our IntLi class .
amine carefully the memory addresses to convince yourself that the implementation of correct copy constructor , assignment  and destructor for the class solved the aliasing , memory leak , and undefined behavior problems .

Creating Creating .

Creating original list Creating Creating .

Creating seq list .

See Figure provides an annotated output of Listing updated to use our IntLi class .

The output demonstrates that assignment now works correctly for our linked list objects .
Correctly implementing the copy constructor , assignment  and destructor for the class solved the aliasing , memory leak , and undefined behavior concerns .

The copy constructor , assignment  and destructor have special relationship in .
These three methods are involved in the Rule of Three .
The Rule of Three is this : If class designer feels the need to add copy constructor , assignment  destructor to class , the class should have all three .

Said another way , it almost always is mistake to have just one or two of these special methods defined for class without including all three .

The Rule of Three is design guideline ; it is not requirement of the language that the compiler enforces .
Consider why the rule exists .
If an object must be guaranteed to perform some action at the end of its existence and failure to do so would result in undesirable consequences as the program continues to execute , the class must contain destructor .
This essential action usually involves some releasing some resource it owns .
If the destructor is responsible for releasing resource , the copy constructor must somehow acquire resource that is in some way related to the resource of an existing .
The assignment must both release an owned resource and acquire resource related to the resource of an existing What if you leave out one of the three .

If you omit the destructor , the default destructor does no resource clean up .
Objects can acquire resources through copy construction and assignment but cannot release them .
Most resources are finite , so lack of an appropriate destructor will limit the number objects available to the executing application .

If you omit the copy constructor , the default copy constructor will copy the bits of the existing into the .
This means the will have the exact resources managed by another .
The destruction of exactly one of the objects will release the resources held by the other .
The then will not have access to the resources it needs to function .

If you omit the assignment  the default assignment will copy the bits of one existing into another existing .
This means the assigned will have the exact resources managed by another .
It also means that the resources the assigned originally held are not reclaimed .

The destruction of exactly one of the objects will release the resources held by the other .
The then will not have access to the resources it needs to function .

In sum , you should have very good reason for designing class that violates the Rule of Three .

The in lvalue stands for left , as can appear all by itself on the left side or right side of the assignment operator .
The expression + is classified as an rvalue , since it can appear only on the right side of the assignment operator but cannot appear on the left side ; for example , the following statement is illegal : +  Illegal .

The term temporary is appropriate , as the program may reuse that same memory for other purposes .

Consider the following variable .

The variable  however , would continue to exist , but it would not be aliasing any valid quantity .

does permit us to make const reference to temporary .
The following code fragment is .

In this case behaves as if it were simply const int .

Everything works as expected because .

The function accepts reference to variable , but the caller is attempting to pass temporary .
Once function begins executing , the memory reserved for the original temporary is invalid , so the compiler rightly does not permit this .

As with the simple declarations we saw above , given function .

While these examples may seem bit esoteric , we are paving the way for more efficient linked list .

Figure annotates the output of Listingi to explain .

Either way , the expression represents the Int Li returned by the st function when passed the actual parameter .
The expression st is an rvalue , temporary , because it cannot appear on the left side of the assignment operator .
Since the Int Li copy constructor accepts const IntLi parameter , it will accept the temporary  but it makes copy of the temporary to send to the copy constructor .

If is wasteful to make copy of this transient .
If the list contained millions of nodes , this additional construction and destruction could be time consuming .

does permit special kind of reference for rvalues known as an rvalue reference .
An rvalue ence enables programmers to alias temporary without making copy .

In the following .

Figure An annotated output of Listing .
Examine carefully the node memory addresses .
The executing program first creates the temporary IntLi returned by .
It the copy constructs the from the temporary and then destroys the temporary .
After printing the linked list , the program finally destroys the my li st .

Calling with reference parameter , result .

Calling with rvalue reference parameter , result The expression twi ce calls the twi ce function with an lvalue , so it calls the first version of twi ce .

The expressions + and are can appear by itself on the left side of the assignment both twi ce + and twi ce invoke the second version of the twi ce function .

These examples with integers we have seen so far help us better understand the mechanics of rvalue references , but , honestly , rvalue references offer little value to the simple types like integers .
The guage designers introduced rvalue references into for the specific purpose of making copy construction and assignment from temporaries more efficient .
Rvalue references are exactly what we need to make our linked list of integers more efficient when dealing with temporary lists .

Listing declares the fifth generation of our integer linked list class .
It contains new constructor overload and adds an assignment operator overload , both of which accept rvalue references .

The additional constructor known as move constructor , and the additional assignment known as the move assignment .
To make the discourse clearer , we will refer to the original assignment as copy assignment .
The compiler can disambiguate between the overloaded methods by virtue of the actual parameters passed by the .

If the caller passes an lvalue , the compiler generates code that invokes the copy constructor or copy assignment .

If the caller passes an rvalue , the compiler generates code that invokes the move constructor or move assignment .

The purpose of move construction to efficiently move the resources held by the temporary into the new being created .
We want to avoid making copy of the temporary .
Similarly , the purpose of move assignment to efficiently move the resources held by the temporary into an existing without creating new .
The copy constructor and copy assignment are designed to make copies .

It safe to " the resources of the temporary because temporary transient and cannot be used later within the program .
Even though temporary objects are transient , they nonetheless are real , nameless objects .
If the class of the temporary has destructor , the destructor will execute when the ephemeral life over .
This means that even though the move constructor and move assignment may move resources into another  they must leave the temporary in state so that the destructor can do its job .

The following implements the move constructor for the IntLi .

This move constructor delegates to the constructor that accepts no arguments .
This initializes the head and tail pointers of this new to nullptr .
Note that this represents an empty , but valid linked list .
The move constructor then exchanges the head and tail pointers of the it creating with those of the temporary .
This effectively moves the list of nodes to this and moves the this empty , but valid , list of nodes to the temporary .
When this copy constructor finishes , the life over .
Since the temporary still contains valid list of nodes , its destructor can execute successfully .
Observe that no where in this copy constructor did we traverse list of nodes copying each element individually .
This means move construction of list with nodes requires no more time than move constructing an empty list .

Note that the parameter to the move constructor not declared const .
If it were declared const , it would not be possible to swap its contents with new being created .

The move assignment similar to the move constructor , except assignment , of course , does not begin with an initially empty .
We must ensure our move assignment does not leak memory from any preexisting list of nodes the may contain .

The implementation of the move constructor for the IntLi class looks very similar to the move .

The only difference the move constructor always will given the empty list to the .
The move assignment exchange the list for the list .
The list could be empty , but in general it will not be empty .
When the move assignment returns , the passed to it will cease to exist .
The destructor then will properly dispose of the original list of nodes .

The st function creates the  this accounts for all statements that begin with Creating .
The move constructor exchanges the list of nodes with the empty list found in the newly created .
At this point contains the original list and the contains the empty list .
The destructor executes but finds no nodes to destroy is .
At the end of the mai function destructor all the nodes in st .

As an aside , note that the compiler can detect that the function creates local but merely returns it to the caller .
The compiler can use return value optimization tion to avoid creating an extra within the function to return to the caller .
Instead , the compiler generates code that enables the st function to create the linked list directly in the ronment of the caller .

The addition of move construction and move assignment brings us to Rule of Five .
The Rule of Five involves copy construction , move construction , destruction , copy assignment , and move assignment .

If programmer defines none of these special methods for class , the compiler automatically will provide its own versions of each of them that work properly for classes that support value semantics ; for example , all the classes in value semantics .
Classes that use value semantics avoid the memory management and aliasing issues we encountered with our linked list classes .

If the programmer defines one or more of copy constructor , destructor , or copy assignment  the compiler will not automatically supply move constructor or move assignment .
This is not problem as far as program correctness is concerned ; move construction and move assignment merely provide an optimization that avoids the unnecessary creation of an extra when constructing or signing from rvalue .
missing move constructor means is copied by the copy constructor , and missing move assignment means is copied by the copy assignment .

The programmer can precisely control which of these special methods the compiler supplies by itly marking these methods with default or delete label .
We will not go into the details here , but merely provide few examples .

; Illegal ; the client must provide an integer If we really want client to be able to create an object both with or without an integer argument , we can overload the constructor our own default or force the compiler to generate one for us using the default label , as shown .

We added destructor but did not supply copy constructor and did not define copy assignment .
How can we justify this decision .

In reality , the struct does not need destructor .
The linked list class will operate flawlessly with inner struct that has no destructor .
No code within the struct allocates any resources .
The outer linked list class is responsible for allocating and deallocating memory resources .
The linked list methods manipulate objects as passive data .
We added the destructor only so we could see exactly when the program destroyed object .
This enabled us to detect memory leaks and multiple deletions and refine our linked list class into robust useful type .
The destructor cleans up no resources nor does anything else that would impact the work the copy constructor or the copy assignment operator would do .
Remember , you should follow the Rule of Three unless you have very good reason not to do so .
In our case , our good reason is our destructor does nothing that would prompt us to write our own copy constructor and copy assignment operator to properly coordinate with destructor .

In order to emphasize our intentional decision to violate the Rule of Three , we can rewrite the Node .

By explicitly defaulting the copy constructor and copy assignment operator , we indicate that we did not omit them by accident .
The inclusion of the destructor prevents the compiler from automatically generating move constructor and move assignment operator .
By declaring these two methods as default , the compiler will generate them for us .

Since our object contains only simple types nt and we can omit all the explicit defaulted methods in the declaration above , nothing will be different .
This is because " an integer merely by copying it .
simple integer has no resources we need to steal from temporary ; simple assignment is all that is needed .
Similarly , pointer may refer to an elaborate object of some sort , but the pointer itself in simply an address .
Copy move construction is the same , copy move assignment is handled same as well .

programmers that manually manage dynamic memory with delete follow style inherited directly from programming language .
Many modern programming languages like Python , Java , manage dynamic memory through technique called garbage collection .
Garbage collection takes care of accounting necessary to avoid multiple deletes memory leaks .
In garbage collected languages programmers need only call equivalent of  garbage collector takes care of freeing up space later when executing program no longer uses object .
Garbage collection works well , but it does add some overhead to an executing program .
This overhead consumes some extra memory can affect efficiency .
strives to be as efficient as possible , so it does not provide an automatic garbage collector .
Garbage collected languages typically allocate all objects on heap , thereby managing objects in uniform manner .
supports objects , as well as objects .
Heap allocation is sightly slower , heap fragmentation can further degrade program performance .
follows mantra you only pay for what you use , meaning programs that do not need heap do not incur cost of using heap .

provides efficiency benefits of language with convenience of garbage collection when desired .
achieves this in various ways .
One way we have seen have been enjoying its benefits for some time .
The std : class manages dynamic array , using delete behind scenes .
Software engineers implemented std   vector carefully to do right thing , ing aliasing , memory leaks , multiple deletions .

Modern makes it possible to write programs that manage dynamic memory using neither delete directly .
Such style uses smart , that is , pointers that " exactly when to deallocate memory they reference .

smart pointers eliminate need for such manual intervention on part of programmer .
smart pointer automatically deletes its associated memory at proper time .
The std   sha type is one example of standard smart pointer .

Suppose we have following Wi dget .

The std :  function eliminates need of .
It uses scenes to allocate necessary memory for object it creates , but programmer does not see .

On other end of lifetime , programmers never call delete when using smart pointers ; smart pointers automatically call delete at proper time .
The use of std   function enables programmers to work with memory without ever using delete directly .
This removes possibility of memory leaks multiple deletions that haunt manual memory management .

In expression std   name inside angle brackets is type of object to create , value in parentheses is argument to pass to that constructor .

The compiler knows that function will return type std :  so there is no need to spell out exact type of on left side .

Once we have defined in one of these ways we can treat it syntactically as if it were raw pointer ; for example : Make point to dynamically created object .

Destroying widget .

The code in testl modifies the id value of the Wi dget object .

It is important to note that is local variable in testl , so the space for std :  itself appears on the stack .
The call to std   red creates via new widget object on the heap .

When goes out of scope at the end of testl ' execution , desructor automatically calls delete to deallocate the widget from the heap .
The usual function return mechanism automatically removes from the stack .

The next few lines of .

In the next few lines of .

The program includes the function simply to demonstrate that std   sha objects can manage the dynamic memory of simple types just as well as fancier types .
The simple nt type does not report its destruction when its memory is freed , but rest assured that the std   object will deallocate its memory correctly .

In the next few lines of .

This is because it is the first invocation of .
The first call initializes the stati c local , hence the construction of std   sha and its associated Widget object .
Since is static local variable it must survive between calls to ; therefore , cannot be deallocated until the program finishes executing .

In the next few lines of .

This means destroys its widget .

In the output of the final test function , we see .

Creating widget Destroying widget Leaving Test The function allocates just one Wi dget object .
It assigns three std   sha objects to the same widget object .
This provides clear justification for the name three pointers share access to the same object .
If and are std   of the same type , the statement .

Regardless of the aliasing , the code within allocates exactly one Widget object and deallocates that same Widget object when the function completes its execution .

The final lines in the .

Destroying widget .

If you analyze the output of Listingj carefully , you will see that every constructor call has an associated destructor call for the same object testl renamed widget to , so compare widget creation address with widget destruction address , and you will see they .
The heap provided all the space for Wi dget objects in Listing , yet we see neither new delete anywhere in the code .

This ability to deallocate its referenced memory at the proper time is what makes std   sha object smart pointer .

Recall Listing that demonstrated the difficulty of managing dynamic memory manually .
Listing converts all the raw pointers of Listing into std   sha rs .
We no longer need to worry about who " the memory of the heap allocated objects ; std   objects manage all those details .

Entering Creatin Creatin Creatin Creatin Creatin Creatin Creatin Leaving Destroying widget Destroying widget Destroying widget Destroying widget Destroying widget Destroying widget Destroying widget .

How does std   smart pointer " when to call delete to free up its object .

Given the following Widget .

The following statement : is the Widget object created above nullptr ; redirects to point to nothing .
At this point no variable references the Wi dget object created earlier .
This means the object effectively is cut off from the remainder of the execution .
This abandoned object is classified as garbage .
The term garbage is technical term used in computer science that refers to ory allocated by an executing program that the program no longer can access .

Reference counting garbage collection works as follows .
All objects dynamically created via the std : constructor or the std   convenience function have an associated reference count .
When the executing program creates new managed by std   it sets the shared pointer reference count to .
After executing the following statement : auto .

Both and share the same and share the same reference count .

If we finally reassign  nullptr ; the reference count of the containing drops to zero .
The std   sha class has custom assignment operator .
The process of assignment alters the reference count for objects managed via these smart pointers .
When an assignment would cause shared reference count for an to come zero , the shared pointer can delete that before attaching to the being assigned .
The assignment would increase the reference count of the being assigned by one .

The std : class has method named that returns the reference count for the current managed by the shared pointer .
Listing exploits this .

Creating Destroying .

Nowhere in the class can we see the delete operators .

The destruction of the first will destroy .

This results in the destruction of the second The destruction of the second destroys its next pointer which leads to the distruction of the third  followed by the fourth  etc .
This cascading process ultimately destroys all the nodes in the list to which points .

If this simple implementation of clea achieves the same result as the more involved clear method in Listing that uses loop , why even consider the more complicated code .
As it turns out , the simpler method has problem with very long lists .
To see how , suppose we have long linked list .
When the clear method sets the std :  to null , no other smart pointers will be pointing to the first .
The smart pointer reassignment in this case calls method behind the scenes to destroy the object to which it points object to which points ; that is , the first in the .
This method does not return until the process is complete , and , for long lists , this process can be quite lengthy .
The destruction of the first requires the destruction of its next pointer ,
This pointer points to the second in the list .
The destruction of this pointer triggers the destruction of the second because no other std :  objects point to it .
This means that before method returns , the chain of events it sets off must invoke the method of which leads to the destruction of the second .
The destruction of the second necessarily must destroy the next smart pointer of the second .
This in turn leads to the destruction of the object to which points is , the third in the .
By this same process , the destruction of the third in the list leads to the destruction of the fourth  and then the fifth  etc .
This cascade of method calls continue until it reaches the last in the list .
Two smart pointers point to the last  the next pointer of the in the list and the tai pointer of the Li nkedLi st object itself .
The destruction of the removes one of the smart pointers but not the other .
This means the method of the cannot destroy the last .
This turns out not to be memory leak , however , as the clear method also sets to nullptr , so eventually the last will be destroyed properly .

Everything appears to work resource management as what is the problem for very long lists .
We left the activity of the LinkedList : method as the destruction of the smart method was destroying the in the list .
The problem is this : The destruction of the first of the list is not complete until the destruction of the second is complete .
The destruction of the second is not complete until the destruction of the third is complete , and so forth .
This means the method destroying the first does not do its job , return , and then clean up the next pointer ; it does not return until the second completes its clean up , which , of course , does not complete until the third clean up is finished , etc .
Theoretically , this chain of function calls eventually returns back to the action that initiated reassignment of to nullptr , and for lists that are not too long , this is the case .
Each method invocation consumes some stack space , and for very long lists this call chain can be so deep so as to overflow the stack , causing the program to crash .
The scenario is similar to recursive function that recurses too deeply .
On one system the program crashed when attempting to destroy linked list containing nodes .

The version of clear in Listing iterates through the list setting the next pointers of the nodes it most recently visited to nullptr .
On the very next iteration the pointer destroys the during its reassignment from .
This means it must destroy next smart pointer , but the previous iteration set this to null .
This eliminates the chaining problem and allows the previous to be destroyed with single function call that returns immediately .
This version deallocates the list through series of separate , isolated function calls that return immediately rather than chain of function invocations that potentially can overflow the stack .

Our linked list class has an insert method that allows clients to add elements to the list , but it has .

, we could add the following .

The remove method is more complicated than the nsert method because the nsert method always adds new to the back end of the list .
The remove method must be able to remove from anywhere in the , back , and anywhere in between .

The remove method for our IntLi smart list class would look like the .

The flexible sorting examples in Listing , Listing , and Listing allow us to arrange the in integer vectors in creative ways and perform other interesting activities such as logging .
Those examples demonstrate the power of function pointers , inheritance , and polymorphism .
As flexible and powerful as these techniques are , they all contain one major limitation : they deal with vectors of integers only .
Consider the Comparer class from ing and Listing , and the " selecti function from Listing .
The selecti function accepts vector of integers and Comparer reference .
What if we need to sort vector of numbers or vector of std   stri ng objects .
Unfortunately , all of this " code cannot handle this seemingly minor variation .

In this chapter we look at template mechanism that enables programmers to develop truly generic algorithms and data structures .
We will see how the standard library has embraced the template nology to provide wealth of generic algorithms and data structures that greatly assist developers in the construction of quality software .

The situation is even worse for the following code : 

As another example , consider the following function that computes the sum of the in of integers : int .

The second code fragment attempts to pass of values to the sum function .
Unfortunately , the sum function accepts only vectors that contain integers .
More precisely , sum accepts only arguments of type std :  and std   object is not std  
The solution is easy ; just copy and paste the original sum function and change all the occurrences of nt " to " creating an overloaded sum function : double : double ; for elem  elem ; return  This works , but the duplicated effort is unsatisfying .
These two overloaded sum functions are identical except for the types involved .
The actions of the two initialization , traversal and essentially the same .
In general , code duplication is undesirable .
programmer that discovers and repairs an error in one of the functions must remember to apply the corresponding correction to the overloaded counterpart .

Both the and sum functions share common shortcoming : they are tied in some way to particular data type .
It would be convenient to be able to specify the common pattern and let the compiler fill in the types as required .
In the case of we would like to be able to write function that can use the operator on parameters of any type for which is compatible .
For sum , we would like to create generic function that works for vectors containing any numeric type .

enables programmers to write such generic functions via templates .
function template specifies pattern of code , and either the programmer or the compiler supplies the exact type as needed .

The template keyword indicates that the function definition that follows is not normal function definition but rather is pattern or template from which the compiler can attempt to produce the correct function definition .
function template is also known as generic function .
The typename keyword indicates that the identifier that follows this case is placeholder for type name .
The type parameter stands for an actual type to be determined elsewhere .
is an identifier and so can have any name legal for variable , function , or class ; some programmers prefer more descriptive names such as CompareType or TypeParam .
Single capital letters such as , and are popular type parameter names among programmers .
Just as regular parameter of function or method represents value , template parameter represents type .

You may use the reserved class interchangeably with the keyword typename in this .

In Listing the compiler generates three different functions : one that accepts two integers , one that accepts two values , and one the accepts two string objects .
Although the programmer cannot see them in the source code , the compiler in effect creates the following literal function .

The compiler instantiates functions only as needed .
If Listing did not contain the std   stri ng objects , when processing the source code the compiler would not instantiate the version of that accepts two std   stri ng objects .

For efficiency purposes , the better way to write .

Notice that parameters and are passed by reference , not by value .
This means the caller passes only the addresses of objects and and does not need to make copies to send to the function .
This can make big difference if represents large objects .
Since the parameters are const references , the function cannot change the state of the actual parameters ; therefore , the function offers safety without the overhead of copying the parameters .

This is because the template definition specifies that its two type parameters are identical .
The literal is an nt , and the literal .
The compiler can automatically instantiate functions that accept two nts or two doubles but not mixed types .

One solution requires the programmer to explicitly instantiate the function shown here :  This forces the compiler to instantiate and call the integer version .
The compiler will issue warning about truncating the .
The statement :    would use the version of  and it compiles cleanly with no warnings since widening the nt to double is automatic .

We can rewrite the template function to avoid the need for explicit instantiation .
For the most flexibility , we can express the template function as .

While this more flexible template function allows us to compare mixed numeric expressions , in general it makes more sense to expect the two parameters to be the same type .

Returning to our summation function , we can express sum generically as .

The angle brackets that follow the template keyword contain declarations of template parameters .

The compiler generates these automatically and secretly .
The programmer never sees these instantiated template functions because they do not appear in any source code .
Unlike the preprocessor that sends modified version of the source code to the compiler Section to review the role in the build , modern compiler generates the machine language versions of these instantiated functions directly from the source code .

Recall our swap function from Listing .

Here the type name is This swap function works fine , but we do not need to write such function ourselves ; the standard library includes std   swap template function that does the same thing as our swap function shown above .

The following function will print the contents of of any .

Notice that all the functions except for mai are functions .
The selecti rt function is the .

This explicit instantiation is required because the compiler cannot automatically instantiate the function without an actual call to the function passing real parameters , and pointer to function is not function invocation .
At this point in the program we are not calling the function but only passing pointer to it .
Calling it would provide the necessary type information to the compiler via the actual parameters used , but pointer to function does not contain parameter information .
The compiler needs the assistance of this explicit template instantiation .

The call to swap within is actually invoking the std   swap function the standard library .
The nclude li directive brings in the declaration for std   swap , which itself is template function .

The compiler can instantiate an actual function template function only if the type substituted for .

The expression , is illegal because no exists to compare two std   ofstream objects ; thus , the compiler cannot produce the machine language that represents .

When programmers use templates incorrectly or construct incorrect template functions or classes , the compiler can detect and report the problems .
All current compilers share one weakness with template processing : poor error messages .
The error messages the compiler produces in these situations tend to be lengthy and difficult to decipher even for experienced programmers .
This is because the compiler bases its error messages on its processing of the instantiated code , not the original code .
Since programmers see only the source , deciphering the template error messages tends to be more challenging than usual .

Other types such as and types may not be template parameters .

The Standard Library contains many functions , some of which we have seen .

With class templates we can specify the pattern or structure of class of objects in way .
The class template mechanism is key tool for creating generic types .

As simple example , consider basic Point class that represents point objects .

Mathematical point objects should have coordinates that we can approximate with precision values .
point on graphical display , on the other hand , better uses integer dinates because screen pixels have discrete , whole number locations .

Rather than providing two separate classes , we can write one class template let the compiler instantiate .

As with Listing , the Comparer objects specified in Listing .

Without templates , we would have to copy the IntLi st code and modify it so it works with st ri ng objects instead of integers .
We could call this class St ngLi st .
Note that the code in the IntLi st and Stri ngLi st classes would be almost identical ; the only major difference would be the type of elements the list can hold .
class template feature is ideal for designing generic container classes .

LinkedLi .

Destroying node .

Destroying node .

Just as we may instantiate function templates with multiple different types within the same program , we can do the same for class templates .
The class template Li nkedLi st in Listing makes the following client code possible :

The std :  vector .

Write generic function named that accepts std : containing any comparable by .
The function should return if the in the vector appear in order ; otherwise , the function should return false .

Write generic function named that accepts argument of any type comparable by and second argument consisting of std   vector containing of same type as the first argument .
The function should return true if the first argument is member of the second argument ; otherwise , the function should return false .

Augment Listing by adding method named prepend that adds an to the front of generic linked list .

Augment Listing by adding an method that returns true if two generic linked list contain exactly the same in exactly the same order ; otherwise , the method returns false .
Also provide method that utilizes your method .

the mechanics of generic programming with templates .
The standard library leverages templates to provide rich collection of standard generic containers and algorithms to manipulate the containers and process the they contain .
This part of the standard library commonly is known as the standard template library  or STL for short .
As its name implies , the STL contains number of generic functions and classes built with templates .
We have seen the std   vector class .

The design of the containers and their iterators make the generic algorithms possible .
The algorithms provided by the STL are powerful and flexible , but they also are somewhat arcane and can be difficult to use for casual programmers .

In this chapter we explore some of the features of the STL , providing examples that illustrate its bilities .

We are familiar with one STL container : std   vector .
vector object manages primitive array .

arrays come in two varieties : static and dynamic Section .
Vectors manage dynamicallyallocated arrays .
vector object can expand as needed the storage space for its array .
The STL provides an equivalent to static array in its std   array class .
programmer must specify the size of std   ray object when declaring it .
The following code creates std   ray that can hold integer .

Note that the second template parameter is parameter Section specifying the size of the array .
Besides not being able to modify the size through methods such as , std : objects work very much like std :
Array objects keep track of their size , unlike primitive arrays .

In Listing we developed generic linked list class named Li nkedLi st .
That was good practice dealing with generic types , but our work really was the wheel because the STL provides the generic std : class .
The STL implements linked list with pointers connecting node to both its successor node and predecessor node .
list with both forward and backward pointers is known as doubly linked list .
Listing is the third and final variation of our list programs .
Listing used custom class to implement singly linked list of integers .

priority queue is data structure that allows clients to store objects with various priorities or rankings .

Clients can insert the objects in any order , and the priority queue always will serve higher priority objects before lower priority objects .
properly designed priority queue supports very fast insertion and removal operations .

The library provides the std   pri ori class .

Note that the priority queue serves larger values before smaller values regardless of their insertion order .
It equates numbers with higher priority .

If we want to change the notion of priority so that numbers are considered higher priority than larger numbers , the std : class provides the flexibility for us to do so .
We must define special class or struct that provides public method named .
This method must return Boolean result and accept two arguments of the same type as the elements held by the priority queue .

Consider the following Cmp .

The first output line indicates it is false that .
The second line reveals that it is true that , and in the last line we see that it is false that .

The expression op , looks like call to the function named op , but it really is just syntactic sugar for ,
We see that we really are invoking the method nameed operatorQ on behalf of the op object .

Listing provides the complete code for apriority queue that holds integers and .

Since we are providing custom comparer class to modify the default priority queue ordering , the .

The std   pri ori class serves as wrapper around an exiting container type .

Cmp is the type of comparer object that the priority queue will use to order its items .

Armed with the ability to precisely specify how the priority queue defines priorities , we can store any type of objects in priority queue .
By default , the std   pri ori class can store any type of objects that can be compared using the operator .
This includes the basic numeric types nt , double , unsigned , and std :  string objects .
The std :  complex class Section models mathematical complex numbers .
The relational operators , and have no practical mathematical meaning in the context of complex numbers ; therefore , does not automatically support operator comparison between two std   complex objects .
We can define our own ordering , however .
Let + bi and c + di be two complex numbers .
We will define + bi to have higher priority that c + di if the distance between + bi and on the complex plane is less than the distance between c + di and .
The distance between + bi and is  and the distance between and is +
The following custom comparer class implements this notion of complex number .

Custom comparer objects allow us to place items in priority queue that inherently are not numerical themselves .
Suppose we are writing part of messaging system that processes text messages .
In addition to the text in the message , each message has integer priority in the range .
Lower numbered messages have priority over messages with higher numbers .
Instances of the following struct model our simple .

This means their elements appear .

Section demonstrates how we can use pointer to access the elements within an array .
vector is an object that manages primitive array , and the developers of the vector class designed vectors to look and feel as much as possible as arrays .
They adopted the square bracket operator to access elements .

They also devised way for programmers to use objects to access the elements within vector .

These objects are called iterators .

An iterator is an object that allows client to traverse and access elements of data structure in an implementation independent way .
defines two global functions , std   begi and std   end , that produce iterators to the front and back , respectively , of data structure like vector or static array .
tainers defined int the STL provide begi and end methods that serve the same purpose ; for example , if is std :  vector , std   begi returns the same iterator as the call .
Functions in the standard library that accept iterators as arguments rather than arrays or vectors work equally well with both vectors and arrays .
Since they accept iterator arguments , these standard functions additionally are able to work with other , more sophisticated data structures .
We will examine some of these standard functions later in this chapter .

In order to behave like pointer , an iterator object provides the following .

The syntax is exactly like pointer dereferencing Section .

The syntax is exactly like pointer arithmetic Section .

The type of is std   vectorci  This complicated expression indicates that terator is type defined within the std   type .
shorter way to express this statement takes advantage of the ability to infer the type from its .

While the std : function returns an iterator pointing to the first element in data .

As such , we never attempt to dereference the iterator ; the expression ter in this case is undefined .
We normally use the iterator returned by the std   end function to test to see if we are past the end of our data structure .
Listing demonstrates .

We can use the methods begi and end instead of the std   begi and std   end tions .
Listing is modified version of Listing that .

Any type for which the std : and std   end functions have been overloaded may participate .

The following code .

Section that we can manipulate pointers with pointer arithmetic .
If points to the first element of an array , + points to the sixth element in the array + is the same as .
The expression + + makes the point to the next element in the array , while moves backwards one position .
We can use similar arithmetic with iterators as Listing pOTl illustrates .

Subtraction is not an option for these kinds of iterators .

We can specify range with pair of iterators ; one iterator points to the first element in the sequence , and the other iterator points to the position just past the end of the sequence .
The global functions std   begi and std   end fit well into this definition of range .

Suppose vec is .
The two iterators std   begi and std   end span the .

Section introduced technique for traversing an array via pointer range .
Rather than passing an array the address of the first and its size of to traversal function , the approach passes the array , literally pointer to the first and pointer to the position just past the end of the array .
Notice how the pointers in array technique correspond directly to the iterator objects returned by the std   begi and std   end functions .
Since iterator objects behave like pointers , we can write truly generic code that can process both arrays and vectors .

The following function uses iterators to count the number of times value appears within .

Type elements must be .

The first two parameters of selecti rt are generic , and the code within the function treats these two parameters as if they are pointers .
Since ator objects behave exactly like pointers to the extent exercised within selecti , the compiler can instantiate the template to accept pointer or iterator arguments .
Similarly , the pri nt function works equally well with both pointer ranges for arrays and iterators for vectors .
The main function demonstrates the flexibility of print and functions by sending them both array pointer ranges and iterators .
Behind the scenes the compiler will automatically instantiate two overloaded pri nt functions and two overloaded selecti on sort functions .

Clients may use vectors , arrays , any sequence type that overloads the begi end functions .

Clients may work with sequences that contain elements of any type that supports the tors .

Clients may customize the element ordering .

One of the primary benefits of functions is that we can write code once invoke it from many different places within the program even invoke it from other .
Ordinarily , in order to call function , we must know its name .
Almost all the examples we have seen have invoked function via its name .
Listing in Section provided examples of invoking functions without using their names directly .
There we saw function named evaluate that accepts function as .

The answer , of course , is that evaluate invokes the function passed in from the .

The code in the evaluate function demands that callers send function as the first parameter .
Does this mean we have to write separate function with name in order to call evaluate .
Once we create function with name it is available to be called from anywhere within the program after its definition or declaration .
What if we want to ensure that our function will execute exactly one time only when invoked by evaluate .

The term lambda comes from lambda calculus ki , mathematical system developed by Alonzo Church in the .
Concepts from lambda calculus led to the development of the modern computer .
The lambda calculus is the basis for modern functional languages like Haskell .

The construct identifies lambda function ; thus , the first argument being passed to evaluate is indeed function that takes two integer parameters .
Notice that result of passing the lambda function here is the same as passing the multi ply function fromListing compute the product of the two parameters .

One interesting aspect of lambda functions is that they can be used to create closures .
closure is unit of code this case that can capture variables from its surrounding context .
These captured variables then can be used outside of their original context .
In order to demonstrate closure , we first must explore function objects .

std   uncti on object works like function pointer Section .
The std   uncti on .

Note the type parameter nt nt  inside the angle brackets .
The first nt represents the return type .
The two nts inside the parentheses specify the parameters .
Function objects take the place of function pointers .
Function pointers are available in as well as , but does not provide function objects .
Function objects provide capabilities above simple function pointers , including the ability to manage closures .

Note that mai creates function via the lambda expression that it passes to .
The variable appears within the capture square brackets .
This makes value available to whatever code invokes the lambda function .
In this case the function can see value even though is local to mai is not passed to as an explicit parameter .

We say the lambda function captures the variable .
When invokes the function sent by the caller , has no access to variable named .
The involved in the conditional expression is captured from mai .
This is an example of closure transporting captured variable into function call .

For an example of closure transporting captured local variable out of function , consider .

lambda capture mechanism provides capabilities that go beyond the examples shown here ; for example , the expression within the square brackets would capture variable by reference , allowing an external context to modify the variable .
Note that when closure captures variable by reference , that variable must exist in its original context as long as the closure is viable .
This means you should not attempt to capture local c variable of function by reference by closure to be returned by that function .
The local variables disappear when the function returns , and so the references will refer to garbage values .

If you are unfamiliar with calculus , all you need to know is that the derivative of function is itself function ; the above formula shows how to transform function into its derivative .
The process of computing derivative is known as differentiation .
The notation indicates that the answer becomes more precise as the value gets closer to zero .
Letting be exactly zero would result in division by zero , which is undefined .
The trick is to make as small as possible , keeping in mind that the values have limitations .

Based on the mathematical definition we can define function that computes the derivative of another function , as shown .

The function that derivative returns is closure because it captures the function parameters and .

Our deri vati ve function allows us to compute the derivative of function at given value .
This is known as numerical differentiation .
Another approach one emphasized in calculus uses symbolic differentiation .
Symbolic differentiation transforms the formula for function into different formula .
The details of symbolic differentiation are beyond the scope of this text , but we will use one of its results for particular function to check our computed numerical results .

The flexible design of the STL containers and their iterators make possible the generic algorithms .

The algorithms provided by the STL are powerful and flexible , but they also are somewhat arcane and can be difficult to use for casual programmers .
The STL algorithms are best viewed as the building blocks for more specific tasks required by applications .

In order to use the STL algorithms you must include the following preprocessor directive : ffinclude One relatively simple algorithm is std  
The function applies unary function to each element in the container .
Like the other algorithms we will see , uses an iterator to drive loop behind the scenes .
The following statement prints out each element in std   Ti st object called seq holding .

The std   iota function , delared in the header , is simple but handy function that fills container with ascending numbers .
The std   ota function allows us to replace the following .

The std   copy function copies the elements from one container to another .
The std   transform function works like std   copy except it expects function that that can modify the copied elements .
Both functions require the begin and end iterators from the source container and the begin iterator of the tion container .
Listing illustrates the use of std  copy and std :

The std :  copy function may seem superfluous since for vectors also performs .

The std   count serves the role of our function from Listing .

The last argument to std : function that accepts single value of the type the container is declared to hold .
The function returns true or false .
function that returns Boolean result is known as predicate .
Some STL algorithms , like std   expect predicate to allow them to process only elements that satisfy the predicate .
As another example , the std   function copies only elements from one container to another that satisfy given predicate .
Listing uses std   and std   to copy relevant portions of vectors .

Observe that in Listing we assigned the lambda functions to the variables pri nt and .
This is so we did not have to write the same lambda expressions twice , for printing seq and and for testing evenness in for and .
Predicates do not have to be lambda can be global named functions as well , but lambda function often are more convenient .

We can use the std   generate function to populate container based on generating function .

The first two lines of the output will always be the same , but the last line will vary from one run to the next .

The std : function applies binary operation to all the elements of container to produce single value .
Listing shows the std : function in action .

This is the expected output , + and .

While it may seem good in theory , this approach is not efficient and should be avoided .
Each tion of the + concatenation creates new   stri ng object from two existing 
Especially for longer lists , this repeated creation process unnecessarily wastes time and space .
For container that contains strings , the   accumulate function will ate new on its way to produce the final accumulated result .
Numeric arithmetic does not create new  and so  accumulate is best used on containers holding numbers .

This appends characters onto the end of an existing object , thus avoiding the creation of new In this case simple familiar for loop is preferable to sophisticated STL algorithm .
The following code illustrates more efficient .

If the number of strings is small , it does not make much difference .
It is only when the collection of strings to concatenate becomes large that we will detect performance difference .
Listing tests the two algorithms .

Some runs show   accumulate to be faster , but the differences are usually milliseconds .

We can use the std   remove and std   functions to remove elements from .

Neither remove nor by themselves achieve the results we generally desire .

The first line shows the contents of the original vector .
The second line shows the modified vector with removed .
Element definitely is gone , but the vector contains the same number of elements as before .

closer inspection reveals that all the elements that followed in the original vector have been shifted forward one position .
It is as if the removal of left hole in the vector that the following elements had to shift forward to fill .
That would be fine , but the last element , was copied forward and remains the last element in the vector .

In order to actually remove the elements and make the resulting container smaller , we must couple remove or with the erase method .
The erase method accepts two iterators establishing range of elements to delete from the container .
Listing shows how to remove section of vector using the std   vector   erase method .

The return value of the call to remove returns an iterator pointing to the second occurrence of in the second line of output .
In the third line of output the call to returns pointer to second occurrence of as well .
Note that in both cases the iterators point to the first element in the remaining values that ought to be erased from the vector .

The combination of std   vector   erase and std   remove is known in the community .

The STL contains number of other algorithms to process generic containers .
Some examples include .

We now are creating our own names for functions and types within the programs we write .
Using the blanket usi ng directive can present problems at times because the std namespace contains hundreds of type and function names , and it is too easy for programmer to accidentally reuse for another purpose name already claimed by the std namespace .
Such name conflicts lead to problems during software development , and since the development process generally has enough other challenges to address , it is best practice to avoid the blanket usi ng directive .

Listing defines max function that computes the number of times the maximum .

The mai function tries out the function on sample vector .

Notice the blanket usi ng namespace std directive that makes all the function and type names in the std namespace available to this program .
This has not been our common practice so far , but you frequently will encounter this approach in published code .
This program works correctly , however , as it prints the following : The standard library contains function named , declared in the header .

The standard performs the same task as this , except that the standard function , striving to be as generic as possible , accepts two iterators instead of the container itself .
In preparation to replace our function with the standard function , we add the following directive to the top of the code with the other .

Before the inclusion of , the only the compiler knew of was the one defined in Listing .
This function expects reference to std   object .
The std   class contains constructor that accepts an initializer list .
The compiler , therefore , automatically can create from an initializer list .

The compiler automatically uses the initializer list to create object and sends it off the function for processing .

The inclusion of the header provides the declaration of std :  that accepts , among other arguments , an initializer list .
When the compiler matches function call to its ing definition , it always seeks the best match for the arguments passed .
Since the std   accepts an initializer list , it better matches the calls in the mai function .

Remember , our purpose for including the header was to gain access to , and we had no intention of changing our implementation .
Unfortunately , the compiler , following and sensible algorithm , silently warnings or substituted different function to change the behavior of our program .
This is prime example of why the blanket using namespace std directive can be dangerous .

Identifiers names , function names , and type should be meaningful , clearly nicating their intent .
English words or simple variations of common words are ideal .
This means it is quite likely that library developed by team of developers would contain function names and type names that also appear in different library developed by different team of programmers .
Each library used separately is not problem , but issues can arise when building software system atop multiple libraries ; for example , consider the task of building program that models and visualizes the spread of an infectious agent .
Such system could make good use of the following .

Ideally , any code meant for widespread use should be part of namespace .
company developing .

In it is easy to put the functions and types we develop into custom namespaces .
Suppose we wish to make the functions from Listing available to wider audience .
ing and Listing package the two functions into namespace named vectuti Is .
Listing provides the function declarations , and Listing contains the function definitions .

Just as with the std namespace , it is best to avoid blanket usi ng directives for custom namespaces .

Since nested namespace names can become quite lengthy , supports namespace aliases , as in .

This namespace alias makes it possible for us to call with the more compact statement :  Nesting allows developers to organize better the components within libraries ; for example , company may .

Both of these data structures represent linear quences of elements .
Vectors and arrays are convenient for storing collections of data , but they have some limitations .
For one , we locate an element within vector or array based on its position .
To retrieve specific element we must supply its index .
While this approach is fine for many applications , in other situations this approach is awkward or inefficient .

In contrast , an associative container permits access based on key , rather than an index .
Unlike an index , key is not restricted to an integer expression .
The standard library supports three kinds of associative containers : set , map , and .
Here we will examine each of these types in some detail .

Unlike vectors , arrays , and lists , mathematical sets are unordered and may contain no duplicate elements .
The std :  set container , like mathematical sets , ignores any attempts to include duplicate elements ; however , std   set objects do order their elements internally in particular way .
This ordering permits very fast access to .

The order actually is ascending order in all of our tests in Listing , and this is not coincidence .
Also observe that sets do not admit duplicate elements .

The implementation of the std   class on all the major libraries use tree as the internal data structure .
The dering imposed by this internal data structure enables very fast access to the elements .
tree permits binary search Section ;
determines the order of its elements via operators The works with all the primitive numeric types , double , float , unsigned ,
The is defined for std : ng class instances to compare two string objects cally .
Instances of any type we wish to store in std   must support the .

In Listing we define new type , MyClass .
We must ensure that it is possible to compare two MyClass instances using the in order to put MyClass objects in .
To achieve this , we define as global function that compares two MyClass objects .
This allows us to create of MyClass objects .

Also , any duplicate elements in the will appear only once in the object .

Unlike in mathematics , all sets in must be finite .

supports the standard mathematical operations of intersection , union , difference , and metric difference .
These functions are part of the algorithms library , and thus they are designed to work with as wide an array of containers as possible .
The downside of this flexibility is they are somewhat arcane and awkward to use , as Listing shows .

The catch is that the elements in the containers must be ordered for these functions to work properly .

We saw that std   objects are ordered automatically .
Since std   objects do not impose an order on their elements , we must first sort any vectors we wish to send to the standard intersection and union functions .

Listing implements and operator to work with objects to vide more convenient interface to programmers .
The operator represents intersection , and .

The real value of the class comes from the speed of access it provides to its elements .
As an associative container , we do not access an element via an index as we do with or array .
In fact , std   does not even provide operator .
We want to place an item into and retrieve it later without regard to its location within its internal data structure .

Recall the std : algorithm provided by the STL Section .
Given an iterator to the beginning of the container , an iterator just past the end of the container , and an item to find , std  returns an iterator that points to the sought element within the container .
If the container does not contain the sought element , std   find returns the iterator that equals the iterator .

The std   find function works with std :  object just as it does with other containers , but the std   class provides its own find method that exploits the structure of the data within the object to locate elements very quickly .
Listing illustrates the use the std :    find method , comparing the time to locate an element in versus the time to locate the same element in containing the exact elements contained in the .

The and objects within Listing each contain the integers ,

Note that the contains the elements in ascending order .
We then create containing random values in the range .
The program will search for these random values within each container .
The program measures the time it takes to complete the searches .

The output Listing reveals the dramatic difference in performance between the std   find function on and the std     find method with .

We see on this particular run that the search required almost one and half minutes to complete , while the search took only about quarter of second .
While the exact numbers will vary from run to run and be higher or lower depending on the host machine , the disparity of times will be consistent .
The two data structure contain exactly the same elements , and program uses the exact same search values .
The std   search is so much quicker because std     fi nd performs binary search on its internal data structure , while std   find uses linear search Section .

That one thing might be an integer or single object like or an instance of some other class , but it must be just one thing .
What if we need function to return more than one thing .
We could put the desired return values into and return the .
The caller then would extract the components from the upon the return .
Unfortunately , this will not work if the multiple elements to return have different types .
The container types we have examined thus , arrays , lists , and been homogeneous ; that is , their elements all have the same .

We could define struct or class that has fields of different types , but this creates   In large program we may need many different structs to cover all the combinations of return types we need .
Providing struct or class introduces into the system , thereby increasing the complexity .

All we want is to be able to package multiple elements together for some simple purpose , without needing to create .
Fortunately , provides the std : generic class in its .

The arguments used when making can consist of literals , variables , and other more complex expressions .

Extracting the components of is known as unpacking .
Listing shows how to use the std   ti function to assign the components of to individual variables in one statement .

The std   ti function is generic function that works with any types storable within .
If we wish to extract just one element from  we can use the std   generic function .
The generic std   function is parameterized by an integer that serves as an index into the .

supports another way of unpacking tuples .
Structured binding is similar to std   ti but can be used only when declaring the variables used to represent the components of .
With structured binding we can rewrite the following code : 

Note that we can use this special syntax only when declaring the variables to be bound to the components of the .
This copies the components of the into the newly declared .

We can specify that the structured binding be done by reference , as in the following :   In this case each within the binding becomes an alias to component of the .
In the previous code fragment above , reassigning will similarly modify the second component of .

Structured binding is especially convenient when processing tuples within loops .
Listing uses structured bindings by reference to reassign the elements in vector of tuples .

The standard library supports special case of std :  tuple called std :

As Listing shows , we can use std : std : and structured binding with std   pai object , and they work exactly as they do with std   tuple .
Since pair objects always contain exactly two elements the std   pai class provides the public fields fi rst and second through which we can unpack pair using simpler syntax .

We say each integer in the map object has an associated stri ng key .
In the expression std     stri ng  the first template argument std :  stri indicates the map ' key type , and the second template argument indicates the type of values stored in the map .
Listing provides simple example that uses map object .

Keys must be unique ; that is , no two values in an unordered map can have the same key .
Duplicate values are allowed ; that is , two different keys can have the same value , but two different values cannot have the same key .
This is similar to vector or array , in that the same value may be stored at different indices , but only one value may be associated with particular index .

One big difference between map and vector is vector of size allows any index in the range .
Consider the statement container ; if the key within the square brackets does not exist in the map before this statement executes , the statement adds the key to the map and pairs it with the on the right of the assignment operator .
If the key already exists in the map , the statement replaces the previously associated with the key with the new on the right of the assignment operator .

Consider accessing with given key rather than assigning the  the statement   prints the associated with the key .
If " is not currently key in the map , this statement will add the key " with the default for the type of declared for the map .
For integers , the default is .
As other examples , the default is , the default string is the empty string ,  and the default bool is false .

You should use map object when you need fast and convenient access to an element of collection based on search key rather than an index .
Consider the problem of implementing simple telephone contact list .
Most people are very familiar with the names of their friends , family , and business contacts but can remember only handful of telephone numbers .
contact list associates with telephone .

It would be inappropriate to place the names in vector , for example , and locate using the associated phone as an index into the vector .
This method is do not want to find given phone  we want to look up based on .
Besides , each phone contains many digits , and we would not need or want to have vector with indices that of the space in the data structure would be unused .

In our situation person or is unique identifier for that contact .
In this case the is key to that contact .
map is an ideal data structure for mapping keys to values .
It allows for the fast .

Listing can successfully translate eight Spanish words into English .
If we wish to increase the vocabulary , we must modify the logic by adding another else if block for each new .
Listing provides better approach ; it uses map to assist the translation .

The words will become the key and value items in our map when the program runs .
This is significant difference if wish to enough words to make the program practical .

The std  no type is another example of container .
std   object works like std : object , but they each use different underlying data structure .
Most std   map implementations use tree to store the elements , while an unordered map uses hash table .

This difference makes an unordered map faster in general than map for accessing an element via its key .
Map objects trade raw speed for the ability to access ciently elements in order based on their keys .
Unordered map objects truly are unordered ; they provide no efficient way for clients to traverse their pairs by order of their keys .

In order to use std : object within program we must use the appropriate .

Like the std   map class , the std   class is template class , so when declaring an instance we must supply type parameters within angle brackets as shown in the following .

The ordering of the elements in an unordered map is not really random ; special function known as hash function determines their position within the unordered map at the time of their insertion .
This hashing process makes unordered maps slightly faster than regular map objects .
If the speed of access is critical and accessing the elements in order is not necessary , std   is the better choice .

Associative containers are useful for counting things .
We have experience using variables to count ; recall Listing and Listing .
These programs counted one thing at time , so they each use just one counter variable .
In general , we need to use separate variable for each count we manage .
Listing uses function to count the number of negative and nonnegative numbers in vector of integers and returns Std   pai with the .

Note that we created type alias for the more complicated type   pai nt 

This is not particularly helpful in this simple program only use the type in one , but it illustrates that we can use the usi ng statement for type aliasing std :  pai as easily as with std :  vector or any other more complicated looking type name .
We also simplified the return statement at the end of the function .
The compiler knows the return type of the function as IntPai pair of , so it must return pair object .
The curly brace notation without any other verbiage indicates the arguments to the , class constructor that it should use when creating the object to return .
The compiler automatically generates the machine code to call the pair constructor with the arguments within the curly braces .

Suppose we wish to keep track of the quantity of each letter that appears in text file .
There are letters in the alphabet , so we would need counter variables .
Managing different counter variables is inconvenient , so we could use vector containing integers .
The element at index could store the number of As , the element at index could keep track of the number of , etc .
An associative container may be useful but is not necessary to solve our problem .
Listing provides one implementation .

In this case we knew we needed to count different things , so we were prepared with counters .
The number of letters in the English alphabet does not change , so this approach works well .

So far so good , but what if we face situation in which we must count multiple kinds of things , and we cannot know ahead of time how many kinds of things there will be to count .
How can we determine how many counter variables to use in program that attempts to solve such problem .

The answer is this : We cannot know how many counter variables we will need , so we must use different approach .
With an associative container we can use the items we wish to count as the keys .

After reading the file the program prints .

: AMONG : AND : COURSE : FOR : GOD : HAVE : HUMAN : IN : IT : LAWS : OF : ONE : PEOPLE : REQUIRES : SHOULD : THAT : THE : THEM : THEY : TO : WHEN : WITH : In Listing , since we cannot predict what words will appear in document , we cannot use separate variable for each counter .
Instead , we use the words as keys in map object .
For each key in the map we associate an integer value that keeps track of the number of times the word appears in the file .
We use map instead of an so that we can list the words and their counts in .

If the map currently holds the string word , the sion simply adds one to the integer value ; it the string word does not appear in the counters map object , the statement first inserts the string word with an associated value of and then immediately increments it to .
This is the exact behavior we need for our word counting program .

In this example the need for map object is not as compelling as in Listing , because in practice the length of English words is limited .
We could instead use vector of sets .

Only rarely used , highly technical words exceed letters .
We could handle these " words in special way , perhaps storing them in the in the last position in the vector with other words of more than letters .
Our program could use special processing for this of long words if it ever becomes nonempty .
This approach under typical circumstances would result in number of empty sets at higher indices because most English text contains words of at most about letters .
The advantage of map is that it stores only what it needs .
Listing is close transliteration of Listing that uses vector in place of map .

We know program can use variables to remember values as it executes .
programmer must be able to predict the number of values the program must manage in order to write enough variables in the code .

An associative container provides an opportunity to create an arbitrary amount of new during execution .
We will consider simple problem that demonstrates the value of the dynamic provided by objects .

the Fibonacci number sequence .
That section provided function to compute the th Fibonacci number , reproduced .

This fibonacci function is correct , but it does not scale execution time grows significantly as its parameter ,  increases .
The problem is this : when computing solution for particular Fibonacci number the function can repeat exactly the same work multiple times .
illustrates the repetitive work performed by the call fibonacci .
As we can see from the figure , the recursive execution calls fibonacci five times during the computation of fibonacci .
We can verify the results shown in Figure by augmenting our fibonacci function with global map that counts function calls .

For tional emphasis , the call recursively calls , and over one million times each .
We may be tempted to care less about the repeated all , it is the computer doing the work , not us .
Unfortunately , the puter , even though it is very fast , requires some amount of time to perform any task .
As we multiply the number of tasks program must do to solve problem , the time to compute the solution increases , and , in the case of the function , the time increases dramatically .

We can improve the performance of our function using technique known as memoization .

Memoization is an algorithm design technique that records the result of specific computation so that result can be used as needed at later time during the execution .
It is as if the executing program note to itself " or the result in " When the program needs the result of an identical putation in the future , if simply reads the memo with the answer it stored earlier .
In this way the program avoids repeating the work .
Memoization is especially useful for problems that consist of subproblems that overlap and appear to require multiple computations with identical input .

The following function uses an unordered map object to cache previously computed Fibonacci .

The function uses an unordered map as cache of stored values that persist for the duration of the execution .
Since the ans local variable is stati c , the environment creates and initializes it with keys and before executing the mai function .
When caller invokes , if the answer is not in ans , it computes the result and stores the result in ans for future use .
This not only helps future calls to the function from the outside , but it also speeds up recursive invocations that must perform the same work .

The Fibonacci numbers grow very quickly , so the functions in Listing return unsigned long long values .
For convenience it introduces the type alias Integer for unsigned long long to simplify the code .
Under Visual , for example , this type supports values in the range .
provides the implementations for the two functions .

When compiled and linked with the code in Listing .
Listing verifies that the function produces the same results as the function when given the same arguments .
It tests unsi gned values up to .
You will observe that as the arguments become larger , the program takes longer to print the results .

Figure The hierarchy of recursive function calls that result from the call .

The original recursive version requires over seconds two , while the memoized sive version takes only millisecond .
During this run the memoized version was over times faster .

The function is so fast because it avoids all the redundant recursive calls the function must compute .

Listing provides an honest test , as it forces to compute the th Fibonacci number right away with no previous invocations .
Once completing call of , all of the Fibonacci numbers from will be present in the cache of precomputed values .
This means future invocations involving any values in that range will be very fast .
Any program that must compute Fibonacci numbers multiple times during their execution will cially benefit from the memoized version .

Figure shows the recursion tree for our memoized Fibonacci function computing the fifth Fibonacci number .
The figure shows only nine invocations of , compared to invocations of the nonmemoized function .
If you add the function call counting instrumentation used in Listing to , you will find the numbers it reports agrees with Figure .

CHAPTER UNDER CONSTRUCTION In our programming experience so far we have encountered several kinds of errors .
To this point , all of our errors have resulted in the executing termination .
provides an ception handling framework that allows programmers to deal with certain kinds of errors .
Rather than always terminating the execution , the exception handling infrastructure enables mers to detect problem and execute code to correct the issue or manage it in other ways .
This chapter explores exception handling mechanism .

It may be straightforward to write an rithm to solve problem in the general case , but there may be number of special cases that must all be addressed within the algorithm for the algorithm to be correct .
Some of these special cases might occur rarely under the most extraordinary circumstances .
For the code implementing the algorithm to be robust , these exceptional cases must be handled properly ; however , adding the necessary details to the algorithm may render it overly complex and difficult to construct correctly .
Such an overly complex algorithm would be difficult for others to read and understand , and it would be harder to debug and extend .

Ideally , developer would express the algorithm in its general form including any common special cases .
Exceptional situations that should arise rarely , along with strategy to handle them , could appear elsewhere , perhaps as an annotation to the algorithm .
Thus , the algorithm is kept focused on solving the problem at hand , and measures to deal with exceptional cases are handled elsewhere .

exception handling infrastructure allows programmers to cleanly separate the code that ments the focused algorithm from the code that deals with exceptional situations that the algorithm may face .
This approach is more modular and encourages the development of code that is cleaner and easier to maintain and debug .

An exception is an exceptional event that occurs during execution .
An exception always is possible , but it should be relatively rare event .
If it were not rare , it would be customary or expected event , and the program should handle it as part of its normal processing .

An exception almost always represents problem , usually some sort of error .

The operator method performs no bounds checking ; thus , an executing program using the expression would represent undefined behavior .
Consider instead the expression .
The at method works just like ope rato , except at does check the bounds .

While this is better than undefined behavior , it is not ideal .
The program crashes .
When real application crashes the user may lose unsaved data .
Badly behaving programs terminate unexpectedly .
It would be better to defend against the index and keep the program alive .

An algorithm could handle many potential problems itself .
For example , programmer can use an statement to test to see index is within the proper .

To form block we .

Both try and catch are keywords in .
Unlike the bodies of the structured statements such as and whi le , the statements within try block and statements within catch block must appear within .

The variable within the catch block of Listing is reference to an exception object .
The exception class is part of the standard library and is the base class for all the standard exceptions .
The exception class provides what method that returns string .

The excepti on   what string is message containing information about the exception .
The standard does not specify the exact message , but at the very least the exception : method indicates the kind of exception caught .
The following shows what the program reports under Visual when the user enters the value .

While Listing does not technically crash , its behavior is not much ent from an actual abnormal program termination .
Listing provides more practical example .
This improved version uses loop to continuously request integer values until the user supplies one that does not throw an exception .

Listing is specially crafted to provide insight into the exact tion path .
Each function prints message at its beginning and end so we can see when the code within function is active .
Each function also declares local Tracker object which is identified by the name of that function .
An executing function constructs local object at its point of declaration and automatically destroys the object when the function returns to its caller .
These local objects , therefore , have lifetime that mirrors the lifetime of the function that manages them .
Finally , Listing declares global racker object .
An executing program creates global objects before it calls man and .

In Listing the nums , declared in mai , holds three elements .
The main function passes its nums to process .
During its call to process , the main function has no control over the process attempts to access an element outside the range of nums .

The process function , however , does not itself attempt to access any elements within the that mai supplies .
Instead , process passes the on to the find function .
It is in find where lems may arise because find calls the at method .
If the find function calls the at method with an index , at will throw an exception .
Observe that unlike in Listing , the method that calls std :   does not do so within block .
This means find cannot catch any exceptions that std   vectorci  ratmight throw .

The following shows sample run of .

Destroying Tracker .

The find function creates its Tracker object .

The find function obtains the for the element to seek .
Here the user enters is not present in the .

The find function executes its last statement .

Figure provides more graphical representation of this process .

In this case the user did not enter range in the process function that would cause problem in find , so no exceptions arise .
Since the execution produced no exceptions , it did not execute the printing statement in the catch block .

To see what happens during an exception consider the following sample run of Listing .

Destroying Tracker The user supplied range of .
Because the program does not print exit message we know the find function does not complete its execution as usual .
This is because the std     at method called by find throws an exception .

Furthermore , it does not appear that find returns normally to process , since process does not print its exit message either .
We do see , though , that the program does properly destroy the the local Tracker .

Figure Function call chain interrupted by an exception .
Neither the std   vector   at .

Figure better illustrates the execution .

Listing demonstrates that exceptions have the potential to radically alter the normal function call and return pathways .
In one sense an exception works like goto " ment .
The execution jumps back to previous point in its execution sequence , bypassing all functions in the call chain in between .
Recall Section discouraged the use of the goto statement except for it use to exit from within nested loop .
This is because the logic in code that uses indiscriminate gotos instead of the structured branching and looping constructs such as , swi tch , whi le , and for tends to be obscure and difficult to extend and maintain .
exception mechanism is different than goto " in several important .

goto statement cannot jump to code outside of the function in which it appears .
Exceptions have no such limitation .

The programmer must specify destination for goto statement .
In the case of Listing , the std :   method throws the exception .
We can call at from many different functions within single program and use at in many different grams .
The code within the at method cannot possibly know where to go if it encounters an exceptional situation .
An exception simply redirects the execution to the most recent block in the call chain that can handle the exception .

Listing follows .

The standard library has limited number of standard exceptions .
We can create our own custom tions for specialized error handling that our applications may require .
Listing defines custom exception class , FileNot Found Exception , derived from the standard std : class .

Since we derived the FileNotFoundException class from std : any FileNotFoundExcepti on object also is std   excepti on object Section .
This enables the main function to catch Fi leNotFoundExcepti on object in its catch body even though it is declared to catch std   excepti on objects .

The standard library provides number of exception classes , all derived from std   excepti on .

The exception objects thrown by the at method are instances of the standard std : range class .
The std :  out_of_range class is derived from the standard class which itself is derived from the standard std   excepti on class .
Figure shows the relationship among these exception classes .

Figure The relationship among the exception classes involved in Listing .

Size of data set .

This gives us two options for creating and populating the 
Create the with sufficient size up front and then use loop to place to individual elements in their proper places .

Create an empty and then use loop to the individual elements .

Option is more efficient than Option Successive calls to std :  vectorci   must reallocate and copy elements multiple times .
safer than the number of elements specified at the start may not agree with the actual number of data elements in the file .
If the specified number is too small , the function will attempt to overrun the bounds of the .

opts for efficiency at the expense of safety .
This means it depends on correctly created data hie .
If the hie does not exist , will throw our Fi Excepti on custom .

If the hie exists and contains .

Program finished Notice that in Listing the compute function does not create new object ; it simply the same object that it caught .
This concept of intermediate handlers is important since function invocation has complete knowledge of it own local context such as its local variables .
This means that an intermediate function in the call chain has access to information that may be unavailable to all other functions within that call chain .
The catch block in the compute function of Listing involves only local variables .
The catch block within the mai function cannot know the subscript that caused failure since is local to compute .

Some general guidelines .

Handle exceptions as close the call as possible to the code that throws the .

If the are responsible for their own handling , then the may be able to dispense with handling altogether making the methods more robust units of reuse .

The method may just need to know there was problem without needing to know exactly the problem was .
For example , in ing , the compute function could throw custom ComputeExcepti on object whenever filter throws its std   out_of_range instead of just passing up the call chain the std :  out_of_range object it receives .

If total recovery is not possible or desirable at the lower levels of the call chain , the .

When section of code throws an  the catch blocks within the nearest handler are checked in the order they appear in the source code .
The first catch block that matches the type of the thrown is the one executed .
Listing expects two types of exceptions , and it uses the in case any unexpected exceptions arise .

When an is caught , its type is first compared to std :  out_of_range
If it matches , the std : catch block is executed .
If not , the type is then compared to .
The catch block is executed in the case of match .

If neither of the two types match , the code is executed .

When inheritance is involved , the situation becomes more interesting .
The comparison performed in each catch block is test for assignment compatibility .
reference or pointer to an instance of derived class can be assigned to variable declared to be reference pointer to base class .
This casting operation is always legal because of the is relationship between derived class and its base class .
This means an object of type std : is assignment compatible with both std : variables and std :  variables .
Since the catch blocks are checked in the order they appear in the source code , the following code would have .

The std   out_of_range catch block will never execute since std   out_of_range object is an excepti on instance also .
For this reason it is illegal for more specific type to follow more general type in sequence of catch blocks .
The above code fragment will not compile in any context .
Thus , in sequence of catch blocks , list the more specific exceptions first followed by the more general exceptions .

All standard classes have std   excepti on as their direct or indirect base class .
does not require objects to be derived from excepti on ; in fact , primitive types such as nt .

Exceptions should be reserved for uncommon errors .
For example , the following code adds up all the elements in an integer named vec : int ,

This loop is fairly typical .
Another approach uses .

It interrupts the statement .

The exception definitely is not an uncommon occurrence .

You should not use exceptions to dictate normal logical flow .
While very useful for its intended pose , the exception mechanism adds some overhead to program execution , especially when an exception is thrown .
This overhead is reasonable when exceptions are rare but not when exceptions are part of the normal execution .

Sometimes it is not clear when an exception is appropriate .
Consider function that returns the position of an element within .
The straightforward approach that does not use exceptions could be written : int  int int .

In the first approach , an unwary programmer may not check the and blindly use as valid position .

The exception code would not allow this to happen .
However , the first approach is useful for determining if an element is present in the .
If find returns , then is not in the  otherwise , it is in the .
If the exception approach is used , client programmer cannot determine if an element is present without the risk of throwing an exception .
Since exceptions should be rare , the second approach appears to be less than ideal .

The first approach is more useful , but clients need to remember to properly check the .

The second approach provides an exception safety net , but an exception always will be thrown when searching for missing elements .

Which approach is ultimately better .
The first version uses common programming idiom and is the better approach for most programming situations .
The exception version is poorer choice since it is not uncommon to attempt to look for an element missing from  exceptions should be reserved for uncommon error situations .

This appendix describes the task of software development under Visual .

To begin creating program , you must first launch Visual Studio from the Windows start screen or other relevant shortcut .
Figure shows the appropriate application tile to activate .

You soon should see splash screen similar to the one shown in Figure If you have never before used the Visual Studio application , you must wait few moments while it configures the development environment for you .
At this point you will indicate that Visual is your preferred development language .
You also may select color scheme .
The figures shown here reflect the blue color scheme .

Figure shows what Visual Studio looks like when it is fully loaded and ready to use .

After Visual Studio has started , you begin the process of developing program by creating new .
As Figure shows , you can create new by following the menu sequence :

In the dialog that results , shown on the right of Figure you should choose the type to be Visual in the left pane , and use the Console Application option in the center pane .
In the name field near the bottom of the dialog , enter name for the  we will use the name simple .

You may change the location to different folder if you like , or even different drive as USB pen .
In this example , we chose to not change the default location provided by Visual Studio .

When you select OK on the creation dialog , Application Wizard as shown on the left of Figure appears .
At this point , the instructions in the dialog say Finish from any window to accept the current " Do not select Finish ; instead , select Next to continue .
We have one more key step to complete so our is set up correctly .

In the subsequent Applications Settings dialog the right image in Figu re  select the Empty .

Choose Finish when you are ready to continue .

In the Add New Item dialog box , shown on the left in Figure select and enter .

The file here will be named .
Press Add when done .

As shown on the right in Figure the Solution Explorer pane now shows the file si mple .

You may save the sou rce file at th is point by selecting Save from the File menu or by pressing pressing .

These lines indicate the build was successful .

console window appears with the output of your program .
The right image in Figure shows this text window .
You can press any key on the keyboard to close the window .
If the console window does not appear , you have typographical errors in your program ; return to the editor , fix the errors , and try to run the program again .

These are the steps for writing basic program in Visual Studio .
While the steps initially may seem complex and tedious , they will become natural after you have written few programs .

When the program was run , the Visual Studio environment created console window in which to run the program .

The first line of the output was printed by the program .
The second line prompting the user to press any key to continue is added by the Visual environment so the console window stays visible long enough for the user to see the output .
If you run the program from the standard Windows command shell , usually found in the Start menu under Accessories and named Command , only the output will appear and the any key to continue .

The following summarizes the steps you should follow when writing program using the Visual Studio .

It is possible to develop programs without using Visual integrated development ment .
Visual Studio comes with some additional tools for development .
Appendix scribes how you can edit the code with standalone text editor and compile and run the program from the Windows command prompt .
development under Linux and macOS is covered Some programmers prefer the freedom of using their favorite editor , standalone compiler , and scripts to automate the build process .

An integrated development environment like Visual Studio combines all the tools developer needs into one comprehensive application .
While this approach works well for most programmers , some velopers prefer less centralized approach , using instead command line tools to manage the development process .
Command line tools are focused and fast , and each tool itself is fairly simple compared to fullfeatured IDE .
developers may prefer different editor to one provided by the IDE .
Developers can build scripts to around command line tools to automate the building and testing process .

There are few commands that are essential for working within the environment .
These center around manipulating and using files and folders .
Our discussion assumes the Windows shell , and we will note differences with macOS and Linux as needed .
Linux and macOS are both operating systems .

When you run in Windows , the Terminal application on Mac , or bash terminal in Linux , the operating system presents console window .
You type commands into this window and receive text feedback .
Most of the commands are programs that you launch by typing their name .
The following lists common commands useful for using the .

Your location is known as the current working directory .

The command dir prints list of the files in your current working directory .
On machine the Is command performs similar work .
The command dir displays wide listing of the hies with fewer details ; the Is command is the equivalent on systems .

Subdirectories allow you to better organize your hies .

Some examples of its use include cd Code Changes the current working directory to be the named Code .
Here the name is relative to the current directory .
It is an error to provide name that does not correspond to of the current directory .

Changes the current working directory to its parent directory .
Said another way , the current working directory is itself of some other directory .
This command makes this other directory the current working directory .
The name here is known as name .
The name is an absolute location ; it is not relative to the current working directory .
systems do not have drive letter , and the backslashes would be forward slashes .

Changes the current working directory to itself , which effectively does nothing .
This command does no useful work .
The dot in this context means working .

Use this command carefully .
systems use the rm command in its place .

The move command does the same thing , and systems use the mv command to rename files .

In preparation for our programming , we can create new for our code and make that new our current working with the commands : mkdir Code cd Code We can edit our source code with simple text editor such as Notepad or Wordpad for Windows , TextEdit on the Mac , or gEdit on Linux systems .
More powerful programming editors such as http 

Mac , and make editing source code more convenient .

Visual Studio Command Line Tools .

Visual Studio provides number of command line tools as an alternative to its integrated development environment .

To use the command line tools , select the Visual Studio Command Prompt from the Start menu .
command console appears similar to the console that the IDE provides when executing program Section .
Instead of selecting menu items and interacting with dialog boxes , you type commands into the console window to build and run your program .
To edit your program you can use the editor from the IDE , or you can use standalone editor such as http 

Both and Vim provide color tax highlighting and folding like the Visual Studio editor .

In order to use the command prompt version of Visual Studio , it is convenient to first create folder in which you will place all your development files ; for example , you could create folder named Code under your Documents folder .
Suppose the full path to this folder is .

The first command you should issue in the console window is .

The cd command means " This command sets the working to the development folder you previously created .
If you are working in another folder , you can adjust the path given in the cd command to your work area .

You are ready to edit your code .
If your environment is set up so that your editor program is in the system path , you can type .

Within the editor type in your program and then save it to file .

The cl , not command , which stands for compile and link , preprocesses , compiles , and links the program .
The switch uses the Level warning level .
Level warnings provide more thorough analysis of your source code and can detect more programming mistakes .
If you omit the switch , by default the compiler operates at warning level .
Warning level is insufficient for catching many mistakes made by both beginning and experienced programmers .
By default the IDE compiler uses warning level , and the warning level can be changed by adjusting the properties .
On the command line , specifying highest warning is just as easy as specifying .
It is better to use so the compiler can do more thorough check for potential programmer mistakes .
The EHsc is required for all the programs we write .

If want to reduce the level of detail in the output produced by the compiler and linker , you can add the additional switch .

Once the program has been compiled successfully , you can run the program by entering the name of the executable produced .
In our example , we would issue the command .

The program runs in the same window ; no new window is produced .
When the program is finished executing , no any key to continue " message is printed ; you get simply command prompt ready for you to enter your next command .

If you modify your source code in your editor , you must remember to recompile your code before you run it again .
In the IDE , if you modify your code , the environment will suggest that you rebuild the project before running the program .

If the program consists of multiple source files , list all the required files on the command line .
The exe file will be named after the first file listed ; for example , the command .

Developing Programs with the GNU Tools The tools provided in the GNU Compiler Collection http 
The GNU tools are free and are available for the major computing .

Microsoft Windows GCC tools can be found at the MinGW website http 

Mac users also may use the compiler that comes .

GCC tools are readily available for all the major Linux distributions .
To get them , simply install the development packages .

The name of the GNU compiler is .
It is tool , which means it is launched from command in Windows or bash in the Mac and Linux environments .

To see how the GNU buld system works , we will consider Listing from Use an editor to create text file containing the code for Listing , and save the file with the name .
In Windows , if is installed and set up properly , in the command shell you can type .

This command brings up separate window with an editor .
We can type the source code for Listing and save the file .

To create the executable program with GNU , back in our window we issue the command simple .

This one command runs the preprocessor , followed by the compiler , and finally the linker to produce the executable program .
Even though the preprocessor and linker are also involved here , we generally simply say we are the .

It goes beyond checking that the program is it also warns about code constructs that many programmers consider questionable because code of that nature often contains errors .
The component can be interpreted to mean about as many possible problems as " You should compile all programs with this directive because it enables the compiler to catch many careless programmer mistakes that otherwise might go unnoticed .
Use of the directive is desirable for all programmers from novice to expert .

The standards committee is responsible for defining the language .
The committee refines the language specification over time .
In addition to adding new features to the language , the committee also addresses shortcomings in existing language features .
As result of the work newer compilers can check more thoroughly the validity of programs .
Modern compilers do better job of catching common programming errors .

The directive is optional because sometimes developers must work with older source .
The was written originally under more relaxed language rules , but it may not be worthwhile to rewrite the to bring it up to modern standards .
If this older has proven to be reliable , it may be compiled without the more stringent checks .
All new  however , should take advantage of the newer , better checking capabilities of the most compiler ; therefore , always use on the compiler command line for that you write .

Since this standard is relatively  you omit this part of the command , assumes the programmer is writing the source under the rules of the older , ISO standard , usually referred to as .

On Mac and Linux platforms the name of the executable file produced will be just simple exe name .
If the source contains no errors , the compiler will produce the executable file named .
On Windows Machine we can run the compiled program from the command line by typing the command simple also can use the full name , On system or , we instead would type .

Here the file must reside in our current working directory for the compiler to process it .

When you are finished with the executable file , you can delete it with the following .

Fibonacci sequence , fields , for statment , foreach , fragmentation , memory , ri end , function call , function call operator , function declaration , function definition , function invocation , function invocation operator , function objects ,

Rule of Five , Rule of Three , rvalue reference , scoped enumerations , sequence , shift , bitwise , evaluation , slice , array , smart source code formatting , specialization , class , stack overflow , standard namespace ,

Draft date : September ,
