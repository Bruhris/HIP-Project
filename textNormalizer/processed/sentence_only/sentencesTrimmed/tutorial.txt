All rights reserved This document and its content is copyright of ,
All rights reserved .

Any redistribution or reproduction of part or all of the content in any form is prohibited other than to print personal copy of the entire document or download it to local hard disk , without modifying its content in any way , but not limited to , this copyright .

You may not , except with express written permission from , distribute the content of this document .

Nor may you transmit it or store it in any other website or other form of electronic retrieval system .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved Table of contents Table of contents Introduction Instructions for use .
All rights reserved Preprocessor directives .
All rights reserved Introduction Instructions for use To whom is this tutorial directed .

This tutorial is for those people who want to learn programming in and do not necessarily have any previous knowledge of other programming languages .
Of course any knowledge of other programming languages or any general computer skill can be useful to better understand this tutorial , although it is not essential .

It is also suitable for those who need little update on the new the language has acquired from the latest standards .

If you are familiar with the language , you can take the first parts of this tutorial as review of concepts , since they mainly explain the part of .
There are slight differences in the syntax for some  so recommend you its reading anyway .

The part describes programming .

The part mostly describes the new introduced by standard .

Structure of this tutorial The tutorial is divided in parts and each part is divided on its turn into different sections covering topic each one .
You can access any section directly from the section index available on the left side bar , or begin the tutorial from any point and follow the links at the bottom of each section .

Many sections include examples that describe the use of the newly acquired knowledge in the chapter .
It is recommended to read these examples and to be able to understand each of the code lines that constitute it before passing to the next chapter .

good way to gain experience with programming language is by modifying and adding new on your own to the example programs that you fully understand .
be scared to modify the examples provided with this tutorial , the way to learn .

Compatibility Notes The standard acceptation as an international standard is relatively recent .
It was first published in November , and revised in .
Nevertheless , the language exists from long time before .

Therefore there are many compilers which do not support all the new included in , especially those released prior to the publication of the standard .

This tutorial is thought to be followed with modern compilers that support least on some specifications .
encourage you to get one if yours is not adapted .
There are many options , both commercial and free .

Compilers The examples included in this tutorial are all console programs .
That means they use text to communicate with the user and to show their results .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved All compilers support the compilation of console programs .
Check the manual of your compiler for more info on how to compile them .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved Basics of Structure of program Probably the best way to start learning programming language is by writing program .
Therefore , here is our first program : my first program in .

The first panel shows the source code for our first program .
The second one shows the result of the program once compiled and executed .
The way to edit and compile program depends on the compiler you are using .
Depending on whether it has Development Interface or not and on its version .
Consult the compilers section and the manual or help included with your compiler if you have doubts on how to compile console program .

The previous program is the typical program that programmer apprentices write for the first time , and its result is the printing on screen of the " sentence .
It is one of the simplest programs that can be written in , but it already contains the fundamental components that every program has .
We are going to look line by line at the code we have just written : my first program in This is comment line .
All lines beginning with two slash signs are considered comments and do not have any effect on the behavior of the program .
The programmer can use them to short explanations or observations within the source code itself .
In this case , the line is brief description of what our program is .

They are not regular code lines with expressions but indications for the preprocessor .
In this case the directive tells the preprocessor to the iostream standard file .
This specific file includes the declarations of the basic standard library in , and it is included because its functionality is going to be used later in the program .

So in order to access its functionality we declare with this expression that we will be using these entities .
This line is very frequent in programs that use the standard library , and in fact it will be included in most of the source codes included in these tutorials .

The main function is the point by where all programs start their execution , independently of its location within the source code .
It does not matter whether there are other functions with other names defined before or after it the instructions contained within this definition will always be the first ones to be executed in any program .
For that same reason , it is essential that all programs have main function .

The word main is followed in the code by pair of parentheses .
That is because it is function declaration : In , what differentiates function declaration from other types of expressions are these parentheses that follow its name .
Optionally , these parentheses may enclose list of parameters within them .

Right after these parentheses we can find the body of the main function enclosed in braces .
What is contained within these braces is what the function does when it is executed .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved cout ; This line is statement .
statement is simple or compound expression that can actually produce some effect .
In fact , this statement performs the only action that generates visible effect in our first program .

Notice that the statement ends with semicolon character .
This character is used to mark the end of the statement and in fact it must be included at the end of all expression statements in all programs of the most common syntax errors is indeed to forget to some semicolon after .

return code of for the main function is generally interpreted as the program worked as expected without any errors during its execution .
This is the most usual way to end console program .

You may have noticed that not all the lines of this program perform actions when the code is executed .
There were lines containing only comments beginning by .
There were lines with directives for the preprocessor beginning by .
Then there were lines that began the declaration of function this case , the main and , finally lines with statements the insertion into , which were all included within the block delimited by the braces of the main function .

The program has been structured in different lines in order to be more readable , but in , we do not have strict rules on how to separate instructions in different lines .
For example , instead of int main  Hello .

In , the separation between statements is specified with an ending semicolon at the end of each one , so the separation in different code lines does not matter at all for this purpose .
We can write many statements per line or write single statement that takes many code lines .
The division of code in different lines serves only to make it more legible and schematic for the humans that may read it .

Let us add an additional instruction to our first program : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved my second program in .

program In this case , we performed two insertions into in two different statements .
Once again , the separation in different lines of code has been done just to give greater readability to the program , since main could have been perfectly valid defined this way : int main  Hello World .

Preprocessor directives that begin by are out of this general rule since they are not statements .
They are lines read and processed by the preprocessor and do not produce any code by themselves .
Preprocessor directives must be specified in their own line and do not have to end with semicolon .

Comments Comments are parts of the source code disregarded by the compiler .

Their purpose is only to allow the programmer to insert notes or descriptions embedded within the source code .

supports two ways to insert comments : line comment block comment The first of them , known as line comment , discards everything from where the pair of slash signs is found up to the end of that same line .
The second one , known as block comment , discards everything between the characters and the first appearance of the characters , with the possibility of including more than one line .

We are going to add comments to our second program : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved my second program in with more comments .

program return ; Hello World .
program If you comments within the source code of your programs without using the comment characters combinations , or , the compiler will take them as if they were expressions , most likely causing one or several error messages when you compile it .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved Variables .

The usefulness of the World " programs shown in the previous section is quite questionable .
We had to write several lines of code , compile them , and then execute the resulting program just to obtain simple sentence written on the screen as result .
It certainly would have been much faster to type the output sentence by ourselves .

However , programming is not limited only to printing simple texts on the screen .
In order to go little further on and to become able to write programs that perform useful tasks that really save us work we need to introduce the concept of variable .

Let us think that ask you to retain the number in your mental memory , and then ask you to memorize also the number at the same time .
You have just stored two different values in your memory .
Now , if ask you to add to the first number said , you should be retaining the numbers is and in your memory .
Values that we could now for example subtract and obtain as .

The whole process that you have just done with your mental memory is simile of what computer can do with two variables .
The same process can be expressed in with the following instruction set : +  Obviously , this is very simple example since we have only used two small integer values , but consider that your computer can store millions of numbers like these at the same time and conduct sophisticated mathematical operations with them .

Therefore , we can define variable as portion of memory to store determined value .

Each variable needs an identifier that distinguishes it from the others , for example , in the previous code the variable identifiers were  and  but we could have called the variables any names we wanted to invent , as long as they were valid identifiers .

Identifiers valid identifier is sequence of one or more letters , digits or underscore characters .
Neither spaces nor punctuation marks or symbols can be part of an identifier .
Only letters , digits and single underscore characters are valid .
In addition , variable identifiers always have to begin with letter .
They can also begin with an underline character , but in some cases these may be reserved for compiler specific keywords or external identifiers , as well as identifiers containing two successive underscore characters anywhere .
In no case they can begin with digit .

Another rule that you have to consider when inventing your own identifiers is that they cannot match any keyword of the language nor your specific ones , which are reserved keywords .
The standard reserved keywords are : asm , auto , bool , break , case , catch , char , class , const , continue , default , delete , do , double , else , enum , explicit , export , extern , false , float , for , friend , goto , if , inline , int , long , mutable , namespace ,   private , protected , public , register , return , short , signed , sizeof , static , struct , switch , template , this , throw , true , try , typedef , typeid , typename , union , unsigned , using , virtual , void , volatile , while Additionally , alternative representations for some operators cannot be used as identifiers since they are reserved words under some circumstances : and , bitand , bitor , compl , not , or , xor , TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved Your compiler may also some additional specific reserved keywords .

Very important : The language is sensitive " language .
That means that an identifier written in capital letters is not equivalent to another one with the same name but written in small letters .
Thus , for example , the RESULT variable is not the same as the variable or the Result variable .
These are three different variable identifiers .

Fundamental data types When programming , we store the variables in our memory , but the computer has to know what kind of data we want to store in them , since it is not going to occupy the same amount of memory to store simple number than to store single letter or large number , and they are not going to be interpreted the same way .

The memory in our computers is organized in bytes .
byte is the minimum amount of memory that we can manage in .
byte can store relatively small amount of data : one single character or small integer an integer between and .
In addition , the computer can manipulate more complex data types that come from grouping several bytes , such as long numbers or numbers .

Next you have summary of the basic fundamental data types in , as well as the range of values that can be represented with each one : Name Description char Character or small integer .

It can take one of two values : true or false .

The values shown above are those found on most systems .
But for other systems , the general specification is that int has the natural size suggested by the system architecture and the four integer types char , short , int and long must each one be at least as large as the one preceding it , with char being always byte in size .

The same applies to the floating point types float , double and long double , where each one must provide at least as much precision as the preceding one .

Declaration of variables In order to use in , we must first declare it specifying which data type we want it to be .
The syntax to declare is to write the specifier of the desired data type int , bool , followed by valid identifier .
For example : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved int ; float mynumber ; These are two valid declarations of variables .
The first one declares of type int with the identifier .
The second one declares of type float with the identifier mynumber .
Once declared , the variables and mynumber can be used within the rest of their scope in the program .

If you are going to declare more than one of the same type , you can declare all of them in single statement by separating their identifiers with commas .
For example : int , c ; This declares three variables , and , all of them of type int , and has exactly the same meaning as : int ; int ; int c ; The integer data types char , short , long and int can be either signed or unsigned depending on the range of numbers needed to be represented .
Signed types can represent both positive and negative values , whereas unsigned types can only represent positive values .
This can be specified by using either the specifier signed or the specifier unsigned before the type name .
For example : unsigned short int NumberOfSisters ; signed int MyAccountBalance ; By default , if we do not specify either signed or unsigned most compiler settings will assume the type to be signed , therefore instead of the second declaration above we could have written : int MyAccountBalance ; with exactly the same meaning or without the keyword An exception to this general rule is the char type , which exists by itself and is considered different fundamental data type from signed char and unsigned char , thought to store characters .
You should use either signed or unsigned if you intend to store numerical values in .

In this case , they refer to their respective integer fundamental types : short is equivalent to short int and long is equivalent to long int .
The following two declarations are equivalent : short Year ; short int Year ; Finally , signed and unsigned may also be used as standalone type specifiers , meaning the same as signed int and unsigned int respectively .
The following two declarations are equivalent : unsigned NextYear ; unsigned int NextYear ; To see what declarations look like in action within program , we are going to see the code of the example about your mental memory proposed at the beginning of this section : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved operating with variables .

You will see the rest in detail in coming sections .

Scope of variables All the variables that we intend to use in program must have been declared with its type specifier in an earlier point in the code , like we did in the previous code at the beginning of the body of the function main when we declared that   and were of type int .

can be either of global or local scope .
global is declared in the main body of the source code , outside all functions , while local is one declared within the body of function or block .

Global variables can be referred from anywhere in the code , even inside functions , whenever it is after its declaration .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved The scope of local variables is limited to the block enclosed in braces where they are declared .
For example , if they are declared at the beginning of the body of function in function their scope is between its declaration point and the end of that function .
In the example above , this means that if another function existed in addition to main , the local variables declared in main could not be accessed from the other function and vice versa .

Initialization of variables When declaring regular local variable , its value is by default undetermined .
But you may want variable to store concrete value at the same moment that it is declared .
In order to do that , you can initialize the variable .
There are two ways to do this in : The first one , known as , is done by appending an equal sign followed by the value to which the variable will be initialized : type  For example , if we want to declare an int variable called initialized with value of at the moment in which it is declared , we could write : int ; The other way to initialize variables , known as constructor initialization , is done by enclosing the initial value between parentheses : type  For example : int ; Both ways of initializing variables are valid and equivalent in .

The language library provides support for strings through the standard string class .
This is not fundamental type , but it behaves in similar way as fundamental types do in its most basic usage .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved first difference with fundamental data types is that in order to declare and use objects of this type we need to an additional header file in our source code : and have access to the std namespace we already had in all our previous programs thanks to the using namespace .

Both initialization formats are valid with strings : string is ; string is ; Strings can also perform all the other basic operations that fundamental data types can , like being declared without an initial and being assigned values during .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved Constants Constants are expressions with fixed .

Literals Literals are used to express particular values within the source code of program .
We have already used these previously to give concrete values to variables or to express messages we wanted our programs to print out , for example , when we wrote : the in this piece of code was literal constant .

Literal constants can be divided in Integer Numerals , Numerals , Characters , Strings and Boolean Values .

Integer Numerals They are numerical constants that identify integer decimal values .
Notice that to express numerical constant we do not have to write quotes nor any special character .
There is no doubt that it is constant : whenever we write in program , we will be referring to the .

In addition to decimal numbers that all of us are used to use every allows the use as literal constants of octal numbers and hexadecimal numbers .
If we want to express an octal number we have to precede it with .
And in order to express hexadecimal number we have to precede it with the characters ,
For example , the following literal constants are all equivalent to each other : decimal octal hexadecimal All of these represent the same number : expressed as numeral , octal numeral and hexadecimal numeral , respectively .

Literal constants , like variables , are considered to have specific data type .
By default , integer literals are of type int .
However , we can force them to either be unsigned by appending the character to it , or long by appending .

In both cases , the suffix can be specified using either upper or lowercase letters .

Floating Point Numbers They express numbers with decimals exponents .
They can either decimal point , an character expresses ten at the Xth , where is an integer that follows the , or both decimal point and an character : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved .

These are four valid numbers with decimals expressed in .
The first number is PI , the second one is the number of Avogadro , the third is the electric charge of an electron extremely small of them and the last one is the number three expressed as numeric literal .

The default type for floating point literals is double .
If you explicitly want to express float or long double numerical literal , you can use the or suffixes respectively : long double float Any of the letters that can be part of numerical constant , can be written using either lower or uppercase letters without any difference in their meanings .

Character and string literals There also exist constants , like : world " do you " The first two expressions represent single character constants , and the following two represent string literals composed of several characters .
Notice that to represent single character we enclose it between single quotes and to express string generally consists of more than one we enclose it between double quotes .

When writing both single character and string literals , it is necessary to put the quotation marks surrounding them to distinguish them from possible variable identifiers or reserved keywords .
Notice the difference between these two expressions : alone would refer to variable whose identifier is , whereas ' within single quotation would refer to the character constant .

Character and string literals have certain peculiarities , like the escape codes .
These are special characters that are difficult or impossible to express otherwise in the source code of program , like newline or tab .
All of them are preceded by backslash .
Here you have list of some of such escape codes : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved newline carriage return tab vertical tab backspace form feed alert ' single quote " double quote .
In the first case the digits must immediately follow the backslash example or , in the second case , an character must be written before the digits themselves example or .

String literals can extend to more than single line of code by putting backslash sign at the end of each unfinished line .

Boolean literals There are only two valid Boolean values : true and false .
These can be expressed in as values of type bool by using the Boolean literals true and false .

Defined constants You can define your own names for constants that you use very often without having to resort to memoryconsuming variables , simply by using the preprocessor directive .
Its format is : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved identifier value For example : PI NEWLINE ' This defines two new  PI and NEWLINE .
Once they are defined , you can use them in the rest of the code as if they were any other regular constant , for example : defined  calculate circumference using namespace std ; PI NEWLINE ' int main double ; radius double  PI  cout  cout NEWLINE ; return ; In fact the only thing that the compiler preprocessor does when it encounters directives is to literally replace any occurrence of their identifier the previous example , these were PI and by the code to which they have been defined and '

The directive is not statement but directive for the preprocessor ; therefore it assumes the entire line as the directive and does not require semicolon at its end .
If you append semicolon character at the end , it will also be appended in all occurrences within the body of the program that the preprocessor replaces .

Declared With the const prefix you can declare with specific type in the same way as you would do with variable : const int ; const char ; Here , and are two typed .
They are treated just like regular variables except that their values cannot be modified after their definition .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved Operators Once we know of the existence of variables and  we can begin to operate with them .
For that purpose , integrates operators .
Unlike other languages whose operators are mainly keywords , operators in are mostly made of signs that are not part of the alphabet but are available in all keyboards .
This makes code shorter and more international , since it relies less on English words , but requires little of learning effort in the beginning .

You do not have to memorize all the content of this page .
Most details are only provided to serve as later reference in case you need it .

The part at the left of the assignment is known as the lvalue and the right one as the rvalue .
The lvalue has to be variable whereas the rvalue can be either constant , variable , the result of an operation or any combination of these .

The most important rule when assigning is the rule : The assignment operation always takes place from right to left , and never the other way : This statement assigns to variable the contained in variable .
The that was stored until this moment in is not considered at all in this operation , and in fact that is lost .

Consider also that we are only assigning the of to at the moment of the assignment operation .
Therefore later change of will not affect the new of .

For example , let us have look at the following code have included the evolution of the content stored in the variables as comments : assignment .

Notice how was not affected by the final modification of  even though we declared earlier is because of the .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved property that has over other programming languages is that the assignment operation can be used as the rvalue part of an for another assignment operation .
For example : + is equivalent to : +  that means : first assign to variable and then assign to the plus the result of the previous assignment of .

The following expression is also valid in : It assigns to the all the three variables :  and .

Arithmetic operators + The five arithmetical operations supported by the language are : + addition subtraction multiplication division modulo Operations of addition , subtraction , multiplication and division literally correspond with their respective mathematical operators .
The only one that you might not be so used to see is modulo ; whose is the percentage sign .
Modulo is the operation that gives the remainder of division of two values .
For example , if we write : the variable will contain the , since is the remainder from dividing between .

For example : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved compound operators .

Thus : are all equivalent in its functionality : the three of them increase by one the of .

In the early compilers , the three previous expressions probably produced different executable code depending on which one was used .
Nowadays , this type of code optimization is generally done automatically by the compiler , thus the three expressions should produce exactly the same executable code .

characteristic of this operator is that it can be used both as prefix and as suffix .
That means that it can be written either before the variable identifier or after it .
Although in simple expressions like or both have exactly the same meaning , in other expressions in which the result of the increase or decrease operation is evaluated as in an outer expression they may have an important difference in their meaning : In the case that the increase operator is used as prefix the is increased before the result of the expression is evaluated and therefore the increased is considered in the outer expression ; in case that it is used as suffix the stored in is increased after being evaluated and therefore the stored before the increase operation is evaluated in the outer expression .
Notice the difference : Example Example ; contains , contains ; contains , contains In Example , is increased before its is copied .
While in Example , the of is copied and then is increased .

Relational and equality , In order evaluate comparison between two expressions we can use the relational and equality .
The result of relational operation is Boolean that can only be true or false , according its Boolean result .

We may want compare two expressions , for example , know if they are equal or if one is greater than the other is .
Here is list of the relational and equality that can be used in : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved Equal Not equal Greater than Less than Greater than or equal Less than or equal Here there are some .

Thus , in the last expression , we first assigned the and then we compared it  that also stores the , so the result of the operation is true .

Logical , Operator .
Basically , it returns the opposite Boolean of evaluating its operand .
For example : evaluates false the expression at its is true .

This operation results true if both its two operands are true , and false otherwise .
This operation results true if either of its two operands is true , thus being false only when both operands are false themselves .
Here are the possible results of  TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved OPERATOR true true true true false true false true true false false false For example : evaluates false true false .

Its format is : condition .

Comma  comma is used to separate two or more expressions that are included where only expression is expected .
When the set of expressions has to be evaluated for value , only the rightmost expression is considered .

For example , the following code : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved Would first assign the value to  and then assign to variable .
So , at the end , variable would contain the value while variable would contain value .

Bitwise Operators , Bitwise operators modify variables considering the bit patterns that represent the values they store .

The simplest one , which has been inherited from the language , is to precede the expression to be converted by the new enclosed between parentheses : int  float ;  The previous code converts the float number to an integer value , the remainder is lost .
Here , the typecasting operator was .
Another way to do the same thing in is using the functional notation : preceding the expression to be converted by the and enclosing the expression between parentheses : int ; Both ways of casting are valid in .

The value returned by sizeof is constant , so it is always determined before program execution .

Other operators Later in these tutorials , we will see few more operators , like the ones referring to pointers or the specifics for programming .
Each one is treated in its respective section .

Precedence of operators When writing complex expressions with several operands , we may have some doubts about which operand is evaluated first and which later .
For example , in this expression : + TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved we may doubt if it really means : + with result of , or + with result of The correct answer is the first of the two expressions , with result of .
There is an established order with the priority of each operator , and not only the arithmetic ones whose preference come from but for all the operators which can appear in .
From greatest to lowest priority , the priority order is as follows : Level Operator Description Grouping : scope .

All these precedence levels for operators can be manipulated or become more legible by removing possible ambiguities using parentheses signs and , as in this example : + TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved might be written either as : + or + depending on the operation that we want to perform .

So if you want to write complicated expressions and you are not completely sure of the precedence levels , always include parentheses .
It will also become code easier to read .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved Basic Until now , the example programs of previous sections provided very little interaction with the user , if any at all .

Using the standard input and output library , we will be able to interact with the user by printing messages on the screen and getting the input from the keyboard .

uses convenient abstraction called streams to perform input and output operations in sequential media such as the screen or the keyboard .
stream is an object where program can either insert or extract characters it .
We do not really need to care about many specifications about the physical media associated with the stream we only need to know it will accept or provide characters sequentially .

The standard library includes the header file iostream , where the standard input and output stream objects are declared .

Standard Output By default , the standard output of program is the screen , and the stream object defined to access it is .

In the examples above it inserted the constant string Output sentence , the numerical constant and variable into the standard output stream .

Notice that the sentence in the first instruction is enclosed between double quotes because it is constant string of characters .
Whenever we want to use constant strings of characters we must enclose them between double quotes so that they can be clearly distinguished from variable names .
For example , these two sentences have very different results : prints Hello Hello ; prints the content of Hello variable The insertion operator may be used more than once in single statement :  am   This last statement would print the message Hello , am statement on the screen .
The utility of repeating the insertion operator is demonstrated when we want to print out combination of variables and constants or more than one variable : am  age  years old and my zipcode is  zipcode ; If we assume the age variable to contain the value and the zipcode variable to contain the output of the previous statement would be : Hello , am years old and my zipcode is It is important to notice that does not add line break after its output unless we explicitly indicate it , therefore , the following statements : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved is ; is another ; will be shown on the screen one following the other without any break between them : This is is another sentence .

In order to perform break on the output we must explicitly insert character into .
In character can be specified as , This produces the following output : First sentence .

Additionally , to add , you may also use the endl manipulator .
For example : endl ; endl ; would print out : First sentence .

The endl manipulator produces newline character , exactly as the insertion of ' does , but it also has an additional behavior when it is used with buffered streams : the buffer is flushed .
Anyway , will be an unbuffered stream in most cases , so you can generally use both the escape character and the endl manipulator in order to specify new without any difference in its behavior .

Standard Input .

The standard input device is usually the keyboard .
Handling the standard input in is done by applying the overloaded operator of extraction on the cin stream .
The operator must be followed by the variable that will store the data that is going to be extracted from the stream .
For example : int age ; cin age ; The first statement declares variable of type int called age , and the second one waits for an input from cin in order to store it in this integer variable .

Therefore , even if you request single character , the extraction from cin will not process the input until the user presses RETURN after the character has been introduced .

You must always consider the type of the variable that you are using as container with cin extractions .
If you request an integer you will get an integer , if you request character you will get character and if you request string of characters you will get string of characters .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved example .

The user of program may be one of the factors that generate errors even in the simplest programs that use cin the one we have just .
Since if you request an integer value and the user introduces name generally is string of , the result may cause your program to misoperate since it is not what we were expecting from the user .
So when you use the data input provided by cin extractions you will have to trust that the user of your program will be cooperative and that will not introduce name or something similar when an integer value is requested .
little ahead , when we see the stringstream class we will see possible solution for the errors that can be caused by this type of user input .

You can also use cin to request more than one datum input from the user : cin ; is equivalent to : cin ; cin ; In both cases the user must give two data , one for variable and another one for variable that may be separated by any valid blank separator : space , tab character or newline .

This behavior may or may not be what we want ; for example if we want to get sentence from the user , this extraction operation would not be useful .

In order to get entire lines , we can use the function getline , which is the more recommendable way to get user input with cin : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved .

Juan Hello Juan .

What is your favorite team .
The Isotopes like The Isotopes too .

Notice how in both calls to getline we used the same string identifier .
What the program does in the second call is simply to replace the previous content by the new that is introduced .

This way we can perform extraction or insertion operations strings , which is especially useful to convert strings to numerical values and vice versa .
For example , if we want to extract an integer from string we can write : string mystr ; int myint ; myint ; This declares string object with value of , and an int object .
Then we use constructor to construct an object of this type from the string object .
Because we can use stringstream objects as if they were streams , we can extract an integer from it as we would have done on cin by applying the extractor operator on it followed by variable of type int .

After this piece of code , the variable myint will contain the numerical value .

Instead of extracting numeric values directly from the standard input , we get lines from the standard input into string object , and then we extract the integer values from this string into variable of type int .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved Using this method , instead of direct extractions of integer values , we have more control over what happens with the input of numeric values from the user , since we are separating the process of obtaining input from the user now simply ask for with the interpretation of that input .
Therefore , this method is usually preferred to get numerical values from the user in all programs that are intensive in user input .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved Control Structures Control Structures program is usually not limited to linear sequence of instructions .
During its process it may bifurcate , repeat code or take decisions .
For that purpose , provides control structures that serve to specify what has to be done by our program , when and under which circumstances .

With the introduction of control structures we are going to have to introduce new  the compoundstatement or block .
block is group of statements which are separated by semicolons like all statements , but grouped together in block enclosed in braces : Most of the control structures that we will see in this section require generic statement as part of its syntax .
statement can be either simple statement simple instruction ending with or compound statement instructions grouped in , like the just described .
In the case that we want the statement to be simple statement , we do not need to enclose it in braces .
But in the case that we want the statement to be compound statement it must be enclosed between braces , forming block .

Conditional structure : if and else The if keyword is used to execute statement or block only if condition is fulfilled .
Its form is : if statement Where condition is the expression that is being evaluated .
If this condition is true , statement is executed .
If it is false , statement is ignored and the program continues right after this conditional structure .

For example , the following code fragment prints is only if the value stored in the variable is indeed : if cout  is ; If we want more than single statement to be executed in case that the condition is true we can specify block using braces : if cout  is ; cout  We can additionally specify what we want to happen if the condition is not fulfilled by using the keyword else .
Its form used in conjunction with if is : if else For example : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved if cout  is ; else cout  is not ; prints on the screen is if indeed has value of , but if it has not only if it prints out is not .

The if + else structures can be concatenated with the intention of verifying range of values .
The following example shows its use telling if the value currently stored in is positive , negative or none of them .

Iteration structures Loops have as purpose to repeat statement certain number of times or while condition is fulfilled .

The while loop Its format is : while statement and its functionality is simply to repeat statement while the condition set in expression is true .

For example , we are going to make program to countdown using : custom countdown using while .

When the program starts the user is prompted to insert starting number for the countdown .
Then the while loop begins , if the value entered by the user fulfills the condition is greater than the block that follows the condition will be executed and repeated while the condition remains being true .

The whole process of the previous program can be interpreted according to the following script in : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved .

User assigns value to .

The while condition is checked .
At this point there are two posibilities : condition is true : statement is executed step condition is false : ignore statement and continue after it step .

Execute statement : cout , the value of on the screen and decreases by .

End of block .
Return automatically to step .

Continue the program right after the block : print FIRE .

When creating , we must always consider that it has to end at some point , therefore we must provide within the block some method to force the condition to become false at some point , otherwise the loop will continue looping forever .
In this case we have included ; that decreases the value of the variable that is being evaluated in the condition by one this will eventually make the condition to become false after certain number of loop iterations : to be more specific , when becomes , that is where our and our countdown end .

Of course this is such simple action for our computer that the whole countdown is performed instantly without any practical delay between numbers .

The loop Its format is : do statement while ; Its functionality is exactly the same as the while loop , except that condition in the loop is evaluated after the execution of statement instead of before , granting at least one execution of statement even if condition is never fulfilled .
For example , the following example program echoes any number you enter until you enter .

In fact if you never enter the value in the previous example you can be prompted for more numbers forever .

The for loop Its format is : for ; condition ; statement ; TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved and its main function is to repeat statement while condition remains true , like the while loop .
But in addition , the for loop provides specific locations to contain an initialization statement and an increase statement .
So this loop is specially designed to perform repetitive action with counter which is initialized and increased on each iteration .

It works in the following way :

Generally it is an initial value setting for counter variable .
This is executed only once .

If it is true the loop continues , otherwise the loop ends and statement is skipped .

As usual , it can be either single statement or block enclosed in braces .

Here is an example of countdown using for loop : countdown using for loop .

The initialization and increase fields are optional .
They can remain empty , but in all cases the semicolon signs between them must be written .
For example we could write : for if we wanted to specify no initialization and no increase ; or for if we wanted to an increase field but no initialization because the variable was already initialized .

Optionally , using the comma operator we can specify more than one expression in any of the fields included in for loop , like in initialization , for example .
The comma operator is an expression separator , it serves to separate more than one expression where only one is generally expected .
For example , suppose that we wanted to initialize more than one variable in our loop : for ,   whatever .

Because is increased by one and decreased by one , the condition will become false after the loop , when both and will be equal to .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved Jump statements .

The break statement Using break we can leave loop even if the condition for its end is not fulfilled .
It can be used to end an infinite loop , or to force it to end before its natural end .
For example , we are going to stop the count down before its natural end because of an engine check : break loop example .

The continue statement The continue statement causes the program to skip the rest of the loop in the current iteration as if the end of the statement block had been reached , causing it to jump to the start of the following iteration .
For example , we are going to skip the number in our countdown : continue loop example .

The goto statement goto allows to make an absolute jump to another point in the program .
You should use this feature with caution since its execution causes an unconditional jump ignoring any type of nesting limitations .

The destination point is identified by label , which is then used as an argument for the goto statement .
label is made of valid identifier followed by colon .

Generally speaking , this instruction has no concrete use in structured or object oriented programming aside from those that programming fans may find for it .
For example , here is our countdown loop using goto : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved goto loop example .

The exit function exit is function defined in the cstdlib library .

The purpose of exit is to terminate the current program with specific exit code .
Its prototype is : void exit ; The exitcode is used by some operating systems and may be used by calling programs .
By convention , an exit code of means that the program finished normally and any other value means that some error or unexpected results happened .

The selective structure : switch .

The syntax of the switch statement is bit peculiar .
Its objective is to check several possible constant values for an expression .
Something similar to what we did at the beginning of this section with the concatenation of several if and else if instructions .
Its form is the following : switch case : group of statements ; break ; case : group of statements ;

When it finds this break statement the program jumps to the end of the switch selective structure .

If expression was not equal to it will be checked against .
If it is equal to this , it will execute group of statements until break keyword is found , and then will jump to the end of the switch selective structure .

Finally , if the value of expression did not match any of the previously specified constants can as many case labels as values you want to , the program will execute the statements included after the default : label , if it exists it is .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved Both of the following code fragments have the same behavior : switch example equivalent switch case : cout  is ; break ; case : cout  is ; break ; default : cout of ;

This forces us to put break statements after the group of statements that we want to be executed for specific condition .
Otherwise the remainder statements those corresponding to other will also be executed until the end of the switch selective block or break statement is reached .

For example , if we did not break statement after the first group for case one , the program will not automatically jump to the end of the switch selective block and it would continue executing the rest of statements until it reaches either break instruction or the end of the switch selective block .
This makes unnecessary to braces surrounding the statements for each of the cases , and it can also be useful to execute the same block of instructions for different possible values for the expression being evaluated .
For example : switch case : case : case : cout  is , or ; break ; default : cout  is not , nor ; Notice that switch can only be used to compare an expression against constants .
Therefore we cannot put variables as labels example case  where is or ranges because they are not valid constants .

If you need to check ranges or values that are not constants , use concatenation of if and else if statements .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved Functions Using functions we can structure our programs in more modular way , accessing all the potential that structured programming can offer to us in .

function is group of statements that is executed when it is called from some point of the program .
The following is its format : type name , statements .

They allow to pass arguments to the function when it is called .
The different parameters are separated by commas .

It is block of statements surrounded by braces .

Here you have the first function example : function example .

So we will begin there .

We can see how the main function begins by declaring the variable of type int .
Right after that , we see call to function called addition .
Paying attention we will be able to see the similarity between the structure of the call to the function and the declaration of the function itself some code lines above : The parameters and arguments have clear correspondence .
Within the main function we called to addition passing two values : and , that correspond to the int and int parameters declared for function addition .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved At the point at which the function is called from within main , the control is lost by main and passed to function addition .
The value of both arguments passed in the call and are copied to the local variables int and int within the function .

Function addition declares another local variable , and by means of the expression , it assigns to the result of plus .
Because the actual parameters passed for and are and respectively , the result is .

The following line of code : return ; finalizes function addition , and returns the control back to the function that called it in the first place this case ,
At this moment the program follows it regular course from the same point at which it was interrupted by the call to addition .
But additionally , because the return statement in function addition specified value : the content of variable , which at that moment had value of .
This value becomes the value of evaluating the function call .

So being the value returned by function the value given to the function call itself when it is evaluated , the variable will be set to the value returned by addition , that is .
To explain it another way , you can imagine that the call to function is literally replaced by the value it returns .

The following line of code in main is : cout result is   That , as you may already expect , produces the printing of the result on the screen .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved Scope of variables The scope of variables declared within function or any other inner block is only their own function or their own block and cannot be used outside of them .
For example , in the previous example it would have been impossible to use the variables , or directly in function main since they were variables local to function addition .
Also , it would have been impossible to use the variable directly within function addition , since this was variable local to the function main .

Therefore , the scope of local variables is limited to the same block level in which they are declared .
Nevertheless , we also have the possibility to declare global variables ; These are visible from any point of the code , inside and outside all functions .
In order to declare global variables you simply have to declare the variable outside any function or block ; that means , directly in the body of the program .

And here is another example about functions : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved function example .

The only thing that this function does is to subtract both passed parameters and to return the result .

Nevertheless , if we examine function main we will see that we have made several calls to function subtraction .

We have used some different calling methods so that you see other ways or moments when function can be called .

In order to fully understand these examples you must consider once again that call to function could be replaced by the value that the function call itself is going to return .
For example , the first case you should already know because it is the same pattern that we have used in previous : subtraction ; cout first result is   If we replace the function call by the value it returns , we would have : cout first result is   As well as cout second result is  subtraction ; has the same result as the previous call , but in this case we made the call to subtraction directly as an insertion parameter for cout .
Simply consider that the result is the same as if we had written : cout second result is  since is the value returned by subtraction .

In the case of : cout third result is  subtraction ; TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved The only new that we introduced is that the parameters of subtraction are variables instead of constants .

That is perfectly valid .
In this case the values passed to function subtraction are the values of and  that are and respectively , giving as result .

The fourth case is more of the same .
Simply note that instead of : + subtraction ; we could have written : subtraction + with exactly the same result .
have switched places so you can see that the semicolon sign goes at the end of the whole statement .
It does not necessarily have to go right after the function call .
The explanation might be once again that you imagine that function can be replaced by its returned value : + + Functions with no type .

If you remember the syntax of function declaration : type name , statement you will see that the declaration begins with type , that is the type of the function itself , the type of the datum that will be returned by the function with the return .
But what if we want to return no value .

Imagine that we want to make function just to show message on the screen .
We do not need it to return any value .
In this case we should use the void type specifier for the function .
This is special specifier that indicates absence of type .

For example , function printmessage could have been declared as : void printmessage cout ; Although it is optional to specify void in the parameter list .
In , parameter list can simply be left blank if we want function with no parameters .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved What you must always remember is that the format for calling function includes specifying its name and enclosing its parameters between parentheses .
The of parameters does not exempt us from the obligation to write the parentheses .
For that reason the call to printmessage is : printmessage ; The parentheses clearly indicate that this is call to function and not the name of variable or some other statement .
The following call would have been incorrect : printmessage ; TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved Functions Arguments passed by value and by reference .

Until now , in all the functions we have seen , the arguments passed to the functions have been passed by value .

This means that when calling function with parameters , what we have passed to the function were copies of their values but never the variables themselves .
For example , suppose that we called our first function addition using the following code : int ,  addition  What we did in this case was to call to function addition passing the values of and 

This way , when the function addition is called , the value of its local variables and become and respectively , but any modification to either or within the function addition will not have any effect in the values of and outside it , because variables and were not themselves passed to the function , but only copies of their values at the moment the function was called .

But there might be some cases where you need to manipulate from inside function the value of an external variable .
For that purpose we can use arguments passed by reference , as in the function duplicate of the following example : passing parameters by reference .

This ampersand is what specifies that their corresponding arguments are to be passed by reference instead of by value .

When variable is passed by reference we are not passing copy of its value , but we are somehow passing the variable itself to the function and any modification that we do to the local variables will have an effect in their counterpart variables passed as arguments in the call to the function .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved To explain it in another way , we associate  and with the arguments passed on the function call , and and any change that we do on within the function will affect the value of outside it .
Any change that we do on will affect  and the same with and .

That is why our output , that shows the values stored in  and after the call to duplicate , shows the values of all the three variables of main doubled .

If when declaring the following function : void duplicate   we had declared it this way : void duplicate  int  int , without the ampersand signs , we would have not passed the variables by reference , but copy of their values instead , and therefore , the output on screen of our program would have been the values of  and without having been modified .

Passing by reference is also an effective way to allow function to return more than one value .
For example , here is function that returns the previous and numbers of the first parameter passed .

When declaring function we can specify default value for each of the last parameters .
This value will be used if the corresponding argument is left blank when calling to the function .
To do that , we simply have to use the assignment operator and value for the arguments in the function declaration .
If value for that parameter is not passed when the function is called , the default value is used , but if value is specified this default value is ignored and the passed value is used instead .
For example : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved default values in functions .

In the first one : divide we have only specified one argument , but the function divide allows up to two .
So the function divide has assumed that the second parameter is since that is what we have specified to happen if this parameter was not passed the function declaration , which finishes with int , not just int .

In the second call : divide there are two parameters , so the default value for is ignored and takes the value passed as argument , that is , making the result returned equal to .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved Overloaded functions .

In two different functions can have the same name if their parameter types or number are different .
That means that you can give the same name to more than one function if they have either different number of parameters or different types in their parameters .
For example : overloaded function .

The compiler knows which one to call in each case by examining the types passed as arguments when the function is called .
If it is called with two ints as its arguments it calls to the function that has two int parameters in its prototype and if it is called with two floats it will call to the one which has two float parameters in its prototype .

In the first call to operate the two arguments passed are of type int , therefore , the function with the first prototype is called ; This function returns the result of multiplying both parameters .
While the second call passes two arguments of type float , so the function with the second prototype is called .
This one has different behavior : it divides one parameter by the other .
So the behavior of call to operate depends on the type of the arguments passed because the function has been overloaded .

Notice that function cannot be overloaded only by its return type .
At least one of its parameters must have different type .

The inline specifier indicates the compiler that inline substitution is preferred to the usual function call mechanism for specific function .
This does not change the behavior of function itself , but is used to suggest to the compiler that the code generated by the function body is inserted at each point the function is called , instead of being inserted only once and perform regular call to it , which generally involves some additional overhead in running time .

The format for its declaration is : inline type name arguments .
You do not have to the inline keyword when calling the function , only in its declaration .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved Most compilers already optimize code to generate inline functions when it is more convenient .
This specifier only indicates the compiler that inline is preferred for this function .

Recursivity is the property that functions have to be called by themselves .
It is useful for many tasks , like sorting or calculate the factorial of numbers .
For example , to obtain the factorial of number the mathematical formula would be :

This function has limitation because of the data type we used in its design for more simplicity .
The results given will not be valid for values much greater than .

Until now , we have defined all of the functions before the first appearance of calls to them in the source code .

These calls were generally in function main which we have always left at the end of the source code .
If you try to repeat some of the examples of functions described so far , but placing the function main before any of the other functions that were called from within it , you will most likely obtain compiling errors .
The reason is that to be able to call function it must have been declared in some earlier point of the code , like we have done in all our examples .

But there is an alternative way to avoid writing the whole code of function before it can be used in main or in some other function .
This can be achieved by declaring just prototype of the function before it is used , instead of the entire definition .
This declaration is shorter than the entire definition , but significant enough for the compiler to determine its return type and the types of its parameters .

Its form is : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved type name , It is identical to function definition , except that it does not the body of the function itself , the function statements that in normal definitions are enclosed in braces and instead of that we end the prototype declaration with mandatory semicolon .

The parameter enumeration does not need to the identifiers , but only the type specifiers .
The inclusion of name for each parameter as in the function definition is optional in the prototype declaration .
For example , we can declare function called protofunction with two int parameters with any of the following declarations : int protofunction first , int ; int protofunction , Anyway , including name for each variable makes the prototype more legible .

Type to : Number is even .

Type to : Number is even .

Type to : Number is even .

This example is indeed not an example of efficiency .
am sure that at this point you can already make program with the same result , but using only half of the code lines that have been used in this example .
Anyway this example illustrates how prototyping works .
Moreover , in this concrete example the prototyping of at least one of the two functions is necessary in order to compile the code without errors .

The first things that we see are the declaration of functions odd and even : void odd ; void even ; This allows these functions to be used before they are defined , for example , in main , which now is located where some people find it to be more logical place for the start of program : the beginning of the source code .

Anyway , the reason why this program needs at least one of the functions to be declared before it is defined is because in odd there is call to even and in even there is call to odd .
If none of the two functions had been TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved previously declared , compilation error would happen , since either odd would not not be visible from even it has still not been , or even would not be visible from odd the same .

Having the prototype of all functions together in the same place within the source code is found practical by some programmers , and this can be easily achieved by declaring all functions prototypes at the beginning of program .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved Compound data types Arrays An array is series of elements of the same type placed in contiguous memory locations that can be individually referenced by adding an index to unique identifier .

That means that , for example , we can store values of type int in an array without having to declare different variables , each one with different identifier .
Instead of that , using an array we can store different values of the same type , int for example , with unique identifier .

For example , an array to contain integer values of type int called billy could be represented like this : where each blank panel represents an element of the array , that in this case are integer values of type int .
These elements are numbered from to since in arrays the first index is always , independently of its length .

Like regular variable , an array must be declared before it is used .
typical declaration for an array in is : type name ; where type is valid type int , name is valid identifier and the elements field is always enclosed in square brackets , specifies how many of these elements the array has to contain .

Therefore , in order to declare an array called billy as the one shown in the above diagram it is as simple as : int billy ; NOTE : The elements field within brackets which represents the number of elements the array is going to hold , must be constant value , since arrays are blocks of memory whose size must be determined before execution .
In order to create arrays with variable length dynamic memory is needed , which is explained later in these tutorials .

When declaring regular array of local scope function , for , if we do not specify otherwise , its elements will not be initialized to any value by default , so their content will be undetermined until we store some value in them .
The elements of global and static arrays , on the other hand , are automatically initialized with their default values , which for all fundamental types this means they are filled with zeros .

In both cases , local and global , when we declare an array , we have the possibility to assign initial values to each one of its elements by enclosing the values in braces .
For example : int , This declaration would have created an array like this : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved The amount of values between braces must not be larger than the number of elements that we declare for the array between square brackets .
For example , in the example of array we have declared that it has elements and in the list of initial values within braces we have specified values , one for each element .

When an initialization of values is provided for an array , allows the possibility of leaving the square brackets empty .
In this case , the compiler will assume size for the array that matches the number of values included between braces : int , After this declaration , array would be ints long , since we have provided initialization values .

Accessing the values of an array .

In any point of program in which an array is visible , we can access the value of any of its elements individually as if it was normal variable , thus being able to both read and modify its value .
The format is as simple as : Following the previous examples in which had elements and each of those elements was of type int , the name which we can use to refer to each element is the following : For example , to store the value in the third element of  we could write the following statement : and , for example , to pass the value of the third element of to variable called  we could write : Therefore , the expression is for all purposes like variable of type int .

Notice that the third element of is specified , since the first one is , the second one is , and therefore , the third one is .
By this same reason , its last element is .
Therefore , if we write , we would be accessing the sixth element of and therefore exceeding the size of the array .

In it is syntactically correct to exceed the valid range of indices for an array .
This can create problems , since accessing elements do not cause compilation errors but can cause runtime errors .
The reason why this is allowed will be seen further ahead when we begin to use pointers .

At this point it is important to be able to clearly distinguish between the two uses that brackets have related to arrays .
They perform two different tasks : one is to specify the size of arrays when they are declared ; and the second one is to specify indices for concrete elements .
Do not confuse these two possible uses of brackets with arrays .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved int ; declaration of new ; access to an element of the .

If you read carefully , you will see that type specifier always precedes variable or declaration , while it never precedes an access .

Some other valid operations with arrays :  + arrays example .

For example , bidimensional can be imagined as bidimensional table made of elements , all of them of same uniform data type .

The way to declare this in would be : int jimmy ; and , for example , the way to reference the second element vertically and fourth horizontally in an expression would be : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved that indices always begin by .

Multidimensional arrays are not limited to two indices , two .
They can contain as many indices as needed .

The amount of memory needed for an rapidly increases with each dimension .
For example : char century ; declares an with char element for each second in century , that is more than billion chars .
So this declaration would consume more than gigabytes of memory .

Multidimensional arrays are just an abstraction for programmers , since we can obtain the same results with simple just by putting factor between its indices : int ; is equivalent to int ; With the only difference that with multidimensional arrays the compiler remembers the depth of each imaginary dimension for us .
Take as example these two pieces of code , with both exactly the same .
One uses bidimensional and the other one uses simple  multidimensional WIDTH HEIGHT int ; int ; int main .

All rights reserved We have used constants " to simplify possible future modifications of the program .
For example , in case that we decided to enlarge the to height of instead of it could be done simply by changing the line : HEIGHT to : HEIGHT with no need to make any other modifications to the program .

Arrays as parameters At some moment we may need to pass an to function as parameter .
In it is not possible to pass complete block of memory by value as parameter to function , but we are allowed to pass its address .
In practice this has almost the same effect and it is much faster and more efficient operation .

In order to accept arrays as parameters the only thing that we have to do when declaring the function is to specify in its parameters the element type of the array , an identifier and pair of void brackets .
For example , the following function : void procedure accepts parameter of type of int " called arg .
In order to pass to this function an array declared as : int myarray ; it would be enough to write call like this : procedure ; Here you have complete example : arrays as parameters .

For that reason we have included second parameter that tells the function the length of each array that TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved we pass to it as its first parameter .
This allows the for loop that prints out the array to know the range to iterate in the passed array without going out of range .

In function declaration it is also possible to multidimensional arrays .
The format for tridimensional array parameter is : for example , function with multidimensional array as argument could be : void procedure Notice that the first brackets are left blank while the following ones are not .
This is so because the compiler must be able to determine within the function which is the depth of each additional dimension .

Arrays , both simple or multidimensional , passed as function parameters are quite common source of errors for novice programmers .
recommend the reading of the chapter about Pointers for better understanding on how arrays operate .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved Character Sequences As you may already know , the Standard Library implements powerful string class , which is very useful to handle and manipulate strings of characters .
However , because strings are in fact sequences of characters , we can represent them also as plain arrays of char elements .

For example , the following array : char jenny ; is an array that can store up to elements of type char .
It can be represented as : Therefore , in this array , in theory , we can store sequences of characters up to characters long .
But we can also store shorter sequences .
For example , jenny could store at some point in program either the sequence " or the sequence , since both are shorter than characters .

Therefore , since the array of characters can store shorter sequences than its total length , special character is used to signal the end of the valid sequence : the null character , whose literal constant can be written as '

Our array of elements of type char , called jenny , can be represented storing the characters sequences " and Christmas " as : Notice how after the valid content null character has been included in order to indicate the end of the sequence .
The panels in gray color represent char elements with undetermined values .

Initialization of character sequences Because arrays of characters are ordinary arrays they follow all their same rules .
For example , if we want to initialize an array of characters with some predetermined sequence of characters we can do it just like any other array : char , In this case we would have declared an array of elements of type char initialized with the characters that form the word " plus null character ' at the end .

But arrays of char elements have an additional method to initialize their values : using string literals .

In the expressions we have used in some examples in previous chapters , constants that represent entire strings of characters have already showed up several times .
These are specified enclosing the text to become string literal between double quotes .
For example : result is :  TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved is constant string literal that we have probably used already .

Double quoted strings are literal constants whose type is in fact array of characters .
So string literals enclosed between double quotes always have null character automatically appended at the end .

Therefore we can initialize the array of char elements called with sequence of characters by either one of these two methods : char , char ; In both cases the array of characters is declared with size of elements of type char : the characters that compose the word " plus final null character which specifies the end of the sequence and that , in the second case , when using double quotes it is appended automatically .

Please notice that we are talking about initializing an array of characters in the moment it is being declared , and not about assigning values to them once they have already been declared .
In fact because this type of nullterminated arrays of characters are regular arrays we have the same restrictions that we have with any other array , so we are not able to copy blocks of data with an assignment operation .

Assuming is variable , expressions within source code like : would not be valid , like neither would be : The reason for this may become more comprehensible once you know bit more about pointers , since then it will be clarified that an array is in fact constant pointer pointing to block of memory .

Using sequences of characters sequences of characters are the natural way of treating strings in , so they can be used as such in many procedures .
In fact , regular string literals have this type and can also be used in most cases .

For example , cin and cout support sequences as valid containers for sequences of characters , so they can be used directly to extract strings of characters from cin or to insert them into cout .
For example : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved sequences of characters .

As you can see , we have declared three arrays of char elements .
The first two were initialized with string literal constants , while the third one was left uninitialized .
In any case , we have to speficify the size of the array : in the first two and the size was implicitly defined by the length of the literal constant they were initialized to .
While for yourname we have explicitly specified that it has size of chars .

Finally , sequences of characters stored in char arrays can easily be converted into string objects just by using the assignment operator : string  char ;  TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved Pointers We have already seen how variables are seen as memory cells that can be accessed using their identifiers .
This way we did not have to care about the physical location of our data within memory , we simply used its identifier whenever we wanted to refer to our variable .

The memory of your computer can be imagined as succession of memory cells , each one of the minimal size that computers manage .
These memory cells are numbered in consecutive way , so as , within any block of memory , every cell has the same number as the previous one plus one .

This way , each cell can be easily located in the memory because it has unique address and all the memory cells follow successive pattern .
For example , if we are looking for cell we know that it is going to be right between cells and , exactly one thousand cells after and exactly one thousand cells before cell .

Reference operator As soon as we declare variable , the amount of memory needed is assigned for it at specific location in memory memory .
We generally do not actively decide the exact location of the variable within the panel of cells that we have imagined the memory to be Fortunately , that is task automatically performed by the operating system during runtime .
However , in some cases we may be interested in knowing the address where our variable is being stored during runtime in order to operate with relative positions to it .

The address that locates variable within memory is what we call reference to that variable .
This reference to variable can be obtained by preceding the identifier of variable with an ampersand sign , known as reference operator , and which can be literally translated as .
For example : This would assign to the address of variable  since when preceding the name of the variable with the reference operator we are no longer talking about the content of the variable itself , but about its reference , its address in .

From now on we are going to assume that is placed during runtime in the memory address .
This number is just an arbitrary assumption we are inventing right now in order to help clarify some concepts in this tutorial , but in reality , we cannot know before runtime the real value the address of variable will have in memory .

Consider the following code fragment :  The values contained in each variable after the execution of this , are shown in the following diagram : First , we have assigned the value to variable whose address in memory we have assumed to be .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved The second statement copied to the content of variable is .
This is standard assignment operation , as we have done so many times before .

Finally , the third statement copies to not the value contained in but reference to it , its address , which we have assumed to be .
The reason is that in this third assignment operation we have preceded the identifier with the reference operator , so we were no longer referring to the value of but to its reference address in .

The variable that stores the reference to another variable in the previous is what we call pointer .
Pointers are very powerful feature of the language that has many uses in advanced programming .

Farther ahead , we will see how this type of variable is used and declared .

Dereference operator We have just seen that variable which stores reference to another variable is called pointer .
Pointers are said to to " the variable whose reference they store .

Using pointer we can directly access the value stored in the variable which it points to .
To do this , we simply have to precede the identifier with an asterisk , which acts as dereference operator and that can be literally translated to pointed .

Therefore , following with the values of the previous example , if we write : we could read as :  equal to value pointed by would take the value , since is , and the value pointed by is .

You must clearly differentiate that the expression refers to the value , while an asterisk preceding the refers to the value stored at address , which in this case is .
Notice the difference of including or not including the dereference operator have included an explanatory commentary of how each of these two expressions could be :  equal to ; equal to value pointed by Notice the difference between the reference and dereference .

All rights reserved Thus , they have complementary meanings .
variable referenced with can be dereferenced with .

Earlier we performed the following two assignment operations : Right after these two statements , all of the following expressions would give true as result : The first expression is quite clear considering that the assignment operation performed on was .
The second one uses the reference operator , which returns the address of variable  which we assumed it to have value of .
The third one is somewhat obvious since the second expression was true and the assignment operation performed on was .
The fourth expression uses the dereference operator that , as we have just seen , can be read as pointed , and the value pointed by is indeed .

So , after all that , you may also infer that for as long as the address pointed by remains unchanged the following expression will also be true : Declaring variables of pointer types Due to the ability of pointer to directly refer to the value that it points to , it becomes necessary to specify in its declaration which data type pointer is going to point to .
It is not the same thing to point to char as to point to an int or float .

The declaration of pointers follows this format : type name ; where type is the data type of the value that the pointer is intended to point to .
This type is not the type of the pointer itself .
For example : int number ; char character ; float greatnumber ; These are three declarations of pointers .
Each one is intended to point to different data type , but in fact all of them are pointers and all of them will occupy the same amount of space in memory size in memory of pointer depends on the platform where the code is going to .
Nevertheless , the data to which they point to do not occupy the same amount of space nor are of the same type : the first one points to an int , the second one to char and the last one to float .
Therefore , although these three example variables are all of them pointers which occupy the same size in memory , they are said to have different types : and respectively , depending on the type they point to .

want to emphasize that the asterisk sign that we use when declaring pointer only means that it is pointer is part of its type compound , and should not be confused with the dereference operator that we have seen bit earlier , but which is also written with an asterisk .
They are simply two different things represented with the same sign .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved Now have look at this code : my first pointer .

This is the procedure : First , we have assigned as value of reference to firstvalue using the reference operator .
And then we have assigned the value to the memory location pointed by  that because at this moment is pointing to the memory location of  this in fact modifies the value of .

In order to demonstrate that pointer may take several different values during the same program have repeated the process with and that same .

Here is an example little bit more elaborated : more pointers .

Notice that there are expressions with pointers and , both with and without dereference operator .
The meaning of an expression using the dereference operator is very different from one that does not : When this operator precedes the pointer name , the expression refers to the value being pointed , while when pointer name appears without this operator , it refers to the value of the pointer itself .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved Another thing that may call your attention is the line : int , This declares the two pointers used in the previous example .
But notice that there is an asterisk for each pointer , in order for both to have type to .

Otherwise , the type for the second variable declared in that line would have been int not because of precedence relationships .
If we had written : int , would indeed have type , but would have type int do not matter at all for this .
This is due to operator precedence rules .
But anyway , simply remembering that you have to put one asterisk per pointer is enough for most pointer users .

Pointers and arrays The concept of array is very much bound to the one of pointer .
In fact , the identifier of an array is equivalent to the address of its first element , as pointer is equivalent to the address of the first element that it points to , so in fact they are the same concept .
For example , supposing these two declarations : int ; int  The following assignment operation would be valid :  After that , and would be equivalent and would have the same properties .
The only difference is that we could change the value of pointer by another one , whereas will always point to the first of the elements of type int with which it was defined .
Therefore , unlike  which is an ordinary pointer , is an array , and an array can be considered constant pointer .
Therefore , the following allocation would not be valid :  Because is an array , so it operates as constant pointer , and we cannot assign values to constants .

Due to the characteristics of variables , all expressions that pointers in the following example are perfectly valid : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved more pointers .

Well , these bracket sign operators are also dereference operator known as offset operator .
They dereference the variable they follow just as does , but they also add the number between brackets to the address being dereferenced .
For example : pointed by These two expressions are equivalent and valid both if is pointer or if is an array .

Pointer initialization When declaring pointers we may want to explicitly specify which variable we want them to point to : int number ; int ; The behavior this code is equivalent to : int number ; int ; When pointer initialization takes place we are always assigning the reference value to where the pointer points , never the value being pointed .
You must consider that at the moment declaring pointer , the asterisk indicates only that it is pointer , it is not the dereference operator both use the same sign :
Remember , they are two different functions one sign .
Thus , we must take care not to confuse the previous code with : int number ; int ; that is incorrect , and anyway would not have much sense in this case if you think about it .

As in the case arrays , the compiler allows the special case that we want to initialize the content at which the pointer points with constants at the same moment the pointer is declared : char ; TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved In this case , memory space is reserved to contain " and then pointer to the first character this memory block is assigned to .
If we imagine that " is stored at the memory locations that start at addresses , we can represent the previous declaration as : It is important to indicate that contains the value , and not ' nor , although indeed is the address both these .

The pointer points to sequence characters and can be read as if it was an array that an array is just like constant .
For example , we can access the fifth element the array with any these two expression : Both expressions have value ' fifth element the .

Pointer arithmetics To conduct arithmetical operations on pointers is little different than to conduct them on regular integer data types .
To begin with , only addition and subtraction operations are allowed to be conducted with them , the others make no sense in the world pointers .
But both addition and subtraction have different behavior with pointers according to the size the data type to which they point .

When we saw the different fundamental data types , we saw that some occupy more or less space than others in the memory .
For example , assume that in given compiler for specific machine , char takes byte , short takes bytes and long takes .

Suppose that we define three pointers in this compiler : char ; short ; long ; and that we know that they point to memory locations , and respectively .

So if we write : mychar , as you may expect , would contain the value .
But not so obviously , myshort would contain the value , and mylong would contain , even though they have each been increased only once .
The reason is that when adding one to pointer we are making it to point to the following element the same type with which it has been defined , and therefore the size in bytes the type pointed is added to the pointer .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved This is applicable both when adding and subtracting any number to pointer .
It would happen exactly the same if we write : + + + Both the increase and decrease operators have greater operator precedence than the dereference operator , but both have special behavior when used as suffix expression is evaluated with the value it had before being .
Therefore , the following expression may lead to confusion : Because has greater precedence than , this expression is equivalent to .
Therefore , what it does is to increase the value it now points to the next , but because is used as postfix the whole expression is evaluated as the value pointed by the original reference address the pointer pointed to before being .

Notice the difference with : Here , the expression would have been evaluated as the value pointed by increased by one .
The value pointer would not be modified is being modified is what it is being pointed to by this .

If we write : Because has higher precedence than , both and are increased , but because both increase operators are used as postfix and not prefix , the value assigned to is before both and are increased .

It would be roughly equivalent to : Like always , recommend you to use parentheses in order to avoid unexpected results and to give more legibility to the code .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved Pointers to pointers allows the use of pointers that point to pointers , that these , in its turn , point to data even to other .
In order to do that , we only need to add an asterisk for each level of reference in their declarations : char  char  char  This , supposing the randomly chosen memory locations for each variable of , and , could be represented as : The value of each variable is written inside each cell ; under the cells are their respective addresses in memory .

The new in this example is variable  which can be used in three different levels of indirection , each one of them would correspond to different .

In , void represents the absence of type , so void pointers are pointers that point to value that has no type thus also an undetermined length and undetermined dereference .

This allows void pointers to point to any data type , from an integer value or float to string of characters .
But in exchange they have great limitation : the data pointed by them cannot be directly dereferenced is logical , since we have no type to dereference , and for that reason we will always have to cast the address in the void pointer to some other pointer type that points to concrete data type before dereferencing it .

One of its uses may be to pass generic parameters to function : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved increaser .

For nondynamic data types this value is constant .
Therefore , for example , is , because char type is one byte long .

Null pointer null pointer is regular pointer of any pointer type which has special value that indicates that it is not pointing to any valid reference or memory address .
This value is the result of the integer value zero to any pointer type .

null pointer is value that any pointer may take to represent that it is pointing to , while void pointer is special type of pointer that can point to somewhere without specific type .
One refers to the value stored in the pointer itself and the other to the type of data it points to .

Pointers to functions allows operations with pointers to functions .
The typical use of this is for passing function as an argument to another function , since these cannot be passed dereferenced .
In order to declare pointer to function we have to declare it like the prototype of the function except that the name of the function is enclosed between parentheses and an asterisk is inserted before the name : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved pointer to functions .

It is immediately assigned to point to the function subtraction , all in single line : subtraction ; TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved Dynamic Memory Until now , in all our programs , we have only had as much memory available as we declared for our variables , having the size of all of them to be determined in the source code , before the execution of the program .
But , what if we need variable amount of memory that can only be determined during runtime .
For example , in the case that we need some user input to determine the necessary amount of memory space .

The answer dynamic memory , for which integrates the operators delete .

Operators In order to request dynamic memory we use the operator .
It returns to the beginning of the of memory allocated .
Its form  The first expression used to allocate memory to contain one single element of .
The second one used to assign of elements of  where an integer value representing the amount of these .
For example :  In this case , the system dynamically assigns space for five elements of returns to the first element of the sequence , which assigned to .
Therefore , now , points to valid of memory with space for five elements of .

The first element pointed by can be accessed either with the expression or the expression .

Both are equivalent as has been explained in the section about pointers .
The second element can be accessed either with or so .

You could be wondering the difference between declaring normal array assigning dynamic memory to  as we have just done .
The most important difference that the size of an array has to be constant value , which limits its size to what we decide at the moment of designing the program , before its execution , whereas the dynamic memory allocation allows us to assign memory during the execution of the program using any variable or constant value as its size .

The dynamic memory requested by our program allocated by the system from the memory heap .
However , computer memory limited resource , it can be exhausted .
Therefore , it important to have some mechanism to check if our request to allocate memory was successful or not .

provides two standard methods to check if the allocation was successful : One by handling exceptions .
Using this method an exception of thrown when the allocation fails .
Exceptions are powerful feature explained later in these tutorials .
But for now you should know that if this exception thrown it not handled by specific handler , the program execution terminated .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved This exception method the default method used by  the one used in declaration like : if it fails an exception thrown The other method known  what happens when it used that when memory allocation fails , instead of throwing exception or terminating the program , the returned by null  the program continues its execution .

This method can be specified by using special object called  declared in header , argument for  In this case , if the allocation of this of memory failed , the failure could be detected by checking if took null value :  if error assigning memory .

Anyway this method can become tedious for larger projects , where the exception method generally preferred .
The exception method will be explained in detail later in this tutorial .

Operators delete Since the necessity of dynamic memory usually limited to specific moments within program , once it no longer needed it should be freed so that the memory becomes available again for other requests of dynamic memory .
This the purpose of the operator delete , whose format  delete  delete  The first expression should be used to delete memory allocated for single element , the second one for memory allocated for arrays of elements .

The value passed argument to delete must be either to memory previously allocated with  or null the case of null  delete produces no .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved .

For example , when tried to give value of billion to the many numbers " question , my system could not allocate that much memory for the program got the text message we prepared for this case : memory could not be .

Remember that in the case that we tried to allocate the memory without specifying the parameter in the  an exception would be thrown , which if not handled terminates the program .

It good practice to always check if dynamic memory block was successfully allocated .
Therefore , if you use the method , you should always check the value of the pointer returned .
Otherwise , use the exception method , even if you do not handle the exception .
This way , the program will terminate at that point without causing the unexpected results of continuing executing code that assumes block of memory to have been allocated when in fact it has not .

Dynamic memory in Operators delete are exclusive of .

But using pure language its library , dynamic memory can also be used through the functions malloc , calloc , realloc free , which are also available in including the header file cstdlib for more .

The memory blocks allocated by these functions are not necessarily compatible with those returned by  each one should be manipulated with its own set of functions or operators .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved Data structures We have already learned how groups of sequential data can be used in .
But this somewhat restrictive , since in many occasions what we want to store are not mere sequences of elements all of the same data type , but sets of different elements with different data types .

Data structures data structure group of data elements grouped together under one name .
These data elements , known members , can have different types different lengths .
Data structures are declared in using the following syntax : struct ;

Within braces there is list with the data members , each one is specified with valid identifier as its name .

The first thing we have to know is that data structure creates  Once data structure is declared , with the identifier specified as is created can be used in the rest of the program as if it was any other .
For example : struct product int weight ; float price ;  product apple ; product banana , melon ; We have first declared structure called product with two members : weight price , each of different fundamental .
We have then used this name of the structure to declare three objects of that  apple , banana melon as we would have done with any fundamental data .

Once declared , product has become name like the fundamental ones int , char or short from that point on we are able to declare objects of this compound  like we have done with apple , banana melon .

Right at the end of the struct declaration , before the ending semicolon , we can use the optional field to directly declare objects of the structure .
For example , we can also declare the structure objects apple , banana melon at the moment we define the data structure this way : struct product int weight ; float price ; apple , banana , melon ; It is important to clearly differentiate between what is the structure name , what is an object that has this structure .
We can instantiate many objects .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved Once we have declared our three objects of determined structure , banana we can operate directly with their members .
To do that we use dot inserted between the object name the member name .
For example , we could operate with any of these elements as if they were standard variables of their respective types : Each one of these has the data corresponding to the member they refer to : are of int , while , are of float .

see real example where you can see how structure can be used in the same way as fundamental .

For example , the member yours .

The objects mine and yours can also be treated as variables of , for example we have passed them to the function printmovie as we would have done with regular variables .
Therefore , one of the most important advantages of data structures is that we can either refer to their members individually or to the entire structure as block with only one identifier .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved Data structures are feature that can be used to represent databases , especially if we consider the possibility of building arrays of .

So , the following code would also be valid : The value of the pointer would be assigned to reference to the object amovie memory .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved We will now go with another example that includes pointers , which will serve to introduce new  the arrow .

This is dereference that is used exclusively with pointers to objects with members .
This serves to access member of an object to which we have reference .
In the example we used : Which is for all purposes equivalent to : Both expressions and are valid and both mean that we are evaluating the member title of the data structure pointed by pointer called .
It must be clearly differentiated from : which is equivalent to : And that would access the value pointed by hypothetical pointer member called title of the structure object in this case would not be .
The following panel summarizes possible combinations of pointers and structure members : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved Expression What is evaluated Equivalent Member of object Member of object pointed by Value pointed by member of object Nesting structures Structures can also be nested so that valid element of structure can also be in its turn another structure .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved Other Data Types Defined data types allows the definition of our own types based on other existing data types .
We can do this using the keyword typedef , whose format is : typedef  where is fundamental or compound and is the name for the new we are defining .
For example : typedef char ; typedef unsigned int WORD ; typedef char pChar ; typedef char field ; In this case we have defined four data types : WORD , pChar and field as char , unsigned int , and respectively , that we could perfectly use in declarations later as any other valid  mychar , anotherchar , WORD myword ; pChar ; field name ; typedef does not create different types .
It only creates synonyms of existing types .
That means that the of myword can be considered to be either WORD or unsigned int , since both are in fact the same .

It is also useful to define types when it is possible that we will need to change the in later versions of our program , or if you want to use has name that is too long or confusing .

Unions Unions allow one same portion of memory to be accessed as different data types , since all of them are in fact the same location in memory .
Its declaration and use is similar to the one of structures but its functionality is totally different : union ;

Its size is the one of the greatest element of the declaration .
For example : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved union char c ; int ; float ; mytypes ; defines three elements : each one with different data .
Since all of them are referring to the same location in memory , the modification of one of the elements will affect the value of all of them .
We cannot store different values in them independent of each other .

One of the uses union may have is to unite an elementary with an array or structures of smaller elements .

For example : union long ; struct short hi ; short lo ; char ; mix ; defines three names that allow us to access the same group of bytes : and and which we can use according to how we want to access these bytes , as if they were single data , as if they were two short elements or as an array of char elements , respectively .
have mixed types , arrays and structures in the union so that you can see the different ways that we can access the data .
For system PC , this union could be represented as : The exact alignment and order of the members of union in memory is platform dependant .
Therefore be aware of possible portability issues with this of use .

Anonymous unions In we have the option to declare anonymous unions .
If we declare union without any name , the union will be anonymous and we will be able to access its members directly by their member names .
For example , look at the difference between these two structure declarations : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved structure with regular union structure with anonymous union struct char ; char ; union float .

The difference is seen when we access the members dollars and yens of an object of this .
For an object of the first  it would be : whereas for an object of the second  it would be : Once again remind you that because it is union and not struct , the members dollars and yens occupy the same physical space in the memory so they cannot be used to store two different values simultaneously .
You can set value for price in dollars or in yens , but not in both .

Enumerations Enumerations create new types to contain something different that is not limited to the values fundamental types may take .
Its form is the following : enum ,

To say it somehow , we have created whole new from scratch without basing it on any other existing .
The possible values that variables of this new may take are the new values included within braces .
For example , once the enumeration is declared the following expressions will be valid :  blue ; if red ; Enumerations are compatible with numeric variables , so their constants are always assigned an integer numerical value internally .
If it is not specified , the integer value equivalent to the first possible value is equivalent to and the following ones follow progression .
Thus , in our that we have defined above , black would be equivalent to , blue would be equivalent to , green to , and so on .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved We can explicitly specify an integer value for any of the values that our enumerated can take .
If the value that follows it is not given an integer value , it is automatically assumed the same value as the previous one plus one .
For example : enum , february , march , april , may , june , july , august , september , october , november , In this case , variable of enumerated can contain any of the possible values that go from to december and that are equivalent to values between and between and , since we have made equal to .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved Object Oriented Programming Classes class is an expanded concept of structure : instead of holding only  it can hold both and functions .

An object is an instantiation of class .
In terms of variables , class would be the  and an object would be the variable .

Classes are generally declared using the keyword class , with the following format : class class_name

The body of the declaration can contain members , that can be either or function declarations , and optionally access specifiers .

All is very similar to the declaration on structures , except that we can now include also functions and members , but also this new called access specifier .
An access specifier is one of the following three keywords : private , public or protected .
These specifiers modify the access rights that the members following them .

Finally , public members are accessible from anywhere where the object is visible .

By default , all members of class declared with the class keyword have private access for all its members .

Therefore , any member that is declared before one other class specifier automatically has private access .
For example : class CRectangle int , public : void ; int area ; rect ; Declares class , called CRectangle and an object , of this class called rect .
This class contains four members : two members of int and member with private access private is the default access and two member functions with public access : and , of which for now we have only included their declaration , not their definition .

Notice the difference between the class name and the object name : In the previous example , CRectangle was the class name , the , whereas rect was an object of CRectangle .
It is the same relationship int and have in the following declaration : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved int ; where int is the name and is the variable name .

After the previous declarations of CRectangle and rect , we can refer within the body of the program to any of the public members of the object rect as if they were normal functions or normal variables , just by putting the name followed by dot and then the name of the member .
All very similar to what we did with plain structures before .
For example : The only members of rect that we cannot access from the body of our program outside the class are and , since they have private access and they can only be referred from within other members of that same class .

It is used to define member of class from outside the class definition itself .

You may notice that the definition of the member function has been included directly within the definition of the CRectangle class given its extreme simplicity , whereas has only its prototype declared within the class , but its definition is outside it .
In this outside declaration , we must use the operator of scope to specify that we are defining function that is member of the class CRectangle and not regular global function .

The scope operator specifies the class to which the member being declared belongs , granting exactly the same scope properties as if this function definition was directly included within the class definition .
For example , in the function of the previous code , we have been able to use the variables and  which are private members of class CRectangle , which means they are only accessible from other members of their class .

The only difference between defining class member function completely within its class or to only the prototype and later its definition , is that in the first case the function will automatically be considered an inline member function by the compiler , while in the second it will be normal class member function , which in fact supposes no difference in behavior .

Members and have private access that if nothing else is said , all members of class defined with keyword class have private .
By declaring them private we deny access to them from anywhere outside the TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved class .
This makes sense , since we have already defined member function to set values for those members within the object : the member function .
Therefore , the rest of the program does not need to have direct access to them .
Perhaps in so simple example as this , it is difficult to see an utility in protecting those two variables , but in greater projects it may be very important that values cannot be modified in an unexpected way from the point of view of the .

One of the greater advantages of class is that , as any other type , we can declare several objects of it .
For example , following with the previous example of class CRectangle , we could have declared the object rectb in addition to the object rect : example : one class , two objects .

Each one of them has its own member variables and member functions .

Notice that the call to does not give the same result as the call to .
This is because each object of class CRectangle has its own variables and  as they , in some way , have also their own function members and that each uses its own variables to operate .

That is the basic concept of programming : Data and functions are both members of the object .
We no longer use sets of global variables that we pass from one function to another as parameters , but instead we handle objects that have their own data and functions embedded as members .
Notice that we have not had to give any parameters in any of the calls to rect .
Those member functions directly used the data members of their respective objects rect and rectb .

Constructors and destructors Objects generally need to initialize variables or assign dynamic memory during their process of creation to become operative and to avoid returning unexpected values during their execution .
For example , what would happen if in the previous example we called the member function before having called function .
Probably we would have gotten an undetermined result since the members and would have never been assigned value .

In order to avoid that , class can special function called constructor , which is automatically called whenever new of this class is created .
This constructor function must have the same name as the class , and cannot have any return type ; not even void .

We are going to implement CRectangle including constructor : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved example : class constructor .

CRectangle rectb .

But now we have removed the member function , and have included instead constructor that performs similar action : it initializes the values of and with the parameters that are passed to it .

Notice how these arguments are passed to the constructor at the moment at which the objects of this class are created : CRectangle rect ; CRectangle rectb ; Constructors cannot be called explicitly as if they were regular member functions .
They are only executed when new of that class is created .

You can also see how neither the constructor prototype declaration the nor the latter constructor definition return value ; not even void .

The destructor fulfills the opposite functionality .
It is automatically called when an is destroyed , either because its scope of existence has finished example , if it was defined as local within function and the function or because it is an dynamically assigned and it is released using the operator delete .

The destructor must have the same name as the class , but preceded with tilde sign and it must also return no value .

The use of destructors is especially suitable when an assigns dynamic memory during its lifetime and at the moment of being destroyed we want to release the memory that the was allocated .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved example on constructors and destructors using namespace std ; class CRectangle ,

, new  new  delete  delete 

Remember that for overloaded functions the compiler will call the one whose parameters match the arguments used in the function call .
In the case of constructors , which are automatically called when an is created , the one executed is the one that matches the arguments passed on the declaration : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved overloading class constructors .

Important : Notice how if we declare new and we want to use its default constructor one without , we do not parentheses : CRectangle rectb ; right CRectangle ; wrong .

Default constructor If you do not declare any constructors in class definition , the compiler assumes the class to have default constructor with no arguments .
Therefore , after declaring class like this one : class CExample public : void multiply , The compiler assumes that CExample has default constructor , so you can declare objects of this class by simply declaring them without any arguments : CExample ex ; But as soon as you declare your own constructor for class , the compiler no longer provides an implicit default constructor .
So you have to declare all objects of that class according to the constructor prototypes you defined for the class : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved class CExample .

Therefore the following declaration would be correct : CExample ex ; But , CExample ex ; Would not be correct , since we have declared the class to have an explicit constructor , thus replacing the default constructor .

But the compiler not only creates default constructor for you if you do not specify your own .
It provides three special member functions in total that are implicitly declared if you do not declare your own .
These are the copy constructor , the copy assignment operator , and the default destructor .

The copy constructor and the copy assignment operator copy all the data contained in another to the data members of the current .
For CExample , the copy constructor implicitly declared by the compiler would be something similar to : Therefore , the two following declarations would be correct : CExample ex ; CExample ; copy constructor copied from Pointers to classes It is perfectly valid to create pointers that point to classes .
We simply have to consider that once declared , class becomes valid type , so we can use the class name as the type for the pointer .
For example : CRectangle prect ; is pointer to an of class CRectangle .

As it happened with data structures , in order to refer directly to member of an pointed by pointer we can use the arrow operator of indirection .
Here is an example with some possible combinations : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved pointer to classes example .

If you have doubts , read again this section consult the previous sections about pointers and data structures .

Classes defined with struct and union Classes can be defined not only with keyword class , but also with keywords struct and union .

The concepts of class and data structure are so similar that both keywords and can be used in to declare classes .
The only difference between both is that members of classes declared with the keyword struct have public access by default , while members of classes declared with the keyword class have private access .
For all other purposes both keywords are equivalent .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved The concept of unions is different from that of classes declared with struct and class , since unions only store one data member at time , but nevertheless they are also classes and can thus also hold function members .
The default access in union classes is public .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved Classes Overloading operators incorporates the option to use standard operators to perform operations with classes in addition to with fundamental types .
For example : int    +  This is obviously valid code in , since the different variables of the addition are all fundamental types .

Nevertheless , it is not so obvious that we could perform an operation similar to the following one : struct string product ; float price ;    +  In fact , this will cause compilation error , since we have not defined the behavior our class should have with addition operations .
However , thanks to the feature to overload operators , we can design classes able to perform operations using standard operators .
Here is list of all the operators that can be overloaded : Overloadable operators +
The format is : type operator sign Here you have an example that overloads the addition operator .
We are going to create class to store bidimensional vectors and then we are going to add two of them : and .
The addition of two bidimensional vectors is an operation as simple as adding the two coordinates to obtain the resulting coordinate and adding the two coordinates to obtain the resulting .
In this case the result will .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved vectors : overloading operators example .

But , consider that some of them refer to the class name CVector and some others are functions with that name must have the same name as the .
Do not confuse them : CVector , function name CVector CVector ; function returns CVector The function of class CVector is the one that is in charge of overloading the addition operator .
This function can called either implicitly using the operator , or explicitly using the function name : + Both expressions are equivalent .

Notice also that we have included the empty constructor and we have defined it with an empty block : CVector ; This is necessary , since we have explicitly declared another constructor : CVector , And when we explicitly declare any constructor , with any number of parameters , the default constructor with no parameters that the compiler can declare automatically is not declared , so we need to declare it ourselves in order to able to construct objects of this type without parameters .
Otherwise , the declaration : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved  included in would not have been valid .

Anyway , have to warn you that an empty block is bad implementation for constructor , since it does not fulfill the minimum functionality that is generally expected from constructor , which is the initialization of all the member variables in its class .
In our case this constructor leaves the variables and undefined .
Therefore , more advisable definition would have been something similar to this : which in order to simplify and show only the point of the code have not included in the example .

As well as class includes default constructor and copy constructor even if they are not declared , it also includes default definition for the assignment with the class itself as parameter .
The behavior which is defined by default is to copy the whole content of the data members of the object passed as argument one at the right side of the to the one at the left side :  copy assignment The copy assignment function is the only member function implemented by default .
Of course , you can redefine it to any other functionality that you want , like for example , copy only certain class members or perform additional initialization procedures .

The overload of operators does not force its operation to bear relation to the mathematical or usual meaning of the  although it is recommended .
For example , the code may not very intuitive if you use + to subtract two classes or to fill with zeros class , although it is perfectly possible to do so .

Although the prototype of function + can seem obvious since it takes what is at the right side of the as the parameter for the member function of the object at its left side , other operators may not so obvious .
Here you have table with summary on how the different functions have to declared by the in each : Expression Operator Member function Global function +

You can see in this panel that there are two ways to overload some class operators : as member function and as global function .
Its use is indistinct , nevertheless remind you that functions that are not members of class cannot access the private or protected members of that class unless the global function is its friend is explained .

The keyword this The keyword this represents pointer to the object whose member function is being executed .
It is pointer to the object itself .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved One of its uses can be to check if parameter passed to member function is the object itself .

Following with the examples seen before we could have written an function similar to this one : return ; In fact this function is very similar to the code that the compiler generates implicitly for this class if we do not an member function to copy objects of this class .

Static members class can contain static members , either data or functions .

Static data members of class are also known as , because there is only one unique value for all the objects of that same class .
Their content is not different from one object of this class to another .

For example , it may be used for variable within class that can contain counter with the number of objects of that class that are currently allocated , as in the following example : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved static members in classes .

For that reason , and to avoid them to be declared several times , we can only the prototype in the class declaration but not its definition .
In order to initialize static we must formal definition outside the class , in the global scope , as in the previous example : int ; Because it is unique variable value for all the objects of the same class , it can be referred to as member of any object of that class or even directly by the class name course this is only valid for static : cout ; cout ; These two calls included in the previous example are referring to the same variable : the static variable within class shared by all objects of this class .

Once again , remind you that in fact it is global variable .
The only difference is its name and possible access restrictions outside its class .

Just as we may static data within class , we can also static functions .
They represent the same : they are global functions that are called as if they were object members of given class .
They can only refer to static data , in no case to members of the class , as well as they do not allow the use of the keyword this , since it makes reference to an object pointer and these functions in fact are not members of any object but direct members of the class .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved Friendship and inheritance Friend functions In principle , private and protected members of class cannot be accessed from outside the same class in which they are declared .
However , this rule does not affect friends .

Friends are functions or classes declared as such .

If we want to declare an external function as friend of class , thus allowing this function to have access to the private and protected members of this class , we do it by declaring prototype of this external function within the class , and preceding it with the keyword friend : friend functions .

From within that function we have been able to access the members and of different objects of type CRectangle , which are private members .
Notice that neither in the declaration of nor in its later use in have we considered duplicate member of class CRectangle .
It simply has access to its private and protected members without being member .

The friend functions can serve , for example , to conduct operations between two different classes .
Generally , the use of friend functions is out of an programming methodology , so whenever possible it is better to use members of the same class to perform operations with them .
Such as in the previous example , it would have been shorter to integrate within the class CRectangle .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved Friend classes Just as we have the possibility to define friend function , we can also define class as friend of another one , granting that first class access to the protected and private members of the second one .

You may also see something new the beginning of the program : an empty declaration of class CSquare .
This is necessary because within the declaration of CRectangle we refer to CSquare parameter in .
The definition of CSquare is included later , so if we did not previous empty declaration for CSquare this class would not be visible from within the definition of CRectangle .

Consider that friendships are not corresponded if we do not explicitly specify so .
In our example , CRectangle is considered as friend class by CSquare , but CRectangle does not consider CSquare to be friend , so CRectangle can access the protected and private members of CSquare but not the reverse way .
Of course , we could have declared also CSquare as friend of CRectangle if we wanted to .

Another property of friendships is that they are not transitive : The friend of friend is not considered to be friend unless explicitly specified .

Inheritance between classes key feature of classes is inheritance .
Inheritance allows to create classes which are derived from other classes , so that they automatically some of its " members , plus its own .
For example , we are going TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved to suppose that we want to declare series of classes that describe polygons like our CRectangle , or like CTriangle .
They have certain common properties , such as both can be described by means of only two sides : and base .

This could be represented in the world of classes with class CPolygon from which we would derive the two other ones : CRectangle and CTriangle .

The class CPolygon would contain members that are common for both types of polygon .
In our case : and And CRectangle and CTriangle would be its derived classes , with specific features that are different from one type of polygon to the other .

Classes that are derived from others inherit all the accessible members of the base class .
That means that if base class includes member and we derive it to another class with another member called , the derived class will contain both members and .

In order to derive class from another , we use colon in the declaration of the derived class using the following format : class : public ; Where is the name of the derived class and is the name of the class on which it is based .
The public access specifier may be replaced by any one of the other access specifiers protected and private .
This access specifier describes the minimum access level for the members that are inherited from the base class .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved derived classes .

The protected access specifier is similar to private .
Its only difference occurs in fact with inheritance .
When class inherits from another one , the members of the derived class can access the protected members inherited from the base class , but not its private members .

Since we wanted and to be accessible from members of the derived classes CRectangle and CTriangle and not only by members of CPolygon , we have used protected access instead of private .

We can summarize the different access types according to who can access them in the following way : Access public protected private members of the same class yes yes yes members of derived classes yes yes no not members yes no no Where members " represent any access from outside the class , such as from , from another class or from function .

In our example , the members inherited by CRectangle and CTriangle have the same access permissions as they had in their base class CPolygon : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved : protected access .

This is because we have used the public keyword to define the inheritance relationship on each of the derived classes : class CRectangle : public CPolygon .
Since public is the most accessible level , by specifying this keyword the derived class will inherit all the members with the same levels they had in the base class .

If we specify more restrictive access level like protected , all public members of the base class are inherited as protected in the derived class .
Whereas if we specify the most restricting of all access levels : private , all the base class members are inherited as private .

For example , if daughter was class derived from mother that we defined as : class daughter : protected mother ; This would set protected as the maximum access level for the members of daughter that it inherited from mother .
That is , all members that were public in mother would become protected in daughter .
Of course , this would not restrict daughter to declare its own public members .
That maximum access level is only set for the members inherited from mother .

If we do not explicitly specify any access level for the inheritance , the compiler assumes private for classes declared with class keyword and public for those declared with struct .

In principle , derived class inherits every member of base class .

If the base class has no default constructor or you want that an overloaded constructor is called when new derived is created , you can specify it in each constructor definition of the derived class :  For example : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved constructors and derived classes .

The difference is because the constructor declaration of and son : nothing specified : call default son  mother constructor specified : call this Multiple inheritance In it is perfectly possible that class inherits members from more than one class .
This is done by simply separating the different base classes with commas in the derived class declaration .
For example , if we had specific class to print on screen and we wanted our classes CRectangle and CTriangle to also inherit its members in addition to those of CPolygon we could write : class CRectangle : public CPolygon , public COutput ; class CTriangle : public CPolygon , public COutput ; here is the complete example : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved multiple inheritance .

All rights reserved Polymorphism Before getting into this section , it is recommended that you have proper understanding of pointers and class inheritance .
If any of the following statements seem strange to you , you should review the indicated sections : Statement : Explained in : int ; Classes Data Structures class : public ; Friendship and inheritance Pointers to base class One of the key features of derived classes is that pointer to derived class is with pointer to its base class .
Polymorphism is the art of taking advantage of this simple but powerful and versatile feature , that brings Object Oriented Methodologies to its full potential .

We are going to start by rewriting our program about the rectangle and the triangle of the previous section taking into consideration this pointer compatibility property : pointers to base class .

Then we assign references to rect and trgl to these pointers , and because both are objects of classes derived from  both are valid assignment operations .

The only limitation in using and instead of rect and trgl is that both and are of type and therefore we can only use these pointers to refer to the members that CRectangle and TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved CTriangle inherit from .
For that reason when we call the members at the end of the program we have had to use directly the objects rect and trgl instead of the pointers and .

In order to use with the pointers to class  this member should also have been declared in the class  and not only in its derived classes , but the problem is that CRectangle and CTriangle implement different versions of  therefore we cannot implement it in the base class .
This is when virtual members become handy : Virtual members member of class that can be redefined in its derived classes is known as virtual member .
In order to declare member of class as virtual , we must precede its declaration with the keyword virtual : virtual members .

The member function has been declared as virtual in the base class because it is later redefined in each derived class .
You can verify if you want that if you remove this virtual keyword from the declaration of within  and then you run the program the result will be for the three polygons instead of , and .

That is because instead of calling the corresponding function for each object , and , will be called in all cases since the calls are via pointer whose type is .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved Therefore , what the virtual keyword does is to allow member of derived class with the same name as one in the base class to be appropriately called from pointer , and more precisely when the type of the pointer is pointer to the base class but is pointing to an object of the derived class , as in the above example .

class that declares or inherits virtual function is called polymorphic class .

Note that despite of its virtuality , we have also been able to declare an object of type and to call its own function , which always returns .

Abstract base classes Abstract base classes are something very similar to our class of our previous example .
The only difference is that in our previous example we have defined valid function with minimal functionality for objects that were of class the object , whereas in an abstract base classes we could leave that member function without implementation at all .
This is done by to to the function declaration .

An abstract base class could look like this : abstract class class protected : int   public : void , int ; virtual int ; Notice how we to virtual int instead of specifying an implementation for the function .

This type of function is called pure virtual function , and all classes that contain at least one pure virtual function are abstract base classes .

The main difference between an abstract base class and regular polymorphic class is that because in abstract base classes at least one of its members lacks implementation we cannot create instances of it .

But class that cannot instantiate objects is not totally useless .
We can create pointers to it and take advantage of all its polymorphic abilities .
Therefore declaration like : poly ; would not be valid for the abstract base class we have just declared , because tries to instantiate an object .

Nevertheless , the following pointers : would be perfectly valid .

This is so for as long as includes pure virtual function and therefore an abstract base class .

However , pointers to this abstract base class can be used to point to objects of derived classes .

Here you have the complete example : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved abstract base class .

This can be tremendously useful .
For example , now we can create function member of the abstract base class that is able to print on screen the result of the function even though itself has no implementation for this function : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved pure virtual members can be called from the abstract base class using namespace std ; class protected : int   public : int ; virtual int ; printarea .

Of course , we have seen very simple uses of these features , but these features can be applied to arrays of objects or dynamically allocated objects .

end with the same example again , but this time with objects that are dynamically allocated : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved dynamic allocation and polymorphism .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved Advanced concepts Templates Function templates Function templates are special functions that can operate with generic types .
This allows us to create function template whose functionality can be adapted to more than one type or class without repeating the entire code for each type .

In this can be achieved using template parameters .
template parameter is special kind of parameter that can be used to pass type as argument : just like regular function parameters can be used to pass values to function , template parameters allow to pass also types to function .
These function templates can use these parameters as if they were any other regular type .

The format for declaring function templates with type parameters is : template function_declaration template function_declaration The only difference between both prototypes is the use of either the keyword class or the keyword typename .
Its use is indistinct , since both expressions have exactly the same meaning and behave exactly the same way .

For example , to create template function that returns the greater one of two objects we could use : template myType GetMax , myType return ; Here we have created template function with myType as its template parameter .
This template parameter represents type that has not yet been specified , but that can be used in the template function as if it were regular type .
As you can see , the function template GetMax returns the greater of two parameters of this stillundefined type .

To use this function template we use the following format for the function call : function_name For example , to call GetMax to compare two integer values of type int we can write : int ; GetMax ; When the compiler encounters this call to template function , it uses the template to automatically generate function replacing each appearance of myType by the type passed as the actual template parameter in this and then calls it .
This process is automatically performed by the compiler and is invisible to the programmer .

Here is the entire example : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved function template .

But you can use any identifier you like .

In the example above we used the function template twice .
The first time with arguments of type int and the second one with arguments of type long .
The compiler has instantiated and then called each time the appropriate version of the function .

As you can see , the type is used within the template function even to declare new of that type :  Therefore , will be an object of the same type as the parameters and when the function template is instantiated with specific type .

In this specific case where the generic type is used as parameter for the compiler can find out automatically which data type has to instantiate without having to explicitly specify it within angle brackets we have done before specifying and .
So we could have written instead : int ; Since both and are of type int , and the compiler can automatically find out that the template parameter can only be int .
This implicit method produces exactly the same  TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved function template II .

, return ; int main .

The compiler automatically determines what type is needed on each call .

Because our template function includes only one template parameter and the function template itself accepts two parameters , both of this type , we cannot call our function template with two of different types as arguments : int  long  This would not be correct , since our function template expects two arguments of the same type , and in this call to it we use of two different types .

We can also define function templates that accept more than one type parameter , simply by specifying more template parameters between the angle brackets .
For example : template , class GetMin , return ; In this case , our function template accepts two parameters of different types and returns an object of the same type as the first parameter that is passed .
For example , after that declaration we could call with : int ; long  or simply : GetMin ; even though and have different types , since the compiler can determine the appropriate instantiation anyway .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved Class We also have the possibility to write class  so that class can have members that use template parameters as types .
For example : template class mypair ; public : mypair first , The class that we have just defined serves to store two elements of any valid type .
For example , if we wanted to declare an object of this class to store two integer of type int with the and we would write : myobject , this same class would also be used to create an object to store any other type : myfloats , The only member function in the previous class template has been defined inline within the class declaration itself .

In case that we define function member outside the declaration of the class template , we must always precede that definition with the template prefix : class .

All rights reserved template Confused by so many .
There are three in this declaration : The first one is the template parameter .
The second refers to the type returned by the function .
And the third one between angle is also requirement : It specifies that this template parameter is also the class template parameter .

Template specialization If we want to define different implementation for template when specific type is passed as template parameter , we can declare specialization of that template .

For example , suppose that we have very simple class called mycontainer that can store one element of any type and that it has just one member function called increase , which increases its value .
But we find that when it stores an element of type char it would be more convenient to have completely different implementation with function member uppercase , so we decide to declare class template specialization for that type : template specialization .

This is to explicitly declare it as specialization .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved But more important than this prefix , is the specialization parameter after the class name .
This specialization parameter itself identifies the type for which we are going to declare class specialization .
Notice the differences between the generic class and the specialization : class .

When we declare specializations for class , we must also define all its members , even those exactly equal to the generic class , because there is no " of members from the generic to the specialization .

parameters for Besides the arguments that are preceded by the class or typename keywords  which represent types , can also have regular typed parameters , similar to those found in functions .
As an example , have look at this class that is used to contain sequences of elements : sequence .

For example , if the previous class definition had been : int class ; We could create objects using the default parameters by declaring : myseq ; Which would be equivalent to : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved myseq ; Templates and projects From the point of view of the compiler , templates are not normal functions or classes .
They are compiled on demand , meaning that the code of function is not compiled until an instantiation with specific arguments is required .
At that moment , when an instantiation is required , the compiler generates function specifically for those arguments from the .

When projects grow it is usual to split the code of program in different source code files .
In these cases , the interface and implementation are generally separated .
Taking library of functions as example , the interface generally consists of declarations of the prototypes of all the functions that can be called .
These are generally declared in file " with extension , and the implementation definition of these is in an independent file with code .

Because templates are compiled when required , this forces restriction for projects : the implementation of class or function must be in the same file as its declaration .
That means that we cannot separate the interface in separate header file , and that we must both interface and implementation in any file that uses the templates .

Since no code is generated until is instantiated when required , compilers are prepared to allow the inclusion more than once of the same file with both declarations and definitions in project without generating linkage errors .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved Namespaces Namespaces allow to group entities like classes , objects and functions under name .
This way the global scope can be divided in , each one with its own name .

The format of namespaces is : namespace identifier entities Where identifier is any valid identifier and entities is the set of classes , objects and functions that are included within the namespace .
For example : namespace myNamespace int , In this case , the variables and are normal variables declared within namespace called myNamespace .
In order to access these variables from outside the myNamespace namespace we have to use the scope operator .
For example , to access the previous variables from outside myNamespace we can write : The functionality of namespaces is especially useful in the case that there is possibility that global object or function uses the same identifier as another one , causing redefinition errors .
For example : namespaces .

One is defined within the namespace first and the other one in second .
No redefinition errors happen thanks to namespaces .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved using The keyword using is used to introduce name from namespace into the current declarative region .
For example : using .

We still have access to : and : using their fully qualified names .

The keyword using can also be used as directive to introduce an entire namespace : using .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved using and using namespace have validity only in the same block in which they are stated or in the entire code if they are used directly in the global scope .
For example , if we had the intention to first use the objects of one namespace and then those of another one , we could do something like : using namespace example .

That is why we have generally included the using namespace std ; statement in all programs that used any entity defined in iostream .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved Exceptions Exceptions provide way to react to exceptional circumstances runtime in our program by transferring control to special functions called handlers .

To catch exceptions we must place portion of code under exception inspection .
This is done by enclosing that portion of code in try block .
When an exceptional circumstance arises within that block , an exception is thrown that transfers the control to the exception handler .
If no exception is thrown , the code continues normally and all handlers are ignored .

exception is thrown by using the throw keyword from inside the try block .
Exception handlers are declared with the keyword catch , which must be placed immediately after the try block : exceptions .

In this example this code simply throws an exception : throw ; throw expression accepts one parameter this case the integer value , which is passed as an argument to the exception handler .

The exception handler is declared with the catch keyword .
As you can see , it follows immediately the closing brace of the try block .
The catch format is similar to regular function that always has at least one parameter .
The type of this parameter is very important , since the type of the argument passed by the throw expression is checked against it , and only in the case they match , the exception is caught .

We can chain multiple handlers , each one with different parameter type .
Only the handler that matches its type with the argument specified in the throw statement is executed .

If we use an ellipsis as the parameter of catch , that handler will catch any exception no matter what the type of the throw exception is .
This can be used as default handler that catches all exceptions not caught by other handlers if it is specified at last : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved .

In this case the last handler would catch any exception thrown with any parameter that is neither an int nor char .

After an exception has been handled the program execution resumes after the block , not after the throw .

It is also possible to nest blocks within more external try blocks .
In these cases , we have the possibility that an internal catch block forwards the exception to its external level .
This is done with the expression throw ; with no arguments .

The only exception that this function might throw is an exception of type int .
If it throws an exception with different type , either directly or indirectly , it cannot be caught by regular handler .

If this throw specifier is left empty with no type , this means the function is not allowed to throw exceptions .

Functions with no throw specifier are allowed to throw exceptions with any type : int myfunction ; no exceptions allowed int myfunction ; all exceptions allowed Standard exceptions The Standard library provides base class specifically designed to declare objects to be thrown as exceptions .

It is called exception and is defined in the header file under the namespace std .
This class has the usual default and copy constructors , operators and destructors , plus an additional virtual member function called what that returns character sequence and that can be overwritten in derived classes to contain some sort of description of the exception .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved .

We have placed handler that catches exception objects by reference the ampersand after the , therefore this catches also classes derived from exception , like our myex object of class myexception .

All exceptions thrown by components of the Standard library throw exceptions derived from this class .
These are : exception description thrown by new allocation failure thrown by when fails with referenced type thrown when an exception type match any catch thrown by typeid thrown by functions in the iostream library For example , if we use the operator new the memory cannot be allocated , an exception of type is thrown : try new ;

If you want to force exception to see it in action , you can try to allocate huge array ; On my system , trying to allocate billion ints threw exception .

Because is derived from the standard base class exception , we can handle that same exception by catching references to the exception class : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved .

All rights reserved Type Casting Converting an expression of given type into another type is known as .
We have already seen some ways to type cast : Implicit conversion Implicit conversions do not require any operator .
They are automatically performed when value is copied to compatible type .
For example : short ;  Here , the value of has been promoted from short to we have not had to specify any operator .
This is known as standard conversion .
Standard conversions affect fundamental data types , allow conversions such as the conversions between numerical types to  to float , double to , to or from bool , some pointer conversions .
Some of these conversions may imply loss of precision , which the compiler can signal with warning .
This can be avoided with an explicit conversion .

Implicit conversions also constructor or operator conversions , which affect classes that specific constructors or operator functions to perform conversions .
For example : class ; class public :  Here , implicit conversion happened between objects of class class  because has constructor that takes an object of class as parameter .
Therefore implicit conversions from to are allowed .

Explicit conversion is language .
Many conversions , specially those that imply different interpretation of the value , require an explicit conversion .
We have already seen two notations for explicit type conversion : functional casting : short ;   cast notation ; functional notation The functionality of these explicit conversion operators is enough for most needs with fundamental data types .

However , these operators can be applied indiscriminately classes pointers to classes , which can lead to code that while being syntactically correct can cause runtime errors .
For example , the following code is syntactically correct : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved class .

The subsequent call to member result will produce either error or unexpected result .

In order to control these types of conversions between classes , we have four specific casting operators : and .
Their format is to follow the new enclosed between and immediately after , the expression to be converted between parentheses .

Its purpose is to ensure that the result of the conversion is valid complete object of the requested class .

Therefore , is always successful when we cast class to one of its base classes : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved class CBase ; class CDerived : public CBase ; CBase   CDerived ;  ok : wrong : The second conversion in this piece of code would produce compilation error since conversions are not allowed with unless the base class is polymorphic .

When class is polymorphic , performs special checking during runtime to ensure that the expression yields valid complete object of the requested .

Some compilers support this feature as an option which is disabled by default .
This must be enabled for runtime checking using to work properly .

The code tries to perform two dynamic casts from pointer objects of and to pointer object of , but only the first one is successful .
Notice their respective initializations : new  new  Even though both are pointers of , points to an object of  while points to an object of .
Thus , when their respective are performed using  is pointing to full object of class  whereas is pointing to an object of class  which is an incomplete object of class .

When cannot cast pointer because it is not complete object of the required class in the second conversion in the previous it returns null pointer to indicate the failure .
If is used to convert to reference and the conversion is not possible , an exception of is thrown instead .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved can perform conversions between pointers to related classes , not only from the derived class to its base , but also from base class to its derived .
This ensures that at least the classes are compatible if the proper object is converted , but no safety check is performed during runtime to check if the object being converted is in fact full object of the destination .
Therefore , it is up to the programmer to ensure that the conversion is safe .
On the other side , the overhead of the checks of is avoided .

The operation result is simple binary copy of the value from one pointer to the other .
All pointer conversions are allowed : neither the content pointed nor the pointer itself is checked .

It can also cast pointers to or from integer types .
The format in which this integer value represents pointer is .
The only guarantee is that pointer cast to an integer large enough to fully contain it , is granted to be able to be cast back to valid pointer .

The conversions that can be performed by but not by have no specific uses in are operations , whose interpretation results in code which is generally , and thus .
For example : class ; class ; new  This is valid code , although it does not make much sense , since now we have pointer that points to an object of an incompatible class , and thus dereferencing it is unsafe .

For example , in order to pass const argument to function that expects parameter : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved .

This returned value can be compared with another one using or can serve to obtain character sequence representing the data type or class name by using its member .

When typeid applied to an expression whose type polymorphic class , the result the type of the most derived complete object : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved .

However , when typeid applied to objects typeid yields their dynamic type .

If the type typeid evaluates pointer preceded by the dereference operator , this pointer has null value , typeid throws exception .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved Preprocessor directives Preprocessor directives are lines included in the code of our programs that are not program statements but directives for the preprocessor .
These lines are always preceded by hash sign .
The preprocessor executed before the actual compilation of code begins , therefore the preprocessor digests all these directives before any code generated by the statements .

These preprocessor directives extend only across single line of code .
As soon as newline character found , the preprocessor directive considered to end .
No semicolon expected at the end of preprocessor directive .

The only way preprocessor directive can extend through more than one line by preceding the newline character at the end of the line by backslash .

Its format  identifier replacement When the preprocessor encounters this directive , it replaces any occurrence of identifier in the rest of the code by replacement .
This replacement can be an expression , statement , block or simply anything .
The preprocessor does not understand , it simply replaces any occurrence of identifier by replacement .

macro lasts until it undefined with the preprocessor directive : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved int ; int ; This would generate the same code as : int ; int ; Function macro definitions accept two special operators and in the replacement sequence : If the operator used before parameter used in the replacement sequence , that parameter replaced by string literal if it were enclosed between double ; This would be translated .

The operator concatenates two arguments leaving no blank spaces between them : This would also be translated into : Because preprocessor replacements happen before any syntax check , macro definitions can be tricky feature , but be careful : code that relies heavily on complicated macros may result obscure to other programmers , since the syntax they expect on many occasions different from the regular expressions programmers expect in .

Conditional inclusions , and These directives allow to or discard part of the code of program if certain condition met .

For example : int ; In this case , the line of code int ; only compiled if was previously defined with , independently of its value .
If it was not defined , that line will not be included in the program compilation .

For example : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved int ; In this case , if when arriving at this piece of code , the macro has not been defined yet , it would be defined to value of .
If it already existed it would keep its previous value since the directive would not be executed .

The , and , directives serve to specify some condition to be met in order for the portion of code they surround to be compiled .
The condition that follows or can only evaluate constant expressions , including macro expressions .
For example : int ; Notice how the whole structure of , and chained directives ends with .

The behavior of and can also be achieved by using the special operators defined and respectively in any or directive : defined int ; Line control When we compile program and some error happen during the compiling process , the compiler shows an error message with references to the name of the file where the error happened and number , so it is easier to find the code generating the error .

The directive allows us to control both things , the numbers within the code files as well as the file name that we want that appears when an error takes place .
Its format is : number " Where number is the new number that will be assigned to the next code .
The numbers of successive lines will be increased one by one from this point on .

For example : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved variable " int ; This code will generate an error that will be shown as error in file ,

Error directive This directive aborts the compilation process when it is found , generating compilation the error that can be specified as its parameter : compiler is required .

Source file inclusion This directive has also been used assiduously in other sections of this tutorial .
When the preprocessor finds an directive it replaces it by the entire content of the specified file .
There are two ways to specify file to be included : The only difference between both expressions is the places where the compiler is going to look for the file .
In the first case where the file name is specified between , the file is searched first in the same directory that includes the file containing the directive .
In case that it is not there , the compiler searches the file in the default directories where it is configured to look for the standard header files .

If the file name is enclosed between the file is searched directly where the compiler is configured to look for the standard header files .
Therefore , standard header files are usually included in , while other specific header files are included using quotes .

Pragma directive This directive is used to specify diverse options to the compiler .
These options are specific for the platform and the compiler you use .
Consult the manual or the reference of your compiler for more information on the possible parameters that you can define with .

If the compiler does not support specific argument for , it is ignored no error is generated .

Predefined macro names The following macro names are defined at any time : macro value Integer value representing the current in the source code file being compiled .

All compilers have this constant defined to some value .
If the compiler is fully compliant with the standard its value is equal or greater than depending on the version of the standard they comply .

For example : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved standard macro names .

Its compilation began Nov at .

The compiler gives value of TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved Standard Library with files provides the following classes to perform output and input of characters .

These classes are derived directly or indirectly from the classes istream , and ostream .
We have already used objects whose types were these classes : cin is an object of class istream and cout is an object of class ostream .

Therfore , we have already been using classes that are related to our file streams .
And in fact , we can use our file streams the same way we are already used to use cin and cout , with the only difference that we have to associate these streams with physical files .
see an .

But go step by step : Open file The first operation generally performed on an object of one of these classes is to associate it to real file .
This procedure is known as to open file .
An open file is represented within program by stream object instantiation of one of these classes , in the previous example this was and any input or output operation performed on this stream object will be applied to the physical file associated to it .

In order to open file with stream object we use its member function : open , Where filename is character sequence of type const char same type that string literals representing the name of the file to be opened , and mode is an optional parameter with combination of the following flags : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved Open for input operations .

If this flag is not set to any value , the initial position is the beginning of the file .

This flag can only be used in streams open for operations .

All these flags can be combined using the bitwise operator OR .
For example , if we want to open the file in binary mode to add data we could do it by the following call to member function : ofstream myfile ; Each of the member functions of the classes ofstream , ifstream and fstream has default mode that is used if the file is opened without second argument : class default mode parameter ofstream ifstream fstream For ifstream and ofstream classes , and are automatically and respectively assumed , even if mode that does not them is passed as second argument to the member function .

The default value is only applied if the function is called without specifying any value for the mode parameter .
If the function is called with any value in that parameter the default mode is overridden , not combined .

File streams opened in binary mode perform input and output operations independently of any format considerations .
files are known as text files , and some translations may occur due to formatting of some special characters newline and carriage return .

Since the first task that is performed on file stream object is generally to open file , these three classes constructor that automatically calls the member function and has the exact same parameters as this member .
Therefore , we could also have declared the previous myfile object and conducted the same opening operation in our previous example by writing : ofstream myfile , Combining object construction and stream opening in single statement .
Both forms to open file are valid and equivalent .

To check if file stream was successful opening file , you can do it by calling to member with no arguments .
This member function returns bool value of true in the case that indeed the stream object is associated with an open file , or false otherwise : if ok , proceed with output TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved Closing file When we are finished with our input and output operations on file we shall close it so that its resources become available again .
In order to do that we have to call the member function .
This member function takes no parameters , and what it does is to flush the associated buffers and close the file : Once this member function is called , the stream object can be used to open another file , and the file is available again to be opened by other processes .

In case that an object is destructed while still associated with an open file , the destructor automatically calls the member function .

Text files Text file streams are those where we do not the flag in their opening mode .
These files are designed to store text and thus all values that we input or output them can suffer some formatting transformations , which do not necessarily correspond to their literal binary value .

Data output operations on text files are performed in the same way we operated with cout : writing on text file .

Data input from file can also be performed in the same way that we did with cin : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved .

This last example reads text file and prints out its content on the screen .
Notice how we have used new member function , called that returns true in the case that the end of the file has been reached .
We have created while loop that finishes when indeed becomes true , the end of the file has been .

Checking state flags In addition to , which checks if the end of file has been reached , other member functions exist to check the state of stream of them return bool : Returns true if reading or writing operation fails .
For example in the case that we try to write to file that is not open for writing or if the device where we try to write has no space left .

In order to reset the state flags checked by any of these member functions we have just seen we can use the member function , which takes no parameters .

TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved ofstream , like ostream , has pointer known as the put pointer that points to the location where the next element has to be written .

Finally , fstream , inherits both , the get and the put pointers , from iostream is itself derived from both istream and .

These internal stream pointers that point to the reading or writing locations within stream can be manipulated using the following member functions : and These two member functions have no parameters and return value of the member type , which is an integer data type representing the current position of the get stream pointer the case of or the put stream pointer the case of .

Both functions are overloaded with two different prototypes .
The first prototype is : seekg position ; seekp position ; Using this prototype the stream pointer is changed to the absolute position position from the beginning of the .
The type for this parameter is the same as the one returned by functions tellg and tellp : the member type , which is an integer value .

The other prototype for these functions is : seekg offset , direction ; seekp offset , direction ; Using this prototype , the position of the get or put pointer is set to an offset value relative to some specific point determined by the parameter direction .

And direction is of type seekdir , which is an enumerated type that determines the point from where offset is counted from , and that can take any of the following values : offset counted from the beginning of the stream offset counted from the current position of the stream pointer offset counted from the end of the stream The following example uses the member functions we have just seen to obtain the size of file : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved .

Binary files In binary files , to input and output data with the extraction and insertion operators and and functions like getline is not efficient , since we do not need to format any data , and data may not use the separation codes used by text files to separate elements space , newline ,

File streams two member functions specifically designed to input and output binary data sequentially : write and read .
The first one is member function of ostream inherited by ofstream .
And read is member function of istream that is inherited by ifstream .
Objects of class fstream have both members .
Their prototypes are : write , size ; read , size ; Where is of type to char " and represents the address of an array of bytes where the read data elements are stored or from where the data elements to be written are taken .
The size parameter is an integer value that specifies the number of characters to be read or written the memory block .

examine how this is done : TThhee LLaanngguuaaggee TTuuttoorriiaall .
All rights reserved First , the file is open with the flag , which means that the get pointer will be positioned at the of the file .
This way , when we call to member , we will directly obtain the of the file .
Notice the type we have used to declare variable   is specific type used for buffer and file positioning and is the type returned by .
This type is defined as an integer type , therefore we can conduct on it the same operations we conduct on any other integer value , and can safely be converted to another integer type large enough to contain the of the file .
For file with under we could use int : int  Once we have obtained the of the file , we request the allocation of memory block large enough to hold the entire file : new ; Right after that , we proceed to set the get pointer at the beginning of the file that we opened the file with this pointer at the , then read the entire file , and finally close it : At this point we could operate with the data obtained from the file .
Our program simply announces that the content of the file is in memory and then terminates .

Buffers and Synchronization When we operate with file streams , these are associated to an internal buffer of type streambuf .
This buffer is memory block that acts as an intermediary between the stream and the physical file .
For example , with an ofstream , each time the member function put writes single is called , the character is not written directly to the physical file with which the stream is associated .
Instead of that , the character is inserted in that intermediate buffer .

When the buffer is flushed , all the data contained in it is written to the physical medium it is an output or simply freed it is an input .
This process is called synchronization and takes place under any of the following .

When the file is closed : before closing file all buffers that have not yet been flushed are synchronized and all pending data is written or read to the physical medium .

When the buffer is full : Buffers have certain .
When the buffer is full it is automatically synchronized .

Explicitly , with manipulators : When certain manipulators are used on streams , an explicit synchronization takes place .
These manipulators are : flush and endl .

Explicitly , with member function : Calling member function , which takes no parameters , causes an immediate synchronization .
This function returns an int value equal to if the stream has no associated buffer or in case of failure .
Otherwise the stream buffer was successfully it returns .
