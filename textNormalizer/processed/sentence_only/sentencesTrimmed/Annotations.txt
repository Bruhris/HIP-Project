runs on variety of platforms , such as Windows , Mac OS , and the various versions of UNIX .

This tutorial adopts simple and practical approach to describe the concepts of .

Audience This tutorial has been prepared for the beginners to help them understand the basic to advanced concepts related to .

Prerequisites Before you start practicing with various types of examples given in this are making an assumption that you are already aware of the basics of computer program and computer programming language .

Copyright Disclaimer Copyright by Tutorials Point Pvt .

All the content and graphics published in this are the property of Tutorials Point Pvt .
The user of this is prohibited to reuse , retain , copy , distribute or republish any contents or part of contents of this in any manner without written consent of the publisher .

We strive to update the contents of our website and tutorials as timely and as precisely as possible , however , the contents may contain inaccuracies or errors .

Tutorials Point Pvt .

If you discover any errors on our website or in this tutorial , please notify us at Table of Contents About the Tutorial .
ENVIORNMENT SETUP .
BASIC SYNTAX .

DATA TYPES .
VARIABLE TYPES .
VARIABLE SCOPE .
MODIFIER TYPES .
STORAGE CLASSES .
LOOP TYPES .
STATEMENTS .
DATE AND TIME .
BASIC .
DATA STRUCTURES .
CLASSES AND OBJECTS .
OVERLOADING .
DATA ABSTRACTION .
DATA ENCAPSULATION .
FILES AND STREAMS .
EXCEPTION HANDLING .
DYNAMIC MEMORY .
SIGNAL HANDLING .
WEB PROGRAMMING .
STL TUTORIAL .
STANDARD LIBRARY .

is regarded as language , as it comprises combination of both language features .

was developed by Bjarne Stroustrup starting in at Bell Labs in Murray Hill , New Jersey , as an enhancement to the language originally named with Classes but later it was renamed in .

is superset of , that virtually any legal program is legal program .

Note : programming language is said to use static typing when type checking is performed during as opposed to .

Programming fully supports programming , including the four pillars of development : Encapsulation Data hiding Inheritance Polymorphism Standard Libraries Standard consists of three important parts : The core language giving all the building blocks including variables , data types literals , etc .

The ANSI Standard The ANSI standard is an attempt to ensure that is portable ; that code you write for compiler will compile without errors , using compiler on Mac , UNIX , Windows box , or an Alpha .

OVERVIEW The ANSI standard has been stable for while , and all the major compiler manufacturers support the ANSI standard .

Learning The most important thing while learning is to focus on concepts .

The purpose of learning programming language is to become better programmer ; that is , to become more effective at designing and implementing new and at maintaining old ones .

supports variety of programming styles .
You can write in the style of Fortran , Smalltalk , in any language .
Each style can achieve its aims effectively while maintaining runtime and space efficiency .

Use of is used by hundreds of thousands of programmers in essentially every application domain .

is being highly used to write device drivers and other software that rely on direct manipulation of hardware under constraints .

is widely used for teaching and research because it is clean enough for successful teaching of basic concepts .

Anyone who has used either an Apple Macintosh or PC running Windows has indirectly used because the primary user interfaces of these are written in .

Try it Option Online You really do not need to set up your own environment to start learning programming language .
Reason is very simple , we have already set up Programming environment online , so that you can compile and execute all the available examples online at the same time when you are doing your theory work .
This gives you confidence in what you are reading and to check the result with different options .
Feel free to modify any example and execute it online .

Try the following example using our online compiler option available at .

So just make use of it and enjoy your learning .

Local Environment Setup If you are still willing to set up your environment for , you need to have the following two softwares on your computer .

Text Editor : This will be used to type your program .
Examples of few editors Windows Notepad , OS Edit command , Brief , Epsilon , EMACS , and vim or vi .

Name and version of text editor can vary on different operating .
For example , Notepad will be used on Windows and vim or vi can be used on windows as well as Linux , or UNIX .

The files you create with your editor are called source files and for they typically are named with the extension , or .

text editor should be in place to start your programming .

ENVIORNMENT SETUP Compiler : This is an actual compiler , which will be used to compile your source code into final executable program .

Most compilers care what extension you give to your source code , but if you specify otherwise , many will use by default .

Most frequently used and free available compiler is GNU compiler , otherwise you can have compilers either from HP or Solaris if you have the respective Operating Systems .

Installing GNU Compiler : Installation : If you are using Linux or UNIX then check whether GCC is installed on your system by entering the following command from the command line : If you have installed GCC , then it should print message such as the following : Using specs .

Target : Configured with :

Thread model : posix gcc version Hat If GCC is not installed , then you will have to install it yourself using the detailed instructions available at .

Mac OS Installation : If you use Mac OS , the easiest way to obtain GCC is to download the Xcode development environment from website and follow the simple installation instructions .

Xcode is currently available at .

Windows Installation : To install GCC at Windows you need to install MinGW .
To install MinGW , go to the MinGW homepage , and follow the link to the MinGW download page .
Download the latest version of the MinGW installation program which should be named .

While installing MinGW , at minimum , you must install , binutils , and the MinGW runtime , but you may wish to install more .

Add the bin subdirectory of your MinGW installation to your PATH environment variable so that you can specify these tools on the command line by their simple names .

When the installation is complete , you will be able to run gcc , ar , ranlib , dlltool , and several other GNU tools from the Windows command line .

When we consider program , it can be defined as collection of objects that communicate via invoking each methods .
Let us now briefly look into what class , object , methods , and instant variables mean .

Example : dog has states color , name , breed as well as behaviors wagging , barking , and eating .

An object is an instance of class .

It is in methods where the logics are written , data is manipulated and all the actions are executed .

An state is created by the values assigned to these instant variables .

Program Structure : Let us look at simple code that would print the words Hello World .

The language defines several headers , which contain information that is either necessary or useful to your program .
For this program , the header is needed .

The line using namespace std ; tells the compiler to use the std namespace .
Namespaces are relatively recent addition to .

BASIC SYNTAX .
The next line is where program execution ' is comment available in .
comments begin with and stop at the end of the line .

The line int is the main function where program execution begins .

The next line is my first ; causes the message is my first program " to be displayed on the screen .

The next line return ; terminates function and causes it to return the value to the calling process .

Compile Execute Program : look at how to save the file , compile and run the program .
Please follow the steps given below :
Open text editor and add the code as above .

Open command prompt and go to the directory where you saved the file .

Type ' and press enter to compile your code .
If there are no errors in your code the command prompt will take you to the next line and would generate executable file .

Now , type ' to run your program .

You will be able to see  Hello World  printed on the window .

You can compile programs using makefile .
For more details , you can check our .

Semicolons Blocks in In , the semicolon is statement terminator .
That is , each individual statement must be ended with semicolon .
It indicates the end of one logical entity .

For example , following are three different statements :  block is set of logically connected statements that are surrounded by opening and closing braces .

For this reason , it does not matter where you put statement in line .
For example :  is the same as  Identifiers identifier is name used to identify variable , function , class , module , or any other item .
An identifier starts with letter to or to or an underscore followed by zero or more letters , underscores , and digits to .

does not allow punctuation characters such as , and within identifiers .

is programming language .

Thus , Manpower and manpower are two different identifiers in .

Here are some examples of acceptable identifiers : mohd zara abc retVal Keywords The following list shows the reserved words in .
These reserved words may not be used as constant or variable or any other identifier names .

trigraph is sequence that represents single character and the sequence always starts with two question marks .

Trigraphs are expanded anywhere they appear , including within string literals and character literals , in comments , and in preprocessor directives .

Following are most frequently used trigraph sequences : Trigraph Replacement '

Whitespace in line containing only whitespace , possibly with comment , is known as blank line , and compiler totally ignores it .

Whitespace is the term used in to describe blanks , tabs , newline characters comments .
Whitespace separates one part of statement from another enables the compiler to identify where one element in statement , such as int , ends the next element begins .
Statement : int age ; In the above statement there must be at least one whitespace character int age for the compiler to be able to distinguish them .

Statement : apples + oranges ; Get the total In the above statement , no whitespace characters are necessary , or apples , although you are free to include some if you wish for readability purpose .

Program comments are explanatory statements that you can include in the code .
These comments help anyone reading the source code .
All programming languages allow for some form of comments .

supports comments .
All characters available inside any comment are ignored by compiler .

comments start with end with .
For example : This is comment comments can also span multiple lines comment can also start with , extending to the end of the line .
For example :

Within comment , have no special meaning .
Thus , you can " one kind of comment within the other kind .
For example : Comment out printing of Hello World :
COMMENTS IN ; prints Hello World While writing program in any language , you need to use various variables to store various information .
Variables are nothing but reserved memory locations to store values .
This means that when you create variable you reserve some space in memory .

You may like to store information of various data types like character , wide character , integer , floating point , double floating point , boolean etc .
Based on the data type of variable , the operating system allocates memory decides what can be stored in the reserved memory .

Primitive Types offers the programmer rich assortment of as well as user defined data types .
Following table lists down seven basic data types : Type Keyword Boolean bool Character char Integer int Floating point float Double floating point double Valueless void Wide character Several of the basic types can be modified using one or more of these type modifiers : signed unsigned short long .
DATA TYPES The following table shows the variable type , how much memory it takes to store the value in memory , what is maximum minimum value which can be stored in such type of variables .

Type Typical Bit Width Typical Range char to or to unsigned char to signed char to int to unsigned int to signed int to short int to unsigned short int Range to signed short int Range to long int to signed long int same as long int unsigned long int to float double long double or bytes wide character The size of variables might be different from those shown in the above table , depending on the compiler and the computer you are using .

Following is the example , which will produce correct size of various data types on your computer .

We are also using function to get size of various data types .

When the above code is compiled and executed , it produces the following result which can vary from machine to machine : Size of  Size of  Size of short  Size of long  Size of  Size of  Size of  typedef Declarations You can create new for an existing using typedef .
Following is the simple syntax to define new using typedef : typedef newname ; For example , the following tells the compiler that feet is another for  typedef feet ; Now , the following declaration is perfectly legal and creates an integer variable called distance : feet distance ; Enumerated Types An enumerated declares an optional and set of zero or more identifiers that can be used as values of the .
Each enumerator is constant whose is the enumeration .

Creating an enumeration requires the use of the keyword enum .
The general form of an enumeration is : enum list of names ; Here , the is the .
The list of names is comma separated .

For example , the following code defines an enumeration of colors called colors and the variable of color .
Finally , is assigned the value .

But you can give  specific value by adding an initializer .

For example , in the following enumeration , will have the value .

variable provides us with named storage that our programs can manipulate .

Each variable in has specific  which determines the size and layout of the memory ; the range of values that can be stored within that memory ; and the set of operations that can be applied to the variable .

The of variable can be composed of letters , digits , and the underscore character .
It must begin with either letter or an underscore .
Upper and lowercase letters are distinct because is : There are following basic types of variable in as explained in last chapter : Type Description bool Stores either value true or false .

Typically single octet .

The most natural size of integer for the machine .

floating point value .

wide character .

also allows to define various other types of variables , which we will cover in subsequent chapters like Enumeration , Pointer , Array , Reference , Data structures , and Classes .

Following section will cover how to define , declare and use various types of variables .

Variable Definition in variable definition tells the compiler where and how much storage to create for the variable .
variable definition specifies data  and contains list of one or more variables of that as follows :
VARIABLE TYPES ; Here , must be valid data including char ,    bool or any object , and may consist of one or more identifier names separated by commas .
Some valid declarations are shown here : int , char  ch ; float  salary ; double  The line int , both declares and defines the variables , and ; which instructs the compiler to create variables named , and of int .

Variables can be initialized an initial in their declaration .
The initializer consists of an equal sign followed by constant expression as follows : type value ; Some examples are : extern int , declaration of and .

For definition without an initializer : variables with static storage duration are implicitly initialized with NULL bytes have the value ; the initial value of all other variables is undefined .

Variable Declaration in variable declaration provides assurance to the compiler that there is one variable existing with the given type and name so that compiler proceed for further compilation without needing complete detail about the variable .
variable declaration has its meaning at the time of compilation only , compiler needs actual variable declaration at the time of linking of the program .

variable declaration is useful when you are using multiple files and you define your variable in one of the files which will be available at the time of linking of the program .
You will use extern keyword to declare variable at any place .

Though you can declare variable multiple times in your program , but it can be defined only once in file , function or block of code .

Example : Try the following example where variable has been declared at the top , but it has been defined inside the main function : using namespace std ; Variable declaration : extern int , extern int c ; extern float  int main Variable definition : int   int  float  actual initialization ; +  cout endl  cout endl  return ; When the above code is compiled and executed , it produces the following result : Same concept applies on function declaration where you provide function name at the time of its declaration and its actual definition can be given anywhere else .

An lvalue may appear as either the or side of an assignment .

An rvalue is an expression that cannot have value assigned to it which means an rvalue may appear on the but not side of an assignment .

Variables are lvalues and so may appear on the side of an assignment .

Numeric literals are rvalues and so may not be assigned and cannot appear on the side .
Following is valid statement : int ; But the following is not valid statement and would generate error : scope is region of the program and broadly speaking there are three places , where variables can be declared : Inside function or block which is called local variables , In the definition of function parameters which is called formal parameters .

We will learn what function is , and parameter in subsequent chapters .
Here let us explain what local and global variables are .

Local Variables Variables that are declared inside function or block are local variables .
They can be used only by statements that are inside that function or block of code .

Local variables are not known to functions outside their own .
Following is the example using local variables :

VARIABLE SCOPE Global Variables Global variables are defined outside of all the functions , usually on top of the program .
The global variables will hold their value throughout the of your program .

global variable can be accessed by any function .
That is , global variable is available for use throughout your entire program after its declaration .
Following is the example using global and local variables : using namespace .

Global variables are initialized automatically by the system when you define them as follows : Data Type Initializer int char ' float double pointer NULL It is good programming practice to initialize variables properly , otherwise sometimes program would produce unexpected result .

Constants refer to fixed values that the program may not alter and they are called literals .

Constants can be of any of the basic data types and can be divided into Integer Numerals , Numerals , Characters , Strings and Boolean Values .

Again , constants are treated just like regular variables except that their values cannot be modified after their definition .

Integer Literals An integer literal can be decimal , octal , or hexadecimal constant .
prefix specifies the base or radix : or for hexadecimal , for octal , and nothing for decimal .

An integer literal can also have suffix that is combination of and , for unsigned and long , respectively .
The suffix can be uppercase or lowercase and can be in any order .

Here are some examples of integer literals : Legal .

Literals literal has an integer part , decimal point , fractional part , and an exponent part .
You can represent floating point literals either in decimal form or exponential form .

While representing using decimal form , you must the decimal point , the exponent , or both and while representing using exponential form , you must the integer part , the fractional part , or both .
The signed exponent is introduced by or .

Here are some examples of .

Boolean Literals There are two Boolean literals and they are part of standard keywords : value of true representing true .

You should not consider the value of true equal to and value of false equal to .

Character Literals Character literals are enclosed in single quotes .
If the literal begins with , it is wide character literal , and should be stored in type of variable .
Otherwise , it is narrow character literal , and can be stored in simple variable of char type .

character literal can be plain character , an escape sequence , or universal character ,

There are certain characters in when they are preceded by backslash they will have special meaning and they are used to represent like newline or tab .
Here , you have list of some of such escape sequence codes : Escape sequence Meaning character '  character "  character .

Hexadecimal number of one or more digits Following is the example to show few escape sequence characters :

string contains characters that are similar to character literals : plain characters , escape sequences , and universal characters .

You can break long line into multiple lines using string literals and separate them using whitespaces .

Here are some examples of string literals .
All the three forms are identical strings .

The Preprocessor Following is the form to use preprocessor to define constant : identifier value Following example explains it in detail : using namespace std ; LENGTH WIDTH NEWLINE ' int int  LENGTH WIDTH ; cout  cout NEWLINE ; return ; When the above code is compiled and executed , it produces the following result : The const Keyword You can use const prefix to declare constants with specific type as follows : const type value ; Following example explains it in detail :

allows the char , int , and double data types to have modifiers preceding them .
modifier is used to alter the meaning of the base type so that it more precisely fits the needs of various situations .

The data type modifiers are listed here : signed unsigned long short The modifiers signed , unsigned , long , and short can be applied to integer base types .
In addition , signed and unsigned can be applied to char , and long can be applied to double .

The modifiers signed and unsigned can also be used as prefix to long or short modifiers .
For example , unsigned long int .

allows shorthand notation for declaring unsigned , short , or long integers .
You can simply use the word unsigned , short , or long , without int .
It automatically implies int .
For example , the following two statements both declare unsigned integer variables .

MODIFIER TYPES ;  cout    return ; When this program is run , following is the output : The above result is because the bit pattern that represents as short unsigned integer is interpreted as by short .

Type Qualifiers in The type qualifiers provide additional information about the variables they precede .

Qualifier Meaning const Objects of const cannot be changed by your program during execution volatile The modifier volatile tells the compiler that value may be changed in ways not explicitly specified by the program .

Only adds new qualifier called restrict .

storage class defines the scope and of variables functions within Program .
These specifiers precede the that they modify .
There are following storage classes , which can be used in Program auto register static extern mutable The auto Storage Class The auto storage class is the default storage class for all local variables .

The register Storage Class The register storage class is used to define local variables that should be stored in register instead of RAM .
This means that the variable has maximum size equal to the register size one and have the unary ' operator applied to it it does not have memory .

It should also be noted that defining ' does not mean that the variable will be stored in register .
It means that it MIGHT be stored in register depending on hardware and implementation restrictions .

The static Storage Class .
STORAGE CLASSES The static storage class instructs the compiler to keep local variable in existence during the of the program instead of creating and destroying it each time it comes into and goes out of scope .
Therefore , making local variables static allows them to maintain their values between function calls .

The static modifier may also be applied to global variables .
When this is done , it causes that scope to be restricted to the file in which it is declared .

In , when static is used on class data member , it causes only one copy of that member to be shared by all objects of its class .

When you use ' the variable cannot be initialized as all it does is point the variable name at storage location that has been previously defined .

When you have multiple files and you define global variable or function , which will be used in other files also , then extern will be used in another file to give reference of defined variable or function .
Just for understanding extern is used to declare global variable or function in another file .

The extern modifier is most commonly used when there are two or more files sharing the same global variables or functions as explained below .

First File : int .

Second File : extern int  void is  Here , extern keyword is being used to declare in another file .
Now compile these two files as follows : write This will produce write executable program , try to execute write and check the result as follows : The mutable Storage Class The mutable specifier applies only to class objects , which are discussed later in this tutorial .
It allows member of an object to override const member function .

That is , mutable member can be modified by const member function .

An operator is symbol that tells the compiler to perform specific mathematical or logical manipulations .
is rich in operators and provide the following types of operators : Arithmetic Operators Relational Operators Logical Operators Bitwise Operators Assignment Operators Misc Operators This chapter will examine the arithmetic , relational , logical , bitwise , assignment and other operators one by one .

Arithmetic Operators There are following arithmetic operators supported by language : Assume variable holds and variable holds , then : Operator Description Example + Adds two operands + will give Subtracts second operand from the first will give Multiplies both operands will give Divides numerator by denumerator will give Modulus Operator and remainder of after an integer division will give .
OPERATORS Increment operator , increases integer value by one will give Decrement operator , decreases integer value by one will give Try the following example to understand all the arithmetic operators available in .

Copy and paste the following program in file and compile and run this program .

operand is greater than or equal to the value of right operand , if yes then condition becomes true .

Try the following example to understand all the relational operators available in .

Copy and paste the following program in file and compile and run this program .

Assume variable holds and variable holds , then : Operator Description Example Called Logical AND operator .
If both the operands are , then condition becomes true .

If any of the two operands is nonzero , then condition becomes true .

Called Logical NOT Operator .

Use to reverses the logical state of its operand .
If condition is true , then Logical NOT operator will make false .

Try the following example to understand all the logical operators available in .

Copy and paste the following program in file and compile and run this program .

The truth tables for , and are as follows : Assume if ; and ; now in binary format they will be as follows : The Bitwise operators supported by language are listed in the following table .
Assume variable holds and variable holds , then : Operator Description Example Binary AND Operator copies bit to the result if it exists in both operands .

The left operands value is moved left by the number of bits specified by the right operand .

The left operands value is moved right by the number of bits specified by the right operand .

Copy and paste the following program in file and compile and run this program .

Copy and paste the following program in file and compile and run this program .

Operator Description sizeof sizeof operator returns the size of variable .
For example , where ' is integer , and will return .

 Conditional operator .
If Condition is true then it returns value of otherwise returns value of .

The value of the entire comma expression is the value of the last expression of the list .

Cast Casting operators convert one data type to another .

For example , would return .

For example ; will give actual address of the variable .

For example ; will pointer to variable var .

Operators Precedence in Operator precedence determines the grouping of terms in an expression .
This affects how an expression is evaluated .
Certain operators have higher precedence than others ; for example , the multiplication operator has higher precedence than the addition operator : For example + here , is assigned , not because operator has higher precedence than + so it first gets multiplied with and then adds into .

Here , operators with the highest precedence appear at the top of the table , those with the lowest appear at the bottom .
Within an expression , higher precedence operators will be evaluated first .

Category Operator Associativity Postfix arrow_operator
Copy and paste the following program in file and compile and run this program .

Check the simple difference with and without parenthesis .
This will produce different results because , and + have different precedence .
Higher precedence operators will be evaluated .

In general , statements are executed sequentially : The first statement in function is executed first , followed by the second , and so on .

Programming languages provide various control structures that allow for more complicated execution paths .

loop statement allows us to execute statement or group of statements multiple times and following is the general from of loop statement in most of the programming languages : programming language provides the following type of loops to handle looping requirements .

Loop Type Description while loop Repeats statement or group of statements while given condition is true .
It tests the condition before executing the loop body .

LOOP TYPES loop Like ' statement , except that it tests the condition at the end of the loop body .

While Loop while loop statement repeatedly executes target statement as long as given condition is true .

Syntax The syntax of while loop in .

Here , may be single statement or block of statements .

The condition may be any expression , and true is any value .
The loop iterates while the condition is true .

When the condition becomes false , program control passes to the line immediately following the loop .

Flow Diagram Here , key point of the while loop is that the loop might not ever run .
When the condition is tested and the result is false , the loop body will be skipped and the first statement after the while loop will be executed .

Example .

Syntax The syntax of for loop in is : for init ; condition ; increment ; Here is the flow of control in for loop :
The init step is executed first , and only once .
This step allows you to declare and initialize any loop control variables .
You are not required to put statement here , as long as semicolon appears .

Next , the condition is evaluated .
If it is true , the body of the loop is executed .
If it is false , the body of the loop does not execute and flow of control jumps to the next statement just after the for loop .

After the body of the for loop executes , the flow of control jumps back up to the increment statement .
This statement allows you to update any loop control variables .
This statement can be left blank , as long as semicolon appears after the condition .

The condition is now evaluated again .
If it is true , the loop executes and the process repeats itself of loop , then increment step , and then again .
After the condition becomes false , the for loop terminates .

Flow Diagram Example .

loop is similar to while loop , except that loop is guaranteed to execute at least one time .

Syntax The syntax of loop in is : do ; condition ; Notice that the conditional expression appears at the end of the loop , so the in the loop execute once before the condition is tested .

If the condition is true , the flow of control jumps back up to do , and the in the loop execute again .
This process repeats until the given condition becomes false .

Flow Diagram Example .

allows at least levels of nesting .

Syntax The syntax for nested for loop statement in is as follows : for init ; condition ; increment .

When execution leaves scope , all automatic objects that were created in that scope are destroyed .

supports the following control statements .

Control Statement Description break statement Terminates the loop or switch statement and transfers execution to the statement immediately following the loop or switch .

Though it is not advised to use goto statement in your program .

Break Statement The break statement has the following two usages in : When the break statement is encountered inside loop , the loop is immediately terminated and program control resumes at the next statement following the loop .

If you are using nested loops , one loop inside another , the break statement will stop the execution of the innermost loop and start executing the next line of code after the block .

Syntax The syntax of break statement in is : break ; Flow Diagram Example .

Instead of forcing termination , however , continue forces the next iteration of the loop to take place , skipping any code in between .

For the for loop , continue causes the conditional test and increment portions of the loop to execute .
For the while and loops , program control passes to the conditional tests .

Syntax The syntax of continue statement in is : continue ; Flow Diagram Example .

NOTE : Use of goto statement is highly discouraged because it makes difficult to trace the control flow of program , making the program hard to understand and hard to modify .
Any program that uses goto can be rewritten so that it need the goto .

Syntax The syntax of goto statement in is : goto label ;

labeled statement is any statement that is preceded by an identifier followed by colon .

Flow Diagram Example .

For example , consider the following code .

simplebreak statement would not work here , because it would only cause the program to exit from the innermost loop .

The Infinite Loop loop becomes infinite loop if condition never becomes false .
The for loop is traditionally used for this purpose .
Since none of the three expressions that form the ' loop are required , you can make an endless loop by leaving the conditional expression empty .

You may have an initialization and increment expression , but programmers more commonly use the ' construct to signify an infinite loop .

NOTE : You can terminate an infinite loop by pressing Ctrl + keys .

Decision making structures require that the programmer specify one or more conditions to be evaluated or tested by the program , along with statement or statements to be executed if the condition is determined to be true , and optionally , other statements to be executed if the condition is determined to be false .

Following is the general from of typical decision making structure found in most of the programming languages : programming language provides following types of decision making statements .

Statement Description if statement An ' statement consists of boolean expression followed by one or more statements .

STATEMENTS for equality against list of values .

If Statement An if statement consists of boolean expression followed by one or more statements .

Syntax The syntax of an if statement in is : will execute if the boolean expression is true If the boolean expression evaluates to true , then the block of code inside the if statement will be executed .
If boolean expression evaluates to false , then the first set of code after the end of the if statement the closing curly will be executed .

Flow Diagram Example .

Syntax The syntax of an statement in is :

Flow Diagram Example .

When using if  else if  else statements there are few points to keep in mind .

An if can have zero to many else and they must come before the else .

Syntax The syntax of an statement in is :

Each value is called case , and the variable being switched on is checked for each case .

Syntax The syntax for switch statement in is as follows : case .

Each case is followed by the value to be compared to and colon .

If no break appears , the flow of control will fall through to subsequent cases until break is reached .

The default case can be used for performing task when none of the cases is true .
No break is needed in the default case .

Flow Diagram Example .

Syntax The syntax for nested if statement is as follows :

Example .

Even if the case constants of the inner and outer switch contain common values , no conflicts will arise .

specifies that at least levels of nesting be allowed for switch statements .

Syntax The syntax for nested switch statement is as follows : case : cout is part of outer ; case : cout is part of inner ; break ; case :

It has the following general form :

Notice the use and placement of the colon .

The value of ' expression is determined like this : is evaluated .
If it is true , then is evaluated and becomes the value of the entire ' expression .

If is false , then is evaluated and its value becomes the value of the expression .

function is group of statements that together perform task .
Every program has at least one function , which is , and all the most trivial programs can define additional functions .

You can divide up your code into separate functions .
How you divide up your code among different functions is up to you , but logically the division usually is such that each function performs specific task .

function declaration tells the compiler about name , return type , and parameters .
function definition provides the actual body of the function .

The standard library provides numerous functions that your program can call .
For example , function to concatenate two strings , function to copy one memory location to another location , and many more functions .

function is known with various names like method or or procedure etc .

Defining Function The general form of function definition is as follows : return_type parameter list body of the function function definition consists of function header and function body .

Here are all the parts of function : Return Type : function may return value .

Some functions perform the desired operations without returning value .
In this case , the return_type is the keyword void .

The function name and the parameter list together constitute the function signature .

When function is invoked , you pass value to the parameter .
This value is referred to as actual parameter or argument .
The parameter list refers to the type , order , and number of the parameters of function .
Parameters are optional ; that is , function may contain no parameters .

FUNCTIONS Function Body : The function body contains collection of statements that define what the function does .

Example : Following is the source code for function called .
This function takes two parameters and and returns the maximum between the two : function returning the max between two numbers int , int local variable declaration int  if ; else ; return  Function Declarations function declaration tells the compiler about function name and how to call the function .
The actual body of the function can be defined separately .

function declaration has the following parts : return_type parameter list ; For the above defined function , following is the function declaration : int , int ; Parameter names are not important in function declaration only their type is required , so following is also valid declaration : int , Function declaration is required when you define function in one source file and you call that function in another file .
In such case , you should declare the function at the top of the file calling the function .

Calling Function While creating function , you give definition of what the function has to do .
To use function , you will have to call or invoke that function .

When program calls function , program control is transferred to the called function .
called function performs defined task and when return statement is executed or when its closing brace is reached , it returns program control back to the main program .

To call function , you simply need to pass the required parameters along with function name , and if function returns value , then you can store returned value .
For example :

While running final executable , it would produce the following  Max value is  Function Arguments If function is to use arguments , it must declare variables that accept the values of the arguments .
These variables are called the formal parameters of the function .

The formal parameters behave like other local variables inside the function and are created upon entry into the function and destroyed upon exit .

While calling function , there are two ways that arguments can be passed to function : Call Type Description Call by value This method copies the actual value of an argument into the formal parameter of the function .
In this case , changes made to the parameter inside the function have no effect on the argument .

Call by pointer This method copies the address of an argument into the formal parameter .
Inside the function , the address is used to access the actual argument used in the call .

This means that changes made to the parameter affect the argument .

Call by reference This method copies the reference of an argument into the formal parameter .
Inside the function , the reference is used to access the actual argument used in the call .
This means that changes made to the parameter affect the argument .

Call by Value The call by value method of passing arguments to function copies the actual value of an argument into the formal parameter of the function .
In this case , changes made to the parameter inside the function have no effect on the argument .

By default , uses call by value to pass arguments .
In general , this means that code within function cannot alter the arguments used to call the function .

Consider the function definition as follows .

Call by Pointer The call by pointer method of passing arguments to function copies the address of an argument into the formal parameter .
Inside the function , the address is used to access the actual argument used in the call .
This means that changes made to the parameter affect the passed argument .

To pass the value by pointer , argument pointers are passed to the functions just like any other value .
So accordingly you need to declare the function parameters as pointer types as in the following function , which exchanges the values of the two integer variables pointed to by its arguments .

For now , let us call the function by passing values by pointer as in the following example :

Inside the function , the reference is used to access the actual argument used in the call .
This means that changes made to the parameter affect the passed argument .

To pass the value by reference , argument reference is passed to the functions just like any other value .
So accordingly you need to declare the function parameters as reference types as in the following function , which exchanges the values of the two integer variables pointed to by its arguments .

In general , this means that code within function cannot alter the arguments used to call the function and above mentioned example while calling function used the same method .

Default Values for Parameters When you define function , you can specify default value for each of the last parameters .
This value will be used if the corresponding argument is left blank when calling to the function .

This is done by using the assignment operator and assigning values for the arguments in the function definition .
If value for that parameter is not passed when the function is called , the default given value is used , but if value is specified , this default value is ignored and the passed value is used instead .

Consider the following example :

The number data types , their possible values and number ranges have been explained while discussing Data Types .

Defining Numbers in You have already defined numbers in various examples given in previous chapters .
Here is another consolidated example to define various types of numbers in :

NUMBERS cout " endl ; return ; When the above code is compiled and executed , it produces the following  short int long float double Math Operations in In addition to the various functions you can create , also includes some useful functions you can use .
These functions are available in standard and libraries and called functions .
These are functions that can be included in your program and then use .

has rich set of mathematical operations , which can be performed on various numbers .
Following table lists down some useful mathematical functions available in .

To utilize these functions you need to the math header file .

Function Purpose double ; This function takes an angle and returns the cosine .

double , The first is number you wish to raise and the second is the power you wish to raise it double , If you pass this function the length of two sides of right triangle , it will return you the length of the hypotenuse .

Following is simple example to show few of the mathematical operations :

Random Numbers in There are many cases where you will wish to generate random number .
There are actually two functions you will need to know about random number generation .
The first is , this function will only return pseudo random number .
The way to fix this is to first call the function .

Following is simple example to generate few random numbers .
This example makes use of function to get the number of seconds on your system .

An array is used to store collection of data , but it is often more useful to think of an array as collection of variables of the same type .

Instead of declaring individual variables , such as , and , you declare one array variable such as numbers and use , and , to represent individual variables .

specific element in an array is accessed by an index .

All arrays consist of contiguous memory locations .
The lowest address corresponds to the first element and the highest address to the last element .

Declaring Arrays To declare an array in , the programmer specifies the type of the elements and the number of elements required by an array as follows : type arrayName arraySize ; This is called array .
The arraySize must be an integer constant greater than zero and type can be any valid data type .
For example , to declare array called of type double , use this statement : double ; Initializing Arrays You can initialize array elements either one by one or using single statement as follows : double , The number of values between braces cannot be larger than the number of elements that we declare for the array between square brackets .
Following is an example to assign single element of the array : If you omit the size of the array , an array just big enough to hold the initialization is created .
Therefore , if you write : double , You will create exactly the same array as you did in the previous example .

ARRAYS ; The above statement assigns element number in the array value of .

Array with index will be , last element because all arrays have as the index of their first element which is also called base index .
Following is the pictorial representation of the same array we discussed above : Accessing Array Elements An element is accessed by indexing the array name .
This is done by placing the index of the element within square brackets after the name of the array .
For example : double ; The above statement will take element from the array and assign the value to variable .
Following is an example , which will use all the abovementioned three concepts viz .

When the above code is compiled and executed , it produces the following result : Arrays in Arrays are important to and should need lots of more detail .
There are following few important concepts , which should be clear to programmer : Concept Description arrays supports multidimensional arrays .
The simplest form of the multidimensional array is the array .

Pointer to an array You can generate pointer to the first element of an array by simply specifying the array name , without any index .

Passing arrays to functions You can pass to the function pointer to an array by specifying the name without an index .

Return array from functions allows function to return an array .

Arrays allows multidimensional arrays .
Here is the general form of multidimensional array declaration : type ; For example , the following declaration creates three dimensional .
array is , in essence , list of arrays .
To declare integer array of size , you would write something as follows : type arrayName ; Where type can be any valid data type and arrayName will be valid identifier .

array can be think as table , which will have number of rows and number of columns .
array , which contains three rows and four columns can be shown as below : Thus , every element in array is identified by an element name of the form , where is the name of the array , and and are the subscripts that uniquely identify each element in .

Initializing Arrays Multidimensioned arrays may be initialized by specifying bracketed values for each row .
Following is an array with rows and each row have columns .

The following initialization is equivalent to previous example : int ; Accessing Array Elements An element in array is accessed by using the subscripts , row index and column index of the array .
For example : int ; The above statement will take element from the row of the array .
You can verify it in the above digram .

Pointer to an Array It is most likely that you would not understand this chapter until you go through the chapter related Pointers .

So assuming you have bit understanding on pointers in , let us start : An array name is constant pointer to the first element of the array .
Therefore , in the declaration : double ; balance is pointer to , which is the address of the first element of the array balance .
Thus , the following program fragment assigns the address of the first element ofbalance : double ; double ; balance ; It is legal to use array names as constant pointers , and vice versa .
Therefore , + is legitimate way of accessing the data at .

Once you store the address of first element in  you can access array elements using , and so on .
Below is the example to show all the concepts discussed above :

In the above example , is pointer to double which means it can store address of variable of double type .
Once we have address in  then will give us value available at the address stored in  as we have shown in the above example .

Passing Arrays to Functions does not allow to pass an entire array as an argument to function .

However , You can pass pointer to an array by specifying the name without an index .

If you want to pass array as an argument in function , you would have to declare function formal parameter in one of following three ways and all three declaration methods produce similar results because each tells the compiler that an integer pointer is going to be received .

Formal parameters as pointer as follows : void .

Return Array from Functions does not allow to return an entire array as an argument to function .

However , you can return pointer to an array by specifying the name without an index .

If you want to return array from function , you would have to declare function returning pointer as in the following example : int .

Now , consider the following function , which will generate random numbers and return them using an array and call this function as follows :

provides following two types of string representations : The character string .

The Character String The character string originated within the language and continues to be supported within .
This string is actually array of characters which is terminated by null character .
Thus string contains the characters that comprise the string followed by null .

The following declaration and initialization create string consisting of the word .
To hold the null character at the end of the array , the size of the character array containing the string is one more than the number of characters in the word " char , If you follow the rule of array initialization , then you can write the above statement as follows : char ; Following is the memory presentation of above defined string in : Actually , you do not place the null character at the end of string constant .
The compiler automatically places the ' at the end of the string when it initializes the array .
Let us try to print string : using namespace std ;
STRINGS int main char , message : endl ; return ; When the above code is compiled and executed , it produces the following result : Greeting message : Hello supports wide range of functions that manipulate strings :
Function Purpose , Copies string into string .

Following example makes use of few of the functions :

Let us check the following example :

Some tasks are performed more easily with pointers , and other tasks , such as dynamic memory allocation , cannot be performed without them .

As you know every variable is memory location and every memory location has its address defined which can be accessed using ampersand operator which denotes an address memory .
Consider the following which will print the address of the variables defined :

pointer is variable whose value is the address of another variable .
Like any variable or constant , you must declare pointer before you can work with it .
The general form of pointer variable declaration is :
POINTERS type ; Here , type is the base type ; it must be valid type and varname is the name of the pointer variable .
The asterisk you used to declare pointer is the same asterisk that you use for multiplication .
However , this statement the asterisk is being used to designate variable as pointer .

Following are the valid pointer .

The actual data type of the value of all pointers , whether integer , float , character , or otherwise , is the same , long hexadecimal number that represents memory address .
The only difference between pointers of different data types is the data type of the variable or constant that the pointer points to .

Using Pointers There are few important operations , which we will do with the pointers very frequently .
This is done by using unary operator that returns the value of the variable located at the address specified by its operand .
Following example makes use of these operations :

There are following few important pointer concepts which should be clear to programmer : Concept Description Null Pointers supports null pointer , which is constant with value of zero defined in several standard libraries .

pointer arithmetic There are four arithmetic operators that can be used on pointers : + pointers vs arrays There is close relationship between pointers and arrays .

array of pointers You can define arrays to hold number of pointers .

pointer to pointer allows you to have pointer on pointer and so on .

Passing pointers to functions Passing an argument by reference or by address both enable the passed argument to be changed in the calling function by the called function .

Return pointer from functions allows function to return pointer to local variable , static variable and dynamically allocated memory as well .

Null Pointers It is always good practice to assign the pointer NULL to pointer variable in case you do not have exact address to be assigned .
This is done at the time of variable declaration .
pointer that is assigned NULL is called null pointer .

The NULL pointer is constant with value of zero defined in several standard libraries , including iostream .
Consider the following program :

However , the memory address has special significance ; it signals that the pointer is not intended to point to an accessible memory location .
But by convention , if pointer contains the null value , it is assumed to point to nothing .

To check for null pointer you can use an if statement as follows : succeeds if is not null succeeds if is null Thus , if all unused pointers are given the null value and you avoid the use of null pointer , you can avoid the accidental misuse of an uninitialized pointer .

Many times , uninitialized variables hold some junk values and it becomes difficult to debug the program .

Pointer Arithmetic As you understood pointer is an address which is numeric value ; therefore , you can perform arithmetic operations on pointer just as you can numeric value .
There are four arithmetic operators that can be used on pointers : + and To understand pointer arithmetic , let us consider that is an integer pointer which points to the address .
Assuming integers , let us perform the following arithmatic operation on the pointer : the will point to the location because each time is incremented , it will point to the next integer .
This operation will move the pointer to next memory location without impacting actual value at the memory location .
If points to character whose address is , then above operation will point to the location because next character will be available at .

Incrementing Pointer We prefer using pointer in our program instead of an array because the variable pointer can be incremented , unlike the array name which cannot be incremented because it is constant pointer .
The following program increments the variable pointer to access each succeeding element of the array : using namespace .

If and point to variables that are related to each other , such elements of the same array , then and can be meaningfully compared .

The following program modifies the previous example one by incrementing the variable pointer so long the address to which it points is either less than or equal to the address of the last element of the array , which is : using namespace .

In fact , pointers and arrays are interchangeable in many cases .
For example , pointer that points to the beginning of an array can access that array by using either pointer arithmetic or indexing .
Consider the following program : using namespace .

For example , consider the following program : using namespace .

The reason for this is that is constant that points to the beginning of an array and can not be used .

Because an array name generates pointer constant , it can still be used in expressions , long it is not modified .
For example , the following is valid statement that assigns the value : + Above statement is valid and will compile successfully because is not changed .

Array of Pointers Before we understand the concept of array of pointers , let us consider the following example , which makes use of an array of integers : using namespace .

Following is the declaration of an array of pointers to an integer : int ; This declares as an array of integer pointers .
Thus , each element in  now holds pointer to an int value .
Following example makes use of three integers which will be stored in an array of pointers as follows : using namespace std ; const int .

Normally , pointer contains the address of variable .
When we define pointer to pointer , the first pointer contains the address of the second pointer , which points to the location that contains the actual value as shown below .

variable that is pointer to pointer must be declared as such .
This is done by placing an additional asterisk in front of its name .
For example , following is the declaration to declare pointer to pointer of type int : int ; When target value is indirectly pointed to by pointer to pointer , accessing that value requires that the asterisk operator be applied twice , as is shown below in the example :

To do so , simply declare the function parameter as pointer type .

Following simple example where we pass an unsigned long pointer to function and change the value inside the function which reflects back in the calling function :

To do so , you would have to declare function returning pointer as in the following example : int .

Now , consider the following function , which will generate random numbers and return them using an array name which represents pointer , address of first array element .

reference variable is an alias , that is , another name for an already existing variable .
Once reference is initialized with variable , either the variable name or the reference name may be used to refer to the variable .

References vs Pointers References are often confused with pointers but three major differences between references and pointers are : You cannot have NULL references .
You must always be able to assume that reference is connected to legitimate piece of storage .

Pointers can be pointed to another object at any time .

Pointers can be initialized at any time .

Creating References in Think of variable name as label attached to the location in memory .
You can then think of reference as second label attached to that memory location .
Therefore , you can access the contents of the variable through either the original variable name or the reference .
For example , suppose we have the following example : int ; We can declare reference variables for as follows .

Thus , read the first declaration as  is an integer reference initialized to  and read the second declaration as is double reference initialized to " Following example makes use of references on int and double :

REFERENCES declare simple variables int  double  declare reference variables   of   endl ; of reference   endl ; of   endl ; of reference   endl ; return ; When the above code is compiled together and executed , it produces the following result : Value of  Value of reference  Value of  Value of reference  References are usually used for function argument lists and function return values .
So following are two important subjects related to references which should be clear to programmer : Concept Description References as parameters supports passing references as function parameter more safely than parameters .

Reference as return value You can return reference from function like any other data type .

References as Parameters We have discussed how we implement call by reference concept using pointers .
Here is another example of call by reference which makes use of reference :

function can return reference in similar way as it returns pointer .

When function returns reference , it returns an implicit pointer to its return value .
This way , function can be used on the left side of an assignment statement .
For example , consider this simple program :

So it is not legal to return reference to local var .
But you can always return reference on static variable .

inherits the structs and functions for date and time manipulation from .
To access date and time related functions and structures , you would need to header file in your program .

There are four types : and tm .
The types , and are capable of representing the system time and date as some sort of integer .

The structure type tm holds the date and time in the form of structure having the following .

All these functions are part of standard and library and you can check their detail using reference to standard library given below .

SN Function Purpose ; This returns the current calendar time of the system in number of seconds elapsed since January ,
If the system has no time , is returned .

DATE AND TIME .

value of is returned if the time is not available .

The time is represented in Coordinated Universal Time , which is essentially Greenwich Mean Time .

Current Date and Time Suppose you want to retrieve the current system date and time , either as local time or as Coordinated Universal Time .
Following is the example to achieve the same : using namespace .

This structure holds the date and time in the form of structure as mentioned above .
Most of the time related functions makes use of tm structure .

Following is an example which makes use of various date and time related functions and tm structure : While using structure in this chapter , making an assumption that you have basic understanding on structure and how to access structure members using arrow arrow_operator operator .

This chapter will discuss very basic and most common operations required for programming .

occurs in streams , which are sequences of bytes .
If bytes flow from device like keyboard , disk drive , or network connection etc .

Library Header Files There are following header files important to programs : Header File Function and Description This file defines the cin , cout , cerr and clog objects , which correspond to the standard input stream , the standard output stream , the standard error stream and the buffered standard error stream , respectively .

We will discuss about it in detail in File and Stream related chapter .

The Standard Output Stream The predefined object cout is an instance of ostream class .
The cout object is said to be to " the standard output device , which usually is the display screen .
The cout is used in conjunction with the stream insertion operator , which is written as which are two less than signs as shown in the following example .

BASIC using namespace std ; int char ; cout of is   endl ; When the above code is compiled and executed , it produces the following result : Value of is  Hello The compiler also determines the data type of variable to be output and selects the appropriate stream insertion operator to display the value .
The operator is overloaded to output data items of types integer , float , double , strings and pointer values .

The insertion operator may be used more than once in single statement as shown above and endl is used to add at the end of the .

The Standard Input Stream The predefined object cin is an instance of istream class .
The cin object is said to be attached to the standard input device , which usually is the keyboard .

The cin is used in conjunction with the stream extraction operator , which is written as which are two greater than signs as shown in the following example .

You enter value and then hit enter to see the following result : Please enter your name : cplusplus Your name is : cplusplus The compiler also determines the data type of the entered value and selects the appropriate stream extraction operator to extract the value and store it in the given variables .

The stream extraction operator may be used more than once in single statement .
To request more than one datum you can use the following : cin name age ; This will be equivalent to the following two statements : cin name ; cin age ; The Standard Error Stream The predefined object cerr is an instance of ostream class .
The cerr object is said to be attached to the standard error device , which is also display screen but the object cerr is and each stream insertion to cerr causes its output to appear immediately .

The cerr is also used in conjunction with the stream insertion operator as shown in the following example .

The Standard Log Stream The predefined object clog is an instance of ostream class .
The clog object is said to be attached to the standard error device , which is also display screen but the object clog is buffered .
This means that each insertion to clog could cause its output to be held in buffer until the buffer is filled or until the buffer is flushed .

The clog is also used in conjunction with the stream insertion operator as shown in the following example .

You would not be able to see any difference in cout , cerr and clog with these small examples , but while writing and executing big programs the difference becomes obvious .
So it is good practice to display error messages using cerr stream and while displaying other log messages then clog should be used .

arrays allow you to define variables that combine several data items of the same kind , but structure is another user defined data type which allows you to combine data items of different kinds .

Structures are used to represent record , suppose you want to keep track of your books in library .
You might want to track the following attributes about each book : Title Author Subject Book ID Defining Structure To define structure , you must use the struct statement .
The struct statement defines new type , with more than one member , for your program .
The format of the struct statement is this : struct member definition ; member definition ;

At the end of the definition , before the final semicolon , you can specify one or more structure variables but it is optional .
Here is the way you would declare the Book structure : struct Books char ; char ; char ;
DATA STRUCTURES int ; Accessing Structure Members To access any member of structure , we use the member access operator .
The member access operator is coded as period between the structure variable name and the structure member that we wish to access .
You would use struct keyword to define variables of structure type .
Following is the example to explain usage of structure :

You would access structure variables in the similar way as you have accessed in the above example : using namespace std ; void struct Books book ; struct Books char ; char ; char ; int 

To find the address of structure variable , place the ' operator before the name as follows : To access the members of structure using pointer to that structure , you must use the arrow_operator operator as follows : Let us above example using structure pointer , hope this will be easy for you to understand the concept :

For example : typedef struct char ; char ; char ; int  Now , you can use Books directly to define variables of Books type without using struct keyword .
Following is the example : Books , You can use typedef keyword for as well as follows : typedef long int ; and are all pointers to long ints .

The main purpose of programming is to add object orientation to the programming language and classes are the central feature of that supports programming and are often called types .

class is used to specify the form of an object and it combines data representation and methods for manipulating that data into one neat package .

The data and functions within class are called members of the class .

Class When you define class , you define blueprint for data type .
This actually define any data , but it does define what the class name means , that is , what an object of the class will consist of and what operations can be performed on such an object .

class definition starts with the keyword class followed by the class name ; and the class body , enclosed by pair of curly braces .
class definition must be followed either by semicolon or list of declarations .
For example , we define the Box data type using the keyword class as follows : class Box .

The keyword public determines the access attributes of the members of the class that follows it .
public member can be accessed from outside the class anywhere within the scope of the class object .
You can also specify the members of class as private or protected which we will discuss in .

Define Objects class provides the blueprints for objects , so basically an object is created from class .
We declare objects of class with exactly the same sort of declaration that we declare variables of basic types .
Following statements declare two objects of class Box : Box ; Declare of type Box Box ; Declare of type Box .
CLASSES AND OBJECTS Both of the objects and will have their own copy of data members .

Accessing the Data Members The public data members of objects of class can be accessed using the direct member access operator .
Let us try the following example to make the things clear : using namespace std ; class Box .

We will learn how private and protected members can be accessed .

Classes Objects in Detail So far , you have got very basic idea about Classes and Objects .
There are further interesting concepts related to Classes and Objects which we will discuss in various listed below : Concept Description Class functions function of class is function that has its definition or its prototype within the class definition like any other variable .

Class modifiers class can be defined as public , private or protected .
By default members would be assumed as private .

Constructor destructor class constructor is special function in class that is called when new of the class is created .
destructor is also special function which is called when created is deleted .

copy constructor The copy constructor is constructor which creates an by initializing it with an of the same class , which has been created previously .

friend functions friend function is permitted full to private and protected members of class .

inline functions With an inline function , the compiler tries to expand the code in the body of the function in place of call to the function .

The this pointer in Every has special pointer this which points to the itself .

Pointer to classes pointer to class is done exactly the same way pointer to structure is .
In fact class is really just structure with functions in it .

Static members of class Both data members and function members of class can be declared as static .

Class functions function of class is function that has its definition or its prototype within the class definition like any other variable .
It operates on any of the class of which it is  and has to all the members of class for that .

Let us take previously defined class to the members of the class using function instead of directly accessing them : class .

Member functions can be defined within the class definition or separately using scope resolution operator ,
Defining function within the class definition declares the function inline , even if you do not use the inline specifier .
So either you can function as below : class .

function will be called using dot operator on where it will manipulate data related to that only as follows : myBox ; Create an ; Call function for the Let us put above concepts to set and get the value of different class members in class : using namespace std ; class Box .

The access restriction to the class members is specified by the labeled public , private , and protected sections within the class body .
The keywords public , private , and protected are called access specifiers .

class can have multiple public , protected , or private labeled sections .
Each section remains in effect until either another section label or the closing right brace of the class body is seen .
The default access for members and classes is private .

You can set and get the value of public variables without any function as shown in the following example : using namespace std ; class Line public : double  void double len .

Only the class and friend functions can access private members .

By default all the members of class would be private , for example in the following classwidth is private member , which means until you label member , it will be assumed private member : class Box double width ;

You will learn derived classes and inheritance in next chapter .
For now you can check following example where have derived one child class SmallBox from parent class Box .

Following example is similar to above example and here member will be accessible by any member function of its derived class SmallBox .

constructor will have exact same name as the class and it does not have any return type at all , not even void .
Constructors can be very useful for setting initial values for certain member variables .

Following example explains the concept of constructor : using namespace std ; class Line .

; This is the constructor .

This helps you to assign initial value to an object at the time of its creation as shown in the following example : using namespace std ; class Line .

; This is the constructor .

double .

destructor will have exact same name as the class prefixed with tilde and it can neither return value nor can it take any parameters .

Following example explains the concept of destructor : using namespace std ; class Line .

; This is the constructor declaration ; This is the destructor : declaration private : double  Member functions definitions including constructor .

The copy constructor is used to : Initialize one object from another of the same type .

If copy constructor is not defined in class , the compiler itself defines the class has pointer variables and has some dynamic memory allocations , then it is must to have copy constructor .
The most common form of copy constructor is shown here : classname classname body of constructor .

Line .

Length of  Freeing memory .

Let us see the same example but with small change to create another object using existing object of the same type : using namespace std ; class Line .

Copy constructor allocating .

Length of  Freeing memory .

Copy constructor allocating .

Length of  Freeing memory .

Friend Functions friend function of class is defined outside that class ' scope but it has the right to access all private and protected members of the class .
Even though the prototypes for friend functions appear in the class definition , friends are not member functions .

friend can be function , function template , or member function , or class or class template , in which case the entire class and all of its members are friends .

To declare function as friend of class , precede the function prototype in the class definition with keyword friend as follows : class Box double width ;

If function is inline , the compiler places copy of the code of that function at each point where the function is called at compile time .

Any change to an inline function could require all clients of the function to be recompiled because compiler would need to replace all the code once again otherwise it will continue with old functionality .

To inline function , place the keyword inline before the function name and define the function before any calls are made to the function .
The compiler can ignore the inline qualifier in case defined function is more than .

function definition in class definition is an inline function definition , even without the use of the inline specifier .

Following is an example , which makes use of inline function to return max of two numbers :

The this pointer is an implicit parameter to all member functions .
Therefore , inside member function , this may be used to refer to the invoking object .

Friend functions do not have this pointer , because friends are not members of class .
Only member functions have this pointer .

Let us try the following example to understand the concept of this pointer : using namespace std ; class Box .

Constructor called .

is equal to or larger than Pointer to Classes pointer to class is done exactly the same way as pointer to structure and to access members of pointer to class you use the member access operator arrow_operator operator , just as you do with pointers to structures .
Also as with all pointers , you must initialize the pointer before using it .

Let us try the following example to understand the concept of pointer to class : using namespace std ; class Box .

Volume of : Volume of : Static Members of Class We can define class members static using static keyword .
When we declare member of class as static it means no matter how many objects of the class are created , there is only one copy of the static member .

static member is shared by all objects of the class .
All static data is initialized to zero when the first object is created , if no other initialization is present .
We put it in the class definition but it can be initialized outside the class as done in the following example by redeclaring the static variable , using the scope resolution operator : to identify which class it belongs to .

Let us try the following example to understand the concept of static data members : using namespace std ; class .

Total objects : Static Function Members By declaring function member as static , you make it independent of any particular object of the class .
static member function can be called even if no objects of the class exist and the static functions are accessed using only the class name and the scope resolution operator .

static member function can only access static data member , other static member functions and any other functions from outside the class .

Static member functions have class scope and they do not have access to the this pointer of the class .
You could use static member function to determine whether some objects of the class have been created or not .

Let us try the following example to understand the concept of static function members : using namespace std ; class public : static int  Constructor definition , double , double " endl ;    Increase every time object is created ;

Final Stage  One of the most important concepts in programming is that of inheritance .
Inheritance allows us to define in terms of another  which makes it easier to create and maintain an application .
This also provides an opportunity to reuse the code functionality and fast implementation time .

When creating  instead of writing completely new members and member functions , the programmer can designate that the new should inherit the members of an existing .
This existing is called the base  and the new is referred to as the derived .

The idea of inheritance implements the is relationship .
For example , mammal animal , dog mammal hence dog animal as well and so on .

Base Derived Classes can be derived from more than one classes , which means it can inherit and functions from multiple base classes .
To define derived  we use derivation list to specify the base .
derivation list names one or more base classes and has the form : Where is one of public , protected , or private , and is the name of previously defined .
If the is not used , then it is private by default .

Consider base Shape and its derived Rectangle as follows : using namespace .

INHERITANCE void  protected : int  int  Derived .

; Print the of the object .

Thus members that should not be accessible to the member functions of derived classes should be declared private in the base .

We can summarize the different access types according to who can access them , in the following way : Access public protected private Same yes yes yes Derived classes yes yes no Outside classes yes no no derived inherits all base methods with the following exceptions : Constructors , destructors and copy constructors of the base .

Type of Inheritance When deriving from base  the base may be inherited through public , protected or private inheritance .
The type of inheritance is specified by the as explained above .

We hardly use protected or private inheritance , but public inheritance is commonly used .
While using different type of inheritance , following rules are applied : Public Inheritance : When deriving class from public base class , public members of the base class become public members of the derived class and protected members of the base class become protected members of the derived class .

base private members are never accessible directly from derived class , but can be accessed through calls to the public and protected members of the base class .

Private Inheritance : When deriving from private base class , public and protected members of the base class become private members of the derived class .

Multiple Inheritance class can inherit members from more than one class and here is the extended syntax : class : access baseA , access .

Where access is one of public , protected , or private and would be given for every base class and they will be separated by comma as shown above .
Let us try the following example : using namespace .

An overloaded declaration is declaration that is declared with the same name as previously declared declaration in the same scope , except that both declarations have different arguments and obviously different definition .

When you call an overloaded function or operator , the compiler determines the most appropriate definition to use , by comparing the argument types you have used to call the function or operator with the parameter types specified in the definitions .
The process of selecting the most appropriate overloaded function or operator is called overload resolution .

Function Overloading in You can have multiple definitions for the same function name in the same scope .

The definition of the function must differ from each other by the types the number of arguments in the argument list .
You cannot overload function declarations that differ only by return type .

Following is the example where same function is being used to print different data types : using namespace .

OVERLOADING void character :  c .

Thus , programmer can use operators with types as well .

Overloaded operators are functions with special names the keyword operator followed by the symbol for the operator being defined .
Like any other function , an overloaded operator has return type and parameter list .

Box ; Declares the addition operator that can be used to add two Box objects and returns final Box object .
Most overloaded operators may be defined as ordinary functions or as class member functions .
In case we define above function as function of class then we would have to pass two arguments for each operand as follows : Box , const ; Following is the example to show the concept of operator over loading using member function .
Here an object is passed as an argument whose properties will be accessed using this object , the object which will call this operator can be accessed using this operator as explained below : using namespace std ; class Box .

Box Box box ; box .

Operators and Example Unary operators overloading Binary operators overloading Relational operators overloading operators overloading and operators overloading Assignment operators overloading Function call operator overloading Subscripting operator overloading Class access operator arrow_operator overloading Unary Operators Overloading The unary operators operate on single operand and following are the examples of Unary operators : The increment and decrement operators .

The unary operators operate on the object for which they were called and normally , this operator appears on the left side of the object , as in , and but sometime they can be used as postfix as well like or .

Following example explain how minus operator can be overloaded for prefix as well as postfix usage .

using namespace .

; apply negation .

Increment and Decrement Operators The increment and decrement operators are two important unary operators available in .

Following example explain how increment operator can be overloaded for prefix as well as postfix usage .
Similar way , you can overload operator .

You use binary operators very frequently like addition operator , subtraction operator and division operator .

Following example explains how addition operator can be overloaded .

Similar way , you can overload subtraction and division operators .

Box Box box ; box .

You can overload any of these operators , which can be used to compare the objects of class .

Following example explains how operator can be overloaded and similar way you can overload other relational operators .

The stream insertion and stream extraction operators also can be to perform input and output for types like an object .

Here , it is important to make overloading function friend of the class because it would be called without creating an object .

Following example explains how extraction and insertion .

Following example explain how increment can be for prefix as well as postfix usage .
Similar way , you can overload .

Following example explains how an assignment can be overloaded .

When you overload , you are not creating new to call function .
Rather , you are creating an function that can be passed an arbitrary number of parameters .

Following example explains how function call can be overloaded .

cout :   endl ;

This can be overloaded to enhance the existing functionality of arrays .

Following example explains how subscript can be overloaded .

It is defined to give class type " behavior .

If used , its return type must be pointer or an object of class to which you can apply .

The is used often in conjunction with the to implement " These pointers are objects that behave like normal pointers except they perform other tasks when you access an object through them , such as automatic object deletion either when the pointer is destroyed , or the pointer is used to point to another object .

The dereferencing can be defined as unary postfix operator .
That is , given .

Typically , polymorphism occurs when there is hierarchy of classes and they are related by inheritance .

polymorphism means that call to member function will cause different function to be executed depending on the type of object that invokes the function .

Consider the following example where base class has been derived by other two classes : using namespace std ; class Shape protected : int   public : int , int .

POLYMORPHISM return ;

This is called static resolution of the function call , or static linkage the function call is fixed before the program is executed .
This is also sometimes called early binding because the function is set during the compilation of the program .

But now , make slight modification in our program and precede the declaration of in the Shape class with the keyword virtual so that it looks like this : class Shape protected : int   public : int , int .

Hence , since addresses of objects of tri and rec classes are stored in the respective function is called .

As you can see , each of the child classes has separate implementation for the function .
This is how polymorphism is generally used .
You have different classes with function of the same name , and even the same parameters , but with different implementations .

Virtual Function virtual function is function in base class that is declared using the keyword virtual .
Defining in base class virtual function , with another version in derived class , signals to the compiler that we want static linkage for this function .

What we do want is the selection of the function to be called at any given point in the program to be based on the kind of object for which it is called .
This sort of operation is referred to as dynamic linkage , or late binding .

Pure Virtual Functions It is possible that you want to virtual function in base class so that it may be redefined in derived class to suit the objects of that class , but that there is no meaningful definition you could give for the function in the base class .

We can change the virtual function in the base class to the following : class Shape protected : int   public : int , int .

Data abstraction refers to providing only essential information to the outside world and hiding their background details , to represent the needed information in program without presenting the details .

Data abstraction is programming technique that relies on the separation of interface and implementation .

take one real life example of TV , which you can turn on and off , change the channel , adjust the volume , and add external components such as speakers , VCRs , and DVD players , BUT you do not know its internal details , that is , you do not know how it receives signals over the air or through cable , how it translates them , and finally displays them on the screen .

Thus , we can say television clearly separates its internal implementation from its external interface and you can play with its interfaces like the power button , channel changer , and volume control without having zero knowledge of its internals .

In , classes provides great level of data abstraction .
They provide sufficient public methods to the outside world to play with the functionality of the object and to manipulate object data , state without actually knowing how class has been implemented internally .

For example , your program can make call to the function without knowing what algorithm the function actually uses to sort the given values .
In fact , the underlying implementation of the sorting functionality could change between releases of the library , and as long as the interface stays the same , your function call will still work .

In , we use classes to define our own abstract data types .
You can use the cout object of class ostream to stream data to standard output like this :

DATA ABSTRACTION Here , you need to understand how cout displays the text on the screen .
You need to only know the public interface and the underlying implementation of ' is free to change .

Access Labels Enforce Abstraction In , we use access labels to define the abstract interface to the class .
class may contain zero or more access labels : Members defined with public label are accessible to all parts of the program .

There are no restrictions on how often an access label may appear .
Each access label specifies the access level of the succeeding member definitions specified access level remains in effect until the next access label is encountered or the closing right brace of the class body is seen .

Benefits of Data Abstraction Data abstraction provides two important advantages : Class are protected from inadvertent errors , which might corrupt the state of the object .

By defining data members only in the private section of the class , the class author is free to make changes in the data .
If the implementation changes , only the class code needs to be examined to see what affect the change may have .
If data is public , then any function that directly access the data members of the old representation might be broken .

Data Abstraction Example Any program where you implement class with public and private members is an example of data abstraction .
Consider the following example : using namespace .

Designing Strategy Abstraction separates code into interface and implementation .
So while designing your component , you must keep interface independent of the implementation so that if you change underlying implementation then interface would remain intact .

In this case whatever programs are using these interfaces , they would not be impacted and would just need recompilation with the latest implementation .

All programs are composed of the following two fundamental elements : Program statements : This is the part of program that performs actions and they are called functions .

Encapsulation is an Object Oriented Programming concept that binds together the data and functions that manipulate the data , and that keeps both safe from outside interference and misuse .
Data encapsulation led to the important OOP concept of data hiding .

Data encapsulation is mechanism of bundling the data , and the functions that use them and data abstraction is mechanism of exposing only the interfaces and hiding the implementation details from the user .

supports the properties of encapsulation and data hiding through the creation of types , called classes .
We already have studied that class can contain private , protected and public members .
By default , all items defined in class are private .
For example : class Box .

The variables length , breadth , and height are private .
This means that they can be accessed only by other members of the Box class , and not by any other part of your program .
This is one way encapsulation is achieved .

To make parts of class public , accessible to other parts of your , you must declare them after the public keyword .
All variables or functions .
DATA ENCAPSULATION defined after the public specifier are accessible by all other functions in your program .

Making one class friend of another , exposes the implementation details and reduces encapsulation .
The ideal is to keep as many of the details of each class hidden from all other classes as possible .

Data Encapsulation Example Any program where you implement class with public and private members is an example of data encapsulation and data abstraction .
Consider the following example : using namespace .

The public members addNum and are the interfaces to the outside world and user needs to know them to use the class .
The private member is something that is hidden from the outside world , but is needed for the class to operate properly .

Designing Strategy Most of us have learnt to make class members private by default unless we really need to expose them .
just good encapsulation .

This is applied most frequently to data members , but it applies equally to all members , including virtual functions .

An interface describes the behavior or capabilities of class without committing to particular implementation of that class .

The interfaces are implemented using abstract classes and these abstract classes should not be confused with data abstraction which is concept of keeping implementation details separate from associated data .

class is made abstract by declaring at least one of its functions as pure virtual function .
pure virtual function is specified by " in its declaration as follows : class Box .

The purpose of an abstract class referred to as an is to provide an appropriate base class from which other classes can inherit .
Abstract classes cannot be used to instantiate objects and serves only as an interface .

Attempting to instantiate an object of an abstract class causes compilation error .

Thus , if subclass of an ABC needs to be instantiated , it has to implement each of the virtual functions , which means that it supports the interface declared by the ABC .
Failure to override pure virtual function in derived class , then attempting to instantiate objects of that class , is compilation error .

Classes that can be used to instantiate objects are called concrete classes .

Abstract Class Consider the following example where parent class provides an interface to the base class to implement function called :
INTERFACES using namespace std ; Base class class Shape .

Designing Strategy An system might use an abstract base class to provide common and standardized interface appropriate for all the external .

Then , through inheritance from that abstract base class , derived classes are formed that operate similarly .

The capabilities , the public offered by the external are provided as pure virtual functions in the abstract base class .
The implementations of these pure virtual functions are provided in the derived classes that correspond to the specific types of the application .

This architecture also allows new to be added to system easily , even after the system has been defined .

So far , we have been using the iostream standard library , which provides cin and methods for reading from standard input and writing to standard output respectively .

This tutorial will teach you how to read and write from file .
This requires another standard library called fstream , which defines three new types : Data Type Description ofstream This type represents the output file stream and is used to create files and to write information to files .

To perform file processing in , header files and must be included in your source file .

Opening File file must be opened before you can read from it or write to it .
Either ofstream or fstream object may be used to open file for writing .
And ifstream object is used to open file for reading purpose only .

Following is the standard syntax for function , which is member of fstream , ifstream , and ofstream objects .

Mode Flag Description .
FILES AND STREAMS Append mode .
All output to that file to be appended to the end .

You can combine two or more of these values by ORing them together .
For example if you want to open file in write mode and want to truncate it in case that already exists , following will be the syntax : ofstream outfile ; Similar way , you can open file for reading and writing purpose as follows : fstream afile ; Closing File When program terminates it automatically flushes all the streams , release all the allocated memory and close all the opened files .
But it is always good practice that programmer should close all the opened files before program termination .

Following is the standard syntax for function , which is member of fstream , ifstream , and ofstream objects .

The only difference is that you use an ofstream or fstream object instead of the cout object .

Reading from File You read information from file into your program using the stream extraction operator just as you use that operator to input information from the keyboard .
The only difference is that you use an ifstream or fstream object instead of the cin object .

Read Write Example Following is the program which opens file in reading and writing mode .

After writing information entered by the user to file named , the program reads information from the file and outputs it onto the screen :

File Position Pointers Both istream and ostream provide member functions for repositioning the fileposition pointer .
These member functions are seekg for istream and seekp for ostream .

The argument to seekg and seekp normally is long integer .
second argument can be specified to indicate the seek direction .
The seek direction can be for positioning relative to the beginning of stream , for positioning relative to the current position in stream or for positioning relative to the end of stream .

The pointer is an integer value that specifies the location in the file as number of bytes from the starting location .
Some examples of positioning the " pointer are : position to the nth byte of fileObject ; position bytes forward in fileObject , position bytes back from end of fileObject , position at end of fileObject , An exception is problem that arises during the execution of program .
exception is response to an exceptional circumstance that arises while program is running , such as an attempt to divide by zero .

Exceptions provide way to transfer control from one part of program to another .

exception handling is built upon three keywords : try , catch , and throw .

This is done using throw keyword .

The catch keyword indicates the catching of an exception .

It is followed by one or more catch blocks .

Assuming block will raise an exception , method catches an exception using combination of the try and catch keywords .
block is placed around the code that might generate an exception .
Code within block is referred to as protected code , and the syntax for using is as follows : try .

You can list down multiple catch statements to catch different type of exceptions in case your try block raises more than one exception in different situations .

EXCEPTION HANDLING Throwing Exceptions Exceptions can be thrown anywhere within code block using throw statement .

The operand of the throw statement determines type for the exception and can be any expression and the type of the result of the expression determines the type of exception thrown .

Following is an example of throwing an exception when dividing by zero condition .

You can specify what type of exception you want to catch and this is determined by the exception declaration that appears in parentheses following the keyword catch .

If you want to specify that catch block should handle any type of exception that is thrown in try block , you must put an ellipsis , between the parentheses enclosing the exception declaration as follows : try protected code .

If we compile and run above code , this would produce the following result : Division by zero condition .

Standard Exceptions provides list of standard exceptions defined in which we can use in our programs .
These are arranged in class hierarchy shown below : Here is the small description of each exception mentioned in the above hierarchy : Exception Description An exception and parent class of all the standard exceptions .

Define New Exceptions You can define your own exceptions by inheriting and overriding exception class functionality .
Following is the example , which shows how you can use class to implement your own exception in standard way : using namespace std ; struct MyException  public exception .

This would produce the following result : MyException caught Exception Here , is public method provided by exception class and it has been overridden by all the child exception classes .
This returns the cause of an exception .

good understanding of how dynamic memory really works in is essential to becoming good programmer .
Memory in your program is divided into two parts : The stack : All variables declared inside the function will take up memory from the stack .

Many times , you are not aware in advance how much memory you will need to store particular information in defined variable the size of required memory can be determined at run time .

You can allocate memory at run time within the heap for the variable of given type using special in which returns the address of the space allocated .

If you are not in need of dynamically allocated memory anymore , you can use delete  which memory previously allocated by .

The delete Operators There is following generic syntax to use to allocate memory dynamically for any .

Let us start with types .
For example we can define pointer to type then request that the memory be allocated at execution time .
We can do this using the with the following statements : NULL ; Pointer initialized with null  Request memory for the variable The memory may not have been allocated successfully , if the free store had been used up .
So it is good practice to check if is returning NULL pointer take appropriate action as below :
DYNAMIC MEMORY NULL ; out of " The function from , still exists in , but it is recommended to avoid using function .
The main advantage of new is that new just allocate memory , it constructs objects which is prime purpose of .

At any point , when you feel variable that has been dynamically allocated is not anymore required , you can free up the memory that it occupies in the free store with the delete as follows : delete  Release memory pointed to by Let us put above concepts form the following example to show how new delete work :

Using the same syntax we have used above we can allocate memory dynamically as shown below .

For example , consider the following code where we are going to use an array of objects to clarify the concept : using namespace std ; class Box .

If we compile run above code , this would produce the following result : Constructor called .

Consider situation , when we have two persons with the same name , Zara , in the same class .
Whenever we need to differentiate them definitely we would have to use some additional information along with their name , like either the area , if they live in different area or their or name , etc .

Same situation can arise in your applications .
For example , you might be writing some code that has function called there is another library available which is also having same function .
Now the compiler has no way of knowing which version of function you are referring to within your code .

namespace is designed to overcome this difficulty is used as additional information to differentiate similar functions , classes , variables etc .
Using namespace , you can define the context in which names are defined .
In essence , namespace defines scope .

Defining Namespace namespace definition begins with the keyword namespace followed by the namespace name as follows : namespace code declarations To call the version of either function or variable , prepend the namespace name as follows : code could be variable or function .

Let us see how namespace scope the entities including variable functions :

NAMESPACES second name space .

This directive tells the compiler that the subsequent code is making use of names in the specified namespace .
The namespace is thus implied for the following code :

For example , if the only part of the std namespace that you intend to use is cout , you can refer to it as follows : using ; Subsequent code can refer to cout without prepending the namespace , but other items in the std namespace will still need to be explicit as follows : using ; int main cout is used with " return ; If we compile and run above code , this would produce the following result : is used with std .

Names introduced in using directive obey normal scope rules .
The name is visible from the point of the using directive to the end of the scope in which the directive is found .
Entities with the same name defined in an outer scope are hidden .

Discontiguous Namespaces can be defined in several parts and so is made up of the sum of its separately defined parts .
The separate parts of can be spread over multiple files .

So , if one part of the requires name defined in another file , that name must still be declared .
Writing following definition either defines new or adds new to an existing one : code declarations .

You can access members of nested by using resolution operators as follows : to access members of using ; to access members of using .

is blueprint or formula for creating generic class or function .

The library containers like iterators and algorithms are examples of generic programming and have been developed using concept .

There is single definition of each container , such as vector , but we can define many different kinds of vectors for example , vector or vector .

You can use templates to define functions as well as classes , let us see how they work : Function Template The general form of function definition is shown .

Here , type is placeholder name for data type used by the function .
This name can be used within the function definition .

The following is the example of function that returns the maximum of two values : using std ; inline Max ,

TEMPLATES int ; int ;  endl ; double ; double ;  endl ; string ; string ;  endl ; return .

Just as we can define function templates , we can also define class templates .

The general form of generic class declaration is shown here : class .

You can define more than one generic data type by using commaseparated list .

Following is the example to define class and implement generic methods to push and pop the from the stack :

All preprocessor directives begin with , and only characters may appear before preprocessor directive on line .
Preprocessor directives are not statements , so they do not end in semicolon .

You already have seen directive in all the examples .

There are number of preprocessor directives supported by like , etc .
Let us see important directives : The Preprocessor The preprocessor directive creates symbolic constants .
The symbolic constant is called macro and the general form of the directive is : When this line appears in file , all subsequent occurrences of macro in that file will be replaced by before the program is compiled .
For example : using namespace .

So let us compile it with option and redirect the result to .

Now , if you check , it will have lots of information and at the bottom , you will find the value replaced as follows :

This process called conditional compilation .

The conditional preprocessor construct much like the ' selection structure .

Consider the following preprocessor code : NULL NULL You can compile program for debugging purpose .
You can also turn on or off the debugging using single macro as follows : DEBUG "  endl ; This causes the statement to be compiled in the program if the symbolic constant DEBUG has been defined before directive DEBUG .
You can use statement to comment out portion of the program as follows : code prevented from compiling Let us try the following example : using namespace std ; DEBUG .

The operator causes token to be converted to string surrounded by quotes .

Consider the following macro definition : using namespace .

It simple to understand that the preprocessor turns the line : endl ; Above line will be turned into the following line :  endl ; The operator used to concatenate two tokens .
Here an example :  When CONCAT appears in the program , its arguments are concatenated and .

It simple to understand that the preprocessor transforms : Above line will be transformed into the following line :  Predefined Macros provides number of predefined macros mentioned below : Macro Description This contains the current line number of the program when it being compiled .

Let us see an example for all the above macros :

You can generate interrupts by pressing on UNIX , LINUX , Mac OS or Windows system .

There are signals which cannot be caught by the program but there is following list of signals which you can catch in your program and can take appropriate actions based on the signal .
These signals are defined in header file .

Signal Description SIGABRT Abnormal termination of the program , such as call to abort .

SIGFPE An erroneous arithmetic operation , such as divide by zero or an operation resulting in overflow .

SIGILL Detection of an illegal instruction .

SIGINT Receipt of an interactive attention signal .

SIGSEGV An invalid access to storage .

SIGTERM termination request sent to the program .

The Function library provides function signal to trap unexpected events .

Following is the syntax of the function : void sig , void ; Keeping it simple , this function receives two arguments : first argument as an integer , which represents signal number and second argument as pointer to the function .

Let us write simple program where we will catch SIGINT signal using function .
Whatever signal you want to catch in your program , you must register that signal using signal function and associate it with signal handler .

Examine the following example :
SIGNAL HANDLING .

Now , press to interrupt the program and you will see that your program will catch the signal and would come out by printing something as follows : Going to .

Interrupt signal received .

The Function You can generate signals by function , which takes an integer signal number as an argument and has the following syntax .

Following is the example where we raise signal internally using function as follows :

Interrupt signal received .

Multithreading is specialized form of multitasking and multitasking is the feature that allows your computer to run two or more programs concurrently .
In general , there are two types of multitasking : and .

multitasking handles the concurrent execution of programs .

multitasking deals with the concurrent execution of pieces of the same program .

multithreaded program contains two or more parts that can run concurrently .

Each part of such program is called thread , and each thread defines separate path of execution .

does not contain any support for multithreaded applications .

Instead , it relies entirely upon the operating system to provide this feature .

This tutorial assumes that you are working on Linux OS and we are going to write program using POSIX .
POSIX Threads , or Pthreads provides API which are available on many POSIX systems such as FreeBSD , NetBSD , Mac OS and Solaris .

Creating Threads The following routine is used to create POSIX  attr , Here , creates new and makes it executable .
This routine can be called any number of times from anywhere within your code .

Here is the description of the parameters : Parameter Description An opaque , unique identifier for the new returned by the subroutine .

You can specify attributes object , or NULL for the default values .

MULTITHREADING arg single argument that may be passed to .
It must be passed by reference as pointer cast of type void .
NULL may be used if no argument is to be passed .

The maximum number of threads that may be created by process is implementation dependent .
Once created , threads are peers , and may create other threads .
There is no implied hierarchy or dependency between threads .

Terminating Threads There is following routine which we use to terminate POSIX  Here is used to explicitly exit .

Typically , the routine is called after has completed its work and is no longer required to exist .

If finishes before the threads it has created , and exits with , the other threads will continue to execute .
Otherwise , they will be automatically terminated when finishes .

Example : This simple example code creates threads with the routine .

Thread ID ,  endl ;

Thread ID , Hello World .
Thread ID , Hello World .
Thread ID , Hello World .
Thread ID , Hello World .
Thread ID , Passing Arguments to Threads This example shows how to pass multiple arguments via structure .
You can pass any data type in callback because it points to void as explained in the following example :

Thread ID  Message  This is Thread ID  Message  This is Thread ID  Message  This is Thread ID  Message  This is Thread ID  Message  This is Joining and Detaching Threads There are following two routines which we can use to join or detach threads : The subroutine blocks the calling until the specified ' terminates .
When is created , one of its attributes defines whether it is joinable or detached .
Only threads that are created as joinable can be joined .
If is created as detached , it can never be joined .

This example demonstrates how to wait for completions by using the Pthread join routine .

The Common Gateway Interface , or CGI , is set of standards that define how information is exchanged between the web server and custom script .

The CGI specs are currently maintained by the NCSA and NCSA defines CGI is as follows : The Common Gateway Interface , or CGI , is standard for external gateway programs to interface with information servers such as HTTP servers .

The current version is and is under progress .

Web Browsing To understand the concept of CGI , see what happens when we click hyperlink to browse particular web page or URL .

If it finds the requested file then web server sends that file back to the browser otherwise sends an error message indicating that you have requested wrong file .

However , it is possible to set up the HTTP server in such way that whenever file in certain directory is requested , that file is not sent back ; instead it is executed as program , and produced output from the program is sent back to your browser to display .

The Common Gateway Interface is standard protocol for enabling applications CGI programs or CGI to interact with Web servers and with clients .
These CGI programs can be written in Python , PERL , Shell , or etc .

CGI Architecture Diagram The following simple program shows simple architecture of CGI :
WEB PROGRAMMING Web Server Configuration Before you proceed with CGI Programming , make sure that your Web Server supports CGI and it is configured to handle CGI Programs .
All the CGI Programs to be executed by the HTTP server are kept in directory .
This directory is called CGI directory and by convention it is named as .
By convention CGI files will have extension as , though they are executable .

By default , Apache Web Server is configured to run CGI programs in .
If you want to specify any other directory to run your CGI scripts , you can modify the following section in the file : AllowOverride None Options ExecCGI Order Allow from all Options All Here , assume that you have Web Server up and running successfully and you are able to run any other CGI program like Perl or Shell etc .

First CGI Program Consider the following Program content :

This is my first CGI ; cout ; cout ; return ; Compile above code and name the executable as .
This file is being kept in directory and it has following content .
Before running your CGI program make sure you have change mode of file using chmod UNIX command to make file executable .

Now if you click then this produces the following output : My First CGI program The above program is simple program which is writing its output on STDOUT file .
There is one important and extra feature available which is first line printing .
This line is sent back to the browser and specify the content type to be displayed on the browser screen .

Now you must have understood the basic concept of CGI and you can write many complicated CGI programs using Python .
CGI program can interact with any other external system , such as RDBMS , to exchange information .

HTTP Header The line is part of HTTP header , which is sent to the browser to understand the content .
All the HTTP header will be in the following form : HTTP Field Name : Field Content For Example : There are few other important HTTP headers , which you will use frequently in your CGI Programming .

Header Description : MIME string defining the format of the file being returned .
Example is .

Expires : Date The date the information becomes invalid .
This should be used by the browser to decide when page needs to be refreshed .
valid date string should be in the format Jan GMT .

Location : URL The URL that should be returned instead of the URL requested .
You can use this field to redirect request to any file .

: Date The date of last modification of the resource .

: The length , in bytes , of the data being returned .
The browser uses this value to report the estimated download time for file .

: String Set the cookie passed through the string .

CGI Environment Variables All the CGI program will have access to the following environment variables .

These variables play an important role while writing any CGI program .

Variable Name Description The data type of the content , used when the client is sending attached content to the server .
For example file upload etc .

The length of the query information that is available only for POST requests .

Returns the set cookies in the form of key value pair .

The field contains information about the user agent originating the request .
It is name of the web browser .

The path for the CGI script .

The information that is sent with GET method request .

The IP address of the remote host making the request .
This can be useful for logging or for authentication purpose .

The fully qualified name of the host making the request .
If this information is not available then can be used to get IR address .

The method used to make the request .
The most common methods are GET and POST .

The full path to the CGI script .

The name of the CGI script .

The hostname or IP Address .

The name and version of the software the server is running .

Here is small CGI program to list out all the CGI variables .

, gzip , deflate NT ; like Gecko PATH GET Apache CGI Library For real examples , you would need to do many operations by your CGI program .

There is CGI library written for program which you can download from and follow the steps to install the library : xzf install You can check related documentation available at CGI Lib .

GET and POST Methods You must have come across many situations when you need to pass some information from your browser to web server and ultimately to your CGI Program .
Most frequently browser uses two methods to pass this information to web server .
These methods are GET Method and POST Method .

Passing Information Using GET Method The GET method sends the encoded user information appended to the page request .
The page and the encoded information are separated by the ' character as follows : The GET method is the default method to pass information from browser to web server and it produces long string that appears in your .

Never use the GET method if you have password or other sensitive information to pass to the server .
The GET method has size limitation and you can pass up to characters in request string .

When using GET method , information is passed using http header and will be accessible in your CGI Program through environment variable .

You can pass information by simply concatenating and value pairs along with any URL or you can use HTML tags to pass information using GET method .

Simple URL Example : Get Method Here is simple URL which will pass two values to program using GET method .

We are going to use CGI library which makes it very easy to access passed .

We are going to use same CGI script to handle this input .

You enter First and Last Name and then click submit button to see the result .

First Name : Last Name : Submit Passing Information Using POST Method generally more reliable of passing information to CGI program is the POST .
This packages the information in exactly the same way as GET methods , but instead of sending it as text string after ' in the URL it sends it as separate message .
This message comes into the CGI script in the form of the standard input .

The same program will handle POST as well .
Let us take same example as above , which passes two values using HTML FORM and submit button but this time with POST as follows : First Name : Last Name : Here is the actual output of the above form .
You enter First and Last Name and then click submit button to see the result .

First Name : Last Name : Submit Passing Checkbox Data to CGI Program Checkboxes are used when more than one option is required to be selected .

Here is example HTML code for form with two checkboxes : Maths " Physics " Subject " The result of this code is the following form : Maths Physics Select Subject Below is program , which will generate script to handle input given by web browser through checkbox button .

Here is example HTML code for form with two radio button : Maths " Physics " Subject " The result of this code is the following form : Maths Physics Select Subject Below is program , which will generate script to handle input given by web browser through radio buttons .

Here is example HTML code for form with TEXTAREA box : Type your text .

Here is example HTML code for form with one dropdown box : The result of this code is the following form : Maths Submit Below is program , which will generate script to handle input given by web browser through drop down box .

But for commercial website it is required to maintain session information among different pages .
For example one user registration ends after completing many pages .
But how to maintain session information across all the web pages .

In many situations , using cookies is the most efficient of remembering and tracking preferences , purchases , commissions , and other information required for better visitor experience or site statistics .

How It Works Your server sends some data to the browser in the form of cookie .
The browser may accept the cookie .
If it does , it is stored as plain text record on the hard drive .
Now , when the visitor arrives at another page on your site , the cookie is available for retrieval .
Once retrieved , your server what was stored .

Cookies are plain text data record of fields : Expires : This showsthe date the cookie will expire .
If this is blank , the cookie will expire when the visitor quits the browser .

Domain : This is the domain of your site .

This may be blank if you want to retrieve the cookie from any directory or page .

If this field is blank , no such restriction exists .

Setting up Cookies It is very easy to send cookies to browser .
These cookies will be sent along with HTTP Header before the filed .
Assuming you want to set and as cookies .
So cookies setting will be done as follows :

We use SetCookie HTTP header to set cookies .

Here , it is optional to set cookies attributes like Expires ,  and .
It is notable that cookies are set before sending magic line .

Compile above program to produce , and try to set cookies using following link .
It will set four cookies at your computer : Retrieving Cookies It is easy to retrieve all the set cookies .
Cookies are stored in CGI environment variable and they will have following form .

Here is an example of how to retrieve cookies .

The input tag with the file will create " button .

But you can try above code with your server .

Here is the script to handle file .

Hope you have enjoyed this tutorial .
If yes , please send us your feedback .

Hope you have already understood the concept of Template which we have discussed earlier .
The STL Template is powerful set of template classes to provide classes and functions with templates that implement many popular and commonly used algorithms and data structures like vectors , lists , queues , and stacks .

At the core of the Standard Template Library are following three wellstructured components : Component Description Containers Containers are used to manage collections of objects of certain kind .
There are several different types of containers like deque , list , vector , map etc .

Algorithms Algorithms act on containers .
They provide the means by which you will perform initialization , sorting , searching , and transforming of the contents of containers .

Iterators Iterators are used to step through the elements of collections of objects .
These collections may be containers or subsets of containers .

We will discuss about all the three STL components in next chapter while discussing Standard Library .
For now , keep in mind that all the three components have rich set of functions which help us in doing complicated tasks in very easy fashion .

Let us take the following program that demonstrates the vector container Standard which is similar to an array with an exception that it automatically handles its own storage requirements in case it grows :

STL TUTORIAL create vector to store int vec ; int  display the original of vec 

The Standard can be categorized into two parts : The Standard Function  This library consists of generalpurpose , functions that are not part of any class .
The function library is inherited from .

Standard incorporates all the Standard libraries also , with small additions and changes to support type safety .

The Standard Function The standard function library is divided into the following categories : String and character handling , Mathematical , Time , date , and localization , Dynamic allocation , Miscellaneous , functions The Object Oriented Class Standard Object Oriented defines an extensive set of classes that provide support for number of common activities , including , strings , and numeric processing .
This library includes the following : The Standard Classes The String Class The Numeric Classes The STL Container Classes The STL Algorithms The STL Function Objects The STL Iterators The STL Allocators .
STANDARD LIBRARY The Localization library Exception Handling Classes Miscellaneous Support .
