Complete Guide to Programming in Ulla Peter Prinz JONES AND BARTLETT PUBLISHERS Ulla Peter Prinz Complete Guide to Programming in World Headquarters Jones and Bartlett Publishers Tall Pine Drive Sudbury , MA Jones and Bartlett Publishers Canada Nikanna Road Mississauga , ON CANADA Jones and Bartlett Publishers International Barb House , Barb Mews London UK Copyright by Jones and Bartlett Publishers , Inc .

All rights reserved .
No part of the material protected by this copyright notice may be reproduced or utilized in any form , electronic or mechanical , including photocopying , recording , or any information storage or retrieval system , without written permission from the copyright owner .

Cover Image : Stones on and yellow leaf , Bjorkliden , Sweden , by Peter Lilja Library of Congress Data Prinz , Peter .

complete guide to programming in Peter Prinz , Ulla ; translated by Ian Travis .

ISBN :

Chief Executive Officer : Clayton Jones Chief Operating Officer : Don .

, Managing Editor : Judith .
Hauck , Design and Production : Anne Spencer , Manufacturing and Inventory Control : Therese Br√§uer : Michael Stranz Development and Product Manager : Amy Rose Marketing Manager : Nathan Schultz Production Assistant : Tara McCormick Cover Design : Night Day Design Composition : Northeast Compositors Text Design : Mary McKeon Printing and Binding : Courier Westford Cover printing : John Pow Company , Inc .

This book was typeset in QuarkXpress on Macintosh .
The font families used were Goudy , Gill Sans , Courier , Rubino Serif , and Seven Sans .
The first printing was printed on lb .

Printed in the United States of America Dedicated to our children , Vivi and Jeany This page intentionally left blank This book was written for readers interested in learning the programming language from scratch , and for both novice and advanced programmers wishing to enhance their knowledge of .
It was our goal from the beginning to design this text with the capabilities of serving dual markets , as textbook for students and as holistic reference manual for professionals .

The language definition is based on the American National Standards Institute ANSI Standard .
This standard also complies with ISO norm , which was ratified by the International Standardization Organization in .
The programming language is thus in the main with majority of compilers providing ANSI support .
New elements of the language , such as exception handling and templates , are supported by most of the major compilers .
Visit the Jones and Bartlett web site at for listing of compilers available for this text .

The chapters in this book are organized to guide the reader from elementary language concepts to professional software development , with coverage of all the language elements en route .
The order in which these elements are discussed reflects our goal of helping the reader to create useful programs at every step of the way .

This type of visual representation offered by each spread will provide students and professionals with an unmatched guide throughout the text .
The sample programs were chosen to illustrate typical application for each language element .
In addition , filter programs and case studies introduce the reader to wide range of application scenarios .

To gain command over programming language , students need lot of experience in developing programs .
Thus , each chapter includes exercises followed by sample solutions , allowing the reader to test and enhance his or her performance and understanding of .

The appendix provides further useful information , such as binary number representation , directives , and operator precedence tables , making this book wellstructured and intelligible reference guide for programmers .

In order to test and expand your acquired knowledge , you can download sample programs and solutions to the exercises at : Content Organization Chapter gives thorough description of the fundamental characteristics of the objectoriented programming language .
In addition , students are introduced to the steps necessary for creating fully functional program .
Many examples are provided to help enforce these steps and to demonstrate the basic structure of program .

Chapter provides complete introduction to the basic types and objects used by programs .
Integral types and constants , fundamental types , and Boolean constants are just few of the topics discussed .

Chapter describes how to declare and call standard functions .
This chapter also teaches students to use standard classes , including standard header files .
In addition , students work with string variables for the first time in this chapter .

Chapter explains the use of streams for input and output , with focus on formatting techniques .
Formatting flags and manipulators are discussed , as are field width , fill characters , and alignment .

Chapter introduces operators needed for calculations and selections .
Binary , unary , relational , and logical operators are all examined in detail .

Chapter describes the statements needed to control the flow of program .
These include loops with while , and for ; selections with , switch , and the conditional operator ; and jumps with goto , continue , and break .

Chapter provides thorough introduction to the definition of symbolic constants and macros , illustrating their significance and use .
Furthermore , comprehensive examination of standard macros for character handling is included .

Chapter introduces implicit type conversions , which are performed in whenever different arithmetic types occur in expressions .
Additionally , the chapter explores an operator for explicit type conversion .

In addition to defining strings , the chapter looks at the various methods of string manipulation .
These include inserting and erasing , searching and replacing , comparing , and concatenating strings .

Chapter describes how to write functions of your own .
The basic rules are covered , as are passing arguments , the definition of inline functions , overloading functions and default arguments , and the principle of recursion .

Chapter gives thorough explanation of storage classes for objects and functions .

Object lifetime and scope are discussed , along with global , static , and auto objects .

Namespaces and external and static functions are also included in the discussion .

Chapter explains how to define references and pointers and how to use them as parameters return values of functions .
In this context , passing by reference and access to arguments are introduced .

Chapter provides complete description of how classes are defined and how instances of classes , or objects , are used .
In addition , structs and unions are introduced as examples of special classes .

Chapter describes how constructors and destructors are defined to create and destroy objects .
Also discussed are how inline methods , access methods , and methods can be used .
Furthermore , the chapter explains the pointer this , which is available for all methods , and what you need to pay attention to when passing objects as arguments or returning objects .

Chapter gives complete explanation of member objects and how they are initialized , and of data members that are created only once for all the objects in class .
In addition , this chapter describes constant members and enumerated types .

Chapter takes an look at how to define and use arrays .
Of particular interest are and multidimensional arrays , strings , and class arrays .

Chapter describes the relationship between pointers and arrays .
This includes pointer arithmetic , pointer versions of functions , pointers as return values and pointers , and pointer arrays .
Students learn that operations that use strings illustrate how to use pointers for efficient programming , and that string access via the command line of an application program is used to illustrate pointer arrays .

Chapter explains sequential file access using file streams .
Students will develop an understanding of how file streams provide simple and portable file handling techniques .

Chapter provides complete description of the various uses of overloaded operators .
Arithmetic operators , comparisons , the subscript operator , and the shift operators for input and output are overloaded to illustrate the appropriate techniques .
In addition , the concept of friend functions , which is introduced in this context , is particularly important for overloading operators .
Students learn how overloading operators allows them to apply existing operators to objects of class type .

Chapter discusses how implicit type conversion occurs in when an expression cannot be compiled directly but can be compiled after applying conversion rule .
The programmer can stipulate how the compiler will perform implicit type conversion for classes by defining conversion constructors and functions .
Finally , the chapter discusses ambiguity that occurs due to type conversion and how to avoid it .

PREFACE vii Chapter describes how program can allocate and release memory dynamically in line with current memory requirements .
Dynamic memory allocation is an important factor in many programs , and the following chapters contain several case studies to help students review the subject .

Chapter explains how to implement classes containing pointers to dynamically allocated memory .
These include your own copy constructor definition and overloading the assignment operator .
class designed to represent arrays of any given length is used as sample application .

Chapter provides thorough description of how derived classes can be constructed from existing classes by inheritance .
In addition to defining derived classes , this chapter discusses how members are redefined , how objects are constructed and destroyed , and how access control to base classes can be realized .

Chapter discusses implicit type conversion within class hierarchies , which occurs in the context of assignments and function calls .
Explicit type casting in class hierarchies is also described , paying particular attention to upcasting and downcasting .

Chapter gives complete explanation of how to develop and manage polymorphic In addition to defining virtual functions , dynamic downcasting in polymorphic class hierarchies is introduced .

Chapter describes how defining pure virtual methods can create abstract and how you can use abstract at polymorphic interface for derived .
To illustrate this , an inhomogeneous list , that is , linked list whose elements can be of various class types , is implemented .

Chapter describes how new are created by multiple inheritance and explains their uses .
Besides introducing students to the creation and destruction of objects in  virtual base are depicted to avoid ambiguity in multiple inheritance .

Chapter explains how program uses techniques to resolve error conditions .
In addition to throwing and catching exceptions , the chapter also examines how exception specifications are declared and exception are defined .
In addition , the use of standard exception is discussed .

Chapter examines random access to files based on file streams , and options for querying file state .
Exception handling for files is discussed as well .
The chapter illustrates how to make objects in polymorphic persistent , that is , how to save them in files .
The applications introduced in this chapter include simple index files and hash tables .

Chapter provides thorough explanation of the advanced uses of pointers .
These include pointers to pointers , functions with variable number of arguments , and pointers to functions .
In addition , an application that defines class used to represent dynamic matrices is introduced .

Chapter describes bitwise operators and how to use bit masks .
The applications included demonstrate calculations with parity bits , conversion of lowercase and capital letters , and converting binary numbers .
Finally , the definition of is introduced .

Chapter discusses how to define and use function and class templates .
In addition , special options , such as default arguments , specialization , and explicit instantiation , are viii discussed .
Students learn that templates allow the construction of functions and based on types that have not yet been stated .
Thus , templates are powerful tool for automating program code generation .

Chapter explains standard class templates used to represent containers for more efficient management of object collections .
These include sequences , such as lists and double ended queues ; container adapters , such as stacks , queues , and priority queues ; associative containers , such as sets and maps ; and bitsets .
In addition to discussing how to manage containers , the chapter also looks at sample applications , such as bitmaps for raster images , and routing techniques .

Additional Features Chapter Goals concise chapter introduction , which contains description of the contents , is presented at the beginning of each chapter .
These summaries also provide students with an idea of the key points to look for throughout the chapter .

Chapter Exercises Each chapter contains exercises , including programming problems , designed to test students ' knowledge and understanding of the main ideas .
The exercises also provide reinforcement for key chapter concepts .
Solutions are included to allow students to check their work immediately and correct any possible mistakes .

Case Studies Every chapter contains number of case studies that were designed to introduce the reader to wide range of application scenarios .

Notes This feature provides students with helpful tips and information useful to learning .
Important concepts and rules are highlighted for additional emphasis and easy access .

Hints These are informative suggestions for easier programming .
Also included are common mistakes and how to avoid making them .

Acknowledgements Our thanks go out to everyone who helped produce this book , particularly to Ian Travis , for his valuable contributions to the development of this book .

Alexa Doehring , who reviewed all samples and program listings , and gave many valuable hints from the American perspective .

Michael Stranz and Amy Rose at Jones and Bartlett Publishers , who managed the publishing agreement and the production process so smoothly .

Our children , Vivi and Jeany , who left us in peace long enough to get things finished .

And now all that remains is to wish you , Dear Reader , lots of fun with .

Ulla Peter Prinz PREFACE ix This page intentionally left blank xi Chapter Fundamentals Development and Properties of Programming Developing Program Program Structure of Simple Programs Exercises Solutions Chapter Fundamental Types , Constants , and Variables Fundamental Types Constants Escape Sequences Names Variables The Keywords const and volatile Exercises Solutions contents Chapter Using Functions and Classes Declaring Functions Function Calls Type void for Functions Header Files Standard Header Files Using Standard Classes Exercises Solutions Chapter Input and Output with Streams Streams Formatting and Manipulators Formatted Output of Integers Formatted Output of Numbers Output in Fields Output of Characters , Strings , and Boolean Values Formatted Input Formatted Input of Numbers Unformatted Exercises Solutions Chapter Operators for Fundamental Types Binary Arithmetic Operators Unary Arithmetic Operators Assignments Relational Operators Logical Operators Exercises Solutions Chapter Control Flow The while Statement The for Statement The Statement Selections with Chains Conditional Expressions Selecting with switch Jumps with break , continue , and goto Exercises Solutions xii Chapter Symbolic Constants and Macros Macros Macros with Parameters Working with the Directive Conditional Inclusion Standard Macros for Character Manipulation Redirecting Standard Input and Output Exercises Solutions Chapter Converting Arithmetic Types Implicit Type Conversions Performing Usual Arithmetic Type Conversions Implicit Type Conversions in Assignments More Type Conversions Exercises Solutions Chapter The Standard Class string Defining and Assigning Strings Concatenating Strings Comparing Strings Inserting and Erasing in Strings Searching and Replacing in Strings Accessing Characters in Strings Exercises Solutions Chapter Functions Significance of Functions in Defining Functions Return Value of Functions Passing Arguments Inline Functions Default Arguments Overloading Functions Recursive Functions Exercises Solutions Chapter Storage Classes and Namespaces Storage Classes of Objects The Storage Class extern CONTENTS xiii The Storage Class static The Specifiers auto and register The Storage Classes of Functions Namespaces The Keyword using Exercises Solutions Chapter References and Pointers Defining References References as Parameters References as Return Value Expressions with Reference Type Defining Pointers The Indirection Operator Pointers as Parameters Exercises Solutions Chapter Defining Classes The Class Concept Defining Classes Defining Methods Defining Objects Using Objects Pointers to Objects Structs Unions Exercise Solution Chapter Methods Constructors Constructor Calls Destructors Inline Methods Access Methods const Objects and Methods Standard Methods this Pointer Passing Objects as Arguments Returning Objects Exercises Solutions xiv Chapter Member Objects and Static Members Member Objects Member Initializers Constant Member Objects Static Data Members Accessing Static Data Members Enumeration Exercises Solutions Chapter Arrays Defining Arrays Initializing Arrays Arrays Class Arrays Multidimensional Arrays Member Arrays Exercises Solutions Chapter Arrays and Pointers Pointer Arithmetic Arrays as Arguments Pointer Versions of Functions Pointers Returning Pointers Arrays of Pointers Command Line Arguments Exercises Solutions Chapter Fundamentals of File Input and Output Files File Streams Creating File Streams Open Modes Closing Files Reading and Writing Blocks Object Persistence Exercises Solutions CONTENTS xv Chapter Overloading Operators Generals Using Overloaded Operators Global Operator Functions Friend Functions Friend Classes Overloading Subscript Operators Overloading for Exercises Solutions Chapter Type Conversion for Classes Conversion Constructors Conversion Functions Ambiguities of Type Conversions Exercise Solution Chapter Dynamic Memory Allocation The Operator new The Operator delete Dynamic Storage Allocation for Classes Dynamic Storage Allocation for Arrays Application : Linked Lists Representing Linked List Exercises Solutions Chapter Dynamic Members Members of Varying Length Classes with Dynamic Member Creating and Destroying Objects Implementing Methods Copy Constructor Assignment Exercises Solutions Chapter Inheritance Concept of Inheritance Derived Classes xvi Members of Derived Classes Member Access Redefining Members Constructing and Destroying Derived Classes Objects of Derived Classes Protected Members Exercises Solutions Chapter Type Conversion in Class Hierarchies Converting to Base Classes Type Conversions and Assignments Converting References and Pointers Explicit Type Conversions Exercises Solutions Chapter Polymorphism Concept of Polymorphism Virtual Methods Destroying Dynamically Allocated Objects Virtual Method Table Dynamic Casts Exercises Solutions Chapter Abstract Classes Pure Virtual Methods Abstract and Concrete Classes Pointers and References to Abstract Classes Virtual Assignment Application : Inhomogeneous Lists Implementing an Inhomogeneous List Exercises Solutions Chapter Multiple Inheritance Classes Multiple Indirect Base Classes Virtual Base Classes Constructor Calls Initializing Virtual Base Classes Exercises Solutions CONTENTS xvii Chapter Exception Handling Traditional Error Handling Exception Handling Exception Handlers Throwing and Catching Exceptions Nesting Exception Handling Defining Your Own Error Classes Standard Exception Classes Exercises Solutions Chapter More About Files Opening File for Random Access Positioning for Random Access File State Exception Handling for Files Persistence of Polymorphic Objects Application : Index Files Implementing an Index File Exercises Solutions Chapter More About Pointers Pointer to Pointers Variable Number of Arguments Pointers to Functions Complex Declarations Defining Typenames Application : Dynamic Matrices Exercises Solutions Chapter Manipulating Bits Bitwise Operators Bitwise Shift Operators Bit Masks Using Bit Masks Exercises Solutions Chapter Templates Function and Class Templates Defining Templates xviii Template Instantiation Template Parameters Template Arguments Specialization Default Arguments of Templates Explicit Instantiation Exercises Solutions Chapter Containers Container Types Sequences Iterators Declaring Sequences Inserting in Sequences Accessing Objects Length and Capacity Deleting in Sequences List Operations Associative Containers Sets and Multisets Maps and Multimaps Bitsets Exercise Solution Appendix Binary Numbers Preprocessor Directives Standard Macros Binding Functions Operators Overview Operator Precedence Table ASCII Code Table Screen Control Sequences Literature Index CONTENTS xix This page intentionally left blank Fundamentals This chapter describes the fundamental characteristics of the objectoriented programming language .
In addition , you will be introduced to the steps necessary for creating fully functional examples provided will help you retrace these steps and also demonstrate the basic structure of program .

The earliest versions , which were originally referred to as with " date back to .
As the name implies , was derived from the programming language : is the increment operator in .

As early as an ANSI Committee National Standards was founded to standardize the programming language .
The aim was to have as many compiler vendors and software developers as possible agree on unified description of the language in order to avoid the confusion caused by variety of dialects .

In the ISO Organization for approved standard for .

This means that you have all the features that are available in : universally usable modular programs efficient , close to the machine programming portable programs for various platforms .

The large quantities of existing source code can also be used in programs .

supports the concepts of programming OOP for , which are : data abstraction , that is , the creation of classes to describe objects data encapsulation for controlled access to object data polymorphism for , that is , the implementation of instructions that can have varying effects during program execution .

Various language elements were added to , such as references , templates , and exception handling .
Even though these elements of the language are not strictly programming features , they are important for efficient program implementation .

This has significant effect on the way program handles data : the programmer must ensure that data are initialized with suitable values before use and that suitable data are passed to function when it is called if the data representation is changed ,

Both of these points can lead to errors and neither support low program maintenance requirements .

program designed to maintain bank accounts would work with data such as balances , credit limits , transfers , interest calculations , and so on .
An object representing an account in program will have properties and capacities that are important for account management .

OOP objects combine data and functions .
class defines certain object type by defining both the properties and the capacities of the objects of that type .
Objects communicate by sending each other " which in turn activate another capacities .

More specifically , an object can reject erroneous access attempts easy : objects maintain themselves and can therefore be used as building blocks for other programs low maintenance requirement : an object type can modify its own internal data representation without requiring changes to the application .

Additional error messages may be shown if the compiler attempts to continue despite having found an error .
So when you are troubleshooting program , be sure to start with the first error shown .

+ + NOTE The following three steps are required to create and translate program :
First , text editor is used to save the program in text file .

In larger projects the programmer will normally use modular programming .
This means that the source code will be stored in several source files that are edited and translated separately .

The source file is put through compiler for translation .
If everything works as planned , an object file made up of machine code is created .
The object file is also referred to as module .

Finally , the linker combines the object file with other modules to form an executable file .
These further modules contain functions from standard libraries or parts of the program that have been compiled previously .

It is important to use the correct file extension for the source name .
Although the file extension depends on the compiler you use , the most commonly found file extensions are and .

Prior to compilation , header files , which are also referred to as include files , can be copied to the source file .
Header files are text files containing information needed by various source files , for example , type definitions or declarations of variables and functions .

Header files can have the file extension , but they may not have any file extension .

The standard library contains predefined and standardized functions that are available for any compiler .

Modern compilers normally offer an integrated software development environment , which combines the steps mentioned previously into single task .
graphical user interface is available for editing , compiling , linking , and running the application .
Moreover , additional tools , such as debugger , can be launched .

In addition to error messages , the compiler will also issue warnings .
warning does not indicate syntax error but merely draws your attention to possible error in the logic , such as the use of variable .

Function name What the program does Type of function End of function Beginning of function Function block .

What the program does  + + program is made up of objects with their accompanying member functions and global functions , which do not belong to any single particular class .
Each function fulfills its own particular task and can also call other functions .
You can create functions yourself or use functions from the standard library .
You will always need to write the global function yourself since it has special role to play ; in fact it is the main program .

The short programming example on the opposite page demonstrates two of the most and displays message .

The first line begins with the number symbol , which indicates that the line is intended for the preprocessor .
The preprocessor is just one step in the first translation phase and no object code is created at this time .
You can type to have the preprocessor copy the quoted file to this position in the source code .
This allows the program access to all the information contained in the header file .
The header file iostream comprises conventions for input and output streams .
The word stream indicates that the information involved will be treated as flow of data .

Predefined names in are to be found in the std namespace .
The using directive allows direct access to the names of the std namespace .

Program execution begins with the first instruction in function , and this is why each program must have main function .
The structure of the function is shown on the opposite page .
Apart from the fact that the name cannot be changed , this structure is not different from that of any other function .

In our example the function contains two statements .
The first statement yourself with " endl ; outputs the text string Enjoy yourself with .
The name designates an object responsible for output .

The two symbols , indicate that characters are being " to the output stream .
Finally endl of causes line feed .
The statement return ; terminates the function and also the program , returning value of as an exit code to the calling program .
It is standard practice to use the exit code to indicate that program has terminated correctly .

Note that statements are followed by semicolon .
By the way , the shortest statement comprises only semicolon and does nothing .

program with several functions Screen output Hello .
The program starts in .

+ + The example on the opposite page shows the structure of program containing multiple functions .
In  functions do not need to be defined in any fixed order .
For example , you could define the function first , followed by the function , and finally the function .

However , it is more common to start with the function as this function controls the program flow .
In other words , calls functions that have yet to be defined .
This is made possible by supplying the compiler with function prototype that includes all the information the compiler needs .

This example also introduces comments .
Strings enclosed in .

EXAMPLES : can cover several lines can cover just one In comments the compiler ignores any characters following the signs up to the end of the .
Comments that cover several lines are useful when troubleshooting , as you can use them to mask complete sections of your program .
Both comment types can be used to comment out the other type .

As to the layout of source files , the compiler parses each source file sequentially , breaking the contents down into tokens , such as function names and operators .
Tokens can be separated by any number of whitespace characters , that is , by spaces , tabs , or new characters .
The order of the source code is important but it is not important to adhere to specific layout , such as organizing your code in rows and columns .
For example void function " might be difficult to read , but it is correct definition of the function .

Preprocessor directives are one exception to the layout rule since they always occupy single .
The number sign , at the beginning of can be preceded only by space or tab character .

To improve the legibility of your programs you should adopt consistent style , using indentation and blank lines to reflect the structure of your program .
In addition , make generous use of comments .

Since computer uses different methods for processing and saving data , the data type must be known .
The type defines .

number such as can be stored in either or bytes .
When accessing the part of memory in which the number is stored , it is important to read the correct number of bytes .
Moreover , the memory content , that is the bit sequence being read , must be interpreted correctly as signed integer .

The compiler recognizes the fundamental types , also referred to as types , shown on the opposite page , on which all other types , pointers , classes , are based .

uses the bool type to represent boolean values .
An expression of the type bool can either be true or false , where the internal value for true will be represented as the numerical value and false by zero .

character code is an integer associated with each character .
The letter is represented by code , for example .
The character set defines which code represents certain character .
When displaying characters on screen , the applicable character codes are transmitted and the " that is the screen , is responsible for correctly interpreting the codes .

The language does not stipulate any particular characters set , although in general character set that contains the ASCII code Standard Code for Information is used .
This code contains definitions for control characters and printable characters .

The char type is used to store character codes in one byte .
This amount of storage is sufficient for extended character sets , for example , the ANSI character set that contains the ASCII codes and additional characters such as German umlauts .

The character type comprises at least bytes and is thus capable of storing modern Unicode characters .
Unicode is code also used in Windows NT and containing codes for approximately characters in languages .

These types are distinguished by their ranges of values .
The table on the opposite page shows the integer types , which are also referred to as integral types , with their typical storage requirements and ranges of values .

The int type is for computers and adapts to the length of register on the computer .
For computers , int is thus equivalent to short , whereas for computers int will be equivalent to long .

treats character codes just like normal integers .
This means you can perform calculations with variables belonging to the char or types in exactly the same way as with int type variables .
The range of values is thus to or from to , depending on whether the compiler interprets the char type as signed or unsigned .

The type is further integral type and is normally defined as unsigned short .

However , integral types can be preceded by the keyword unsigned .
The amount of memory required remains unaltered but the range of values changes due to the highest bit no longer being required as sign .
The keyword unsigned can be used as an abbreviation for unsigned .

The type is also normally interpreted as signed .
Since this is merely convention and not mandatory , the signed keyword is available .
Thus three types are available :  signed  and unsigned .

The current value ranges are available in the climits header file .
This file defines constants such as , and  which represent the smallest and greatest possible values .
The program on the opposite page outputs the value of these constants for the and unsigned types .

In ANSI the size of integer types is not preset .
However , the following order applies : long Moreover , the type comprises at least bytes and the long type at least bytes .

The table above makes use of this representation .

In contrast to integers , numbers must be stored to preset accuracy .
The following three types are available for calculations involving numbers : float for simple accuracy double for double accuracy long double for high accuracy The value range and accuracy of type are derived from the amount of memory allocated and the internal representation of the type .

Accuracy is expressed in decimal places .
This means that decimal places " allows programmer to store two numbers that differ within the first six decimal places as separate numbers .
In reverse , there is no guarantee that the figures and will be distinguished when working to accuracy of six decimal places .
And remember , it is not question of the position of the decimal point , but merely of the numerical sequence .

If it is important for your program to display numbers with an accuracy supported by particular machine , you should refer to the values defined in the cfloat header file .

Readers interested in additional material on this subject should refer to the Appendix , which contains section on the representation of binary numbers on computers for both integers and numbers .

For example , value of or depending on the machine .
In contrast , will always equal .

The types used for integers and numbers are collectively referred to as arithmetic types , as arithmetic operators are defined for them .

The void type is used for expressions that do not represent value .
function call can thus take void type .

Constants can thus be subdivided into boolean constants numerical constants character constants string constants .

Every constant represents value and thus does every expression in .
The type is defined by the way the constant is written .

Both constants are the bool type .
They can be used , for example , to set flags representing just two states .

Hexadecimal numbers can be capitalized or noncapitalized .

Integral constants are normally type int .
If the value the constant is too large for the int type , type capable representing larger values will be applied .
The ranking for decimal constants is as follows : int , long , unsigned long You can designate the type constant by adding the letter or , or or .
For example , and correspond to the type long and correspond to the type unsigned int and correspond to the type unsigned long   String literal : Stored byte sequence : Examples for constants Examples for character constants Internal representation of string literal .

However , exponential notation is also permissible .

EXAMPLES : Type : double Here , represents value of .
can also be written with small letter .
decimal point or must always be used to distinguish constants from integer constants .

constants are of type double by default .
However , you can add or to designate the float type , or add or for the long double type .

Character constants take the type char .

EXAMPLE : Type : char The numerical value is the character code representing the character .
The constant ' thus has value of in ASCII code .

string constant consists of sequence of characters enclosed in double quotes .

EXAMPLE : comprises two bytes , the first byte containing the code for the character zero code and the second byte the value .

The terminating null character is an example of an escape sequence .
Escape sequences are described in the following section .

Single character Meaning ASCII code string terminating character numerical value of character '

The effect of an escape sequence will depend on the device concerned .
The sequence , for example , depends on the setting for the tab width , which defaults to eight blanks but can be any value .

An escape sequence always begins with and represents single character .
The table on the opposite page shows the standard escape sequences , their decimal values , and effects .

You can use octal and hexadecimal escape sequences to create any character code .

Thus , the letter in ASCII code can also be expressed as or .
Traditionally , escape sequences are used only to represent characters and special characters .
The control sequences for screen and printer drivers are , for example , initiated by the ESC character , which can be represented as or .

Escape sequences are used in character and string constants .

EXAMPLES : The characters , and have no special significance when preceded by backslash ,

When using octal numbers for escape sequences in strings , be sure to use three digits , for example , and not .
This helps to avoid any subsequent numbers being evaluated as part of the escape sequence .
There is no maximum number of digits in hexadecimal escape sequence .
The sequence of hex numbers automatically terminates with the first character that is not valid hex number .

The sample program on the opposite page demonstrates the use of escape sequences in strings .
The fact that string can occupy two lines is another new .
String constants separated only by white spaces will be concatenated to form single string .

To continue string in the next you can also use backslash as the last character in  and then press the Enter key to begin new  where you can continue typing the string .

EXAMPLE : am very , very Please note , however , that the leading spaces in the second will be evaluated as part of the string .
It is thus generally preferable to use the first method , that is , to terminate the string with  and reopen it with .

The following rules apply when creating names , which are also known as identifiers : name contains series of letters , numbers , or underscore characters .
German umlauts and accented letters are invalid .
is case sensitive ; that is , and lowercase letters are different .

The opposite page shows keywords and some examples of valid and invalid names .

The compiler uses internal names that begin with one or two underscores followed by capital letter .
To avoid confusion with these names , avoid use of the underscore at the beginning of name .

Under normal circumstances the linker only evaluates set number of characters , for example , the first characters of name .
For this reason names of global objects , such as functions , should be chosen so that the first eight characters are significant .

The names of some variables tend to be associated with specific use .

EXAMPLES : c , ch for characters , for integers , in particular indices , for numbers To improve the readability of your programs you should choose longer and more selfexplanatory names , such as or startIndex for the first index in range of index values .

In the case of software projects , naming conventions will normally apply .
For example , prefixes that indicate the type of the variable may be assigned when naming variables .

Integers are printed in decimal format by default .

VARIABLES Data such as numbers , characters , or even complete records are stored in variables to enable their processing by program .
Variables are also referred to as objects , particularly if they belong to class .

When you define variable the type is specified and an appropriate amount of memory reserved .
This memory space is addressed by reference to the name of the variable .
simple definition has the following syntax : SYNTAX : typ .

Thus , one or more variables can be stated within single definition .

EXAMPLES : char c ; int , counter ; double , size ; In program , variables can be defined either within the functions or outside of them .
This has the following effect : variable defined outside of each function is global ,

Local variables are normally defined immediately after the first example at the beginning of function .
However , they can be defined wherever statement is permitted .
This means that variables can be defined immediately before they are used by the program .

Initialization is achieved by placing the following immediately after the name of the variable : an equals and an initial value for the variable or round brackets containing the value of the variable .

EXAMPLES : char ; float ; Any global variables not explicitly initialized default to zero .
In contrast , the initial value for any local variables that you fail to initialize will have an undefined initial value .

As an object of this type is constant , it cannot be modified at later stage and must be initialized during its definition .

EXAMPLE : const double ; Thus the value of cannot be modified by the program .
Even statement such as the following will merely result in an error message : + invalid Volatile Objects The keyword volatile , which is rarely used , creates variables that can be modified not only by the program but also by other programs and external events .
Events can be initiated by interrupts or by hardware clock , for example .

EXAMPLE : volatile unsigned long ; Even if the program itself does not modify the variable , the compiler must assume that the value of the variable has changed since it was last accessed .
The compiler therefore creates machine code to read the value of the variable whenever it is accessed instead of repeatedly using value that has been read at prior stage .

It is also possible to combine the keywords const and volatile when declaring variable .

EXAMPLE : volatile const unsigned ; Based on this declaration , the variable cannot be modified by the program but by external events .

EXERCISES Exercise The sizeof operator can be used to determine the of bytes occupied in memory by variable of certain type .
For example , is equivalent to .

Write program that displays the memory space required by each fundamental type on screen .

Exercise Write program to generate the screen output shown on the opposite page .

Exercise Which of the variable definitions shown on the opposite page is invalid or does not make sense .

Exercise Write program that two defines variables for numbers and initializes them with the values and Then display the sum and the difference of these two numbers on screen .

SOLUTIONS Exercise Incorrect : is not an integer value const large ; Without initialization .

The type void is available for functions of this type , which are also referred to as procedures in other programming languages .

Example : void unsigned int seed ; The standard function initializes an algorithm that generates random numbers .
Since the function does not return value , it is of type void .
An unsigned value is passed to the function as an argument to seed the random number generator .
The value is used to create series of random numbers .

Example : int void ; or int ; The standard function is called without any arguments and returns random number between and .
series of random numbers can be generated by repeating the function call .

The function prototypes for and can be found in both the cstdlib and header files .

Calling the function without previously having called creates the same of numbers as if the following statement would have been proceeded : If you want to avoid generating the same of random numbers whenever the program is executed , you must call with different value for the argument whenever the program is run .

It is common to use the current time to initialize random number generator .
See Chapter for an example of this technique .

Output the new on screen .

This page intentionally left blank Input and Output with Streams This chapter describes the use of streams for input and output , focusing on formatting techniques .

This gave rise to the stream classes , which are now available in library of their own , the iostream library .

The diagram on the opposite page shows how hierarchy develops due to inheritance .
The ios is the base of all other stream classes .
It contains the attributes and abilities common to all streams .
Effectively , the ios manages the connection to the physical data stream that writes your data to file or outputs the data on screen contains the basic functions needed for formatting data .
of flags that determine how character input is interpreted have been defined for this purpose .

The istream and ostream classes derived from ios form interface for stream manipulation .
The istream is used for reading streams and the ostream is used for writing to streams .
The operator is defined in istream and is defined in ostream , for example .

The iostream is derived by multiple inheritance from istream and ostream and thus offers the functionality of both classes .

Further stream classes , file management  for example , are derived from the classes mentioned above .
This allows the developer to use the techniques described for file manipulation .
These classes , which also contain methods for opening and closing files , will be discussed in later chapter .

When program is launched these objects are automatically created to read standard input or write to standard output .

Standard input is normally the keyboard and standard output the screen .
However , standard input and output can be redirected to files .
In this case , data is not read from the keyboard but from file , or data is not displayed on screen but written to file .

The other two standard streams cerr and clog are used to display messages when errors occur .
Error messages are displayed on screen even if standard output has been redirected to file .

The other positive numbers are printed with their sign as .

The output of positive sign can be canceled by the manipulator .

The last statement is equivalent to ; The operators and format the input output according to how the flags in the base ios are set The manipulator is function that calls the method , being the flag belonging to the ios Using manipulators is easier than directly accessing flags .
For this reason , manipulators are described in the following section , whereas the methods and are used only under exceptional circumstances .

Similarly , screen output adheres to set of rules governing how , for example , numbers are displayed .

The stream classes istream and ostream offer various options for performing these tasks .
For example , you can display table of numeric values in simple way .

In previous chapters we have looked at the cin and streams in statements such as : enter number : cin ; The following sections systematically describe the abilities of the stream classes .
This includes : the and operators for formatted input and output .
These operators are defined for expressions with fundamental is , for characters , boolean values , numbers and strings .

Manipulators can be used to generate formats for subsequent .
One manipulator that you are already familiar with is endl , which generates line feed at the end of line .

In general , flags are represented by individual bits within special integral variable .
For example , depending on whether bit is set or not , positive number can be output with or without plus sign .

Each flag has default setting .
For example , integral numbers are output as decimals by default , and positive numbers are output without plus sign .

It is possible to modify individual formatting flags .
The methods and can be used for this purpose .
However , the same effect can be achieved simply by using manipulators , which are defined for all important flags .
Manipulators are functions that can be inserted into the input or output stream and thus be called .

Generates capital letters in hexadecimal output .

Generates numeric output without + sign .

Generates lowercase letters in hexadecimal output .

The following formatting options are available : define the numeric system in which to display the  decimal , octal , or hexadecimal use capitals instead of small letters for hexadecimals display sign for positive numbers .

In addition , the field width can be defined for the above types .
The field width can also be defined for characters , strings , and numbers , and will be discussed in the following sections .

The manipulators oct ,  and dec can be used for switching from and to decimal display mode .

Example : Output : Hexadecimals are displayed in small letters by default , that is , using ,
The manipulator allows you to use capitals .

Example : The manipulator nouppercase returns the output format to small letters .

You can use the manipulator to output signed positive numbers .

Example : You can use noshowpos to revert to the original display mode .

When octal or hexadecimal numbers are output , the bits of the to be output are always interpreted as unsigned .
In other words , the output shows the bit pattern of in octal or hexadecimal format .

Example :   This statement causes the following output on system : ffffffff .

The key word const within the prototype of signifies that the method performs only read operations .

Returns the used precision .

The of digits after the decimal point corresponds to the used precision .

Output in fixed point notation Output in notation Sets the precision to .

Trailing zeroes after the decimal point are not printed .

If there are no digits after the decimal point , the decimal point is not printed .

Decimals are separated from the integral part of the number by decimal point .
Trailing zeroes behind the decimal point are not printed .
If there are no digits after the decimal point , the decimal point is not printed .

Examples : Output : Output : Output :

Very large and very small numbers are displayed in exponential notation .

Example : Output : Formatting The standard settings can be modified in several ways .
You can change the precision ,

Both the manipulator the method can be used to redefine precision to be used .

This also applies to all standard manipulators called with at least one argument .

The manipulator outputs the decimal point and trailing zeroes .
The number of digits being output .

Example : Output : However , point output with predetermined number of decimal places is often more useful .
In this case , you can use the manipulator with the precision defining the number of decimal places .
The value of is assumed in the following example .

Example : Output : In contrast , you can use the manipulator to specify that numbers are output as exponential expressions .

Manipulator Effects Sets the minimum field width to Sets the fill character to ch output in fields output in fields output of the sign and output of the numeric value left right internal OUTPUT IN FIELDS The operator can be used to generate formatted output in fields .
You can specify the field width set the alignment of the output to or specify with which to fill the field .

If the output string is larger than the field width , the output is not truncated but the field is extended .

The output will always contain at least the number of digits specified as the field width .

You can either use the method or the manipulator to define field width .

Example : or : One special attribute of the field width is the fact that this value is : the field width specified applies to the next output only , as is illustrated by the examples on the opposite page .
The first example outputs the character ' to field with width of , but does not output the ' character .

The default field width is .
You can also use the method to get the current field width .
To do so , call without any other arguments .

Example : int ; Fill Characters and Alignment If field is larger than the string you need to output , blanks are used by default to fill the field .
You can either use the method or the manipulator to specify another fill character .

Example : Output : The fill character applies until another character is defined .

As the previous example shows , output to fields is normally .
The other options available are and  which can be set by using the manipulators left and .
The manipulator the sign and rightjustifies the number within field .

Example : Output : Enters character and outputs its .

The program to be continued return ; The buffer is cleared and error flags are reset by calling the and methods .
This ensures that the program will wait for new for the  even if more than characters have been entered for the label .

When reading from standard  cin is buffered by .
Keyboard is thus not read until confirmed by pressing the key .
This allows the user to press the backspace key and correct any errors , provided the return key has not been pressed .

Input is displayed on screen by default .

Any white space characters as blanks , tabs , and new are ignored by default .

Example : char  cin  Enter character When the following keys are pressed the character ' is stored in the variable .

An field is terminated by the first white space character or by the first character that cannot be processed .

Example : int ; cin ; Typing stores the decimal value in the variable .
However , the characters that follow , FF and the newline character , remain in the buffer and will be read first during the next read operation .

When reading strings , only one word is read since the first white space character will begin new field .

Example : string city ; cin city ; To read just one word .

If Lao Kai is  only Lao will be written to the city string .
The of characters to be read can also be limited by specifying the field width .
For given field width of , maximum of characters will be read , as one byte is required for the null character .
Any initial white space will be ignored .
The program on the opposite page illustrates this point and also shows how to clear the buffer .

Example : int ; cin oct ; An value of will be interpreted as an octal , which corresponds to decimal value of .

Example : cin hex ; Here , any will be interpreted as hexadecimal , enabling such as or .

The can be entered in point or exponential notation .

Example : double  cin  The character is converted to double value in this case .
Input , such as , or is valid .

Example : int , cin ; Given of the digit will be stored in the variable .
The next field begins with .
But since decimal type is required , the sequence will not be processed beyond the letter .
If , as in our example , no type conversion is performed , the variable is not written to and an internal error flag is raised .

It normally makes more sense to read numerical values individually , and clear the buffer and any error flags that may have been set after each entry .

Chapter , and Chapter , show how program can react to errors .

of more than one line can be entered .

The sample program requires that at least one word and following white space are entered .

Exercise The corrected .

Overloading and other operators , such as those needed for bit manipulations , are introduced in later chapters .

In expressions of this type the variable must be placed on the left and the assigned on the right of the assignment .

In the case of the last example , the right side of the expression is first evaluated and the result is assigned to the variable on the left .

Each assignment is an expression in its own right , and its is the assigned .

Example : In this assignment the number is assigned to and then passed to the function as an argument .

Multiple assignments , which are always evaluated from right to left , are also possible .

Example : In this case the is first assigned to and then to .

The second example shows that compound assignments are implicitly placed in parentheses , as is demonstrated by the fact that the precedence of the compound assignment is just as low as that of the simple assignment .

Compound assignment operators can be composed from any binary arithmetic , as we will see later , with bit .
The following compound operators are thus 

You can modify variable when evaluating complex expression by means of an assignment or the , operators .
This technique is referred to as side effect .
Avoid use of side effects if possible , as they often lead to errors can impair the readability of your programs .

Example : circuit false or true If the variables circuit contain the same number , the comparison is true the value of the relational expression is true .
But if the expressions contain different values , the value of the expression will be false .

When individual characters are compared , the character codes are compared .
The result therefore depends on the character set you are using .
The following expression results in the value true when ASCII code is used .

Example : true , Precedence of Relational Operators Relational operators have lower precedence than arithmetic operators but higher precedence than assignment operators .

Example : bool max ; In our example , max is evaluated first , then the is compared to  the value of the relational expression or is assigned to the variable .

Similarly , in the following Example : int  + limit ; + is evaluated first , then the is compared to limit , the value of the relational expression is assigned to the variable .
Since is an int type , numerical value is assigned instead of false or true ,

It is quite common to assign value before performing comparison , parentheses must be used in this case .

Example : + limit Our example stores the of + in the variable then compares this expression with limit .

You cannot use the assignment to compare two expressions .
The compiler will not generate an error message if the value on the left is variable .
This mistake has caused headaches for lots of beginners when troubleshooting their programs .

Any value other than is NOTE LOGICAL OPERATORS " table for logical operators Examples for logical expressions true true true false false true false false false true true false false true true false true false true false false true true false .

They can be used to create compound conditions and perform conditional execution of program depending on multiple conditions .

logical expression results in value false or true , depending on whether the logical expression is correct or incorrect , just like relational expression .

However , operands of any type that can be converted to bool can also be used , including any arithmetic types .
In this case the operand is interpreted as false , or converted to false , if it has value of .
Any other value than is interpreted as true .

The OR will return true only if at least one operand is true , so the value of the expression Example : is true if is less than or greater than .

The AND will return true only if both operands are true , so the logical expression Example : is true , provided index is less than max and number is successfully input .
If the condition index max is not met , the program will not attempt to read number .
One important feature of the logical operators and is the fact that there is fixed order of evaluation .
The left operand is evaluated first and if has already been ascertained , the right operand will not be evaluated .

If the variable flag contains the value false the value , returns the boolean value true .

The precedence of both these operators is higher than the precedence of an assignment operator , but lower than the precedence of all previously used operators .
This is why it was permissible to omit the parentheses in the examples earlier on in this chapter .

Refer to the table of precedence in the Appendix for further details .

What value will be assigned in part to the variable if the variable has value of .

Exercise The int variable contains the number .
Calculate the value of the following logical .

The value will be assigned to the variable .

The set of instructions to be iterated is called the loop body .
offers three language elements to formulate iteration statements : while , and for .
The number of times loop is repeated is defined by controlling expression .
In the case of while and for statements this expression is verified before the loop body is executed , whereas loop is performed once before testing .

The while statement takes the following format : Syntax : statement loop body When entering the loop , the controlling expression is verified ,
If this value is true , the loop body is then executed before the controlling expression is evaluated once more .

If the controlling expression is false ,

It is common practice to place the loop body in new of the source code and to indent the statement to improve the readability of the program .

Example : int ; endl ; As this example illustrates , the controlling expression is normally boolean expression .

However , the controlling expression might be any expression that can be converted to the bool type including any arithmetic expressions .
As we already learned from the section on boolean operators , the value converts to false and all other values convert to true .

block is syntactically equivalent to statement , so you can use block wherever the syntax requires statement .

The program on the opposite page calculates the average of sequence of integers input via the keyboard .
Since the loops contains two statements , the statements must be placed in block .

The controlling expression cin is true provided the user inputs an integer .

The result of converting the expression cin to bool type will be true for any valid input and false in any other case .
Invalid input , if the user types letter instead of an integer , for example , terminates the loop and executes the next statement .

Example : int 
Thus , for has the following form : Syntax : statement is executed first and only once to initialize the .
Subsequently , the is reinitialized by executing and is .

You can also define the counter in .
Doing so means that the counter can be used within the  but not after leaving the .

Example :  As this example illustrates , the body can be an empty statement .
This is always the case if the header contains all necessary statements .
However , to improve readability , even the empty statement should occupy of its own .

In direction the ball is subject to constant acceleration of , expressed as .

EXERCISES Since the program must not immediately output single following control  you will need to store the predecessor of this .
You may want to use two counters to count the of characters and control characters in the current string .

In both cases use the conditional operator .

Add these macros and other macros from this chapter to the header file and then test the macros .

If your system supports screen control macros , also add some screen control macros to the header .
For example , you could write macro named to define the foreground and background colors for the following output .

Exercise Modify the program to .

You will need the functions and to solve parts and of this problem .

Exercise Write filter program to display the text contained in any given program should filter any control characters out of the input with the exception of the characters and , which are to be treated as normal characters for the purpose of this exercise .
Control characters are defined by codes to .

sequence of control characters is to be represented by single space .

single  that is , appearing between two control characters , is not to be output .

SOLUTIONS Exercise .

This page intentionally left blank Converting Arithmetic Types This chapter introduces implicit type conversions , which are performed in whenever different arithmetic types occur in expressions .

Additionally , an operator for explicit type conversion is introduced .

The compiler automatically performs implicit type conversion , where common type , which allows the operation in question to be performed , is assigned for the values of both operands .
You can generally assume that the " type will be converted to the " type .
The assignment operator is an exception to this rule and will be discussed separately .

The result of an arithmetic operation belongs to the common type used to perform the calculation .
However , comparison expressions will be bool types no matter what type of operands are involved .

This type conversion is performed so as to preserve the original values .
The boolean value false is converted to and true is converted to .

Thus , will always use int type values or greater when performing calculations .

Given char variable  the values of and ' in the expression Example : will be converted to int before being compared .

In this case , the type of the operand with the highest rank in the hierarchy is applied .
These type conversions and integer promotions are collectively known as usual arithmetic type conversions .

In our example ,  the value of size is first promoted to int before an integer division is performed .
The interim result is then converted to double and multiplied by .

Usual arithmetic type conversions are performed for all binary operators and the conditional operator : provided the operands belong to an arithmetic type , the only exceptions being the assignment operator and the logical operators and .

Binary representaion of the integer as value of type signed char .

Binary representaion of the integer as value of type signed char .

The value of negative number changes if the pattern is interpreted as unsigned .
The pattern of , for example , corresponds to the unsigned char value + + + + + + NOTE PERFORMING USUAL ARITHMETIC TYPE CONVERSIONS Converting signed integers Converting positive number Converting negative number The pattern of is computed by starting with the pattern of and generating the binary complement Binary Representation of Numbers in the .

PERFORMING USUAL ARITHMETIC TYPE CONVERSIONS Usual arithmetic conversions retain the value of number provided it can be represented by the new .
The procedure for conversion depends on the types involved :
Conversion of an unsigned to larger integral Examples : unsigned char to int or unsigned int Zero extension is performed first .
During this process , the pattern of the number to be converted is expanded to match the length of the new by adding zeros from the left .

Conversion of signed to larger integral The new is also signed Examples : char to int , short to long Signed integers are represented by generating the binary complement .
The value is retained by performing sign extension .
As shown in the example on the opposite page , the original pattern is expanded to match the length of the new by padding the sign from the left .

If the new is of the same length , the pattern is retained .
However , the pattern will be interpreted differently .
The sign bit loses its significance the note .

If the new is longer , sign extension is performed first and the new bit pattern is then interpreted as unsigned .

Conversion of an integral to Examples : int to double , unsigned long to float The number is converted to an exponential and the value retained .
When converting from long or unsigned long to float , some rounding may occur .

Conversion of to larger Examples : float to double , double to long double The value is retained during this conversion .

IMPLICIT TYPE CONVERSIONS IN ASSIGNMENTS Arithmetic types can also be mixed in assignments .
The compiler adjusts the of the value on the right of the assignment operator to match the of the variable on the left .

In the case of compound assignments , calculations using normal arithmetic conversions are performed first before conversion is performed following the rule for simple assignments .

Two different cases can occur during conversion in assignments :
If the of the variable is larger than the of the value to be assigned , the of the value must be promoted .
The rules for usual arithmetic conversions are applied in this case Example .

If the of the value to be assigned is larger , this must be " The following procedures are followed depending on individual circumstances :

Conversion of an integral to smaller  the is converted to smaller by removing the most significant .
The bit pattern that remains will be interpreted as unsigned , if the new is also unsigned , and as signed in all other cases .
The value can only be retained if it can be represented by the new Example .

Conversion of to an integral The decimal part of the number is removed .
For example , converts to the integer .
Rounding can be achieved by adding to positive number or subtracting from negative number .
This would allow for converting + to .

If the resulting integer is too large or too small for the new  the result is unpredictable .
This particularly applies to converting negative floatingpoint numbers to unsigned integers Example .

Conversion of to smaller If the number falls within the range of the new  the value will be retained , although the accuracy may be compromised .
If the value is too large to be represented by the new  the result is unpredictable Example .

The function has two parameters belonging to the short and double types .

However , the function is called using two int arguments .
This leads to implicit conversion of the value of to short and the integer to double .

When an int is converted to short the compiler issues warning , since some data loss may occur .
You can use explicit conversion to avoid warnings during conversion .

Syntax : expression This converts the value of an expression to the given .
Explicit conversion is also known as casting .

The cast operator is unary operator and thus has higher precedence than the arithmetic operators .

Example : int , double  In this example the value of is explicitly converted to double .
Following the conventions of usual implicit conversion , is also converted to double and floatingpoint division is performed .
The exact result , is assigned to the variable .

Without casting , an integer division with result of would have occurred .

has additional operators explicit cast operator , example .
These operators , which are described in later chapters , are required special circumstances , example , to perform checking at runtime when converting classes .

Plot one point of the curve in columns , leads to step value of for .

Use the following extended ASCII code characters to draw the axes : Example : up arrowhead NOTE Character Decimal Octal + Exercise function has the following prototype void unsigned int ; What happens when the function is called with as an argument .

Exercise How often is the following loop executed .

Exercise What is output when the program opposite is executed .

Exercise Write program to output the sine curve on screen as in the graphic shown on the opposite page .

The pattern of is interpreted as unsigned , which yields the greatest unsigned value .

On system , has the bit pattern , which , when interpreted as unsigned , corresponds to the decimal value .

Exercise The statement within the loop is not executed at all .
In the expression the value of variable  is implicitly converted to unsigned int and thus it represents the greatest unsigned value Exercise .

Exercise The screen output of the program : fffe : fffe : fffffffe : Exercise .

Besides defining strings we will also look at the various methods of string inserting and erasing , searching and replacing , comparing , and concatenating strings .

Initializing string ; Sample program Objects of class string do not necessarily contain the string terminating character , as the case with .

During string operations the required memory space automatically reserved or modified .
The programmer does not need to concern himself or herself with internal memory allocation .

The string class defined in the string header file and was mentioned in Chapter as an example for the use of classes .
Several operators are overloaded for  that  they were also defined for the string class .
This allows for easy copying , concatenation , and comparison .
Additionally , various methods for string manipulation such as insertion , erasing , searching , and replacing are available .

If string not initialized explicitly , an empty string with length of created .

The length of string , that  the current number of characters in the string , stored internally and can be accessed using the method or its equivalent .

Example : string ; Output : String Assignments When you assign value to string , the current contents are replaced by new character sequence .
You can assign the following to string object : another string string constant or single character .

The memory space required adjusted automatically .

The program on the opposite page uses the function , which was introduced in an earlier chapter , to store of from the keyboard in string .
In contrast , the operator reads only one word , ignoring any leading white space .
In both cases the original content of the string lost .

Example : string ; string they go , and ;

What will be done Function block .

Chapter , Defining Classes , describes the steps for defining member functions .

This makes the program easier to understand , since you start reading at the point where the program starts to execute .

The function is shown opposite as an example and followed by the general form of function .
The example can be read as follows : type is the function type , that is , the type of the return value .

The list can be empty , as for the function , for example .
list of declarations that contains only the word void is equivalent to an empty list .

The parameters declared in list are no more than local variables .
They are created when the function is called and initialized by the values of the arguments .

Example : When , is called , the parameter is initialized with value of and with .

The left curved bracket indicates the start of function block , which contains the statements defining what the function does .

The only difference when function is defined is that the name and declaration list are not followed by semicolon but by function code block .

The prototype is the declaration of the function and thus describes only the formal interface of that function .
This means you can omit parameter names from the prototype , whereas compiling function definition will produce machine code .

Stack further local objects return address first parameter last parameter .

Of course the called function cannot change the values of the arguments in the calling function , as it uses copies of the arguments .

However , function arguments can also be passed by reference .
In this case , the function passed reference to an object as an argument and can therefore access the object directly and modify it .

An example of passing by reference was provided in the example containing the function .
When ; called , the address of the variable sek passed as an argument , allowing the function to store the result in the variable .
We will see how to create functions of this type later .

Passing by value does , however , offer some important advantages : function arguments can be any kind of expression , even constants , for example the called function cannot cause accidental modifications of the arguments in the calling function the parameters are available as suitable variables within the functions .
Additional indirect memory access unnecessary .

However , the fact that copying larger objects difficult can be major disadvantage , and for this reason vectors are passed by reference to their starting address .

That  they are valid within the function only and not related to any objects or parameters of the same name in any other functions .

For example , the program structure opposite contains variable in the function and in the function .
The variables do not collide because they reference different memory addresses .
This also applies to the variables in and .

local objects are placed on the parameters of the function are placed first and in reverse order .
The stack an area of memory that managed according to the LIFO in first principle .
stack of plates good analogy .
The last plate you put on the stack has to be taken off first .
The LIFO principle ensures that the last local object to be created is destroyed first .

Copy The executable file only contains one instance of the machine code .

The part of the stack occupied by the function is then released .

All this jumping back and forth can affect the run time of your program , especially if the function contains only few instructions and is called quite often .
The time taken to branch to small function can be greater than the time needed to execute the function itself .
However , you can define inline functions to avoid this problem .

The definition of an inline function is introduced by the inline keyword in the function header .

Example : return .
This is why inline functions should contain no more than one or two instructions .
If an inline function contains too many instructions , the compiler may ignore the inline keyword and issue warning .

An inline function must be defined in the source file in which it is called .
You cannot simply supply prototype of the function .
The code containing the instructions must also be available to the compiler .
It therefore makes sense to define inline functions in header files , in contrast to " functions .

When macro is called , the preprocessor simply replaces block of text .
In contrast , an inline function behaves like normal function , although the program flow is not interrupted by the function branching .
The compiler performs type check , for example .

function defined with default arguments is always called with the full number of arguments .
For reasons of efficiency it may be useful to define several versions of the same function .

This allows you to omit some arguments when calling the function .
The compiler simply uses the default values for any missing arguments .

In other words , you need to supply them when you declare the function .

Example : void , Parameter names can be omitted , as usual .

Example : void , The function can then be called with or without one or two arguments .

Example : moveTo ; moveTo ; The first two calls are equivalent to ; or .

It is also possible to define default arguments for only some of the parameters .
The following general rules apply : the default arguments are defined in the function prototype .
They can also be supplied when the function is defined , if the definition occurs in the same source file and before the function is called if you define default argument for parameter , all following parameters must have default arguments default arguments must not be redefined within the prototype scope next chapter gives more details on this .

You can use default arguments to call function with different number of arguments without having to write new of the function .

This page intentionally left blank Storage Classes and Namespaces This chapter begins by describing storage classes for objects and storage class responsible for defining those parts of program where an object or function can be used .
Namespaces can be used to avoid conflicts when naming global identifiers .

The following storage class specifiers can be used extern static auto register STORAGE CLASSES OF OBJECTS When an object declared , not only are the type and name defined but also its storage class .
The storage class specifies the lifetime of the object , that  the period of time from the construction of the object until its destruction .
In addition , the storage class delimits the part of the program in which the object can be accessed directly by its name , the object scope .

Essentially , an object only available after you have declared it within translation unit .
translation unit , also referred to as module , comprises the source file you are compiling and any files you have included .

As programmer , you can define an object  block scope The object only available in the code block in which it was defined .
The object no longer visible once you have left the code block .

Only the functions within this module can reference the object .
Other modules cannot access the object directly .

For this reason , these objects are often referred to as global .

Access to an object as defined by the storage class independent of any access controls for the elements of class .
Namespaces that subdivide program scope and classes will be introduced at later stage .

Such objects can only be accessed by statements within that block and are called local to that block .
The memory used for these objects freed after leaving the code block .
In this case , the lifetime of the objects said to be automatic .

However , it possible to define objects block scope that are available throughout the runtime of program .
The lifetime of these objects said to be static .
When the program flow code block , any conditions will apply .

Objects program and file scope are always static .
These objects are created when program is launched and are available until the program is terminated .

Four storage classes are available for creating objects the scope and lifetime you need .
These storage classes will be discussed individually in the following sections .

Objects in this storage class have program scope and can be read and , provided they have not been defined as const , modified at any place in the program .
External objects thus allow you to exchange information between any functions without passing any arguments .
To demonstrate this point , the program on the opposite page has been divided into two separate source files .
The string  which has global definition , is used to exchange data .

Global objects that are not explicitly initialized during definition receive an initial value of is , all by default .
This also applies to objects belonging to class types , if not otherwise stipulated by the class .

If you need to use an object before defining it or in another module , you must first declare the object .
If you do not declare the object , the compiler issues message stating that the object is unknown .
The declaration makes the name and type of the object known to the compiler .

In contrast to definition , the storage class identifier extern precedes the object name in declaration .

Example : extern long position ; Declaration This statement declares position as an external object of type long .
The extern declaration thus allows you to " an object from another source file .

global object must be defined once , and once only , in program .
However , it can be declared as often as needed and at any position in the program .
You will normally declare the object before the first function in source file or in header file that you can when needed .
This makes the object available to any functions in the file .

Remember , if you declare the object within code block , the object can only be used within the same block .

An extern declaration only refers to an object and should therefore not be used to initialize the object .
If you do initialize the object , you are defining that object .

Global objects affect the whole program and should be used sparingly .
Large programs in particular should contain no more than few central objects defined as extern .

Example : static int  The most important characteristic of static objects is their static lifetime .

Static objects are not placed on the stack , but are stored in the data area of program just like external objects .

However , in contrast to external objects , access to static objects is restricted .
Two conditions apply , depending on where the object is defined :
Definition external to all program functions In this case , the object is external static , that is , the object can be designated using its name within the module only , but will not collide with any objects using the same name in other modules .

Definition within code block This means that the object is internal static , that is , the object is only visible within single block .
However , the object is created only once and is not destroyed on leaving the block .
On the block , you can continue to work with the original object .

The same rules apply to initializing static objects as they do to external objects .
If the object is not initialized explicitly , default value of applies .

Permission is refused following three unsuccessful attempts or when seconds have elapsed .
You could use the following instructions to call the function in another source file : Example : The string and the thresholds and are external static , whereas the variable in the function is internal static .
Its value is zero only when the function is first called .

It makes sense to add further function to these source files providing for changes .

White spaces and sign can precede the sequence of digits .

The parameters of function are also auto objects .

You can use the auto keyword during definition .

Example : auto float radius ; Equivalent to : float radius ; When the program flow reaches the definition , the object is created on the stack , but in contrast to static type object , the object is destroyed on leaving the block .

However , objects belonging to class type are normally initialized with default values , which can be specified in the class definition .

In this case , the register keyword is used to declare the object .

register is normally the size of an int variable .
In other words , it only makes sense to define register variables if the variable is not too large , as in the case of types such as char , short , int or pointers .
If you omit the type when defining register variable , an int is assumed .

However , the compiler can ignore the register keyword .
The number of registers available for register variables depends on your hardware , although two registers are normally available .
If program defines too many register variables in code block , the superfluous variables are placed in the auto storage class .

This is useful if you need to perform calculations with contained in string .

The algorithm using the string " and the long variable  Step : Step : + Step : + This pattern is followed for every in longer string .

Functions with block scope are invalid : you cannot define function within another function .

The storage class of function defines access to the function , as it does for an object .

External functions have program scope , whereas static functions have file scope .

In similar manner to external objects , external functions can be used at any position in program .
If you need to call function before defining it , or in another source file , you will need to declare that function .

Example : extern bool ; Prototype As previously seen , you can omit the extern keyword , since functions belong to the extern storage class by default .

They can only be called in the source file that defines them .
The name of static function will not collide with objects and functions of the same name in other modules .

If you need to call static function before defining it , you must first declare the function in the source file .

Example : static long void ; The program structure opposite takes up the example with the functions and once more .
The function is an auxiliary function and not designed to be called externally .
The function is declared as static for this reason .

provides for the use of namespaces in order to avoid naming conflicts with global identifiers .
Within namespace , you can use identifiers without needing to check whether they have been defined previously in an area outside of the namespace .
Thus , the global scope is subdivided into isolated parts .

normal namespace is identified by name preceded by the namespace keyword .

The elements that belong to the namespace are then declared within braces .

Example : namespace myLib .

Elements belonging to namespace can be referenced directly by name within the namespace .
If you need to reference an element from outside of the namespace , you must additionally supply the namespace .
To do so , place the scope resolution operator , before the element name .

Example : Outside of myLib This allows you to distinguish between identical names in different namespaces .
You can also use the scope resolution operator : to reference global names , that is , names declared outside of any namespaces .
To do so , simply omit the name of the namespace .

This technique is useful when you need to access global name that is hidden by an identical name defined in the current namespace .

Example : Not belonging to any namespace Be aware of the following when using namespaces : namespaces do not need to be defined contiguously .
You can reopen and expand namespace you defined previously at any point in the program namespaces can be nested , that is , you can define namespace within another namespace .

Global identifiers belonging to the standard library automatically belong to the standard namespace std .

In this case , you do not need to repeatedly quote the namespace .
Just like normal declarations , using declarations and using directives can occur at any part of the program .

Example : using ; Declaration You can then call the function from the myLib namespace .

Example : using namespace myLib ; This statement allows you to reference the identifiers in the myLib namespace directly .

If myLib contains an additional namespace and using directive , this namespace is also imported .

If identical identifiers occur in the current namespace and an imported namespace , the using directive does not automatically result in conflict .
However , referencing an identifier can lead to ambiguities .
In this case , you should use the scope resolution operator to resolve the situation .

header files without file extensions are used to declare the global identifiers in the standard namespace std .
The using directive was used in previous examples to import any required identifiers to the global scope : Example : using namespace std ; When developing programs or libraries , it is useful to declare the elements of any proprietary namespaces in header files .
Normal source files are used to define these elements .

However , if you define name for an within code block and the name is also valid for another  you will reference only the new within the code block .

The new hides any using the same name outside of the block .

When you leave the code block , the original once more becomes visible .

The program on the opposite page uses identical variable names in different does the program output on screen .

Exercise You are developing program and intend to use two commercial libraries , and names of types , functions , macros , and so on are declared in the header files and for users of these libraries .

Unfortunately , the libraries use the same global names in part .
In order to use both libraries , you will need to define namespaces .

Write the following program to simulate this situation : Define an inline function called that returns the sum of two numbers for the header file function interface is as follows : double , double ; Define an inline function called that returns the product of two numbers for second header file function has the same interface as the function in .

To resolve potential naming conflicts , define the namespaces and that the relevant header files .

It is syntactically simpler to use references , although not always permissible .

parameter of reference type is an alias for an argument .
When function is called , reference parameter is initialized with the object supplied as an argument .
The function can thus directly manipulate the argument passed to it .

Example : void ; Based on this definition , the statement ; For an int variable var increments the variable var .
Within the function , any access to the reference automatically accesses the supplied variable , var .

If an object is passed as an argument when passing by reference , the object is not copied .
Instead , the address of the object is passed to the function internally , allowing the function to access the object with which it was called .

The argument must have an address in memory and be of the correct type .

Using references as parameters offers the following benefits : arguments are not copied .
In contrast to passing by value , the run time of program should improve , especially if the arguments occupy large amounts of memory function can use the reference parameter to return multiple values to the calling function .
Passing by value allows only one result as return value , unless you resort to using global variables .

If you need to read arguments , but not copy them , you can define reference as parameter .

Example : void const ; The function contains as an argument .
However , it does not generate new to which the argument is copied .
Instead , is simply reference to the argument .
The caller can rest assured that the argument is not modified within the function , as is declared as const .

The function call then represents an object , and can be used just like an object .

This function returns reference to static .
Pay attention to the following point when returning references and pointers : The object referenced by the return value must exist after leaving the function .

It would be critical error to declare the as normal auto variable in the function .
This would destroy the on leaving the function and the reference would point to an object that no longer existed .

Then new is appended before the length of the referenced is output in the third statement .

If you want to avoid modifying the referenced object , you can define the function type as reference .

Example : const ;

References are commonly used as return types when overloading operators .
The operations that an operator has to perform for type are always implemented by an appropriate function .
Refer to the chapters on overloading operators later in this book for more details .
However , examples with operators from standard classes can be provided at this point .

Example : Operator of class ostream  Sample assignments of class EXPRESSIONS WITH REFERENCE TYPE Every expression belongs to certain type and also has  if the type is not void .
Reference types are also valid for expressions .

Example : This expression is not void type but reference to the object  that is , it represents the object .
This allows you to repeatedly use the on the expression :  The expression is then equivalent to  Good ' Expressions using the are composed from left to right , you can see from the table of precedence contained in the appendix .

Similarly , the expression cin variable represents the stream cin .
This allows repeated use of the .

Example : int  double  cin   Other Reference Type Operators Other commonly used reference type operators the simple assignment compound assignments , such .
These operators return reference to the operand on the left .
In an expression such or must therefore be an object .
In turn , the expression itself represents the object .
This also applies when the operators refer to objects belonging to class types .
However , the class definition stipulates the available operators .
For example , the assignment operators are available in the standard class .

Example : to Since an expression of this type represents an object , the expression can be passed an argument to function that is called by reference .
This point is illustrated by the example on the opposite page .

Linked lists or trees whose elements are generated dynamically at runtime are typical examples .

Using the address  for given object creates pointer to that object .
Given that is an int variable , Example : Address of the object is the address of the int object in memory thus pointer to .
pointer points to memory address simultaneously indicates by its type how the memory address can be read or written to .
Thus , depending on the type , we refer to pointers to char , pointers to int , so on , or use an abbreviation , such char pointer , int pointer , so on .

Example : int ; or :  This statement defines the variable  which is an type other words , pointer to .
In declaration , the star char Pointer types are derived types .
The general form is , where can be any given type .

In the above example is an int type .

Objects of the same base type can be declared together .

Example : int   Definition of  After declaring pointer variable , you must point the pointer at address .
The program on the opposite page does this using the statement .

However , pointer is not merely an alias but an individual object that has an identity separate from the object it references .
pointer has its own address can be manipulated by pointing it at new address thus referencing different object .

That is , it occupies as much space as is necessary to store an address .
On computer , such as PC , this is four bytes .

This allows for efficient storage management and the swapping of currently unused blocks to the hard disk .

Thus , the special value is used to indicate an error .
For pointers , the symbolic constant NULL is defined as in standard header files .
pointer containing the value NULL is also called NULL pointer .

THE INDIRECTION OPERATOR Using Pointers to Access Objects The indirection operator is used to access an object referenced by pointer : Given pointer ,  is the object referenced by .

As programmer , you must always distinguish between the pointer and the addressed object .

This assigns the value of to  since points to .
The assignment  would return the same result .
The expression represents the object  and can be used wherever could be used .

The star character used for defining pointer variables is not an operator but merely imitates the later use of the pointer in expressions .
Thus , the definition long ; has following meaning : is to type and is long type .

The indirection operator has high precedence , just like address operator .
Both operators are unary , that is , they have only one operand .
This also helps distinguish redirection operator from binary multiplication operator , which always takes two operands .

The term occurs commonly in compiler error messages and is derived from assignment .
The left operand of operator must always designate address .

Expressions other than an are often referred to as .

variable name is simplest example of an .
However , constant or an expression , such as + is an .
The indirection operator is one example of an operator that yields .
Given pointer variable , both and are , as designates object to which points .

POINTERS AS PARAMETERS Objects as Arguments If an object is passed as an argument to function , two possible situations occur : parameter in question is same type as object passed to it .
The func parameter in question is reference .
The parameter is then an alias for argument , that is , function that is called manipulates object passed by calling function by .

In first case , argument passed to function cannot be manipulated by function .
This is not true for passing by reference .
However , there is third way of passing by pointers to function .

The answer is quite simple : The parameter must be declared as pointer variable .

If , for example , function requires address of an int value as an argument , you can use following statement .

If function knows address of an object , it can of course use indirection operator to access and manipulate object .

In program on opposite page , function swaps values of variables and in calling function .
The function is able to access variables since addresses of these variables , that is and , are passed to it as arguments .

The parameters and in are thus declared as float pointers .
The statement , initializes pointers and with addresses of or .
When function manipulates expressions and , it really accesses variables and in calling function and exchanges their values .

Test values Quadratic Equation Solutions , + + none EXERCISES Given circle with radius : and where NOTE Exercise What happens if parameter in sample function is declared as instead of string .

Exercise Write void type function called calculate and area of radius and two variables are passed to function , which therefore has three parameters : Parameters : reference to double for radius and two references to double that function uses to store area and of circle .

Test the function by outputting table containing the radius , the  and the area for the radii ,

Exercise .

The version of the function opposite can be compiled without producing any error messages .
However , the function will not swap the values of and when ; is is wrong .

Test the correct pointer version of the function found in this write and test version of the function that uses references instead of pointers .

Exercise Create function that calculates the solutions to quadratic formula for calculating quadratic equations is shown opposite .

Arguments : The coefficients , and two pointers to both solutions .

Returns : false , if no real solution is available , otherwise true .

Test the function by outputting the quadratic equations on the opposite page and their solutions .

But instead of passing by reference , passing by value occurs , the function manipulates local copy .

Thus , only local copy of the string is changed in the function , but the string in the calling function remains unchanged .

This page intentionally left blank Defining Classes This chapter describes how classes are defined and how instances of classes , that is , objects , are used .
In addition , structs and unions are introduced as examples of special classes .

Properties : Date when .

Methods : to run , to brake , to park , to turn off .

class defines the properties and capacities of an object .

Objects and processes are reduced to basics and referred to in generic terms .
Classes allow more direct use of the results of this type of abstraction in software development .

The first towards solving problem is analysis .
In programming , analysis comprises identifying and describing objects and recognizing their mutual relationships .
Object descriptions are the building blocks of classes .

In , class is type .
It contains data members , which describe the properties of the class , and member functions , or methods , which describe the capacities of the objects .
Classes are simply patterns used to instantiate , or create , objects of the class type .
In other words , an object is variable of given class .

An application program accesses objects by using the public methods of the class and thus activating its capacities .

Access to object data is rarely direct , that is , object data is normally declared as private and then read or modified by methods with public declarations to ensure correct access to the data .

One important aspect of this technique is the fact that application programs need not be aware of the internal structure of the data .
If needed , the internal structure of the program data can even be modified .
Provided that the interfaces of the public methods remain unchanged , changes like these will not affect the application program .
This allows you to enhance an application by programming an improved class version without changing single byte of the application .

An object is thus seen to encapsulate its private structure , protecting itself from external influences and managing itself by its own methods .
This describes the concept of data encapsulation concisely .

The definition begins with the keyword class followed by the class name .
The data members and methods are then declared in the subsequent code block .
Data members and member functions can belong to any valid type , even to another previously defined class .
At the same time , the class members are divided into : private members , which cannot be accessed externally public members , which are available for external access .

The public members form the public interface of the class .

The opposite page shows schematic definition of class .
The private section generally contains data members and the public section contains the access methods for the data .
This provides for data encapsulation .

The following example includes class named Account used to represent bank account .
The data members , such as the name of the account holder , the account  and the account balance , are declared as private .
In addition , there are two public methods , for initialization purposes and , which is used to display the data on screen .

The labels private : and public : can be used at the discretion within class : you can use the labels as often as needed , or not at all , and in any order .
section marked as private : or public : is valid until the next public : or private : label occurs the default value for member access is private .
If you omit both the private and public labels , all the class members are assumed to be private .

These rules often reflect the target platform and the class libraries used .
For the purposes of this book , we decided to keep to standard naming conventions for distinguishing classes and class members .
Class names begin with an uppercase letter and member names with lowercase letter .

Members of different classes can share the same name .
member of another class could therefore also be named .

Only then can the objects of the class be used .

Within method , all the members of class can be designated directly using their names .
The class membership is automatically assumed .
In particular , methods belonging to the same class can call each other directly .

Access to private members is only possible within methods belonging to the same class .
Thus , private members are completely controlled by the class .

Defining class does not automatically allocate memory for the data members of that class .
To allocate memory , you must define an object .
When method is called for given object , the method can then manipulate the data of this object .

In this case , you will need to place the class definition in header file .
If you place the definition of the class Account in the file , any source file including the header file can use the class Account .

Methods must always be defined within source file .
This would mean defining the methods for the class Account in source file named , for example .

The source code of the application program , for example , the code containing the function main , is independent of the class and can be stored in separate source files .
Separating classes from application programs facilitates of classes .

In an integrated development environment , programmer will define project to help manage the various program modules by inserting all the source files into the project .

When the project is compiled and linked , modified source files are automatically and linked to the application program .

You can assign this address to suitable pointer .

Example : This defines the object savings and pointer variable called .
The pointer is initialized so that it points to the object savings .
This makes the object savings itself .
You can then use the statement Example : to call the method for the object savings .
Parentheses must be used in this case , as the .

Syntax : This expression is equivalent to The arrow_operator is made up of minus sign and the greater than sign .

Example : This statement calls the method for the object referenced by  that is , for the object savings .
The statement is equivalent to the statement in the previous example .

The difference between the class member access operators .

function that gets the address of an object as an argument can manipulate the referenced object directly .
The to read the data for new .
When called , the address of the is passed : The function can then use the pointer and the method to write new data to the referenced object .

Extensive data such as the data for the articles in an automobile stocks can be organized for ease of viewing and stored in files .

From the viewpoint of an language , record is merely class containing only public data members and no methods .
Thus , you can use the class keyword to define the structure of record in .

Example : class Date public : short month , day , year ; However , it is common practice to use the keyword struct , which is also available in the programming language , to define records .
The above definition of Date with the members day , month , and year is thus equivalent to : Example : struct Date short month , day , year ; The Keywords class and struct You can also use the keyword struct to define class , such as the class .

The keywords class and struct only vary with respect to data encapsulation ; the default for access to members of class defined as struct is public .
In contrast to class defined using the class keyword , all the class members are public unless private label is used .
This allows the programmer to retain compatibility .

Example : future ; future .
Public data Records in the true sense of the word , that is , objects of class containing only public members , can be initialized by means of list during definition .

Example : The first element in the list initializes the first data member of the object , and so on .

However , union is class whose members are stored in the same memory space .

Each data member has the same starting address in memory .
Of course , union cannot store various data members at the same address simultaneously .
However , union does provide for more versatile usage of memory space .

Example : union Number .

This example defines the union Number and two objects of the same type .
The union Number can be used to store either integral or numbers .

Unless private label is used , all union members are assumed to be public .
This is similar to the default setting for structures .
This allows direct access to the members and in the union Number .

This is normally achieved using an additional type field that identifies the current content .

The size of union type object is derived from the longest data member , as all data members begin at the same memory address .
If we look at our example , the union Number , this size is defined by the double member , which defaults to .

The example opposite defines the union WordByte that allows you to read or write to memory space for or as unit .

The method outputs the date to standard output using the format .

The method uses three parameters and copies the values passed to it to corresponding range check is not required at this stage , but will be added later .

The method without parameters writes the current date to the corresponding members .

The structure and sample calls to this function are included type is defined as long in ctime .

The function returns the system time expressed as number of seconds and writes this value to the variable referenced by ptrSec .
This value can be passed to the function that converts the number of seconds to the local type date and returns pointer to this structure .

Use object assignments an additional and pointers to objects .

: Defining destructor .

The tasks involved in cleaning up releasing memory and closing files .

Objects are cleaned up by special method called destructor , whose is made up of class preceded by .

Neither does it have any parameters , which makes destructor impossible to overload .
Each class thus has one destructor only .

If class does not define destructor , compiler will create minimal version of destructor as public member , called default destructor .

It is important to define destructor if certain actions performed by constructor need to be undone .
If constructor opened file , for example , destructor should close that file .
The destructor in Account class has no specific tasks to perform .
The explicit definition is thus : Nothing to do The individual data members of an object are always removed in order opposite of order in which they were created .
The first data member to be created is therefore cleaned up last .
If data member is also class type object , own destructor will be called .

The sample program on opposite page illustrates various implicit calls to constructors and destructors .

This is only way to ensure data encapsulation and class functionality .

However , continually calling " methods can impact runtime .
In fact , saving address and jumping to called function and back into calling function can take more time than executing function itself .
To avoid this overhead , you can define inline methods in way similar to defining inline global functions .

In first case , method is declared within the class , just like any other method .
You simply need to place the inline keyword before the method in the function header when defining the method .

Short methods can be defined within the class .
Methods of this type are known as implicit inline methods , although the inline keyword is not used .

Example : Within class Account : bool return ; Constructors and Destructors with inline Definitions Constructors and destructors are special methods belonging to class and , as such , can be defined as inline .
This point is illustrated by the new of the Account class opposite .
The constructor and the destructor are both implicit inline .
The constructor has default value for each argument , which means that we also have default constructor .
You can now define objects without supplying an initialization list .

Example : temp ; Although we did not explicitly supply values here , the object temp was correctly initialized by the default constructor we defined .

To allow access to this data , you could place the data members in the public section of the class ; however , this would undermine any attempt at data encapsulation .

Access methods offer far more useful way of accessing the private data members .

Access methods allow data to be read and manipulated in controlled manner .
If the access methods were defined as inline , access is just as efficient as direct access to the public members .

In the example opposite , several access methods have been added to the class .
You can now use the methods to read the individual data members .
As is illustrated in , references should be when used as return values .
Direct access for write operations could be possible otherwise .
To manipulate data members , the following methods can be used :

This allows you to define new  as follows : Example : Access Method Benefits Defining access methods for reading and writing to each member may seem like lot of that typing , reams of source code , and the programmer has to remember the names and tasks performed by all those methods .

So , you may be asking yourself how you benefit from using access methods .
There are two important issues : Access methods can prevent invalid access attempts at the onset by performing sanity checks .
If class contains member designed to represent positive numbers only , an access method can prevent processing negative numbers .

It is therefore possible to modify the internal structure of your at later stage .
If you detect that new structure will allow more efficient handling , you can add this modification to new of the class .
Provided the public interface to the class remains unchanged , an application program can be leveraged by the modification without needing to modify the application itself .
You simply recompile the application program .

As mentioned earlier , the object must be initialized when you define it for this reason .

Example : const , The object inv cannot be modified at later stage .
This also means that methods such as cannot be called for this object .
However , methods such as getName or will be similarly unavailable although they only perform read access with the members .

The reason for this is that the compiler cannot decide whether method performs write operations or only read operations with members unless additional information is supplied .

To identify method as , append the const keyword in the method declaration and in the function header for the method .

Example : unsigned long const ; This declares the method as method that can be used for constant objects .

Example :    Of course , this does not prevent you from calling method for object .

The compiler issues an error message if method tries to modify member .
This also occurs when method calls another method that is not defined as const .

In addition , this chapter describes constant members and enumerated types .

However , in the case of the class there is nothing to do at present .

Correct values are assigned later .
This additional action can impact your performance .

When defining constructor , you can use member initializers to ensure general and efficient use of member objects .

Example : Member initializer Multiple member initializers are separated by commas .
list of member initializers defined in this way follows the constructor header and is separated from the header by colon .

Example : Function block This ensures that suitable constructor will be called for data members with member initializers and avoids calls to the default constructor with subsequent assignments .
As the example shows , you can also use member initializers for data members belonging to fundamental types .

The argument names of the member initializers are normally constructor parameters .

This helps pass the values used to create an object to the right member object .

Member initializers can only be stated in constructor definition .
The constructor declaration remains unchanged .

For example , you could set the for measurement once and not change this time subsequently .
However , you need to be able to edit the measurement value to correct systematic errors .
In this case , the member object time can be declared as follows : Example : const  Since the const member object cannot be modified by later assignment , the correct constructor must be called to initialize the object .
In other words , when you define constructor for  you must also define member initializer for each const member object .

Example : mn , Error .

However , the later versions of these constructors are ok .
The member initializer ensures that the desired initial values are used to create the member object .

The compiler will issue an error message at this point and for any statement in the current program that attempts to modify the static member , This means that programmer cannot accidentally overwrite member declared as const .

The new of the Result no longer contains default constructor , since default value for the of the measurement does not make sense .

The Client contains number , nr , which is used to identify customers .
Since the client number never changes , it makes sense to define the number as const .
The constructor for Client would then read as follows : Example : The member initializer initializes the const data member nr with the global value id , which is incremented prior to use .

This means that the data members of two different objects will be stored at different memory addresses .

However , sometimes it is useful to keep some common data that can be accessed by all the objects belonging to  for example : figures such as exchange rates , interest rates or limits which have the same value for every object status information , such as the number of objects , current minimum or maximum threshold values , or pointers to some objects ; for example , pointer to an active window in window .

This kind of data needs to be stored once only , no matter how many objects exist .

Since programmer will also need to manage the data from within the  it should be represented within the rather than globally .
Static data members can be used for this purpose .
In contrast to normal data members , static data members occur only once in memory .

On the opposite page , the following statement Example : static double   Declaration defines two static data members called and that record the minimum and maximum values for the measurements .

Just like member functions , which occur only once , static data members must be defined and initialized in an external source file .
The range operator : is then used to relate the data members to the .

Example : double : Definition As the example illustrates , the static keyword is not used during the definition .
Static data members and member functions belonging to the same are normally defined in one source file .

An enumeration is defined using the enum keyword .
range of values and name for these values are also defined at the same time .

Example : enum Line , Rectangle , This statement defines the enumerated type .
The names quoted in the list identify integral constants .
Their values can be deduced from the list order .
The first constant has value of , and each subsequent constant has value that is one higher than its predecessor .

In the previous example , Line thus represents value of , Rectangle value of , and Ellipse value of .
type variable can only assume one of these values .

Example : enum , You can leave out the type name , if you only need to define the constants .

Example : enum   This statement defines the constants and  setting their value to , and the constants and with value of .
The values for and are implicit .

In contrast to directives , which merely replace text strings , enum constants are part of declaration and thus have valid range .
This allows you to define constants that are visible within namespace or only .

The example on the opposite page shows the enumerated type  which was defined within the .
This means that the type and enum constant are only available for direct use within the .
The enumeration itself is declared public , however , and access from outside the is therefore possible .

The Member Class int string const Date Member Number Name Birthday more information , such an address , telephone number ,

Constructor with one parameter for each data member Access methods for each data member .
The birthday is .

method for formatted screen output of all data members Private Data Members Public Methods Type EXERCISES Exercise In the first exercise of the last chapter you defined simple class called involved using global counter to log object creation and destruction .
Improve and extend the Article class follows : Use static data member instead of global variable to count the current number of objects .

The method returns the current number of objects .

Tip : Use member initializers .

Exercise sports club needs program to manage its task is to define and test class called for this purpose .

Use the Date class defined in the last chapter for your definition .
Since member ' birthday will not change , the data member for birthdays must be defined const .

Overload the constructor to allow for entering date an object well three values for day , month , and year .

If no has been appointed , the pointer should point to NULL .

Use pointer to set and return the object in question .

Terminate this program with .

Light AMBER GREEN AMBER AMBER RED GREEN AMBER RED AMBER GREEN .

Sample output .

The function is declared in the header file ctime .
The call determines the number of seconds of type since , type is defined as long .

Instead of calling the function in loop , you can use the function for Windows or the function for Unix .
These system calls are not standardized , yet they are much more effective because they send process to sleep instead of using waiting loop .

EXERCISES Exercise Create program to simulate the signal positions for two sets of traffic lights at junction .
Use the class Lights as defined in this chapter for your program .

For example , the green phase can take seconds and the amber phase values can be different for each set of lights .
Define an auxiliary function The function returns after the stipulated number of do so , you can call the standard function in loop .
forget to read the notes on the opposite page .

SOLUTIONS Exercise The Date class from the last chapter see files and can be left unchanged .
But it makes sense to define the function static member function of class Date rather than globally .

An array always occupies contiguous memory space .
In the case of the array arr , this space is bytes .

In an index always begins at zero .
The elements belonging to the array arr are thus , 

Any int expression can be used as an index .
The subscript operator has high precedence , just like the class member operators .

No error message is issued if the index exceeds the valid index range .
As programmer , you need to be particularly careful to avoid this error .
However , you can define class to perform range checking for indices .

You can create an array from any type with the exception of some special types , such as void and certain classes .
Class are discussed later .

Example : short ; short array ; This example defines an array called number with short elements and assigns the values ,

If you initialize an array when you define it , you do not need to state its length .

Example : int , In this case , the length of the array is equal to the number of initial values .
If the array length is explicitly stated in the definition and is larger than the number of initial values , any remaining array elements are set to zero .
If , in contrast , the number of initial values exceeds the array length , the surplus values are ignored .

Locally defined are created on the stack at program runtime .
You should therefore be aware of the following issues when defining  Arrays that occupy large amount of memory , more than one should be defined as global or static .

Values are normally assigned by means of loop .

You cannot assign vector to another vector .
However , you can overload the assignment operator within class designed to represent .
This topic will be discussed in depth later .

Fibonacci numbers are useful for representing natural growth .
In computer science , Fibonacci numbers are used for things like memory management and hashing .

Their definition is as follows : the first Fibonacci number is , the second is each subsequent Fibonacci number is the sum of its two immediate predecessors .

This results in the following sequence :

The quotient of Fibonacci number and its predecessor is referred to as Fibonacci quotient .
The sequence of Fibonacci quotients , converges towards the threshold value +

The array text has length of , whereas the string Eve " only occupies the first bytes .

Example : char ; Kbyte buffer However , their most common use is for string storage .
One way of representing string is to store the string and the terminating null character ' in char array .

When you define an array , you can use string constant to initialize the array .

Example : char ; This definition is equivalent to char ' As you can see , the string occupies five bytes , including an additional byte for the null character .
If you need to allocate more memory , you can state the size of the array explicitly as shown opposite .

In the language , strings are usually represented as char vectors with terminating null character .
In , strings of this type are referred to as strings to distinguish them from objects of the string class .

Thus , for example , assignments and comparisons are not defined .

Example : char , Error .

The standard functions of the language , such as , and others , are available for strings .
These global functions all begin with the prefix .

As the program on the opposite page shows , streams are overloaded for char arrays , too .
Input and output are as easily achieved as with string class objects .
However , the program must make sure not to overrun the end of the char array when reading data into the array .
You can use the method or the manipulator for this purpose .

Example : cin  characters strings are preferable to the string class if only few operations are needed and you want to avoid unnecessary overheads .

The array is known as class array in this case .
When you declare an array of this type , you only need to state the type of the array elements .

Example : Result ; This statement defines the class array that stores objects of type This class was introduced at the beginning of the last chapter .

As the statement does not initialize the array explicitly , the default constructor is automatically called for each array element .

Thus , the previous example is only valid for the first version of the class as this class contains default constructor .

The list contains constructor call for each array element .

The first five array elements are initialized by the constructor calls implicitly contained in these statements .
Instead of using constructor with one argument , you can simply supply the argument .
The default constructor is then called for the remaining elements .

If the size of an array is not stated explicitly , the number of values in the initialization list defines the size of the array .

The public interface of the objects in the array is available for use as usual .

Example : No additional parentheses are needed in this statement since the subscript operator and the class member operator .

Class can only be defined without explicit initialization if default constructor exists for the class .

The ANSI standard stipulates minimum of dimensions but the total of dimensions is in fact limited by the amount of memory available .

The most common multidimensional array type is the array , the socalled matrix .

Example : float ; matrix This defines matrix called that contains rows and columns .
Each of the elements is float type .
The assignment Example : Row , column stores the value in the last element of the first row .

On the contrary , an array is no different than an array with only one dimension whose elements are .

The array thus contains the following three elements :

Each of these elements is float array with size of , which in turn forms the rows of the .

This means that the same rules apply to multidimensional as to .
The initialization list of array thus contains the values of the array elements , that is , the rows .

Examples : int , int , These two definitions are equivalent .
When you initialize an array , you can only omit the size of the first dimension .
It is necessary to define any other dimensions since they define the size of array elements .

The rows are char used for storing the names of the representatives .
You can also use onedimensional string array .

Example : string ; Class to represent list containing names and telephone numbers .

class designed to perform this task can use an array for ease of data management .
An array allows you to access individual objects directly and perform searches .

class that encapsulates an array will provide methods for simple array operations , such as inserting and deleting objects .
When you design class of this type , one aim will be to perform automatic range checking .
This helps avoid overrunning the end of an array when performing read or write operations .
The resulting class will contain comfortable and safe interface for object data management .

Each entry in the list contains dataset containing name and phone .
The Element type , which comprises two strings , was defined for this purpose .
The array can store up to MAX entries of the Element type .
The data member records the of elements currently stored in the array .
When phone list is created , this will initially be .
When an element is inserted or deleted , the is modified correspondingly .

The class uses single default constructor that sets the counter ,  to zero .
It is not necessary to provide an initial value for the MAX elements in the array since the default constructor of the string class is executed for all strings .

The tasks performed by the other methods are easily deduced from their names .
The method returns to given index pointer to the corresponding element .

Using pointer makes it possible to return NULL pointer if the index is invalid .

The methods add new to the list .
The data passed to method is copied to the next free array element and the counter is incremented .
If there is no space available , the name field is empty , or the name is already in use , nothing happens .
In this case , the method returns false instead of true .

The exercises for this chapter contain further details on these methods .
You can implement the methods for the yourself and go on to test them .

The screen control characters make it possible to locate the cursor , and that independent of the current compiler .

Result : Screen shot of exercise EXERCISES Use the bubble sort algorithm to sort the array .
This algorithm repeatedly accesses the array , comparing neighboring array elements and swapping them if needed .
The sorting algorithm terminates when there are no more elements that need to be swapped .
You use flag to indicate that no elements have been swapped .

Input can be terminated by any invalid input , such as letter .

Exercise Chapter introduced the sample class DayTime and the method .

Define and initialize an array with four DayTime class objects .

Then write main function that first uses the method to display the four elements .
Finally , find the largest and smallest elements and output them on screen .

Exercise Write program that outputs all prime numbers less than program should also count the number of prime numbers less than .
Use the Sieve of Eratosthenes : To find primary numbers simply eliminate multiples of any primary numbers you have already found , first eliminate any multiples of ,

Exercise Write program to create the screen output shown following banner is to be displayed in the center of the window and scrolled can scroll the banner by beginning string output with the first character , then the second , and so on .
Handle the string like loop where the first letter follows the last letter and output continues until the starting position is reached .

You can use wait loop to modify the speed of the banner after each string is output .

This is just one of the enhancements would be variable that will be added at later stage .

The method deletes an array position of the element to be deleted is first located using the method .
If the element does not exist , returns value of false .
In any other case , the last element in the array is used to overwrite the element that is to be deleted and the counter count is decremented .

The method finds the position in the array that contains the search name .
If the search operation is unsuccessful , the value PSEUDO is returned .

The print method without parameters outputs all available can pass the first letter or letters of name to the second method to output any beginning with these letters .
Use the method from the string class to help you with this task .

Example : This expression is true if the five characters subsequent to position in the strings and are identical .

The method is used to read new list method .
Reading should be terminated if the user types an empty string .

The method returns the number of new .

Write an application program that creates list of type TelList and displays the menu shown on the opposite page .

Depending on the command input , one of the methods defined in is chosen , you must also read name or the first letters of name from the keyboard .

SOLUTIONS Exercise .

String access via the command line of an application program is used to illustrate pointer arrays .

However , just like the definition used for reference , you can also define pointer , that is , pointer that can be used for read operations only .
In fact , pointer is obligatory if you need to point to constant object .

Example : const int , This statement defines the constants and  and pointer to constant object of type int .
The referenced object can be read but not modified .

Example : To read is ok .

The pointer itself is not constant , so it can be modified : Example : ok .

The referenced object also does not need to be constant .
In other words , pointer can also point to object .

But can only be used for read access to the object depo .

This guarantees that arguments cannot be modified .

Example : int const char ; In this example , the parameter is pointer .
This allows you to pass constant .

Best wishes Yours Vivi Array in memory COMMAND LINE ARGUMENTS Arguments for Program When you launch program , you can use the command line to supply additional character sequences other than the program .
These command line arguments are typically used to govern how program is executed or to supply the data program will work with .

Example : copy In this case , the program copy is launched with the arguments and .
The individual arguments are separated by spaces .
Characters used for redirecting input and output or and following word are evaluated by the operating system and not passed to the program .
If an argument contains space or redirection characters , you must place it in double quotes .

So far we have only used the function without parameters .
However , if you intend to process command line arguments , you must define parameters for .

The program is one of these , so will have value of at least .

The parameter is an array of char pointers : points to the first real argument , that is , the word after the program points to the second argument .

Various operating systems , for example WINDOWS and UNIX , allow you to declare third parameter for .
This parameter is an array with pointers to environment strings .
The exercises for this chapter contain program that displays the program environment .

Original array : After the first loop : After the second loop : smallest element second smallest element EXERCISES For exercise Notes on exercise The selection sort algorithm Method First find the smallest element in the array and exchange it with the first element .

This procedure is repeated while for the remainder of an array containing array elements with an initial index of .

Example EXERCISES Exercise Given an array with the following definition : int ,  What screen output is caused by the following statements .

File streams provide simple and portable file handling techniques .

To store data permanently , you need to write that data to file on an external storage medium .

However , it is common practice to store records in files .
contains data that forms logical unit , such as the human resource information for person .
write operation stores in file , that is , the existing in the file is updated or new is added .
When you read  this is taken from the file and copied to the data structure of program .

Objects can be put into permanent storage using similar techniques .
However , this normally involves more than just storing an data .
You also need to ensure that the object can be correctly reconstructed when it is read , and this in turn involves storing type information and references to other objects .

External mass storage media , such as hard disks , are normally is , data is transferred in blocks whose size is multiple of bytes .
Efficient and easy file management thus implies putting the data you need to store into temporary storage in main memory , in file buffer .

The structure of the  using records for example , is entirely the responsibility , allowing for maximum degree of flexibility .

Every character in occupies byte position .
The first byte occupies position , the second byte position , and so on .
The current position is the position of the byte that will be read or written next .
Each byte that is transferred automatically increases the current position by .

In the case of sequential access , the is read or written byte by byte in fixed order .

The first read operation starts at the beginning of the .
If you need access to some piece of information in  you must read the content from start to finish .
Write operations can create new  overwrite an existing  or append new to an existing .

Easy access to given in implies being able to set the current position as required .
This technique is known as random access and will be discussed in one of the following chapters .

These stream classes allow for easy handling .
As programmer you will not need to concern yourself with buffer management or system specifics .

Since the stream classes have been standardized , you can use them to develop portable programs .
One program can thus process files on Windows NT or UNIX platform .
You simply need to recompile the program for each platform you use .

As you would expect , it supports both read and write operations for files .

The stream classes are declared in the fstream header .
An object that belongs to stream class is known as stream .

Thus , the methods , operators , and manipulators you have already used for cin and are also available here .
Thus every stream has : methods for writing and reading of single characters blocks the operators or for formatted reading and writing from or to files methods and manipulators for formatting character sequences methods for state queries .

File handling methods , particularly methods for opening and closing files , round off the package .

For example , you can stipulate the effect of the + operator for the objects of particular class .

This chapter describes various uses of overloaded operators .

Arithmetic operators , comparisons , the subscript  and the shift operators for input and output overloaded to illustrate the appropriate techniques .

The concept of friend functions , which is introduced in this context , is particularly important for overloading operators .

This meaning can be changed for classes by definition of your own .

The definition scope of an is simply characteristics of the remain unchanged .
The following rules apply : You cannot create is , you can only overload existing .

binary will always be binary and unary will always be unary .

In other words , overloading an means making the significant for .

Most are already overloaded for fundamental types .
In the case of the expression : Example : the operand determines the machine code created by the compiler for the division If both operands are integral types , an integral division is performed ; in all other cases division occurs .
Thus , different actions are performed depending on the operand types involved .

Thus , you can overload the + instead of , or in addition to , using the method .
For the objects and in this class : + Using the overloaded of class expressions of this can be as easily defined as for fundamental types .
Expressions using are often more intuitive , thus easier to understand than expressions containing function calls .

Many belonging to the standard library classes are already overloaded .

This applies to the string class , with which you are already familiar .

The tables on the opposite page show those that can be overloaded .
Some cannot be overloaded , such as the cast  the sizeof  the following four  member access scope resolution : conditional These either have fixed significance in the classes for which they are defined , or overloading the makes no sense .

The function describes the actions to be performed by the .
The name of an function must begin with the keyword followed by the symbol .

Example : + This is the name of the function for the +

An function can be defined as global function or as class method .
Generally , functions are defined as methods , especially in the case of unary operators .

However , it can make sense to define an function globally .
This point will be illustrated later .

The function is called for this object .
The  right operand is passed as an argument to the method .
The method thus has single parameter .

Example : bool const const ; In this case the lesser than is overloaded to compare two DayTime objects .
It replaces the method , which was formerly defined for this class .

The prefix has been overloaded in the example on the opposite page to illustrate overloading unary operators .
The corresponding function in this class has no parameters .
The function is called if the object in the expression is an object of class DayTime .

The expression is thus equivalent to Although somewhat uncommon , you can call an function explicitly .
The previous function call is therefore technically correct .

Programs that use operators are easier to encode read .
However , you should be aware of the fact that an function should perform similar operation to the corresponding for the fundamental .
Any other use can lead to confusion .

Class Notes on the Sample Class The opposite page shows the class , which represents the new currency .

The member stores given amount of euros as an integer in the format : + Cents .

Thus returns the number of euros the number of .
This technique allows for easy implementation of the arithmetic operations needed for the class .

In addition to constructor that is passed whole euros as arguments , there is constructor that can process double value of euros standard copy constructor .

Example : Negation , Addition , Subtraction unary does not change its operand .
In the previous example , is thus assigned value of  but remains unchanged .

Thus , the functions also create temporary objects return them with the correct values .

Example : + expression + results in .

Both are distinct that require separate definitions .
Of course , you should overload the to ensure that the statements Example : + produce the same results .

temporary is not required .

These expressions contain only type objects , which functions have been defined .
However , you can also add or subtract int or double types .
This is made possible by the constructors , which create objects from int or double types .
This allows function that expects value as argument to process int or double values .

As the program opposite shows , the statement Example : is valid .
Since there is no function with these characteristics , the compiler converts the double value to calls the existing function euros .

Example : + ok ; ok first statement is equivalent to .

But the following statement is invalid .

Example : +  wrong .

Since the function was defined as method , the left operand must be class Thus , you cannot simply exchange the operands of the +
However , if you want to convert both operands , you will need global definitions the functions .

You can define an function as global function instead of method .

Global functions are generally preferable if one of the following situations applies : the is binary both operands are symmetrical ,

The function of unary thus possesses single parameter , whereas the function of binary has two .

The class has been modified to provide global definition of the functions the +

Example : const ; Both operands are now peers .
More specifically , conversion of int or double to is performed both operands now .
Given object net , following expressions are valid equivalent : Example : net + + net They cause following function calls : However , global function cannot access private members of class .
The function shown opposite therefore uses  whose function is defined as method .

global function can be declared as " of class to allow it access to private members of that class .

This is made possible by friend declaration , which eliminates encapsulation in certain cases .

Imagine you need to write global function that accesses elements of numerical array class .
If you need to call access methods of class each time , if these methods perform range checking , function runtime will increase considerably .
However , special permission to access private members of class can dramatically improve response .

This is achieved by declaring function as friend .
The friend keyword must precede function prototype in class definition .

Example : class .

This allows them direct access to private members of class .
Since these functions are not methods of class , this pointer is not available to them .
To resolve this issue , you will generally pass object function needs to process as an argument .

It is important to note that class itself determines who its friends are .
If this were not so , encapsulation could easily be undermined .

In order to compute interest , it is necessary to multiply divide euros by double values .
Since both expression are possible , friend functions are implemented to perform multiplications .
As example shows , friend functions can also be defined inline in class .

All methods in this " class automatically become friend functions in class containing friend declaration .

This technique is useful if class is used in such close conjunction with another class that all methods in that class need access to private members of other class .

For example , class ControlPoint uses objects of Result class .
Calculations with individual measurements are performed repeatedly .
In this case , it makes sense to declare ControlPoint class as friend of Result class .

Example : class Result .

It is important to note that ControlPoint class has no influence over fact that it is friend of Result class .
The Result class itself decides who its friends are and who has access to its private members .

It does not matter whether friend declaration occurs in private or public section of class .
However , you can regard friend declaration as an extension of public interface .
For this reason , it is preferable to place friend declaration in public area of class .

More specifically , you can utilize global friend functions where methods are not suited to the task in hand .
Some common uses are global operator functions declared as friend functions .

However , extensive use of friend techniques diffuses the concept of encapsulation .
Allowing external functions to manipulate internal can lead to inconsistency , especially if class is modified or extended in later version .
For this reason , you should take special care when using friend techniques .

It is binary operator and thus has two operands .
Given an expression such as , the array name will always be the left operand , whereas the index will be the right operand .

The subscript operator for arrays implies background pointer arithmetic , for example , is equivalent to .
Thus , the following restrictions apply to index operators : an operand must be array name , for example the other operand must be an integral expression .

You should note , however , that the operator function is always class method with parameter for the right operand .
The following therefore applies : the left operand must be class object the right operand can be any valid type the result type is not defined .

This allows for considerable flexibility .
However , your overloading should always reflect the normal use of arrays .
More specifically , the return value should be reference to an object .

Since an index can be of any valid type , the possibilities are unlimited .
For example , you could easily define associative arrays , that is , arrays whose elements are referenced by strings .

An invalid index can thus lead to abnormal termination of an application program .
However , you can address this issue by defining your own array classes , although this may impact the speed of your programs .

The opposite page shows simple array class definition for float values .
The subscript operator has been overloaded to return reference to the array .

However , when the array is accessed , checking is performed to ensure that the index falls within given boundaries .
If an invalid index is found , the program issues an error message and terminates .

The class FloatArr array has fixed length .
As we will see , variable lengths are possible using dynamic memory allocation .

Dynamic memory allocation is an important factor in many programs and the following chapters will contain several additional case studies to you review the subject .

In cases like you will need to allocate memory dynamically , that is , while the program is running .

Dynamically allocated memory can be released to continually optimize memory usage with respect to current requirements .
This in turn provides high level of flexibility , allowing programmer to represent dynamic data structures , such as trees linked lists .

Programs can access large space of free memory known as the heap .
Depending on the operating system how the OS is , the heap can also occupy large amounts of unused space on the hard disk by swapping memory to disk .

uses the new delete operators to allocate release memory , means that objects of any can be created destroyed .
look at the scenario fundamental types first .

In its simplest form , call to new syntax Syntax : new  Where is pointer to .
The new creates an of the specified returns the address of that .
The address is normally assigned to pointer variable .
If the pointer belongs to wrong  the compiler will issue an error message .

Example : new  This statement allocates memory  that is , bytes .

The previous call to new not define an initial the new  however , you can supply in parentheses to initialize the .

Example : new ; Following statement points to memory address containing with of .
The statement endl ; will output .

Failure to do so impact the performance of your computer system .
Memory that is released is available further calls to new .

call to delete syntax Syntax : delete  The operand addresses the memory space to be released .
But make sure that memory space was dynamically allocated by call to new .

You pass NULL pointer to delete when you call the .
In this case nothing happens delete just returns , so you do not need to check NULL pointers when releasing memory .

delete expression is always void  so you cannot check whether memory has been successfully released .

As the sample program illustrates , misuse of delete be disastrous .
More specifically do not call delete twice the same do not use delete to release statically allocated memory .

The new is function designed central error handling .
Thus , you do not need to design your own error handling routines each time you call new .

The new is activated by default throws an exception .
Exceptions be caught by the program , allowing the error condition to be remedied to Chapter , Exception .
Any exception that is not caught will terminate the program , however , you install your own new .

If you are working with an older compiler , please note that new NULL pointer if not enough memory is available .

In this case , in addition to allocating memory , suitable constructor must be called .
Before releasing memory , the destructor must be called to perform cleaning up tasks .
However , the operators new delete ensure that this happens .

Unless explicitly initialized , the default constructor is called each new  but you must make sure that default constructor exists .

Example : new  This statement allocates memory an of the class .
If enough memory is available , the default constructor is executed the address of new returned .

Syntax : new ; The in the initialization list are passed as arguments to the constructor .
If the compiler is unable to locate suitable constructor , an error message occurs .

Example : new ; This statement assigns the address of new class to the pointer .
The is initialized using the supplied .
The expression thus represents the entire .

Example : To add euros .

The public members are referred to via the member access operator arrow_operator

Example : endl ; Releasing Memory When an that was created dynamically is destroyed , the delete operator makes sure that the is cleaned up .
The destructor is first called , only then is the memory space released .

As previously discussed in the section on fundamental types , when you call delete you must ensure that the pointer is addressing dynamic or that you are dealing NULL pointer .

This page intentionally left blank Dynamic Members This chapter describes how to implement classes containing pointers to dynamically allocated your own copy constructor definition and overloading the assignment .

class designed to represent of any given length is used as sample application .

Object fArr arrPtr max : cnt : class representing dynamic of floats .

Depending on the of data an application program really has to handle , memory is allocated as required while the application is running .
In order to do this the class needs pointer to the dynamically allocated memory that contains the actual data .
Data members of this kind are also known as dynamic members of .

When compiling program that contains  you will probably not know how many elements the will need to store .
designed to represent should take this point into consideration and allow for dynamically defined variable length .

For example , simple assignment should be possible for two objects and in the new .

Example : The not the ensure that enough memory is available to accommodate the array .

Just as in the case of fundamental types , it should also be possible to use an existing  to initialize new 

Example : FloatArr ; Here the ensures that enough memory is available to accommodate the array elements of .

When an of the FloatArr is declared , the user should be able to define the initial length of the array .
The statement Example : FloatArr ; allocates memory for maximum of array elements .

The definition of the FloatArr therefore comprises member that addresses dynamically allocated array .
In addition to this , two int variables are required to store the maximum and current number of array elements .

The operator allows both read and write access to the array elements and cannot be used for constant objects for this reason .
However , you will need to support access to constant objects .

The first version returns reference to the array element and thus supports write access .
The second , version only supports read access to the array elements and is automatically called by the compiler when accessing constant objects .

The implementation of these versions is identical .
In both cases range checking is performed for the index .
If the index lies within the valid boundaries , an array or simply value in the case of the returned .

In the first version , the only works if there is at least one empty slot in the array .
In the exercises , is used to extend the array as required .
This also applies for new  which you will write as an exercise in this chapter .

When the is used to delete an  the elements following the deleted move up one place , preserving the original order .
The current count is decremented by one .
What was formerly the last in the array is not deleted but overwritten when new is inserted .

Another technique would be to copy the last to the position of the that needs to be deleted , simply overwriting that .
Of course , this technique is quicker and preferable for cases where the order of the elements is not significant .

Effect of the standard copy constructor FloatArr ; Creates copy of .

copy constructor for class FloatArr COPY CONSTRUCTOR Initializing with an Object The next step is to ensure that an existing can be used to initialize new .

Given an array , the following statement should be valid : Example : FloatArr ; The array should now be the same length as the array and the array elements in should contain the same values as in .

The FloatArr class needs copy constructor to perform this task .
The constructor has reference to constant array as parameter .

Prototype : const ; Standard Copy Constructor If class does not contain copy constructor , the compiler will automatically create minimal version , known as the standard copy constructor .
This constructor copies the data members of the passed to it to corresponding data members of the new .

standard constructor is normally sufficient for class .
However , simply copying the data members would serve no useful purpose for objects containing dynamic members .
This would merely the pointers , meaning that the pointers of several different objects would reference the same place in memory .
The diagram on the opposite page illustrates this situation for two FloatArr class objects .

This scenario would obviously mean trouble .
Imagine releasing memory allocated for an dynamically .
The pointer for the second would reference memory area that no longer existed .

The example on the opposite page shows the definition of the constructor for the FloatArr class .
Calling and the elements of the passed to the are then copied to that .

SOLUTIONS Exercise  Dynamic arrays of numbers .

Besides defining derived classes , we will also discuss how members are redefined how objects are constructed and destroyed , and how access control to base classes can be realized .

The new derived " the data and methods of the base .
But you can add more characteristics and functionality to the new .

fleet management program used by car hire company needs to handle all kinds of , motorcycles , trucks , and so on .
All of these vehicles have an identification number that indicates the vehicle , the manufacturer , and the vehicle status , such as " and so on .
Additionally , operations such as status " are required for the .

To differentiate between vehicle types , various are derived from the base Car , such as PassCar , which is used to represent vehicles .
This has additional attributes , such as the number of seats , type , sunroof , and various additional operations .

passenger vehicle is special kind of car .
In cases like this we can say that the derived establishes an is relationship to the base .

We distinguish between this close relationship and has relationship .
As already mentioned , has relationship occurs between two when an member of one has another type .
An Account object has string object to represent the name of the account holder , for example .

This makes it easier to manage complex situations and relationships .

The base implementation need not be known for this purpose : only the public interfaces are required .

The opposite page shows schematic definition of derived 
The inherits the  which is defined in the public section following the colon .
The private and public sections contain additional members of the .

In other words , all the public members in base are publicly available in the derived .

This kind of inheritance ports the public interface of the base to the derived where it is extended by additional declarations .
Thus , objects of the derived can call the public methods of the base .
public base  therefore , implements the is relationship ; this is quite common .

There are some less common cases where access to the members of the base needs to be restricted or prohibited .
Only the methods of can still access the public members of  but not the users of that .
You can use private or protected derivation to achieve this techniques will be discussed .

That is , the methods of the derived cannot access the private members of the base .

Imagine the consequences if this were not so : you would be able to hack access to the base by simply defining derived  thus undermining any protection offered by data encapsulation .

This allows for hierarchies .
Class then becomes an indirect base for .

In the graphic on the opposite page , the arrow means directly derived from .
That is , is direct derivation of and an indirect derivation of .

The Car class and derived class PassCar are defined in the example .

The derived class PassCar inherits these data members .
Thus , an object of the PassCar class also contains the data members and .
The object includes base subobject of type Car .

The PassCar class additionally contains the data members and to represent passenger vehicle with or without sunroof .
So PassCar type object has total of four data members .
For the sake of simplicity , we have omitted further data members , such as the number of seats , etc .

The base class Car contains constructor , access methods , and the method , which is used for screen output .
The methods are also inherited by the derived class PassCar .

In the PassCar class constructor , additional access methods , and second output function also called are declared .
The derived class thus inherits method method is said to have been redefined .

Every member function and every data member in derived class can be redefined .

The member assumes new for the derived class .
The member inherited from the base class is also available in the derived class and will retain its original .

We will be looking at this point in more detail later .

For example , you can call the method for an object named cabrio in the PassCar class .

Example :  The public interface of the derived class thus comprises the public members of the base class and the public members additionally defined in the derived class .

Example : const const return  The method directly accesses the private data member in the PassCar class in this example .

The output function in the derived class PassCar , for example , cannot contain the following statement : Example :   As is private data member of the base class Car , the compiler would issue an error message at this point .

Methods belonging to derived classes only have indirect access to the private data members of the base class .
They use access methods in the public declaration of the base class for this purpose .
The opposite page shows version of the method that calls the get methods in its base class Car .

When you call an access method , you do not need to state the base class .

The base class is identified by the this pointer , which is passed implicitly as an argument .
The call to on the opposite page is thus equivalent to : Example : Name Lookup The following rules apply when searching for the name of method : the compiler looks for the name of the method called in the derived class first if the name cannot be found , the compiler walks one step up the tree and looks for public method with that name .

The above example thus calls the in the base class Car , as the method is not defined in the PassCar class .

The name does not occur in the base class redefinition .

The name already exists in the base class redefinition .

In the second case , the member of the same name continues to exist unchanged in the base class .
In other words , redefining members in derived class has effect on the base class .

However , the name lookup rules for the compiler lead to the following scenario : if member is redefined in derived class , it will mask the corresponding member in the base class .

This situation is similar to the one seen for local and global variables .
local variable will mask previously defined global variable with the same name .

This adopts the methods to the new features of the class .
When method is redefined , the signature and the return type of the method can be changed .
However , redefinition does not overload functions since the derived class has different scope .

Redefining method will always mask method with the same name in the base class .

Of course , you can overload methods within the same class , and this means you can repeatedly redefine base class method for derived class .

If the method was declared in the public section of the base class , you can call it to redefine method .
The range : operator is used to access the base class method .

The new of the method opposite illustrates this point .
The method defined in the base class is used to output the data members of the base class .
To do so , you must use the range operator with the name of the base class .

Otherwise the method in the derived class will call itself and head off into an indefinite recursion .

As the derived class contains all the members of the base class , the base must also be created and initialized .
The base class constructor is called to perform this task .

Unless otherwise defined , this will be the default constructor .

The order in which the constructors are called is important .
The base class constructor is called first , then the derived class constructor .
The object is thus constructed from its core outwards .

The first of the constructor for PassCar , as shown opposite , sets initial values by calling the access methods of the base class .
An implicit call to the default constructor of the base class occurs prior to this , and the base is initialized with default values .
This process has the same drawbacks as the technique of creating objects with member objects .
default constructor must be available in the base class and initialization with incorrect values before assigning live values impacts the response of the program .

This immediately initializes the data members with correct values .
base initializer for the constructor of the derived class can be defined for this purpose .

The second of the constructor for PassCar contains base initializer .

Example : The syntax of the base initializer for base is similar to that of the member initializer for member .
This means that you can state both the base and the member initializer in list separated by commas .
The third of the PassCar constructor illustrates this point .

The reverse order of the constructor calls applies .

You need to define destructor for derived class if actions performed by the constructor need to be reversed .
The base class destructor need not be called explicitly as it is executed implicitly .

Two objects , beetle and cabrio , of the derived class PassCar type are declared .
As the PassCar class does not contain default constructor , both objects must be initialized .
However , it is sufficient to state PassCar type with or without sunroof as default values exist for all other data members .

The object beetle is declared as const just to show that the get methods and the method can also be called for constant objects since they were declared as methods .

However , the following call is invalid : Example : Error This means you have to correctly define all the initial values for the object when you declare it .

In the PassCar class the method has been redefined .
The statement Example : also outputs the additional data members and .
However , in the case of the van object in the Car class , calling Example : will execute the method in the base class .

This is possible using the scope resolution .

If you want to display the basic data of the cabrio object , you can use direct call to the base class method to do so .

Example : The name of the method is preceded by the name of the base class and the scope resolution operator in this case .

When you create class hierarchy you may want require the methods and friend functions of derived class to communicate directly with the members of the base class .

This would be particularly necessary if the base class contained members for use as building blocks for derived classes but not for general purpose use .

For example , class used to represent window on screen could contain the dimensions and other characteristics of general windows .
The characteristics need protecting ; however , methods in derived classes will still need direct access .

This is achieved by means of protected declarations .

member declared protected is sheltered from external access just like private member .
That means , protected member is inaccessible for base class objects and any classes derived from the base class .
However , in contrast to private member , methods and friend functions of derived classes can access the member .

The classes defined opposite , Safe and Castle , show that protected members of the base class can be accessed directly in derived class .
In contrast to this , protected members are inaccessible to users of these classes .

Protected declarations should be used with caution .
If you change the declaration of protected member , every class derived from this class must be examined to ascertain whether additional modifications are necessary .

In addition , the class is to be added to the class hierarchy .

The SavAcc contains the members of the base class and an interest rate .

Properties : Weight Price per pound .

Exercise EXERCISES Exercise supermarket chain has asked you to develop an automatic checkout system .

All products are identifiable by means of barcode and the product name .

Groceries are either sold in packages or by weight .
Packed goods have fixed price of groceries sold by weight is calculated by multiplying the weight by the current price per kilo .

Develop the needed to represent the products first and organize them Product class , which contains generic information on all products , name , can be used as base class .

Define constructor with parameters for both data default for the parameters to provide default constructor for the class .
In addition to the access methods and , also define the methods and .
For test purposes , these methods will simply output product on screen or read the of product from the keyboard .

Define two derived from Product , PrepackedFood and FreshFood .
In addition to the product  the PrepackedFood class should contain the unit price and the FreshFood class should contain weight and price per kilo as members .

In both define constructor with parameters providing for all members .
Use both the base and member initializer .

Define the access methods needed for the new redefine the methods and to take the new members into consideration .

One object of each type is fully initialized in the object definition .
Use the default constructor to create the other the get and set methods and the method and display the products on screen .

When such an reaches the end of its lifetime , the memory occupied by the must be released by delete statement .

If multiple constructors were called to create the  the corresponding destructors are called in reverse order .
What does this mean for objects in derived classes .
The destructor of the derived class is called first and then the destructor of the base class executed .

If you use base class pointer to manage an  the appropriate virtual methods of the derived class are called .
However , methods will always execute the base class .

In the previous example , only the base class destructor for was executed .
As the destructor is not called , neither is the destructor called for the data member passCarType , which is additionally defined in the derived class .
The data member passCarType is string , however , and occupies dynamically allocated this memory will not be released .

If multiple objects are created dynamically in the derived class , dangerous situation occurs .
More and more unreferenced memory blocks will clutter up the main memory without you being able to reallocate can seriously impact your response and even lead to external memory being swapped in .

The opposite page shows how you would define virtual destructor for the class .
Just like any other virtual  the appropriate of the destructor will be executed .
The destructors from any direct or indirect base class then follow .

class used as base class for other classes should always have virtual destructor defined .
Even if the base class does not need destructor itself , it should at least contain dummy destructor , that is , destructor with an empty function body .

The address is inserted directly into the machine code .
This is also referred to as static or early binding .

If virtual method is called via an  the appropriate version of this method is also known at time of compilation .
So this is also case of early binding .

The statement Example : could execute different versions of the method , depending on the currently referenced by the pointer .

The compiler is therefore forced to create machine code that does not form an association with particular function until the program is run .
This is referred to as late or dynamic binding .

VMT is created for each class with at least one virtual is , an array with the addresses of the virtual methods in the current class .

Each in polymorphic class contains VMT pointer , that is , hidden pointer to the VMT of the corresponding class .
Dynamic binding causes the virtual function call to be executed in two steps :
The pointer to the VMT in the referenced object is read .

The address of the virtual method is read in the VMT .

In comparison with static binding , dynamic binding does have the disadvantage that VMTs occupy memory .
Moreover , program response can be impacted by indirect addressing of virtual methods .

However , this is small price to pay for the benefits .
Dynamic binding allows you to enhance compiled source code without having access to the source code .
This is particularly important when you consider commercial class libraries , from which user can derive his or her own classes and virtual function versions .

The option Time Type Information " must be activated , for example , under .
The GNU compiler activates these options automatically .

If the referenced object does not correspond to the type of the derived class , fatal runtime errors can occur .

Given that is pointer to the base class  which is currently pointing to type , the statement Example : will not cause compiler error .

But the following statement , could cause the program to crash .

At runtime the operator checks whether the required conversion is valid or not .

Syntax : If so , the expression expression is converted to the target type type .
The target type must be pointer or reference to polymorphic class or void pointer .
If it is pointer type , expression must also be pointer type .
If the target type is reference , expression must identify an object in memory .

If this is not so , the operator will return NULL pointer .

Given that cabrio is type object , the following statements Example : cabrio ; perform dynamic cast to the to  type .
In any other case , that is , if the reference does not identify type object , an exception of the type is thrown .

The dynamic cast can also be used for upcasting .
The classes involved do not need to be polymorphic in this case .
However , type checking is not performed at runtime .
An erroneous upcast is recognized and reported by the compiler .

First , define class called CityCar that contains an array of pointers to the objects in the also allows you to store pointers to objects of the derived class types and .

The objects themselves will be created dynamically at runtime .

The constructor will set the current number of array elements to .

The destructor must release memory allocated dynamically for the remaining objects .
Make sure that you use virtual destructor definition in the base class to allow correct releasing of memory for trucks and vehicles .

Implement two versions of the method using the prototype shown opposite .
Each version will allocate memory to an object of the appropriate is of the or use the arguments passed to it for method should return false if it is impossible to enter another automobile is , if the array is , and true in all other cases .

The method outputs the data of all vehicles on perform this task it calls the existing method for each object .

Insert one and one will be the first vehicles of the fleet .

If user chooses  or " your program must read the data supplied and call the appropriate version of .

If yes to record Dialog with the receptionist EXERCISES Exercise An automatic checkout system for supermarket chain needs to be completed .

The creates an array of pointers to the base class , Product .

The checkout assistant is prompted to state whether prepacked or fresh food item is to be scanned next .
Memory for each product scanned is allocated dynamically and referenced by the next pointer in the array .

After scanning all the available items , sequential list is prices of all the items are added and the total is output at the end .

The checkout assistant is prompted in loop to state whether to define new .
If so , the is called ; if not , the program terminates .

Example : The pointer is base class pointer that can address objects belonging to derived concrete classes .
The reference coRef can also address objects this type .

The copy constructor in the Coworker class is just one them .

Example : const ; The copy constructor expects an object belonging to derived class , since the base class is abstract .

The assignment in the Coworker class has reference as parameter and returns reference to the abstract class .

If the base class is abstract , you can only allocate memory for objects belonging to derived , concrete classes .

Example :  new , Since the is virtual , corresponding function found in the derived class is executed .

If derived class contains its own definition virtual method , this version will also be executed if an object is referenced by base class pointer or reference .
Abstract classes are therefore also referred to as polymorphic interfaces to derived classes .

The opposite page shows the definition the class , which was also derived from the abstract class .
The functions for the assignments are discussed and implemented in the following section .

Redefining the virtual function , which returns reference to the derived class , is not yet supported by all compilers .
In case the return type must be reference to the base class .

In case , you can ensure that the right version an function will be executed when using pointer or reference to base class to address derived class object .

One example is the function for an assignment .
If the function declaration is not virtual , and if the function is called via base class pointer , only the base data the object is overwritten .
Any additional data members the derived class remain unchanged .

The derived classes and both contain their own versions .
Thus , in the following Example : the assignment the class is executed , if an object class type is the first argument passed to it .
If the object is type , the assignment the class is performed .

In the case the , you can therefore assign two objects any class , including classes derived at later stage , without having to modify the function itself .

However , you definitely need to define the assignment for each derived class .

Since the standard assignment derived class has signature its own , it is not virtual .
The standard assignment for the class has the following prototype : Example : The type const is different from the const type the parameter in the virtual function the base class .
The standard assignment thus masks the virtual assignment in the base class .
This gives rise to two issues : the virtual function for the assignment must be defined for every derived class to ensure that the standard assignment is also available , the standard assignment must also be redefined in every derived class .

An inhomogeneous list is linear list whose elements can be of different types .
If the data you need to store consists of objects in class hierarchy , one list element could contain an object belonging to the base class , whereas another could contain an object of derived class .

Due to implicit type conversions in class hierarchies , you can use the base class pointers to manage the list elements , that is , you can manage the elements in linked list .

The following graphic illustrates scenario : Representing List Elements To separate the management of list elements from the information contained in the list , we have defined an abstract class called as base class for all list elements .
The class contains pointer of type as the data member used to link list elements .

Since type objects are not be created , the constructor in the class has protected declaration .

The class does not contain any data that might need to be output .
However , each class derived from contains data that need to be displayed .
For reason , contains declaration of the pure virtual method , which can be modified for multiple derivations .

The classes BaseEl and DerivedEl , which are derived from  represent list elements used for storing information .
To keep things simple , the BaseEl class contains only name , and the DerivedEl class additionally contains comment .
The public declaration section contains constructor and access method declarations .
In addition , suitable of the method is defined .

This page intentionally left blank More about Files This chapter describes random access to files based on file streams options for querying file state exception handling for files .

We will also illustrate how to make objects in polymorphic classes persistent , that is , how to save them in applications introduced in chapter simple files and hash tables .

To open the file for and output .

Opens the file for and output .
If the file already exists , it will be truncated .

Opens the file for and output .
If the file does not exist , it will be created .

Before each writing access , seek to end is performed .

If the flag is additionally set , the file will be opened in binary mode .

If the flag is additionally set , the current seek position is set to immediately after opening .

If you need access to specific information in such file , you have to walk through the file from top to tail , and new records are always appended at the end of the file .

Random file access gives you the option of reading and writing information directly at position .
To be able to do  you need to change the current file position explicitly , that is , you need to point the pointer to the next byte to be manipulated .
After pointing the pointer , you can revert to using the read and write operations that you are already familiar with .

This implies opening the file in binary to avoid having to transfer additional escape characters to the file .

Example : fstream , This statement opens the file " in binary for reading and appending at .
The file will be created if it did not previously exist .
Random read access to the file is possible , but for write operations new will be appended at the end of the file .

To enable random read and write access to file , the file can be opened as follows : Example : fstream , However , this technique can only be used for existing files .
If the file does not exist , you can use the flag to create it .

The section State " discusses your error handling options if file , such as " cannot be found .

The and methods return the current position of the put or get pointers as long value .

Example : long ; This statement queries the current position of the read pointer in the myfile stream .

The current position is always returned as byte offset relative to the beginning of the file .

The current file position can be modified using the or method .

The position is stated as byte offset , relative to either the beginning or end of the file , or relative to the current position in the file .

Imagine you want to write the object acc to the file " at offset pos .

You can use the following statements to do so : Example : ofstream , fstr ; This calls the method in the Account class , which allows an object to write its own data members to file Chapter .

If you do not specify positioning flag , the position will be assumed to be relative to the beginning of the file .
The statement used to position the write pointer in the last example can therefore be formulated as follows : Example : The byte offset can also be negative for calls to the methods and .

However , you cannot position the pointer before the beginning of the file .

In contrast , it is possible to place the pointer at position after the end of the file and then perform write operation , which will create gap with unknown content in the file .
This only makes sense if all the empty slots in the file are of an equal length , as they can be overwritten later .
This option is often used when programming hash tables .

Representing an index entry The and methods Using Positioning Methods The following statements are commonly used for random positioning ; and , They set the current position to the beginning or end of file .
You should be aware that the first argument is to indicate that long type is required .

If you need to determine the length of file , you can point the get pointer to the end of the file and then query the position of the pointer : Example : unsigned long ; The variable will then contain the number of bytes occupied by the file .

These positioning methods are useful for files opened in binary .
However , it does not make much sense to use them for text files or particularly for devices .
In text  conversions of prevent the methods from working correctly .

Given that size is the length of record , size ,

If you are working with variable length records , you cannot exactly compute their positions .
To enable random access you therefore need to store the positions of the records in separate structure , index .

The index stores pairs of keys and record positions , index entries in file .
 social security number , or customer id , for example , must uniquely identify record .
If the index is sorted , the position that correlates to the required can be quickly found using the binary search algorithm .

The class comprises methods for reading and writing an index entry at the current file position or at any given position .
The appropriate file stream is passed as an argument to the method .

file operation can also fail if file cannot be opened , or if block is not transferred correctly .

The ios class uses state flags to define the various states file can assume .
Each state flag corresponds to single bit in , which is represented by the iostate type in the ios class .
The following state flags exist : end of file reached last read or write operation failed an irrecoverable error occurred the stream is ok ,

The " is an exception to the rule since it is not represented by single bit , but by the value if no other flag has been set .
In other words has the value if everything is fine .

method exists for each state flag ; these are , and .
They return true when the corresponding flag has been raised .
This means you can discover the end of file with the following statement : Example :

The of stream can be read using the method .
Individual flags can then be queried by simple comparison : Example :

An argument of the iostate type passed to automatically becomes the new for the stream .

The constructor for this class uses the method to reset the fail bit after an invalid attempt to open .

The IndexFile class comprises methods for inserting , seeking , and retrieving index entries , which we will be implementing later in this chapter .

; EXCEPTION HANDLING FOR FILES Defining your own exception classes EXCEPTION HANDLING FOR FILES Implementing Your Own Exception Handling You can exploit the error tracking options that state flags give you to implement your own exception handling for files .
For example , method that reads records from can throw an exception when the state flag is raised , that is , when the end of the is reached .

The opposite page shows typical exception classes organized in hierarchy that can be used to represent error conditions on opening , reading from , and writing to .
In each case the is saved for evaluation by the exception handler .

You can use the method to specify the flags in the of stream that will cause exceptions to be thrown .

The method is defined in the ios stream base class .
The method expects one or multiple state flags separated by the sign .
An exception is then thrown for the flags specified .

Example : ifstream ; On accessing the fstrm stream an exception is thrown if either one of the flags or is raised .
The operation that caused the error is then terminated and the state flags are cleared by call to .

The exception thrown here is of standard exception class , failure .
This type is defined as public element in the ios base class and comprises the virtual method that returns string containing the cause of the error .
The exception handler will normally send the string to standard error output .

You can call without any arguments to discover the state flags in of stream that can cause an exception to be thrown .
If bit is set in the return value of the method , an appropriate exception will be thrown whenever this error occurs .

Example : iostate ;

This statement uses bitwise AND operator to ascertain whether an exception is thrown when is reached .

The methods and of class DepAcc PERSISTENCE OF POLYMORPHIC OBJECTS Storing Polymorphic Objects Imagine you want to make the objects of polymorphic class hierarchy persistent , that is , store them in .
You need to ensure that an object can be reconstructed precisely when it is read .
This gives rise to the fact that objects in polymorphic class hierarchies contain virtual methods .
So it is not simply case of making the data members of an object into records and writing them to .

You must write both the type and the data members of the object to .

If the objects contain dynamic members , you must save the referenced objects themselves along with information on the object type .

The methods can have virtual definition within the class hierarchy .
Thus , if pointers are used to reference objects , the appropriate operation for each object will be called .

Virtual methods have now been added .
The implementation of the and methods was discussed earlier in Chapter , of File Input and " and is unchanged .

The derived classes DepAcc and SavAcc also contain definitions of the and that read only their " objects and write them to files .
The implementation first calls the appropriate base class method .
If no errors occur , it is simply question of transferring the additional data members of the derived class to or from .

At present , no type information will be written to file or read from file .
This task will be performed by special class whose features are used for file management .
The following section contains more details on this topic .

This page intentionally left blank More about Pointers This chapter describes advanced uses of pointers to pointers , functions with variable number of arguments , and pointers to functions .

An application that defines class used to represent dynamic matrices is introduced .

POINTER TO POINTERS Motivation Pointer variables are objects that have an address in memory , and this means you can use pointers to address them .
It is thus possible to create pointers to pointers .
This is necessary if an array of pointers is to be dynamically allocated , or function expects an array of pointers as an argument .

In both cases you need to declare pointer variable that can access the first element in the array .
Since each element in the array is pointer , this pointer variable must be pointer to pointer .

Example : new ; The pointer is now pointing at the first pointer in the array with total of type pointers .
The array elements can be addressed as follows : and and Access to objects managed by the array is achieved as follows : and and Pointer Arrays as Arguments When you define function that expects an array of pointers as an argument , you must define parameters to match .

Example : void , int ; You can use the parameter to manipulate pointer array whose length is stored in the second parameter , len .
After calling Example :  points to the first pointer in the pointer array .
Instead of you can also use the equivalent form .

The opposite page shows an implementation of the function .
The function uses the selection sort algorithm you have already worked for sorting .

In this case it is important not to sort the accounts itself , but to sort the pointers instead .

This saves copying .

One example of function of this type is the standard function , which requires at least one argument , format string .
The function uses the conversion specifiers in the format string to compute the number and type of arguments that follow .

At least one obligatory argument is required .

As you would expect , you need to define an appropriate parameter for each obligatory argument when you define function of this type .
The optional arguments are represented by three dots .
The function shown opposite , expects two or more arguments .
The prototype is , thus , as follows Prototype : int char , int max , To allow functions with variable number of arguments to be defined , pushes the last argument onto the stack first .
After calling the sample function , the stack looks like the diagram opposite .

The optional arguments are accessed via pointer , the argument pointer , which is designated by argptr here .
The header files cstdarg or contain macros , which conform to ANSI standard , to manage the pointer and assure that the source code will be portable .

The type argument pointer argptr must be declared in addition to other local variables .
The type is defined in the header file as typeless or char pointer .

The macro is then called to point the argument pointer argptr to the first optional argument .

Example : argptr , max ; The function reads characters from the keyboard and appends .

Pointer to the input buffer .

Maximum number of characters to be read .
Optional arguments : Characters that .

When the macro is called , the optional argument pointed to by argptr is read from the stack .
The arguments of are the name of the argument pointer and the type of the optional argument :  argptr , Each call to the macro sets the argument pointer to the next optional argument .
The result of has the type stated in the call .
It must be identical to the type of the corresponding optional argument .

There is no special terminating condition for the last optional argument .
specific value as NULL , or can be used , or the current number of arguments can be defined by an obligatory argument .

After evaluating the arguments the argument pointer is set to NULL by the macro :  Optional arguments can also be read more than once .
The procedure described above is repeated beginning at Step , that is , with the macro .

The second argument defines the maximum number of characters to be read .
All other arguments are characters that can terminate keyboard input .
The last argument must be return character .

Input can be terminated by pressing the space , ESC , or return keys .
The return value is the corresponding character code .
characters are ignored unless stated as optional arguments .

Special keys , such as the function keys , return value of for the first call to and the extended code for the second call .
For function keys this code is within the range .
To distinguish extended codes from normal ASCII codes , the value is added to the extended code .
table of extended codes is available in the Appendix .

Both integral and numbers are represented internally as binary numbers , that is , as sequences of and values .
However , the formats for representing integral and numbers differ .
Thus , the of an integer will be interpreted differently from that of number by the computer .

Representing Signed and Unsigned Integers The binary format of integers is basically the same for the char , short , int and long types and differs only in the number of bytes available for each type and whether the number is interpreted as signed or unsigned .

The of positive integer can be represented as base power series .
The sign bit additionally indicates that the number is positive in the case of signed types .

The number can be represented by the following power series : + + + +

The binary representation of the number as signed char type value is thus as follows : complement is used to represent negative number , for example : First , complement of is computed , that is , all the bits are inverted : Then the number is added : Producing the bit pattern of :

complement for yields value of .

Sign bits are not required for unsigned types .
The bit can then be used to represent further positive numbers , doubling the range of positive numbers that can be represented .

The following table contains the binary formats of signed and unsigned integral bit values : If the of negative number is interpreted as an unsigned number , the value of the number changes .
The of the number will thus yield the following unsigned value : + + + + + + + that is , the decimal number .

Representing Numbers To represent given number ,  the number is first broken down into sign , mantissa , and power , exp , with base of : Binary Signed decimal Unsigned decimal .

BINARY NUMBERS Memory for the values , and exp is normally assigned in IEEE of Electronics and Electronical format .
The type float will thus be organized as follows : In this " form , numbers are unambiguous .
The mantissa , has value that is greater than or equal to and less than , the only exception being , where the mantissa is .

Example : The first digit of the mantissa is always and need not be stored .
The power is stored along with its bias .
bias of applies for float types ; thus power of floatingpoint number is represented internally as +

The memory reserved for the mantissa defines the accuracy , and the memory reserved for the power defines the range of values for the number .

If ranges , such as the length of the mantissa or the smallest or largest value that can be represented , are significant in your programs , you can discover these ranges in the cfloat or climits header files .

You can use an instantiation of the class template for the type in question to query ranges by method calls .

Bit position exp PREPROCESSOR DIRECTIVES The Directive The directive is used to define symbolic constants and macros .

Syntax : The preprocessor replaces name or SubstituteText throughout the whole program .
If SubstituteText is not stated , the preprocessor will delete the symbolic constant or macro throughout the program code also Chapter , Example : BUFSIZ Symbolic constant .

When the macro is called , the argument is set in quotes , that is , string constant is formed using the characters of the current argument .

Example : which is then concatenated to Catalog .

The characters  and are represented by " and within an argument .

Example : With the string  is produced .

The Operator When macro is defined , character sequences can be concatenated in the substitute text .
The past token operator , is used to this effect .

When the macro is called , the parameter preceding or following the token is replaced by the appropriate argument .
Then the token and any leading or trailing whitespace character is removed .

PREPROCESSOR DIRECTIVES Example : Calling ; will generate the statement " The arguments of macro are not parsed for symbolic constants or macros .
However , if the result of concatenation is symbolic constant or macro , text replacement is again performed .

The Directive To change the definition of symbolic constant or macro at program runtime , you must first remove the original definition .
To do so , the directive is used .

Syntax : name Do not supply the parameter list for parameterized macros .

You can then use the directive to redefine the macro .

Example : BUFSIZE .

The directive is replaced by the content of the file .

Syntax :

Replace the sign by the appropriate decimal number in all cases .

Cursor lines up Cursor lines down Cursor characters right Cursor characters left or Put cursor in line and column Save cursor position Load saved cursor position : Delete from cursor position to line end from start of line to cursor position : Delete whole line Clear screen : all attributes normal : switch double intensity on : Blink on : Inverse on : Foreground color : Background color : black : blue : red : magenta : green : cyan : yellow Change key assignments : The key with decimal code will then return code .

To enable these escape sequences , you must first load an appropriate screen device driver .
To do so for Windows , place the following line in your file Win NT and Win do not supply the ANSI screen control characters .
Corresponding functions based on system calls are offered for download .

International Standard , Programming ; published by ISO Copyright Office , Case postale , Geneva ,

Stroustrup , Bjarne , The Programming Language , Addison Wesley ,

Josuttis , Nicolai , The Standard Library , Addison Wesley ,

LITERATURE This page intentionally left blank Note : Italicized page locators indicate figures .

See also Compound assignments Associative arrays , Associative container classes , Associative containers , and bitsets , ATM Transfer cells header of , representing , method , auto keyword , Automatic lifetime , auto objects , auto specifier , method and container classes vector , deque , and list , Backslashes , badbit , Base classes , accessibility of , access to members in , calling methods in , conversions in references to , converting to , multiple indirect , virtual , with virtual destructors , Base class object assignment , Base class pointer conversion , class , defining , Base initializers , Base subobject , method , Bell Laboratories , Bias , Bidirectional iterators , Binary arithmetic operators , Binary bitwise operators , Binary complement , Binary mode file opened in , Binary operator , and operands , Binary search algorithm , Binary trees , Binding , Bit coded data , defining , Bitmap container class , Bitmaps raster images represented with , Bit masks , creating , using , Bit patterns retaining , Bits deleting , manipulating , Bitsets , associative containers and , declaring , Bitwise AND operator , Bitwise exclusive OR operator , INDEX Bitwise operators , for bit manipulation , in compound assignments , for creating bit masks , Bitwise OR operator , Bitwise shift operators , Blocks , building , Block scope object defined with , Boolean constants , Boolean operator precedence , Boolean values , output of , types for , bool type , Braces and functions without arguments , and variables , Brackets and parameters for macros , in syntax descriptions , Branches , break statement , sample program containing , Bresenham algorithm , Bubble sort algorithm , types , programming language , standard library header files , characteristics of , conventions in , programs in , historical perspective on , keywords in , programming language , sample program , standard library , function , Calling environment , Capacities , function defining , Car class , accessing members of , virtual method table for , Case conversion and macros , Case labels , Casting , Castle class , Cast operator , catch block , nested , syntax of , Catching exceptions , cctype header file , Cell base class and derived classes , cerr stream , cfloat header file , Character by character string comparison , Character codes , Character constants , examples for , Character manipulation standard macros for , Characters , output of , reading and writing , testing , types for , Character set , char arrays , char pointers , array of , sample function , char type , char vectors , cin , cin stream , Class arrays declaring , sample program , abstract , adapter , associative container , base , container , defining , derived , dynamic members of , dynamic storage allocation for , example of , exception , friend , and friend functions , and global functions , stream , iterator , naming , operators for ,
See also Abstract classes ; Adapter classes ; Base classes ; Derived classes ; Type conversion for classes class keyword , Class access operator , constants , Class  defining , for sequences , method , for deleting objects in container classes , for erasing containers , and , Client class , climits header file , clog stream , method , Closing files , CLS macro , cmath header file , Collision resolution , Collisions , Colons after labels , Command line arguments , sample program , Comma operator , syntax for , Commas for separating initializers , Comments program with , examples of , Comparative operators , Comparator class , function , Comparisons results of , Compiler , Complex declarations , operators and , rules for evaluating , complex header file , Compound assignments , bitwise operators in , demonstration of , operators , Compound conditions , Concatenation operators , Concrete classes abstract classes versus , Conditional expressions , compilation , structogram for , Conditional inclusion , Conditional operator precedence , header file , Constants , type , const keyword , const object declaration , Const accessing , pointers to , Constructor calls , and initialization , sample program , in virtual base classes , Constructors , Account class with , for adapter classes , calling , conversion , copy , declaring , INDEX default , defining , initializing , with inline definitions , task of , of vector , list , and deque ,
See also Destructors Container adapters , Container classes , deleting objects in , Containers , description of , length and capacity of , positioning and iterating in , types of , Containers Library , Contiguous memory space , continue statement , Control , Controlling expression , ControlPoint class , Conversion constructors , Conversion functions , conversion constructor versus , defining , Copy constructor , effect of standard , for FloatArr class , proprietary version of , function , Counter initializing , method and , count variable , cout , cout stream , Coworker class , assignment for , CPU registers , cstdlib header file , strings initializing , specializing function template for , and string class , function , header file , Current file position , global function , Data abstraction , bit coding , encapsulation , structures , Data blocks transferring , Data handling with traditional procedural programming , Data members , and methods , static , Date class methods , Daytime class operators , DayTime sample class , Debuggers , DEC Alpha workstations and , Decimal constant , Decimals numbers represented as , Declarations , within header files , Declaring sequences , dec manipulator , Decrement operator , and bidirectional iterators , Default arguments , defining , rules for and setting of , of templates , default constructors , Default destructors , default label , Default settings , for flags , directive , enum constants contrasted with , working with , delete operator , operator , Deleting in arrays , list elements , objects in container classes , in sequences , depAcc class and methods of , deque container class , constructors of , Derived classes , defining , members of , standard assignment of , Derived class object assignment , class , defining , Derived type , Destructors , calling , declaring , default , defined , with inline definitions , in Matrix class , sample program ,
See also Constructors Direct base class , Direct derivation , function , function , method , calling , new of , Division , Dot operators , Double ended queue , Double quotes and header files , string constant within , double type , loop , syntax for , statement structogram for , Downcasting , safety issues in , method and Bitmap container class , and Bresenham algorithm , Dynamically allocated objects destroying , Dynamic arrays , Dynamic binding , Dynamic casting , operator , Dynamic casts using , Dynamic data structures , Dynamic matrices , Dynamic members , classes with , description of , objects created with , of varying length , Dynamic memory allocation , for containers , Dynamic storage allocation for arrays , for classes , Early binding , Elementary operations , Element functions for output in fields , else branch , chains structogram for , switch statement contrasted with , Embedded keys , Employee class , assignment for , Empty lists , method , and container classes , Empty statements , Empty strings , Encapsulation , of arrays , and static data members , INDEX method , and associative container classes , endl manipulator , Enumeration definition , sample program , enum keyword , eof bit , Equals sign and initialization , method , for deleting objects in container classes , header file , Error classes defining , Error condition backing out of , Error handling , and exception hierarchies , for new  traditional , Errors avoiding , common causes of , input , messages , parity bit computation and recognition of , runtime , templates checked for , Escape sequences , decimal values and effects , Euro class , converting constructors of , converting function for , explicit type conversion for , expressions valid for operators in , with friend functions ,  testing conversions of , Exception classes , defining , standard , Exception class members , Exception declaration , Exception handlers , searching for , Exception handling , concept behind , description of , for files , implementing own , nesting , Exception hierarchies , Exceptions , catching , throwing , method , Exception specification list , template function ,

Exit code , function , function , Explicit cast constructions , Explicit initialization , of objects , Explicit inline methods , Explicit instantiation of templates , syntax for , Explicit type conversion , for Euro class , testing , explicit keyword , Exponential notation , Expressions , evaluating , with reference type , in switch statement , Extended codes , External functions , External static object , extern storage class , extern , failbit state flag , of ios base class , method , false keyword , Fibonacci numbers , Fibonacci quotients , Fields input , output , Field width defining , specifying , File access mode , stream classes for , File management and file buffer , File operations , Files , buffers , closing , default settings for opening , determining positions in , error handling when opening , exception handling for , extensions , names , open mode of , positioning for random access ,

See also Header files ; Records File scope object defined with , File state , File stream classes , functionality of , in iostream library , File streams , definition , sample , specifying for field , method , Filter programs using , Filters , method , and , fixed manipulator , Fixed point output , Flags , for open mode of file , open mode , positioning , state , FloatArr class , constructors in , copy constructor for , data members of , new in , new of , prototype of operator function for , versions of , constants , examples for , division , numbers , formatted output of , inputting , types , conversion of , to integral type , conversion of , to larger type , conversion of , to smaller type , values types for , float type , for loops syntax for , Formatting , options , standard settings , Formatting flags , Formatting operator , for statement , sample program , structogram for , Fraction class , method of , Fractions calculating with , Friend classes , declaring , using , Friend declaration , Friend functions , declaring , overloading operators with , using , INDEX friend keyword , method , and container classes vector , deque , and list , fstream class , Function blocks , Function call operator , Function calls defined , implicit type conversions in , sample program , Function prototype , example of , Functions , program with , calling and called , conversion of , declaring , default arguments defined for , defining , error checking after leaving , external , general form of , hash , inline , libraries , and macros , operator , overloading , and passing by value , pointers to , pointer versions of , recursive , return value of , sample , scheme of , with varying arguments , signatures , significance of , in , static , virtual operator , without arguments , without return value , Function templates , ANSI instantiation of , defining , explicit instantiation of , passing arguments to , Fundamental types , example with , operators for ,

See Institute of Electrical and Electronic Engineers directive , statement structogram for , syntax for , directive , if statements variables defined in , ifstream class , Implicit conversion , example for , Implicit inline methods , Implicit instantiation , of template class , Implicit type conversions , in assignments , avoiding , to base class type , in function calls , directive , Include files , include folder , method , in constant , Increment operator , and bidirectional iterators , Indefinite recursion , Indentation , Index entries , representing , IndexEntry class , Indexes , access via , for array elements , and bit manipulation , invalid , representing , Index file , implementing , IndexFile class , constructor of , defined , method of , IndexFileSystem class and methods of , Index versions of functions , Indirect base class , Indirect derivation , Indirection operator , Infinite loops , Inheritance , data abstraction and reusability , derived classes , is relation , member access , protected members , redefining members ,
See also Multiple inheritance Inheritance graph building , InhomList class complete , defining , Inhomogeneous lists application with , implementing , terminology for , call , Initialization , and constructor calls , of constructors , explicit , of member objects , of objects , references , for virtual base classes , INDEX Initialization list , and arrays of pointers , method , Inline functions , definition of , global , and macros , inline keyword , Inline methods , Input errors , fields , formatted , formatted , for numbers , redirecting standard , stream classes for , streams , function , method , Insertion methods in sequences , in vector , deque , and list container classes , Insertion sort algorithm , method , of class IndexFile , of class IndexFileSystem , and , of SortVec derived container class , Instances , class , Instantiation and template definition , of template functions , of templates , Institute of Electrical and Electronic Engineers , Integer promotions , Integers , computing parity of , formatted output of , inputting , types for , Integer types , Integral constants , examples for , Integral numbers displaying , Integral promotion , Integral types , conversion of , to type , conversion of , to smaller type , and operands for bitwise operators , Integrated software development environment , internal manipulator , Internal static object , International Organization for Standardization , Interpolation search , int type , Invalid indexes , class , overloading shift operators for , redirecting , iomanip header file , ios baseclass flags defined in , flag , ios class , type positioning flags , iostream class , iostream header file , iostream library , file stream classes in , method , macro , ISO .
See International Organization for Standardization method , is relationship , istream class , Iterating lists , Iterator classes , Iterators , types of , Jump table , function , Keys and adapter classes , and associative containers , hash , representing pairs of , and sets and multisets , unique and ambiguous , Keyword , Labels and goto statement , Laborer class , standard assignment for , Layout and program flow , of source files , Left shift operators , left manipulator , Legibility , Length , of container , class , method , symbols , Libraries functions in , Lifetime object , static , LIFO principle , Lights class , limits header file , Linear solution , Line feed , function , Linked lists , advantages with , defining , representing , Linker , List class class definition for , of , list container class , constructors of , for deleting objects in , List elements , inserting in middle of inhomogeneous list , inserting  representing , List operations sample program , Lists representing , sorting , inverting , and splicing , Literals , Local objects , Local variables , LOCATE macro , Logarithmic runtimes , Logical bitwise operators , Logical expressions examples for , Logical operators , Logical shifts , exception classes derived from , long double type , long type , Loop body , Loops , Macro definition visibility for , Macros calling with arguments , and case conversion , for character , defining , in different source files , within header files , and inline functions , redefining , sample program , for screen control , Macros with parameters sample program , function , parameters of , structure of , MAKE utility , for module management , INDEX Manipulators , calling , numbers formatting , and integers formatting , for output in fields , Maps and associative containers , representing , using , Masks , bit , Mathematical rules and expressions , Mathematical standard functions , MathError exception class , header file , Matrix , Matrix class , constructor , destructor , and subscript operator for , Member arrays , Member functions , Member initializers , Member objects , constant , initializing , Members , redefining , Member , Memory allocating , objects in , releasing , union and usage of , Memory address for object of class , method for merging list containers , of SortVec container class , function , Methods , calling , of class template , const and versions of , and data members , defining , global functions versus , name lookup for , operator functions as , operators overloadable by , positioning , pure virtual , standard , function template , MIN macro , Modifiers signed and unsigned , Modular programming , Modules , MotorHome class , method and BitmapN container class , Multidimensional arrays defining , as parameters , sample program , Multimaps , using , Multiple assignments , Multiple indirect base classes , Multiple inheritance , constructor calls , initializing virtual base classes , multiple identical base classes , multiple indirect base classes , classes , virtual base classes , Multiple template parameters , classes , multiset container class , Multisets , declaring , sample , Names and naming arrays , constructors , declaring , file , macros , operator functions , source file , valid , of variables , namespace keyword , Namespaces defining , array , Negation , Negative numbers converting , outputting as decimals , Nested statements , Nested namespaces , Nesting exception handling , Nesting loops ,  characters ,  calling for fundamental types , calling with default constructor ,  noboolalpha manipulator , Nongraphic characters , manipulator , NOT  nouppercase manipulator , NULL , Null character , NULL pointer , Numbers formatted input of , Number symbol , Numerical constants , Numeric operations exception handling for , programming , Object persistence , Objects , accessing , as arguments , assigning , cleaning up , creating with dynamic members , declaring , defining , of derived classes , explicit initialization of , initializing , lifetime of , local , member , in memory , passing as arguments , passing by reference , passing by value , pointers to , references returned to , representing pairs of , returning , static , storage classes of , storing , of union WordByte in memory , using ,
See also Classes ; References Obligatory arguments , Octal constant , Octal numbers outputting , oct manipulator , OFF constant , ofstream class , ON constant , OOP .
See programming method , Open mode flags , Open modes , of file , Operands and order of evaluation , symmetry of , Operations file , for sequences , Operator functions , calling , declaration of , defining global , definition of , INDEX global or method , as methods , naming , negation , addition , and subtraction , keyword , Operators bitwise , for classes , and complex declarations , dot , indirection , overloadable , overloading , with pointer variables , reference type , in template functions , unary , Operators for fundamental types binary arithmetic operators , operators , logical operators , relational operators , sign operators , unary arithmetic operators , Optional arguments , OR operator , ostream class , out constant , Output redirecting standard , stream classes for , streams , class , Overloaded operators rules for , using , Overloading assignment operator , functions , operators , and redefinition , shift operators for , subscript operators , Parameters , declaring , multidimensional arrays as , pointers as , pointers as , Parentheses in syntax description , Parity bit computation , function , PassCar versions of , PassCar class virtual method table for , PassCar derived class , Passing arguments to function templates , Passing by reference , Passing by value , Persistence object , of polymorphic objects , Pixels , Pointer arithmetic , Pointer arrays generating dynamically , Pointer assignment effect of , Pointers , to abstract classes , as arguments , array elements interrelated with , arrays of , comparing , to const objects , defining , defining arrays of , to functions , moving in array , NULL , to objects , as parameters , parameters declared as , returning , sample program , subtracting , typeless , use of , instead of indices , Pointers to pointers , Pointer types , Pointer variables , addressing with , and arrays , Polymorphic interfaces , Polymorphic objects persistence of , storing , Polymorphism , concept of , destroying dynamically allocated objects , dynamic casts , virtual methods , virtual method table , method for deleting objects in container classes , method , method , Positioning flags , Positioning methods , Positive numbers converting to , Postfix increment , Postfix notation , effects of , Precedence of arithmetic operators , and arithmetic type conversions , of Boolean operators , for cast operator , for comma operator , for indirection operator , operator , for operators with pointer variables , of relational operators , method , Prefixes , Prefix increment , Prefix notation , effects of , Preprocessor , Preprocessor directives , Primary file , within index file , function , Priority queues , testing , template , Private data members accessing , Private members , Procedures , Program scope object defined with , Projects , Properties , protected constructors , Protected declarations , Protected members , Prototype , public base classes is relationship established by , Public interface , of class , Public members , access to , in base class , Public methods , Pure virtual methods ,

Resistant mistakes program with , method and container classes , Result class , constructors for , new of , with static members , with static methods , method , of IndexFileSystem class , Return address , return statement , Return values , Reusability , function , method , method , Right shift operators , Round brackets , Routers , Row class defining , RTTI .
See Run Time Type Information Runtime behavior of container classes , Run time errors , avoiding , exception classes derived from , Run Time Type Information , Safe class , SavAcc class defining , scientific manipulator , Scope , Scope resolution operator , Screen control macros , Scrolling string output ,

Semicolon , Sequences and header files , operations for , representing , Sequential containers , Sequential file access , set container class ,

Sets associative containers within , declaring , representing , sample , method , manipulator , Shape type , Sheltered members access to , Shift operators , short type , showpos manipulator calling , Side effects avoiding , of macros , Sieve of Eratosthenes , header file , Signatures constructor , function , signed char type , Signed integers converting , signed keyword , Signed type conversion of , to larger integral type , Sign extension , Sign operators , Simple assignments , Single characters meaning of , Single quotes character constants within , method and length of container , and , and number of objects in container , sizeof operator , method list container sorted by call to , SortVec container class method of , method of , using , Source code , Source files , layout of , name , INDEX Spaces , Special characters , Special objects , of base class , function , Splice operations , function , function , sstream class , Stack class template , explicit instantiation for , with two template parameters , Stack content after calling function , Stacks , arguments on , and recursive functions , as sequential containers , testing , Standard copy constructor , Standard exception classes hierarchy of , using , Standard exception handling for streams , Standard input , Standard methods , sample program , Standard output , Standard settings , Star character , State flags , Statements , Static arrays , Static binding , Static data members , accessing , declaring , definition and initialization , and encapsulation , Static data structures , Static functions , static keyword , Static lifetime , Static member functions , Static objects , static storage class , std standard namespace , Storage classes , of functions , Storage class specifiers , function and return pointers , function , index version of , function , pointer versions of , and return pointers , Stream access errors , Stream class shift operators , streambuf class , Streams , status of , standard , standard exception handling for , String assignments , string class , strings and , defining , objects of , sample assignments of , sample program , String constants , String literal internal representation of , Strings characters accessed in , comparing , concatenating , escape sequences used in , initializing , inserting and erasing in , numbers converted to , output of , searching and replacing in , stringstream class , function , Stroustrup , Bjarne , function sample program , struct keyword , structs sample program , Style , lattice , Subroutines , Subscript , Subscript operators , and access via indices , bits referenced by , in Matrix class , overloading , read and write access using , Substrings erasing , replacing , Subtraction , implementing as method , function , Swapping , switch statement , chains contrasted with , structogram for , Symbolic constants , method , Syntax , brackets in descriptions , for defining variables , errors , Tabs , function , method , TelList class , methods implemented for , method , Template arguments restrictions on , Template function definition , Template functions motivation for , Template parameters multiple , restrictions on , Templates , advantages of , arguments , in standard library , default arguments of , defining , defining with multiple parameters , function and class , instantiating , parameters , specialization , function , Testing characters , Text mode , and nesting loops , Text editor , this pointer sample class DayTime , using , Throwing exceptions , throw statement , using , function , function , type , tm struct , Tokens , Tone and nesting loops , method , macro , Traditional procedural programming , Translation unit , true keyword , trunc open mode , Truth table for logical operators , try block , nested , syntax of , arrays initialization list of , parameter declaration for , Type casting , Type conversion for classes , ambiguities of type conversions , conversion constructors , conversion functions , INDEX Type conversions , ambiguities of , in assignments , explicit , failure , implicit , standard , usual arithmetic , typedef keyword , Type hierarchy , Typeless pointers , Typenames defining , Types , platform dependent , pointer , Unary arithmetic operators , Unary operators , class , directive , Underscores and internal names , Unicode , Union , defined , Unique keys , method , unsigned char type , unsigned keyword , unsigned short , Unsigned types , Unsigned value , Unwinding the stack , Upcasting , User Network Interface , using declaration , using directive , using keyword , Usual arithmetic type conversions , performing , macro arguments of , valarray class , Variables defining , defining in if statements , names of , pointer , sample program , Variable type , Vector , vector container class , constructors of , methods for deleting objects in , Vectors iterating , Virtual assignments using , Virtual base classes , constructor calls in , initializing , Virtual destructors declaring , virtual keyword , Virtual methods , calling , declaring , pure , redefining , Virtual method tables , Virtual operator functions , VMT .
See Virtual method tables void type , for functions , type pointer , volatile keyword , Warnings , type , method , virtual method , while statement structogram for , structogram for break within , syntax for , Whitespace characters , Width , method , Wordbyte union , Write access open mode for , method , WriteError type exception , method , of classes DepAcc and SavAcc , Write operation , Writing blocks of records , characters , XOR operator , Zero extension , INDEX .
