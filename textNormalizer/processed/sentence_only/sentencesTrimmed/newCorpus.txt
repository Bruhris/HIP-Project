Practical Programming Steve Oualline Associates , Inc .

Beijing Cambridge KÃ¶ln Paris Sebastopol Taipei Tokyo Page iv Practical Programming by Steve Oualline Copyright Associates , Inc .
All rights reserved .

Printed in the United States of America .

Editors : Adrian Nye and Dale Dougherty Production Editor : Nicole Gipson Printing History : August First Edition .

January : Minor corrections .

Nutshell Handbook , the Nutshell Handbook logo , and the logo are registered trademarks and The Java Series is trademark of Associates , Inc .

Many of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks .
Where those designations appear in this book , and Associates , Inc .

While every precaution has been taken in the preparation of this book , the publisher assumes no responsibility for errors or omissions , or for damages resulting from the use of the information contained herein .

This book is printed on paper with recycled content , waste .

Associates is committed to using paper with the highest recycled content available consistent with high quality .

Page xv Preface This book is devoted to practical programming .
It teaches you not only the mechanics of the language , but also style and debugging .
The entire life cycle of program is discussed , including conception , design , writing , debugging , release , documentation , maintenance , and revision .

Style is emphasized .
Creating good program involves more than just typing code .
It is an art in which writing and programming skills blend to form masterpiece .
program not only functions correctly , but also is simple and easy to understand .
Comments allow programmers to include descriptive text in their programs .
Clearly written , programs are highly prized .

program should be as simple as possible .
Avoid the use of clever tricks .
Cleverness and complexity can kill programs .
This book stresses simple , practical rules .
For example , the rules in can be simplified to :
Multiply and divide before you add and subtract .

Put parentheses around everything else .

One was written by clever programmer , using all the tricks .
The program contains no comments , but it works .
The other is nicely commented and well structured , but work .
Which program is more useful .
In the long run , the " one is more useful because it can be fixed and maintained easily .
Although the clever one works now , sooner or later it will have to be modified .
The hardest work you will ever have to do is modifying cleverly written program .

Page xvi Scope of This Handbook This handbook is written for people with no previous programming experience , for programmers who know and want to upgrade their skills to , and for those who already know and want to improve their programming style and reliability .
You should have access to computer and know how to use the basic functions such as the text editor and file system .

Computer languages are best learned by writing and debugging programs .
Sweating over broken program at two in the morning only to find that you where you should have is very effective teaching tool .
Many programming examples are used throughout this book .
Most of them contain deliberate errors .
You are encouraged to enter the examples into your computer and then run and debug them .
This process introduces you to common errors using short programs so you will know how to spot and correct such errors in your own larger programs .

" UNIX compiler that should work on most UNIX systems .

Visual for As far as standard is concerned there are only minor differences among the various compilers .
This book clearly indicates where compiler differences can affect the programmer .

Specific instructions are given for producing and running programs using each of these compilers .
The book also gives examples of using the programming utility make for automated program production .

How This Book Is Organized You must crawl before you walk .
In Part : The Basics you learn how to crawl .
These chapters teach you enough to write very simple programs .
You start with the mechanics of programming and programming style .
Next , you learn how to use variables and very simple decision and control statements .

Page xvii At this point you will have learned enough to create very simple programs ; therefore , in Chapter , The Programming Process , you embark on complete tour of the programming process that shows you how real programs are created .

Chapter , What Is , gives you an overvie ins the basic programming process and gives you enough information to write very simple of , describes its history uses , explains how the language is organized .

Chapter , The Basics Program Writing , expla Chapter , Style , discusses programming style .
Ho Chapter , Basic Declarations Expressions , int to comment program is covered , as well as how to write clear simple code .
Basic variables the assignment statement are covered in detail along with the arithmetic operators : +

Chapter , Arrays , Qualifiers , Reading Numbers , covers arrays more complex variables .
The shorthand operators ,  are described .

Chapter , Decision Control Statements , explains simple decision statements including if , else for .
The problem is discussed .

Chapter , The Programming Process , takes you through the steps required for creating simple program , from specification through release .
Structured programming , fast prototyping , debugging are discussed .

Part II : Simple Programming , describes all the other simple statements operators that are used in programming .
You also learn how to organize these statements into simple functions .

Chapter , More Control Statements , describes additional control statements .
Included are while , break , continue .
The switch statement is discussed in detail .

Chapter , Variable Scope Functions , introduces local variables , functions , parameters .

Chapter , The Preprocessor , describes the preprocessor , which gives you great flexibility in creating code .
It also provides tremendous number ways for you to screw up .

Simple rules that help keep the preprocessor from becoming problem are described .

Chapter , Bit Operations , discusses the logical operators that work on bits .

In Part III : Advanced Types Classes , you learn how basic declarations statements can be used in the construction advanced types such as structures , unions , classes .
You also learn about the concept pointers .

Page xviii Chapter , Advanced Types , explains structures other advanced types .
The sizeof operator the enum type are included .

Chapter , Simple Classes , introduces the concept class .
This is one the more powerful features .
Classes allow you to group data the operations that can be performed on that data into one object .

Chapter , More on Classes , describes additional operations that can be performed with classes .

Chapter , Simple Pointers , introduces pointer variables shows some their uses .

Advanced programming techniques are explored in Part IV : Advanced Programming Concepts .
In this section , you explore number features that let you create complex , yet objects or classes .

Chapter , File , describes both buffered unbuffered .

ASCII binary files are discussed you are shown how to construct simple file .
Old operations are also included .

Chapter , Debugging Optimization , describes how to debug program , as well as how to use an interactive debugger .
You are shown not only how to debug program , but also how to write program so that it is easy to debug .
This chapter also describes many optimization techniques to make your programs run faster more efficiently .

Chapter , Operator Overloading , explains that allows you to extend the language by defining additional meanings for the operators .
In this chapter , you create complex type the operators that work on it .

Floating Point , uses simple decimal format to introduce the problems inherent in using floating points , such as roundoff errors , precision loss , overflow , underflow .

Chapter , Advanced Pointers , describes advanced use pointers to construct dynamic structures such as linked lists trees .

Chapter , Advanced Classes , shows how to build complex , derived classes out simple , base ones .

Finally number miscellaneous features are described in : Other Language Features .

Chapter , Exceptions , explains how to handle unexpected conditions within program .

Page xix Chapter , Modular Programming , shows how to split program into several files use modular programming techniques .
The make utility is explained in more detail .

Chapter , Templates , allows you to define generic function or class that generates family functions .

Chapter , Portability Problems , describes the problems that can occur when porting program program from one machine to .

Chapter , Putting It All Together , details the steps necessary to take complex program from conception to completion .
Information hiding modular programming techniques , as well as programming , are stressed .

Chapter , From to , describes how to turn code into code , addresses many the traps lurking in code that bite the programmer .

Chapter , Dustier Corners , describes the statement , the comma operator , the : operators .

Chapter , Programming Adages , lists programming adages that will help you construct good programs .

Appendix , ASCII Table , contains list character codes their values .

Appendix , Ranges , lists the numeric ranges some variable types .

Appendix , Operator Precedence Rules , lists the rules that determine the order in which operators are evaluated .

Appendix , Computing sine Using Power Series , contains program that shows how the computer can compute the value the sine function .

How to Read This Book If You Already Know is built on the language .
If you know , you will find much the material presented in Chapters through familiar .

does introduce number new 

An entirely new system .
The new system is discussed in detail in Chapter , File .

Constant reference variables .

Function overloading , inline functions , reference parameters , default parameters .

Classes are unique to are one the more powerful the language .

Font Conventions The following conventions are used in this book : Italic is used for directories and to emphasize new and when they are introduced .

Italic is also used to highlight comments in examples .

Bold is used for keywords .

Constant Width is used for programs and the elements of program and in examples to show the contents of files or the output from commands .
reference in text to word or item used in an example or code fragment is also shown in constant width font .

Constant Bold is used in examples to show commands or other text that should be typed literally by the user .

We usually use this for examples that should be executed only by root .

Page xxi surround optional values in description of program syntax .

The notation or indicates use of control characters .
It means hold down the " key while typing the character .
We denote other keys similarly , RETURN indicates carriage .

All examples of command lines are followed by RETURN unless otherwise indicated .

Obtaining Source Code You can obtain the source code for the programs presented in this book from Associates through their Internet server .

The example programs in this book are available electronically in number of ways : by FTP , Ftpmail , BITFTP , and UUCP .
The cheapest , fastest , and easiest ways are listed first .
If you read from the top down , the first one that works for you is probably the best .
Use FTP if you are directly on the Internet .
Use Ftpmail if you are not on the Internet , but can send and receive electronic mail to Internet sites includes CompuServe .
Use BITFTP if you send electronic mail via BITNET .
Use UUCP if none of the above works .

FTP To use FTP , you need machine with direct access to the Internet .
sample session is shown , with what you should type in boldface .

Name : anonymous Guest login ok , send domain style address as password .

You must specify binary transferfor Type set to .

Page xxii quit Goodbye .

This includes any company or service provider that allows email connections to the Internet .

In the message body , give the FTP commands you want to run .
The server will run anonymous FTP for you and mail the files back to you .
To get complete help file , send message with no subject and the single word " in the body .

The following is sample mail session that should get you the examples .
This command sends you listing of the files in the selected directory and the requested example files .
The listing is useful if later version of the examples interested in .

BITFTP BITFTP is mail server for BITNET users .
You send it electronic mail messages requesting files , and it sends you back the files by electronic currently Page xxiii serves only users who send it mail from nodes that are directly on BITNET , EARN , or NetNorth .
BITFTP is public service of Princeton University .
how it works .

To use BITFTP , send mail containing your ftp commands to .
For complete help file , send HELP as the message body .

The following is the message body you send to BITFTP : FTP NETDATA USER anonymous CD DIR BINARY GET QUIT Once got the desired file , follow the directions under FTP to extract the files from the archive .
Since you are probably not on UNIX system , you may need to get versions of uudecode , uncompress , atob , and tar for your system .
VMS , DOS , and Mac versions are available .

UUCP UUCP is standard on virtually all UNIX systems and is available for PCs and Apple Macintoshes .
The examples are available by UUCP via modem from UUNET ; charges apply .

You can get the examples from UUNET whether you have an account there or not .
If you or your company has an account with UUNET , you have system somewhere with direct UUCP connection to UUNET .
Find that system , and type : uucp The backslashes can be omitted if you use the Bourne shell instead of csh .
The file should appear some time later to day or in the directory yourname .
If you have an account , but would like one so that you can get electronic mail , contact UUNET at .

good idea to get the file as short test file containing the filenames and sizes of all the files available .

Once got the desired file , follow the directions under FTP to extract the files from the archive .

Page xxiv Comments and Questions Please address comments and questions concerning this book to the publisher : Associates , Inc .

Special thanks to Dale Dougherty for ripping apart my first book and forcing me to put it together correctly .
greatly appreciate the hard work put in by Phil Straite and Gregory Satir .
especially thank all those people who reviewed and edited my book .
My thanks also go to the production group at Gipson , project manager and production editor ; John Files , Juliette Muellner , and Jane Ellln , production assistants ; and Mike Sierra , book design implementor .

Finally , special thanks go to all the programmers out there whose code has taught me so much .

Page The Basics Page What Is .

Brief Histoty of .

How to Learn Profanity is the one language that all programmers understand .

Computers are designed to handle and process large amounts of information quickly and efficiently .

is programming that allows software engineer to efficiently communicate with computer .

is highly flexible and adaptable .
Since its creation in , it has been used for wide variety of programs including firmware for , operating systems , applications , and graphics programming .
is quickly becoming the programming of choice .
There is tremendous demand for people who can tell computers what to do , and lets you do so quickly and efficiently .

Brief History of In two programmers , Brian Kernighan and Dennis Ritchie , created new called .
The was extremely simple and flexible and soon was used for many different types of programs .
It quickly became one of the most popular programming languages in the world .

Page had one major problem , however .
It was .
This meant that in designing typical program , the programmer would start by describing the data and then write procedures to manipulate that data .
Programmers eventually discovered that it made program clearer and easier to understand if they were able to take bunch of data and group it together with the operations that worked on that data .
Such grouping is called an object or class .
Designing programs by designing classes is known as design .

In Bjarne Stroustrup started working on new  called with " This improved on by adding number of new  the most important of which was classes .
This was improved , augmented , and finally became .

owes its success to the fact that it allows the programmer to organize and process information more effectively than most other languages .
Also , it builds on the work already done with the .
In fact , most programs can be transformed into programs with little trouble .
These programs usually use all the new of , but they do work .

In this way , allows programmers to build on an existing base of code .

Organization is designed as bridge between the programmer and the raw computer .
The idea is to let the programmer organize program in way that he or she can easily understand .
The compiler then translates the into something the machine can use .

Computer programs consist of two main parts : data and instructions .
The computer imposes little or no organization on these two parts .
After all , computers are designed to be as general as possible .
The idea is for the programmer to impose his or her own organization on the computer and not the other way around .

The data in computer is stored as series of bytes .
organizes those bytes into useful data .
Data declarations are used by the programmer to describe the information he or she is working with .

You can let the compiler decide what particular bytes of memory to use ; minor bookkeeping detail you need to worry about .

Page The variable total is simple variable .
It can hold only one integer and describe only one total .
series of integers can be organized into an array .
Again , will handle the .

Width of rectangle in pixels Height of rectangle in pixels Color of the rectangle Fill pattern However , data is only one part of program .
You also need instructions .
As far as the computer is concerned it knows nothing about the layout of the instructions .
It knows only what doing for the current instruction and where to get the next instruction .

is .
It lets you write statement such .

The compiler translates this statement into series of cryptic machine instructions .
This sort of statement is called an assignment statement .
It is used to compute and store the value of an arithmetic expression .

You can also use control statements to control the order of processing .
Statements such as the if and switch statements enable the computer to make simple decisions .
Statements can be repeated by using looping statements such as while and for .

Groups of statements can be wrapped to form functions .
Thus you only need to write function to draw once and then you can reuse that function whenever you want to draw new .
provides rich set of standardfunctions that perform common functions such as searching , sorting , input , and output .

set of related functions can be grouped together to form module , and modules are linked to form programs .

One of the major goals of the is to organize instructions into reusable components .
After all , you can write programs much faster if you " most of your code from somewhere else .
Groups of reusable modules can be combined into library .
For example , if you need sort routine , you can use the standard function qsort from the library and link it into your program .

Page computer divides the world into data and instructions .
For long time , highlevel languages such as kept that dividing line in place .
In you can define data or write instructions , but you combine the two .

One of major innovations is the idea of combining data and instructions together in construct called class or object .
programming allows you to group data with the operations that can be performed on that data .
This concept is taken one step further in by allowing you to derive new from existing ones .

This last feature is extremely powerful .
It allows you to build complex on top of smaller , simpler ones .
It also allows you to define basic , abstract class and then derive specific from it .
For example , an abstract class of shape might be used to define the shapes  triangle , and circle .

Organization is the key to writing good programs .
In this book , you know that the table of contents is in the front and the index is in the back , because the way books are organized .

Organization makes this book easier to use .

The lets you organize your programs using simple yet powerful syntax .
This book goes beyond the syntax and teaches you style rules that enable you to create highly readable and reliable programs .
By combining powerful syntax with good programming style you can create powerful programs that perform complex and wonderful operations .

How to Learn The only way to learn how to program is to write programs .
learn lot more by writing and debugging programs than you ever will by reading this book .
This book contains many programming exercises , and you should try to do as many of them as possible .
When doing the exercises keep good programming style in mind .
Always comment your programs , even if doing the exercises only for yourself .
Commenting helps you organize your thoughts , let yourself be seduced by the idea that , only writing these programs for myself , so need to comment " First of all , code that looks obvious to you when you write it can often be confusing and cryptic when you revisit it week later .
Writing comments also helps you organize your ideas .
once wrote program that was designed to work only on the computer at Caltech .
The program was highly system dependent .

As was the only one who would ever Page use the program , the program would print the following message if got the command line wrong : User is twit few years later was student at Syracuse University .
The secretary at the School Computer Science needed program that was similar to my Caltech listing program , so adapted my program for her use .
Unfortunately , had forgotten about my funny little error message .

Imagine how horrified was when came into the Computer Science office and was accosted by the chief secretary .
This lady had so much power she could make the dean cringe .
She looked at me and said , is twit , Luckily she had sense humor , or might not be here today .

Sprinkled throughout this book are " programs .
Spend the time to figure out why they work .
Often the problem is very subtle , such as misplaced semicolon or instead .
These programs let you learn how to spot mistakes in small program .
That way when you make similar mistakes in big program , and you will make mistakes , you will be trained to spot them .

Page The Basics Program Writing In This .

Programs from Conception to Execution .

Creating Real Program .

Creating Program Using CommandLine Compiler .

Creating Program Using an Integrated Development Environment .

Programming Exercises The first and most important thing all , at least for writers today , is to strip language clean , to lay it bare down to the bone Hemingway Computers are very powerful tools that can store , organize , and process tremendous amount information .
However , they do anything until someone gives them detailed instructions .

Communicating with computers is not easy .
They require instructions that are exact and detailed .
life be easier if we could write programs in English .
Then we could tell the computer , up all my checks and deposits , and then tell me the " and the machine would balance our checkbooks .

But English is lousy language when you must write exact instructions .
The language is full ambiguity and imprecision .
Grace Hopper , the grand old lady computing , once commented on the instructions she found on bottle shampoo : Wash Rinse Repeat She tried to follow the directions , but she ran out shampoo .

Of course , we can try to write in precise English .
have to be careful and make sure to spell everything out and be sure to include instructions for every contingency .
If we worked really hard , we could write precise English instructions , right .

Page As it turns out , there is group people who spend their time trying to write precise English .

called the government , and the documents they write are called government regulations .

Unfortunately , in their effort to make the regulations precise , the government also has made the documents almost unreadable .
If ever read the instruction book that comes with your tax forms , you know what precise English can be like .

Still , even with all the extra verbiage the government puts in , problems can occur .
few years ago California passed law requiring all motorcycle riders to wear helmet .
Shortly after this law went into effect cop stopped guy for not wearing helmet .
The man suggested the police officer take closer look at the law .

The cop give the motorcyclist ticket because the man did have helmet firmly strapped his knee .

So English , with all its problems , is out as computer language .
Now , how do we communicate with computer .

The first computers cost millions dollars , while at the same time good programmer cost about year .
Programmers were forced to program in language where all the instructions were reduced to series numbers , called machine language .
This language could be directly input into the computer .
typical program looks like :
To program these ancient machines , software engineers would write out their programs simple language where each word would stand for single instruction .
This was called assembly language because the programmers had to manually translate , or assemble , each line into machine code .

typical program might look like : Program Translation MOV ADD HALT .

Translation was difficult , tedious , exacting task .
One software engineer decided this was perfect job for computer , so he wrote program , called an assembler , that would do the job automatically .

Page Figure .
Assembling program He showed his new to his boss and was immediately chewed out : dare you even think such an expensive machine for mere ' Given the cost an hour computer time versus the cost an hour time , this was not an unreasonable attitude .

Fortunately , as time passed the cost programmers went up and the cost computers went down .
So it became more to let the programmers write programs in assembly language and then use program called an assembler to translate the programs into machine language .

Assembly language organized programs in way that was easier for the programmers to understand .
However , the program was more difficult for the machine to use .
The program had to be translated before the machine could execute it .
This was the start of trend .
Programming languages became more and more convenient for programmers to use and started requiring more and more computer time to translate them into something useful for computers .

Over the years series of languages has been devised .
These languages are attempts to let programmers write in something that is easy for them to understand and that is also precise and simple enough for computers to understand .

Early languages were designed to handle specific types of applications .
FORTRAN was designed for number crunching ; COBOL , for writing business reports ; and PASCAL , for student use .
It is rumored that Nicklaus Wirth has said , had known that PASCAL was going to be so successful , would Later on , Brian Kernighan and Dennis Ritchie developed and Bjarne Stroustrup turned it into .

Page Programs from Conception to Execution programs are written in language using letters , numbers , and the other symbols you find on computer keyboard .
Computers actually execute very language called machine code series of .
So , before program can be used , it must undergo several transformations .

Programs start out as an idea in head .
He writes down his thoughts in file , called sourcefile or source code , using text editor .
This file is transformed by the compiler into an objectfile .
Next program called the linker takes the object file , combines it with predefined routines from standard library , and produces an executable program set of .
In the following sections , see how these various forms of the program work together to produce the final program .

Figure shows the steps that must be taken to transform program written in language into an executable program .

Figure Transformation of language into program Wrappers Fortunately you have to run the compiler , assembler , and linker individually .
Most compilers use " programs , which determine which tools need to be run and then run them .

Page Some programming systems go even farther and provide the developer with an integrated development environment .
The IDE contains an editor , compiler , linker , project manager , debugger , and more in one convenient package .
Both Borland and Microsoft provide IDES with their compilers .

Creating Real Program Before you can actually start creating your own programs you need to know how to use the basic programming tools .
This section will take you step by step through the process of entering , compiling , and running simple program .

This section describes how to use two different types of compilers .
The first type is the standalone or compiler .
This type of compiler is operated in batch mode from the command line .
In other words , you type command and the compiler turns your source code into an executable program .
The other type of compiler is contained in an IDE .

Most UNIX systems use compilers .
few compilers are available for UNIX , but they are rare .
On the other hand almost all the compilers used with and Windows contain an integrated development environment .
For , these compilers do contain compilers as well .

Creating Program Using Compiler In this section go through the process needed to create program using compiler .
Instruction is given for using generic UNIX compiler , the Free Software compiler , Borland , and Microsoft Visual .

However , if you are using Borland or Microsoft compiler , you might want to skip ahead to the section on using the IDE .

Step : Create Place for Your Program It is easier to manage things if you create separate directory for each program you are working on .
In this case create directory called hello to hold your hello program .

In UNIX , type : mkdir hello cd hello Page In , type : MKDIR HELLO : CD HELLO Step : Create the Program program starts out as text file .
Example shows the hello program in source form .

Example Source for the program .

Use your favorite text editor to enter the program .
In UNIX your file should be named and in the file should be named .

WARNING users should not use program such as Microsoft Word or WordPerfect to write their programs .
programs add formatting codes to the file that confuse the compiler .
You must use text editor such as the EDIT program that is capable of editing ASCII files .

Step : Run the Compiler The compiler changes the source file you just created into an executable program .
Each compiler has different command line .
The commands for the most popular compilers are listed below .

Most compilers follow the same generic standard .
The compiler is named CC .

To compile our hello program we need the following command : CC The option enables debugging .
See your compiler manual for details on all the possible options .
There are several different compilers for UNIX , so your command line may be slightly different .

Page Free Software Compiler The Free Software Foundation , the GNU people , publishes number of programs .

To compile program using the compiler , use the following command line : The additional switch turns on all the warnings .

Turbo in Borland International makes compiler called .
This compiler is ideal for learning .
The command line for is : tcc The tells to use the large memory model .
This book discusses none of them .
Instead we take the attitude , large and worry about it until you become an The switch tells to put debugging information in the program .
Warnings are turned on by ; stack checking by .
The compiler will actually compile both and .

We force compile using the switch .
Finally , tells to create program named hello , and is the name of the source file .
See the reference manual for complete list of options .

Borland in and Windows In addition to , Borland International also makes , professional compiler for called Borland .
Its command line is : bcc The options are the same for both and Borland .

Microsoft Visual Microsoft Visual is another compiler for .
It is not as robust or full featured as its Borland counterpart , but it will compile most of the programs in this book .

To compile , use the following command line : cl Page The option tells the program to use the large memory model .
Debugging is turned on with the option and warnings with the option .

Step : Execute the Program Now , when you run the program by typing , for example : hello at the UNIX or prompt , the message : Hello World will appear on the screen .

Creating Program Using an Integrated Development Environment Integrated development environments provide shop when it comes to programming .

They take compiler , editor , and debugger and wrap them into one neat package for the programmer .

Since development environments tend to change , the particular version you use may require slightly different keystrokes .

Create Place for Your Program It is easier to manage things if you create separate directory for each program you are working on .
In this case create directory called HELLO to hold your hello program .

In , type : MKDIR HELLO : CD HELLO Step : Enter , Compile , and Run Your Program Each IDE is little different , so included separate instructions for each one .

Start the IDE with the command : TC .
Use the Options Compiler Code Generation command to pull up the Code Generation dialog box as seen in Figure .
Change the memory model to large .

Use the Options Compiler command to turn stack checking on , as shown in Figure .

Page Figure .
Code Generation dialog box Figure .
Code Generation dialog box .
Use the Options Compiler Messages Display command to bring up the Compiler Messages dialog box as seen in Figure .
Select All to display all the warning messages .

Use the Options Save command to save all the options used so far .

Page Figure .
Compiler Messages dialog box .
Use the Open Project File dialog box to select project file .
In this case your project file is called .
The screen should look like Figure when finished .

Figure Open Project File dialog box .
Press the Insert key to add file to the project .
The file you want to add is as seen in Figure .

Page Figure .
Add to Project List dialog box .
Press ESC to get out of the file " cycle .

Press the key to go up one line .
The line with should now , be highlighted as seen in Figure .

Figure .
Press Return to edit this file .

Finished project .
Use the Run Run command to execute the program .

After the program runs , control returns to the IDE .
This means that you see what your program output .
To see the results of the program you must switch to the user screen using the command Window User .
Pressing any key will return you to the IDE .
Figure shows the output of the program .

When you are finished you can save your program with the File ISave command .

To exit the IDE use the File Quit command .

Page Figure .
User screen Borland .
Create directory called HELLO to hold the files for our hello program .
You can create directory using the Windows ' File Manager Program or by typing the following command at the prompt : mkdir .
From Windows , on the Borland icon to start the IDE The program begins execution and displays blank workspace as seen in Figure .

Select the Project New Project item to create project for our program .
Fill in the Path and " blank with .
For the Target Type select .

The Target Model is set to Large .
The results are shown in Figure .

Click on the Advanced button to bring up the Advanced Options dialog .
Clear the and items as shown in Figure .

Click on OK to return to the New Target dialog .

Press to bring up node shown in Figure .

Select Edit Node Attributes to bring up the dialog shown in Figure .
In the Style Sheet blank , select the item Info and " Click on OK to return to the main window .

Page Figure Borland initial screen .

Figure Node Attributes dialog box .
Go to the Project Options dialog by selecting the Options Project Options item .
Go down to the Compiler item and click on the " to expand the options .

Turn on the Test stack overflow option shown in Figure .
Click on OK to save these options .

Click on OK to return to the main window .
Press the down arrow to select the item in the project in Figure .

Press Return to start editing the file .
Type in the following .

When you have finished , your screen will look like Figure .

Compile and run the program by selecting the Debug Run menu item .
The program will run and display World " in window , as shown in Figure .

Page Figure Project Options dialog box .

Page Microsoft Visual .
Create directory called HELLO to hold the files for our hello program .
You can create directory using the Windows File Manager Program or by typing the following command at the prompt : mkdir .
From Windows , on the Visual icon to start the IDE .
blank workspace will be displayed as shown in Figure .

Figure Microsoft Visual initial screen .
Click on Project New to bring up the New Project dialog shown in Figure .

Fill in the Project Name blank with .
Change the Project Type to QuickWin application .

Visual goes to the Edit dialog to allow you to name the source files in this project Figure .
In this case we have only file .
Click on Add to enter the name in the project and then click on Close to tell Visual that there are no more files in the program .

Select Options Project Options to bring up the Project Options dialog shown in Figure .

Click on the Compiler button to change the compiler options .

Page Figure Project create screen .

Figure Project Options dialog box .
Go down to the Custom Options item in the Category and change the warning level to as shown in Figure .

Change to the Memory Model category and change the memory model to large Figure .

Close the dialog by clicking on the OK button .
This brings you back to the Project Options dialog .
Click on OK to dismiss this dialog as well .

Select New " to start new file .
Type in the following .

Your results should look like Figure .

Use the File Save As menu item to save the file under the name .

Use the Project Build command to compile the .
The compiler will output messages as it builds .
When it is finished your screen should look like Figure .

Page Figure Compiler Options dialog box .

The can now be started with the Debug Go command .
The results appear in Figure .

Figure World " results Getting Help in UNIX Most UNIX systems have an online documentation system called the " These can be accessed with the man command .
This item activates Help system .

Programming Exercises Exercise : On your computer , type in the hello and execute it .

Exercise : Take several programming examples from any source , enter them into the computer , and run them .

Page Style In This .

Indentation and Code Format .

Consistency and Organization .

Summary There is no programming language , no matter how structured , that will prevent programmers from writing bad programs .
Flon It is the nobiliy , of their style which will make our writers of unreadable forty years from now This chapter discusses how to use good programming style to create simple .
Style is what separates the gems from the junk .
It is what separates the programming artist from the butcher .
You must learn good programming style first , before typing in your first line of code , so everything you write will be of the highest quality .

Contrary to popular belief , programmers do not spend most of their time writing programs .
Far more time is spent maintaining , upgrading , and debugging existing code than is ever spent on creating new .
The amount of time spent on maintenance is skyrocketing .
From to the average number of lines in typical application went from to million .
The average system age has gone from to years .

To make matters worse , of the managers surveyed at the Annual Meeting and Conference of the Software Maintenance Association reported that they systems in their department that have to be maintained by specific individuals because no one else understands Page Most software is built on existing software .
recently completed coding for new .

Only one of these was created from scratch ; the other are adaptations of existing .

Programmers believe that the purpose of is only to present the computer with compact set of instructions .

Programs written only for the machine have two .

They are difficult to correct because sometimes even the author does not understand them .

Modifications and upgrades are difficult to make because the maintenance programmer must spend considerable amount of time figuring out what the does from its code .

Comments Ideally , serves two purposes : First , it presents the computer with set of instructions and , second , it provides the programmer with clear , description of what the does .

Example contains glaring error .
It is an error that many programmers still make and one that causes more trouble than any other problem .
The contains no comments .

working but uncommented is time bomb waiting to explode .
Sooner or later someone will have to modify or upgrade the  and the lack of comments will make the job ten times more difficult .
, simple is of art .
Learning how to comment is as important as learning how to code properly .

has two flavors of comments .
The first type starts with and ends with .
This type of comment can span multiple lines as shown : This is comment .

Page The advantage of the comment style is that you can easily span multiple lines , whereas with the style you have to keep putting the on each line .
The disadvantage of is that forgetting can really screw up your code .

Whichever one makes your program as clear and as easy to read as possible .
Mostly , matter of taste .
In this book we use the style comments for big , multiline comments while the style is reserved for comments that take up only single line .

Whatever comment style you decide to use , you must comment your .
Example shows how the world " program looks after comments are added .

One of the best ways to organize your thoughts is to write them down in language that is clear and easy to understand .
Once the process has been clearly stated , it can be translated into computer program .

Understanding what you are doing is the most important part of programming .
once wrote two pages of comments describing complex graphics algorithm .
The comments were revised twice before even started coding .
The actual instructions Page Poor Typesetting In typesetting you can use font style and size , bold , and italic to make different parts of your text stand out .
In programming , you are limited to single , monospaced font .
However , people have come up with ingenious ways to get around the limitations of the typeface .

Some of the various commenting tricks are : WARNING : This is an example of message that grabs the attention of the programmer .

Even though we have the bold typeface we can words .

Because had organized my thoughts well was , the program worked the first time .

Page Your program should read like an essay .
It should be as clear and easy to understand as possible .
Good programming style comes from experience and practice .
The style described in the following pages is the result of many years of programming experience .
It can be used as starting point for developing your own style .
These are not rules , but only suggestions .
The only rules are : Make your program as clear , concise , and simple as possible .

At the beginning of the program is comment block that contains information about the program .
Boxing the comments makes them stand out .
The list that follows contains some of the sections that should be included at the beginning of your program .
Not all programs will need all sections , so use only those that apply .

Heading The first comment should contain the name of the program .
Also short description of what it does .
You may have the most amazing program , one that slices , dices , and solves all the problems , but it is useless if no one knows what it does .

Author gone to lot of trouble to create this program .
Take credit for it .
Also , if someone else must later modify the program , he or she can come to you for information and help .

Purpose Why did you write this program .

Usage In this section give short explanation of how to run the program .
In an ideal world , every program comes with set of documents describing how to use it .
The world is not ideal .

law of documentation states : of the time the documentation is lost .
Out of the remaining , of the time the revision of the documentation is different from the revision of the program and therefore completely useless .
The of the time you actually have documentation and the correct revision of the documentation , the documentation will be written in Japanese .

To avoid falling prey to law of documentation , put the documentation in the program .

References Creative copying is legitimate form of programming you break the copyright laws in the .
In the real world , it matter how you get working program , as long as you get it ; but , give credit where credit is due .
In this section you should reference the original author of any work you copied .

Page File formats List the files that your program reads or writes and short description of their format .

Restrictions List any limits or restrictions that apply to the program , such as : The data file must be correctly formatted ; the program does not check for input errors .

Revision history This section contains list indicating who modified the program and when and what changes have been made .
Many computers have source control system : RCS and SCCS ; that will keep track of this information for you .

Error handling If the program detects an error , what does it do with the error .

Notes Include special comments or other information that has not already been covered .

The format of your beginning comments will depend on what is needed for the environment in which you are programming .
For example , if you are student , the instructor may ask you to include in the program heading the assignment number , your name , student identification number , and other information .
In industry , project number or part number might be included .

Comments should explain everything the programmer needs to know about the program , but no more .
It is possible to overcomment program .

Inserting Easy Way If you are using the UNIX editor vi , put the following in your file to make it easier to construct boxes .

Typing will end box .

The number of stars was carefully selected so the end of the box is aligned on tab stop .

Page Code The actual code for your program consists of two parts : variables and executable instructions .

Variables are used to hold the data used by your program .
Executable instructions tell the computer what to do with the data .
classes are combination of data and the instructions that work on the data .
They provide convenient way of packaging both instructions and data .

variable is place in the memory for storing value .
identifies that place by the variable name .
Names can be any length and should be chosen so their meaning is clear .

The reader has no idea .
They could represent the number of angels on the head of pin , or the location and acceleration of plasma bolt in game of Space Invaders .

By putting comment after each declaration we , in effect , create where we define the meaning of each variable name .
Since the definition of each variable is in known place , easy to look up the meaning of name .
was once asked to modify program that converted plot data files from one format to another .
Many different units of length were used throughout the program and none of the variable declarations was Page commented .
tried very hard to figure out what was going on , but it was impossible to determine what units were being used in the program .
Finally , gave up and put the following comment in the program : Note : have no idea what the input units are , nor do have any idea what the output units are , but have discovered that if divide by the plots look about the right size .

Cleverness makes for unreadable and unmaintainable programs .
Programs , by their nature , are extremely complex .
Anything you can to do to cut down on this complexity will make your programs better .
Consider the following code , written by very clever programmer .

Even novice programmer who does not know well can tell that this program has something to do with moving data from source to destination .

The computer care which version is used .
good compiler will generate the same machine code for both versions .
It is the programmer who benefits from the verbose code .

Naming Style Names can contain both uppercase and lowercase letters .
In this book we use all lowercase names for variables ,
All uppercase Page is reserved for constants ,
This convention is the classic convention followed by most and programs .

Many newer programs use names ,
Sometimes they use the capitalization of the first letter to indicate information about the variable .
For example , recordsInFile might be used to denote local variable while RecordsInFile would denote global variable .
It is more matter of religion than of style .

However , using consistent naming style is extremely important .
In this book we have chosen the first style , lowercase variable names and uppercase constants , and we use it throughout the book .

Coding Religion Computer scientists have devised many programming styles .
These include structured programming , programming , and programming .
Each of these styles has its own following or cult .
use the term " because people are taught to follow the rules blindly without knowing the reasons behind them .
For example , followers of the cult will never use goto statement , even when it is natural to do so .

The rules presented in this book are the result of years of programming experience .
have discovered that by following these rules , can create better programs .
You do not have to follow them blindly .
If you find better system , by all means use it .
The general rule for program is to indent one level for each new or conditional .
In Example there are three levels of logic , each with its own indentation level .
The while statement is outermost .
The statements inside the while are at the next level .
The statement inside the if is at the innermost level .

There are two styles of indentation , and vast religious war is being waged in the programming community as to which is better .
The first is the short .

Both formats are commonly used .
You should use the format you feel most comfortable with .

This book uses the short form .

The amount of indentation is left to the programmer .
Two , four , and eight spaces are common .

Studies have shown that indent makes the most readable code .
You can choose any indent size as long as you are consistent .

Clarity program should read like technical paper .
It should be organized into sections and paragraphs .
Procedures form natural section boundary .
You should organize your code into paragraphs .
It is good idea to begin paragraph with topic sentence comment and separate .

better version would be : Swap the two corners Swap coordinate .

Simplicity Your program should be simple .
Some general rules of thumb .

single function should not be longer than one or two pages .

This rule comes about because the human mind can hold only so much in memory .

Three pages is about the most the human mind can wrap itself around in one sitting .

Avoid complex logic such as multiple nested ifs .
The more complex your code , the more indentation levels you will need .
About the time you start running into the right margin , you should think about splitting your code into multiple procedures and thus decreasing the level of complexity .

Did you ever read sentence , like this one , where the author went on and on , stringing together sentence after sentence with the word " and seem to understand the fact that several shorter sentences would do the job much better , and it bother you .

Long statements should be avoided .
If an equation or formula looks like it is going to be longer than one or two lines , you probably should split it into two shorter equations .

Split large single code files into multiple smaller ones .
That way they too difficult to edit and print .

When using classes Chapter , Simple , put one class per module .

Finally , the most important rule : Make your program as simple and easy to understand as possible , even if it means breaking some of the rules .
The goal Page is clarity , and the rules given in this chapter are designed to help you accomplish that goal .

If the rules get in the way , get rid of them .
have seen one program with single statement that spanned more than pages .
However , because of the specialized nature of the program , this statement was simple and easy to understand .

Consistency and Organization Good style is only one element in creating program .
Consistency is also factor .

This book is organized with the table of contents at the front and the index at the back .
Almost every book printed has similar organization .
This consistency makes it easy to look up word in the index or find chapter title in the table of contents .

Unfortunately the programming community has developed variety of coding styles .
Each has its own advantages and disadvantages .
The trick to efficient programming in group is to pick one style and then use it consistently .
That way you can avoid the problems and confusion that arise when programs written in different styles are combined .

Good style is nice , but consistency is better .

Further Reading In this chapter we have touched only the basics of style .
Later chapters expand on this base , adding new as you learn new of the language .

Summary program should be concise and easy to read .
It must serve as set of computer instructions , but also as reference work describing the algorithms and data used inside it .
Everything should be documented with comments .
Comments serve two purposes .
First , they describe your program to any maintenance programmer who has to fix it and , second , comments help you remember what you did .

Class : Create style sheet for class assignments .
Discuss what comments should go into the programs and why .

Class : Analyze the style of an existing program .
Is the program written in manner that is clear and easy to understand .
What can be done to improve the style of the program .

Page Exercise : Go through all the other programming exercises in this book and write comment blocks for them .
This will serve several purposes .
First , it will give you practice commenting .

Second , it will the old excuse , have time to put in the Page Basic Declarations and Expressions In This .

The Elements of Program .

The Output Class .

Basic Program Structure .

Variables and Storage .

Floating Point Numbers .

Answers to Chapter Questions journey of thousand miles must begin with single step If carpenters made buildings the way programmers make programs , the first woodpecker to come along would destroy all of civilization The Elements of Program If you are going to construct building , you need two things : the bricks and blueprint that tells you how to put them together .
In computer programming you also need two things : data and instructions .
Variables are the basic building blocks of program .

Instructions tell the computer what to do with the variables .

Comments are used to describe the variables and instructions .
They are notes by the author documenting the program so it is clear and easy to read .
Comments are ignored by the computer .

In construction , before we can start we must order our materials : need large bricks , bricks , and " Similarly , in you must declare all variables before to use .

After the variables are defined you can begin to use them .
In construction the basic structure is room .
By combining many rooms we form building .
In the basic structure is function .

Functions can be combined to form program .

Page An apprentice builder does not start out building the Empire State Building .
He starts on house .
In this chapter you will concentrate on constructing simple , programs .

Basic Program Structure The basic of program are the data declarations , functions , and comments .
see how these can be organized into simple program .

The basic structure of program is : Heading comments data declarations .

The heading comments tell the programmer all about the program .
The data declarations describe the data that the program is going to use .

Our single function is named main .
The name main is special , because it is the first function called .
Any other functions are called directly or indirectly from main .
The function main begins .

nonzero indicates an bigger the return value , the more severe the error .
Typically is used for most simple errors , such as missing file or bad syntax .

Now take look at the World " program .

At the beginning of the program is comment box enclosed in and .
Following this is the line : Page This statement signals that you are going to use set of standard classes called the stream classes .
This is type of data declaration .
uses semicolon to end statement in much the same way we use period to end sentence .
Unlike with languages such as BASIC , the end of line does not end statement .
The sentences in this book can span several end of line is treated as space separating words .
works the same way .
single statement can span several lines .

Similarly , you can put several sentences on the same line , just as you can put several statements on the same line .
However , most of the time your program is more readable if each statement starts on separate line .

We are using the standard class to output the message .
standard class is generally useful object that has already been defined and put in the standard library .
library is collection of classes , functions , and data that have been grouped together for reuse .

The standard library contains classes and functions for input , output , sorting , advanced math , and file manipulation .
See your reference manual for complete list of library functions and standard classes .

It contains no computations , merely sending single message to the screen .
It is starting point .
Once you have mastered this simple program , you have done great deal of things right .
The program is not as simple as it looks .
But once you get it working , you can move on to create more complex code .

Simple Expressions Computers can do more than just print strings .
They can also perform calculations .

Expressions are used to specify simple computations .
has the five simple operators listed in Table .

Page Table .
Simple Operators Operator Meaning .

Multiply , divide , and modulus have precedence over addition and subtraction .
Parentheses may be used to group terms .

The program in Example computes the value of the expression +

Although we calculate the answer , we do anything with it .
learn what class is later in Chapter , Simple Classes .
But for now all we have to know is that the operator tells what to output .
So the statement :  tells to take the string  and write it to the console .

When this executed it will write : Half on the console .
Note that we had to put space after the " in " There also space on either side the " string .
These spaces are needed in the output to separate the numbers .

But these spaces are not inside any string , so they will not be output .
The result this code  Half Omitting needed spaces common programming mistake .
Remember , only the text inside the quotation marks will be output .

Variables and Storage allows you to store values in variables .
Each variable identified by variable name .

Additionally , each variable has variable type .
The type tells how the variable going to be used and what kind numbers , it can hold .

To avoid confusion , it better to use different names for variables and not depend on case differences .

Most programmers use all lowercase variable names .
Some names , such as int , while , for , and float , have special meaning to and are considered reserved words .

The following an example some variable names : average average all grades pi pi to decimal places number students in this class The following are not variable names : the end int .

Begins with number Contains space Reserved word Avoid variable names that are similar .
For example the following illustrates poor choice variable names : total total number items in current entry .

variable cannot be used unless it declared .

variable declaration serves three purposes :
It defines the name the variable .

It defines the type the variable , real , character ,

It gives the programmer description the variable .

The declaration variable answer can be : int answer ; the result our expression .

The keyword int tells that this variable contains an integer value .
The semicolon used to indiPage cate the statement end , and the comment used to define this variable for the programmer .

The general form variable declaration .

Type one the variable types , float , Name any valid variable name .
The comment explains what the variable and what it will be used for .
Variable declarations come just before the line at the top program .
Integers known as whole have no fractional part or decimal point .
Numbers such as , and are integers .
The number not an integer because it contains decimal point .
The general form an integer declaration  int .

calculator with an display can only handle numbers between and .
If you try to add to , you will get an overflow error .
Computers have similar limits .
The limits on integers are implementation dependent , meaning they change from computer to computer .

Calculators use decimal digits .
Computers use binary digits called bits .
Eight bits make byte .
The number bits used to hold an integer varies from machine to machine .

Numbers are converted from binary to decimal for printing .

On most UNIX machines integers are bits , providing range to .
On the PC in Turbo , only bits are used , so the range to .

Question : The following will work on UNIX machine but willfail on PC int .

What will be the result when run on PC .

Page Assignment Statements Variables are given value through the use assignment statements .
Before variable can be used it must be declared .
For example : int .

The variable on the left side the equals assigned the value the expression + on the right side .
The semicolon ends the statement .

When you declare  allocates storage for the and puts an unknown value inside it .
You can think the declaration as creating box to hold the data .
When it starts out it mystery box containing an unknown quantity .
This illustrated in Figure .

The assignment statement computes the value the expression and drops that value into the box as shown in Figure .

Declaration and assignment statements .

The equals is used for assignment , not equality .

Page In Example the term is used to store an integer value that is used in two later expressions .
Variables , like expressions , can be output using the output operator , so we use this operator to check the results .

Example .

Real numbers are numbers that have fractional part .
Because of the way they are stored internally , real numbers are also known as floating point numbers .
The numbers , and are all floating point numbers .
uses the decimal point to distinguish between floating point numbers and integers , so number such as floating point number while an integer .
Floating point numbers must contain decimal point .
Numbers such as , and are floating point numbers .

Although it possible to omit digits before the decimal point and specify number as instead of , the extra makes it clear that you are using floating point number .
similar rule applies to .
Floating point zero should be written as .

Additionally , floating point number may an exponent specification of the form .

For example , shorthand for .

The form of floating point declaration .

Again , there limit on the range of numbers the computer can handle .
The range varies widely from computer to computer .
Floating point accuracy discussed further in Chapter , Floating Point .

Floating point numbers may be output using .
For example :  Page Floating Point Versus Integer Divide The division operator special .
There vast difference between an integer divide and divide .
In an integer divide , the result truncated fractional part .
For example , the integer divide value of .

If either the divisor or the dividend number , floating point divide executed .

Table Expression Examples Expression Result .

Floating point allows the assignment of an integer expression to .
It will automatically perform the conversion and then make the assignment .
similar conversion performed when assigning point number to an integer .
Floating point numbers are truncated when assigned to variables .

Example .

Page Question : Why does Example print value of .
What must be done to this program to fix it .

Characters are enclosed in single quotation marks .
The backslash character called the escape character .
It used to signal that special character follows .
For example , the character can be used to represent the single character " the character .
It causes the output device to go to the beginning of the next  similar to return key on typewriter .
The character the backslash itself .
Finally , characters can be specified by where nnn the octal code for the character .
Table summarizes these special characters .
For full list of ASCII character codes , see Appendix .

Special Characters Character Name .

Tab Advance to the next tab stop ' Apostrophe or single quotation mark The character .

Page NOTE While characters are enclosed in single quotes , different data type , the string , enclosed in double quotes .
good way to remember the difference between these two types of quotes that single characters are enclosed in single quotes Strings can have any number of characters double quote , and they are enclosed in double quotes .

Example reverses three characters .

Example cc .

ABC reversed CBA Boolean The Draft Standard defines boolean  bool , that can have the value true or false .

Most compilers do not yet support this new  so we will not discuss it here .
Instead , it can Programming Exercises Exercise : Write program to print your name , Social Security number , and date of birth .

Exercise : Write program to print block using asterisks , where the characters high and characters wide .

Page Exercise : Write program to compute the area and circumference of rectangle inches wide by inches long .
What changes must be made to the program so it works for rectangle inches wide by inches long .

Exercise : Write program to print " in big block letters where each letter characters high and characters wide .

Answers to Chapter Questions Answer : The largest number that can be stored in an int on UNIX machine .
When using the limit .
The zip code larger than , so it mangled and the result .

This problem can be fixed by using long int instead of just an int .
The various types of integers are discussed in Chapter , Arrays .
Qualifiers , and Reading Numbers .

Answer : The problem concerns the division :
The number and the number are both integers , so this an divide .
Fractions are truncated in an divide .
The expression should be written as : Page Arrays , Qualifiers , and Reading Numbers In This .

Types of Integers .

Types of Floats .

Programming Exercises That mysterious independent variable of political calculations , Public Opinion .

That is fine for small number of bricks , but what happens when we want to construct something larger .
We would like to point to stack of bricks and say , for the left wall .
brick , brick , This declares to be an array of the three elements , and , which are separate variables .
To reference an element of an array , you use number called the index number inside the square brackets .
is funny language and likes to start counting at , so these three elements are numbered .

Page NOTE Common sense tells you that when you declare to be three elements long , would be valid .
Common sense is wrong and is illegal .

Example computes the total and average of five numbers .

The special character  is used to indicate the end of string .

This creates character array four elements long .
Note that we had to allocate one character for the marker .

String constants consist of text enclosed in double quotes .
You may have already noticed that used string constants extensively for output with the standard class .

NOTE The line is needed to inform that you are using the string function library .

uses strings .
For example , the .

The size of the array is , but the length of the string is .
Any string up to characters long can be stored in string .
These are listed in Table .

Table String Functions Function .

Page Function .

Example takes first and last and combines the two strings .
The program works by initializing the variable first to the first .
The last put in the variable last .
To construct the full  the first copied into .
Then strcat used to add space .
We call strcat again to tack on the last .

The dimension of the string variables because we know that no one we are going to encounter has more than characters long .

Note : strcat not strcpy Page .

The Steve Oualline Reading Data So far learned how to compute expressions and output the results .
You need to have your programs read numbers as well .
The output class variable uses the operator to write numbers .
The input class variable cin uses the operator to read them .
For example , the code : cin price ; reads two numbers : price and .
The input to this program should be two numbers , separated by white space .
For example , if you type : then price gets the value and gets .

NOTE This does not give you very precise control over your input .
does reasonable job for simple input .
If your program expects number and you type instead , the program will skip the white and wait for you to type number .
Sometimes this may lead you to think your stuck .

In Example , we use cin to get number from the user and then we double it : Example char .

This program asks the user for single number and doubles it .
Notice that there no at the end of Enter .
This because we do not want the computer to print newline after the prompt .
For example , sample run of the program might look like : Enter  If we replaced Enter  with Enter  the result would be : Enter  Question : Example designed to compute the area of triangle , given its width and height .
For some strange reason , the compiler refuses to believe that we declared the variable width .
The declaration right there on line two , just after the definition of height .
Why the compiler seeing it .

Example int int .

When reading string , the cin class considers anything up to the part of the string .

Enter The of the  Initializing Variables allows variables to be initialized in the declaration statement .

The number of elements in the curly braces does not have to match the array size .
If too many numbers are present , warning will be issued .
If there are not enough numbers , the extra elements will be initialized to .

Page If no dimension given , will determine the dimension from the number of elements in the initialization list .
For example , we could have initialized our variable with the statement : Product numbers for the parts we are making int ,

uses strings .
For example , the declaration : char ; creates an array that can contain up to characters .
The size of the array , and the length of the .
Any up to characters long can be stored in .
The other elements are not initialized and may contain random data .

Multidimensional Arrays Arrays can have more than one dimension .
The declaration for array .

Additional dimensions can be tacked on .

Last element Your answers may vary .

Page Types of Integers considered language because it allows you to get very close to the actual hardware of the machine .
Some languages , such as BASIC , go to great lengths to completely isolate the user from the details of how the processor works .
This consistency comes at great loss of efficiency .
lets you give detailed information about how the hardware to be used .

For example , most machines let you use numbers .
Simple BASIC allows the programmer to use only one number type .
This simplifies the programming , but BASIC programs are extremely inefficient .
allows the programmer to specify many different kinds of integers , so the programmer can make best use of the hardware .

The type specifier int tells to use the most efficient size the machine you are for the integer .
This can be to bytes depending on the machine .
Sometimes you need extra digits to store numbers larger than are allowed in normal int .
The declaration : long int answer ; the answer of our calculations used to allocate long integer .
The long quantifier informs that you wish to allocate extra storage for the integer .
If you are going to use small numbers and wish to reduce .

guarantees that the storage for long .
In actual practice , almost always allocates bytes ; long , bytes ; and  or bytes .

The type uses bytes , or bits .
Fifteen bits are used normally for the number and bit for the sign .
This gives it range of to .
An unsigned uses all bits for the number , giving it the range of to .
All declarations default to signed , so that the declaration : signed long answer ; final result Page .

Character variables take up byte .
They can also be used for numbers in the range to or to .
Unlike integers , they do not default to signed ; the default compiler dependent .

compiler dependent .

If you always specify signed or unsigned you have to worry about problems like .

Reading and writing very integers little tricky .
If you try to use char variable in an output statement , it will be written , as character .
You need to trick into believing that the char variable an integer .
This can be accomplished with the operator .
Example shows how to write out very integer as number .

Example cc .

On the next line we write out the value of the variable .
If we tried to write directly , would treat it as character .
The even has switch to make the default for type char either signed or unsigned Page Reading very integer not possible .
You must first read it as and then assign it to very integer .

Summary of Integer Types long declarations allow the programmer to explicitly specify extra precision where it needed the expense of .
The most compact integers have type char .
They also have the most limited range .

The kind of number you use will depend on your program and storage requirements .
The range of the various types of integers listed in Appendix .

Types of Floats The float type also comes in various flavors .
Double precision gives the programmer twice the range and precision of variables .

The quantifier long double denotes extended precision .
On some systems the same as double ; on others , it offers additional precision .
All types of numbers are always signed .

On most machines , instructions execute faster less than double precision .
Double precision gains accuracy at the expense of time and storage .
In most cases float adequate ; however , if accuracy problem , switch to double Chapter , Floating .

Constant and Reference Declarations Sometimes you want to use value that does not change , such as .
The keyword const .

NOTE By convention variable names use lowercase only while constants use uppercase only .
However , there nothing in the language that requires  and several programming systems use different convention .

Page Constants must be initialized at declaration time and can never be changed .

However , some compilers , such as Version , allow integer constants in type of expression .

The special character " used to tell that reference .

Reference variables Page This form of the reference variable not very useful .
In fact , in actual programming it almost never used .
In Chapter , Variable Scope and Functions , see how another form of the reference variable can be very useful .

Qualifiers As seen , allows you to specify number of qualifiers for variable declarations .
Qualifiers may be thought of as adjectives that describe the type that follows .
Table summarizes the various qualifiers .

Table Qualifiers and Simple Types Special volatile Class register static extern auto Size long short double Sign signed unsigned Type int float char Special The volatile keyword used for specialized programming such as drivers and shared memory applications .
It an advanced modifier whose use far beyond the scope of this book .

brief description of the various classes follows : register This indicates frequently used variable that should be kept in machine register .
See Chapter , Debugging and Optimization .

This keyword is described in Chapter , Variable Scope and Functions , and Chapter , Modular Programming .

Page extern The variable is defined in another file .

Size The size qualifier allows you to select the most efficient size for the variable .

Sign Numbers can be signed or unsigned .
This qualifier applies only to char and int types .

numbers are always signed .
The default is signed for int and undefined for characters .

Type This specifies the type of the variable .
Simple types include : int Integer float number char Single characters , but can also be used for very short integers Page Hexadecimal and Octal Constants Integer numbers are specified as string of  such as , and so on .
These are decimal numbers : or .
Computers deal with binary numbers :
The octal system easily converts to and from binary .
Each group of three can be transformed into single octal digit .
Thus can be written as and changed to the octal .
Hexadecimal numbers have similar conversion , but bits at time are used .

The language has conventions for representing octal and hexadecimal values .
Leading zeros are used to signal an octal constant .
For example , is or .

Starting number with " indicates hexadecimal constant .

Table shows several numbers in all three bases .

Table Integer Examples Base Base .

Operators for Performing Shortcuts not only provides you with rich set of declarations , but also gives you large number of operators .
Frequently programmer wants to increment variable .

Using normal assignment statement , this would look like : + Page .

Each of the simple operators shown in Table can be used in this manner .

Table Shorthand Operators Operator Shorthand .

Side Effects Unfortunately , allows the programmer to use side effects .
side effect an operation that performed in addition to the main operation executed by the statement .
For example , the following legal .

The first statement assigns the value of .
The second statement : But in what order .
There are four possible answers :

The answer compiler dependent and varies from computer to computer .

If you write code like this , you have to worry about these sorts of questions .

The correct answer : The increment occurs before the assignment .

The main effects of are confusing enough without having to worry about side effects .

NOTE Some programmers highly value compact code .
This holdover from the early days of computing when storage cost significant amount of money .
It my view that the art of programming has evolved to the point where clarity much more valuable than compactness .

The programmer read this statement , he decodes it .
If you never use or part of any other statement , but always put them on line by themselves , the difference between the two forms of these operators not noticeable .

NOTE The prefix form preferred over the suffix form variable because it allows the compiler to generate slightly simpler code .

Page More complex side effects can confuse even the compiler .
Consider the following code .

Multiply by and add to .

Multiply by and add to .

Add the results of the two multiples together .

Steps and are of equal priority , unlike the previous example , so the compiler can execute them in any order it wants to .
Suppose it decides to execute step first , as shown in Figure .

Expression evaluation , method But it may execute step first , as shown in Figure .

By using the first method , we get of ; using the second method the .
The of this expression ambiguous .
By using the operator in the middle of larger expression , we created problem .
We To avoid trouble and keep the program simple , always put and on line by themselves .

Page Figure Expression evaluation , method Programming Exercises Exercise : Write program that converts Celsius to Fahrenheit .

Exercise : Write program to print out the of rectangle given its height and width .

Exercise : Write program that converts kilometers per hour to per hour .

Exercise : Write program that takes hours and as input and outputs the total of hour .

Exercise : Write program that takes an integer as the of and outputs the total hours and hour .

Answers to Chapter Questions Answer : The programmer accidentally omitted the symbol after the comment for height .
The comment continues onto the next line and Page engulfs the width variable declaration .
Example shows the program with the comments underlined .

Answer : The problem with the way we specified the element of the array :

The reason that the specification does not generate syntax error that it legal .
There comma operator in Darker so the expression evaluates to .

treats this as pointer Simple and written shows up as memory address .

Answer : The problem that the zip code begins with zero .
That tells that an octal constant .
When we print it , we print in decimal .
Because the program prints : New zip code  Page Decision and Control Statements In This .

The Assignment Anywhere Side Effect .

Answers to Chapter Questions Once decision was made , did not worry about it afteruard Truman Calculations and expressions are only small part of computer programming .
Decision and control statements also are needed , to specify the order in which statements are to be executed .

So far you have constructed linear programs , which are programs that execute in straight line , one statement after another .
In this chapter you will see how to change the control flow of program with branching statements and looping statements .
Branching statements cause one section of code to be executed or not , depending on conditional clause .
Looping statements are used to repeat section of code number of times or until some condition occurs .

The general form of the if statement  statement ; If the expression true the statement will be executed .
If the expression zero , the statement will not be executed .
For example , suppose you are writing billing program .
At the end , if the customer owes nothing or if he has credit negative you want to print message .
In this written : owe ; Page relational that represents less than or equal to .
This statement reads the less than or equal to zero , print the " complete list of relational operators found in Table .

Relational Operators Operator Meaning .

Not equal Multiple relational expressions may be grouped together with logical operators .
For example , the statement : uses the logical OR to cause the if statement to print " if either lowercase " or an uppercase " Table lists the logical operators .

Table Logical Operators Operator Usage .

For readability , the statements enclosed in curly braces are usually indented .
This allows the programmer to quickly tell which statements are to be conditionally executed .
As you will see later , mistakes in indentation can result in programs that are misleading and hard to read .

Page else Statement An alternative form of the if statement  statement ; else statement ; If the condition true , the first statement executed .
If it false , the second statement executed .
In our accounting example , we wrote out message only if nothing was owed .
In real life we probably want to tell the customer how much he owes if there is balance due .

Now consider this program fragment : If .

You have to worry about this situation if you never write code like this .

According to the syntax rules , the else goes with the nearest if , so is syntactically correct .
But writing code like this violates the KISS principle It Simple ,
It is best to write your code as clearly and simply as possible .
This code fragment should be written .

From our original example , it was not clear which if statement had the else clause ; however , adding an extra set of braces improves readability , understanding , and clarity .

How Not to Use strcmp function strcmp compares two strings and returns zero if they are equal and nonzero if they are different .
To check whether two strings are equal , we use code : Check for equal .

Unfortunately , obvious is wrong .
If strings are equal strcmp returns zero , and is not executed .
Because of this backwards behavior of strcmp , you should be very careful in your use of strcmp and always comment its use .

Looping Statements Computers not only do calculations , but also will do them over and over and over .
To get computer to repeat its work , you need loop statement .
Looping statements have many uses .

For example , loops are used to number of words in document or to number of accounts that have past due balances .

The Fibonacci sequence is :

The terms are computed from equations : etc .

In general terms this is : + This is mathematical equation using variable names .
Mathematicians use this very terse style of naming variables .
In programming , terse is dangerous , so we translate these names into something verbose for .

We want to loop until our current term is or larger .
The while loop : will repeat our computation and printing until we reach this limit .

In our while loop we compute value of and print it Next we need to advance one term .

This completes body of loop .
The first two terms of Fibonacci sequence are and .

We initialize our first two terms to these values .

Figure shows what happens to variables during execution of program .

We print value of current term .
Then variable is computed .
Next we advance one term by putting into and into .
This is repeated until we compute last term and while loop exits .

Page Example shows this written as code .

Example cc int .

Page Break Statement We have used while statement to compute Fibonacci numbers less than .
The loop exits when condition at beginning becomes false .
Loops also can be exited at any point through use of break statement .

Suppose you want to add series of numbers and you know how many numbers are to be added together .
You need some way of letting program know it has reached end of list .
In Program you use number zero to signal end of list .

Note that while statement begins with : while The program will loop forever because while will exit only when expression is zero .
The only way to exit this loop is through break statement .

When we see indicator , we use statement : break ; to exit loop .

For example , if you modify previous program to only numbers larger than , you get Example .

The first version buries the assignment of inside the expression .

Programs should be clear and simple and should not hide anything .
The most important rule of programming is KEEP IT SIMPLE .

also allows you to put assignment statements in the while conditional .
For example : do not program like this  

Sample output : Enter number of dollars owed : You dollars .

Programming Exercises Exercise : Write program to find the square of the distance between two points .
Find the distance only if you want to do the independent research needed to perform square root in .

Exercise : professor generates letter grades using Table .

Table Grade Values Correct Grade .

Given numeric grade , print the letter .

Exercise : Modify the previous program to print out + or after the letter grade based on the last digit of the score .
The modifiers are listed in Table .

Table Values Last digit Modifier .

Note : An is only an .

NOTE Programmers frequently have to modify code that someone else wrote .

Exercise : Given an amount than , compute the number of quarters , dimes , nickels , pennies needed .

Exercise : leap year is any year divisible by unless it is divisible by , but not .

Write program to tell whether year is leap year .

Page Exercise : Write program that , given the number of hours an employee worked his hourly wage , computes his weekly pay .
Count any hours over as overtime at .

Answers to Chapter Questions Answer : This program illustrates the most common error one of the most frustrating .
The problem is that allows assignment statements inside of if conditionals .
The statement : uses single equal sign instead of the double equal .
will assign the value then test the result is .
If the result were nonzero , the if clause would be executed .
Since the result is zero .

The statement is equivalent to ; The statement should be written : This is the most common error that beginning programmers make .
It is also one the most difficult frustrating to find .

once taught course programming .
One day about month after the course had ended saw one my former students on the street .
He greeted me said , have to tell you the truth .
During the class thought you were going bit overboard on .

Mark Up the Program .

Programming Exercises just simple matter programming .

Software has life cycle .
It is born , grows up , becomes mature , finally dies , only to be replaced by newer , younger product .

Understanding cycle is important because as programmer you will spend only small amount time actually writing new .
Most programming time is spent modifying debugging existing .
Software does not exist vacuum ; it must be documented , maintained , enhanced , sold .
In section we take look at small programming project using one programmer .
Larger projects that involve many people are discussed Chapter , Modular Programming .
Although the final is fewer than hundred lines , the principles used its construction can be applied to programs with thousands lines .

Figure illustrates the software life cycle .

The major steps making program .

Programs start when someone gets an idea assigns you to implement it .

The requirement document describes , very general terms , what is wanted .

In the beginning , Preliminary Specification is used to describe what the program is going to do .
Later , as the program becomes more refined , so does the specification .
Finally , when the program is finished , the specification serves as complete description what the program does .

Page Figure .
Software life cycle .

The programmer does an overall design the program .
The design should include major algorithms , class definitions , module specifications , file formats , data structures .

One thing cannot be ; before you " Studies have shown that good design can result program that is the size poorly designed one .
This is especially true when using , where designPage ing good objects is critical to writing good program .

The next step is writing the program .
This involves first writing prototype then filling it to create the full program .

The programmer should design test plan use it to test the program .
It is good idea , when possible , to have someone else test the program .

Unfortunately , very few programs work the first time .
They must be corrected tested again .

The program is packaged , documented , and sent out into the world to be used .

Programs are never perfect .
Bugs will be found and will need correction .

Revising and updating .
After program has been working for while , the users will want changes , such as more features or more intelligent algorithms .
At point new specification is created and the process starts again .

Setting Up The operating system allows you to group files directories .
Just as file folders serve as way keeping papers together filing cabinet , directories serve as way keeping files together .
In chapter you will be creating simple calculator program .
All the files for program will be stored directory named calc .
To create directory UNIX , execute the following commands : cd mkdir calc In , type : cd mkdir calc To tell the operating system which directory you want to use , UNIX type the command : cd In , type : cd : Page More information on how to organize directories can be found your operating system documentation .

The Specification For chapter we are going to assume that you have been given the assignment to program that acts like " Typically , the specification you are given is vague and incomplete .
It is up to you to refine it into something that exactly defines the program you are going to produce .

The first step is to write document called The Preliminary Users ' Specification , which describes what your program is going to do and how to use it .
This document does not describe the internal structure the program or the algorithm you plan to use .
sample specification for the calculator is : Calc calculator Preliminary Specification Dec .
Any resemblance to any software living or dead is purely coincidental .

Calc is program that allows the user to turn his computer into calculator .
The program adds , subtracts , multiplies , and divides simple integers .

When the program is run , it zeros the result register and displays its contents .
The user can then type in an operator and number .
The result is updated and displayed .
The following operators are valid : Operator Meaning .

Division calc Result : Enter operator and number : + Result : Enter operator and number : Result : Page Enter operator and number : Result : Enter and number : Result : The preliminary specification serves two purposes .
First , you should give it to your boss to make sure that what he thought he said and what you thought he said agree .

Second , you can circulate it among your colleagues to see whether they have any suggestions or corrections .

This preliminary specification was circulated and received the comments : are you and we add another paragraph : Dividing by results in an error message and the result register is left unchanged .

The professor say what sort of numbers had to be used , so the student created program that worked only with Roman numerals +
The program came with complete user in Latin .

Code Design After the preliminary specification has been approved , you can start designing code .
In the phase , you plan your work .
In large programming projects involving many people , the code would be broken up into modules for each programmer .
At this stage , file formats are planned , data structures are designed , and major algorithms are decided upon .

This simple calculator uses no files and requires no fancy data structures .
left for this phase is to design the major algorithm .
Outlined in , shorthand halfway between English and real code , it is : Loop Read an and number Do the calculation Page Display the result The Prototype Once the code design is completed , you can begin writing the program .
But rather than try to write the entire program at once and then debug it , you will use method called fast prototyping .
This consists of writing the smallest portion of the specification you can implement that will still do something .
In our case , you will cut the four functions down to calculator .
Once you get this small part working , you can build the rest of the functions onto this stable foundation .
Also , the prototype gives the boss something to look at and play around with so he has good idea of the direction the project is taking .
Good communication is the key to good programming , and the more you can show someone , the better .
The code for the first version of the calculator is found in Example .

Example cc int char .

These are parsed and stored in the variables and value .
If the is plus , you perform an addition using the line : if .

The Makefile Once the source has been entered , it needs to be compiled and linked .
Up to now we have been running the compiler manually .
This is somewhat tedious and prone to error .
Also , larger programs consist of many modules and are extremely difficult to compile by hand .
Fortunately , both UNIX and have utility called make that handles the details of compilation .

For now , just use this example as template and substitute the name of your program in place of calc .
The make program is discussed in detail in Chapter , Modular Programming .

Basically , make looks at the file called Makefile for description of how to compile your program and runs the compiler for you .

For UNIX system using the generic compiler , the Makefile should be : Makefile for many UNIX compilers using the " command name all : calc calc : Page calc clean : rm calc If you are using the Free Software compiler , the Makefile is : Makefile for the Free Software Foundations compiler all : calc calc : calc clean : rm calc For , the Makefile should be : Makefile for compiler Flags Check for stack overflow Enable debugging Turn on all warnings Large model all : clean : erase For Borland , the Makefile is the same except the compiler is named bcc .

Finally , for Microsoft Visual , the Makefile is : Makefile for Microsoft Visual Flags AL Compile for large model Page Zi Enable debugging Turn on warnings all :

To compile the program , just execute the command make .

Compilation creates an object file .
The modification date of the object file is later than the modification date of its source .
If the source is edited , its modification date is updated , making the object file out of date .

Testing Once the program is compiled without errors , you can move on to the testing phase .
Now is the time to start writing test plan .
This document is simply list of the steps you perform to make sure the program works .
It is written for two reasons .

If bug is found , you want to be able to reproduce it .

If you ever change the program , you will want to retest it to make sure new did not break any of the sections of the program that were previously working .

The test plan starts out as : Try the following operations + + Result should be Result should be Error message should be output Page Running the program you get : Result : Enter operator and number : + Result : Enter operator and number : + Result : Enter operator and number : Result : Something is clearly wrong .
The entry " should have generated an error message but .
There is bug in the program , so you begin the debugging phase .
One advantage to making small working prototype is that you can isolate errors early .

Debugging First you inspect the program to see if you can detect the error .
In such small program it is not difficult to spot the mistake .
However , assume that instead of program , you have much larger one containing lines .
Such program would make inspection more difficult , so you need to proceed to the next step .

Most systems have debugging programs , but each debugger is different .
Some systems have no debugger .
In that case you must resort to diagnostic print statement .
Then put where the data is bad .
Run the program and keep putting in until you isolate the area in the program that contains the mistake .

NOTE The at the beginning of each line flags the line as debug line .
This makes it easy to tell the temporary debug output from the real program output .

Also , when you finally find the bug the makes it easy to find and remove the debug lines with your editor .

Page Running the program again results in : Result : Enter and number : + Result : Enter and number : + after + after + Result : Enter and number : after after + Result : From this you see that something is going wrong with the statement .
Somehow the variable is an going in and + coming out .
Closer inspection reveals that you have the old mistake instead .
After you fix this bug , the program runs correctly .
Building on this working foundation , you add in the for the other operators , and , to create Example .

Example int .

You expand the test plan to the new and try it again .

The word " is removed from the specification and the program , test plan , and specification are released .

Maintenance Good programmers put their programs through long and rigorous testing process before releasing it to the outside world .
Then the first user tries the program and almost immediately finds bug .
This starts the maintenance phase .
Bugs are fixed , the program is tested make sure the fixes break , and the program is released again .

Revisions Although the program is officially finished , you are not finished with it .
After it is in use for few months , someone will come to us and ask , you add modulus " So you revise the specifications , add the change to the program , update the test plan , test the program , and release it again .

As time passes , more people will come to you with additional requests for changes .
Soon the program has trig functions , linear regressions , statistics , binary arithmetic , and financial calculations .
The design is based on the idea .
Soon you find yourself running out characters to use .
At this point the program is doing work far beyond what it was initially designed to do .
Sooner or later you reach the point where the program needs to be scrapped and new written from scratch .
At this point you write new Preliminary Specification and start the process over again .

Page Electronic Archaeology Unfortunately , most programmers start project at the design step .
Instead they are immediately thrust into the maintenance or revision stage .
This means the programmer is faced with the worst possible job : understanding and modifying someone code .

Contrary to popular belief , most programs are not written by disorganized orangutans Zen programming techniques and poorly commented in Esperanto .
They just look that way .
Electronic archeology is the art digging through old code to discover amazing things how and why the code .

Your computer can aid greatly in your search to discover the true meaning someone code .
Many tools are available for examining and formatting code .
Many tools have yet to be upgraded for .
See earlier sections on Some these tools .

These programs have names like xref , cxref , and cross .
System UNIX has the utility cscope .
They print out list variables and where the variables are used .

pretty printer such as vgrind or cprint typesets source code for printing on laser printer .

On System UNIX the program cflow analyzes the structure the program .

On other systems there is public domain utility , calls , that produces call graphs , showing who calls whom and who is called by whom .

class browser allows you to display the class hierarchy so you can tell what components went into building the class as well as its structure .
learn what class is in Chapter , Simple Classes .

Different programmers work in different ways .
Some techniques for examining code are listed below .
Choose the ones that work for you and use them .

Mark Up the Program Take printout the program and make notes all over it .
Use red or blue ink so you can tell the difference between the printout and the notes .
Use highlighter to emphasize important sections .
These notes are useful ; put them in the program as comments , and then make new printout and start the process over again .

Page Use the Debugger The debugger is great tool for understanding how something works .
Most debuggers allow you to step through the program line at time , examining variables and discovering how things really work .
Once you find out what the code does , make notes and put them in as comments .

Use the Text Editor as Browser One of the best tools for going through someone code is your text editor .
Suppose you want to find out what the variable sc is used for .
Use the search command to find the first place sc is used .
Search again and find the second .
Continue searching until you know what the variable does .

Suppose you find out that sc is used as sequence counter .
Since already in the editor , you can easily do global to change the variable sc to .
Also make sure you do word replacement or find you replaced sc in places you Comment the declaration and on your way to creating an understandable program .

Add Comments be afraid to put any information you have , no matter how little , into the comments .

As you go through someone code adding comments and improving style , the structure will become clearer to you .
By inserting notes , you make the code better and easier to understand for future programmers .

Suppose you are confronted with the following program written by someone from the Terser the Better " school of programming .
Your assignment is to figure out what this program does .
First you pencil in some comments as shown in Figure .

Page Figure .
terse program This mystery program requires some work .
After going through it and applying the principles described in this section , you get the , version shown in Example .

Example guess simple guessing game Usage : guess random number is chosen between and .

Because returns number maxint this slightly favors Page the lower numbers .

Programming Exercises For each assignment , follow the software life cycle from specification through release .

Exercise : Write program to convert English units to metric , miles to kilometers , gallons to liters ,
Include specification and code design .

Exercise : Write program to perform date arithmetic , such as how many days there are between and .
Include specification and code design .

Exercise : serial transmission line can transmit characters second .
Write program that will calculate how long it will take to send file , given the size .
Try it on Exercise : Write program to add an sales tax to given amount and round the result to the nearest penny .
Exercise : Write program to tell whether number is prime .

Exercise : Write program that takes series of numbers and counts the number of positive and negative values .

Page II Simple Programming Page More Control Statements In This .

Answers to Chapter Questions Grammar , which knows how to control even kings for Statement The for statement allows you to execute block of code specified number of times .
The general form of the for statement .

Normally you count five items as ,
You will get along much better in if you change your thinking to counting and count five items as ,

Careful examination of the two flavors of this program reveals the similarities between the two versions , as shown in Figure .

Many older programming languages do not allow you to change the control variable this case inside the loop .

You can change the control variable anytime you can jump into and out of the loop and generally do things that would make PASCAL or FORTRAN programmer cringe .
Similarities between while and for Question : Example contains an error .

Page Question : Example reads list of five numbers and counts the number of threes and sevens in the data .
Why does it give us the wrong answers .

Number of sevens in the data The data to count and in Number of threes in the data Index into the data .

The general form of switch statement  case constantl : statement .

Duplicate labels are not allowed , so only one case will be selected .
The expression must evaluate to integer , character , or enumeration .

The default label can be put anywhere in the switch .

When sees switch statement , it evaluates the expression and then looks for matching case label .
If none found , the default label used .
If no default found , the statement does nothing .

break statement inside switch tells the computer to continue the execution after the switch .
If the break not there , execution continues with the next statement .

NOTE The switch statement very similar to the PASCAL case statement .
The main differences are that while PASCAL allows only one statement after the label , allows many .
keeps executing until it hits break statement .
In PASCAL you through " from one case to another .

The calculator program in Chapter , The Programming Process , contains series of statements .

This section of code can easily be rewritten as switch statement .
In this switch , we use different case for each operation .
The default clause takes care of all the illegal operators .

Rewriting the program using switch statement makes it not only simpler , but also easier to read as seen in Example .

Example int .

break statement is not required at the end of case .
If the break is not there , execution will continue with the next statement .

For example : not so good example of programming case : case .

Reset Initializing Case does not end with break statement .
After printing " the program falls better example of programming .

But suppose we modify the program slightly and add another case to the switch : We have little problem case :

Working Closing down This is an unpleasant surprise .
The problem is caused by the fact that case is no longer the last case .

If you always put in break statement , you have to worry about whether or not it is really needed .

Finally , we ask the question : What happens when .
In this case , since there is no matching case or default clause , the entire switch statement is skipped .

In this example , the programmer did not default statement because will never be anything but , or .
However , variables can get assigned strange values , so we need little more defensive programming .

Used inside switch it causes the to exit the switch statement .
Inside of for or while loop , it causes loop exit .
The continue statement is only valid inside loop and causes the to go to the top of the loop .

To illustrate how these statements work , produced new of the calculator The new prints the only after valid data is input and has Help command .

The Help command is special .
We want to print the after the Help command , so instead of ending the Help case with break we end it with continue .
The continue forces execution to go to the top of the loop .

When an unknown is entered , we print an error message .
As with the Help case , we use continue statement to skip printing the .

Finally , there is one special command : quit .
This command is handled outside the switch .
It is handled by the break at the top of the loop .
Since the break is outside the switch , it belongs to the while loop and causes the to exit the while .

The flow for this can be seen in Figure .

Page Figure Page Programming Exercises Exercise : Print checkerboard .
Each square should be characters wide .
example follows : Exercise : The total resistance of resistors in parallel is : Suppose we have network of two resistors with the values and .
Then our equation would be : Substituting in the value of the resistors we get : So the total resistance of our network is .

Write to compute the total resistance for any number of parallel resistors .

Exercise : Write to average numbers .

Exercise : Write to print out the multiplication table .

Exercise : Write that reads character and prints out whether or not it is vowel or consonant .

Page Exercise : Write that converts numbers to words .
Example : results in Answers to Chapter Questions Answer : The problem lies with the semicolon at the end of the for statement .
The body of the for statement is between the closing parentheses and the semicolon .

Even though the statement is indented , it is not part of the for statement .
The indentation is misleading .
The compiler does not look at indentation .
The does nothing until the expression becomes false .

Answer : The problem is that we read the number into through .
In the range of legal array indices is to or in this case to .
When we use it strange things happen ; in this case the variable is changed .
The solution is to use only to .

Page Variable Scope and Functions In This .

Scope and Storage Class Functions Summary of Parameter Types Structured Programming Basics Recursion Programming Exercises Answers to Chapter Questions But in the gross and scope of my opinion This bodes some strange eruption to our state .

These are variables that can be set or used almost anywhere in the program .
In this chapter you learn about other kinds of variables and how to use them .
This chapter also tells you how to divide your code into functions .
Many aspects of functions are detailed , including function overloading , using functions to build structured programs , and the use of recursive function calls .

Scope and Storage Class All variables have two attributes , scope and storage class .
The scope of variable is the area of the program where the variable is valid .
global variable is valid from the point it is declared to the end of the program .
local scope is limited to the block where it is declared and cannot be accessed or outside that block .
block is section of code enclosed in curly braces .
Figure illustrates the difference between local and global variables .

It is possible to declare local variable with the same name as global variable .

Normally , the scope of the variable count declaration in Figure would be the whole program .
The declaration of second , local count takes precedence over the global declaration inside the small block where the local count is declared .
In this block , the global count is hidden .
You can also nest local declarations and hide local variables .
These local " variables have an even smaller and more local scope than the local " variables .

Local and global variables of the previous sentence gives you some idea why using nesting to hide local variables does not make your program easy to Figure illustrates hidden variable .

Figure Hidden variables The variable count is declared both as local variable and as global variable .
Normally the scope of would be the entire program , but when variable is declared inside block , that instance of the variable becomes the Page active one for the length of the block .
The global has been hidden by the local for the scope of this block .
The shaded area in the figure shows where the scope of is hidden .

It is not good programming practice to hide variables .
The problem is that when you have the statement : it is difficult to tell which you are referring to .
Is it the global  the one declared at the top of main , or the one in the middle of the while loop .
It is better to give these variables different names , such as ,  and .

The storage class of variable may be either permanent or temporary .
Global variables are always permanent .
They are created and initialized before the program starts and remain until it terminates .
Temporary variables are allocated from section of memory called the stack at the beginning of the block .
If you try to allocate too many temporary variables you will get stack overflow error .
The space used by the temporary variables is returned to the stack at the end of the block .
Each time the block is entered , the temporary variables are initialized .

The size of the stack depends on the system and compiler you are using .
On many UNIX systems , the program is automatically allocated the largest possible stack .
On other systems , default stack size is allocated that can be changed by compiler switch .
In the stack space must be fewer than bytes .
This may seem like lot of space , but several large arrays can eat it up quickly .
You should consider making all large arrays permanent .

Local variables are temporary unless they are declared static .

NOTE static has an entirely different meaning when used with global See Chapter , Modular Programming .
For complete discussion of the many meanings of the word " see Table .

Example illustrates the difference between permanent and temporary variables .
We have chosen obvious variable names ; temporary is temporary variable while permanent is permanent .
initializes temporary each time it is created the beginning of the for statement , while permanent gets initialized only once , at program time .

In the loop both variables are incremented .
However , at the top of the loop temporary is initialized to .

Page Example .

The output of this program is : Temporary Temporary Temporary NOTE Temporary variables are sometimes referred to as automatic variables because the space for them is allocated automatically .

The qualifier auto can be used to denote variable ; however , in practice auto is almost never used .

Table describes the different ways variable can be declared .

Table Declaration Modifiers Declared Scope .

Once NOTE The keyword static is the most overloaded operator .
It means lot of different things depending on how it is used .
For complete list see Table .

Page Functions Functions allow you to group commonly used code into compact unit that can be used repeatedly .
You have already encountered one function , main .
It is special function called at the beginning of the program .
All other functions are directly or indirectly called from main .

Suppose you want to write program to compute the area of three triangles .
You could write out the formula three times , or you could create function to do the work and then use that function three times .
Each function should begin with comment block containing the following : Name Name of the function Description Description of what the function does Parameters Description of each parameter to the function Returns Description of the return value of the function Additional sections may be added such as file formats , references , or notes .
Refer to Chapter , Style , for other suggestions .

The function to compute the area of triangle begins with : Triangle compute area of triangle Parameters width width of the triangle height height of the triangle Returns area of the triangle The function proper begins with the lines : float is the function type .
This defines the type of data returned by the function .
Parameters are variables local to the function that are used to pass information into the function .

Page NOTE The function type is not required by .
If no function type is declared , the type defaults to int .
However , if you omit the function type , it is not clear whether you want to have the function default to int or you just forgot the function type .
To avoid this confusion , always declare the function type and do not use the default .

The function computes the with the statement : width height .

left is to give the result to the caller .
This is done with the return statement : The full triangle function can be seen in Example .

When sees this function call it performs the following operations : variable Begin execution of the first line of the function triangle .

Page The technical name for this type of parameter passing is by " The assignment only occurs when the function is called , so data flows through the parameters only one way : in .

The return statement is how you get data out of the function .
In the triangle example , the function assigns the local variable the value and then executes the statement return , so the return value of this function is .
This value is assigned to .

Example computes the of three triangles .

Functions must be declared just like variables .
The declaration tells the compiler about the return value and parameters .
There are two ways of declaring function .
The first is to write the entire function before used .
The other is to define called function prototype , which gives the compiler just enough information to call the function .
function prototype looks like the first Page line of the function , only the function has no body .
For example , the prototype for the function is : float  float ; Note the semicolon at the end of the line .
This is used to tell that this is prototype and not real function .

allows you to leave out the parameter names when declaring prototype .
This function could just as easily have been written : float , However , this technique is not commonly used .
The reason is that very easy to create prototype by simply using the editor to copy the first line of function and put that line where you want the prototype .

Functions that have no parameters are declared with parameter list of void .
For example : int ; The keyword void also used to indicate function that does not return value to the FORTRAN SUBROUTINE or PASCAL .
For example , this function just prints result , it does not return value .

Ordinary parameters can be changed inside functions , but the changes will not be passed back to the calling program .

Page For example , in the function , we never change or .
These could easily be declared const .
Since the return value also something that cannot be changed , it can be declared const as well .
The const declarations serve to notify the programmer that the parameters do not change inside the functions .
If you do attempt to change const parameter , the compiler generates an error .
The improved function with the const declarations can be seen in Example .

Reference Parameters and Return Values Remember that in Chapter , Basic Declarations and Expressions , we discussed reference variables .
reference variable way of declaring an additional name for variable .
For global and local variables , reference variables are not very useful .
However , when used as parameters they take on an entirely new .

Suppose you want to write subroutine to increment counter .
If you write it like Example , it work .

Because defaults to call by value .
This means that values go in , but they come out .

What happens if you convert the parameter counter to reference .
References are just another way of giving the same variable two names .
When called , counter becomes reference to .
That means that anything done to counter results in changes to .
Example , using reference parameter , works properly .

Examining this program we find that it looks lot like Example except for the " in front of counter .
This " tells that counter reference and not normal parameter .

Reference declarations can also be used for return values .
For example , Example finds the biggest element in an array .

When used on it returns reference to .
Remember that in the following code ,
The following three code sections all perform equivalent operations .
The actual variable , does not change ; however , the way we refer to it does .

Page Dangling References You should be careful when using by " If not careful , you can wind up with reference to variable that no longer exists .
Example illustrates this problem .

Example cc return ;

It returns reference to the smaller of two integers .

In line we call this function .
Before the function min called creates temporary integer to hold the value of the expression +
reference to this temporary passed to the min function as the parameter .
creates another temporary for the parameter .

The function min then called and returns reference to .

It refers to temporary that created in main .
At the end of the statement can destroy all the temporaries .

look at the call to min in more detail .
pseudocode version of line , including the details that normally hides from the programmer : create integer , assign it the value + create integer , assign it the value + bind parameter so it refers to tmpl bind parameter so it refers to .

Page At the end of line we have bad situation : refers to temporary variable that has been destroyed .
In other words , points to something that does not exist .
This is called dangling reference and should be avoided .

Array Parameters So for dealt only with simple parameters .
treats arrays little differently .
First of all , you have to put size in the prototype declaration .
For example : int ; uses scheme called by address " to pass arrays .
Another way of thinking of this is that automatically turns all array parameters into reference parameters .

This allows any size arrays to be passed .
The function sum we just declared may accept integer arrays of length , or any length .

However , if you want to put in size you can .
allows this although it ignores whatever number you put there .
But by putting in the size you alert the people reading your program that this function takes only arrays .

Now we have two functions with the same name .

In older languages such as and PASCAL that would be true .

allows function overloading , which means you can define multiple functions with the same names .
Thus you can define square function for all types of things : int , float , short int , double , and even char if we could figure out what it means to square character .

To keep your code consistent , all functions that use the same name should perform the same basic function .
For example you could define the following two square functions : Square an integer .

This is perfectly legal code , but it is confusing to anyone who has to read the code .

The problem is that uses the parameter list to tell the functions apart .
But the parameter list of the two routines is the same :
The result is that tell these two routines apart and flags the second declaration as an error .

Default Parameters Suppose you want to define function to draw rectangle on the screen .
This function also needs to be able to the rectangle as needed .
The function definition is : After using this function for while , you discover that of the time you use the ability of draw to .
In other words , of the time the factor is .

allows you to specify default value for .

Can you tell whether the programmer intended for the to be or just forgot to put it in .

Although sometimes useful , the default parameter trick should be used sparingly .

Unused Parameters If you define parameter and fail to use it , most good compilers will generate warning .

But what about the times you really want to use parameter .
Is there way to get to shut up and not bother you .
The trick is to leave out the name of the parameter .

Some people consider this style ugly and confusing .
right that not that easy to read .

There ought to be better way ; just wish could think of one .

One question you might be asking by now is , would ever write code like this .
Why not It turns out that many programming systems make use of callback functions .
For example , you can tell the Window System , the ' button is pushed call the function " Your callback function may handle many buttons , so important to know which button is pushed .
So supplies button as parameter to the function .

What happens if you know that only button can cause to call .
Well , is still going to give it to you , just going to ignore it .
why some functions have unused parameters .

Whenever calls function there is some overhead generated .
This includes putting the parameters on the stack , entering and leaving the function , and stack after the function returns .

For example , the .

As you can see from this code , there are eight lines of overhead for two lines of work .
allows you to cut out that overhead through the use of the inline function .
The inline keyword tells that the function is very small .
This means that simpler and easier for the compiler to put the entire body of the function in the code stream instead of generating call to the function .

Expanding the function inline has eliminated the eight lines of overhead and results in much faster execution .

The inline modifier provides valuable hint it can use when generating code .

Inline tells the compiler that the code is extremely small and simple .
Like Page register , the inline modifier is hint .
If the compiler generate function inline , it will create it as an ordinary function .

Summary of Parameter Types Table lists the various parameter types .

Table Parameter Types Type Declaration .

Value is passed into the function and can be changed inside .

Constant call by value .

Reference is passed to the function .

Constant reference Value cannot be changed in the function .
This form of parameter is more efficient than call by value " for Array .

Value is passed in and may be modified .

Call by address .

Passes pointer to an item .
Pointers are covered in Chapter , Simple Pointers .

Structured Programming Basics Computer scientists spend great deal of time and effort studying how to program .
The result is that they come up with the absolutely , positively , best programming new one each month .
Some of these systems include flow charts , programming , programming , structured programming , and programming .

Now that you have learned about functions , we can talk about using structured programming techniques to design programs .
This is way of dividing up or structuring program into small , functions .
It makes the program easy to write and easy to understand .
claim that this system is the absolute best way to program .
It happens to be the system that works best for me .
If another system works better for you , use it .

Page Structured programming concentrates on code .
Later see how to merge code and data to form classes and begin to perform programming .

The first step in programming is to decide what you are going to do .
This has already been described in Chapter , The Programming Process .
Next , decide how you are going to structure your data .

Finally , the coding phase begins .
When writing paper , you start with an outline , with each section in the paper described by single sentence .
The details are filled in later .
Writing program is similar .
You start with an outline , but this outline is your main function .
The details can be hidden within other functions .
For example , the program in Example solves all of the problems .

global solution .

Of course , some of the details remain to be filled in .

Start by writing the main function .
It should be less than two pages long .
If it grows longer , consider splitting it up into two smaller , simpler functions .
The size of the function should be limited to three pages because that is about the maximum amount of information human being can store in memory at one time .
After the main function is complete , you can start on the other functions .
This type of structured programming is called programming .

You start at the top and work your way down .

Another type of coding is called programming .
This involves writing the function first , testing it , and then building on that working set .
tend to use some techniques when working with new function that used before .

write small function to make sure really know how the function works and continue from there .
This is the approach used in Chapter to construct the calculator program .

In actual practice , both techniques are useful .
This results in mostly , partially technique .
Computer scientists have term for this methodology : chaos .
The one Page Recursion Recursion occurs when function calls itself directly or indirectly .
Some programming functions lend themselves naturally to recursive algorithms , such as the factorial .

recursive function must follow two basic rules :
It must have an ending point .

It must make the problem simpler .

definition of factorial is :

Second , it simplifies the problem because is simpler than .

Factorial is legal only for .
But what happens if we try to compute .
The program aborts with stack overflow or similar message .
There is no ending point .
This is called an infinite recursion error .

Many things we do iteratively can be done recursively , such as summing the elements of an array .
You can define function to add elements through of an array as follows : If you have only one element , then the sum is simple .

Otherwise , it is the sum of the element and the sum of the rest .

Exercise : Write function , that returns true if begins .
Write program to test the function .

Exercise : Write function count , array , that will count the of times appears in array .
The array has length elements .
The function should be recursive .
Write test program to go with the function .

Exercise : Write function that will take character string and return primitive hash code by adding up the value of each character in the string .

Exercise : Write function that returns the maximum value of an array of numbers .

Exercise : Write function that scans string for the character " and replaces it with .

Answers to Chapter Questions : The programmer went to lot of trouble to explain that the for loop did nothing increment the .
However , there is no semicolon at the end of the for .
keeps reading until it sees statement this case and puts that in the for loop .

contains correctly written version of the program .

Page Loop until we reach the end of string character .

When was still being developed , it soon became apparent that needed facility for handling named constants , macros , and include files .
The solution was to create preprocessor that is run on the programs before they are passed to the compiler .
The preprocessor is nothing more than specialized text editor .

Its syntax is completely different from and it has no understanding of constructs .
It is merely dumb text editor .

The preprocessor was very useful and soon it was merged into the main compiler .
The compiler kept this .
On some systems , like UNIX , it is still separate program , automatically executed by the compiler wrapper cc .
Some of the newer compilers , like , have the built in .

For example , the following two lines perform similar functions :

This takes the drudgery and guesswork out of making changes .

Page All preprocessor commands begin with hash mark in column .
is free format .

Language elements can be placed anywhere on line , and the is treated just like space .
The preprocessor is not free format .
It depends on the hash mark being in the column .
As you will see , the preprocessor knows nothing about and can be used to edit things other than programs .

WARNING The preprocessor is not part of the compiler .
It uses an entirely different syntax and requires an entirely different to use it well .
Most problems you will see occur when the preprocessor is treated like .

Preprocessor directives terminate at the end of the line .
In semicolon ends statement .
The preprocessor directives do not end in semicolon , and putting one in can lead to unexpected results .
preprocessor directive can be continued by putting backslash at the end of the line .
The simplest use of the preprocessor is to define replacement macro .
For example , the command : FOO bar occurs .
It is common programming practice to use all uppercase letters for macro names .
This makes it very easy to tell the difference between variable and macro .

The general form of simple define statement is : Name Name can be any valid identifier .
can be anything as long as it fits on single line .
The can include spaces , operators , and other characters .

It is possible to use the following definition : and use it like : Clear the array .

Page programmer wants to know what the loop does , he must search the beginning of the program for the definition of .

It is even worse to define macros that do replacement of basic programming constructs .
For example , you can define the following : BEGIN END .

BEGIN ; END The problem is that you are no longer programming in , but in mongrel .

The preprocessor can cause unexpected problems because it does not check for correct syntax .
For example , Example generates an error on line .

Example .

The definition in line causes the to expand line to look like : Because is an illegal operator , this generates syntax error .

Page Question : The following program generates the answer instead of the expected Example .

CC sends the output of the preprocessor to the standard output .

In , the command : cpp creates file called prog containing the output of the preprocessor .

Running the program For Example through thepreprocessor gives you .

Example " About lines of stuff omitted .

NOTE The output of the preprocessor contains lot of information , most of which can easily be ignored .
In this case , you need to scan the output till you reach the line .
Examining this line will give you an idea of what caused the error .

Question : Example generates warning that counter is used before it is set .

This is surprise because the for loop should set it .
You also get very strange warning , effect , line .

Question : Example computes the wrong valuefor .

Question : The following program supposed to print the message Error : Abort " and exit when it receives bad data .
But when it gets good data , it exits .

Example .

However , the use of const preferred over for several reasons .
First of all , checks the syntax of const statements immediately .
The directive not checked until the macro used .
Also , const uses syntax , while has syntax all its own .
Finally , const follows normal scope rules , whereas constants defined by directive continue on forever .

In most cases const statement preferred over .
Here are two ways of defining the same constant .

Conditional Compilation One problem programmers have writing code that can work on many different machines .
In theory , code portable ; in actual practice many machines have little quirks that must be accounted for .
For example , this book covers UNIX , MSDOS , and Windows compilers .

Although they are almost the same , there are some differences , as you will see in Chapter , Portability Problems .

The preprocessor allows you great flexibility in changing the way code generated through the use of conditional compilation .
Suppose you want to put debugging code in the program while you are working on it and then remove the debugging code in the production version .
You could do this by including the code in an section .

If the beginning of the program contains the directive : DEBUG Turn debugging on the included .
If the program contains the directive : DEBUG Turn debugging off the omitted .

Strictly speaking the DEBUG unnecessary .
If there no DEBUG statement , then DEBUG undefined .
The DEBUG statement used to indicate explicitly to anyone reading the code that DEBUG used for conditional compilation and now turned off .

The directive will cause the code to be compiled if the symbol not defined .

Page reverses the sense of the conditional .
For example : DEBUG version .
Debugging ; DEBUG ; DEBUG programmer may wish to temporarily remove section of code .
common method of doing this to comment out the code by enclosing it in .
This can cause problems , as shown by the following example : Comment out this section ; Handle the stuff ; End of commented out section This generates syntax error for the fifth line .

better method to use the construct to remove the code .

For example , the command : prog compiles the program and includes all the code in DEBUG pairs even though there no DEBUG in the program .
The equivalent  tcc The general form of the option is or .
For example , the following sets to : prog Most compilers automatically define some symbols .
For example , defines the symbol and .
The ANSI standard compiler defines the symbol .
compilers define the symbol .
Most UNIX compilers define name for the system , Sun , VAX , celerity , however , they are rarely documented .
The symbol unix is always defined for all UNIX machines Page NOTE options specify the initial of symbol only .

Any and directives in the program can change the .
For example , the directive : DEBUG results in DEBUG being undefined whether or not you use .

This tells the preprocessor to take the file and insert it in the current program .
Files that are included in other programs are called headerfiles .
In UNIX , these files are usually located in .
In , they are located in the directory .

Standard files are used for defining data structures and macros used by library routines .

For example , is standard class that you know by prints data on the standard output .
The ostream class definition used by and its related routines is defined in .

Sometimes you may want to write your own set of files .
Local files are particularly useful for storing constants and data structures when program spans several files .

They are especially useful for information sharing when team of programmers is working on Local files may be specified by using double quotation marks around the filename .

The filename can be any valid filename .
This can be simple file , relative path , called ; or an absolute path , called Page Include files may be nested .
This can cause problems .
Suppose you define several useful constants in the file .
If the files and both and you put the .

Defining constant twice is not fatal error ; however , defining data structure or union twice is an error and must be avoided .

One way around this problem is to have check to see whether it has already been included and not define any symbols that have already been defined .

Look at the following code : Define constants When is included , it defines the symbol .
If that symbol is already defined the file was included , the conditional hides all the other defines so they cause trouble .

NOTE It is possible to put code in header file .
This is considered poor programming practice .
By convention , code goes in files and definitions , declarations , macros , and inline functions go in the files .

Parameterized Macros So far we have discussed only simple or macros .
Macros can take parameters .

The following macro computes the square of .

It is good rule always to put parentheses around the parameters of macro .
Example illustrates the problems that can occur if this rule is not followed : Example .

When used in an expression , they are considered side effects , and this can lead to unexpected results as illustrated in Example .

Why does this not produce the expected output .

In the program shown in Example the is expanded to in this case .
The result is that goes up by each time through the loop .
The actual result of this expression is system dependent .

Question : The following program tells us we have an undefined variable , but our only variable name is .

Example .

For more extensive example of how to use this operator see Chapter , Putting It All Together .

Parameterized Macros Versus Inline Functions In most cases it is better to use an inline function instead of parameterized macro , to avoid most of the traps caused by parameterized macros .
But there are cases where parameterized macro may be better than an inline function .
For example , the SQR macro works for both float and int data types .
have to write two inline functions to perform the same functions .

Advanced Features This book does not cover the complete list of preprocessor directives .
Among the more advanced features are an advanced form of the directive for Page conditional compilations and the directive for inserting commands into file .
See your reference manual for more information on these features .

Summary The preprocessor is very useful part of the language .
It has completely different look and feel from .
However , it must be treated apart from the main compiler .

Problems in macro definitions often do not show up where the macro is defined , but result in errors much further down in the program .
By following few simple rules , you can decrease the chances of having problems .

Put parentheses around everything .
In particular they should enclose constants and macro parameters .

When defining macro with more than one statement , enclose the code in .

Programming Exercises Exercise : The standard contains boolean type that defines the values true and false .
The problem is most compilers implemented this type yet .
Create boolean type by using to define values for BOOLEAN , TRUE , and FALSE .

Exercise : Write macro that returns true if its parameter is divisible by and false otherwise .

Exercise : Write macro that returns true if its argument is decimal digit .

Write second macro that returns true if its argument is hex digit .
The second macro should reference the first .

Exercise : Write preprocessor macro that swaps two integers .

If you change definition of to : program executes correctly .

Answer : The preprocessor is very program .
When it defines macro , everything past identifier is part of macro .
In this case , definition of MAX is literally .
When for statement is expanded , result is : allows you to compute result and throw it away .
For this statement , program checks to see whether is and discards answer .

Answer : As with previous problem , preprocessor does not respect syntax conventions .
In this case programmer used semicolon to end statement , but preprocessor included it as part of definition for .
The assignment statement for  expanded , is : The two semicolons at end do not hurt anything , but one in middle is killer .
This line tells to do two things : assign to and compute and throw it away results in null effect .

Answer : The output of preprocessor looks .

The problem is that two statements follow if line .
Normally they would be put on two lines .
If we properly indent this program we .

From this it is obvious why we always exit .
The fact that there were two statements after if was hidden by using single preprocessor macro .
The cure for this problem is to put curly braces around all multistatement macros .

To avoid this problem , inline functions instead of parameterized macros .

Answer : The only difference between parameterized macro and one without parameters is parentheses immediately following macro name .
In this case , space follows definition of RECIPROCAL , so it is not parameterized macro .
Instead it is simple text replacement macro that replaces RECIPROCAL with : space between RECIPROCAL and corrects problem .

Page Bit Operations In This .

Bit Operators The AND Operator Bitwise OR The Bitwise Exclusive OR The Ones Complement Operator The Left and Right Shift Operators Setting , Clearing , and Testing Bits Bitmapped Graphics Exercises Answers to Questions To be or not to be , that is question .

bit is smallest unit of information .

Normally it is represented by values and .

They allow programmer to get hood " of machine .
Many programs will never need bit operations .
Lowlevel coding such as writing device drivers or graphic programming requires bit operations .
If you plan to program only at higher level , this chapter may be safely skipped .

Eight bits together form byte , represented by data type char .
byte might contain following bits :

This can also be written as hexadecimal number .
Table gives hexadecimal to binary conversion : Table .
Hex and Binary Hex Binary .

So the hexadecimal number represents the binary number .

Bit Operators Bit , or bitwise , operators allow the programmer to work on individual bits .
For example , short integer holds bits most .
The bit operators treat each of these as an independent bit .
By contrast , an add operator treats the bits as single number .

Bit operators allow you to set , clear , test , and perform other operations on bits .
The bit operators are listed in Table .

Table Bit Operators Operator Meaning .

These operators work on any integer or type .

The AND operator compares two bits .

The results of the AND operator are defined in Table .

Table AND Operator .

Page When two variables are " together , the AND operator works on each bit independently .
The following program segment illustrates this .

The output this program is : This is because :

In the logical AND if both operands are true , the result is true .
In bitwise AND , if the corresponding bits both operands are true , then the corresponding bits the results are true .
So the bitwise works on each bit independently while the logical AND works on the operands as whole .

AND However , and are different operators , as Example .

Answer : The operator is bitwise AND .
The result the bitwise AND is zero .

If the programmer had used the first form : and made the mistake using instead : the program would still have executed correctly .

NOTE Soon after discovering the bug illustrated by this program told my office mate , now understand the difference between AND and AND , and he understood me .
How we understand language has always fascinated me , and the fact that could utter such sentence and have someone understand it without trouble amazed me .

You can use the bitwise AND operator to test whether number is even or odd .
In base , the last digit all even numbers is zero and the last digit all odd numbers is one .
The following function uses the bitwise AND to pick off this last digit .
If it is zero even , the the function is true .

The inclusive OR operator known as just the OR compares its two operands .

Table lists the truth table for the OR operator .

The truth table for the exclusive OR operator is listed in Table .

Table Exclusive OR .

Table NOT Operator Bit .

Page On byte this is : The left shift operator moves the data left specified number of bits .
Any bits that are shifted out the left side disappear .
New bits coming in from the right are zeros .
The right shift does the same thing in the other direction .
For example : Shifting left by one is the same as multiplying by .
Shifting left by two is the same as multiplying by , or .
You can see pattern forming here .
Shifting left by places is the same as multiplying by .
Why shift instead of multiply .
Shifting is faster than multiplication , so .

The compiler is smart enough to perform the speedup automatically .
This means that putting in shift gains you nothing at the expense of clarity .

The left shift operator multiplies ; the right shift divides .

Again , this clever trick should not be used in modern code .

Right Shift Details Right shifts are particularly tricky .
When variable is shifted to the right , needs to fill the space on the left side with something .
For signed variables , Page uses the value of the sign bit .
For unsigned variables , uses zero .
Table illustrates some typical right shifts .

Table Right Shift Examples Signed Character Signed Character Unsigned Character Expression .

Each of these can be treated as separate flag .
Bit operations can be used to pack eight values in single byte .
For example , suppose you are writing communications program .
You are going to store the characters in an buffer for later use .
With each character you will also store set of status flags .
The flags are listed in Table .

Table Communications Status Values Name Description .

Power was lost on the communication device You could store each flag in its own character variable .
That would mean that for each character buffered , you would need five bytes of status storage .
For large buffer , that adds up .

By instead assigning each status flag its own bit within an status character , you cut storage requirements down to of the original need .

You can assign the flags the bit numbers listed in Table .

Bit Assignments Bit Name .

Page Table Bit Assignments Bit Name .

Bits are numbered by convention .
The constants for each bit are defined in Table .

Table Bit Values Bit Binary Value .

Table shows how you can use the left shift operator to define bits .

The Left Shift Operator and Bit Definition Representation Base Equivalent .

Bit Page Representation Base Equivalent .

Bit Although it is hard to tell what bit is represented by , easy to tell what bit is meant by .

The flags can be defined as : True if any error is set const int ; framing error occurred for this character const int ; Character had the wrong parity const int ; The carrier signal went down const int ; Power was lost on the communication device const int ; Now that you have defined the bits , you can manipulate them .
To set bit , use the operator .

Suppose you want to clear the bit .
In binary this bit is .
You want to create mask that has all bits set except for the bit you want to clear .

The mask is then ANDed with the number to clear the bit .

More and more computers now have graphics .
For the PC , there are graphics devices like EGA and VGA cards .
For UNIX , there is the windowing system .

In bitmapped graphics , each pixel on the screen is represented by single bit in memory .
For example , Figure shows bitmap as it appears on the screen and enlarged so you can see the bits .

Suppose we have small graphic pixel monochrome display .
We want to set the bit at ,
The bitmap for this device is shown as an array of bits in Figure .

There is no data type for an array of bits in .
The closest we can come is an array of bytes .
Our array of bits now becomes array of bytes , as shown in Figure .

To set the pixel at bit number we need to set the fourth bit of byte .
To set this bit we would use the statement : Page .

Figure Array of bytes The constant is the leftmost bit .

We can generalize this process to produce macro that turns on the bit located at ,

We need to compute two values : the coordinate of the byte and the number of the bit within the byte .

Our bit address is ,
Bytes are groups of eight bits , so that means that our byte address is ,

The bit within the byte is not so simple .
We want to generate mask consisting of the single bit we want to set .
For the leftmost bit this should be , or .

The next bit is , or , and occurs when .
So to generate our bit mask we use the expression .

Now that we have the byte location and the bit mask , all we have to do is set the bit .
The following function sets given bit in bitmapped graphics array named graphics .

Example draws diagonal line across the graphics array and then prints the array on the terminal .

The constant is used since we have bits across , which translates to bytes .

The main for loop : draws diagonal line across the graphics array .

Since we do not have bitmapped graphics device we will simulate it with the subroutine .

There are eight bits in each byte handled by the .

This loop causes the variable to start with leftmost .
For each iteration of the loop , the is moved to the right one by .
When we run out of bits , the loop exits .

The loop counter cycles through .

Finally , at the heart of the loops is the code : Binary Hex .

Programming Exercises Exercise : Write set of inline functions , and , to go with the operation defined in Example .
Write main program to test these functions .

Exercise : Write program to draw bitmapped square .

Page Exercise : Change Example so it draws white line across black background .

Exercise : Write program that counts the number of bits set in an integer .
For example , the number , which , has two bits set .

Exercise : Write program that takes integer and splits it into eight Exercise : Write program that will take all the bits in number and shift them to the left end .
For example , would become .

Answers to Chapter Questions Answer : defined to be number by the ; however , the eight bits in character variable are numbered .

solution to this problem to make flags short integer with bits .

Answer : The problem that character .
The value represented in bits .
The first  the sign  set .
When right shift done on this variable , the sign used for fill , so .

The variable works even though it signed because it bits long .

Notice that the got set nowhere near the sign .

The solution to the problem to declare as an unsigned variable .

Page III Advanced Types and Classes Page Advanced Types In This .

Structures Unions typedef enum Type Bit Fields or Packed Structures Arrays of Structures Programming Exercises Total grandeur of total edifice .
Chosen by an inquisitor ofstructures Stevens provides rich set of data .
Through the use of structures , unions , enum , and class  the programmer can extend the language with new .

Structures Suppose you are writing an inventory program for warehouse .
The warehouse filled with bins each containing bunch of parts .
All the parts in bin are identical , so you have to worry about mixed bins or partials .

For each bin you need to .

The name of the part it holds string .

The price .

In previous chapters you have used arrays for storing group of similar  but in this example you have mixed bag : two integers and string .

Instead of an array , you will use new type called structure .
In an array , all the elements are of the same type and are numbered .
In structure , each element , or field , named and has its own type .

Page The general form of structure definition .

Name of the part How many are in the bin Where we put the print cables This definition actually tells two things .
The first what struct bin looks like .
This statement defines new type that can be used in declaring other variables .
This statement also declares the variable .
Since the structure of bin has been defined , you can use it to declare additional variables : struct bin ; Place to put terminal cables The part of the definition may be omitted .

Name of the part How many are in the bin Where we put the print cables The variable still to be defined , but no type created .
The type for this variable an anonymous structure .

The part also may be omitted .
This would define structure type but no variables .

In an extreme case , both the and the parts may be omitted .
This creates section of correct but totally useless code .

Once the structure type has been defined you can use it to define variables : struct bin ; Define the box holding printer cables allows the struct to be omitted , so you can use the following declaration : bin ; Define the box holding printer cables Page You have defined the variable containing three named fields : name , quantity , and .
To access them you use the syntax : variable .

Structures may be initialized at declaration time by putting the list of elements in curly braces .

Unions structure is used to define type with several fields .
Each field takes up separate .

The fields and share the same space .
You might think of structure as large box divided up into several different compartments , each with its own name .
union is box , not divided at all , with several different labels placed on the single compartment inside .

In structure , the fields do not interact .
Changing one field does not change any others .
In union , all fields occupy the same space , so only one may be active at time .
In other words , if you put something in , assigning something to wipes out the old value of .

Page The following shows how union may be used : Define variable to hold an integer or .

Suppose you want to store the information about shape .
The shape can be any standard shape such as circle , rectangle , or triangle .
The information needed to draw circle is different from the needed to draw rectangle , so you need to define different structures for each .

The first field is code that tells you what type of shape you have .
The second is union that holds the shape .

Graphically you can represent shape as large box .
Inside the box is the single integer kind and our union .
The union is box with three labels on it .
The question is which one is the " label .
You tell from looking at the union , but why you defined It tells us which label to read .
The layout of the shape structure is illustrated by Figure .

Figure " layout .

This provides way for you to extend basic types .
The general form of the typedef statement is : typedef The is the same as variable declaration except name is used instead of variable name .
For example : typedef int width ; Define that is the width of an object defines new  width , that is the same as an integer .

These values are referenced by name .
The compiler assigns each tag an integer value internally , such as the days of the week .
You could use the directive const to create values for the days of the week as follows : typedef int ; const const const const const const const int int int int int int int Define the for days of the week .

As with structures , the or the may be omitted .
The tags may be any valid identifier ; however , tags are usually all uppercase .

An additional advantage of using an enum is that will restrict the values that can be used to the ones listed in the enum declaration .
The following will result in compiler error : is not One disadvantage of using enum is that enum variables cannot be used to index an array .

This accomplished through the cast or typecast operation .
The expression tells , know not an integer , but treat it like " To fix the above problem , use the statement :  Page Casts are also useful in expressions to make sure the variables have the correct .
In general , you can change the of almost any expression with the expression : This particularly useful when working with integers and floating point numbers .

also supports the older casting .
The syntax for casting  value For example : Turn " into floating point number casts are frowned upon because they can easily be ambiguous .
For example , in the expression : + does the apply to or +

To make this expression clearer you need to add parentheses : + As you can see , this form more complex than casts .
Simpler better , so use casting .
Packed structures allow you to declare structures in way that takes up minimum of storage .
For example , the following structure takes up bytes .

Unpacked structure However , the fields list and seen can have only two values , and , so only bit needed to represent them .
You never plan on having more than items or .

You can redefine this structure using bit fields , so , it takes only bytes , by following each field with colon and the number of bits to be used for that field .

Packed structure Packed structures should be used with care .
The machine code to extract data from bit fields relatively large and slow .
Unless storage problem , packed structures should not be used .

In Chapter , Bit Operations , you needed to store character data and five status flags for characters .
In this case , using different byte for each flag would eat up lot of storage bytes for each incoming .
You used Page bitwise operations to pack the five flags into single byte .
Alternatively , packed structure .

Character from device True if any error set framing error occurred Character had the wrong parity The carrier signal went down Power was on the channel Using packed structures for flags clearer and less than using bitwise operators .

However , bitwise operators allow additional flexibility .
You should use the one that clearest and easiest for you to use .

Arrays of Structures Structures and arrays can be combined .
Suppose you want to record the time runner .

Each element consists of single time structure .

You can use this as follows : Runner just past the timing point .

Suppose you want to write program to handle mailing list .
Mailing labels are lines high and characters wide .
You need structure to store names and addresses .
The mailing list will be sorted by name for most printouts , and sorted in order for actual mailings .
The mailing list structure looks .

Exercise : Design structure to store time and date .
Write function to find the difference between two times in minutes .

Exercise : Design an airline reservation data structure that contains the following data : Flight number Departure time Arrival time Write program that lists all the planes that leave from two airports specified by the user .

Page Simple Classes In This .

Stacks Improved Stack Using Class Introduction to Constructors and Destructors Automatically Generated Member Functions Shortcuts Style Programming Exercises She thinks that even up in heaven Her class lies late and snores Connolly So far used simple variables and structures to hold data and functions to process the data .
classes allow you to combine data and the functions that use it .

In this chapter see how class can improve your code by implementing simple stack two ways : first , using structure and functions , and then using class .

Stacks stack is an algorithm for storing data .
Data can be put in the stack using push operation .

The pop operation removes the data .
Data is stored in order .

You can think of stack as stack of papers .
When you perform push operation , you put new on top of the stack .
You can push as many times as you want .
Each time the new data goes on top of the stack .
You get data out of stack using the pop operation , which takes the top off the stack and gives it to the caller .

Suppose you start with an empty stack and put three elements on it , and , using three push operations .
The first pop would return the top element :
The elements and remain in the stack .
Popping again will give us .
You then Page push another value , on the stack .
Popping twice will give us the numbers and , in that order .
This is illustrated by Table .

Stack Operation Operation Stack After Operation .

This structure will need place to put the data and count of the number of items currently pushed on the stack .

Note : This version of the program does not check for stack overflow or other error conditions .

Later , in Chapter , More on Classes , see how you can use this simple stack to make safer , more complex one .

Popping simply removes the top item and decreases the number of items in the stack .

Notice that you need to zero the data field in the stack , since the elements of data are overwritten by the push operation .

You are now finished .
To actually use the stack you declare it with struct statement .
Next you must make sure that you initialize it , and then you can push and pop to your content at least within the limits of the .

Example contains complete implementation of the structure version of the stack and short test routine .

Improved Stack The structure version of the works but has few drawbacks .
The first is that the data and the functions are defined separately , forcing you to pass struct variable into each procedure .

There is also the problem of data protection .
The fields data and are accessible to anyone .
The design states that only the functions should have access to these fields , but there is nothing to prevent rogue code from modifying them .

struct is mixed collection of data .
The class not only holds data like structure , but also adds set of functions for manipulating the data and access protection .

Turning the struct into class you get : class .

This declares two fields : and data .
In class these items are not called fields ; they are called member variables .
The keyword private indicates the access privileges associated with these two member variables .

There are three levels of access privileges : public , private , and protected .

Class  both data and functions , marked private cannot be used outside the class .

They can be accessed only by functions within the class .
The opposite of private is public , which indicates that anyone can access .

Finally , protected is similar to private except that it allows access by derived finished defining the data for this class .
Now you need to define the functions that manipulate the data .

This section starts with the keyword public .
This tells that you want all these member functions to be available to the outside .
In this case , you just define the function prototypes .
The code for the function will be defined later .

Next comes the body of the init function .
Since this function belongs to the class , you prefix the name of the procedure with .

This procedure zeroes the .
In the structure version of the init function you must pass the in as parameter .
Since this function is part of the class , unnecessary .
This also means that you can access the member variables directly .

Using Class Using class is much like using structure .
Declaring class variable is the same , except you use the word class instead of struct .

To call the init member function of the class all you need to do is :

Example contains class version of the .

Introduction to Constructors and Destructors This stack class has one minor inconvenience .
The programmer must call the init member function before using the stack .
However , programmers are terribly forgetful and sooner or later someone is going to forget to initialize the stack .
it be nice if had an automatic way of initializing the stack .

Actually will automatically call number of member functions .
The first you are concerned about is called when the class is created .
This is called the constructor function and has the same name as the class .
For example , the constructor for the stack class is named stack known as stack : outside the class .

variable is created when it is declared .

Constructors can never return value so the void is not needed .
In fact the compiler will complain if present .

Destructors The constructor is automatically called when the variable is created .
The destructor is automatically called when the variable is destroyed .
This occurs when the variable goes out of scope or when pointer variable is deleted .
So , for the stack class the destructor would be named .

Page Suppose you make the rule that the stack should be empty when the programmer is finished with it .
In other words , for every push you do , must be done .
If this happen , an error and you should warn the user .

All you have to do is create destructor for the stack that checks for an empty stack and issues warning if the stack is not empty .
The destructor looks .

The constructor for class can take parameters .
Suppose you want to define class that holds name and phone number .
The data members for this class would look like : class person .

Parameterized Destructors There is no such thing as parameterized destructor .
Destructors take no parameters and supply no return value .
All they do is destroy the variable .

Copy Constructor The copy constructor is special constructor that is used to make an exact copy of class .

This function is expected to turn the current class into an exact copy of the parameter .

On the face of it , the copy constructor seem that important .
But if you remember , back in Chapter , Variable Scope and Functions , you discussed the various ways can pass parameters to function .
One of these was call by value .
where copy of the parameter is made and passed to the function .

When or any other class is passed as parameter , copy is made of that class using the copy constructor .

In the following code , added some commentary to show you the functions that will automatically call behind your back .

As you can see , does lot of work behind the scenes .
It starts when is declared .
calls the default constructor to create .

The variable is used , and then passed to the function .
Since is passed by value , copy must be made of the using the copy constructor .

The function then adds few items to .
Note : This is copy of , so anything you do to does not affect .
At the Page end of the function contains four items , and contains two items ,

Finally after the function call , you print out the top element of , which is .

Automatically Generated Member Functions Every class has constructor and destructor .
If the programmer does not write these member functions , will automatically generate them .
Also , there are several member functions such as the copy constructor that can be called automatically .

Automatically Generated and Used Functions Default constructor .

Automatically generated if no other constructors are defined .
The generated code fills the data members of the class with random values .

Automatically called when variable of this class is declared with no parameters , such as : var ; Copy constructor .

Automatically generated unless the programmer explicitly defines copy constructor .
The function generates copies all the data members from the old class to the new .

Automatically called when passing parameter to function .
This member function may also be called when creating duplicate of .

Automatically generated unless the programmer defines .

Page Automatically called when variable is destroyed .
This occurs when variable goes out of scope .
The function generates copies all the data members from the old class to the new .

So far you have used only function prototypes in the classes created .
It is possible to define the body of the function inside the class itself .
Thus : class .

Page Style Programming style for classes looks pretty much like the style for structures and functions .

Every member variable should be followed by comment explaining it and every member function should be commented like function .

However , you comment the prototypes for member functions differently from normal function prototypes .
For normal functions you put full function comment block in front for the prototype .
If you did this for the member functions of class , the comments would obscure the structure of the class .
This is of the few cases when too many comments can cause trouble .

So you put comment in front of each member function prototype and full comments in front of the function itself .

But what about functions , where the entire body of the function is declared inside the class .

If you put in full comments , you obscure the structure of the class .
If you put in , you omit lot of useful information .
Proper commenting is balancing act .
You need to put in useful and leave out not .

The solution is to keep the size of the function small .
There are two reasons for this , first all inline functions should be small and , secondly , large functions declared inside class make the class excessively complex .
good rule of thumb is that if the function requires more than about five lines of code , put prototype in the class and put the body of the function elsewhere .

The structure of very small member functions should be obvious and thus not require comment block .
If the function is not obvious and requires extensive comments , you can always put in prototype and comment the body of the function later in the program .

does not require an access protection declaration , private , or before the first member variable .
The following is perfectly .

If you put in an explicit declaration , then you have to worry about questions like this .
Suppose you have class that does not specify copy constructor , such as : Page Comments describing the class Note : The style of this class leaves something to be desired class queue .

Will the copy constructor automatically generated by work , or did the programmer design this class knowing that the copy constructor would never be called .
These important questions are not answered by the class as written .

All classes have default constructor , copy constructor , assignment  and destructor .
If you want to use the generates automatically , put comment in the class indicating that the default is being used .

Use automatically generated destructor .

Now it is obvious what member functions the programmer wanted to let generate automatically , and being obvious is very important in any programming project .

The copy constructor automatically generated by is rather simple and limited .
It work in all cases , as see later when you start to construct more complex classes .
But what happens when the automatic copy constructor work as you desire and you want to go to the trouble to create your own .

Page After all , you may decide that class will never be copied that if it is , an .

One solution is to create dummy copy constructor that prints an error message and aborts the program : class .

This works , sort of .
The problem is that errors are detected at runtime instead of compile time .

You want to catch errors as soon as possible , so this solution is at best hack .

However , you can prevent the compiler from automatically calling the copy constructor .
The trick is to declare it private .
your way of saying to the world , there is copy .

Now when the compiler attempts to use the copy constructor you will get an error message like Programming Exercises Exercise : Write parity class .
This class allows the program to put any number of items into it and returns TRUE if an even number of items is put in and FALSE if an odd number is used .

Page Exercise : Write " class .
You put list of numbers into this class and get total out .

queue is very similar to stack except the data is removed in order .

Exercise : Define class that will hold the set of integers from to .
An element can be set with the set member function and cleared with the clear member function .
It is not an error to set an element already set or clear an element already clear .
The function test is used to tell whether an element is set .

then go through the stack of flash Page cards one at time .
If word right , that card is discarded .
If it wrong , the card goes to the back of the stack .

Write class to implement this system .

Friends Constant Functions Constant Members Static Member Variables Static Member Functions The Meaning of static Programming Exercises This method is , to define as the number of class the class of all classes similar to the given class .

Suppose you want to write function to see whether two stacks are equal .
At first glance this is simple .
The function looks like Example .

Example Test to see whether two stacks are equal , the two stacks Returns stacks are not equal stacks are equal int  Index into the items in the array .

Like many programs , this solution is simple , clear , and wrong .
The problem is that the member variables and data are private .
That means you access them .

One solution is to make these variables public .
That gives the function access to and data .
The problem is that it also gives everyone else access , and you want that .

Fortunately gives you way to say , and only stack equal have access to the private data of the class " This is accomplished through the friend directive .
Classes must declare their friends .
No function from the outside may access the private data from the class , unless the class allows it .

NOTE is not member function of the class stack .
It is normal , simple function .
The only difference is that because the function is friend it has access to private data for any class that calls it friend .

Page Friend Classes Friends are not restricted to just functions .
One class can be friend of another .

For example : int  Current into the data array const int ; Maximum number of items in the array These two items are treated differently .
For example , you can change the value of but you change .

Now consider class to implement set of numbers from to .
The definition of this class is : Warning : The member functions in this class are incomplete See below for better definition of this class class .

There is also function test that changes nothing .

Obviously you want to allow set and clear to be used on constant .
However , it is okay to use the test member function .

But how does know what can be used on constant and what .
The trick is to put the keyword const at the end of the function header .
This tells that this member function can be used for constant variable .
So if you put const after the member function test , will allow it to be used in constant .
The member functions set and clear do not have this keyword , so they be used in constant .

Constant Members Classes may contain constant members .
The problem is that constants behave little differently inside classes than outside .
Outside , constant variable declaration must be initialized .
For example : const int ; Number of data items in the input stream Page .

Use syntax trick to fool into defining constant : class foo public : enum ; Number of data items in the list This defines as constant whose value is .
It does this by actually declaring as element of an enum type and giving it the explicit value .
Because treats enums as integers , this works for defining integer constants .

Page The drawbacks to the method are that tricky , it only works for integers , and it exploits some holes in the syntax that may go away as the language is better defined .
Such code can easily cause difficulties for other programmers trying to maintain your code who familiar with the trick .

Static Member Variables Suppose you want to keep running count of the number of stacks in use at any given time .
One way to do this is to create global variable that is incremented in the stack constructor and decremented in the destructor .

Note that is single global variable .
No matter how many different stacks you create , there is one and only one .

Although this system works , it has some drawbacks .
The definition of the class stack contains everything about the stack , except the variable .
It would be nice to put in the class , but if you define it as member variable , get new copy of each time you declare stack class variable .

has special modifier for member variables : static .
This tells that one and only one variable is to be defined for the class .

This is done with the statement : int : No stacks have been defined The difference between static and member variables is that if you define three stacks , you create three different member variables , but there is one and only one .
Member variables belong to the individual stack .
Static variables belong to the class .

So if you have : stack ; stack .

allows you to access this using the syntax : Thus you can get to with the statement : number of active stacks is 

Static Member Functions The member variable is defined as private .
This means that nothing outside the class can access it .
You want to know how many stacks are defined , so you need function to get the value of .
first cut might be : class stack .

They access nonstatic member variables or functions in the class .
They can access static member data , static member functions , and functions and data outside the class .

The Meaning of static The keyword static has many different meanings in .
Table is complete list of the various ways static can be used .

Table The Meanings of static Usage Meaning Variable outside the body of any function The scope of the variable is limited to the file in which it is declared .

Variable declaration inside function The variable is permanent .
It is initialized once and only one copy is created even if the function is called recursively .

Function declaration The scope of the function is limited to the file in which it is declared .

Page Usage Meaning Member variable One copy of the variable is created per class one per .

Member function Function can only access static members of the class .

Programming Exercises Exercise : Two classes share file .
Other areas of the program need to know when this file is busy .
Create function that returns when the file is being used by either of these two classes .

Exercise : You are asked to write booking program for the veterinarian : Dr .
Able Smith , PHD , Horses ,
Define class type for each animal .
Each class should keep track of the number of animals that have been defined using that class in private static variable .

Define function that returns the total number of animals three types .

Exercise : Write class where each instance of the class can access one stack per instance , but one stack period .
Any instance of the class can lock the stack for its own exclusive use and unlock it later .
Define member functions to perform the lock and unlock functions .

As an added attraction , make the unlock function check to see that the current instance of the class was the same instance that locked the stack in the first place .

Exercise : You need to supply some routines for handling lines in file .
The basic definition of the class is : class .

Page Several classes may be in use at any time .
The class maintains its own internal list so that it knows which classes are in use .
When is called , the function will scan the list of classes to find the one nearest the given line number and use it to start scanning for the given line number .

For example , suppose there are four active variables : Variable Position .

Line You wish to move to line .
The function would search the list for the line nearest the new this case and use it to jump to line .
It then would read the file character by character until it saw three characters to position itself at line .

Page Simple Pointers In This .

Constant Pointers Pointers and Printing Pointers and Arrays Splitting Strings Pointers and Structures Arguments Programming Exercises Answers to Chapter Questions The choice of point of view is the initial act of culture Gasset There are things and there are pointers to things .

thing and pointer to thing Things can come in any size ; some may be big , some may be small .
Pointers come in only one size Throughout this book you use box to represent thing .
The box may be large or small , but things are always box .
Pointers are represented by arrows .

Most novice programmers get pointers and their contents confused .
To limit this problem , all pointer variables in this book end with the extension .
You probably want to follow this convention in your own programs .
Although not as common as it should be , this notation is extremely useful .

Because of the strange architecture of the , is forced to use both near pointers and far pointers See the manual for details Page Figure shows one thing : variable named thing .
The name of the variable is written on the box that represents it .
This variable contains the value .
The actual address of this variable is .
automatically assigns an address to each variable at compile time .

The actual addresses differ from machine to machine .
Most of the time you have to worry about variable addresses , as the compiler takes care of that detail .
Pointers are also called address variables since they contain the addresses of other variables .
In this case , the pointer contains the address .
Since this is the address of thing , you say that points to thing .
For example , you might live in house .
The street address might be .
Main " An address is small thing that can be written down on piece of paper .
Putting house on piece of paper is something else requiring lot of work and very large crane .

Street addresses are approximately the same size : one line .
Houses come in various sizes .

Pennsylvania " might refer to big house and Skid Row " might refer to shack , both addresses are the same size .

Many different address variables can point to the same thing .
This is true for street addresses as well .
Table lists the of important services in small town .

Table Directory .

Gas Station In this case you have one , large , multipurpose building that is used by several services .

Although there are three address variables , there is only one address Main As you will see in this chapter , pointers can be used as quick and simple way to access arrays .
In later chapters you will discover how pointers can be used to create new variables and complex data structures such as linked lists and trees .
As you go through the rest of the book , you will be able to understand these data structures as well as create your own .

Page pointer is declared by putting an asterisk in front of the variable name in the declaration .

Pointer Operators Operator Meaning .

The ampersand operator changes into pointer .
The changes pointer into These operators can easily cause confusion .
look at some simple uses of these operators in detail .

The declaration int does not contain an asterisk , so is not pointer .

The asterisk in the declaration indicates this is pointer .
Also , you have put the extension onto the name .

The variable is pointer .
The tells to look at the data pointed to , not at the pointer itself .
Note : This points to an integer , any integer .
It may or may not point to the specific variable .

The following examples show misuse of pointer operators .

Asks to get the object pointed to by the variable .
Since is not pointer , this is an invalid operation .

Page Figure Pointer operators Legal , but strange .
The operator gets pointer to the object this case .
The result is pointer to pointer .
It declares one object ,  and .

Several pointers can point to the same 

In line you use the operator to change simple variable into pointer that can be assigned to .
Because and are both pointers , you can do direct assignment in line .

After executing this program fragment , you have the situation illustrated by Figure .

Two pointers and .

Finally , there is special pointer called NULL that points to nothing .

Figure NULL .

Declaring constant pointers is little tricky .
For example , although the .

Instead it tells that the data pointed to by is constant .
The data cannot be changed , but the pointer can .
Again we need to make sure we know the difference between " and to .

Yes , just .

const char array .
Can the data pointed to by be changed .

constant pointer .

Integer In this case , the value represents memory address .
This address may vary from program to program .

treats character pointers little differently from other pointers .
character is treated as to string .
For example : char ; simple set of characters char ; Pointer to character 

String Hello Pointers and Arrays allows arithmetic .
Addition and subtraction are allowed with pointers .

Note the use of parentheses .
The is outside the parentheses so it is added after the .

Page Figure Pointers and an array At first glance this may seem like complex way of representing simple array indices .
You are starting with simple arithmetic .
In later chapters you will use more complex pointers to handle more difficult functions efficiently .

Pointers are merely memory addresses .
In an array each element is assigned to consecutive addresses .
For example , may be placed at address .
Then would be placed at address and so on .
Example prints out the elements and addresses of simple character array .

When run this program prints : Characters usually take up one byte , so the elements in character array will be assigned consecutive addresses .
short int takes up two bytes , so in an array of short ints the addresses increase by two .
Does this mean will not work for anything other than characters .
automatically scales arithmetic so it works correctly .
In this case will point to element number .

provides shorthand for dealing with arrays .

blurs the distinction between pointers and arrays by treating them the same in many cases .

Here you used the variable as and automatically did the necessary conversion .

Example counts the number of elements that are and stops when zero is found .

No limit check is provided , so there must be at least one in the .

The expression at the end of this program ,  computes how far is into the .

When passing an to procedure , will automatically change the into .

In fact , if you put an before the  will issue warning .
Example illustrates passing .

Splitting Strings Suppose you are given string of the form " You want to split this into two strings , one containing the first name and one containing the last name .

Example reads in single line , stripping the newline character from it .
The function strchr is called to find the location of the slash .
You then split the string by replacing the slash with an or .
Now points to just the last name and points to null string .
Moving to the next character makes point to the beginning of the first name .

Graphically what you are doing is illustrated in Figure .

Example contains the full program .

Page Figure .
Splitting string Example Split split an entry of the form into two parts .

Question : Example is supposed to print out : Name : tmpl but instead you get : Name : results may Why does this happen .

Two lines of street address abbreviation Numeric zip code Mailing lists must frequently be sorted order and order .
You could sort the entries themselves , but each entry is bytes long .
lot of data to move around .

This sorting is much faster .
Imagine that you had warehouse full of big heavy boxes and you needed to locate any box quickly .
One way of doing this would be to put the boxes alphabetical order .
But that would require lot of moving , so you assign each location number , write down the and number on index cards , and sort the cards by .

Arguments The procedure main actually takes two arguments .
They are called argc and argv .

The parameter argc is the number of arguments on the command the program .
The array argv contains the actual arguments .
For example , if the program args were run with the command  args this is test then : argc NOTE The UNIX shell expands wildcard characters like , and before sending the command line to the program .
See your sh or csh manual for details .

will expand wildcard characters if the file is linked with your program .
See the manual for details .

Page Almost all UNIX commands use standard format .
This " has carried over into other environments .
standard UNIX command has the form : command options filel filel .

Options are preceded by hyphen and are usually single letter .
For example , the option might turn on verbose mode .
If the option takes parameter , the parameter follows the letter .
For example , the switch sets the maximum number of symbols to and sets the output file to outfile .

You have been given the assignment to write program that will format and print files .
Part of the documentation for the program looks like :

In this line , sets verbose options , which turns on lot of progress information messages .

The option sets the page size to lines and sets the output file to .
list of files to print follows these options ,
If no files are specified , then print the file .

The while loop cycles through the options .
The actual loop is : while There is always one argument , the program .
The expression checks for additional arguments .
The first one will be numbered .
The first character of the first argument is .
If this character is dash you have an option .

At the end of the loop is the .

This consumes an argument .
The number of arguments is decremented to indicate one less option , and the pointer to the first option is incremented , shifting the list to the left one place .

The switch statement is used to decode the options .
Character of the argument is the hyphen .
Character is the option character , so you use the expression : switch .

Page The option has no arguments ; it just causes flag to be set .

The option takes an integer argument .
The library function atoi is used to convert the string into an integer .
From the previous example you know that starts the string containing the number .
This string is passed to atoi .

The option takes filename .
Rather than copy the whole string , you set the character pointer to point to the part of the string .
By this time you know that : start of the file You set to point to the string with the statement : Finally all the options are parsed and you fall through to the processing loop .
This merely executes the function for each file argument .
Example contains the complete program .

Example cc Print format files for printing .

Output file Number of lines per page dummy routine to handle file Parameter of the file to print .

This one way of parsing the argument list .
The use of the while loop and switch statement simple and easy to understand .
This method does have limitation .
The argument must immediately follow the options .
For example , will work , but will not .
An improved parser would make the program more friendly , but this works for simple programs .

Exercise : Write function that takes single string as its argument and returns pointer to the first nonwhite character in the string .

Answers to Chapter Questions Answer : The problem that the variable temporary variable .
The compiler allocates space for the when the function entered and reclaims the space when the function exits .
The function assigns the correct value and returns pointer to it .

However , the function over , so disappears and you have pointer with an illegal value .

The solution to declare static .
Consequently , it permanent variable and will not disappear at the end of the function .

Page Question : After fixing the function , you try using it for two filenames .
Example should print out : Name : tmpl Name : but it .

Answer : The first call to returns pointer to .
There is only one The second call to changes and returns pointer to it .
So you have two pointers , and they point to the same .

Several library functions return pointers to static strings .
second call to one of these routines will overwrite the first value .
solution to this problem is to copy the .

IV Advanced Programming Concepts Page File In This .

File Conversion Routines Binary and ASCII Files The Puzzle Binary Buffering Problems Unbuffered Designing File Formats Routines Conversion Routines am the heir of all the ages , in the foremost files of time file is collection of related data .
treats file as series of bytes .
Many files reside on disk ; however , devices such as terminals , printers , and magnetic tapes are also considered files .

The Annotated Reference Manual and is the current widely used standard for .
This book does not contain specification of the system .
de facto standard has evolved based on the library supplied with the cfront compiler from .
The problem is that some of the details may differ from compiler to compiler .
For example , flushes at the end of each line while the SunPro UNIX compiler does not .

The current version of the ANSI Draft Standard does contain detailed description of calls .
However , currently no compilers support this , and the standard also is still undergoing revision .

This chapter discusses three different packages .
The first is the stream classes .

This is the most commonly used system and the one been using up to now .
Next , we examine the raw routines that give us direct access to the .
Finally we look at the system .
Although it is somewhat outdated , calls still appear in old code .
Also , in some cases , the routines are superior to the ones provided with .

Page File file is based on three classes : the istream class for input , the ostream class for output , and the iostream class for .
refers to files as streams since it considers them stream of bytes .
Four class variables are automatically created when you start program .
These are listed in Table .

Table Predefined Class Variables Variable Use .

Console log These variables are defined in the standard include file .
Normally cin is assigned to the keyboard and  cerr , and clog are assigned to the screen .
Most operating systems allow you to change these assignments through redirection your operating system manual for .

For example , the command runs the program and assigns cin to the file .

When doing to disk files through you must use the file version of the stream classes .
These are ifstream , ofstream , and fstream and are defined in the include file .

NOTE The ifstream class is actually derived from the istream class .

Similarly , ofstream is derived from ostream and fstream is derived from iostream .
learn about derived classes in Chapter , Advanced Classes .

Suppose you want to read series of numbers from the file .
You start by declaring the input file variable : ifstream ; File we are reading the data from .

Closing the file frees resources that can then be used again by the program .

allows the open call to be combined with the constructor .
For example , instead of writing : ifstream ; File we are reading the data from .

But what if the file is missing .
How can you tell if there is problem .
The member function bad returns " if there is problem , and " otherwise .
So to test for problems all you need .

better version of the program for reading numbers is Example .

This function defined as : The parameters to this function are : buffer buffer to store the data that has been read .

The function reads up to len bytes of data into the buffer .

The character used to signal .

This function returns reference to the input file .
The function reads up to and including the character .
The character not stored in the buffer .

Problems can occur if the size specified too big .
provides convenient way to make sure the size parameter just right through the use of the sizeof operator .

The sizeof operator returns the size in bytes of its argument .

The and bytes per long longs in the .

NOTE sizeof not the same as length .
The sizeof operator returns the number of bytes in string or .

Output Files The functions for output files are similar to input files .
For example , the declaration : ofstream ; creates file named and lets you write to the file using the file variable .

Actually , the constructor can take two additional parameters .
The full definition of the output file constructor  char , int , int ; The parameters for this function are : name The name of the file .

set of flags ORed together that determine the open .
The flag ios : required for output files .
Other flags are listed in Table .
This operator discussed in more detail in Chapter File protection .
This an value that determines the protection for the file .
In UNIX the protection defaults to owner , group read , others .
For this defaults to .

Open Flags Flag Meaning .

Open file for output be supplied to ofstream .

Page Flag Meaning ios : Binary file not present , the file opened as an ASCII See the section " on page for definition of binary file .

Input files always fail if there Do not overwrite existing file .
If file exists , cause the open to fail .

Conversion Routines So far we have just considered writing characters and strings .
In this section , we consider some of the more sophisticated operations : conversions .

To write number to printer or terminal you must convert the number to characters .
The printer understands only characters , not numbers .
For example , the number must be converted to the three characters , and " to be printed .

The operator used to convert data to characters and put them in file .
This function extremely flexible .
It can convert simple integer into or string as hex , octal , or decimal number with left or right justification .
So far been using the default conversion for your output .
It serves pretty well , but if you want to control your output exactly , you need to learn about conversion flags .

The member functions setf and unsetf are used to set and clear the flags that control the conversion process .
The general form of the functions .

Table Conversion Flags Flag Meaning .

Output left justified .

Page Flag Meaning .

When converting numbers to characters the member function : int ; determines the minimum characters to use .
For example , the would normally convert to the character string " the lack of .
If the width is set to four , then the result " where represents single space .

Page The member function : int .

This character is used for padding when is smaller than the specified width .

NOTE Some of these flags and parameters are reset after each output call and some are not .
Which flags are permanent and which are temporary seems to change from compiler to compiler .
In general , assume anything is going to remain set and be okay .
You can think of manipulator as magic bullet that when sent through an input or output file changes the state of the file .
manipulator cause any output ; it just changes the state .
For example , the manipulator changes the output conversion to hexadecimal .

The manipulators are defined in the file .
Table contains the full list of manipulators .

Manipulators Manipulator .

Page Manipulator Description .

Example shows how some of the manipulators may be used .

It set of printable characters and control codes .
When you write program , the file ASCII .

Terminals , keyboards , and printers deal with character data .
When you want to write like to the screen , it must be converted to four characters , and written .

Similarly , when you read from the keyboard , the data must be converted from characters to integers .

The ASCII character " has the value , the value , and so on .
When you want to convert single digit from ASCII to  you must subtract this value .

Computers work on binary data .
When reading numbers from an ASCII file , the program must process the character data through conversion routine like the conversion routine just defined .

Binary files require no conversion .
They also generally take up less space than ASCII files .
The drawback they cannot be directly printed on terminal or printer .
They can be moved from machine to machine with very little trouble .
Binary files are almost certainly nonportable .
Unless you are an expert programmer , it almost impossible to make portable binary file .
In most cases , ASCII best .
If you have small to medium amounts of data , the conversion time does not seriously affect the performance of your program .

Page Only when you are using large amounts of data will the space and performance problems force you to use the binary format .

The Puzzle Back in the dark ages BC , there existed magical device called Teletype Model .
This amazing machine contained shift register made out of motor and rotor as well as keyboard ROM consisting solely of levers and springs .

The teletype contained keyboard , printer , and paper tape .
It could transmit messages over telephones using modem at the blazing rate of characters second .

But teletype had problem .
It took second to move the printhead from the right side to the second two character times .
If second character came while the printhead was in the middle of return , that character was lost .

The teletype people solved this problem by making two characters : to position the printhead at the margin , and to move the paper up one That way the " while the printhead was racing back to the margin .

When the early computers came out , some designers realized that using two characters for wasted storage this time storage was very .
Some picked for their , and some chose .
Some of the stayed with the sequence .

UNIX uses for .
The character is code or .

uses the two characters .
Compiler designers had problems in dealing with the old programs that thought was just .

The solution was to add code to the library that stripped out the characters from ASCII input files and changed to on output .

In , whether or not file is opened as ASCII or binary is important to note .

The flag ios : is used to indicate binary file : Open ASCII file for reading , Open binary file for reading , Question : The member function put can be used to write out single byte of binary file .
The follouing program writes numbers to to afile called .

Page It works just fine in UNIX , creating long file ; however , in , thefile contains bytes .

In fact , you can write if you want to .

Binary Binary is accomplished through two member functions : read and write .
The syntax for read is : Pointer to place to put the data .

Page size Number of bytes to be read .

The member function gcount returns the number of bytes gotten by the last read .
This may be less than the number of bytes requested .
For example , the read might encounter an or error : struct int .

In this example you are reading in the structure rectangle .
The operator makes rectangle into pointer .
The cast " is needed since read wants character array .
The sizeof operator is used to determine how many bytes to read in as well as to check that read was successful .

The member function write has calling sequence similar to read .

Instead , the data is kept in buffer until there is enough for big write , or until it is flushed .
The following program is designed to print progress message as each section is finished .

Instead of writing the messages as each step completes , puts them in buffer .
Only after the program is finished does the buffer get flushed , and all the messages come spilling out at once .

Page The manipulator flush forces the flushing of the buffers .
Properly written , the above .

Unbuffered In buffered , data is buffered and then sent to the file .
In unbuffered , the data is immediately sent to the file .

If you drop number of paperclips on the floor , you can pick them up in buffered or unbuffered mode .
In buffered mode , you use your right hand to pick up paper clip and transfer it to your left hand .
The process is repeated until your left hand is full , and then you dump handful of paperclips into the box on your desk .

In unbuffered mode , you pick up paperclip and dump it into the box .
There is no buffer .

In most cases buffered should be used instead of unbuffered .
In unbuffered , each read or write requires system call .
Any call to the operating system is expensive .
Buffered minimizes these calls .

Unbuffered should be used only when reading or writing large amounts of binary data or when direct control of device or file is required .

Back to the paperclip you were picking up small items like paperclips you would probably use buffer .
But if you were picking up cannon balls are much , no buffer would be used .

The open system call is used for opening an unbuffered file .
The macro definitions used by this call differ from system to system .
You are using both UNIX and , so you have used conditional compilation to bring in the correct files .

Page int .

An integer that is used to identify the file for the read , write and close calls .
If is less than an error occurred .

Open flags are described in Table .

Table Open Flags Flag Meaning .

Normally this is for most files .

For example , to open the existing file in text mode for reading , you use the following :

Notice that you combined flags using the OR operator .
This is quick and easy way of merging multiple flags .

When any program is initially run , three files are already opened .

Page Table .
Standard Unbuffered Files File Number Description .

indicates and negative number indicates an error .

File descriptor of an open file .

This is the size of the request .
The actual number of bytes read The format of write call is : buffer , Actual number of bytes written .
negative number indicates an error .

File descriptor of an open file .

The system will try to write this many bytes , but if the device is full or there is some other problem , smaller number of bytes may be written .

Finally , the close call closes the file : for success , negative for error .

File descriptor of an open file .

Page Example copies file .
Unbuffered is used because of the large buffer size .
It makes no sense to use buffered to read of into buffer an and then transfer it into buffer .

Example Copy copy one file to another Usage copy the file to copy from the file to copy into .

Buffer for Input file descriptor Output file descriptor Number of bytes on last read .

Several things should be noted about this program .
First of all , the buffer size is defined as constant , so it is easily modified .
Rather than have to remember that is , the programmer used the expression .
This form of the constant is obviously .

If the user improperly uses the program , an error message results .
To help the user get it right , the message tells how to use the program .

You may not read full buffer for the last read .
That is why is used to determine the number of bytes to write .

Designing File Formats Suppose you are designing program to produce graph .
The height , width , limits , and scales are to be defined in graph configuration file .
You are also assigned to write program that asks the operator questions and writes configuration file so he or she does not have to learn the text editor .
How should you design configuration file .

One way would be as follows : lower limit upper limit lower limit upper limit Page typical plotter configuration file might look like : This file does contain all the data , but in looking at it , you have trouble identifying what , for example , is the value of the lower limit .
solution is to comment the file so the configuration program writes out not only the data .

But suppose user runs the plot program and types in the wrong filename , and the program gets the lunch menu for today instead of plot configuration file .
The program is probably going to get very upset when it tries to construct plot whose The result is that you wind up with egg on your face .
There should be some way of identifying this file as plot configuration file .
One method of doing this is to put the words Configuration File " on the first line of the file .
Then , when someone tries to give your program the wrong file , the program will print an error message .

This takes care of the wrong file problem , but what happens when you are asked to enhance the program and add optional logarithmic plotting .
You could simply add another line to the configuration file , but what about all those old files .
not reasonable to ask everyone to throw them away .
The best thing to do point of is to accept old format files .
You can make this easier by putting version number in the file .

typical file now looks like : Plot Configuration File log Logarithmic or normal plot lower limit Page upper limit lower limit upper limit In binary files , it is common practice to put an identification number in the first four bytes of the file .
This is called the magic number .
The magic number should be different for each type of file .

One method for choosing magic number is to start with the first four letters of the program name , and convert them to hex :
Then add to the number :

This generates magic number that is probably unique .
The high bit is set on each byte to make the byte and avoid confusion between ASCII and binary files .

When reading and writing binary file containing many different types of structures , it is easy to get lost .
For example , you might read name structure when you expected size structure .

This is usually not detected until later in the program .
To locate this problem early , the programmer can put magic numbers at the beginning of each structure .
Then if the program reads the name structure and the magic number is not correct , it knows something is wrong .

Magic numbers for structures do not need to have the high bit set on each byte .
Making the magic number just four ASCII characters makes it easy to pick out the beginning of structures in file dump .

Routines allows you to use the library in programs .
Many times this occurs because someone took program and translated it to and want to bother translating the calls .
In some cases , the old library is better and easier to use than the new library .
For example , routines such as sscanf and sprintf are far easier to use than their counterparts .

The declarations for the structures and functions used by the functions are stored in the standard file .

The declaration for file variable is : FILE , Comment .

The format for fopen is : file variable .

Mode is " for writing and " for reading .

The function fclose closes the file .
The format of fclose is : fclose ; The variable will be zero if the fclose was successful or for an error .

provides three preopened files .
These are listed in Table .

Standard Files File Description .

Equivalent to cerr .

There is no file equivalent to clog .

The function fgetc reads single character from file .
If there is no more data in the file the function returns the constant EOF is defined in .
Note that fgetc returns an integer , not character .
This is necessary because the EOF flag must be noncharacter value .

Example counts the number of characters in the file .

The format of the fgets call  fgets , size , Equal to string if the read was successful , or NULL if EOF or an error detected .

It then ends the string with null .

Example : char .

The format of the fputs function  fputs , The parameters to fputs are similar to the ones for fgets .

Conversion Routines uses the operator for output .
uses the printf family of functions .
printf call consists of two parts : format that describes how to print the data and list of data to print .

The general form of the printf call  printf ,

For example , when sees in the format string , it takes the next parameter from the parameter list must be an and prints it .

Figure shows how the elements of the printf statement work to generate the final result : Figure .
Other types of parameters use different conversions .

For example , if you want to print floating point number , you need conversion .
Table lists the conversions .

Conversions Conversion Variable Type .

See your reference manual for details .

The printf function not check for the correct number of parameters on each line .
If you add too many , the extra parameters are ignored .
If you add too few , will make up values for the missing parameters .
Also not type check parameters , so if you use on floating point number , you will get strange results .

Warning : The return value of sprintf differs from system to system .
The ANSI standard defines it as the of characters stored in the string ; however , some implementations of UNIX define it to be pointer to the string .

Reading accomplished through the scanf family of calls .
The scanf function has similar sister functions : fscanf and sscanf .
The format for fscanf  format ,
In some cases random variable or instruction will be modified .
This is not common on UNIX machines , but , with its lack of memory protection , cannot easily detect this problem .
In , omitting can cause system crash .

There is one problem with this scanf : next to impossible to get the handling right .
However , simple way to get around the limitations of use it .

Instead use fgets followed by the string version of scanf , the function .

Use fgets and sscanf instead .

Binary Binary is accomplished through two routines : fread and fwrite .
The syntax for fread is : fread , size , Size of the data that was read .
If this is less than size , then an or error occurred .

Example : struct int .

The cast " turns into the proper parameter type , and the sizeof operator is used to determine how many bytes to fread in as well as to check that read was successful .

For full description of these functions see your reference manual .

Question : No matter what filename you give the following program , our program find it .

Programming Exercises Exercise : Write program that reads file and counts the of lines in it .

Exercise : Write program to copy file , expanding all tabs to multiple spaces .

Exercise : Write program that reads file containing list of numbers and writes two files , one with all the numbers divisible by and another containing all the other numbers .

Exercise : Write program that reads an ASCII file containing list of numbers and writes binary file containing the same list .
Write program that goes the other way so you can check your work .

Exercise : Write program that copies file and removes all characters with the high bit Exercise : Design file format to store name , address , and other information .

Write program to read this file and produce set of mailing labels .

Answers to Chapter Questions Answer : The problem is that you are writing an ASCII file , but you wanted binary file .

In UNIX , ASCII is the same as binary , so the program runs fine .
In , the issue causes problems .
When you write character to the file , carriage return is added to the file .

To write binary data output you need to open the file with the binary option :

The problem is that the parameter containing the answer was omitted .
When this happens printf gets the answer from random location and prints garbage .

Properly written , the printf statement is : answer is , Page Answer : The printf call not check the type of its parameters .
You tell the printf call to print an integer and supply it with floating point parameter .
This mismatch causes unexpected results such as printing the wrong answer .

When printing floating point you need conversion .
Properly written , our printf statement is : answer is , Answer : The problem is that fgets gets the entire including the character .
If you have file named sam , the program reads and tries to look for file by that Because there is no such file , the program reports an error .

The fix is to strip the character from the .

The error message in this case is poorly designed .
True , you did not open the file , but the programmer could supply the user with more information .
Are you trying to open the file for input or output .
What is the of the file you are trying to open .
You even know whether the message you are getting is an error , warning , or just part of the normal operation .

better error message is : Unable to open for , Notice that this message would also help us detect the programming error .
When you typed in " the error would be : Error : Unable to open sam for input This clearly shows us that you are trying to open file with in its .

Page Debugging and Optimization In This .

Debugging Divide and Conquer Code Debug CommandLine Switch Interactive Debuggers Debugging Binary Search Runtime Errors The Confessional Method of Debugging How to Optimize Case Study Exercises Answers to Questions Bloody instructions which , being learned , return to plague the inventor .

It is here that you find out how your program really works of how you think it .

To eradicate bug , you need two things : way of reproducing the bug and information from the program that lets you locate and correct the problem .

In some cases , finding the bug is easy .
You discover the bug yourself , the test department produces clear and easy test that displays the bug , or the output always comes out bad .

In some cases , especially with interactive programs , reproducing the bug may be percent of the problem .
This is especially true when dealing with bug reports sent in by users in the field .

typical call from user might be : User : That database program you gave me is broken .

Programmer : wrong .

User : Sometimes when doing sort , it gets things in the wrong order .

Page Programmer : What command were you using .

User : The sort command .

Programmer : Tell me exactly what you typed , keystroke by keystroke , to get it to fail .

User : remember it exactly .

Programmer : If come over can you show me the bug .

User : Of course .

The user types away and the program stubbornly works , no matter what the user does to it .

The programmer gives up and goes back to his office only to find message from the user : Example is short database lookup program .
It asks the user for input and checks the input against list of names .
Although it is very simple , the structure is typical of much larger and more complex interactive programs .

typical execution of this program is : Enter  Sam Sam is not in the Enter  John Page John is in the Enter  When we release this program , the users immediately start complaining about mysterious problems that go away whenever the programmer is around .
it be nice to have little gremlin sitting on the shoulder copying down everything he or she types .
Unfortunately , gremlins are unavailable ; however , we can change this program so it produces save file that contains every keystroke the user typed .

Our program uses the statement : to read the user data .

write new  and use it instead of getline .
It not only will get line .

Example The main program will open this file if is on the command line .

We also change our main program to handle new  to specify save file .

Now we have complete record of what the user typed .
Looking at the input , we see that he typed : Sam John The second name begins with space and , although " is in the list , is not .

In this case we found the error by inspecting the input ; however , more complex programs have much more complex input .
We could type all that in when debugging , or we could add another feature to that would add playback file to it .
When the playback file is enabled , input will not be taken from the keyboard , but instead will be taken from the file .

Example .

Our main program now looks like Example .

Playback data Save open flag Save if any True if playback in progress char , int size , istream ; char char char ; name to look up ; Name of the save ; Name of the playback int ; lookup name .

Now when user calls up with an error report , we can tell him , it again with the feature enabled , and then send me copy of your " The user then runs the program and saves the input into the .

In many cases half the battle .

Once you can reproduce the problem you can proceed to the next steps : finding it and fixing it .

Once programmer asked user to send the programmer copy of his floppy .

An express package arrived the next day containing photocopy of the floppy .
But the user was not completely : He knew it was floppy , so he had photocopied both sides .

Serial Debugging Before you start debugging , save the old , copy of your program in safe place .
Sometimes you will find been barking Page up the wrong tree and need to start over .
when the last working copy becomes invaluable .

Once you have reproduced the problem , you must determine what caused it to happen .

Divide and Conquer The divide and conquer method has already been briefly discussed in Chapter , The Programming Process .
It consists of putting in statements where you know the data is good make sure it really is , where the data is bad , and several points in between .

This way you can start zeroing in on the section of code that contains the error .
More statements can further reduce the scope of the error until the bug is finally located .

Code The method uses temporary statements .
They are put in as needed and taken out after they are used .
The directives can be used to put in and take out debugging code .
For example : DEBUG     DEBUG The program can be compiled with DEBUG undefined for normal use so you can define it when debugging is needed .

Debug Switch Rather than using switch to create special version of the program , you can permanently the debugging code and add special program switch that will turn on debugging output .
For example :     where debug is variable set if is present on the command line .

This has the advantage that only single version of the program exists .
One of the problems with " code is that unless the code is frequently used , it can easily become stale and out of date .
Frequently programmer tries to find bug only to discover that the code is out of date and needs fixing .

Another advantage of the debug switch is that the user can turn on this switch in the field , save the output , and send it to you for analysis .
The Page runtime switch should be used in all cases instead of conditional compilation , unless there is some reason you do not want the customer to be able to get at the debugging information .

Some programs use the concept of debug level .
Level outputs only minimal debugging information , level more information , and on up to level , which outputs everything .

Another debugging technique can be seen in the program by Aladdin Enterprises .

This program implements the idea of debugging letters .
The command sets the debugging flags for each type of diagnostic output wanted .
For example , is the code for the fill algorithm and is the code for the path tracer .
If wanted to trace both these sections , would specify .

The is implemented by the following code : Even though we only put zero , will fill in the rest of the arrays with zeros .

Free Software Foundation .
Inc , Mass Ave  Cambridge .
MA , phone .

This form of debugging allows the user to get great deal of information easily .

Going Through the Output Enabling printout is nice way of getting information , but many times there is so much data that the information you want can easily get lost .

The shell or interpreter allows you to redirect what would normally go to the screen to file through the use of the .
For example : buggy will run the program buggy with high level of set and send the output to the file .

The text editor on your system also makes good file browser .
You can use its search capabilities to look for the information you want to find .

Interactive Debuggers Most compiler manufacturers provide an interactive debugger .
They give you the ability to stop the program at any point , examine and change variables , and " through the program .
Because each debugger is different , detailed discussion is not possible .

However , we are going to discuss one debugger gdb .
This program is available for many UNIX machines from the Free Software Foundation .
has its own debugger .

Although the exact syntax used by your debugger may be different , the principles shown here will work for all debuggers .

Basic GDB commands are : run Start execution of program .

When running program reaches breakpoint , execution stops and control returns to the debugger .

Commonly , the command break in main is used to stop execution at the beginning of the program .

Page cont Continue execution after breakpoint .

If the current statement calls function , the function is single stepped .

This command is used to skip over function calls .

We have program that should count the number of threes and sevens in series of numbers .

The problem is it keeps getting the wrong answer for the number of sevens .
Our program is shown in Example .

Page return ; get numbers from the command line .

Threes We start by invoking the debugger with the name of the program we are going to debug .
The debugger initializes , outputs the prompt , and waits for command .

There is absolutely no warranty for GDB ; type warranty " for details .

GDB , Copyright Free Software Foundation ,

We know where the variable is getting changed , so start at the beginning and work our way through until we get an error .
At every step display the variable just to make sure okay .

We need to stop the program at the beginning so we can through it .
The command break main tells GDB to set breakpoint at the first instruction of the function main .
The command run tells GDB to start the program , which will run until it hits the first breakpoint .

The number is used by GDB to identify the breakpoint .
Now we need to start the program : run Starting program : Breakpoint , main at ; The message Breakpoint ,

Page We have reached the point where is initialized .
The command next will execute single statement , treating function calls as one statement .
We try the next few lines , checking all the time : next ; print next Enter numbers for ; print somehow changed the value to .
The last statement we executed was ; so something is going on in that function .
We add breakpoint at the beginning of , get rid of the one at main , and start the program over with the run command : break Breakpoint at : file , line .

Start it from the beginning .

narrowed the problem down to one statement .
By inspection we can see that we are using , an illegal member of the array .

Since is only five elements long , there is no .
However , the cin has to put the someplace , so it decided to put it in random memory location , in this case .

Debugging Binary Search The binary search algorithm is fairly simple .
You want to see whether given number is in an ordered list .
Check your number against the one in the middle of the list .
If it is the number , you were .
If your number was bigger , then you might find it in the top half of the list .

Try the middle of the top half .
If it was smaller , try the bottom half .
Keep trying and dividing the list in half until you find the number or the list gets down to single number .

Example uses binary search to see whether number can be found in the file .

Input file Middle of our search range bound Number to search for .

Our data file is : When we run this program in UNIX , the results are : When we run this program on , the system locks up and we have to hit the reset switch .
If the program is run in Windows we get an application error .

It means something went wrong in our program and the program tried to read memory that there .
The debugger GDB can read this file and help us determine what happened .

Page There is absolutely no warranty for GDB ; type warranty " for details .

GDB , Copyright Free Software Foundation ,

The debugger tells us we have been killed by segmentation fault generated from the procedure .
But we have procedure number .
The routine must belong to the library .

We now use the where command to find out which function called which function known as stack : where in .

The current function is printed first , then the function that called it , and so on until we reach the outer function main .
From this we see that number was called by , which was called by sscanf .
We recognize sscanf as library routine .
The other functions must be subroutines called by sscanf .
The last function that had control was the call of sscanf , which was made from line of main .

Now we use the list command to take look at the source for this line : list break ; break ; quit The program is running .
Quit anyway kill .

Another way of finding the problem is to through the program until the error occurs .

First list section of the program to find convenient place to put the breakpoint , and then start the execution and process .

Page Script started on Mon Oct gdb GDB is free software and you are welcome to distribute copies of it under certain conditions ; type copying " to see the conditions .

There is absolutely no warranty for GDB ; type warranty " for details .

GDB , Copyright Free Software Foundation ,

Quit anyway kill .
On inspection we notice that we forgot to put an ampersand in front of the variable for sscanf .
So we change line .

Page NOTE You might wonder why we use the function sscanf when the line : performs the same function .

The answer is simple .
We used sscanf to cause problems .
Without the pointer error we would have nothing to debug .
The statement is more reliable , and reliable code has no place in chapter on debugging .

The first number in our list is , so we try it .
This time our output looks like : Enter number to search for or to quit : Found at index Found at index Not found Enter number to search for or to quit : The program should find the number , let us know at index , and then ask for another number .
Instead we get two found messages and one not found message .
We know that everything is running smoothly up to the time we get the first found message .

Getting back into the debugger , we use the list command to locate the found message and put breakpoint there .

There is absolutely no warranty for GDB ; type warranty " for details .

GDB , Copyright Free Software Foundation ,

Page Breakpoint , main at at  step Found at step step  step + step step at ; step Found at quit The program is running .
Quit anyway kill .
Instead it continues with the search .
Because the number has already been found , this search results in strange behavior .
We are missing break after the .

We need to change : at 

Making this fix , we try the program again : search Enter number to search for or to quit : Found at Enter number to search for or to quit : Found at Enter number to search for or to quit : Not found Enter number to search for or to quit : We have runaway program .
This time instead of setting breakpoint we just start running the program .
After few seconds pass and we believe that we are stuck in the infinite loop , we stop the program with .
Normally Page this would abort the program and return us to the shell prompt .
Since we are running with the debugger , it returns control to GDB .

There is absolutely no warranty for GDB ; type warranty " for details .

GDB , Copyright Free Software Foundation ,

Quit anyway kill .
Our algorithm has an error .
Obviously the element does not match .
If it did exit with found at message .
So there is no point including the element in our new range .
Our code to adjust the interval is :  else .

Example cc Search set of numbers Usage : You will be asked numbers to look up Page Files : numbers per line to .

Input file Middle of our range bound Number to for .

Interactive debuggers work well for most programs .
Sometimes they need little help .

We try to debug it and find it fails when is .
We want to put breakpoint before the calculation is made .
When the debugger inserts breakpoint into program , the program will execute normally until it hits the breakpoint , and then control will return to the debugger .
This allows the user to examine and change variables as well as perform other debugging commands .
When cont command is typed , the program will continue execution as though nothing happened .
The problem is that there are points before the one we want , and we want to stop for each of them .

We can do this by adding the following temporary code : if Temp code  Line to stop on Line does nothing useful except serve as line that the debugger can stop on .
We can put breakpoint on that line with the command break .
The program will process the first points , and then execute line , hitting the breakpoint .
The advanced GDB command break if would Runtime Errors Runtime errors are usually the easiest to fix .
Some types of runtime errors are segmentation violation , stack overflow , and divide by .

Segmentation violation This error indicates that the program tried to pointer containing bad value .

Stack overflow The program tried to use too many temporary variables .
Sometimes this means the program is too big or using too many big temporary arrays , but most of the time this is due to infinite recursion problems .
Almost all UNIX systems automatically check for this error .
will check for stack overflow only if the compile time option is used .

Divide by Divide by is an obvious error .
UNIX masks the problem by reporting an integer divide by zero with the error message Floating exception .

In all cases , program execution will be stopped .
In UNIX , an image of the running program , called core file , is written out .
This file can be analyzed by the debugger to determine why the program died .
Our first run of Example resulted in core dump .
The buffers for buffered files are not flushed .
This can lead to some unexpected surprises .

Starting This might lead you to think the divide had never started , when in fact it had .
What happened to the message .
The statement executed , and put the message in buffer , and then the program died .
The buffer never got chance to be emptied .

By putting explicit commands inside the code , we get truer picture of what is happening , as shown in Example .

Page The Confessional Method of Debugging The confessional method of debugging is one by which the programmer explains his program to someone : an interested party , an uninterested party , matter whom he explains it to as long he talks about it .

typical confessional session goes like this : Bill , could you take look at this .
My program has bug in it .

The output is computed using this formula and checked out the payment value and rate and the date must be correct , unless there is something wrong with the Optimization And now word on optimization :
Most programs do not need to be optimized .
They run fast enough .
Who cares whether an interactive program takes seconds to start up instead of .

To be fair , there are lot of slow programs out there that can be sped up .
This is usually done not by the simple optimization steps shown in this chapter , but by replacing poorly designed core algorithms with more efficient ones .

For program , the simplest way to get your program to run faster is to get faster computer .
Many times it is cheaper to buy more powerful machine than it is to optimize program , because you may introduce new into your code .
expect miracles from optimization .
Usually most programs can only be sped up percent to percent .

Example initializes matrix .

How can this function be optimized .
First we notice we are using two local varibles .
By using the qualifier register on these variables , we tell the compiler that they are frequently used and should be placed in fast registers instead of relavely slow main memory .
The number of registers varies from computer to computer .
Slow machines like the PC have , most UNIX systems have about supercomputers can have as many as .
It is possible to declare moreregister variables than you have registers .
will put the extra variables in program now looks like Example .

Example .

The outer loop is executed times .
This means the overhead associated with starting the inner loop is executed times .
If we reverse the order of the loops , we will have to deal with the inner loop only times .

In general , loops should be ordered so the innermost loop is the most complex and the outermost loop is the simplest .
Example contains the function with the loops reordered .

To do this , the program must perform the following steps :
Get the address of the matrix .

Add up all three parts to form the address .
In this code looks like : + + However you typically write matrix accesses this way because handles the details .

But being aware of the details can help you generate more efficient code .

Almost all compilers will convert multiplies by power of two , into shifts , thus taking an expensive operation and changing it into an inexpensive operation .

For example :  is compiled as : is , which is not power of two .
By increasing to we waste some memory but get faster program .

Example shows how we can take advantage of power of two .

Since we are initializing consecutive memory locations , we can initialize the matrix by starting at the first location and storing in the next SIZE elements .
Using this method , we cut the number of loops down to one .
The indexing of the matrix has changed from standard index , requiring shift and add , into pointer and an increment .
In Example turned our arrays into pointers .

But why have both loop counter and .

In Example successfully eliminated the loop counter by combining it with the array pointer .

The function is now well optimized .
The only way we could make it better is to manually code it into assembly language .
This might make it faster ; however , assembly language is highly nonportable and very .

The library routine memset can be used to fill matrix or array with single character value .

We can use it to initialize the matrix in this program .
Frequently used library subroutines such as memset are often coded into assembly language and may make use of special tricks to do the job faster than could be done in .
In Example we let the function memset do the work .

Example .

Now our function consists of only single function call .
It seems shame to have to call function just to call another function .
We have to pay for the overhead of two function calls .
It would be better if we called memset from the main function .
Why we rewrite the code using memset instead of .
Because it has several hundred calls and we want to do all that editing .

So how do we get rid of the overhead of function call .
By making the function inline .
Our final version of the function uses inline to eliminate all the call overhead and can be seen in Example .

How to Optimize Our matrix initialization function illustrates several optimizing strategies .
These are : Removing invariant code Code that does not need to be put inside loop should be put outside the loop .
For example : +

Loop ordering Nested loops should be ordered with the simplest loop outermost and the most complex loops innermost .

Page Reduction in strength This is fancy way of saying use cheap operations instead of expensive ones .
Table lists the relative cost of common operations .

Table Relative Cost of Operations Operation Relative Cost File input output , including the functions printf scanf .

They then have to do costly conversion between character string number .
These functions should be avoided in sections of code .

Reference pa ra meters Use constant reference parameters type instead of constant parameters for structures , unions , classes .

Powers of Use power of when doing integer multiply or divide .
Most compilers will substitute shift for the operation .

Pointers Pointers are faster than indexing an array .

Inlinefunctions Using inline functions eliminates the overhead associated with function call .
It also can Page Case Study : Inline Functions Versus Normal Functions once worked on writing program for large computer manufacturer .
We had function that was used to get the next character from the current file .
It was used in thousands of places throughout the program .
When we first tested the program with written as function , the program was unacceptably slow .
Analyzing our program we found that percent of the time was spent in .
So we changed it to an inline function .
The speed doubled ; however , our code size went up percent required memory expansion card to work .
So the speed was all right , but the size was unacceptable .

We finally had to write the routine as function in assembly language to get both the size the speed to acceptable levels .

Case Study : Optimizing Algorithm once was asked to optimize program that did color rendering for large picture .
The problem was that the program took eight hours to process single picture .
This limited us to doing one picture day .

The first thing did was run the program on machine with accelerator .
This brought the time down to about six hours .
Next got permission to use RISC computer that belonged to another project but was currently sitting idle .
That reduced the time to two hours .

saved six hours solely by using faster machines .
No code had changed yet .

Two fairly simple functions were being called only once from the innermost loop .
Rewriting these functions as macros saved about minutes .

Next changed all the operations could from to integer .
The savings amounted to minutes out of run .

Then noticed the program was spending about minutes reading an ASCII file containing long list of numbers used in the conversion process .
Knowing that scanf is an extremely expensive function , cut the initialization process down to almost nothing by making the file binary .
Total runtime was now down to .

By carefully inspecting the code using every trick knew , saved another minutes , leaving me minutes short of my goal of an hour per run .
At this point Page my project was refocused the program put in mothballs for use at some future date .

Programming Exercises Exercise : Take one of your previous programs run it using the interactive debugger to examine several intermediate values .

Exercise : Write function .
Create test program that not only tests the function , but times it as well .
Optimize the program using pointers determine the time savings .

Exercise : Write program to sum the elements in an array .

Exercise : Write program that counts the number of bits in character array .
Optimize it through the use of variables .
Time it on several different arrays of different sizes .

Exercise : Write your own version of the library function memcpy .
Most implementations of memcpy are written in assembly language take advantage of all the quirks tricks of the processor .
How does your memcpy compare with theirs .

Answers to Chapter Questions Answer : The problem is that memset is character fill routine .
An consists of or bytes .
Each byte is assigned the value .
So will receive the value : The hex value for is .
The hex value of is .
So we can take two single byte values , put them together and come out with .
This works for zero also .
Any other number will produce the wrong answer .

Page Operator Overloading In This .

Operator Functions Operator Member Functions Full Definition of the Complex Class Programming Exercises Answers to Chapter Questions Overloaded , undermanned , ment to flounder , we Euchred God storm , bluffed the Eternal Sea .

But have complex type , so it know how to add two complex numbers .
However , through feature called operator overloading , you can " how to handle complex numbers .

Operator overloading is used to define set of functions to add , subtract , multiply and divide complex numbers using the normal operators + and .

In this section we define complex number class .
start by defining the basic complex class .
complex number consists of two parts , the real and the imaginary : class complex .

Next we define several member functions .
These include the usual constructors and destructors as well as routines to get at the real and imaginary parts of the number .

As you may recall , the const appearing after some functions was discussed in Chapter , More on Classes .

Now we want to use our complex numbers .
Declaring variables is simple .
Even initializing them with numbers such as + is easy .

But what happens when we want to add two complex numbers .
We need to define function to do .

This is the most efficient way of passing structures into function .
Finally , because it is such small function , defined it as an inline function for efficiency .

In this function , we explicitly declare result and return it .
We can do both in one step : Version of the complex add function .

In version of the add function we explicitly allocated variable for the result .
In version , automatically creates temporary variable for the result .
This number has no name and really exist outside the return statement .

Creating the temporary variable causes the constructor to be called .
The temporary variable is then assigned to  thus we have call to the assignment function .
After the assignment , no longer has any use for the temporary variable and throws it away by calling the destructor .

Page Operator Functions Using the add function for complex numbers is little awkward .
It would be nice to be able to convince to automatically call this function whenever we try to add two complex numbers together with the + operator .
where operator overloading comes in .
All we have to do is to write the add function .

Note : The operator overloading functions should be used carefully .
You should try to design them so they follow rules .
That is , + should have something to do with addition ; with subtraction ; and so on .
The streams break this rule by defining the shift operators and as input and output operators .
This can lead to some confusion , such as : Does this output " followed by " or does it output the value of the expression .

Unless an expert you tell .
In this case the numbers " and " will be output .

seen how you can overload the + operator .
Now explore what other operators you can use .

Binary Arithmetic Operators Binary operators take two arguments , one on each side of the operator .

One of the parameters must be class or structure .

had to define lot of different functions just to support the addition of our complex class .
Such diarrhea of the definition is typical when overloading operators .

Table lists the binary operators that can be overloaded .

Binary Operators That Can Be Overloaded Operator Meaning + Addition Subtraction .

Right shift Relational Operators The relational operators include such things as and not .
Normally they take two constant classes and return either or .

Table Relational Operators Operator Meaning .

Greater than Page Operator Meaning .

Greater than or equal to Unary operators Unary operators , such as negative , take single parameter .

Table Unary Operators Operator Meaning .

Ones complement Shortcut Operators Operators such are shortcuts for more complicated operators .

very close examination the standard reveals that these operators return the value the variable after the increase or decrease .

Note that unlike the other functions defined , the first parameter is not constant .

Also we , return reference to the first  not new or copy the first parameter .

Page Table lists the shortcut operators .

Simple Shortcut Operators Operator Meaning .

Shift right Increment Decrement Operators increment decrement operators have two forms : prefix suffix .

language contains hack to handle this case .

If we define for the complex type to mean increment the part , then our functions to handle the two forms are : Prefix .

has reduced us to using cute tricks : the unused integer parameter .
In actual practice , never use the suffix version increment always put the prefix version on line by itself .
That way , can avoid most these problems .

As you can see , the prefix version is much simpler than the suffix version .
So restricting yourself to the prefix version not only simplifies your code , but it also makes the job little easier .

Table lists the increment decrement operators .

Table Increment Decrement operators Operator Meaning .

Decrement Logical Operators Logical operators include AND , OR , NOT .
They can be overloaded , but just because you can do it mean you should .
In theory , logical operators work only on Boolean values .
In practice , because have Boolean type , they work on integers .

confuse the issue more by overloading them .

Table lists the logical operators .

Table Logical Operators Operation Meaning .

Logical NOT Operators been using the operators for input output .
Actually these operators are overloaded versions the shift operators .
This has the advantage making fairly simple , at the cost some minor confusion .

We would like to be able to output our complex numbers just like any other data type .
To do this we need to define for it .

Page We are sending our data to the output stream class ostream .
So our output function .

Normally the takes two constant arguments .
In this case the first parameter ostream This because the when used for output has side effects , the major one being that the data goes to the output stream .
In general , however , not good idea to add side effects to an operator that already have them .

Input should be just as simple as output .
You might think all we have to do read the numbers the related extra : input operation .

The function set used to set flag indicating that the input operation found problem .
This allows the caller to test to see whether the input worked by calling the bad function .
See Chapter , Exceptions , for more We have reached the .
read the part of the number .

Page Example .

The operator used by to index arrays .
As we will see in Chapter , Advanced Pointers , this operator very useful when defining class that mimics an array .
Normally , this function takes two arguments , class that simulates an array an index , returns reference to an item in the array .

We cover the operator in more detail in Chapter , Modular Programming .

First of all , they introduced until Chapter , Advanced Pointers , so you know what they do .
Second , when you know what they do , you want to override them .

seen only one program where the new delete operators were overridden at least their .
That program was written by very clever programmer who liked to do everything little strangely .
The result was code that was nightmare to debug .

So unless you are very clever programmer , leave new delete alone .
And if you are clever programmer , please leave new delete alone anyway .
Some day might have to debug your code .

Exotic Operators contains very rich set of operators .

These include :  Allows you to define default function for class .

Allows two expressions to be concatenated .
It rarely used probably should not be overloaded .

All of these operators are discussed in Chapter , Dustier Corners .

Operator Member Functions So far been using overloading functions just like ordinary functions .
They can also be defined as functions .
The only difference that as functions the first argument , the class itself , implied .
So , for example , you can write the as an ordinary function or as function .
the ordinary version that already seen .

In most cases , you need to use this .
However , in few , such  it comes in handy .

Which flavor of overloading functions should you use .
The one that makes your program clearest easiest to read .
In general , we use standard functions for simple operators , such + while use functions for shortcut unary operators , such , unary .

Some overloaded functions only work functions .
These include casting operators well class specific versions of new delete .

Casting Finally we come to cast operators .
Casting way of changing one type to another .
For example , say that when we cast our complex type to double , we want real part .

We can define cast for this function  class complex : public : double automatically calls this function whenever it wants to turn complex into double .

The trouble is that by defining cast , you give something else that it can call behind your back .
Personally , like to know whenever calls something , so avoid creating cast operators .
Unless you have very good reason to define one , create cast function .

Page Full Definition of Complex Class Example lists entire complex class .
The beginning of header file summarizes all functions that are defined .
In creating this class discovered that it consisted of many to be little functions .
Commenting each of these with comment block would obscure code .
In other words , this is one of few cases very where adding comments would cause confusion , so most of small functions have no comments .

When creating this class , noticed that lot of functions have similar structure .

As matter of fact , created by copying functions editing little .
contains rich set that causes this sort of repetition to happen when trying to define complete set of operators for class .

Finally , simple operations are defined in file while longer functions are left in file .

Example  File :

Copy constructor called Copy constructor called over and over .
Review the section Constructor " in Chapter .
Thanks to Jeff Hewett for th is problem .

Programming Exercises Exercise : Write class to handle fractions such as " Define addition , subtraction , multiplication , and division operators for these fractions .

Exercise : Write number class to handle numbers .
All numbers are of the form .
In other words , all numbers have only single digit to the right of the decimal point .
Use integers to implement class .

Exercise : Write class to implement sparse integer array .
This is much like simple integer array : int ; But unlike simple array , the indices can go from to .
the bad news .
The good news is that at most elements will be set at any time .
The rest of the elements will be zero .

Exercise : Write time class .
Implement functions to add , subtract , read , and print times .

Exercise : Write date class that allows you to add , subtract , read , and print simple dates of the form .
Assume year is not leap year .

Page Exercise : Write class that allows you to add , subtract , read , and print dates of the form .

Answers to Chapter Questions Answer : The copy constructor calls the function .
The parameter list to function is : trouble : The parameter to function is being passed as parameter .
When sees type of parameter it calls the copy constructor to put the parameter on the stack .

So we have an infinite loop The copy constructor calls the function .
sees the parameter and calls the copy constructor , which calls and causes the copy constructor to be called .
This keeps up until the system runs out of stack space or the user gets disgusted and aborts the program .

The solution is to pass the parameter to as reference .
This not only is more efficient , but also works .

Format Floating Multiplication Division Overflow and Underflow Roundoff Error Accuracy MinimizingRoundoff Error Determining Accuracy is equal to for sufficiently large values of .

The arithmetic is simple , exact , and fast .
Floating point is the opposite .
Computers do arithmetic only with great difficulty .

This chapter discusses some of the problems that can occur with floating point .
In order to address the principles involved in arithmetic , we have defined simple decimal format .
We suggest you put aside your computer and work through these problems using pencil and paper so you can see firsthand the problems and pitfalls that occur .

The format used by computers is very similar to the one defined in chapter , except that instead of using base , computers use base , or .
However , all the problems demonstrated here on paper can occur in computer .

Format Floating point numbers consist of three parts : sign , fraction , and an exponent .
Our fraction is expressed as decimal .
The exponent is digit .
So our format is : Page where : the sign or .

We represent these numbers in " format :

This format is similar to the format used in many computers .
The IEEE has defined standard , but not all machines use it .

Table shows some typical numbers .

Examples Notation Number .

To minimize errors we make use of guard digit .
That is an extra digit added to the end of the fraction during computation .
Many computers use guard digit in their units .

Floating To add two numbers like and , the computer must perform the following steps :
Start with the numbers .

Add guard digits to both numbers .

Shift the number with the smallest exponent to the right one digit and increment its exponent .

Continue until the exponents of the two numbers match .

Add the two fractions .
The result has the same exponent as the two numbers .

Normalize the number by shifting it left or right until there is just one nonzero digit to the left of the decimal point .
Adjust the exponent accordingly .
number like would be normalized to .
Because the number is already normalized , we do nothing .

Finally , if the guard digit is greater than or equal to , round the next digit up .
Otherwise , truncate the number .

For subtraction , change the sign of the second operand and add .

Multiplication When we want to multiply two numbers such as , the following rules apply .

Add the guard digit .

The number is The number is .

Normalize the result .
If the guard digit is greater than or equal to , round the next digit up .

Otherwise , truncate the number .

The rules for multiplication are lot shorter than those for add .
Integer multiplication is lot slower than integer addition .
In floating point , multiplication speed is lot closer to that of addition .

Page Division To divide numbers like by , we must perform the following steps .

Add the guard digit .

Divide the fractions , and subtract the exponents .

Normalize the result .

If the guard digit is less than or equal to , round the next digit up .
Otherwise , truncate the number .

What are the results of the following calculation .

This is an example of overflow called exponent .
Some computers generate trap when this occurs , thus interrupting the program and causing an error message to be printed .
Others are not so nice and generate wrong answer .
Computers that follow the IEEE standard generate special value called .

Underflow occurs when the numbers become too small for the computer to handle .
Example : The result is : Because is too small to fit into one digit , we have underflow .

Page Roundoff Error Floating point is not exact .
Everyone knows that + is , but did you know that +
This can be shown by the following calculations : as floating point is as floating point is , or which is not : Every computer has similar problem with its floating point .
For example , the number has no exact representation in binary floating point .

Floating point should never be used for money .
Because we are used to dealing with dollars and cents , it is tempting to define the as : float ; However , the more calculations you do with floating point , the bigger the roundoff error .

Banks , credit cards , and the IRS tend to be very fussy about money .
Giving the IRS check almost right is not going to make them happy .
Money should be stored as an integer number of pennies .

Accuracy How many digits of the fraction are accurate .
At first glance you might be tempted to say all four digits .
Those of you who have read the previous section on roundoff error might be tempted to change your answer to three .
The answer is : The accuracy depends on the calculation .
Certain operations , such as subtracting two numbers that are close to each other , generate inexact results .
Consider the following equation : Page or : or The correct answer is and we got .
The very first digit of the fraction is wrong .
This is an example of the problem called roundoff error that can occur during operations .

Minimizing Roundoff Error There are many techniques for minimizing roundoff error .
Guard digits have already been discussed .
Another trick is to use double instead of float .
This gives you approximately twice the accuracy as well as twice the range .
It also pushes away the minimization problem twice as far .
But roundoff errors still can creep in .

Advanced techniques for limiting the problems caused by floating point can be found in books on numerical analysis .
They are beyond the scope of this text .
The purpose of this chapter is to give you some idea of what sort of problems can be encountered .

Floating point by its very nature is not exact .
People tend to think of computers as very accurate machines .
They can be , but they also can give wildly wrong results .
You should be aware of the places where errors can slip into your program .

Determining Accuracy There is simple way of determining how accurate your floating point is simple .
The method used in the following program is to add + + + and so on until the second gets so small that it makes no difference in the result .

The old language specified that all numbers were to be done in double .
removed that restriction , but because many compilers are Page really to compiler , frequently arithmetic is done in double .
This means that the expression : float ,

Note the trick used to determine the accuracy of the numbers in storage .

Example .

more precise definition can be found in the standard file .

Precision and Speed variable of type double has about twice the precision of normal float variable .
Most people assume that arithmetic takes longer than .

assume we have one of the older compilers that does everything in double .

For the equation : float  + must perform the following steps :
Convert from single to double precision .
Convert from single to double precision .
add .
Convert into single precision and store in If the variables were of type double , would only have to perform the steps :
add .
Store in As you can see , the second form is lot simpler , requiring three fewer conversions .
In some cases , converting program from single precision to double precision makes it run faster .

NOTE Because specifies that floating point can be done in double or float , you be sure of anything .
Changing all floats into doubles may make the program run faster , slower , or the same .

The only thing you can be sure of when using floating point is that the results are unpredictable .

Page Many computers , including the PC and series machines , have special chip called processor that does all the arithmetic .
Actual tests using the Motorola chip is used in the as well as floating point on the PC show that single precision and double precision run at the same speed .

Power Series Many trigonometry functions are computed using power series .
For example , the series for sine .

So , different angles require different number of terms .
If they know ahead of time the number of terms to use , they can optimize their algorithms for that number of terms .
However , they lose accuracy for some angles .
So compromise must be struck between speed and accuracy .

assume that because the number came from the computer , it is accurate .
The library functions can generate bad when working with excessively large or small values .
Most of the time you will not have any problems with these functions , but you should be aware of their limitations .

Finally , there is the question of what is .
Our format is good for only four digits .
The sine function is cyclical .

Because our format is good to only four digits , is actually mod .
Since is bigger than  the error renders meaningless the result of the sine .

Programming Exercises Exercise : Write class that uses strings to represent numbers in the format used in this chapter .
The class should have functions to read , write , add , subtract , multiply , and divide numbers .

Page attended physics class at Cal Tech taught by two professors .
One was giving lecture on the sun when he said ,

Exercise : Create class to handle numbers .
number has constant number of digits to the right of the decimal point .

Page Advanced Pointers In This .

Pointers , Structures , and Classes delete Operator Linked List Ordered Linked Lists List Trees Printing Tree The Rest of the Program Data Structures for Chess Program Programming Exercises Answers to Chapter Questions race that binds Its body in chains and calls them Liberty , And calls each fresh link progress Buchanan One of the more useful and complex features of is its use of pointers .
With pointers you can create complex data structures such as linked lists and trees .
Figure illustrates some of these data structures .

Up to now all your data structures have been allocated by the compiler as either permanent or temporary variables .
With pointers you can create and allocate dynamic data structures , which can grow or shrink as needed .
In this chapter you will learn how to use some of the more common dynamic data structures .

Pointers , Structures , and Classes Structures and classes may contain pointers , or even pointer to another instance of the same structure .
In the following example : class item .

The operator new storage for variable and returns pointer .
It is used to create new out of thin air out of an area of memory called the Page Figure Examples of pointer use Figure Item .

The operator  unnamed variable and returns pointer it .
The " created by only be referenced through pointers , never by name .

In the following example , we use allocate an from the heap .
The variable will point our .

The operator single argument : the type of the item be allocated .
According the latest standard , if out of memory it should throw an exception and abort the program .

Suppose we are working on complex database that contains other mailing list .
We want keep our storage use minimum , so we only want allocate memory for person if he or she exists .
Creating an array of class person would allocate the data statically and use up too much space .
So we will allocate space as needed .
Our structure for person is : class person public : char char char float .

Name of the Where he lives Part of address His age His height in inches We want allocate space for this .
Later the pointer this record will be put in the database .

Example storage for character array bytes long '
The variable points this storage .

All done is substitute simple type as with an array specification .

To return the memory the heap you use the .

NOTE The reason there are two forms of the delete is because there is no way for tell the difference between an object and an array of objects .
The delete relies on the programmer using " tell the two apart .

Strictly speaking , the line : NULL ; is unnecessary .
However , it is good idea out " pointers after they are deleted .
That way , you try use deleted memory , and also you help prevent any attempts delete the same memory twice .

The other problem that occur is using memory that has been freed .
When delete is used , the memory is returned the memory pool and be reused .
Using after delete call is similar an array index error .
You are using memory that belongs someone else .
This cause unexpected results or program crashes .

Linked List Suppose you are writing program send list of names another computer using communications line .
The types in the names during the day , and then after work you dial up the other computer and send the names .
The problem is , you know ahead of time how many names are going be typed .
By using data structure , you create list of names that grow as more names are entered .
With linked list you also easily insert names into the middle of the list would be slow and difficult with an .

Also , as you will see later , linked lists be combined with other data structures handle extremely complex data .

linked list is chain of items where each item points the next item in the chain .
Think about the treasure hunt games you played when you were kid .
You were given note that said , in the " You raced the mailbox and found the next clue , in the big tree in the back " and so on until you found your treasure you got .
In treasure hunt each clue points the next one .

Figure graphically illustrates linked list .

The variable points the first of the list .
In the beginning , before we insert any elements into the list is , this variable is initialized NULL .

Figure illustrates how be added the beginning of linked list .
Now all we have do is translate this into code .

To do this in , we execute the following steps :
Create the item we are going add .

Example contains the find function .

Question : Why does running this program sometimes result in bus error .
Other times it will report " an item that is not in the list .

In our find program we had use the cumbersome notation access the field of the structure .
provides shorthand for this construct using the arrow_operator operator .
The dot operator means the field of structure , and the structure pointer operator indicates the field of structure pointer .

The following two expressions are equivalent :

So far we have only added new to the head of linked list .
Suppose we want to add in order .
Figure is an example of an ordered linked list .

Page Figure Ordered list Figure shows the steps necessary to add new  to the list .

The following member function implements this algorithm .
The first step is to locate the insertion point .
The points to the first of the list .
The program moves the variable along the list until it finds the proper place for the insertion .
The variable is set to point to the previous value .
The new will be inserted between these .

Adding " to an ordered list Now we know where to insert the new .

This should point to the new  so :  Page .

This is accomplished with the code :

List list contains two links .
One link points forward to the next  the other points backward to the previous .
lists are useful where the program needs to go through the list both forward and backward .

The classes for list are : class .

Page Figure list care of the case where the is inserted at the head of the list or the end of the list .

list insert , part The links are set up for the new .
Now all we have to do is break the old links between items and and connect them to the new .

Getting to is bit of trick .
We only have pointer to .

However , if we follow the previous link back , we get the that we want .
Now all we have to do is fix the for this .

The code for this is surprisingly simple :  Visually we can see this operation in Figure .

The new previous pointer :

Trees Suppose we want to create an alphabetized list of the words that appear in file .
We could use linked list , but searching linked list is slow because we must check each until we find the correct insertion point .
By using type called tree , we can reduce the number of comparisons tremendously .

binary tree structure looks like Figure .

Each box is called node of the tree .
The box at the top is the root and the boxes at the bottom are the Each node contains two pointers : left pointer and right pointer , which point to the left and right subtrees .

Page Figure .
list insert , part .

Trees are often used for storing symbol table list of variables used in .
In this chapter we will use tree to store list of words and then to Programming trees are written with the at the top and the leaves at the bottom Common sense tells you that this is upside down In case you noticed , common sense has very little to do with programming Page .

Tree print the list alphabetically .
The advantage of tree over linked list is that searching tree takes considerably less time .

Page In this example , each node stores single word .
The left subtree stores all the words less than the current word , and the right subtree stores all the words greater than the current word .

For example , Figure shows how we descend the tree to look for the word " We would start at the  Because " we would descend the right link Figure .
Tree search Recursion is extremely useful with trees .
Our rules for recursion are the function must make things simpler and there must be some endpoint .

The algorithm for inserting word in tree is :
If this is null tree , create tree with this word .

If this node contains the word , do nothing .

Otherwise , enter the word in the left or right subtree , depending on the value of the word .

Does this algorithm satisfy our recursion rules .
The has two definite endpoints :
match is found .

Otherwise , we enter the word into subtree is simpler than the whole .

Page To see how this works , consider what happens when we insert the word " into the tree .

First we check the word " against " is smaller , so we go to " Because " is bigger , we go to " Because " is smaller than " we try the left link .
It is NULL , so we create new .

This code makes use of new  strdup .
This creates copy of on the heap and returns pointer to the new .
The may later be returned to the heap using the delete The to enter value into tree .

This passes pointer to the of the tree to .
If the is NULL , creates the .
Because we are changing the value of pointer , we must pass reference to the pointer .

It is , however , available in all the compilers seen It appears to be part of an unwritten standard Page Printing Tree Despite the complex nature of tree structure , it is easy to print .

The printing algorithm is :
For the null tree , print nothing .

Print the data that comes before this .

Print the data that comes after this .

The code for printing the tree .

The Rest of the Program Now that we have the data structure defined , all we need to complete the program is few more functions .
The main checks for the correct number of arguments and then calls the scanner and the routine .

The scan reads the file and breaks it into words .
It uses the standard macro isalpha .

The macro returns if its argument is letter and otherwise .
It is defined in the standard include file .
After word is found , the enter is called to put the word in the tree .

Example is the listing of .

Question : once made program that read the dictionary into memory using tree structure and then used it in program that searched for misspelled words .
Although trees are supposed to befast , this program was so slow you would think used linked list .

Hint : Graphically construct tree using the words ,   and " and look at the .

Page Data Structures for Chess Program classic problem in artificial intelligence is the game of chess .
So far , in spite of all our advances in computer science , no one has been able to create program that plays chess better than the best grand masters .

We are going to design data structure for program .
In chess there are several moves you can make .
Your opponent has many responses , to which you have many answers , and so on back and forth for several levels of moves .

Our data structure is beginning to look like tree .
But this is not binary tree , because we have more than two branches for each .

The problem is that the number of moves from any given position varies dramatically .
For example , in the beginning you have lots of pieces running Trivia question .
What are the moves you can make in chess from the starting position .

Page Things like rooks , queens , and bishops can move any number of squares in straight line .

When you reach the end game an evenly matched , each side probably has only few pawns and one major piece .
The number of possible moves has been greatly reduced .

We want to be as efficient in our storage as possible because chess program stresses the limits of our machine .
We can reduce storage requirements by changing the array into linked list .
The resulting structure .

Graphically , this looks like Figure .

The new adds little complexity , but saves great deal of storage .

Programming Exercises Exercise : Write program .

Exercise : Write function to delete an element of linked list .

Exercise : Write function to delete an element of list .

Page Exercise : Write function to delete an element of tree .

Answers to Chapter Questions Answer : The problem is with the statement : while is checked before we check to see whether is valid .
If it is NULL we can easily check random memory location that could contain anything .
The solution is to check before checking what it is pointing to : while break ; Answer : The problem was as follows : because the first in the dictionary was the smallest , every other used the link .
In fact , because the entire list was ordered , only the link was used .
Although this was defined as tree structure , the was linked list .
See Figure .

Figure Dictionary tree Page Some of the advanced books on data structures , such as Algorithms + Data Programs , discuss ways of preventing this by balancing binary tree .

Trivia Answer : You give up .
right , the move is to resign .

Page Advanced Classes In This .

Derived Classes Virtual Functions Virtual Classes Function Hiding in Derived Classes Constructors and Destructors in Derived Classes Summary Programming Exercises Answers to Chapter Questions Questions The ruling ideas of each age have ever been the ideas of its ruling class Marx Manifesto of the Communist Party Derived Classes The class that was defined in Example contains one major limitation : it does not check for bad data .
For example , there is nothing that prevents the user from pushing too many things onto the .

We need to define new .
This new does everything simple does but also includes checking .
allows you to build new on old ones .
In this case we will be building our on the existing simple .
Technically we will be using the class as base class to create new class , the .

We start by telling that we are creating out of .

The keyword public tells to make all the members of accessible to the outside world .
If we declared as private then the public and protected members of would be accessible only inside .

This declaration tells that we are going to use as base for .
Figure shows how views this combination .

Now we need to define the new of the push member function .
We first check to see whether room in the .
If no room , we print Page Figure Derived class and base class .

The result is that we call push , which performs limit check and then calls push .
This push belongs to , so we perform check and call push , and so on .
The result is that push will call itself over and over until the system runs out of space .

This is not want we want .
We want to tell that we want to call the push in .
This can be accomplished by using the scope operator .
The new of looks .

The full definition for both the and is shown in Example .

Even though these two classes are relatively simple , they illustrate some important features of the language .
First we have declared as protected member variable .
This means that this variable can be used only within the class stack and in any classes derived from stack , such as .
The functions push and pop can use to do their work .
However , anyone outside of stack and cannot use the variable .

Because is derived from stack , you can use type variable wherever stack type variable is used .
In the following example , we create named that is used as parameter to the function , which takes normal , unbounded stack as parameter .

The function takes as parameter .
Even though the variable is type variable , turns it into when is called .

One way to explain this is that although is of type , when it is used by the function is looking through peephole that allows it to see only the part of the variable as shown in Figure .

Figure How " sees improve the basic so that instead of always allocating  we allocate the dynamically .
The new starts with : class private : Pointer to the in the protected :  Current item on the .

To use the new we must give it size when we declare the .

Page The way we do this is to put the unitization just after the declaration of the constructor for the derived class : But this flexibility creates some problems for the  the constructor for contains parameter .
How is the to initialize the simple .

The solution is to use syntax similar to initializing constant member .

NOTE Because the new of uses dynamic memory and , it is vital that we define the four " member functions : the constructor , the destructor , the copy constructor , and the assignment .

Virtual Functions Today there are many different ways of sending letter .
We can mail it by the United States Postal Service , send it via Federal Express , send it Certified Mail , or even fax it .
All of these methods get the letter to the person of the , but they differ in cost and speed .

define class to handle the sending of letter .
We start by defining an address class and then use this class to define addresses for the sender and the receiver .

There is , however , one little problem with this class .
depending on " to get our letters sent .
The process for sending letter is different depending on which service we are using .
One way to handle this is to have call the appropriate routine depending on what service we are .

This solution is bit clunky .
Our mail class must know about all the mailing services in the world .
Also consider what happens when we add another function to the class : class mail .

Do we create another big switch statement .
If we do , have two big switch statements to worry about .
worse , the sending instructions and cost for each service are now spread out over two functions .
It would be nice if we could group all the functions for the Postal Service in one class , all of Federal Express in one class , and so on .

For example , class for the Postal Service might .

The trouble is that letter is mail class , so when we call we call the send of the base class mail .
What we need is way of telling , call the send Member Function Type .

Example illustrates the use of virtual functions .

Page However , the derived class contain member function named c .
So when we reach the line : tries find c in the derived class and fails .
Then it tries find the member function in the base class .
In this case it succeeds and we get : called Now move on the function .
Because it takes base class as its arguments , restricts its search for member functions the base class .
So the line : outputs called But what happens when the member function is called .

That tells that the search rules are changed .
first checks whether there is member function in the derived class , and then checks the base class .
In the case of , there is in the derived class , so the line : outputs : called The member function c is also virtual function .
Therefore , starts by looking for the function in the derived class .
In this case not defined there , so then looks in the base class .
It is defined there , so we get : called Now getting back our mail .
We need simple base class that describes the basic mailing functions for each different type of service .

Now we can write routine send letter and not have worry about the details .
All we have do is call and let the virtual function do the work .

The mail class is an abstraction that describes generalized mailer .
To associate real mailing service , we need use it as the base for derived class .
But what happens if the programmer forgets put the right member functions in the derived class .
For example : class : public mail .

When we try find the cost of sending letter via Federal Express , will notice that no cost function in and call the one in mail .
The cost function in mail knows that it should never be called , so it spits out an error message and aborts the program .
Getting an error message is nice , but getting it at compilation rather than during the run would be better .

allows you specify virtual functions that must be overridden in derived class .
For this example , the   abstract mailer is : class mail .

That is , they can never be called directly .
Any class containing one or more pure virtual functions is called an abstract class .
If you tried use an abstract class as an ordinary type , such as : mail .

Virtual Classes design some classes handle tax form .
In the upper right corner of each form is blank for your name , address , and Social Security number .
All the forms contain this same information , so define class for this corer of the form .

For deductions we need Schedule , so define class for it .

Tax return structure problem with this structure is that we have two name classes .
But the name change from one form to another .
What we want is the class structure shown in Figure .

Better tax return structure Declaring base class virtual tells to combine common base classes .
Redefining using virtual base classes we .

Notice that the class name is used as the base for two derived classes ; derived classes cause their base constructor to be called to initialize the class .
Does this mean that the constructor for name will be called twice .
is smart enough to know that name is used twice and to ignore the second initialization .

Function Hiding in Derived Classes Example defines base class with the overloaded function , which comes in both an integer version and version .

Clearly , when we are using the derived class and we call the integer version of , we are calling the one in the derived class .
But what happens if we call the version .

Normally , if we have member function in the derived class , will look to the base class .

However , since version of is defined in the derived class , will look to the derived class for all flavors of .
In other words , if one form of is defined in the derived class , then that locks out all forms of the function .

Constructors and Destructors in Derived Classes Constructors and destructors behave differently from normal member functions especially when used with derived classes .
When variable is created , the constructor for the base class is called first , followed by the constructor for the derived class .

Example defines simple base class and uses it to create derived class .

Example cc .

So when we destroy the variable .

You see , is pointer to base class .
At this point all the code can see is the base class .
There is no way for to know that there is derived class out there .

So when the variable is deleted , fails to call the derived class destructor .

We need some way to tell , there is derived class out there and you might want to call its " way we do this is to make the destructor for the base class virtual function .

When sees virtual destructor , it will call the destructor of the derived class and then call the destructor of the base class .

So with the virtual destructor in place , we can safely delete the base_class variable and the program will output the proper information : destructor called base_class destructor called Question : Why does Example fail when we delete the variable program seems to get upset when it tries to call clear at line .

Page Example .

Summary Since programming began , programmers have been trying to find ways of building code .
, through the use of derived classes , allows you to Page build classes on top of existing code .
This provides great deal of flexibility and makes the code easier to organize and maintain .

Programming Exercises Exercise : Combine the checkbook class of Exercise with the queue class of Exercise to implement checkbook class that can print out the last ten entries of your checkbook .

Exercise : Define " base class .

Define derived classes that match words , numbers , and blank strings .

Exercise : Define base class shape that can describe any simple shape such as square , circle or equilateral triangle .
The size of all these shapes can be reduced to single dimension .

Define derived classes for each of the three shapes .

Create virtual function in the base class that returns the area of each shape .

Note : You will need to more precisely define what dimensions are stored in the base class .

Define two derived classes called man and woman that define gender specific items .
Write pure virtual functions in the base class for operations that are common to both sexes yet are handled in different ways by each of them .

Exercise : Write base class number that holds single integer value and contains one member function ,
Define three derived classes to print the value in hex , octal , and decimal .

Answers to Chapter Questions Answer : Remember that destructors are called in the order of derived class first and then base class .
In this case , the destructor for the derived class ,  is called to destroy the class .

Next , the destructor for the base class list is called .
It calls the function .
This pure virtual function , so must call the function in the derived class .

This Page makes very upset and it aborts the program .

Page Other Language Features Page Exceptions In This .

Stack Exceptions Runtime Library Exceptions Programming Exercises How glorious it is and also how to be an exception de Musset Airplanes fly from one place to another and of the time no trouble .
But when there is trouble such as stuck wheel or an engine fire , pilots are trained to handle the emergency .

examine in detail what happens during an airborne emergency such as an engine catching fire .
This is an exception to normal flight .
fire alarm goes off in the cockpit .

This catches the pilots ' attention and they start going through the procedure .

This is an extensive list of things to do in case of fire .
The airline prepared this list ahead of time and the pilots have the list memorized .
The pilots do necessary to handle the exception : activate the fire extinguisher , shut down the engine , land very quickly , etc .

break down this procedure into pseudocode .
When the pilots take off they are going to try to fly the plane from one point to another without problems .

Page But what happens when we get an exception .
We need to handle it .

This is the type of emergency .
It could be fire in engine number , engine number , or engine number .
Which engine is on fire is stored in the variable .

The class describes what type of fire occurred .
Its definition is : class public : int .

Buried within each is .

When this code senses fire , it puts the information in variable named and triggers an exception with the throw statement .

When the throw statement is executed , normal processing is stopped .
After all , when fire occurs , normal flying is stopped .
Execution is transferred to the catch statement for the .

To summarize , exception handling consists .

description of possible problem , in this case the class .

In this case , the statement is .

Something that causes an exception and triggers the emergency procedures through throw statement .

code inside catch block .

Stack Exceptions In Chapter , Advanced Classes , we defined stack with bounds checking .
If the user attempted to push too much data on the stack or to pop too much off , the class would issue an error message and abort .
This is not good way to handle an exception .
Think of how the pilots would feel if the plane displayed an error message and shut down every time there was fire .

The first thing we need to do is decide what type of exceptions we are going to handle and describe them as classes .
In our stack example , the only exception we expect is an error .
describe this error with simple string .
The class for an error is : const int .

Exception checking starts with the keyword try .
This tells that exceptions may be generated in the section of code that follows and that they will be handled immediately after the try block .
For example , if we are trying to perform big stack operation , the code might look .

Several catch statements may be used to catch different types of exceptions .
If an exception is not caught , it is considered an unexpected exception and will cause call to the handler , which aborts the program by default .
If you want to catch all exceptions , use " for the exception type .

Body of catch .

The basic function definition been using so far tells , any exception to be thrown at any " The push function can only throw exception .
allows you to list all the possible exceptions in function by putting throw directive at the end of the function declaration : inline void int Page But happens if we throw an exception not in the list of exceptions .
will turn this into call to the function .

Example contains new of the stack with exceptions .

Runtime Library Exceptions mechanism is relatively .
However , these " exceptions are so are still being refined and updated .
There are lots of details still to be worked out .

Compiler makers need time to catch up to the standard .
At the time of this writing , the currently available compilers generate few if any exceptions in their runtime library , and none generates " exceptions .
This situation will change as the ANSI standard gets better defined and compilers improve .
About the best advice can give you is to read your reference manual and watch out .

Programming Exercises Exercise : Add code to the queue class of Exercise that will trigger an exception when too many items are put in the queue .

Exercise : Take the fraction class from Exercise and add code to generate an exception when divide by zero occurs .
Also add code to generate an exception when bad number is read .

Exercise : Update the checkbook class of Exercise so it generates an exception when your balance goes below zero .

Page Exercise : Write function that takes single character .
This function will the number of consonants and vowels .
If nonletter is given to the function , it generates an exception .

Page Modular Programming In This .

Modules Public and Private extern Modifier Headers Body of the Module Program to Use Infinite Arrays Makefile for Multiple Files Using the Infinite Array Many , hands make light work .

As programs grow larger and larger , should be split into sections , or modules .
allows programs to be split into multiple files , compiled separately , and then combined to form single program .

In this chapter , we go through programming example , discussing the techniques needed to create good modules .
You also are shown how to use make to put these modules together to form program .

Modules module is collection of functions or classes that perform related functions .
For example , there could be module to handle database functions such as lookup , enter , and sort .

Another module could handle complex numbers , and so on .

Also , as programming problems get big , more and more programmers are needed to finish them .
An efficient way of splitting up large project is to assign each programmer different module .
That way each programmer only has to worry about the internal details of his or her own code .

In this chapter , we discuss module to handle infinite arrays .

Page Public and Private Modules are divided into two parts , public and private .
In the infinite array example , we have put the public declarations in the file listing on page .

Anything internal to the module is private .
Everything that is not directly usable by the outside world should be kept private .

Example illustrates simple use of the extern modifier .

Actually , three modifiers can be used to indicate the files in which variable defined , as shown in Table .

For complete list of the meanings of static see Table For data defined globally , static means to this " For data defined inside function , it very liberal in its use of the rules for static , extern , and modifiers .
It possible to declare variable as extern at the beginning of program and later define it as .

This ability useful when you have all your external variables defined in header file .
The program includes the header file defines the variables as , and then defines the variable for real .

Another problem concerns declaring variable in two different files .

The compiler could very carefully analyze both programs , and then pick out the value that most likely to be wrong .

In this case , there only one global variable called .
It will be initialized to either or depending on the whims of the compiler .
It entirely possible for the program main to print out : even though we initialized it to zero .
To avoid the problem of hidden initializations , use the keyword static to limit the scope of variables to the file in which they are declared .

If we had written : File : static int .

Headers Information that shared between modules should be put in header file .
By convention , all header filenames end with .
In the infinite array example , we use the file .

The header should contain all the public information , such .

comment section describing clearly what the module does and what available to the user .

Public structures Page .

This commenting not excessive ; the real guts of the coding hidden in the program file .
The file serves both as program file and as documentation to the outside world .

Notice that there no mention in the comments about how the infinite array implemented .
At this level , we care how something done .

Adding more elements to the array will just cause it to grow .

Any code that defined inline .
No actual code or storage defined in the header file .

The Body of the Module The body of the module contains all the functions and data for that module .
Private functions that are not to be called from outside the module should be declared static .
Variables declared outside of function that are not used outside the module are declared static .

Program to Use Infinite Arrays The infinite array module shown in Figure .
The program uses simple linked list to store the elements of the array .
linked list can grow longer as needed you run out of .
Each list element , or bucket , can store numbers .
To find element , the program starts at the beginning , skips past the first three buckets , and then extracts element from the data in the current bucket .

Infinite array structure Page Example contains the code for module .

The Makefile for Multiple Files The utility make is designed to aid the programmer in compiling and linking programs .
Before make , the user had to explicitly type compile commands each time there was change in the program : NOTE In this chapter we use the commands for the GNU compiler .
The compiler on your system may have different name and slightly different syntax .

As programs grow , the number of commands needed to create them grows .
Typing in series of or commands is tiresome and , so programmers started writing shell scripts , in .
Then all the programmer had to type was and the computer would compile everything .
This was overkill , however , because all the files were recompiled regardless of need .

As the number of files in project grew , this recompiling became significant problem .

Changing one small file , starting the compilation , and then having to wait until the day while the computer executed several hundred compile commands was when only one compile was really needed .

The program make was created to do intelligent compiles .
Its purpose is to first decide what commands need to be executed and then execute them .

The file Makefile is important in contains the rules used by make to decide how to build the program .
The Makefile contains the following sections : Page .

Default rules Any line beginning with is comment .

macro has the format : data Name is any valid identifier .
Data is the text that will be substituted whenever make sees .

Example : Very simple Makefile Doing All all : Explicit rules tell make what commands are needed to create the program .
These rules can take several forms .
The most common is : target : source command .

Target is the of file to create .
It is " or created , out of the source file source .
If the target is created out of several files , they are all listed .

The command used to create the target is listed on the line .
Sometimes it takes more than one command to create the target .
Commands are listed one per line .
Each is indented by tab .

For example , the rule : hello : hello tells make to create the file hello from the file using the command : hello Page Make will create hello only if necessary .
The files used in the creation of hello , arranged in chronological order modification , are shown in Table .

Table File Modification Times UNIX .

Newest If the programmer changes the source file , the modification time will be out of date with respect to the other files .

Another form of the explicit rule is : source : command In this case , the commands are executed each time make is run , unconditionally .

If the commands are omitted from an explicit rule , make uses set of rules to determine what command to execute .

For example , the rule : tells make to create from and , using the standard rule for making .

Both files include the header , so they depend on it .
The UNIX Makefile that creates the program hist from and is listed in Example .

Example Make file needs debugging .

If any of the object files are out of date , make will them .

The line : tells make to create from and is .
Because no command is specified , the default is used .

Example shows the Makefile for , using .

There is one big drawback with make .
It only checks to see whether the files have changed , not the rules .
If you have compiled all your program with for debugging and need to produce the production version , make will not recompile .

The command touch changes the modification date of file .
This is useful if you have changed the flags and want to force .

Make provides rich set of commands for creating programs .
Only few have been discussed Using the Infinite Array The histogram program is designed to use the infinite array package .
It takes one file as its argument .
The file contains list of numbers between and .
Any number of entries may be used .
The program prints histogram showing how many times each number appears .
The first one is : Let the computer do the work whenever possible .
For example , program like .

Also , the computer is more accurate in its computations .
In the hist program , if the user does not type the correct number of parameters on the command line , message appears telling what is wrong and how to correct it .

The program uses the library routine memset to initialize the counters array .
This routine is highly efficient for setting all values of an array to zero .
The line : zeros the entire array counters .
Example contains program that uses the infinite array for storing data used to produce histogram .

sample run of this program produces : test : Page : Dividing Task into Modules Unfortunately , computer programming is more of an art than science .
There are no hard and fast rules that tell you how to divide task into modules .
Knowing what makes good module and what comes with experience and practice .

This section describes some general rules for module division and how they can be applied to programs .
The techniques described here have worked well for me .

Information is vital part of any program .
The key to program is your decision about what information you want to use and what processing you want to perform on it .
Be sure to analyze the information flow before you begin the design .

Design the modules to minimize the amount of information that has to pass between them .
If you look at the organization of the Army , see that it is divided up into modules .
There is the infantry , artillery , tank corps , and so on .
The amount of information that passes between these modules is minimized .
For example , if an infantry sergeant wants the artillery to bombard an enemy position , he calls up artillery command and says , pillbox at location .

Get rid of " The artillery command handles all the details of deciding which battery to use , how much firepower to allocate based on the requirements of other fire missions , maintaining supplies , and many more Programs should be organized the same way .
Information that can be kept inside module should be .
Minimizing the amount of intermodule communication cuts down on communication errors as well as limiting maintenance problems that occur when module is upgraded .

It is program that allows the user to display and change text files .
The main piece of information is the text file we are editing .
Most editors are display oriented and continually display about lines of the current file on the screen .

Finally , one more piece of information is needed : the editing commands .
The commands are typed in by the user .
This information must be parsed so the computer can understand it .

The individual commands are small and perform similar functions line is very much like delete .
Imposing standard structure on the command execution modules improves readability and reliability .
block diagram of the editor can be seen in Figure .

Module division of the text editor There is minimal communication between the modules .
The display section needs to know only two things : where the cursor is and what the file currently looks like .
All the file module needs to do is read the file , write the file , and keep track of changes .
Even the way the changes are made can be minimized .
All Page editing commands , no matter how complex , can be broken down into series of inserts and deletes .
It is the responsibility of the command module to take the complex user commands and turn them into simple inserts and deletes that the file handler can process .
Information passing between the modules is minimal .
No information passes between the command decoder and the display module .

word processor is just fancy text editor .
Where simple editor only has to worry about ASCII characters font , one , word processor must be able to handle many different sizes and shapes .

Compiler Construction In compiler , the information being processed is code .
The job of the compiler is to transform that information from source to object code .
There are several stages in this process .
First the code is run through the preprocessor to expand macros , take care of conditional compilation , and read include files .
Next the processed file is passed to the first stage of the compiler , the lexical analyzer .

The lexical analyzer takes as its input stream of characters and returns series of tokens .
token is term meaning word or operator .
For example , look at the English command : Open the door .

There are characters in this command .
Lexical analysis would turn this into three words and period .
These tokens are then passed to the parser where they are assembled into sentences .

At this stage symbol table is started so that the parser can have some idea what variables are being used by the program .

Now the compiler knows what the program is supposed to do .
The optimizer looks at the instructions and tries to figure out how to make them more efficient .
This step is optional and is omitted unless the flag is specified on the command line .

The code generator turns the statements into assembly code .
In assembly language , each statement corresponds to one machine instruction .

The assembler turns assembly language into binary code that can be executed by the machine .

The general information flow of compiler is diagrammed in Figure .

Lexical analysis and parsing are very common and used in wide variety of programs .
The utility lex can generate the lexical analyzer module for program , given description of the tokens used by the program .
Another utility , yacc , can generate the parser module .
These programs are described in the book lex .

Page Figure Compiler modules Spreadsheet simple spreadsheet takes matrix of numbers and equations and displays the results on screen .
The information managed by this program is the equations and the data .

The core of spreadsheet is the equations .
To change the equations into numbers , we need to go through lexical analysis and parsing , just like compiler .

Page But unlike compiler , we generate machine code .

Results are passed off to the display manager , which puts them on the screen .
Add to this an input module that allows the user to edit and change the equations , and you have spreadsheet , as shown in Figure .

Figure Spreadsheet layout Module Design Guidelines Although there are no hard and fast rules when it comes to laying out the modules for program , here are some general guidelines .

Modules should contain no more than lines .
With more lines , they become difficult to edit , print , and understand .

Programming Exercises Exercise : Write class that handles formatting .
It should contain the following .

Closes the print file .

Exercise : Write module called that first receives an array of filenames that it searches until it finds one that exists , and then it opens that file .

Exercise : Write symbol table class containing the following functions : Enters name into the symbol table .

Removes name from the symbol table .

Exercise : Take the words program from Chapter , Advanced Pointers , and combine it with the infinite array module to create program .

Templates : The Hard Way Function Specialization Class Templates Class Specialization Implementation Difficulties Summary Programming Exercises Thou patten of excelling nature Othello , Act What Is Template .

They allow you to write generic classes and functions that work for several different data types .

Templates will be very useful part of the language , when they grow up .
The problem is that although the Draft ANSI Standard specifies the complete syntax for templates , it says nothing about how to implement them .
The result is that each compiler maker has implemented templates differently , so programs that use templates tend to be nonportable .

Templates : The Hard Way Suppose we want to define function max to return the maximum of two items .
Actually , we want to define just one max function , but family of functions : one to find the maximum of two ints , one for floats , one for chars , and so on .

We start by defining parameterized macro to generate the code for the function .
This is called the definition stage .
The macro looks like : type dl , type return ;

Page NOTE Each line except the last one ends in backslash .
macro spans single line , so the backslash turns our five lines into one .
By putting the backslashes in the same column we can easily tell if we miss one .

This macro generates no code .
It merely provides the definition that is used in the next phase to generate the functions we want .
This is called the generation phase .

Finally , somewhere in the code we use the functions just defined .

Figure shows the source code for the style templates and the code generated by them .

This method works adequately for simple functions like max .
It work well for larger functions .
One drawback to this system is that we must invoke the macro for each data type we want to use .
It would be nice if would call automatically .

Templates allow you to define generic function .
then uses this template to generate specific instance of the function as needed .
For example , to define the function max as template , we write :

NOTE The construct tells that the word kind can be replaced by any type .
Like the parameterized macro , it generates no code : it merely provides definition for the next phase Page Figure .
Code generated by style templates .

Page and sees that it uses the function max ,
It then checks to see whether the code for this function has been generated and generates it if necessary .
In other words , everything is automatic .
From this you can see that the first time max is used for float it generates the floating point version of max .
Next we use max for int , and the int version of max is created .
Note that the last .

Figure Template code generation Page Function Specialization Templates go bit further than simple code generation .
They can handle special cases as well .

What we want to do is tell , the normal comparison except when the data type is string , and then use This is done through process called specialization .
We declare special version of the max function just for .

will find the simple function , char before trying to expand the .

Class Templates Class are little more complex than function .
Declaring them is easy .
They are defined just like function .
Example shows the stack class from Chapter , Simple Classes , written as template .

Example cc .

We could just as well have specified the procedures outside the class .
To do so , we must put the template clause in front of each procedure and put the template parameter in the of the class .
For example , the push routine would look like : push an item on the Warning : We do not check for overflow Parameters item item to put on the .

will also generate automatically the member functions : and .

However , if you explicitly declare member function yourself , will use your definition before generating its own .
Suppose we want to have store strings .
We want to store the pointers ; we want to store the actual strings .
To do this , we need special version of the push function that duplicates the string before pushing it onto the .

Implementation Difficulties The Annotated Reference Manual by Ellis and Stroustrup is considered the default standard of the language .
It contains complete definition of the syntax for .

However , it does not explain how compilers should implement them .

As you shall see , implementing is not easy .
For example , suppose we put the in module .
The file defines the class and the file defines the Now we want to use the for an integer in the file .

Figure shows the layout .

This is where the compiler implementors start pulling their hair out .

Page Figure .
layout for using We know that in , going to use .
As matter of fact , the file defined prototypes for the two member functions push and pop .
So when the compiler sees , it should automatically generate the code for push and pop .

The bodies of these two member functions are tucked away in the file .
The compiler is working on .
It know anything about any other file , so it know how to generate and .

But the compiler generate and when it compiles .

Yes , if it knew that someone had declared variable .
But the only one who did that is and the compiler working on that file just now .
Managers call this situation compatible .
Code written for one compiler may not work on another .
In some cases , even code written for one version of compiler might not work in another version .

Templates are the leading edge of compiler technology and , like all new  there are just few bugs to work out .
In the following sections , we discuss the various ways compiler makers have attempted to solve the problems associated with templates .
Compiler technology and standards are constantly evolving , so the information in this section may not be up to date .

Implementation As of this publication date , the Microsoft and Visual compilers do not have templates .
Although extremely simple , this form of " is very Page limited .
On the other hand , never had any trouble with templates using Microsoft compiler .

and GNU Templates The and the GNU compilers take similar approach .
If you plan to use , then you must have in the file that defines the member functions :
At the beginning of the file , you will need the line : typedef ; Actually you never have to use the type .
The typedef is there just to tell the compiler to generate the needed member functions .

Both compilers also have switches that tell the compiler what to do about inline functions that be handled inline .
Suppose you define the function : inline kind dl , kind .

Also suppose that the function is so complex that the compiler decided to ignore the When your three files are compiled , three copies of are generated .
The linker is smart enough to detect this fact and will throw two of them away .
The GNU linker is not so smart , and wind up with three copies of the same routine in your code .

Both and GNU provide you with compiler options that help solve this problem .
If you put the line : interface GNU only option .

The options are clunky , nonportable , and difficult to use .
They are meant to solve an implementation problem that has not been properly solved yet .

Compilers CFront is the name of the to translator that was the basis of the first compiler .
Most compiler makers consider themselves standard if they are compatible with the latest version of CFront .

CFront handles the problem of generation by putting it off until link time , so you only compile and link the file .
At link time , CFront notices that uses .
It then looks for file named .

Although this method seems simple enough , there are lot of details to take care of .
For example , the file is automatically included when the linker tries to compile .

worse , if you include it yourself with , the compiler gets confused .

The CFront approach is good attempt at solving the problem , but there are still many bugs to work out .

Writing Portable Templates How can you write portable .
The simple answer is , use " However , the best way to create truly portable is to write everything as inline functions and put all your functions in file .
As far as can tell , this method works for every compiler that has templates .
It may not be the most efficient way of doing things , but it is the most portable .

Summary Templates provide convenient way of writing generic classes and functions .
However , implementation of templates is still undergoing refinement .
As practical matter , you may want to wait until the language settles down little before using them .

Programming Exercises Exercise : Write template min that returns the minimum of two values .
Make sure you handle strings correctly .

Page Exercise : Write template class to implement an array with bounds checking .

Exercise : Define template class that implements set .
The class allows you to set , Page Portability Problems In This .

Modularity Word Size Problem Alignment Problem Problem Filename Problems File Types Summary Answers to Chapter Questions Wherein spake of most disastrous changes , Of moving accidents by flood and field , Of ' the imminent deadly breadth on Program Porting Othello , Act , Scene just completed work on your great masterpiece , program that renders complex shaded graphics on Cray supercomputer using of memory and of disk space .
What do you do when someone comes in and asks you to port this program to an IBM PC with of memory and of disk space .

Not only is it illegal , but it also is considered unprofessional .
Your only choice is to whimper and start the port .
It is during this process that you will find that your nice , working program exhibits all sorts of strange and mysterious problems .

programs are supposed to be portable .
However , contains many features .
Also , because of the vast difference between UNIX and , system dependencies can frequently be found in many programs .
This chapter discusses some of the problems associated with writing truly portable programs as well as some of the traps you might encounter .

Modularity One of the tricks to writing portable programs is to put all the nonportable code into separate module .
For example , screen handling differs greatly in and UNIX .
To design portable program , have to write modules .

Page For example , the terminal has set of function keys labeled .
The PC also has set .
The problem is that these keys send out the same set of codes .
The HP sends " for and the PC sends .
In this case , you would want to write routine that gets character function key from the keyboard and translates function keys .
Because the translation is different for both machines , module is needed for each one .
For the HP machine , you would put together the program with and , while for the PC you would use and .

Word Size long int is bits , short int is bits , and normal int can be or bits depending on the machine .
This can lead to unexpected problems .
For example , the following code works on UNIX system , but fails when ported to : int .

Problem short int consists of two bytes .

The two bytes have the value and .
Which value is stored in the first byte .
The answer is machine dependent .

This can cause considerable trouble when you try to write portable binary files .
Motorola machines use one type of byte order , while Intel and Digital Equipment Corporation machines use another .

One solution to the problem of portable binary files is to avoid them .
Put an option in your program to read and write ASCII files .
ASCII offers the twin advantages of being far more portable as well as human readable .

Page The disadvantage is that text files are larger .
Some files may be too big for ASCII .
In that case , the magic number at the beginning of file may be useful .
Suppose the magic number is bad magic number , but good .
When the program reads the magic number , it can check against the correct number as well as the version .
The program can automatically fix the file problem : const int MAGIC .

Alignment Problem Some computers limit the addresses that can be used for integers and other types of data .
For example , the series requires that all integers start on boundary .
If you attempt to access an integer using an odd address , you generate an error .
Some processors have no alignment rules , while some are even more restrictive , requiring integers to be aligned on boundary .

Alignment restrictions are not limited to integers .
Floating point numbers and pointers also must be aligned correctly .

hides the alignment restrictions from you .
For example , if you declare the following structure on .

Structure on and architectures On an machine with no alignment restrictions , this is allocated as shown on the right in Figure .

The problem is that the size of the structure changes from machine to machine .
On , the structure size is six bytes and on the , it is five .
So if you write binary file containing records on , it will be bytes long , while on an it will be only bytes long .
Obviously the file is not written the same way on both machines .

One way around this problem is to use ASCII files .
As we have said before , there are many problems with binary files .
Another solution is to explicitly declare pad byte : struct char .

The pad character makes the field value align correctly on machine while making the structure the correct size on an machine .

Using pad characters is difficult and .
For example , although is portable between machines with and alignment for integers , it is not portable to any machine with integer alignment .

Problem Many programs and utilities were written using UNIX on VAX computers .
On this computer , the first byte of any program .
Many programs written on this computer contain bug : They use the null pointer as .

Page .

This actually an illegal use of .
Null pointers should never be dereferenced .
On the VAX , this error causes no problems .
Because byte zero of the program zero , points to null .
This due to luck , not design .

On VAX , this will print : On an old Celerity , the first byte of the program " When this program run on Celerity , it will print : String ' On other computers , this type of can generate unexpected results .
Many of the utilities ported from VAX to Celerity exhibited the " bug .

Filename Problems UNIX specifies files as while uses .
When porting from UNIX to , file names must be changed .
For example : UNIX version of the file DOS version of the file Question : Why does Example work on UNIX , but when we run it in we get the message : oot ew able : file not found Example .

File Types In UNIX there only one file type .
In there are two , text and binary .
The flags and are used in to indicate file type .
Older versions of UNIX have no such flags .

One way of handling this problem to write different open calls for each system : This messy .
far better way to define dummy and flags : Do we have an .

Because runs on many different types of machines that use different operating systems , it not easy .
However , if you keep portability in mind when creating the code , you can minimize the problems .

Porting words Portability problems are not limited to programming .
When Practical Programming was translated to Japanese , the translator had problem with one exercise : program that removes words from file and replaces them with more The problem was , in Japanese , everything word .

When the translator came to phrase he directly translate , he did his best and also put in the English .
But for the words , he decided to the English as well as some additional help added .
use words like : additional help added .
use words like : Page Answers to Chapter Questions Answer : The problem that uses the backslash as an escape character .
The character , and .
What we really have for name  The name should be specified as : NOTE The uses filename , not .
While you must use double backslashes in  you use single backslashes in an .
The following two lines are both correct : Page Putting It All Together In This .

Requirements Code Design Coding Functional Description Testing Revisions Final Warning Program Files Programming Exercises Exercises For there isn job on the top of the earth the beggar know , nor do In this chapter we create complete program .
Every step of the process is covered , from setting forth the requirements to testing the result .

Requirements Before we start , we need to decide what it is we are going to do .
This is very important step and is left out of far too many programming cycles .

This program must fulfill several requirements .
First , it must be long enough to demonstrate modular programming , but at the same time be short enough to fit inside single chapter .
Second , it must be complex enough to demonstrate wide range of features , but be simple enough for novice programmer to understand .

Finally , it must be useful .
This is not so simple to define .
useful to one person might not be useful to another .
We decided to refine this requirement and restate it as must be useful to " The program we have selected reads source files and generates simple statistics on the nesting of parentheses , and the ratio of comments to code lines .

The specification for our statistics program is : Preliminary Specification for Statistics Gathering Program Steve Oualline February , Page The program stat gathers statistics about source files and prints them .
The command is : stat files where files is list of source files .
The following shows the output of the program on short test file .

Maximum nesting of  Number of blank lines Number of comment only lines Number of code only lines Number of lines with code and comments Comment to code ratio Code Design There are several schools of code design .
In structured programming , you divide the code up into modules and then divide the module into submodules , divide the into , and so on .
This is also known as oriented programming .
In programming , you try to think of the problem as collection of data that you manipulate through member functions .

There also are other approaches , such as state tables and transition diagrams .
All of these have the same basic principle at heart : the information in the clearest and Our program breaks down into several logical modules .
First , there is token scanner , which reads raw code and turns it into tokens .
Actually , this function into two smaller modules .
The first reads the input stream and determines what type of character we have .
The second takes in information and uses it to assemble tokens .
The other module contains the statistics gathering and small main program .

Token Module Our program scans source code and uses the tokens to generate statistics .
token is group of characters that form single word , number , or symbol .
For example , the line : + Compute some sort of consists of the tokens : Left Parenthesis number Page number Right parenthesis divide operator number semicolon comment Our token module needs to identify groups of characters .
For example , an identifier is defined as letter or underscore , followed by any number of letters or digits .
So our tokenizer needs to contain the pseudocode : If the current is letter then scan until we get not letter or digit As you can see from the pseudocode , our tokenizer depends great deal on types , so we need module to help us with the type information .

Module purpose of the module is to read characters and decode their types .
Some types overlap .
For example , includes the NUMERIC set .

This module stores most of the type information in an array and requires only little logic to handle the special types like .

Statistics Class In this program , statistic is an object that consumes tokens and outputs statistics .
We start by defining an abstract class for our statistics .
This class is used as the basis for the statistics we are collecting .

Figure Statistics class hierarchy Our definition of statistic is that uses tokens to collect " These statistics may be printed at the beginning of each line or at the end of the file .

Page Our four statistics are more specific .
For example , the class counts the nesting of parenthesis as well as the maximum nesting .

It counts the number of tokens and outputs that count at the start of each line .

Coding coding process was fairly simple .

Functional Description This section describes all the classes and major functions in our program .
For more complete and detailed description , take look at the listings at the end of this chapter .

For the most part , this is done through table named .
Some types , such as , include two different types of characters , and .
Therefore , in addition to our table , we need little code for the special cases .

It buffers up line and on command writes the line to the output .

We have an input stream consisting of characters .
Actually , our tokenizer is rather simple , because we have to deal with most of the details that full tokenizer must handle .

Page One clever trick is used in this section .
macro is used to generate an enumerated list of token types as well as string array containing the names of each of the tokens .
examine how this is done in more detail .

This allows us to use to generate list of strings containing the names of the .

Using tricks like this is acceptable in limited cases .
However , such tricks should be extensively commented so the maintenance programmer who has to fix your code can understand what you did .

It starts with member function to consume tokens .
This function is pure virtual function , which means that any derived classes must define the function .

We need some way of printing them .
We print statistics in two places .
The first is at the beginning of each line and the second is at the end of the file .
Our abstract class contains two virtual functions to handle these two .

They have to define or eof .

This counting is done through the class .
The only it cares about is .
At the beginning of each line it outputs the line number current count of the .
At the end of file , this class outputs nothing .
As matter of fact , the class even define an eof function .
Instead , we let the default in the Page class This class keeps track of the nesting level of the curly braces .
We feed the class stream of tokens through the member function .
This function keeps track of the left and right curly braces and ignores everything else .

The results of this statistic are printed in two places .
The first is at the beginning of each line .

The second is at the end of file .
We define two member functions to print these statistics : Output start of line statistics namely the current line number .

As matter fact , it was created by copying the class and performing few simple edits .

We probably should combine the class and the class into one class that uses parameter to tell it what to count .
Oh well , something for the next version .

Page class In this class , we keep track lines with comments in them , lines with code in them , lines with both , and lines with none .
The results are printed at the end file .

But how does it know what statistics classes to use .
There is list : static static static static .

Counter Counter Counter Counter lines .

Even though , and are all different types , they are all based on the type stat .
This means that we can put them in an array called .
This design also makes it easy to add another statistic to the list .
All we have to do is define new class and put new in the .

Testing To test this program , we came up with small program that contains every different type possible .
The results are shown in Example .

Revisions As it stands , the program collects very limited set statistics .
It might be nice to add things like average identifier size , statistic , and statistics .
One thing we kept in mind when we designed our program is the need for expendability .

We stopped our statistics collection at four types statistics because we had fulfilled our mission to demonstrate reasonable advanced set constructs .
We add more because it would make the program too complex to fit in the chapter .
On the whole , the program does its job well .

Final Warning Just because you can generate statistic mean that useful .

Program Files The file Example Character type class Member functions : type returns the type character .

The Example token token handling module Functions : get the next token from the input .

Can be or depending on what we read .

The Example stat Produce statistics about program Usage : stat .

Counter Counter Counter Counter lines .

Page list the statistics we are collecting static stat , NULL ; process single file Parameters name the name the file to process .

Example Makefile for many UNIX compilers using the " command all : stat : stat stat .

Page UNIX Makefile for Example .

Exercise : Write program that removes words from file and replaces them with more acceptable equivalents .

Page Exercise : Write mailing list program .
This program will read , write , sort and print mailing labels .

Exercise : Update the statistics program presented in this chapter to add capability .

Exercise : Write program that takes text file and splits each long line into two smaller lines .
The split point should be at the end of sentence if possible , or at the end of word if sentence is too long .

Overview struct malloc and free Turning Structures into Classes setjmp and longmp Summary Programming Exercise No distinction so little excites envl as that which is derived from ancestors by long descent .

both blessing and curse .
curse because it means probably have to deal with lot of ancient code .
On the other hand , there will always be work for you .
This chapter describes some of the differences between and as well as how to migrate from one to the other .

Functions Classic called after its authors , Brian Kernighan and Dennis uses function header different from the one used in .
In the parameter types and names are included inside the defining the function .
In Classic , only the names appear .

When came along , the ANSI committee decided it would be good idea if used the new definitions .
However , because there was lot of code out there using the old method , accepts both types of functions .
Classic does not require prototypes .
In many cases , prototypes are missing from programs .
that does not have prototype has an implied prototype of : int .

Otherwise , you will have to do it manually .

has no operations .
Instead , it makes use of two library routines : malloc and free .

The malloc takes single number of bytes to returns pointer to them char or void .
But how do we know Page how big structure is .
where the sizeof comes in .
It returns the number of .

The calloc is similar to malloc except that it takes two parameters : the number of .

The memory allocators are messy , however , and should be converted to whenever possible .

There are number of traps concerning memory allocation .
Suppose we take our structure and turn it into class .
We can but use the memory routines to allocate space for the class : class ; code like this Because treats struct as special form of class most compilers complain about this code .
The problem is that our malloc statement allocates space for and all .
No constructor is called , so quite possible that the class will not get set up correctly .

uses the free to return memory to the heap .
The free takes single character pointer as parameter making lot of casting :

Again , you be careful when turning into class .
The just returns the memory to the heap .
It does not call the destructor for .

memory allocation is messy and risky .
When converting to you probably should get rid of all malloc , calloc , and whenever possible .

WARNING According to the ANSI draft standard , memory allocated by malloc be deallocated by .
Similarly , memory allocated by new be deallocated by delete .
However , most of the compilers seen implement new call to malloc and delete call to .
In other words , mixing or will usually work .
To avoid errors , you should follow the rules and avoid mixing and operations .

Turning Structures into Classes Frequently when examining code you may find number of struct statements that look like they should be classes .
Actually , structure is really just class with all the members public .

programmers frequently take advantage of the fact that structure only contains data .
One example of this is reading and writing structure to binary file .

keeps extra information , such virtual pointers , in class .
When you write the class to disk using raw write , you are outputting all that information .
worse , when you read the class in you overwrite this bookkeeping data .

Page For example , suppose we have the .

Internally , this class consists of three member variables : constant , allow you to ; simple  and pointer to the real to be used when is called .
All three of these are written to disk by the call : sample .

When this class is read , all three members are changed .
That includes the constant we supposed to and the pointer now probably points to something .

programmers also make use of the memset to set all the members of structure to zero .

Again , be careful when turning structure into class .
If we had used the class instead of the structure , we would have zeroed the constant well the virtual pointer .
The result would probably be crash if we ever tried to call .

The setjmp marks place in program .
The longjmp jumps to the place marked by setjmp .

Normally setjmp returns zero .
This tells the program to execute normal code .
When an exception occurs , the longjmp call returns to the location of the setjmp .
The only difference the program can see between real setjmp call and fake setjmp call caused by longjmp is that normally setjmp returns zero .
When setjmp is " by longjmp , the return value is controlled by parameter to longjmp .

The definition of the longjmp call is : void env , int ; where : env is the environment initialized by previous setjmp call is the return code that will be returned by the setjmp call Figure illustrates the control flow when using setjmp and longjmp There is one problem here , however .
The longjmp call returns control to the corresponding setjmp .
It does not call the destructors of any classes that are " in the process .

In Figure we can see that in the subroutine we define class named .

Normally we would call the destructor for at the end of the function or at return statement .
However , in this case we use longjmp to exit the function .
Since longjmp is function it knows nothing about classes and destructors and does not call the destructor for .
So we now have situation where variable has disappeared but the destructor has When converting to , change all combinations into exceptions .

Page Figure .
Change function headers into standard headers .

Change calls into operations .

Following these three steps you have program .
It works , but really program in clothing .
To convert it to real program you need to do the following :
Change malloc into new .

Change into delete or delete calls .

Turn printf and scanf calls into cout and cin .

When turning struct declarations into class variables , be careful of read , write , and memset functions that use the entire structure or class .

Programming Exercise Exercise : There are lot of programs out there .

Page Dustier Corners In This .

It is titled Dustier Corners because these statements are hardly ever used in real programming .

The program loops , tests the expression , and stops if the expression is false .

NOTE This construct always executes at least once .

In actual practice find use goto statement about once every other year .
For those rare times that goto is necessary , its syntax is : goto label ; Page .

Labeling statement is done as .

Unlike , the : operators can be used inside of an expression .
The general form of : is :

NOTE It is better to define min as an inline function instead of as parameterized macro .
See Chapter , The Preprocessor , for details .

The Comma Operator .

About the only place the comma operator .

Overloading the operator is rarely done .
Normal member functions can easily be used for the same purpose but have the advantage of providing the user with function name .

Pointers to Members The operator : is used to point to member of class .
For example , in the following code we declare as to an integer in : class sample .

set so it points to the member : An ordinary pointer identifies single item .
member pointer identifies member but does not identify an individual variable .
All done is set to member of sample .

To use you need to tell it which class you want : sample ; typical sample .

The variable points to an integer member of sample .

Because been unable to actually use these features , the information presented here is bit sketchy .

However , as soon as the compiler makers catch up with the standard , such macros will cause problems .

Answers to Chapter Questions Answer : The compiler see our default because we misspelled " as " This was not flagged as an error because " is valid goto label .
why when we compile the program we get the warning : warning : defualt unused in function main which means we defined label for goto , but never used it .

Page Programming Adages In This .

General Design Declarations switch Statement Preprocessor Style Compiling The Ten Commandments for Programmers Final Note Answers to Chapter Questions Second thoughts are ever wiser General .

Comment , comment , comment .
Put lot of comments in your program .
They tell other programmers what you did .

Use the " principle It Simple ,
Clear and simple is better than complex and wonderful .

Never put an assignment inside conditional .
Never put an assignment inside any other statement .

Know the difference .

Practice is crucial people involved in almost every other profession that requires significant level of skill creativity , artists ,
Help others learn to program .
It makes good practice you to go over what you already know , or think you know .

Page Design .

If you come to choice relatively hack " or somewhat more involved but more flexible solution , always go the more flexible solution .
more likely to reuse it or learn from it .
also more likely to be thankful later on when requirements shift little your code is ready it .

Never trust any user input to be what you expect .
What would your program do at any given point if cat walked across the keyboard , several times .

Watch out conversions conditions .

Put variable declarations one per line comment them .

Make variable names long enough to be easily understood , but not so long that they are .

Never use default return declarations .
If function returns an integer , declare it as type int .

Always put default case in switch statement .

Every case in switch should end with break or fall through statement .

Always put parentheses , around each constant expression defined by directive : Size of the box in pixels .

When using the construct conditional compilation , put the statements near the top of the program comment them .

The use of inline functions is preferred over the use of parameterized macros .

single block of code enclosed in should not span more than couple of pages .
Split up any bigger blocks into several smaller , simpler procedures .

When your code starts to run into the right margin , about time to split the procedure into several smaller , simpler procedures .

Always define constructor , destructor , copy constructor class .
If using the defaults , these routines with comment such .

Always create Makefile so others will know how to compile your program .

When compiling , turn on all the warning flags .
You never know what the compiler might find .

The Ten Commandments Programmers By Phin Straite .
Thou shalt not rely on the compiler default methods construction , destruction , copy construction , or assignment any but the simplest of classes .
Thou shalt forget these four " methods any nontrivial class .

Thou shalt declare define thy destructor as virtual such that others may become heir to the fruits of your labors .

Thou shalt not violate the " rule by abusing the inheritance mechanism thine own twisted perversions .

Thou shalt not rely on any behavior of compiler , operating system , or hardware environment , lest thy code be forever caged within that dungeon .

Thou shalt not augment the interface of class at the lowest level without most prudent deliberation .
Such practices imprison thy clients unjustly into thy classes create unrest when code maintenance extension are required .

Thou shalt restrict thy friendship to truly worthy contemporaries .
Beware , thou art exposing thyself rudely as from trenchcoat .

Thou shalt not abuse thy implementation data by making it public or static except in the rarest of circumstances .
Thy data are thine own ; share it not with others .

Thou shalt not suffer dangling pointers or references to be harbored within thy objects .

These are nefarious and precarious agents of random and wanton destruction .

Thou shalt make use of available class libraries as conscientiously as possible .
Code reuse , not just thine own but that of thy clients as well , is the holy grail of OO .

Thou shalt forever forswear the use of the vile , rather favoring the flowing streams .
Cast off thy vile cloak and partake of the wondrous fruit of flexible and extensible .

Final Note Just when you think discovered all the things can do to again .
There are still more surprises in store .

Question : Why does Example think everything is two .

Answers to Chapter Questions Answer : The statement .
It is equivalent to : The programmer accidently reversed the not so it .
The statement should read : Page VI Appendixes Page ASCII Table Table .
ASCII Character Chart Dec .

Page Dec .

Page Ranges Tables and list the ranges of various variable types .

Accuracy Page Name Bits .

Page Operator Precedence Rules Practical Subset of the Operator Precedence Rules Table .
Practical Operator Precedence Rules Precedence Operator .

Put parentheses around everything else .

Standard Rules Table .
Standard Precedence Rules Precedence Operators .

Page Computing sine Using Power Series This program is designed to compute the sine function using power series .
very limited format is used to demonstrate some of the problems that can occur when using floating point .

The program computes each term in the power series and displays the result .
It continues computing terms until the last term is so small that it contribute to the final result .
For comparison purposes , the result of the library function sin is displayed as well as the computed sine .

The program is invoked by : sine value where value is an angle in radians .
For example , to compute we use the command : sine .

And to compute we use the command : sine .

Page Makefile Makefilefor UNIX Example .

It is not intended to be used to produce exact values for the sine function .

Very slow , but it works .

Glossary Symbol for the bitwise exclusive OR operator .

Inverts all bits .

Symbol for the logical NOT operator .

Symbol for the bitwise AND operator .

symbol used to precede variable name in .
Means the address of the named variable of .
Used to assign value to pointer variable .

Used to declare reference variable .

Symbol for the multiply operator .

Symbol used to precede pointer variable name that means get the value stored at the address pointed to by the pointer variable .

Page Symbol for the decrementation operator .

character NULL .

If defined , the code following it is included in the source .

If it is currently undefined , the code following is included in the macro expansion .

Page convention used in this book .
All pointer variables end with the extension .

AND Boolean operation that yields if either operand is and if both operands are .

ANSI Any version of that conforms to the specifications of the American National Standards Institute Committee .

ANSI Any version of that conforms to the specifications of the American National Standards Institute .
At the time of this writing , the standards exist only in draft form and there are still lot of details to be worked out .

In , arrays are stored in contiguous memory .

ASCII American Standard Code for Information Interchange .
code to represent characters .

base class class that is used as the base for derived class .

Page bit field group of contiguous bits taken together as unit .
This language feature allows the access of individual bits .

See also complement .

Borland version of the language for personal computers developed by Borland .
This is the version of product .

The technique of using combination of asterisks , vertical and horizontal rules , and other typographic characters to draw box around comment in order to set it off from the code .

computer programming language developed in at Bell Laboratories by Dennis Ritchie .
is considered to be to language .

Page language based on invented in by Bjarne Stroustrup .
First called with " it has evolved into its own language .

code Computer instructions written in the language .

compiler Software that translates source code into machine code .

syntax See syntax .

This program was the basis for the first compilers .
Currently not used for most compilers , as many native compilers now exist .

CGA Color graphics adapter .
common color graphics card for the IBM PC .

Page See storage class .

This is not defined operation in .

Comments are notes to himself and future programmers .
The text is ignored by the compiler .

logical complement is the same as an invert or NOT operation .

Page continue flow control statement that causes the next execution of loop to begin .

When the variable reaches predetermined value , the loop is terminated .

They are used in to delimit groups of elements to treat them as unit .

debugging The process of finding and removing errors from program .

See also derived class class built on top of another , baseass .

Page directive command the preprocessor opposed statement produce machine .

The number usually requires twice as much storage as type float .

See also linked list .

EGA Enhanced graphics adapter .
common graphics card for the IBM PC .

The compiler assigns an integer each member of the set .

EOF character defined in .

This is represented in by the backslash character ,

Page exponent underflow condition resulting from operation where the result is an exponent too large in negative value fit within the bit field allotted the exponent .

fast prototyping programming technique that consists of writing the smallest portion of specification that can be implemented that will still do something .

From the old package stdio .

From the old package stdio .

From the old package stdio .

From the old package stdio .

FILE macro definition in stdio that declares file variable .
From the old package stdio .

The system handles very large and very small numbers .

An error caused by or other illegal arithmetic operation .
It is somewhat misleading error because it is caused by integer as well as errors .

In personal computers , it is found in the math coprocessor .
More advanced processors such as the have units built in .

From the old package stdio .

From the old package stdio .

From the old package stdio .

From the old package stdio .

From the old package stdio .

This has been replaced by the delete operator See also malloc .

Free Software Foundation group of programmers who create and distribute software for free .
Among their products are the editor emacs and the compiler .
Their address is : Free .

From the old package stdio .

From the old package stdio .

generic pointer pointer that can point to any variable without restriction as to type of variable .
pointer to storage without regard to content .

Page Ghostscript interpreter that is freely available from the Free Software Foundation .

header file See include file .

manipulators Functions that when " or " cause no , but set various conversion flags or parameters .

IEEE standard IEEE standard , which standardizes format , precision , and certain values .

particular operation may yield different results when run on another system .

Inclusive OR See OR .

Page index value , variable , or expression that selects particular element of an array .

The idea is keep as much information as possible hidden inside the modules and make information public only if absolutely necessary .

left shift The operation of moving the bits in bit field left by specified amount and filling the vacated positions with zeros .

Each node consists of value and pointer the next item in the list .

Page logical AND Boolean operation that returns true if its two arguments are both true .
When used on integers , each bit is operated on separately .

When used on integers , each bit is operated on separately .

machine code Machine instructions in binary format that can be recognized directly by the machine without further translation .

The value of number without regard sign .

Modification of program because of changing conditions external the computer system .

Makefile The file that contains the commands for the utility make .

This function is now obsolete .
The operator new this function .

Page member An element of class or structure .

An operating system for IBM personal computers developed by Microsoft .

new operator to get new from the heap .

NOT Boolean operation that yields the logical inverse of the operand .
NOT yields and NOT yields .

This indicates that the pointer does not point to valid data .

design design methodology where the programmer bases his or her design on data objects and the connections between them .

Ones become zeros and zeros become ones .

Page OR Boolean operation that yields if either of the operands is or yields zero if both of the operands are .

packed structure technique whereby bit fields are only as large as needed , regardless of word boundaries .

Often means the arguments that are passed between caller and called procedure .

The insertion occurs during the expansion of the macro .

From Picture Element .

numeric value can be added to pointer .

numeric value can be subtracted from pointer .

One pointer can be subtracted from another pointer .

Page Portable compiler compiler written by Stephen Johnson making it relatively easy to adapt the compiler to different computer architectures .

From the old package stdio .

It does not return value of type .

The process of expressing the solution to problem in language that represents instructions for computer .

Page pseudocode coding technique where precise descriptions of procedures are written in language constructs without the bother of precise attention to the syntax rules of computer language .

The class containing pure virtual function cannot be used directly but must be the base for another class .

radix The positive integer by which the weight of the digit place is multiplied to obtain the weight of the next higher digit in the base of the numbering system .

similar option , exists for taking input from file instead of the keyboard .

Page return statement statement that signals the completion of function and causes control to return to the caller .

save file debugging tool where all the keystrokes typed by the user are saved in file for future use .
See also replay file .

In most cases an combination is used .
From the old package stdio .

Caused by bad pointer .

This is not defined operation in .

Used in to delimit single character .

From the old package stdio .

From the old package stdio .

Caused by big program or by infinite recursion .

Inside set of curly braces , it indicates permanent variable .

Outside set of curly braces , it indicates variable .
For class members it denotes variable or function that is instance independent .
See Table for complete list of uses .

From the old package stdio .

Page stdin Predefined input source .
From the old package stdio .

From the old package stdio .

Sunview graphics and windowing system available on SUN workstations .

temporary variable variable whose storage is allocated from the stack .
The variable is initialized each time the block in which it is defined is entered .
It exists only during the execution of that block .

This is not defined operation in .

Page text editor Software used to create or alter text files .

version of the language for personal computers developed by Borland .

unbuffered in which each read or write results in system call .

UNIX popular multiuser operating system first developed by Ken Thompson and Dennis Ritchie of the Bell Telephone Laboratories .

Modification of to provide improved performance or new .

value quantity assigned to constant .

The data represented by the variable name can , at different times during the execution of  assume different values .

Page version term used to identify particular edition of software .
customary practice is to include version number .
Whole numbers indicate major rewrites .
Fractions indicate minor rewrites or corrections of problems .

When used in casts , it indicates that given value is to be discarded .

This attribute is used for , shared memory applications , and other advanced programming .

while An iterative statement that repeats statement as long as given condition is true .

Window System graphics and windowing system , available from the Consortium , that is currently running on many computing systems .

counting system of counting where the first object is given the count zero rather than one .

Page Index operator , operator , operator , operator , operator , equal operator , with include files , for strings , operator , diagnostic tag , operator , operator , conversion , conversion , conversion , conversion , conversion , conversion , conversion , conversion , conversion , conversion , operator , operator , reference , operator , operator , class operator , overloading , parentheses with macro parameters , and simple operators , operator , operator , operator , + operator , + operator , operator , operator ,  operator , operator , operator , comment markers , operator , operator ,  with statements , and preprocessor directives , operator , operator , operator , operator , shortcut operator , than or equal operator , operator , for classes , operator , Page operator , operator , operator , arrow_operator operator , operator , arrow_operator operator , to operator , than or equal operator , operator , operator , operator , operator , shortcut operator , construct , operator , as escape character , in preprocessor directives , character , operator , OR operator , and structures , operator , to merge flags , operator , operator , operator , in class destructor names , abstract classes , stat , accuracy of arithmetic , float double datatypes , add function complex , adding complex numbers , element to linked list , numbers , addition operator , address of operator , addresses , variable , alignment problems and portability , for reference variables , operator , logical , operator , binary , operator , argc and argv arguments , arguments , arrays , index operator , infinite , module for , initializing , multidimensional , as parameters , and pointers , optimizing , of structures , ASCII characters , assembly language , operator , for classes , operator , statements , placement of , author , comments about , auto qualifier , auto variable class , automatic generation of member functions , variables , as escape character , in preprocessor directives , backspace character , bad member function , Page base classes , initializing , search order , binary files , with multiple structures , binary , binary operators , logical , + to merge flags , binary search , debugging , binary trees , nodes , recursion with , bit fields , bitmapped graphics , bits , operations on , muliplication shifting , setting , clearing , and testing , modifier , blocks , stack of , boldface in comments , Borland compiler , Makefile for , programming , branching statements , if statements , switch statements , break command , break statements , in switch statements , browsers , class , byte order and portability , bytes , pad , conversion , language , binary , and language , compiler , conversion routines , handling exceptions in , programming tools for , compiler Borland , Microsoft Visual , Turbo , UNIX CC .

Since that time he has studied practical ways of writing programs so that the risk of generating bug is reduced .
He has worked for Motorola and Celerity Computing , and is currently special consultant for Hewlett Packard , working in the research department of their division .

Colophon The animal on the cover of Practical Programming is an Eastern chipmunk , striped ground squirrel found mostly in eastern North America .
Eastern chipmunks have five dark and two light stripes on their backs , extending from head to rump , and two stripes on their long , bushy tails .
They are distinguished from other ground squirrels by the white stripes above and below their eyes .
The coloration of chipmunks throughout North America varies , but is quite uniform within regions .

Chipmunks often make their homes in sparse forests or farms , where they can build the entrances to their lodges in stone walls , broken trees , or thick underbrush .
The lodges consist of maze of tunnels leading to large nest .
Chipmunks spend most of the daylight hours outdoors , but head for their lodges before nightfall .
Although they are excellent climbers , chipmunks live primarily on the ground .

Chipmunks eat nuts , seeds , insects , and occasionally birds ' eggs .
Like all ground squirrels , they have large cheek pouches , sometimes extending as far back as their shoulders , in which they can store food .
They collect and store nuts and seeds through the summer and fall .
When the weather starts to get cool , all the chipmunks in region will suddenly disappear into their lodges where they begin hibernation .
On warm winter days one can often see chipmunk pawprints in the snow , as they will sometimes wake up and leave their lodges for brief periods when the temperature rises .

Mating season for Eastern chipmunks is to early April .
The gestation period is days , after which litter of three to six is born .
Baby chipmunks leave the lodge after one month , and are mature by July .

The chipmunk most likely got its name from the noise it makes , which sounds like loud " You can occasionally see chipmunk hanging upside down from tree branch " its call .

Page Edie Freedman designed the cover of this book , using engraving from the Dover Pictorial Archive .
The cover layout was produced with Quark XPress using the ITC Garamond font .
Whenever possible , our books use , durable and flexible binding .
If the page count exceeds limit , perfect binding is used .

The inside layout was designed by Edie Freedman , with modifications by Nancy Priest , and implemented in FrameMaker by Mike Sierra .
The text and heading fonts are ITC Garamond Light and Garamond Book .
The illustrations that appear in the book were created in Aldus Freehand by Chris Reilley and Michelle Willey .
This colophon was written by Clairemarie Fisher .
